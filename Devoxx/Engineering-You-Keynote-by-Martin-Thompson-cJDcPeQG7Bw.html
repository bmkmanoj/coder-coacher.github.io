<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>&quot;Engineering You&quot; - Keynote by Martin Thompson | Coder Coacher - Coaching Coders</title><meta content="&quot;Engineering You&quot; - Keynote by Martin Thompson - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>&quot;Engineering You&quot; - Keynote by Martin Thompson</b></h2><h5 class="post__date">2017-03-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/cJDcPeQG7Bw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay good morning everyone
I want to kind of open up here with our
question to begin with here is an
interesting statement oops this is not
working go back to the old-fashioned way
this question here a software system can
best be designed if testing is
interlaced with the design instead of
being used after the design who do we
think said that and when is this a
recent thing is this someone talking
about TDD sort of in the last sort of 10
20 years any idea so much dakki it
anyone shout out a deck here think this
was said 70s good any 60s yeah we got
some people here thinking the right way
this was 1968 by Alan Perlis can
interesting I want to go back and look
at a little bit of our history because
we forget a lot of her history and we
also think interestingly about do we do
computer science to be do engineering
what can we do for ourselves the people
know who Alan Perlis is people anyone
heard of the Turing award guess we'll
get a few people heard of that Alan is
the first recipient of the Turing award
way way back in 1966 in many ways he's
been known as the father of computer
science he done a lot of fundamental
work on compilers and the first ever
parallel programming so it's coming
really interesting history in our
subject and many of us don't understand
it we tend to go forward we tend to hack
software we tend to have a bit of fun
with it we can to build stuff that looks
a bit like this at times I love
collecting interesting pictures of
internet and so this example this is
Russia Russia doesn't have a monopoly on
this my own country they're supposed to
be fused without drill bit is so much
for safety I was down in Australia last
year
they're pretty good at it too so what do
we do when we hack everyday probably a
bit of this so can I enter something
good are we engineers are we software
people are we just hackers are we
whatever but it's kind of interesting
how we're looking at some of this like
they might just software we have knowing
things is getting scary that this is
talking about how much software there is
inside some of our latest cars like ten
times more than you get in f-22 Raptor
which is a the latest fighter we can get
like where we have more than ever was on
the space shuttle
in fact even Mercedes brag about this
they're talking about hi it's got 250
times more code in this than there was
in the original space shuttle hey this
is not good we drive around in these
things and it's kind of scary because we
know what software it can do like the
new Tesla is now up to 350 million lines
of code who thinks that's bug free I
find a terrifying working on any project
with more about 10,000 lines of code and
that's typical most people there's a lot
of studies that show that we really as
humans don't deal very well with code
there's more than about 10,000 lines we
just can't fit it in our heads we can
understand that we can't deal with it so
we're kind of working this out as we go
another way I look at it it's like how
many generations of programmers do we
have when you start thinking about it
look thing buddy how many second
generation programmers do we have or
even how many third generation
programmers all right I can't see in
this room someone asked people to put up
their hands but I've only met two third
generation programmers so far they were
really impressive individuals and
there's something that happens and never
be passed on from generation to
generation what we learned what kind of
very much in the early days of this but
kind of working it out as we go anybody
been involved in any of these standards
like iso 9001 twenty-seven hundred and
one capability maturity models I get
involved in a lot of this of
stuff in the 1990s I've been writing
software for a while my butt so we went
from having
the well-documented that's
basically what happened with this
we weren't bad about it we just had a
paper trail for it that's all we knew
who to blame we get into this blame
culture which is part of the problem as
well I think we need to get better at it
but in a sort of see if we're better way
the way I like to think about it is
we're kind of living in the era of
software alchemy and back into the 1602
moody in physics welcome he was a really
big thing like most people will have
heard of Isaac Newton but many people
don't realize this he was one of the
biggest alchemists in history he wanted
to turn led in the gold as much as
everyone else did because what kind of
work this out we're looking for the
silver bullet what are we doing in
software how do we get better I want to
explore the subject of engineering the
Adhan computer science degree by
background I spend a lot of time in
engineering department and I think what
we are doing now I should be engineering
there's a lot of debate is it a craft is
it a science is an engineering whatever
but let's explore the history of
engineering let's see if it fits
with us but see if we can learn anything
from it so the history of the term
originally laughs and we're talking
about cleverness or devising things this
is the sort of origin offered the first
example of find is back about 1300s from
French and it's did it was someone who
operates an engine we're talking about a
military machine catapults things like
that
this is where the word engineering comes
from an engineer from that sort of thing
later on we introduced the concept of a
civil engineer because a civil engineer
was someone who did engineering that
wasn't military because everything was
military for a long time it's one of the
sad things of history but we drive
forward technology through war more than
are there any other means there almost
is so let's turn to the source of truth
for everything Wikipedia let's see what
it says about engineering does it fit
with how we see the world well Engineers
wouldn't work within constraints I
programmed Java most s and C++ I feel
very constrained I wish I could have
more flexibility to do what I wanted but
let's look at what some of these
constraints are I think what available
resources do you have like
heard people talk about how to see some
people's code and people look like the
program like they're a god where time is
infinite sort of memories infinite CPUs
infinite sorry it's not we're
constrained we have to work within those
constraints and those constraints or
many forms not just physical but
imagination and technical this I think
is one of the biggest points of
engineering which i think is so
applicable to us is we need have
flexibility for future modifications and
additions the majority of time and by
the majority I mean pretty much all of
it we spend time modifying code even if
you're on a greenfield project the code
that you're writing today is probably
modifying the code that you wrote last
week so writing software that's easy to
modify easy to extend easy to deal with
it's very much key to doing a good job
and that is engineering at its core
particularly what's going to look at
other constraints and whereas we were
working and particularly I like this
concept of safety every other
engineering discipline cares about
safety and serviceability and dealing
with stuff like we need to think about
these things take what does CFD mean so
things like to memory management
concurrency all of these things have got
serious impacts for safety and we gotta
be able to deal with the CFD in a better
way and by understanding these
constraints we can see how we can work
what our limits are how we can move
forward so I'm starting to like this
concept of engineering as an idea I
think it does fit a lot with what we
want to do and maybe we should be
inspired a bit by other engineering
disciplines I
what did albert einstein have to say
about engineering since we're here in
switzerland is scientists investigate
what is already there but engineers
careered what has never been and that is
very much what we do we create this new
future like the things we're developing
and software how key software is to the
world is so much about creating the
future in many ways remember Allen Kerr
saying that the best way to predict the
future is actually to invent it we're
driving a lot of this forward so we're
software engineering fit into that
psyche so that was engineering in
general well the first ever reference to
software engineering that can be find is
back in this paper 1967
and the term software engineer was first
coined at this point and how we move
forward how we get better it was
popularized by this great woman this is
woman is Margaret Hamilton she led a lot
of the development on the Apollo
missions give us amazing things like
priority scheduling to the testing in
certain last sort of complete end-to-end
testing human-in-the-loop a lot of these
things all come from her hey we don't
realize the great work that's been done
in our history I happen to have worked
with some people from NASA and their
army and particularly had to focus on
safety and correctness and getting it
well a lot of this comes from her she
did some really really great work in
this area well the ball I want to talk
about for a second is in 1968 whenever
that comment was made by Alan J perlis
about how we should be doing testing
interlaced with the development came
apart came apart from this conference
that was held in Germany at this point
the idea was NATO got a bunch of their
best software people together to discuss
how do we get better at this this
software thing is getting really
important how can we do it better and
over three days the great thing about
this is it was minuted and it was all
captured and you can read it in this
document it's worth going back and
reading this it's it's a really really
interesting part of history but let's
pull out a few choice quotes from this I
think it's really good to review that
this the designs process should be an
iterative one flow chart until you think
you understand the problem write code
until you realize that you don't go back
redo the flowchart write some more code
and edit till you feel you've got the
correct solution this is iterative
development 1968 why did it take us so
long beating our heads against waterfall
when the best people in the world were
doing iterative work in the 60s it's
good we don't learn I think we're not
really winning the intelligent eat sort
of category at the moment look at this
so it's another one
reliability really is a design issue you
can't add it in and this is this is a
kind of an example off how many things
that we do that our quality of service
like security
performance reliability all we call the
quality attributes in architecture
design is you have to put them into the
requirements they have to be enough
front concern you can't add them on
later and then it was ever try to add
security to a system that it wasn't
thought about upfront it's a complete
nightmare I love their point at the end
like though if you don't do this you
might as well give up and can appoint
net some very interesting things here's
another great one the good systems that
are presently working were written by
small groups more than 20 programmers
working on a project is usually
disastrous has that changed fifty years
later I think we're still in the same
point or how do approach suffer well
let's begin with skelewu coding rather
than aiming a finish code the first 46
steps should be aimed at exploring so
interfaces sizes of critical modules
complexity adequacy of those modules
some critical items should be checked
out don't put off the hard stuff to the
end I'm going to come back to that one
again this is one that's that have been
around a lot like how many people have
met architects who don't code I think
this is a great example going back to
then is there a gig I know they're
interesting concept we could apply this
used in their force to fly you have to
maintain your wings by doing a number of
hours per month if you don't you don't
retain your wings like this and should
people who were senior still write a
number of lines of code per month
there's a lot of very interesting things
about that I've seen organizations that
have debated this and they've turned it
around and now everybody who works
within the technical part of a company
must write some code and it does really
improve things
I've seen this else were whenever Disney
was reshaped one of the things they did
is if you don't contribute to the
creative process you don't work there
anymore
and I changed it turned it around to
trying to put in too much bureaucracy
trying to do things with people who
don't understand the process is very
very difficult I think this is really
quite funny it's bit sad in some ways
but many of the people who design
software referred to the users
then them we have the them and us thing
this happens a lot most of the designers
of software it manufacturing think they
do it for their own benefit is what
they're pointing out here like so the
Doudna for themselves not for their
customer I've got a simple term for this
as I see so many projects which people
are basically doing technical
masturbation they're doing it for
themselves is self gratification it's
not for the customer it's not doing the
right thing and this is actually so more
much more prevalent than we think and we
need to be aware of these things and how
we deal with them right estimation is
another great example of best showed so
this was from building the first three
Fortran compilers this is a really
really capable team first go the header
that there are out by a factor of two as
they built the second generation this is
the same team working with refined
practices doing something that they
already knew how to do they were still
overrun the overrun by 36% on the second
go I mean on the third go they started
getting close to it so what it shows is
that as humans we are only good at doing
estimation for something we've
previously done unfortunately an awful
lot of software that we write we have
not done that thing before so choose
your house estimation is really really
difficult to fit into this so that's the
needle conference like I really
recommend you go off and read that paper
it's wonderful and full of gems like
that one of the other people who was at
that conference has also done some
interesting writing on this and he's
another Turing Award winner and that's
Dykstra
he also me at this point that how we
teach computer science has got some
serious issues I've read a lot of
Dykstra's work and I'm kind of mixed on
it I like some of what he's got to say
anything some of it's also a bit extreme
maybe I'm just too liberal with it and
then I don't respect his extreme stuff
but there's some very interesting points
in it they here's a grid paper he wrote
on the cruelty of really teaching
computer science in this paper but he
pulls out a couple of interesting
concepts one of them is this idea of
radical novelty and I think this is very
key so what we do with computing is so
different to most of the things
we do in history he talks about hi you
got our approach radical novelty because
it is so different you've got to have a
blank line you've got to be consciously
refusing to try and link it to anything
else like the morning the most powerful
techniques we have for teaching is sort
of metaphor analogy and storytelling we
want to relate it to something else
unfortunately things that have a radical
novelty to them they feel badly when you
compare them to other things because
they're so different and this is where
we fall down quite a lot he gives an
examples off if anybody has ever learned
quantum mechanics knows what they're
talking about so if you study physics
use quantum mechanics the radical
novelty is so different so if you go
back things like relativity quantum
mechanics or examples of that but go
forward things like the atomic bomb or
the contraceptive pill he pointed out
that these things are so radically
different and so novel that you actually
change the foundations of how people
approach things you can end up changing
religion you can change States you can
change governments all that stuff
because it is so different they don't
existing systems don't know how to deal
with it we are now seeing this globally
at the moment we're by our access to
information the internet how we're using
computing has created a new form of
radical novelty that we're wrestling as
a people to try and deal with and how we
work at art so how do we work with this
how do we deal with these things that
are just so radically novel and what are
the means our points to pull out Dykstra
said he there's a few things in it for
him one of them was that anything that's
a concept of this level as we got to be
able to decompose it we got to divide in
rule and we got to be able to do
decomposition on an unprecedented scale
so we're looking at if we're gonna be
grid engineers what are the skills we
need to focus on how do we get better
well we got to get better at decomposing
these complex problems if you're working
on a vehicle that's got 350 million
lines of code how do we decompose that
problem so we can even remotely
understand what's going on so that's one
thing to grapple with the other thing to
grapple with is the amplification of
changes never in human history have we
had the keys
by such a small change can have such a
big impact like you change a single bit
in code and you can cause the entire
thing to catastrophic we feel we don't
have examples of that elsewhere it's
such a different thing that we have to
deal with so if we look at these as
problems like how do we learn from this
how do we go forward well I find
fundamentally we're all a product of her
own experience so I studied computer
science at University but I also took a
few minors as electives and one of them
was behavioral psychology I think it's a
fascinating subject that people really
should understand and very applicable to
almost most things and what you learned
from a lot of that is there's a nature
and nurture but fundamentally we're a
product of her own experiences who we
are becomes like what we experience is
how we learn it forms it shapes who we
are so if we apply some without thinking
how can we get better so thinking about
how we get better I've worked with lots
of software companies and I find there's
one very uncomfortable truth that you
keep fine is we have lots of processes
lots of ways of working but in most
organizations I see usually the majority
of the work that makes the major change
is done by one or a very small number of
people often working outside of the
process they're not fitting in with that
what did they do that's different how do
we learn from them this was something
that we were wrestling with back in 68
it was talked about in that NATO
conference so what I want to is trying
to break down a little bit off sort of
what the some of these individuals do
what does some people do that you
observe that do things really well and
what do they focus on and let's focus on
the learning I want to focus on three
things they go what should we learn this
applicable in our industry where can we
learn that and how do we go about the
learning process itself so let's start
off with that what should we learn drink
of water first
so can interestingly I find algorithm
the data structures are fascinating
subject and if you've been following
Twitter over the last few days there's
an interesting meme going around about
that we don't really need to know so
much about algorithms and data
structures that's what the implication
is so de Geus said that the whole thing
of going into an interview and on a
whiteboard having to write a bubble sort
that's a really good example of how we
should badly interview people because
people don't naturally work in that
environment but I think there's an
there's a danger here and how people
take things too literally and too much
of a problem like so our algorithms and
data structures a good thing to learn or
not to learn well I'd kind of argue
there's two ways you can look at them
one is are you a writer or a designer a
creator of algorithms and data
structures are all you a consumer of
algorithms and data structures and are
you a good consumer so knowing what are
the available algorithms and data
structures that are out there I'm taking
the right ones in your day that they're
jobs that you're choosing the right way
to represent a relationship choosing the
right way to represent theatre it's very
different from knowing how to write one
it's like knowing about the different
types trees versus writing a new tree
from scratch if you're an engineer in
almost any discipline you know the
fundamentals so I find ask an engineer
that's working with buildings and in
structural engineering I know the
materials I can apply I know the
compression strength of concrete I know
the torsional strength of steel I know
how wood will behave over time doesn't
mean I go and make wood or an egg
concrete but knowing those things that
some people may choose to go off and do
the material science and make those
things that's all good as well some
people choose not everyone but if you're
gonna be an engineer and you need to
know how to consume these things and
I'll find that over 25 years of
professionally programming an even
longer of just writing software for fun
any work I've ever done understanding
algorithms and data structures is still
applicable stuff that I learned about
how maps and trees and sorts and all
sorts of things that I learned back in
the 1980s still apply and I can use them
sort of quite
regularly in my job the fact that I
learned to use WebLogic 4.3 back 17
years ago sorry that's just gone at the
back of my brain of no use anymore at
all so they do what is the useful things
that we need going forward all right I
unfortunately corrupted my brain with
the early days of EJ and EJ be home and
stuff like that still comes and haunts
me the abominations that we created back
then so what is the good stuff what's
the good stuff we need to learn and we
need to keep so okay no fat argue spend
some time studying algorithms and data
structures there's some great things to
learn become at least a good consumer of
them but I think what Mudd is much more
important which I don't see so much to
be about is design fundamentals now but
design fundamentals what I'm talking
about here is understanding coupling
cohesion separation the concerns single
responsibility principle these things
are so key to writing good software
that's maintainable not adoptable
flexible understandable so it decomposes
correctly you don't see people
practicing these skills on a daily basis
yet you should be like when you look at
an air P I what are the coupling
concerns of that API what is the how
should something be cohesive you start
looking at code you go yeah that's an
obvious tree in rack this dot this dot
this does this it's like doing law of
Demeter tell don't ask instead of all
this through things like knowing these
things knowing how to apply them becomes
really really critical so they just take
something like coupling who hears heard
of kinesins very few hands kinesins is
how we describe coupling in
object-oriented design it's quite a
large body of work it's really
interesting yet most people don't
fundamentally know these things they
probably know the latest thing about
spring boot or whatever and sorry in
three years time that will matter anyway
yet we don't learn the fundamentals so
if we will become engineers we need to
get much better and we need to get much
more precise about these sorts of things
like if I walk up to a chemist and I say
I would like to have I'd like you to
help me do a titration people will know
exactly what I mean if you're a chemist
if I walk up to someone and say let's
work on this code it needs to be
refactor
now that may seem like a simple thing
but you being me is that that statement
to some people will mean precisely what
it should mean is that refactoring is a
behavioral preserving change is that the
test should still just pass and you've
changed the code to be easier to work
with through to I like to use the term
refurbishment is where they'll kind of
change quite a bit of it and reshape it
and it will be different the behavior
isn't preserved it will change right
through the complete rewrite but people
will use the term refactoring and mean
all sorts of things along that scale
we're not very mature yet as an industry
dealing with this so I think thinking of
the fundamentals thing what do we do
every day when we start looking at code
also let's not get caught in a rut think
about different programming paradigms
like I spent the early parts of my
career writing a lot of procedural code
I started off in assembly then I
discovered say wow this is brilliant
making a function call without all that
overhead of setting it all up myself it
was so nice and then you discover things
like object orientation and that was
great for encapsulation and dealing with
polymorphism and different things it's
kind of cool I never did that for a
really long time and I noticed that I
was uncomfortable with it and I started
doing a lot of things and stealing ideas
from small talk and whatnot and then
after a while someone pointed out to me
as I see pretty much writing functional
code but it's kind of interesting to go
study some of these things and so you go
off and you kind of formally learn some
of it and it really helps like learn
other paradigms really helps you think
differently about a problem so some of
the people I have worked with from NASA
one of the things that they've taught me
is approached your testing with a
different mindset and a different
paradigm than what you're developing the
code with so for example if you're gonna
develop code use an object orientation
how about approach to tasks for formal
specification you have to think
differently it's not the formal
specification is the best way to do it
it's a different way right your tests
and object oriented where on task
functional code you can do all sorts of
really interesting things to think about
a problem from different perspectives it
uses different parts of your brain let
you see the model in interesting ways
and that way we get a deeper
understanding of things so I don't be
shy to go and learn
Dolf right I find the number of people
who have put set theory at arm's length
for far too long absolutely terrifying
so within object-oriented we've been
using ORM switch I'll sort of kneel my
flag up here is then I think it's an
abomination it's like there's a database
it's a perfectly good thing learn how it
works and use it correctly and don't get
out through a noir and which is just an
abomination in the way it's like
entering a three-legged race with two
different species trying to run together
like get them working together doing the
right things that they know how to do
and the stike stress says we got to get
back to this decomposition and
abstraction and think about what it
really means but think about what it
truly means for decomposition
abstraction it's a decomposed by data
decomposed by function decomposed by a
behavior there's lots of different ways
we start looking at that to start
dealing with it
I look at what abstraction truly means
like whenever we do introduce types are
they really making a concept more
precise more distilled rather than just
putting it in and building a cathedral
if there's one subject I wish I had
studied more at school is mathematics
and I keep finding it is an incredibly
useful subject and I think that the
problem that we see is that most people
just don't deal with it enough to learn
enough from it and it's kind of
fundamental like if you're doing
anything with sad theory it's not a
pretty calculus like so learning that
some of these things are how do we deal
with it we understand understanding and
it doesn't mean you have to go like to
really agree adapt so that just the
fundamentals so for example as we start
to go more and more parallel
we're gonna hit the problem off we can't
go faster we can't scale up in the same
way so you've got a look on tasks and
instructions and work out how do you
make them commutative how do we make
them associative like these are basic
concepts of mathematics but allows us to
swap orders that allows us to swap
groupings that lexis get more progress
in a parallel sense if you start running
off into the java world using Java
streams and you don't understand some of
the fundamentals of that you will not
keep good throughput it will not scale
up very well and so you get hit with
that so it's really worthwhile but kind
of woman the key subject I think is
community
patience we're moving to a very
distributed and very concurrent world so
we need to understand good protocols of
interaction so the protocols we have
between our own micro services between
our components even we have within a
system how do they interact like does
the design fundamentals get respected
here of coupling cohesion separation of
concerns all of those sort of good
things and the protocols themselves
start to really matter so an example is
like what is a protocol well it's not a
Google protocol buffers sorry that is
completely missed named and this is
another problem we have of our industry
a protocol is not Jesus in it is not
something like Google protocol buffers
they are code acts there are laughs
encoding and decoding data a protocol is
a series of messages that allows you
have a treatment and etiquette between
two different components so like a
protocol for dealing with a file as a
simple example is you must open a file
followed by one or more read and write
operations followed by a closed
operation that's the protocol with which
you deal with something it starts to
become important and this is not just
that a technical level is also really
important at a human level like we have
to work with customers we've got to
understand their demands we got to deal
with all this so communication is so key
so if there's one skill to highlight
here is communications is probably the
morning the major things you need to
refine and work on every day like be it
your interpersonal communication but
also the communication your software it
reflects things like if you've heard of
Conway's laws like all software takes on
the structure of the organization that
built it so if you've got two different
compiler teams you'll get a to pass
compiler not sort of stuff if you've got
a team that's good at communicating and
having good protocols between them
you'll see it reflected in the software
as well so you can almost reverse it in
different ways like we're kind of in
this interesting world where everyone
thinks we're gonna build monoliths and
monoliths are other really so if a
monolith this yet so if you can't build
a good monolith so you're gonna build a
whole pile of micro-services so what
happens to when you increase the
surface area of it it smells a lot more
so just running to microservices is not
the answer
microservices a grit but drive them from
design fundamentals like you're choosing
to do it because it's matching some
design fundamentals that you want to
achieve so copy aware of that so let's
move on from where can we learn well
fundamentally we learn by practice kids
learn by play as we turn into adults why
not keep playing let's let's enjoy what
we do and practice but practice the
right things if you're in any sort of
discipline where safety is important you
drill you drill so that under pressure
you do the right sort of things so every
day we should be thinking about are our
practices enforcing good behavior or the
enforcing bad behavior like are you
being sloppy you ignoring the tests are
you just letting a red build continue
for a long time what are the practices
that we approach the stuff starts to
become really important but so start
consciously practice how we get better
how do we get these things going like so
how do we focus on the design
fundamentals and do it well we have to
work in teams and this is a good thing
and that's another grit where that
people learn as humans or grit mimics we
learned from other people so one of the
best things you can do is work in teams
with other people you're going to learn
from people you enjoy working from and
so from a career perspective we should
see guide great places to work one of
the great things we have in this
industry is we have way more work than
we have people who are able to do it so
if you're in a dysfunctional environment
or you're not learning you're not
getting anything from it we can exercise
with their own two feet and go somewhere
that does we should work in environments
where we enjoy it we get something out
of it or we try to change it and do it
for the better turn to do it in some
sort of a think about where you're
actively going work like if you wanted
to plan your career choose where you're
going to work is one of the best things
you can do for that you'll start going
the right way and there's one kind of
interesting strong point around this is
I I've managed the number teams have
been CTO a couple of times in a few
firms and one painful lesson I have
learned very very quickly is that don't
work with us holes
it's a really simple thing get them out
of your team because they're just
downloading and dangerous and they will
be shy will be bit free of the deal with
them it's much easier to deal with a
problem early and deal with it it's like
do people should communicate they could
go back to that early sort of point is
we got to work and Conway's law shows us
that software will take on the
organization's this you have built it if
you've got a difficult person that team
you even have a difficult piece of
software somewhere a lot of miserable
people dealing with it so either help
them change or sort of make them make
the team change and so that you you take
things forward by you change the team or
you change the team now if you're
running the team there's something you
can do but if you're not in the team if
you're not running the team you can help
influence it from below or you can
ultimately go somewhere else we can't
always get access to all of the people
we want to so how do we learn in
otherwise well one of the wonderful
things we have is lots of great research
papers out there they can tell us so
much and help us learn from it so
there's been so much said about this I'm
not gonna really out do it anymore other
than sort of encourage the point it's
just great to go read stuff whenever you
go into a new area and you don't know it
and you can't get information feel free
to go read papers on it but also read
code I think the open source movement is
one of the greatest things we've done
for our industry because if you're in
almost any other discipline one of the
best ways to learn is learn from the
work of other people like Stephen King
was once to ask he's a famous writer and
how do you get better at writing books
and his answer was really simple as read
other books read other good work by
having good software out there and that
we can read we can learn from it and
that's what we should do regularly we
should be radiant code and reading as
much as we can with your colleagues code
do code reviews do feedback do them in a
really healthy positive we're code
review shouldn't be about sort of
anything negative they're actually a
great learning experience for everybody
alright and treat them that way and sort
of think about that we should also think
about if we're gonna learn something and
you don't do something on a project the
hard stuff do it up front there's a
number of really good reasons for that
is by doing something upfront
is you'll start to refine your estimates
much quicker but you'll also get much
more time to go through that learning
process and getting it right when we
start something new don't do all the
easy stuff that you already know down so
you can easy do that at the end and you
can do that under pressure when you're
rushing you want to do the hard stuff
upfront when you're fresh so you get the
most time to do it and you get the
ability for that to bake in and do it
well and get the time to do the second
point all right point that I'm going to
talk about it later but one of the other
things we can do is we can also learn
from online so this whole nonsense about
we get someone into a room and we get
them to write on a whiteboard as part of
an interview like in their daily work we
have access to in their net we have
ideas we have all sorts agree of things
we read stuff online like if I go back
to the early 90s and remember interviews
we're always asking people to recall
stuff like can you remember how to do
such-and-such with the advent of the
Internet those people are completely
redundant the ability to recall doesn't
matter anymore
what's important is can you read on
their information and tell whether it's
good tell whether it's applicable to
what we want to have that's the really
really important thing that's right
there so whenever you go on to Stack
Overflow and you're going to cut and
paste the important thing is how you
couldn't pace them the right thing how
do you know that it's good how do you
know that's applicable so let's sort of
explore that topic a little bit but
first up like if we're going to learn
one of the most important things we need
to be able to learn is time we need the
time to do that and to get time what we
have to do is we've got to automate it
as much as we can because the hard stuff
we want the time to see if you do only
waste in your daily time on the boring
repetitive stuff it's also error-prone
it's wrong it's got the us driving the
wrong way we should be investing in CI
like this should not be a company today
that does not have CI I know there's
many that do but it's just wrong if
we're going to become engineers I'm
gonna do it right we gotta have this all
automated it has to work really well
when we start learning the most
important thing to do is focus on the
feedback cycles so when you don't know
something how do you get from not
knowing to knowing more in
shortest possible path how do we get
those feedback cycles short that's
actually the fundamental of agile agile
is all about reducing the cycle time and
the feedback cycles on stuff so we get
to find out much sooner rather than
putting stuff off tube and focus on that
thing as we play as we deal with stuff
we've got experiment we if you don't
know something be very comfortable
saying you don't know and create an
experiment we move forward but as we do
experiments we shouldn't measure we've
got a measure and do things in the right
sort of way and get the right sorts of
answers but whenever you do measure one
of the very important things is that we
follow good scientific honesty it's so
easy for us to fit data to a certain
belief system we need to try and divorce
ourselves from that there's some great
stories from Richard fireman's work
particularly on the space shuttle
Challenger whenever that happened it's
of Rogers report that came out it's
another great thing to go read if you
ever get the chance in the early days
the group that was put together headed
by Rogers to find out what happened with
the Space Shuttle had Richard finally
known Adele said Neil Armstrong had a
bunch of other quite well-known people
on it and to begin with Rogers wrote an
interesting note saying that Finan is a
pain in the ass he just questions
everything he doesn't less except
anything he is always going against a
lot of the rest of the team but after a
while what Rogers come to learn is he
wasn't being awkward he just realized
that a lot of other people were just
trying to fit announcer I'm trying to do
right by the end of it his report on
fireman was he's got the greatest
scientific honesty of anyone he ever met
and that's a quite a rare thing so even
if we do measure experiment do all the
right sort of things is we got to
analyze the data but don't fool
ourselves like always ask Oh am I
actually feeling myself I'm trying to
fit the data to the answer be
comfortable with it's not clear so to go
and do it again and probably the most
important point around how we change our
behavior in a day to day basis is this
concept of revisit and refine so we've
got an interesting thing in how our
brain works we work in short-term memory
we have long
her memory so if you go to do something
you're doing it all within your
short-term memory to begin with so take
a simple example is you write an email
you write that email and you go and read
the readme mail back again straight away
you don't actually read the words of the
email you read what you think you meant
to write not what you've actually
written if you leave that and go away
and come back again so maybe another
dare do another task or something come
back because that's not gone from your
short-term memories you have to truly
reread again and by truly rereading is
you get to see what you've actually done
not what you've thought you've done this
applies equally with code applies with
anything we do that's a creative
endeavor so when we plan and do our work
on a day to day basis we need to be
thinking about how do we plan the time
so you do something you leave it you'd
go do something else and you go back and
you read it again and you visit you
refine
I keep finding that I can really improve
the quality of code by following that as
a simple pattern you'll also have
learned more things by doing other stuff
later to go back and revisit so you
think about the waterfall approach it's
actually designed to do the worst
possible job you can the iterative stuff
we need to take it much much further not
just that we do it lots of many
waterfalls is but we actually go back
and revisit and refine and do proper
refactoring and also be honest with
ourselves at times because that's not
good enough how do I make it better how
can we go forward
what can I pull out an interesting point
here so having worked with some of the
NASA folks I love one of the questions
that one of the guys Todd montgomery
I've worked with a lot always asked is
when you do something goes what can go
wrong it's kind of a bit of a problem
that they have to fierce and the reality
of it but it's actually really important
for us like I've seen working on
distributed systems where so many people
just assume stuff always works you get
the work with some of these people as
they don't they assume it's always going
to fail it's a completely different
mindset and their code appropriately
their code with safety in mind to do
that here's another grit report that's
worth reading it looks into production
outages of
code and beast upon the production a
disease that were investigated didn't
some root cause analysis to see what
some of the cases were there's some
really interesting stuff around high
seventy odd percent of them could easily
been caught by unit tests but one of the
most important things I think that
really stands out is twenty five percent
of production outages that they studied
could have been dealt with if the error
was not ignored real errors were raised
and they were just ignored in many of
the cases there was an exception
blocking code with it to do call me and
then it's saying must fix this before
production that is real engineering when
you don't do those sorts of things
that's when you've been very how much
your versus doing the true engineering
so it's kind of burned out in mind that
most outages after human error are
actually how we handle errors most
people just didn't know with them so
kind of getting missed the end I but
fundamentally we've got this hugely
complex problem we have a war on
complexity we need a fight if we're
gonna have cars with three hundred and
fifty million lines of code or more and
then we just can't reason with that I
think we need to think much more along
these lines is think about lines of code
spent like you don't measure an aircraft
bad by the way it you measured by what
it's capable off and you want to keep
the weight down to an absolute minimum
we got to think about how do we get
lines of code Dyne all right one of my
favorite measures in any given team that
I'll motivate people on is lines of code
delete it delete the dad code delete
code all the time see if you can add
features and remove code so kind of
quickly in closing my whoops it's gonna
don't feel bad we're living in this year
of sr4 alchemy we're like the physics
off their 1600s we gotta work this art
we've got to get better at it we're
gonna make lots on the stacks but
hopefully we're going to get better at
it probably quicker than the physicists
did because the world is so dependent on
software it's in everything we do now so
it's up to us to try and make it better
and we've got to become more
professional gotta become the engineers
that's a really cool thing to do like we
work in one of the best industries there
is out there
so don't create the du epic
and I'm not thank you very much
I don't know if we have time for
questions are we done
couple minutes do we have any questions
are we good for breakfast yeah I can't
see a thing here
very good question I have a personal
theory I don't know how correct it is I
think we have a large number of
organizations who have put their
commercial interests ahead of the
interests of developing good software I
think the perfect example of that was
the move to application containers like
what we've seen with like mts from
Microsoft will be seen with EJB and
stuff from a lot of that consortium
because a lot of the vendors wanted to
sell a platform and they drove a lot of
thought sort of stuff it's like you
can't sell very easily good design
fundamentals that's a skill that we need
to work on I think that's a craft a
craft that we need to do and the problem
is our industry is so driven by large
marketing budgets particularly through
this sort of 90s and 2000 onwards that
it was driven by those corporations who
wanted to have their commercial
interests it would pretend they were
doing things sort of to help making good
Sulphur but in reality they didn't I
love one of the comments from the guy he
was key to are not WebLogic WebSphere
eventually admitted that it was all
wrong and he shouldn't have gone that
way
but it's gonna that's what the
industry's pushed because that's how
they can make money if we could work out
how to make money from good software
done well it'd be very very different
maybe we got to see that a lot of these
things are much more long
term with Kenneth in a world where
everything's incredibly short term we
want instant gratification so if there's
not direct cause in a fact I I I'm a big
fan of science and if you look at the UK
in the UK any investment we have done in
science has been the greatest long-term
investment ever for the country yet we
don't do enough of it because it doesn't
returns in political cycle the same as
like when youíve got corporations who
but they're looking at their next
quarter the next annual return unless
they get a good result to run that we
get things just ignored or thrown away
and that's very much a thing of like the
bonus driven culture and the corporate
world that drives that so that's my
theory on what it is who knows what the
actual truth is okay thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>