<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Democratizing Serverless: The New Open Source Fn Platform by Travis Reeder and Reed Allman | Coder Coacher - Coaching Coders</title><meta content="Democratizing Serverless: The New Open Source Fn Platform by Travis Reeder and Reed Allman - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Democratizing Serverless: The New Open Source Fn Platform by Travis Reeder and Reed Allman</b></h2><h5 class="post__date">2017-11-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/RgtglVpoP7c" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everyone welcome to our talk we're
gonna talk about democratizing server
lists with open source cloud agnostic
service platform my name is Travis
reader I'm an architect at Oracle I'm
Reed almond I do not have a single word
title like Travis I'm a normal software
engineer at Oracle alright so if you
haven't seen one of the ten other
service talks this thing I'll give you a
quick brief overview of service and then
we'll dive right into some code demos
and get into the details so it's been a
trend over you know past five to ten
years to break down monolith
applications into smaller bite-sized
pieces and the first round of that was
micro services which we're all pretty
aware of I'm sure and that's a you know
taking a piece of your monolith and
creating separate api's for the monolith
so they're easily easier to manage and
scale and those kinds of things
a function is a step further where every
end point of the micro service could be
a separate program essentially a
separate piece of code that can you can
manage deploy and scale independently a
group of functions could make a micro
service otherwise known as functions as
a service you might have heard the term
foz again it's small bits of code that
do one thing well a common use case that
you'll see in demos is image processing
responding to events from mobile apps or
events off kafka queues those kinds of
things the good part about it though is
there's no plumbing code you don't have
to think about building your entire web
server you just have to think about the
little bit of code and what exactly it's
going to do and nothing else of the
related services in the application so
that makes your code easy to understand
and maintain the other thing is the cost
savings the code only runs when it's
executing so you don't have these apps
that need to run 24/7 to respond to
events they can respond on demand and
again each function
scales independently if you have one
endpoint that gets most of your traffic
that one endpoint can scale across a
cluster of notes independently of all of
the other endpoints so FN is kind of our
take on the whole server list thing and
you've seen this entire week really
there's been multiple projects now
coming out that are you know serverless
or fast however they want to brand
themselves this week we saw at least
Google and lamda and two of the
presentations and so for us when we were
kind of thinking about this problem what
we really wanted was something that was
just containers and we didn't want
something that was just language
specific because it's very limiting and
it's really hard
we know kind of from experience that you
know adding individual support for each
language and maintaining that over time
is really a huge task so it's better if
we have this container abstraction and
we put everything in there and that's
our fundamental unit so we do that and
we just automatically support every
programming language out of the box we
conveniently also make it so that we can
run really in any cloud we're not tied
into any you know Amazon or Google or
Microsoft specific services such as you
know s3 or something right so it's open
we can plug into anything we can run any
programming language and we wanted to be
really easy for developers and we want
it to be really easy for operators and
those those are kind of our core
principles when thinking about it so in
general you can just basically save a
lot of money using one of these things
and and we want to make it so that
people can run this kind of stuff on
premise and we also want to make a great
experience for developers and so that
that's kind of how we're different
really and and the main thing is there's
no walk in and there's no walk in for
developers into specific languages and
there's no walk in for operators to
specific clouds so that's kind of two
key things that we have and we just yeah
I think I went over all this stuff we
put the same thing on two slides and
it's open source not proprietary so
patchy to license so I'm gonna give you
a quick demo
of do some live coding here I'll create
a couple functions in a couple of
different languages so you can kind of
see how easy it is to write your
functions test them locally deploy them
so let's just dive right in so I'm going
to do it
F and I know this is when you first want
to create a function I'm gonna do a go
on first this thing like risks are
really cocked up anyways so so this is
what that code looks like so just
generated some coach the FN tool by the
ways I CLI tool you can go to our github
repo install it quickly and get this
running so this is a very simple hello
world functioning go I don't know if
you're familiar with go but the this is
all basically just reading standard in
all of the function gets is a standard
and standard out and standard error at
the base so this is reading standard and
parsing parsing the JSON into an object
and then writing to standard out and
that's the output that the user will get
back to the browser so if I do an FN run
on this this is local testing so I can
do an FN run you'll see it builds
container and runs the function I can do
things like pipe into that function too
so I'm gonna pipe in some JavaScript
here is this big enough you'll see that
okay good so I'm gonna pipe in a little
JSON object into F and run and this is
essentially exactly what it'll get when
it's running on the server - if somebody
posted a JSON request to the FN server
your function will get that JSON just
like this piping mechanism it also
generated a test file well first I'll go
the func that Yama file kind of defines
properties of your function this one the
runtime is go the entry point is dot
slash funk you can set other things like
the memory it requires the timeout you
can set if it needs to run longer or the
default I believe is 30 seconds you can
set different formats the default is
what I just showed you just a straight
standard in whatever comes in but we
also have a cup
other formats too for better for
performance which we'll get into a bit
later yeah so there's that and then it
also created this test file and you'll
see this is also non language specific
so this actually will test the container
so whatever is in the container as long
as it takes the input I'm going to give
it these tests produces the output I
expect then that's fine and you can
imagine down the road you want to change
language on one of these things you
could as long as the test keep passing
you're pretty safe to change the
language or do something inside the
inside your function so if I do FN test
for instance you'll see test one pass
test to past so you can have these tests
for each of your functions to guarantee
the contract basically I have an FN
server running locally on my laptop so I
will deploy this function to I'm gonna
just do local so it doesn't go out to a
docker registry or anything like that so
it basically builds my functions updates
the routes in the application or on the
FN server so now if I do if I go on my
browser and go my app slash go func
that's what I just deployed and then we
have some CLI goodies for this too I can
do I can test it from the CLI I can pipe
data in to the remote server like if I
do this and do FN call this will be
actually piping data to the remote API
or not so you can see it says hello dev
ox now if I if I pass in the name and
the date on otherwise it's just hello
world so that's for local testing you
saw deploy it was pretty pretty simple
and that has actually run it on server
and in the end I'm going to show you a
better live demo but that's the base I'm
sorry
let's go into a Java function
so we have a really nice job of fdk that
a lot of we have obviously have a lot of
Java people on our team since we're
Oracle's so they've made a really nice
API so in Java you can just define these
functions this one expects a string
input you can actually change these into
different types of inputs and it'll
coerce them into objects or different
types of things that you want to pass in
so if I go over on this one you can see
how simple this is all right like this
will be a endpoint it's only a few lines
of code and in Java that's pretty
impressive so if I do a fan run on this
you see the hello world if I pipe data
in you'll see it changed - hello dev ox
so that's the Java function I'll show
you a different one oh it also our
generator will also generate you know
everything it needs the palm file your
func thought llamo and also J unit test
so you can test your functions through J
unit as well and you'll see this right
here
the second version this is a POJO
function so you'll see this one the
difference here how it gets kicked off
in the funk dot llamo in this one you'll
see the entry point is the pooja
function in the greet method and you'll
see in here we call this greet method we
create this new greeting object which is
who says the name and a salutation now
if I run this one it'll output that
object in JSON
yeah so it handles it very nicely makes
it really easy to write these web
services these micro services and same
thing all the functions are deployed the
same I just do FN deploy on that and
it'll be run Ian laughs actually I'll
show you that why not
and so that should be and just see the
same output so that's the quick of
experience of developing these functions
and how easy it can be to do this you'll
notice there's no web server code or
dealing with any of those things so
digging in a little bit further as you
saw it's just a small bit of code for
each of your endpoints there's also
asynchronous I didn't get into that but
you can set your function to be an
asynchronous endpoint and when a request
comes in for that say a web book or some
event from somewhere it'll go into a
queue and that's good for batch
processing and or things that don't need
instant responses things that might take
longer so those will go into a queue and
they'll queue up and they'll run when
there's capacity the synchronous
functions get priority though so we can
respond real quick but when there's
capacity these synchronous functions run
again it's wrapped into a container so
and all you need is docker for these I
don't even need Java installed I don't
need go installed I don't need node
installed they just need a docker
installed and when you're using the F
and run commands it runs all that stuff
inside these different containers with
different languages in them input
standard in output standard out logs you
just print a standard error and you can
grab the logs from the API yeah
developer kits the go on I wasn't using
a developer kit the Java ones I just
showed you was using the Java fdk so it
deals with parsing data we have the
concept of hot functions which is by
default in Java it's the hot function
basically keeps the container running if
there's requests coming in if it sits
idle first
thirty seconds it'll kill the container
and that makes it so you can have really
fast performance you get rid of the
docker startup time which is about 300
milliseconds the Java startup time
making database connections that kind of
thing and all of our FTAs are pretty
similar you define a handler function if
you're used to lambda or any of the
other function providers very similar
you write a handler function it gives
you the input and you respond with the
output or the output is your response
rather you can check the call status you
can see if any calls have failed through
the API you can grab the logs we output
metrics and you can throw those to
Prometheus you can log to syslog as well
and there's a user interface that we
have to and that's also a docker run
command you can fire this up and point
it at any FN server or FN load balancer
and start seeing statistics or manage
your applications there in functions now
Reed's gonna take over for the running
the service yeah so for operators we
thought you know it was really important
for everything to be very simple on the
operators side as well just like the
developer experience that you saw so for
us this is the you know classic
whiteboard diagram that you have to do a
thousand times with various people and
even though you've made this document
one time you guys probably don't know
how it goes so we have client requests
coming in from the top and they go to
basically our special FN load balancer
which we'll get into the details in a
minute and then they go to the FN server
and the FN server is where we're
executing jobs it's also you know it's
doing a lot of the credit stuff so at
the bottom layer we have the data base
which is pluggable we have a message
queue which is pluggable we have an
object store which is pluggable we
contain a registry which is blog Abel so
to get into kind of the details I you
know so the FN server is really the core
application that we have so this is our
you know stateless server and you just
scale the FN servers basically all of
the bottom layer it just scales
completely independent of FN so FN is
the one that's actually executing the
job
so as you know more jobs come in you
want more service to scale up and scale
down as an operator so that you're not
paying for them just just like the
functions so it's going to handle the
crud operations which are relatively
cheap it's going to handle the async
stuff so it's checking the message queue
seeing if there's jobs seeing if it has
capacity to run those jobs and and doing
that and we wrote it and go so that it's
really easy to extend and because we're
an open source project it was really
important that we have just certain
surface areas that we offer to
developers when they want to hook in
with you know say their say somebody
wants to do you know OpenStack
authentication right so you can just
basically go hook in with the go client
API for the OpenStack all stuff sticking
on the server compile the server with
that make an image out of that deploy
that image and and that's kind of how
that goes
so the FNL be is kind of a crucial part
of our deployment strategy because we
realized pretty quickly that if we just
throw a bunch of effing servers behind a
proxy or behind nginx you know things
weren't going to work so well we were
going to end up with a bajillion images
across all the effin servers and you you
know you're you may not have a hot
container on any one server at any time
so we really needed this specific
routing policy so that we can keep track
of you know where hot containers are
running and also kind of how loaded that
specific note is for that specific
function so that we can start scaling
out so what we did was we took go and we
just used most of their HTTP goodness
they have a very robust HTTP library we
get HTTP as well and we get most of the
sugar there and we have a very thin
routing layer and we also allow the FN
server to give us some back pressure so
it tells us on each request you know
this is how long it took for me to start
this function this particular function
so we're scaling with functions
independent scaling units not just nodes
and so we get this piece of information
and and we apply it and we can scale
based on try
so you know you would say something like
well you know I'm running ten containers
on one node right and my wait times are
starting to be one second in two seconds
so then we're gonna start bleeding over
it you know Tim person air traffic to
the next node right and so this was
something that would have been
challenging to do if we were trying to
hook into another load balancer per se
and since the load balancer has this
kind of holistic view of the cluster
topology we can say well you know we
know how many effin servers there are we
know that this server is not running
anything you know we can go ahead and
get rid of that server and start saving
some money as far as the supporting
services go I mean kind of like it
covered the main thing is that you know
these things are pluggable so right now
you know we're selfishly implementing
you know the pieces that we're actually
going to use as a service but we've left
it really easy to hook in for other you
know other people that actually get to
use Postgres that kind of thing so we
have that and you know the registry
piece docker has a very good abstraction
there so it's it's basically just in the
URL and yeah it's really easy to use
your own private registry and in your
own Club as far as metros in monitoring
go this is always important for
operators you know you need logs you
need metrics so you can kind of keep a
handle on this stuff and our answer in
the code is you know well we're using
the open tracing API now which has been
really popular in the java community as
well as the NGO community and so having
cross language support is going to be
interesting for that also for developers
are going to be able to hook into the
open tracing API stuff which should be
pretty cool to see pipelines and such we
have Prometheus support on the backend
for open tracing right now so you know
in our code it's all open tracing and
then you basically plug in whatever
back-end you want to yank stats out of
that and then logging we just have
syslog so if you want to use you know
remote syslog it's it's pretty easy to
get a handle on
alright so that was that's the basics of
developing and operating there's other
features like the concept of an
application where you can group together
functions deploying them all as a set so
you could have Micro Service made up of
10 10 different functions or 20 or
whatever do an FN deploy and deploy the
entire set together so if you checked
out a repo and you wanted to deploy it
to a server would just be a single
command it's also some kubernetes
support as well so if there's helm
charts where you can deploy to a
kubernetes cluster and have kubernetes
manage all your effin servers and your
FN load balancers as well for the java
folks in the crowd which i know most of
you are there is another tool that's a
little bit more advanced but you can use
the completable futures api and if you
go to github /fm project slash flow you
can tie together a bunch of different
functions using you know what you'd
expect in java but it'll distribute
these functions run them on different
servers and you know wait for all the
results to come in and till your futures
are done you can then you can deal with
all the results as they come in a kind
of thing so here's an example this is on
the repos well you can see create a flow
part of its going to be an info function
when that's done you have this then
compose will go on to the next step and
so on and so forth so you can check that
out that's a pretty cool feature I won't
go into details because it's tough as
you can see it's a little bit more
involved there's also a nice flow UI
where you can watch all these steps in
process and see how long they're taking
debug on debug each one of them as you
go as well well we went through pretty
quick
yes so I guess for the finale here we
threw this up on a live server if you
guys want to pull out your phones and go
to this project or this URL here I can
show you go look at the URL I won't tell
you what's on it and then I'll do a
deploy to the live server and you can
see how fast and easy it is to deploy to
a server in the cloud devoxx FN project
I Oh / r / EO / dog in a typical
production scenario you can replace if
you had your own custom domain names you
can replace you'll see the app name is
in the path for these because we have a
single domain name but if you have a
custom domain it can replace the /r on
the / /eo which is the app name tell me
when you've all got that and second
switch screens or ask yell if you if you
don't see it alright so I'll show you
the code for this again it's another
simple function this one is actually
just outputting HTML this little blob
right here but I'm going to change one
thing redeploy it changing the the
server I'm talking to you right there
and then I'll deploy
so when you deploy to non-local it's
pushing the image to a registry
hopefully the Wi-Fi is work and it
wasn't work in about 20 minutes ago
good made it how many people use docker
here okay good so you understand what's
going on all right now I do a refresh
and you should see the change and you'll
see the Twitter link to follow our
project as well so that's it I guess we
have a lot of time left yes we should
maybe get into some questions if you
have any and be excellent to each other
Bart neon dudes the project's a deferent
project that IO
github /fn project the main repo in
there is /fn and you can follow us on
Twitter
yeah so I guess if you guys have any
questions we'd love to answer questions
went up yep
and you don't have to deal with service
though yes so yeah I mean if you're
gonna stick to one of those clouds then
you should probably just use their
service I mean I wouldn't I mean why
would you go set this up if they'll deal
with it for you but if you don't want to
lock into one of those clouds there's
why the lock-in thing a few if you don't
know if you're going to be on Amazon
forever or if you can't be on Amazon
forever if you don't know if you're
gonna be on Google forever then you can
use this and move it anywhere you don't
have to worry about and especially sorry
the question was to repeat the question
why why wouldn't you use one of the
providers cloud services like Google
Amazon or Microsoft and we want to give
you the freedom to move around we want
to allow you to run one of those
services on your own cloud if you have
your own hardware if you have your own
data centers you want to offer this to
your employees for instance you're a big
company you still get a lot of the cost
benefits because you can run a lot more
apps on a lot less hardware if you offer
this to your employees because you don't
need to run you know one server one VM
24/7 for all your apps only the
endpoints you could have a thousand apps
and only the endpoints that are being
used are going to be is so your your
capital cost phone hardware is a lot
cheaper if use this service so that's
essentially if you don't want to lock in
or if you have your own hardware your
own data centers or you want more
control over the environment you know
you want to use your own authentication
you want to use Active Directory or
something like that I would say to his
point really you know it's this is very
easy thing to integrate in into just
because the nature of it is is it's
really just web hooks so you know if you
have any service that you're actually
running internally in your own cloud on
your own servers then you know if you
add web hooks support on whatever action
you want then basically you can
integrate with any of these service
platforms really but specifically the
one running in your club yeah yeah
one function per directory but you
probably have a bunch of functions in a
single repo kind of thing the
application thing I was talking about
didn't show but if you organize all your
functions and basically how you picture
them as being endpoints like slash
whatever is your directory and you think
of that as being the endpoint that I'll
hit in your URLs to then when you do the
FN deploy - all which has the app
concept
it'll deploy those all to the defaults
will be the directory name you can
override that in the func diamo but so
you can group all these functions
together and have a whole bunch of them
in a single repository
so right now it'll do all five we're
trying to figure out a way to only find
changed ones but we haven't done that
yet yep
why would you use it on premise because
you already have your own hardware
because you can still get the benefits
like I was saying if you have a bunch of
apps running you could put them all on
you know one server say and only the
endpoints so only the specific functions
that are actually getting any traffic
will run right so you can cram a lot
more stuff on to a lot less hardware
instead of having you know separate VM
for every app and ten of those apps or a
bunch of those apps aren't even being
used but there's still a wasting memory
and they're still using hardware even
though they're not in use right right
and so this is an open source project -
Patchi - you can run this anywhere we
will most likely be providing this as a
service so you can do a FN deploy - and
it'll go straight to the bare metal
cloud yep
so what's the lifecycle of a class
typically you try to write these things
to be stateless so you think of you know
that what that handle function I showed
you you think of that running and then
everything's gone because it might be
gone like we might forcefully terminate
that container because we want to move
it to a different node so you sort of
try to think of them as stateless you
can keep a class around if you have a
static thing you can put you know static
classes or variables and that's
typically good if you're opening up a
expensive database connection you can
store those and reuse them for each
instead of reopening the database
connections and things like that but
typically I think for the classes and
stuff you're using in the function you
probably want to assume they're gone
after the function runs yeah okay so
yeah so typically you think of functions
is being stateless but you can keep some
stayed around if you want to just by
using the language features yeah and
again if if a container sits or if a
function sits idle for 30 seconds by
default it'll be terminated so another
function can take its place yep
I'll answer the kubernetes one there's
no plans to tie tightly into kubernetes
we fully support operating this with
kubernetes it's you know it's a it's a
layer above kubernetes you know this is
for the developers that don't kubernetes
is for essentially managing containers
on an infrastructure you're thinking
about infrastructure and functions
you're not really thinking about
infrastructure at all as a developer
anyway but as an operator I mean we tell
people to use kubernetes to manage it
and hopefully we'll have hooks into
kubernetes like events that come out of
kubernetes you can kick off function
it's things like that which is you know
what amazon and these other services
have when things happen you can fire off
function events and the other question
was debugging debugging you wanna talk
about that one yeah I well so actually
we've mostly just been talking about at
this point really I would say four with
respect to you know running gdb like
debugging we were speaking with the
basically Java people they want that
feature and and so you know that print
line debugging isn't really gonna make
them happy so for us it's it's like a
client thing we're going to hopefully
have some answer there but I really
concretely nobody has come up with any
way that they necessarily like
specifically when you think about
composing these things and adding break
points into compositions so you have
function spawning functions and you want
to add breakpoints to that and you want
to see the route of where it actually
came from right so our flow project is
is trying to address some of those
concerns around debug ability and you'll
get great kind of tracing and you can
get stacks and it'll show you know where
you basically would set up a chain you
would say you know this function so a
calls B equals C calls D right and if B
fails then you can see that C and D
don't get called and we actually have
the UI kind of got shown but it was just
you know you saw the spans but it has a
kind of debug ability page as well so
you might check out the flow project
yeah but currently is no support for
breakpoints
the debugging tools be cool to have sure
if anybody wants to help out pull
requests welcome yep so it's actually a
pushing code too sorry the question was
how do things get deployed are we
pushing code to the servers were
actually pushing code to a docker
registry and that default is docker hub
but it can be your own internal docker
registry or any docker registry and then
the function servers pull that code over
when it's pull those images in on demand
essentially and then cashes them until
they're not used anymore yeah so we're
just basically storing a pointer pointer
to somewhere in the registry yeah deploy
yeah so when you when when I did the FN
deploy that's essentially doing a build
a push to the docker registry and then
updating of route and that's a part of
our API is routes and the routes have
you know the path like slash slash my
funk and that path or that route also
has the image name like where I can find
the docker image and those kinds of
things
that's correct yep yep yeah exactly yeah
yeah Java is a little bit heavier than
most of languages because you have the
JVM but you know like things like go
it's just a binary so you know it's a
little 5 Meg binary kind of thing so but
depends yep say that again
yeah essentially you can sorry the
question was can you choose which Java
Runtime goes into the container you can
actually make your own docker file sort
of bring your own container and put
whatever you want in it so the default
if you're using our tools without a
docker file is some version of digital
yeah eight eight eight or nine eight
maybe nine no and yeah but so you can
basically override everything if you
want by using your own docker file any
other questions it's very likely No yeah
there's no certain plans we kind of are
trying to just be sort of fast and
aggressive as the projects early this
just got released at JavaOne just over a
month ago
so it's what's that yeah right
so it's it's new we want to move fast we
are talking to a specific organization
that we might try to get involved with
but you know we'll see it and right now
it's it's an Apache 2 project so it's
totally open there's no restrictions on
it if you do submit pull requests the
only thing you do is have to assign the
Oracle CLA which basically means I think
that yes you us down the road soft bark
made a whole episode about that I know
yeah but that's it
anything else sure we we can chat after
200 my opinion as with probably any
project is adoption right I don't think
we're lacking anything severely required
there's a lot of things we want to add
but you know it works out the box I
think an authentication story is
probably something we need to solidify
soon right now like we said you can do
it through we have a middleware plugins
and different ways to extend extend it
yourself and we're kind of leaving it up
to users of the project to add their own
authentication through middleware and
stuff like that and you know eventually
we'll probably have these modules that
you can plug in easily so for me I think
what service is such a nation technology
really that right now I don't know that
there's really you know huge user bases
that are using this for their primary
applications and you know whatever kind
of business is running so I think you
know people talk about ETL processing
they talk about building their web apps
and everybody's mostly right now is just
kind of talking about it theoretically
so it'll be really interesting to see
the use cases where it starts becoming
prevalent and there starts becoming a
more of an ecosystem there I mean for me
the most important is is basically where
to server let's go I think and we'll
kind of adjust to that yeah
alright I'll let them off the hook yeah
well thank you for coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>