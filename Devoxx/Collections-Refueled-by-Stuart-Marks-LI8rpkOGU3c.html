<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Collections Refueled by Stuart Marks | Coder Coacher - Coaching Coders</title><meta content="Collections Refueled by Stuart Marks - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Collections Refueled by Stuart Marks</b></h2><h5 class="post__date">2017-11-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/LI8rpkOGU3c" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning hey everybody welcome to
the last day of de box thanks for coming
in this morning my name is Stuart marks
I work on the JDK cord library team at
Oracle and among the various tasks I do
is I work on the collections framework
so this title of talk is collections
refueled gonna talk mostly about the new
enhancements we've made in JDK 9 with a
little bit of stuff for the future I
have selected a hash tag hash
collections refueled for Twitter so if
you tweet with that hash tag I will look
at the I will I will look for those
tweets afterwards and try to follow up
if people have people have questions
we'll see if we have question time at
the end for questions as well okay so
one slide on the history of collections
in Java so JDK 1.0 was introduced in
1996 and they the the collections they
weren't called that but what we call
what we now call the legacy collections
which consisted of mainly vector and
hash table or hash table as we call it
since the capitalization is wrong so
those with what we call the legacy
collections introduced in 1.0 and so
those served for a little while but it
wasn't until JDK 1.2 was introduced a
couple years later that what we now call
the collections framework was was added
and so that is the that is where the the
implementations and interfaces that
we're all familiar with such as
collection list set map ArrayList and
hash map and so forth but that's all
that stuff was introduced in 1.2 and
we've done a lot of enhancements that
those over the years but basically it's
interesting that those those interfaces
and those implementations have been
around for for that time almost 20 years
at this point so those were very useful
of course and in a big update to those
occurred in Java se5 in 2004 when
generics were added and so at that point
you know up until that point everything
was raw types and so you had to be
careful about making sure about the
types of what you put into
elections and you had to do casting on
the way out and so generics made it
possible for you to to have a typesafe
collection which was not really the case
before I'm also in Java five the Java
util concurrent package was introduced
so I'm not really going to talk about
that very much but but that's an
interesting kind of adjoint to the
collections framework basically a set of
highly scalable concurrent collections
and in Java 8 although we didn't
actually do that much work on the
collections themselves we added lambda
and streams and so streams is not
formally part of the collections
framework but it works very very well
with the collections framework so every
collection can be streamed and you have
all those nice stream operations and
then the at the tail end of the stream
you can collect back into a collection
so that was a big enhancement that
worked very well with collections but
also in Java 8 there was a whole family
of default methods that were added to
the to the existing collections
interfaces and so what that did was it
had the effect of enhancing every single
collection implementation even ones that
did not change as part of Java 8 of
course what we did is we optimized and
enhanced the built-in collections but
even if you had a collection that was
not built-in if even if you didn't
update it for Java 8 you would get the
benefit of all of the new default
methods that were added all right so
that's only going to talk about with
history I think the the theme of this
talk is all right Java 8 was a big deal
Java 9 we are continuing to move forward
with the collections framework so what
we did was a project called the
convenience factory methods for
collections the main goals were
convenience and brevity space efficiency
and unmodifiable 'ti a quick word on
that in previous talks and in the Java 9
documentation that talks about
immutability which i think is a little
bit confusing so I'm gonna I'm gonna
switch over to using the term
unmodifiable our unmodified ability
henceforth all right so what what are
these things all right so we have a set
of library API
Changez we are not changing the
programming language at all for Java 9
at least at least regarding collections
there have been discussion and proposals
in the past to add collection literals
to the to the language and we did some
development on those and there were a
few prototypes and it turns out that
that is actually a much harder problem
than it looks there's probably a very
much longer explanation than I have time
for here about that but we did do a
serious investigation of it and the way
I'd put it is the basic problem with
with enhancing the language to support
collection literals is that what it does
is it binds the collection libraries too
closely to the programming language and
so if you look at the way things are
there are no dependencies today in the
programming language that talk about
Java util lists Drive util collections
and so forth
and so if we added collection literals
to the programming language the first
question is okay what is the type of the
thing is it a Java util list okay what
class is it is it an ArrayList or is it
something else
so if you have a collection literal now
you're starting to bind these class
libraries directly into the programming
language and that was very very
uncomfortable because we might want to
change those in the future so and there
are a bunch of reasons why that became
much more complex to add collection
literals than it might first appear so
instead what we did is we said okay we
want to have the ability to specify a
collection kind of in a collection
literal like syntax but instead of
changing the programming language to do
it we decided to add library only api's
to do it and we believe we have achieved
about 80 percent of the benefit of what
we could have gone using collection
literals and far less complexity than
adding collection literals to the
programming language maybe an order of
magnitude less complexity alright so
this this is basically the API here I'll
leave this up for a little while so you
can digest it but the idea is that if
you want to have a certain number of
elements
put them in the list you say list of and
you can it's basically just a varargs
method so you can just say the list
thought of however many elements you
want including 0 or up to an arbitrary
number if you want to have a set of
elements you can specify a varargs list
of varargs parameters for for the
members of that set map is a little bit
different you can say map dot of but
then you have to specify keys and values
which in general can be of different
types so we can't do a straight VAR args
there so instead what we did was we had
a set of fixed argument overloads for
map dot of where they alternate the key
type and the value type and we have that
going up to 10 map entries but if you
want more than that there is a different
method called mount dot of entries that
takes map entry instances and so that's
a little more cumbersome we made that a
little easier because we've also added a
static method called entry you can see
that lower case entry that takes a key
and a value pair sorry takes a key value
pair and returns a an instance of math
dot entry so if you want to add more
than ten elements sorry if you want to
add more than ten mappings to two to one
of these maps you can say math dot of
entries so this is what the this is what
the Javadoc looks like so it looks
pretty ugly in the Javadoc because
they're basically all these redundant
overloads that differ only in the number
of arguments but the good news is that
you don't see this when you're actually
using the api's yeah sure you pop up
autocomplete when you in your IDE and
you see a bunch of overloads or you see
this in the documentation but when
you're programming you just say map dot
of or list dot of or whatever and then
you just type the number of arguments
you want and the only time you need to
worry about it is if you have more than
ten key value pairs for a map you have
to switch over to math dot of entries
but otherwise this basically just works
and the compiler finds the right
overload for you and you just move on
alright so let's show these things in
action suppose you wanted to have a
string list that was unmodifiable so in
the past what you'd have to do I'll read
this kind of from the inside out so
you'd say arrays dot as list to get to
get a sequence of elements there and
then wrap that in collections dot
unmodifiable list and then assign that
to your variable and so in Java 9 all we
have to do is say list of a b c and
that's pretty easy pretty
straightforward okay set example is
almost the same but it actually gets a
little bit better because you it's
harder it prior to java 9 it was harder
to initialize a set and so what you had
to do is a raised dot as list was quite
convenient because what still is
actually well it's a varargs method and
so that's a nice way to to list off an
arbitrary sequence of elements but then
what you had to do is copy that into a
hash set and then what you had to do
after that is wrap an unmodifiable
wrapper around it and so now in java 9
you simply say set of ABC becomes much
simpler alright so a quick example with
map so here basically there's there's
really no there's really no good
convenient form of doing this prior to
java 9 you had to create a hash map and
then just call put a number of times and
then wrap that wrap wrap the result in a
none modifiable wrapper sometimes you
will find people advocating the double
brace EDM to initialize a map please
don't do that
it's beyond the scope of this talk but
there's some some very good material out
there that tells you why and why you
shouldn't use the double brace idiom
anyway but you don't need to do that
anyway in java 9 because you simply say
math dot of a comma 1 comma B comma 2
comma C comma 3 all right so and notice
what's going on here is when you declare
the variable on the left hand side you
can say math dot of and you just give
the values and type inference make sure
that the type checks all of the
arguments and so if you if you if you
accidentally put a string in the wrong
position then you'll get a compiler
error so this form this form is type
safe and also you might have also heard
that in
in in the next release we are working on
something called local variable type
inference or var and so this actually
type inference works here as well I
don't have I don't have an example but
you can save our string math equals math
dot of a comma 1 comma B comma 2 and so
forth and it gets the right type so it's
very convenient to use that with new
features in upcoming releases all right
now here is an example of using a map
with more than 10 entries and so this in
this case you have to fail over to using
the map dot of entries method instead of
map of and here you have to have a
succession of calls to the entry method
and so here were we're just you know a
so if you're writing a parse or
something you might have a mapping from
string to token type or something like
that and so here we just have a
succession of entries with some kind of
string and you know some enumeration
constant or something like that and so
that's what that looks like so that gets
that gets kind of verbose but it's still
it's still it's still nicer I think than
initializing hashmap this way all right
so moving on from the API I wanted to
spend a fair amount of time on the
implementation characteristics of what
you get back so we have these new api's
list dot offset thought off math dot off
and they don't return kind of the
obvious collection so list thought of
does not give you an array list set
thought of me after I've do not give you
hash set and hash map they give you new
internal private implementations private
in the sense that the the class name is
not visible to you there are no
constructors here the only way to get
instances of these new Diplomat a
chinois list set and math dot of so
these implementations have a bunch of
different characteristics that differ
from what i'll call the conventional
collections the first one is that they
are unmodifiable and so if you well
actually have details on this later on
but anyway they're a bunch of things
where where these these characteristics
differ from the conventional collections
they're unmodifiable
they disallowed nulls randomized
iteration order so I'm going to spend
some time on that that's a that's
something that's caused a bit of
controversy they disallowed duplicates
and there's some things in there they
actually throw an exception if they
detect that their duplicates being being
initialized with duplicates so one thing
that's very interactive is also that
they're much more space efficient at
least for hash that and hash map much
more space efficient than the then
they're they're modifiable counterparts
and they are serializable and there's
some some details to talk about there as
well all right so let me talk about
unmodifiable ax t so as I mentioned
before I'm not really using the term
immutable anymore and the reason is that
these are just collections and if you
take a mutable object and add them into
one of these what you get is still
mutable so calling these immutable
collections is potentially misleading in
fact I've had questions from people who
say oh well so if I take a mutable
object sorry if I take a mutable object
and add it to one of these collections
does the whole thing become immutable no
there's no magic here the collection
itself is unmodifiable but if you put a
mutable object inside of one of these
collections then the whole thing
actually is still mutable so there's a
more precise definition of what it means
to be unmodifiable which is that there's
a family of methods ad set and remove
and they're a handful more but basically
those are the things that modify the
elements of a collector the elements
contained in the collection those will
all throw on support an operation
exception so what good is this it's kind
of surprising i guess i've been i've
been so close to this is like of course
you want your collections to be
unmodifiable
and i've had some questions like well
what good is a non-modifiable collection
don't you want to add more stuff to it
and and so not necessarily I mean
obviously we still have the conventional
collections you can add and remove
elements they're still very useful for
those purposes but there are lots and
lots of use cases where you want to
create a collection you know what
elements need to go into it at
initialization time and you want to put
them in and you never want to change
that collection later on and so that's
what these are useful for so there are a
lot of there are actually a lot of cases
where that occurs in fact these were
added some time ago in the JDK
release cycle and we've we've started to
use these api's in jdk 9 itself and
people are really happy with them I
think it certainly helps certainly help
space utilization and startup time to
use these in JDK 9 itself so there are a
lot of clay places in the JDK and
probably also in other libraries an
application code where you want to
initialize things and then never change
it afterwards so another case is if you
have a data structure and you have a
getter for something you can hand out a
reference to one of these and you can be
fairly well assured that your caller
cannot accidentally modify the contents
of your collection so that's pretty nice
you don't have to make defensive copies
anymore you can just hand it out so
you've probably heard that immutability
in data structures really helps thread
safety and it certainly does so if you
have immutable objects inside and the
unmodified collection then right there
you have taken a big step towards making
your data structure thread safe I also
mentioned space efficiency already so I
think one thing to draw a distinction
here is that these new collections
implementations contain elements
themselves and this is in contrast to
the existing things like collections not
unmodifiable lists which are wrappers
around another collection so these
contain the elements themselves whereas
the wrappers are simply a view onto some
other collection which actually might be
modifiable so here I have a quick
example of that so so I have a list of
integer that is created using arrays dot
as list and I've wrapped that in
collections not unmodifiable lists and I
get that and store that in list 1 and
then enlist to I say list dot of 1 2 3
so those lists have the same contents so
this they're they're both similar and
different they're similar in that if you
call add remove or or set on list one
and list two those will all throw on
supported operation exception
because they're both unmodifiable but
list1 is an unmodifiable view of the
list named inner so you can go in and
change that and that change will be
visible in list 1 so that's what I mean
by an unmodifiable view whereas list 2
cannot be modified at all so not only
can you not change the contents with add
add or remove but since the since since
the the members are integers which are
immutable the whole thing is immutable
but again you have to be a little
careful don't if you want the whole
thing to be immutable don't put mutable
data into one of these lists ok moving
on so all of these collections disallow
nulls so you can't have nulls in list or
set and you can't have no keys or values
in the map and so there's no way for us
to check this at compile time but the
best we can do is when you try to create
one of these lists if you happen to pass
a null in then it'll throw a null
pointer exception and so this is I mean
a couple of reasons for this the I think
it's widely regarded that when
collections the collections framework
was introduced back in one point to the
allowance of nulls in certain
collections particularly hash map I
think hash map is the only map implement
I know I'm not it's it's the most
popular map implementation and it's the
one that allows nulls most of the other
math implementations I don't know about
all but most do not allows nulls in
particular concurrent hash map does not
allow null and so if you look at a hash
map it turns out there a bunch of
special cases laced throughout the code
where it says oh okay let's take the key
oh if it's null then subdue the
substitution it has to do the
substitution all over the place and so
that's extra work but it also it also
means that there's a there's a well
basically that's that's oh the biggest
problem is with math dot gap and also
other api's like math compute so if you
say Matt get and you pass it a key you
get back the value that corresponds to
that key what if that value sorry what
if that key is not present in the map
well math dogette returns null what if
the key is present and the value is null
you also get back null so you can't tell
if your map value if one of your map
values is null math dot get basically
doesn't work you have to call just can't
use it without without worrying about
whether the key was absent or whether it
was present and null so so there's some
semantic issues like that with including
nulls in maps but they're also some
implementation issues if you are some
implementation advantages you can gain
by disallowing nulls as part of the data
just the internal organization in uses
nulls as a special sentinel and so the
implementation the internal
implementations take a lot of advantage
to that of that to make things smaller
and go faster so anyway so no I mean
this is not a new precedent I think any
collection that was introduced since one
point four or five has disallowed nulls
so for the most part we're just
continuing along with that all right so
this is this is something that that has
caused some confusion and consternation
there's a long history about the
iteration order of various collections
that are hashed based so if you look at
the specifications for 50 leur things
like hash set and hash map if you look
at the the method the iterator method
says something like returns the elements
in this set in no particular order but
there's this problem which is that it
turns out that the the hash code for
most data is very stable the hash code
for string which is a very common thing
to put in sets or use his mouth keys the
hash code for string is actually pretty
poor and doesn't doesn't really
randomize things very effect
or it doesn't really spread values
around very effectively which is what
you want from a hash code and so it
turns out if you put a bunch of strings
into a hash set they'll come out in
alphabetical order if they're well if
they're the same length so the typical
thing is you say you know add a B and C
to a hash set it turns out if you
iterate over the hash set they come out
in order and that is very misleading and
what happens is in practice code gets
written that makes assumptions about the
iteration order of hash set and hash map
and occasionally we have reasons to
change the internal structure of of
something like hash map either for
optimization or to improve the security
of the system or things like that
and that changes the iteration order and
what what happens is that a bunch of
code breaks and then we have this we
have this argument which is hey you guys
broke our code we say well oh yeah I
guess we changed the iteration order but
look the specification says you mustn't
you know that it's it doesn't return in
it doesn't return the elements in any
particular order but my code was working
for years and you broke it right and so
unfortunately so it's like everybody
likes to say you know I'm right and
you're wrong but the fact is when you're
in this situation it's it's very
uncomfortable especially when the guy
saying you broke my code is a very very
very large customer so those kind of
conversations are very difficult and so
what we do is we say okay we promise
we're never going to change the
iteration order of hash map again until
the next release and then what happens
is since since the iteration order of
hash map doesn't change very often
there's a whole crop of new code that
gets written that makes dependencies on
hash map iteration harder and then it
gets broken again and so so there's a
real problem here where the
specification says there's no particular
order to find and then the
implementation there are always
opportunities to make changes to
optimize and improve things but that
changed the iteration order but we hold
back from doing those because we don't
want to change the iteration order and
break people's code
all right so that's the history so these
are brand-new collection implementations
in Java 9 so nobody by definition nobody
can have any order dependencies on them
and so what we've done is for the new
set and map implementations we actually
randomized the iteration order of set
elements and map keys and so when the
JVM starts it basically takes a random
number and and then just XOR is it into
the hash code and so in practice what
will happen is every time you you run
every time you run an application you'll
get a different random number and for
the new collections from set of and math
dot ah've they will be iterated in a
different order and so what we're doing
is we're saying ok we're standing behind
this idea of we're not returning the the
elements in any particular order and
instead of changing it as infrequently
as possible we're changing it very
frequently every time a new VM starts
you're gonna get a different order and
what that should do is have an effect of
preventing code from being written that
depends that has implicit dependencies
on iteration order so now I want to
stress that the existing implementations
like hash map are not changing so we're
not we're not going to cross that bridge
at least not yet
although there's some things we might do
so hash map is not changing so it's
iteration order is although it's not
guaranteed to be stable
we are not randomizing its iteration
order whereas for the new set and map
implementation new set of map
implementations we are randomizing them
so one of the one of the things I've
said in the past and I've stopped saying
and it's also one of the things I've
heard is well you know people should
just learn to write code that doesn't
have iteration order dependencies and to
a certain extent that's true but in
large systems it's been our experience
that these iteration order dependencies
can and do creep in regardless of how
how careful you are so we're hoping that
this new feature will will flush those
out early during testing and development
and and prevent problems from occurring
and all and and mainly too we want to be
able to have the ability to to improve
optimize and maintain these new
collection implementations a hat will
and therefore be able to change the
iteration order at will and so if the if
the iteration order is randomized then
making an internal implementation change
that changes the iteration order should
really have no effect whatsoever so this
is part about protecting our ability to
evolve the system but it's also about
the ability of you know preventing these
kind of bugs from creeping into
application code for which it's actually
quite difficult to test alright so it's
interesting so this is so this is new
for Java this is kind of a new thing
because most things in Java have very
very predictable very very deterministic
behavior but in looking at other systems
in particular go and python they have
also used randomized iteration orders so
this has been in go from from the very
beginning and it's interesting people
people do complain about it and if they
want to preserve iteration order they
have to do more work to do that python
has gone back and forth on this python
to I think the the it's one of the it's
a similar thing the specification or at
least if you ask Lido the the maintainer
of Python he'll say that yeah the
there's no specification over the
iteration order of the the equivalent of
math in Python and so in Python 3 they
actually randomized it but I think at
least starting in Python 3.6 there's
actually a new implementation that was
put into Python that does have
predictable iteration order it's
predictable and then it won't change but
it's still not specified to have that
order so that's an that's a discussion
that's still going
and the Python community because there
is this there's this there's a group of
people who want to have predictable and
specified iteration order so I think
Python is is moved back into an
uncomfortable position where it is in
fact stable but it's not specified so
theoretically they're reserving the
right to change iteration order again
but you can see they'll run into
potentially exactly the same problem if
if if code has been developed that
starts to depend on this new iteration
order so anyway if you are concerned
about this about iteration order then
don't use these new makkal
implementations that's one approach you
could stick with hashmap if you're using
that but there are other there are other
implementations in the JDK Center in
particular linked hash map and linked
hash set that preserve insertion order
as iteration order so if you insert
things in a particular order and then
iterate you will get a predictable order
that's the same as the insertion order
there's also an access order variation
of those so if you want to preserve if
you are very if you're concerned about
iteration order even if you're using
hash map you should probably convert to
linked hash map because there's a
possibility that we might change the
iteration order of hash map again in the
future all right
okay so duplicates are disallowed so
this is for sets I am set elements and
map keys and so of course by their
nature you can't have duplicate elements
in a set but what's different here is
that since you know all the elements at
construction time it is probably an
error if you're writing out a list of
elements and you you have duplicates in
them and so we consider that to be a
programming error remember I started
talking about collection literals so
this is modeled on collection literals
so if you want to create a set using a
particular set of you know if you have
specific elements you want to add to the
set if you have duplicates in that then
it's it's a little strange and you might
have you might have made an error so
what we do is we we throw an exception
when we when we discover that at
initialization time this is something
that's a bit unusual
there aren't many systems that do this
most other systems what they do is they
have like a last one winds policy and I
think that's a little bit dangerous
right so if you take a look at this
example so this is a modified version of
an example I showed before or where
you're adding a bunch of map entries to
a map and it turns out that there's a
bug in this one and if you you you might
be able to spot it if you have sharp
eyes but there's a duplicate key in here
so if if this pursued or if this if we
followed a last one winds policy then
what would happen is silently you would
get a map with one fewer entry in it
than you expected and you might have one
of these tokens mapped to the wrong
token type and you know you can imagine
a late night debugging session where
it's like you know you're looking at the
stuff oh this looks right to me how come
getting the wrong result right so I
think this is common enough that it's
worth error checking this and so if if
we're running through the list of map
entries and we encounter duplicate keys
we'll throw an exception at this point
all right so here's an implementation
concern about space efficiency so one of
the reasons that we we are if you look
at the most of the existing collections
how are public classes with public
instructors so if you want a new
ArrayList you say new ArrayList and
you're gonna add elements to it and so
forth the the classes that implement
these these new collections are not
public and so they're all protected
behind static factory methods and so one
of the reasons we do that is that we
choose different implementations for the
collections based on the collection size
so in particular for list and set if you
have 0 1 or 2 elements we use
specialized extremely compact
implementations that store only 0 1 &amp;amp; 2
elements they don't even store them in
an array and then for map if we have 0
or 1 mapping those are also stored in
fields so that gets a very compact
representation for those now if you have
a list Center map with a larger number
of elements or mappings then we do use
internal arrays but we have a different
array organization so instead but anyway
so the benefit is overall there's
there's less space consumed by these and
they're not necessarily faster but
they're not as slow as you might expect
because the locality of reference is
improved compared to hash math alright
so let me run through a quick example of
space efficiency concerns here so let's
say let's take a let's create a hash
that in the conventional way and create
a hash set and add two strings to it foo
and bar and then wrap that in a none
modifiable set so if you count the well
you have to know a little bit about the
actually have to know a lot about the
internal implementation of hash set so a
hash set is actually built on top of
built on top of a hash map so hash set
is simply a hash map that where the set
elements are keys in the hash map and
the value is some Sentinel object that's
irrelevant so a hash map it has an
internal array called the table and that
those are those are hash buckets and
then the the contents are a linked list
of No
that are hanging off of the hash the
hash buckets alright so if you count up
the number of objects used by the
collection I'm not counting that I'm not
counting the strings themselves I'm not
counting the payload that's contained in
the collection just talking about the
overhead of the collection itself and
unmodifiable set instructed this way
takes a lot of objects right so we have
the unmodifiable wrapper we have the
hash set object a hash that contains a
hash map there is an array which is
another object which is the the table
and then there are two note objects
because every mapping has to have a node
object and then that contains the
pointer to the string itself so we have
six objects one two three yeah six
objects all right so that's this is this
is a diagram of what it looks like so so
you have V you know each each box is
each box is an object and and then each
node contains references to the key and
the value alright so now let's talk
about the size of these and so one of
the one of the things about Java is that
small objects are actually fairly
wasteful so on a small heap size there
is a twelve by table jecht editor for
every object and then if you have large
heap then the header rises to sixteen
bytes so I'm not going to go through all
the details here but if you add it all
up it turns out that storing two strings
in an unmodified ball hash that takes a
hundred and fifty two bytes and that's
that's not counting the strings in fact
the strings themselves are well strings
themselves are not as small as you might
think they are
but that's 152 bytes for just a two
element set so that's hash set so if you
look at the new set implementations if
you say set that of foo comma bar you
can do a similar analysis so here this
uses the field based implementations so
two elements set just has two fields and
so that only takes one object and those
are references to the set element and if
you add that up then the space consumed
by a new a new set created using set of
takes only 20 bytes it's compared to 152
bytes for for a hash set
Oh actually so so another another
another point here is that there are if
you look at the size of memory consumed
by collections that are there really two
things you need to look at which is the
fixed cost which is the the cost of
creating a collection even an empty one
to begin with and then there's sort of
the variable cost which is how much more
space that that a collection will
consume as overhead as more elements or
added or as as you create larger ones
and so the new collection
implementations are much more space
efficient so they're smaller even for
small sizes and even if you add lots of
elements there's they they have a lower
per element size so it's like wow this
is really great well remember the reason
we can do this is these are unmodifiable
so once you've initialized the set or
map with these with with the elements
you can't change it and so that's the
the benefit of hashmap of course is that
it has this data structure which is
fairly fairly large the the nodes linked
list of nodes from bucket so what the
advantage is that updates to a hash map
are very very fast so if you if you need
updates hash map and concurrent hash map
are this you know still the way to go
but you're paying a space penalty for
that if you don't need to modify it then
convert over to the new set and amass
implementations and you can save a lot
of space okay so I said earlier that
since we construct since there are no
public constructors and no public
classes we we will return you call the
static factory methods and we'll return
instances of some implementation
internal implementation of our choice
what happens if you want to serialize
one of these guys so what we do is we if
if we didn't do anything else then you
serialized one then the the name of the
internal implementation class would
appear in the serialized output stream
and so we didn't want to do that because
we want to preserve the ability to
change the internal implementations at
and so what we do is we use the
serialization proxy mechanism that's
something that's described in Josh
blocks book effective Java there's an
item that talks about serialization
proxy it's just it's basically a pattern
but basically all of the new set and
amass implementations use a single
serialization proxy and so that is the
the on the wire format that we are
committing to so if you serialize one of
these collections in Java 9 and then we
completely reorganize the
implementations in Java 10 or 11 or
something we will commit to being
serialization compatible going forward
now these are not serialization
compatible with the existing collection
implementations like hash map or
ArrayList
and so if you do need to do have
serialization interoperability with
older versions of Java then you must
continue to use the the existing
collections and if you think about it
that makes sense we're introducing new
implementations in Java 9 and you can't
deserialize them on Java 8 since those
those include implementations simply
don't exist all right so that's that's
pretty much what's going on in Java 9 so
let's turn to the future and talk about
what's going to go on and Java 10 or
18.3 or I guess we're now back to the
Java 10 here we keep changing the
versioning scheme so this is a proposal
that is currently out for review if you
look at the the static factory methods
you can you can provide an explicit list
of elements or you can provide a VAR
args list which actually is the same as
an array and it's actually kind of
cumbersome sometimes what you want to do
is compute or load or something a
collection of things and then once
you've computed that then load them into
one of these unmodifiable lists and so
what we're doing is essentially what I
what we're doing is proposing to add
like copy factory methods so list set
and math dot copy of and what those do
is those take listen set take a
collection and math takes a math and
conceptually what they do is they take a
they make a copy of whatever was passed
in and used that to initialize the new
instance of this collection one on one
of these collection implementations in
addition we are also proposing to add
some new collect doors to the streams
API so in you might not want to
pre-compute a collection you might want
to have a stream that computes some
number of elements any and you might
want to collect them into a list or set
or map or something like that but what
those what the existing collectors do is
essentially return a they return well in
fact what they do is they return an
ArrayList a hash set or a hash map but
what you might want to do is take the
output of stream and and send the
results into one of these new
unmodifiable lists implement our
unmodifiable collection implementations
so we're proposing to add a set of
collectors to to the streams API that
that will let you create that will
create instances of these these new
collections so so one thing one thing
I'll mention is so so notice if you
recall earlier I said that set of and
we'll throw an exception if it
encounters duplicate elements because
they're the presumption is if you are
writing these out by hand and they're
duplicates then you made a mistake so
that's why we throw an exception in
these cases you you you since these are
computed from somewhere else you might
take a list and then copy it into a set
and in that case what we do is we will
compress out the duplicates so
duplicates are allowed in this case
because this is different from from the
collection the journal style of
programming so we did it
for these for these methods it is it is
not considered a programming error if
there are duplicates so that's something
that that people really missed with the
existing ones because what they wanted
to do was compute some elements and
they'd copy into an array but if they if
that had duplicates then they'd have to
deduplicate it and then copy that into a
different array and
loaded into a mapper set using the array
array factory methods since that was
that was very cumbersome so instead so
these will these will compress out
duplicates all right so so that's so
that's about it here I think the main
theme of this is that when I started off
I talked about the history the
collections framework being being almost
twenty years old I think it's it's it's
still important useful and very relevant
and it's in daily use very popular as
far as I know and so even after all
these years we are still enhancing it
and so it's useful and extensible and
we're we're continuing to work on it so
as you know JDK 9 shipped this year
actually I'm sorry I'm not sure these
one of these URLs might be wrong but I
think that I think you know Java 9 is
generally available so it should be
should be easy to find I encourage you
to download it and try it we have
started to we have started to ship JDK
10 builds at this point the new the new
proposed factory methods I talked about
a bit earlier are not yet in the main
line but I hope to get them in over the
next few weeks and so you should be able
to get a JDK 10 build and try those out
as well so I'm Stewart marks on Twitter
and then if you look at the top there's
the collections refueled hash tag and so
you can tweet on that and look at it and
we actually have a few minutes for
questions so when we open it up now all
right we got one one question right
there
okay question is why a single function
implementation and not use a builder
well so it's not entirely clear what the
what the value of builder would add a
builder has very very a very high API
surface and so for most of the
implementations or for most of the cases
we felt that simply having the
overloaded methods was was satisfactory
we did consider using builder form the
math of entries but what what I need to
do is write an article about all the
different things we tried for math of
entries I think we analyzed 14 different
proposals for that and we did include
builders in that I think what it what it
boiled down to was if you use the
builder in that case for math thought of
entries it was basically the same as
building up your own hash map and then
copying the elements in into an array so
so we did look at builders and they just
didn't seem to didn't seem to be helpful
any other questions
yes right here
okay so is so I'll rephrase your
question I think you're asking is there
a different interface in the collections
framework that designates that the
collection is is immutable or
unmodifiable and the answer is no we're
thinking about that a lot but it's
actually there are some subtle and
difficult trade-offs about that so one
is so so the the the kind of the obvious
thing to do is to say so if suppose I
say list out of ABC what that does is it
returns a list shouldn't it return and
you know a new type named unmodifiable
lists well okay sure
yeah that's kind of a reasonable thing
to do so so think about where that would
go in the collections hierarchy so the
list interface contains things like get
and it also contains things like add so
if you have an unmodifiable list might
think okay so that should be a super
type of list because you don't want it
to have the add methods the guy's
shaking his head because he knows where
this is going right so if you have an
unmodifiable list that's a super type of
list that means every list is an
unmodifiable list okay that's wrong ah
okay so maybe you should have an
unmodifiable list as a sub type of list
okay what do you do with the add method
okay so now what you need to do is
enforce somehow that the add method
always throws on supportive operation
exception you can't do that in you can't
do that in an interface you could do it
and this is what guava does they have an
abstract class weight called immutable
list and set in math but that so that's
a public class but it has no public
constructors and so what they do is they
have their private implementations of
add and remove and so forth do throw on
support an operation exception but here
we have this so there's a smell here in
the API already which is refused bequest
which is you are a subtype of something
but you are explicitly disallowing
certain operations okay so that's one
thing and we don't know how to how to
deal with that but then the other thing
is if I think guava did something that
was was useful and helpful for them
which is they they have complete control
over their own immutable
collections and those are all inside a
single package so their framework is not
extensible outside of guava and so for
guava that's just fine
we considered doing that but we didn't
want to commit to that being the
long-term evolution path of collections
and so we've held off from doing that
the fact is that in in the original
collections framework in 1.2 there are
already these things called collections
dot unmodifiable lists and so forth
which return the same old list interface
that that throws unsupported operation
exception so we're kind of continuing
with that we've looked at alternatives
like I just outlined and those are not
necessarily any better so we're
continuing to look at alternatives but I
think that the kind of it's one of those
things where the obvious thing of just
ad types for unmodifiable or immutable
collections it's it's not so obvious
after all so it's something we've
investigated and we're continuing to
think about alright I think I have time
for one more question
all right this gentleman right up here
okay is there any chance that the
randomized iteration order could change
to insertion order well no since that
since the system is already shipping
then no it's out there and it does what
it does
but people have asked for an
unmodifiable insertion ordered set and
there's an RFP for that and I think that
if that's something that people are
interested in we could add that in the
future but that would be using a
different API so instead of set thought
of it would be set thought of ordered or
something like that or maybe that would
be a better word would be chosen but
basically they need would list the
elements and then those would be
iterated in me it wouldn't be insertion
order per se but it would be like in
declaration order so that's something
that people do find useful is to have a
predictable ordered unmodifiable set and
we don't have that but that is something
we're thinking about alright my time is
up thanks for your time and attention
enjoy the rest of the conference</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>