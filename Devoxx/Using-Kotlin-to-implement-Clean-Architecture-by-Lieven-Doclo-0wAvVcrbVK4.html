<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Using Kotlin to implement Clean Architecture by Lieven Doclo | Coder Coacher - Coaching Coders</title><meta content="Using Kotlin to implement Clean Architecture by Lieven Doclo - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Using Kotlin to implement Clean Architecture by Lieven Doclo</b></h2><h5 class="post__date">2017-11-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/0wAvVcrbVK4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay good afternoon everyone welcome to
a presentation on clean architecture and
how we can implement that using cotton
so what are we going to talk about I'm
going to briefly explain on what clean
architecture actually is walk you to
some of the basic concepts of clean
architecture why we can use Koplin to
implement clean architecture and what
are some nice things about the language
that we can use to make implementing
clean architecture a bit more easy and
I'm going to show you some demo codes
I'm just going to build an application
from scratch using clean architecture
principles and I actually wrote an Intel
chip plugin to make sure that the code
that I'm showing you will actually work
so Who am I I'm leaving I'm a developer
since 2005 I do mainly Java but for me
language is the detail clean
architecture is way more important in
any language and if you know basic
architectural concepts you can do it in
at just about any language and I'm
self-employed as of this year so I'm a
freelancer so what is clean architecture
well the cool concepts have been around
for decades it has been published in
various papers but it actually got
popular in 2012 thanks to Robert C
Martin also known as Uncle Bob and he
published an article explaining how
clean architecture actually works and
how it can help you build better
software since then there were a lot of
other articles a lot of presentations
and a lot of videos on YouTube that
explain clean architecture in more
detail for you so once upon a time we
had a big bowl of mud which actually
meant if you have an architecture and
you change the database suddenly you
have to change the front-end your logic
was scattered everywhere and
you never knew what was actually where
and you're you had presentation logic in
the database for example you had to
store your data dates in a certain
format to make sure that it's shown
correctly on the front end this was very
hard to maintain and it actually sorted
cost that you had to test the entire
application when you wanted to make one
single isolated change so what would
Martin actually looked at that and he
decided to show a sort of a diagram of
how clean architecture should look like
and basically it's something like an
onion in the middle you've got your
domain entities which are your domain
logic around that are you use cases
which actually tell you what the
software will do for for business
purposes around that you're gonna have
your controls your presenters and your
gateways for example to go to the
outside world whether it be to web based
clients or to the database or to
document data stores and then around
that you've got your basically your
infrastructure your web your UI for
example your angular applications your
database a Postgres or a MongoDB or just
the different devices or external
interfaces for example an interface to a
ERP system like s ap this was the this
is a widely published graph but there is
actually another graph that we as a
group tried to create so it should
actually shows you what the flow is
towards and inside a clean architecture
system so at the top you've got your
external system for example your a rest
layer or your JMS endpoints it goes to
the application API which are actually
your interfaces from your use cases
those are implemented by your
application layer which actually contact
your domain layer which contains some
sort of a gateway to have your entities
or in your domain
and those gateways are implemented again
through another infrastructure layer for
example that does a rest client for
example getting data from an another
system a hazal cost layer or a Postgres
or a document data store so the calls
actually go from the outside in but the
implementations go from the from the
bottom up and the flow of control
always is from web to web to application
to domain to your infrastructure again
to the actual database or an external
system it's actually a mixed bag of
goodies
so if you'll talk about clean
architecture we're actually talking
about a lot of concepts at the same time
for example you've got hexagonal
architecture which goes around the
concept of port and ports and adapters
you've got onion architecture which
actually goes around layers such as I
showed you in the previous slide and
then you also have screaming
architecture which actually states that
every part of your system should
actually scream its intent towards the
developer that's using the system so you
just look at a part of the code and you
know exactly what it does and what its
principles are one of the core concepts
within clean architecture are the solid
principles so for those who don't know
the solid principles it's single
responsibility principle open/closed
Liskov substitution principle interface
segregation and dependency inversion why
is that so important well single
responsibility principle every single
layer and clean architecture has its own
responsibility and it has its clearly
defined an open closed principle
actually shows you that for example the
gateways disk these can be extended and
implemented from another infrastructure
layer but they cannot be modified their
contract is actually written inside the
domain layer this cough is being able to
substitute every part of the
infrastructure layer
for another implementation interface
segregation I will show you from a use
case standpoint most of you work with
services with a lot of methods inside of
them the use case concept is actually
that you have one single interface per
use case within your system for example
you could have a product service which
has a fine method to create either the
delete methods within clean architecture
we we tend to split those up and two
different classes into different
interfaces which have a single
responsibility and dependency inversion
I will show that to you in the example
that you cannot access the
infrastructure layer firm within the
application layer or you cannot access
the domain layer from inside one of the
outlying web infrastructure layers so
everything is nicely bounded up this is
also one of the more published diagrams
on the in architecture it actually shows
you the different concepts within a the
different elements within a clean
architecture the central concept is the
boundary this is the single this is this
is your business use cases which tells
you what's the system will do these are
implemented by interactors and by
presenters so you have to kind of
boundaries you have input boundaries and
output boundaries and put boundaries are
your actually use cases the output
boundaries are the the the boundaries
that are responsible to transform any
inputs any output that comes from the
input boundary towards for example a
view model to the outside world so that
you don't just expose internal state to
the outside world boundaries can have
response models and request models and
an interact which is the implementation
of the use case will have a reference to
an entity gateway an entity gateway is
responsible to get entities from your
domain layer
so you have your different entities in
your domain layer and then you have you
have the bottom part and which is the
other ticket way implementation which is
the actual database implementation of
your entity gateways for example a API
implementation or a MongoDB
implementation or just plain JDBC if you
were really into that and that actually
references the real database API but the
problem is that a boundary concept is
not really that's known in the in the
real world so if we talk about something
we mainly talking about use cases so you
have use cases which I've used case
implementations and for the rest it's
all just the same and here I also
changed the concept of an output output
boundary to response model consumer
which actually says what it does it
takes the response model of the input
boundary and consumes it and creates a
view model so that the outside world can
actually use that it also allows you to
use a model or approach we're not
talking about Java 9 or OSGi here it can
be used though but you don't need those
to have a model architecture within a
clean architecture system the boundaries
are well-defined and you cannot step
outside of them for example you have
here an example that's available on
github that actually shows you in a very
extensive implementation of a clean
architecture so you have your
application API which is your interfaces
of your use cases the application
implementation the domain then you've
got different infrastructure layers here
I have three different infrastructure
layers at the bottom for example one
that uses JD bi one that uses JPI and
one that uses MongoDB to implement into
the gateways and then towards the
outside world you have different
different infrastructure layers towards
the web for example one implementation
that does a REST API using Jersey and
one other than that uses spring MVC it
all gets bound together into a
main partition which is actually the
deployment that's the glue that takes
everything together and that actually
uses spring boots from a diagram
perspective if you look at the arrows
then you can see the dependency
inversion concept for example the
application implementation has a
reference to the domain layer and the
application API but it can it does not
have a direct dependency on one of the
infrastructure layers so it cannot use
one of those layers directly so it does
not even know that there is a database
or that is being exposed by a web
interface um why am I actually using
cotton well first of all it's a very
popular language nowadays it's quickly
becoming one of the preferred languages
of many developers especially those that
are akin akin to languages like Ruby it
allows you to be very terse and very
precise and just very very productive
from a day to date standpoint
first of all immutability is a
first-class citizen within Kotlin every
object in rockland is immutable by
default also everything is public by
default so clean architecture actually
gains a lot about which with
immutability in the inside Kotlin and i
will show it to you in the example
that's it allows you to clearly define
your data structures and to make sure
that nothing can be changed within other
layers that shouldn't change it statics
are implicitly discouraged if you know
Copelan you have to use a companion
objects to make static methods and it's
not really that clean so they're just
because the fact that you have to do
some extra magic and it's really just as
easy as in Java just put a static
keyword instead in front of it it makes
sure that you adhere to
to object-oriented principles and of
course it also has some syntactic perks
for example null ability can be enforced
from a from a compiler standpoint you
also have the concept of extension
methods which I will show you in the
example so let's build some code it's
gonna be a bit awkward because the
screen is over there so we have a couple
of I'm going to use the present view so
we have a couple of use cases and let's
pretend that we're building a ecommerce
system and we just want to build some
use cases around products so we now have
two use cases for example find products
and create products how can you perhaps
we I can explain how can you define your
use cases within your system well
actually you could be able to model your
entire system in two use cases without
even writing any code whatsoever you can
you can use techniques like events
storming or a use case modeling in or
you use your story modeling to define
your use cases within your system and
just list them into your and inside your
application API and that just defines
what your application will be able to do
how it's going to be done that's
something completely different and
that's something that's a technical
detail so now I've just built here two
use cases find products and great
products and how does this look well
it's just an interface with a single
single methods which is create which
gets a request and a response the
request is a name so I think I use the
wrong one
sorry so it has a fine method and it has
a request and a response the fine just
has a request and it says okay I want to
be able to find my products with a name
contains and the response will actually
return a product response which has an
ID and an industry same thing for create
for example we have a single methods we
have a create method we have requests
and we have a response the data Clause
actually is a little syntactic sugar
within Coughlin's that allows you to
build an immutable immutable data
structure that has a single field for
example name or multiple fields and it
also implements equals hash codes and
two string methods so it's actually just
a nice class to make sure that you have
data objects going throughout your
system so now that we have defined our
use cases we can actually think about
how do we want our domain to look like
so we're going to have a domain layer
and we're gonna gonna have a product
entity so our product entity how does
this look like it's once again it's just
a simple data class and it has an ID and
a string this is something that is done
through the main modeling you can use
DDD for this and this in this instance
DDD is actually a bit overkill because
we're just making a simple crud system
but you can choose to use DDD for this
and then you're gonna have a single
gateway so what is a gateway it actually
allows you to get the main entities from
your system so how does it look like
so it has two to two methods it has
finds products with a query and it
returns a list of products and then you
have a creates methods that takes the
product and returns a string and the
string is the ID of the product that's
got created and we use a ADA class to
have a as the arguments for defined
methods why I'm doing that it's going to
be very clear in a while when I start
implementing the implementation of the
of the use case so now that we have our
domain defined and we have our
implemented we have our use cases
defined we can actually start
implementing our use cases using the
domain I can I don't need anything else
for the moment because my application
implementation cannot access anything
else but the domain and the application
API so what I built here this is built
around a Springwood application so
you're just going to have a single
spring boot configuration class which
are some components coming so let's
start with the fur with the fine
products
apollomon define products use case and
it gets the product gateway as an
argument which is Auto wired by default
thanks to the new spring boots and magic
it implements the fine methods and it
uses a it cuts the the products of the
of the system and that returns actually
a list of products but I don't want to
return my products directly into my
external system I want to use response
models you could use a map method for
this but Kotlin actually has a very nice
system of extension methods which allows
you to to add a methods to a to any
object within the scope of your system
for example here to use case responsible
that actually returns a use case
response and map and does the mapping
here this allows you to make a very
clean code within your within your
implementation of your use case without
having explicit mapping around here one
of the fun parts about this is that this
method only exists within the concept of
this implementation for example this
actually adds a methods to the product
but if I go to the domain layer and try
to do say I this method actually doesn't
exist within the domain layer it just
exists within the application
implementation layer so we're going to
do the same thing we're to create
products so it gets in an applique a
product gateway and it gets it gets a
request which is the create product
which contains a name and it returns a
response which is the string it calls
the product gateway and it uses the
request object and then again a to
domain that to domain does not exist
because it once again we're going to
make a extension methods to change our
our use case request model in
a domain model so now we actually have
very nice clean codes within our
implementation of our use case and then
you can just use that system if we try
to run this for example I always ready
made a mean partition it's not going to
work because we do not have a
implementation of our product gateway
yet how does the main partition look
like with just the main application a
main methods with a spring boot
application inside of it and the wiring
actually just imports all the different
contexts of the different layers so the
two infrastructural layers and in the
use case implementation layer so now we
can actually implement the
infrastructure layers I'll start with
the the persistence layer and I'll
implement that I've chosen to use
MongoDB here because it's easier to
setup and to make sure that everything
works so we're going to make a single
document and the document
representation of our domain model
within our system as you are already
seen we have different representations
of every aspect in our system and we
have clear boundaries within our systems
for example you have your product you
have your responsible level products and
you have the persistence implementation
of that product in this case it's
product documents because we're using
MongoDB and now we can implement the
product gateway so I'm using spring data
for for easy access so I'm going to make
a repository
which is actually just a plain spring
top-up Beijing and sorting repository
that allows you to do some quite
operations on product documents and it
also has a query by example executor
which I will show you later on what it
actually does now we have a basic method
find by name contains that uses spring
doghouse name conventions to create a
query for getting products by it name so
this actually with yeah okay this
actually should return something where
this is not going to work
and now we can implement our gateway
that actually gets domain entities from
our MongoDB so I can implement that
gateway
and once again we have an extension
method for example here you have our
product and we want to make sure that we
can represent that domain object as a
persistence model you cannot use that
inside the domain model because you do
not have any Mongo dependencies inside
your domain model so we can use an
extension method once again here to make
sure that we have that method in our
system so there we go so we actually add
a new method to products that creates a
product documents based on the internal
state of that product so now we actually
have a implementation that should run
already but we can't do anything without
with with T with the code because you
know we don't have any you don't have
any rest interfaces or we have a web
interfaces to actually expose the use
cases to the outside world so here comes
the web interface i explicitly chose not
to use a rest interface because
everybody uses that so I'm going to use
something a little less a little less
known which is JSON RPC and we can use a
once again we need to represent our
response models to the outside world
these are all view models these do the
translation between our response models
and for example JSON specific
presentation logic in this case it would
be a bit overkill because we're just
using the same structure over and over
but for example what you could have is
that you have a certain date and your
domain or a response model and you want
to have it represented in a certain
specific way to the outside world and
you're going to have a different data
structure that defines that that's
formals
so I'm going to create a mole which is a
Pollock Jason which has a an ID and a
string and then we can actually build
our Jason service so how that just RPC
works it you have to define an interface
of a service it has a find products and
a create products methods and a certain
part on which the Jason RPC service is
exposed and then we can implement this
into a real real service
go so the end it actually gets the the
different use cases so like I said with
the interface segregation what you could
have is that in an older system you're
going to have a single service that's
being injected and you can use these
different methods on that service now in
clean architecture you're going to use
different objects and use functional
interfaces with one single method that
does one specific thing so you can
imagine if you also have a very large
web web service that you're going to
have a lot of use cases that you're
going to be able to eight you'll have to
inject into your system once again we
have our our find products which
actually returns a a response which has
a list of products but we do not have a
methods to map that response to review
models so we can use an extension once
again so that actually adds a to Jason
list to our to our response model and
just Maps all the products within that
response model to a product Jason let's
make sure that you have very clean
separation of all your concepts in your
system so now we have a complete
implementation of our application and
now we can run this
we go
and we can do a find products which will
return a value that already certain
previously into the system or I can use
a create products methods for example
the devoxx sandwich that returns the ID
that i have in my system and if I do my
fine again and I'll get two products so
this is actually just a plain crud
system that is implemented completely
using clean architecture concepts within
within our code but now how can we test
this for example you have two ways of
testing this you can use complete
isolation you have your single layer
that you can use using mocks or you can
choose to include certain dependencies
that are not available at runtime within
your test scope for example if you look
at the build file i will use
presentation mode again here
test compile for my for my application
implementation I'm able to use the test
output of my persistence layer i'm item
in layer those are to my my domain layer
is accessible from my application
implementation but IAM for persistence
layer is not so this actually allows me
to make tests throughout the entire
layers and I'm going to show you another
way which is the using mocks in the and
the web layer which does not have any
extra dependencies
besides the spring and the JSF RPC
implementations so first I'm going to
show you the test with the mocks
so you just mock out the different use
cases you create a product controller
you add some behavior to your to your
mocks and then you actually you call
your controller and you assert that your
controller actually does the thing that
it's supposed to do this is completely
in isolation you can use this you don't
need any other layer in order to test
this but what are you actually testing
you're testing your mocks if your mocks
are wrong you're actually not testing
anything you're you're doing a
self-fulfilling prophecy so what I
actually prefer is using other layers
within your test system to test the real
system and the real implementation in
your application so what I'm what I'm
using here is a precision that's config
which overrides the real configuration
and instead of using a real MongoDB it
uses fungal which is a fake Mongo and
it's an memory implementation of Mongo
that just fakes a lot of behavior that
mangu provides so if I implement if I
create a dust you have a lot of this
will actually use a a spring context and
will start up a spring context in your
system and that is something that is a
bit awkward within within Kotlin for
example if you want to use which in unit
5 and spring extensions for the moment
you have to use the lid in it with Auto
wires because if you if you don't do
that it's going to complain that the
value is not assigned yet but now you
can actually use the entire system from
the use case down to the to the
implementation layer of the of the
persistence so if we run this this will
work so we're going to run the tests
there we go so you see it's started up
an entire tests in spring test context
and uses that to test your entire
application if you use the mocks you're
just going to you're not going to start
up as spring applications they're going
to be a bit faster but once again you're
not really testing your application
you're just testing the mocks and some
of the implementation in your system so
to recap with it with Copeland it's
actually very easy to implement clean
architecture because it allows you to
use stuff like in extension methods to
add behavior to certain parts of your
system
that is only accessible within the
defined layers of your clean
architecture you can use you can add
methods on your domain model that
applies to your persistence or you talk
to your to your use case implementation
model without actually having to change
any of the dependencies and adhering to
all the nice layers within your system
and that's about it so if there are any
questions I'm more than willing to
answer any and all of your questions oh
yeah
okay so the question was that whether
all the different data structures are
actually necessary within a clean
architecture to have those duplication
of those different data structures well
you can actually be pragmatic to take a
pragmatic approach there you can for
example say okay I'm going to directly
expose my my response mode to the
outside world
that's perfectly possible you just have
to add another dependency you just your
your infrastructure web layer is able to
access that's responsible and you don't
need really need to do the mapping from
as responsible to adjacent so if you say
okay those objects are always the same
okay you can just implement those right
away and expose them to your rest
service order to reach a star PC service
that's perfectly possible you can also
for example choose to directly implement
your directly persister the main model
into your persistence system that's
perfectly possible for example with GPA
that would mean that you have to add
some JP annotations on your domain model
which in isn't really clean because
sometimes you have to do some very
awkward magic to have JPA
work nicely within within your system
for example if you have collections or
embedded and better data structures but
you can choose to do so what I've
actually shown here is the most clean
implementation the most pure
implementation of clean architecture
with very defined boundaries if you want
to use certain objects within other lays
without using the decoupling of the data
structures
that's perfectly possible and that's and
that's a compromise that you are allowed
to make but know that if you make a
compromise it can bite you and at a
later time for example if you want to
change something in the main model you
don't want to change your database and
you've directly exposed to a
directly persisted to the main model in
your database you're going to have some
fall back on that decision but that's
that's perfectly possible to do so other
questions yes what would be the
equivalent of the the extension method
in Java the problem is that Java does
not have the concept of extension
methods you're probably going to start
writing mappers you're going to have
mapping logic within the different
layers and you're going to call those
mappers to transform one entity into
another for example you're going to have
a mapper to change or the main model
into a persist model or your mapper to
have your responsible of your use case
into a view model you're going to have a
lot of mappers within your system this
is why a lot of people see clean
architects they go like oh my God all
those data structures there's all those
paper that I need to write
Coughlin's actually allows you to
alleviate some of that pain using
extension methods to make it a bit more
clean and not to be confronted with
mappers all over your system any other
questions ok thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>