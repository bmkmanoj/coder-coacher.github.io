<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>ScreenPlay: the next stage in automated acceptance testing by John Smart/Jan Molak | Coder Coacher - Coaching Coders</title><meta content="ScreenPlay: the next stage in automated acceptance testing by John Smart/Jan Molak - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>ScreenPlay: the next stage in automated acceptance testing by John Smart/Jan Molak</b></h2><h5 class="post__date">2016-11-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/4eODK3WS6cM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome my name's John Ferguson smart
this is yard Malik and today we are
going to be talking about automated
testing in a new way of doing automated
testing that I think will change your
view of how you approach automated
testing in the future it's an approach
that we like to call the screenplay
doesn't come from us it's been around
for quite a while it was originally
imagined by a colleague of ours called
Anthony Meccano
some years ago and it has been evolving
and developing in different names ever
since and this green play talk is going
to explain a number of things about how
it works how you can apply it in your
own projects and how it can benefit your
software development process not just
from the point of view of test
automation but from the point of view of
actually making it helping you to write
better software also makes testing fun I
have a slight clicking issue one of the
big principles behind this whole process
why are we doing this is that what we
find in a lot of teams that we go into
it's when they do test automation it
becomes a bit of a chore so anyone had
that sort of experience no one that's
interesting yeah becomes a bit of a
chore it becomes a fairly high mate and
it's probe sounds something that takes a
lot of effort to maintain the test can
become fragile the test can become
difficult to maintain difficult to
extend and it ends up taking more effort
to actually keep track of the tests to
maintain the tests then to then the
value you're getting out of them and so
one of the concepts that we like to
think of is in terms of making your
tests sustainable making the tests land
into the
process so that you don't actually have
that extra overhead was just a natural
part of your development process and
that helps us shift away from the idea
of tests that merely verify what's
already been done so writing regression
tests after the codes been done back to
actually helping making the tests help
verify that you're actually building
software that makes a difference so
there are three aspects of building
sustainable automated tests that we
would like to talk to you about today
and they're actually related to the
model that you see in front of you right
now
so you're probably familiar this one
that's any one of you read Eric Ries
Lean Startup okay cool
quite a few guys so Eric talks about
this cycle of learning building and
measuring and the cycle that should be
applied whenever you develop new
features of developing new products or
new new companies and what we found is
that this this model could be applied to
your to building your automated tests as
well so the way we would like to look at
it is that the requirements discovery
process is very similar to to the
learning experience
well once we understand what we need to
build what we obviously need to deliver
a piece of functionality and certain
practices of software craftsmanship that
help us develop software that is
sustainable is to extend and scale and
so on and obviously we need to measure
the impact of our automated test impact
of our software and that's part of the
of the last cycle the measure cycle so
the first aspect that we want to talk
about is how to test blend into
requirement discovery so some of you may
have heard of behavior driven
development any one one or two I write a
book on it
how do our tests blend in with
behavior-driven development I'll give
you a little hint behavior-driven
development has it's not actually about
automated testing but automated testing
really helps with behavior driven
development if you do it properly so
when we look at the requirements side of
things what we found there's some
interesting numbers yarn families
actually I have yes and it's actually
quite difficult to look up some actual
studies in the field because many people
just quote a number without the source
right so I've actually gone into trouble
to figure out what the sources actually
are so it turns out that over the last
30 years or so several studies have been
done on how unclear and ambiguous and
incorrect requirements affect the way we
develop software and affect the number
of defects we find in this software so
it turns out that between 44 and 80% of
all the bugs in software are caused by
problems with requirements so it seems
like it makes sense to address this
issue as part of our test automation
effort because otherwise if we test a
wrong requirement or we verify that
application works according to a
requirement that's incorrect well we're
just building wrong software right so it
doesn't make sense so what we find is
that if we combine behavior development
and few other concepts like domain
driven design people know that domain
driven design domain-specific languages
for your for your requirements and user
centered design we can take our tests to
a totally new level yeah so one of the
techniques from user centered design
field is called hierarchical task
analysis so instead of designing our
automated tests as a series of
interactions that a browser performs
with a system under test we could try to
look at this process from slightly
different perspective so instead of
focusing on the browser we could focus
on
the actor the user that wants to achieve
a certain goal by using our system and
in order to achieve this goal he'll need
to perform a number of tasks which then
consist of certain interactions with the
system so this change of thinking makes
us focus more on the user rather than
the implementation data rather than the
the browser itself and so what we see
here is a little example of what this
sort of layering listen approach
produces so here we have a very simple
example with a to-do list application
which I've used in some other tutorials
in which you can find on in the in the
Serenity BDD documentation quite
prominently both for the Java and the
JavaScript versions it's what we use for
our smoke tests and what we have here is
effectively a hierarchy of very simple
requirements now in real applications
that can actually become more
complicated than this but you still get
these layers you still get this approach
the user has to achieve something the
user goes in to use the system to have
some sort of outcome and if you don't
understand where that outcome is coming
from and if you don't document explain
what you're doing then your tests become
a lot less useful so we start off with
trying to figure out what the goals are
what the user is actually trying to
achieve for their business or for their
business goals what they what they're
going to get out of the system
then to achieve a goal the user has to
do some stuff perform tasks now if we're
talking about software then typically
those tasks will involve interacting so
interactions with the system the
interactions may involve things like
typing values into fields clicking
buttons and so forth the problem we find
is most tests start off at the
interaction level most automated
selenium tests and even you see
tutorials on cucumber and they make me
wince because they're pure interactions
they're just sequence
of clicks click select click select
inter inter click about a hundred of
them have you insane things like that
given I click on the button and I enter
this fear then what the what am i doing
yeah we don't want that that's really
bad that's not how you write this and
one of the reason why this is bad is
because if you show this sort of test
scraped to a business person to a
product owner and ask them to verify
their the flow that their logic behind
it the business logic behind it they'll
most of the time just say yeah I just
trust you yeah it works fine I'm sure
it's good and ignore the whole thing and
because they start to ignore the test
automation at some point they might come
to a conclusion that you know if those
tests that's know became brittle over
time becomes slow as well
well the perhaps we should just not turn
them off deploy software to production
tested there everybody just stuff in
production right does everybody here
test software in production and that's
how you do it that way users are for
know what to say good news huh yeah do
this we're going to happen yeah you
control so here we have a example of a
cucumber simple is everybody okay with
cucumber gherkin so forth could BJ
behave doesn't matter it could be
anything
as long as it's sort of gherkin ish we
have a feature and our feature is you
told me this was gonna happen didn't you
yeah like a couple of times yeah so we
have our feature our feature is a very
simple one where James out is her
persona James wants to be able to focus
on the things he has to do the
outstanding item so he wants to be able
to filter he's to-do list it only see
the things that haven't been done yeah
did this quite a few interesting
subtleties here so first of all as you
see here if this laser works here it
does we use the persona of James right
so very often when we see feature files
written in cucumber those would refer to
I rather than the persona and there's a
trouble with that there is a
trouble that's raised to empathy
whenever we describe a feature from the
point of view of ourselves we also
automatically think about all the
limitations that we ourselves have so we
think about the person sitting in nice
and close the office now it's warm who
is Western already access to coffee what
or whatever else who has a nice big
screen a nice comfortable chair and so
on now if we try to combine the findings
of our user experience process so to try
to combine the ideas of personas
actually think about those personas when
we design automated tests we empathize
more with the user so if we think of
James as a guy who's using our
application on a busy tube he's using
this on a mobile mate perhaps he doesn't
have no internet connection all the time
and so on
we might actually come up with scenarios
that are much more comprehensive than
what would have come up with if we were
just thinking from the point of view of
ourselves so if we have a look at this
scenario we've got our actor James who
has a particular goal in order to focus
on the outstanding out item so you can
see this structure that we can actually
get to visualize in our feature files if
we do them properly we have our goal in
order to focus on outstanding items and
we have some tasks so Jane just got a
list with some items in it he completes
one item he filters the item so these
are all tasks yeah and then we've got a
sort of task it's not really tasks
actually a question because you're
asking a question about the state of the
system that same thing same level we've
got these taught the goal to achieve
those goals actor has to do a certain
number of things and very often that's
where the the main modeling of our tests
scripts or test scenarios ends so at
this level we still have those
high-level business goals business tasks
expressed in domain language they're
nice they're not implementation specific
and everything's perfect here but what
we find is very often trouble starts at
the step definition level
where this whole domain knowledge
evaporates suddenly and we start talking
about webdriver clicking webdriver
entering values and so on so what we'd
like to show is how we can avoid this
sort of problem so when we have at are
any of those tasks are actually all of
the tasks actually can map to more
low-level actions so we might have
actions which we might describe as
completer to-do item or filter a list or
expect to see get a coffee so these are
not but these can be viewed as building
blocks as reusable action or tasks that
you can use to implement this test but
also other tests and this is sort of the
heart of the idea of this the screenplay
pattern rather than expressing your
tests in terms of interactions with the
UI you express your test in terms of
what the business user what the actor is
trying to achieve express your test in
terms of business tasks not in terms of
interactions this is quite interesting
as well because this this simple switch
allows us to think about those tasks as
or composites of other lower-level ones
so for example to start with the
application of start with a to-do list
containing it means to open the browser
resize the browser window add an item
and so on and we could take this further
so we could define a task to add an item
to a to-do list us entering the value
into a field hitting the enter key and
so on and the interesting thing here is
that there's only a finite number of
tasks that the user can perform in our
application but there's a much larger
number of scenarios then there's a lot
number of tasks so this sort of model
leads to a very high code reuse across
the codebase in fact we've seen
applications where you get almost at 80%
code reuse of these components between
tests which makes us obviously the
scalability of these tests for
significant it means that there's a lot
less code to write and a lot less code
for people to understand when they come
on board and try and start being
productive with an existing test read
what we see a lot in our client sites is
you'll have teams not of one or two
testers but of ten or fifteen or twenty
testers and you'll get a certain amount
of churn obviously so people have to be
able to come on board and understand how
the tests work and how they become
productive quite quickly and that's very
difficult if you have tests that are
basically just a sequence of clicks or
even tests that are a notch higher level
but just interacting with pages it's
very hard to get people on board and up
to speed quickly whereas with this
approach we find that people can relate
much more easily to argue these if I
understand the business domain I
understand what the application does in
business terms I can take these tasks
and reuse them and compose them and
modify them when I'm getting when I get
comfortable with that I can look into
the details and see what they do at a
lower level at the interaction level so
it's a much smoother ramp up for people
coming onto the project we find that
really really impressive so now the
question is how do we actually implement
it right because oh it's very nice to
have a model but model without the
implementation is just just an idea of
you can't really use it which leads on
to the next spot 40 to 70 percent this
is and I've actually seen hayver so
sometimes it goes through 100 percent
but that's a hundred percent it's the
point at which the test we gets thrown
away and rebuilt from scratch we were
talking to one client where they for the
last 12 months they've actually every
three months been writing tests
automated tests in every three months
they'll ditch it and start again because
the tests just become so so hard to
maintain and what we find is in a lot of
projects or environments testing is kind
of a second-class citizen it's not rear
diff scripting anyone could do it yeah
yeah and you end up with very you don't
have the same attention applied to
automate the testing as you do in
production code or if you applied the
same level of care as we see it
automated testing to your production
code I'd be really worried about the
production code but what we really need
to do is automate the testing is an
engineering skill it needs to be done
with care with attention you need to
take pride in the code that you're
writing and the only way to get these
figures down actually keep a nice high
maintenance or low maintenance cost at
high productivity and high output and
enjoyable work is to take pride in the
code and apply the same principles of
software craftsmanship your clean coding
your refactoring your readable code your
dear cells all of this good stuff you
want to apply it to your test automation
as well as to your your production code
and this may sound quite obvious but we
see it very very rarely applied in
practice not to this level anyway so now
we're going to have a look at how we
would actually implement this or how we
implement it so this is where using
serenity BDD which is this is the Java
version there's also a Java JavaScript
version which has very similar code it
looks very similar it's a very similar
behavior produce the same reports and so
forth and the gen but the general
approach is actually something you could
apply in any language
it's just that serenity BDD provides you
a lot of things out of the box you don't
have to do for yourself yeah and the
reason why we use that testing library
Lex certainty BDD is because now if you
think about it
applying the same principles of software
craftsmanship is your testicle as your
production code is an investment right
it takes time and it's sometimes
difficult to justify spending a lot of
time on automated tests it's difficult
to explain to the business that oh this
is something that's that's worth doing
so building something from scratch
yourself takes time is expensive so it
might be actually better to use surface
available as being tested so no that's
us open source and free so if you think
about it many of us developers whenever
we start writing our first blog we would
start with actually writing the blog the
blog engine rather than the article so
similarly here we can use an open source
framework to just focus on the business
logic and implementing what actually
matters so a few things that serenity
does or the process it's really serenity
encourages you to work well it's not
just a tool it's a process that the tool
encourages and it helps you move towards
we someone refer to it as a gateway drug
for BDD you can tweet that so it's
basically the way you work in serenity
BDD gives you a very BDD feel to your
application even if you're writing tests
like we've seen teams that are forced to
write tests after because they start
their automation halfway through the
project so they've got a whole lot of
backlog that they need to automate but
they do it using a very BDD style and
then becomes very natural when you start
actually doing proper BDD and
collaboration and automating proper
acceptance criteria it's a very smooth
transition and this makes it much easier
to write tests that actually focus on
what's important focus on things that
are that the testament to validate so
you can highlight does a feature
actually do what it's supposed to do
it's much easier to focus at that level
if you're thinking of that level I don't
know whether you've ever noticed but
it's very hard to focus at several
levels at the same time if you're
focusing on what the clicks and the you
the clicks do what the input fields do
and so forth it's hard to simultaneously
focus on the flow and the outputs so if
all of your tests reads and in terms of
how you interact with a UI chances are
it's harder to concentrate on whether
you're actually achieving the goal or if
there are other better ways of achieving
those goals so the way we structure our
tests in serenity helps you focus on
these
little girls and switch between levels
as you need to and focus on the right
level at the right point in your
development yeah I think we should skip
to the action you think so yeah I think
so yeah they like it so you probably
remember this this little graph that we
showed you earlier
so actors want to achieve certain goals
and that's why they perform tasks starts
consist of interactions so how would
this work into in terms of actual
implementation so that's pretty much the
amount of code you need to set up an
actor well you get to call the actor
named and then give it the name of the
persona and if you combine it with the
personas that you use in your user
experience design process then you get a
nice mapping of the the persona
characteristic to the actual
functionalities are the person I uses
now actors can have abilities that
enable them to interact with the system
in this particular case we've got the
actor who has the ability to browse the
web with his browser but he could also
interact with our system using a HTTP
client or an FTP client or whatever else
we need in order to interact with the
application and he can have multiple
abilities and those abilities enable
interactions that's pretty much how you
structure the flow of tasks so you call
James Adams too and then pass a number
of tasks objects such as added to-do
item or pay well pay with a default
credit card or other product to the
basket so as you can see from the point
of view of code it's very very simple
and what we found is that you can get
people who've never written any code to
compose those sorts of test automation
scenarios very easily even if they don't
understand Java very well so you can get
a nice mixture of people on a test
automation team if you have one some of
them with more development experience
design those low-level interactions or
more complex interactions with the
system that actually have to call set an
external API and so on and you can get
the less experienced guys to compose the
test scenarios from those building
blocks and in the process of design
those test scenarios they'll actually
get to know the application better
they'll get more familiar with Java with
programming practices and at some point
they might also start developing their
own their own tasks now this is where
this is a key camp have people whose
cucumber JVM so you'll be kind of
familiar this approach to previous
examples actually j-unit so you can use
serenity neither Ju little cucumber or J
behave whatever you prefer and the code
under the hood is very similar so here
we have an actual step definition where
we're showing how you would map
something like James has a to-do list
containing whatever and here we map that
list to some items and we just say James
attempts to start with the to-do list
containing items so at the heart of the
screenplay patterns this idea of
building reusable blocks a bit like a
DSL you're writing your own domain
language around the business domain in
terms of what the business would
actually understand and that's really
important that's what gives you the
power to scale your tests in terms of
reusable building blocks that aren't at
the UI level or aren't at the
interaction level now this also leads to
much higher reusability because if you
think about it lots of those systems
will typically have a number of
components so let's say an e-commerce
system will have a checkout component a
search component and so on and often you
have different teams developing those so
what we found is that it's quite
effective for those teams to ship the
tasks that are required for their
component to be tested so then if at
some point you need to a full
integration test of the entire system
what you can do you can just now use
those tasks from different teams that
are basically just Java classes so you
can charge them up and serve them very
easily as you would any other Java code
and you can assemble those into much
more sophisticated sophisticated
end-to-end tests of the entire system
we've
the risk of duplicating the effort
across two parts so in this case what
are we showing here we've got a the
actual implementation of the of the task
so you remember we had those lay that
layered approach where we had business
starts going down and inside business
tasks we have interactions with the UI
and you can see actually this is looks
very similar to the previous class
because all we're doing is using the
same approach we got an actor who
attempts to do stuff actor attempts to
do at least all things and those things
are evil tasks or interactions and in
this case we've got the things are we're
opening a browser and then we're calling
a business stuff that we've already
referred to so add some to-do items so
you can see here the reusability so some
all of the UI components come out of the
box you don't have to actually write
them for yourself but you are writing
these business once or in this case
added to-do item and there's one more
interesting thing here so as you'll
notice here at the top we've got a
little step annotation so maybe let's
start with a quick question how many of
you enjoy writing documentation okay
maybe I'll repeat the question so how
many of you do enjoy writing
documentation one two okay about five
right again no I think the answer so the
trouble is that no documentation is if
testing is an afterthought
then documentation is very often an
afterthought after testing so it's very
often omitted and whenever we actually
see documentation of a software system
is usually not up-to-date or it's just
not relevant and we could know tossed
into the intervener so what this little
annotation here is doing is it allows
you to map the specific tasks class to a
more human readable description of it
and this is used when you execute the
tests and generate living documentation
from those so what we can do is when we
execute those tests we map every single
task to a human readable description we
can accompany it optionally with a
screenshot and that's how we can get
documentation pretty much for free
part of our test automation process and
here we can see what it actually looks
like under the hood you go down into a
how does the other to-do list task work
well it works by we enter a value into a
field and then we hit return so if you
show that to or test her they'll be able
to pick that up quite quickly because
it's pretty much autocomplete and away
you go there are a number of UI
interaction tasks that you can use that
a pretty much map to everything you
normally do with webdriver and it makes
it very easy for testers to actually
relate to this and use it without a
great deal of training in in webdriver
in the subtleties of the webdriver API
and this brings us to the third element
which is the feedback cycle so if your
tests are run but all they do is give
you red or green well that's useful
feedback that's not really going to tell
you whether you can go into production
whether you can release your software
one of the big things about serenity as
we try and serenity is a living
documentation tool it's what we call
release gives release readiness
reporting at lets you know whether
you're actually ready to release a
software software component weather
features are ready to go whether a
release will actually work in production
whether everything that we promised has
actually been built and this idea you
don't just start getting the test
reports it's very hard to have this
visibility in classic test reports so it
will become more apparent when we show
you some of the examples of this
documentation but the reason what we
think is very important to have this
sort of documentation in place is
because it helps to build trust with
different parties involved in software
development
so trust with the business trust with
with the software developer stress with
testers and so on and that's trust
that's that's very strong because it's
built on evidence because we can
actually prove that our software works
the way it's tended to work that it
covers the features
that is supposed to cover and it's not
just about us telling someone else I
don't yeah I tested this software on my
machine it works fine we can actually
prove it
and one of the big concepts of this
trust is thinking in terms of as I'll
say no levels of focus if you're
focusing on something at a very high
level it's hard to think at a low level
and vice-versa in reporting and command
feedback that's the same thing we have
what I call levels of communication so
we have for instance at a very high
level you want to know whether the
features you planned or promised to
deliver in a particular release are
actually working whether the ones that
are there are good to go whether whether
they've been completely completely
finished whether they're broken in a
traditional test report you can know
what's tested in a release readiness
report you want to know what also what
features have not been tested it's very
hard to get a test report to tell you
what's not tested so that's what we try
and do here as well when we go down a
level we can have a look at the actual
features how is a feature documented how
does it work does it do what the
business expected it to do and then if
we take it a notch down we can actually
see the details of examples how do what
steps are involved in a particular
example in a particular scenario how
does a particular goal play out how does
a task user accomplish a particular task
and this maps directly to our idea of
our capabilities our features and our
scenarios because at the higher level
we're reasoning in terms of goals and
capabilities and as we go down we think
more in terms of features then detailed
scenarios or examples of how those
features are actually delivered for
instance in this case you probably can't
read all the details but the I the this
is what we call a release readiness
report it's the highest level you can
see we have a list of capabilities
rather and not just a list of test
results it's a list of what capabilities
did you say you're going to deliver we
can see we've got some here that are red
some here that are orange ones
completely green ones got a little bit
of blue
in it the blue means pending things that
haven't been completed red obviously
means it's broken but blue is
interesting because blue means that
you've engaged you've said you're going
to deliver something but it hasn't
actually been tested yet and if it's not
tested in agile turns in BDD terms it's
not tested it's not done your test is
your feedback your documentation that
the feature has actually been delivered
and so when we have a report like this
where we have some blue and some gray
which means totally not implemented we
get the impression of okay these
features are done but this one's not
really finished we haven't done
everything we said we'd do is that good
or not it also helps with with our BDD
process as well so those of you who use
BDD how many of you do the three amigos
meeting where we define the examples and
scenarios and so on okay so some of us
cool and how many of you try to write
they're given when then gherkin
scenarios during those meetings okay and
how do you find it that it's easy to
engage with the business by writing
those scenarios how easy it is to get
those guys to do them with you and to
find their time yep oh one person cool
good job so what we found is that by
simply capturing some of the examples of
how a feature is supposed to work and
marking those suspending even before we
write the actual implementation and even
before we write the gherkin scenarios
the given one dance we can capture those
and report on those so we can at least
record that there have been some
examples provided and we guys will show
you a code demo of how this whole thing
works in a couple of minutes so as we go
down the stack we go from reliefs
readiness down into capabilities we'd go
further down into features and as we go
down we get more detailed and eventually
we get to the scenarios where we're
effectively documenting how a feature
works through a set of working
samples illustrator buskerud shot
Tiffany UI test but we're illustrating
the steps that the business the user
would actually do and you'll see we're
not talking about clicks here not
initially where where we are with the
James clicks on a complete button but
that's underneath at the top level we're
still just reasoning in terms of
business tasks just like we saw earlier
on when we were reasoning to the what do
you need to achieve at a certain level I
think it's like for a code demo you
think so yeah because no we're just
talking about slides and those days
would like to see something working I
guess anyone would see something working
or deep for this rise because we've got
some more slides if you want no code
okay cool okay so what I have here is an
application this is a live one
so probably won't work but this is a
real live application where you can do
things like book a train from London to
Brighton or for example and come up and
you'll come up with some results
hopefully if the network is Network gods
are favorable and you have to set the
date otherwise it has funny results bit
of a dodgy application this one this is
the applique I wanted to choose this
application because it's a little bit
closer to real world it is a real world
application so you get some of the real
world challenges rather than they are
smoke tests application and so what we
have here in our application this is a
can we see the hierarchy probably not
really very well let's start off with
something they'll be a little bit
familiar we have a feature file about
buying individual tickets we have
another feature file may be about buying
season tickets then we have some other
requirements we know we need to download
be able to access offline timetables and
view the timetables and so forth now you
notice these ones are pending and
and their pending is that nobody's
actually got around to doing them yet so
if we wanted to report on them we'd want
to note that they're in the list of
things to do but we don't want to
actually have the break because that
would be inaccurate they're not done yet
so we have them appearing as pending in
our reports if we go back to our by
individual test which is a little bit
more interesting here you'll notice
we've got we're talking about persona
earlier on and here we've got so Tracy
who wants to go from London to your crow
festival we've also got bill who loves
to go to Birmingham for a work trip and
we've got some little details about why
that what I do is is to give them
motivation this is very important from
the user the user experience point of
view it makes encourages people to have
a little bit more empathy about their
end users and understand where they're
coming from but I'm guessing you'd like
to see some code to yeah you think
yes so this is cucumber yeah here we
have the actual implementation of Tracy
has decided to check the available
tickets now you know earlier on we had
James who was an actor in cucumber what
we do is we say the actor called and it
will figure out what it will create an
actor for you so you can have multiple
actors you can even have several
different actors in the same scenario
and if you're doing a web test what's
quite cool is you can have multiple
different several actors and all all of
their own browsers let's see if you have
a workflow system we can have one actor
who submits an item to be processed or
to be to be dealt with another actor who
will pick it up in their own browser it
can go back and forth and so forth so
that's quite a natural way of modeling
the user interactions the user
experiences I don't think that you could
also give those actors different
abilities so for example one actor could
be using the web browser other one could
be using a mobile browser
and then let's have a look at the next
step so you notice here we had the actor
called persona now here we've got he or
she so when she looks at a tip a trip
from origin to destination leaving on a
particular day rather than saying the
name of the actor we just say the actor
in the spotlight so the previous actor
that you said that you invoked that you
call on the stage to use the metaphor
becomes the actor in the spotlight and
now this is the interesting bit
no clicks no selects no drop downs what
we're doing is a business task we're
finding tickets for a one-way trip from
a certain origin to a certain
destination leaving on a particular day
so again no user interaction we've got a
totally reusable component and if we
look at this second trip when he looks
for a return trip so we've got Bill
who's going on a wants to do a return
trip let's look at the code that's very
similar we've got fine tickets for a
return trip so from a user if you've got
a tester looking at this this is very
very accessible because it's expressing
things in business terms not in any sort
of UI or technical terms and that's
really important it's all about
reusability and composability and then
the third level she should be showing
the cheapest e-signal ticket price from
London to York we've summarized quite a
lot of checks here in fact we're
summarizing the outcome that we expect
now how do we implement that now in
serenity we have this idea called
questions so we say the actor in the
spotlight should and we can give a list
of questions or based statements
describing our expectations so we should
see that the lower vailable journeys
lowest price is present that the ticket
type is equal to what we expect that the
origin and destination are equal to what
we expect
now I don't know whether anyone saw the
J unit v talk where if one way you had
asserts a list of asserts where if one
is that failed the other ones would
still get evaluated anyone see that yeah
this is the same things if you don't
need J unit five and it works now I mean
so this is basically if any of those
checks fails the others will still get
evaluated it's not like a traditional
test where if webdriver tests were if
something breaks basically that's the
end of the game nothing else happens
you're you're left to your own devices
to figure it out what went wrong and you
don't know anything else so here if
we've got the ticket type is wrong we'll
still get to know whether the other
whether the stations are correctly
defined and as you can see there was
absolutely no magic there so all those
statements equal to ignore case or equal
to our just come quest matches so if any
custom ones you just create a custom
home quest not sure so that's pretty
much the standard way of doing
assertions in frameworks like J unit for
instance now let's have a look at how we
actually interact how these tasks get
broken down so this is a different
example to obviously to the one you saw
in the slides we have for instance a
one-way trip now in serenity you tend to
you in screenplay use a lot of builders
to create basically a DSL so what we
have here it's a little DSL that simply
gives you a different builder for each
type of trip so you write your own so
they're not a big deal so if we have a
one-way trip we're going to create this
little builder that where we define the
destination the departure station and
the day we're going to leave and
eventually we do this little magic thing
find one-way tickets and that's our
actual tasks that we build there's a
little bit of magic going on here with
the instrumented method that let's
serenity do its reporting if we go into
that tasks this is a little bit like the
code that we saw in the slides where we
have
the actor who attempts to do stuff so
we've got the attack the actor selecting
stations entering a day and clicking on
a button yeah so it's all very
composable now if this selecting the
station is actually a little bit
complicated because if we look at the
the actual that'll make the demo is
interesting well I'll describe it if you
go into the drop-down basically the
selector station it's looks like a
drop-down but it's not you type the type
to station it creates a list of
suggestions you click on the suggestion
it feels it in the JavaScript behind the
scene so it's actually relatively
non-trivial but what we've done here has
hidden it away in a reusable task or
interaction task so if we wanted to look
in the details
we've got enter the value station name
into a particular drop-down and then
click on the drop down entry with that
name so we hiding that detail in a
reusable UI interaction so you do a lot
of this reusable task and surrounded
it's very very composable makes it
really easy to create these tasks and
reuse them which is really really nice I
guess we should say show how we identify
elements URI as well yeah do we have the
internet already now we doubt it okay
all right so before we go there how many
of you guys use page objects in your
test automation ok and quick question
what is a good length of a page object
how many lines of code should it have it
okay for it to have I don't know 10 or
they usually get longer than that 50 is
50 still fine hundreds
we've seen some that actually reach a
thousand nines or more so we show you a
slightly more compact version of those
page objects as well so the idea of the
problem we find with large page objects
they become hard to maintain and the
idea of a page object is dates to 2009
nowadays the concept of a page is a
little bit different I mean what's a
page in a single page up you either get
a great big massive page object that's
everything you have to break it up into
little bits and pieces and that's fairly
arbitrary to do a hierarchy do you have
composition it gets complicated so what
we do in screenplays we keep the page
objects to a strict minimum and the kind
of page objects but not really they're
just basically classes that know where
to identify things or to find things on
a page that we're interested in for a
particular task for instance here we
have the journey details actually let's
go back to the station
select the station this is our reusable
tasks we remember and we have our the
station drop down and the drop down
entry if we look at this relatively big
one because it actually represents the
whole block of selecting a station
picking whether it's return or signal
and so forth that's a relatively large
page object in screenplay terms and
you'll notice what it's really doing is
basically identifying where to find
stuff now you'll see it's got this funny
target class we use the target client we
could use buys or selenium classic
selenium finders but we use a target
class because it lets us identify what
we're finding in a readable way that we
place in the report so you don't have to
talk about a CSS classes or XPath or
nasty things like that you can actually
describe what you're trying to identify
and that that's what you'll see in the
reports and you notice here we've got
some funky ones where you can actually
have variable substitution so you would
say the drop down entry
and we've got a little variable here so
the drop down entry for a particular
station name so you can do dynamic
targets as well and so we've got around
10 minutes left so rather than running
the application without internet which
is probably relatively risky what I'm
going to do is show you what the reports
for the last run we read look like so
this is a real live report
now you remember all those tasks we had
those requirements we had that we hadn't
actually got round to doing that's a big
blue bit if we look into it but from
here you can see there's something
broken something running some things
that aren't done that's a list of test
results if you think in terms of
requirements it's quite different we got
to buy tickets which is a third working
a third broken as a third not done at
all and consult the timetables nothing
at all very it's very concise and very
it's a very nice way of seeing getting
an overview of what you're actually look
what you're actually going to deliver if
you deliver at this point in time so
let's look at the maybe huqin things so
but I think that we're capturing the
pending and not done requirements here
we are by no means suggesting that you
should capture all your requirements
before you start your project nothing
like that
we're just saying that you know if you
learn about the new requirement or a new
scenario it's better to capture it in
code and on a version control there are
some sticky notes somewhere and so let's
just step into the requirements or into
one of the test reports so here's one
where we have tracer you remember those
bits of information that we had in the
feature files that give some context we
try and reflect that in the report so
you see all that information you get the
context for what the requirement is that
what the scenario is trying to show not
just some checks and so here we've got
given the trace he wants to buy some
tickets she wants to go from London to
York tomorrow and she should see the
ticket price for London to York and how
does that work well inside we've got
quite a complicated sequence of tasks
and interactions but from a top level
it's just summarized in this one level
one step but here if we wanted to see
the details we can look at the
screenshots and step through them we
could go in here and have a sort of
comic strip version where we step
through the tasks and anyway as you can
see up the top here we've got the tasks
that's actually being displayed and we
can see what's going what's actually
going on which is quite nice and if we
want to see how whether it actually
worked
you remember those asserts we showed at
the end we see the least here and one
other thing which is really nice
remember the target had those little
texts rather than CSS here we notice
we're saying where clicky on the drop
down entry London or where well that one
wasn't configured properly we're
clicking on the buy tickets button we're
describing the interactions in a
readable form not in terms of CSS if
something goes wrong on the other hand
it will tell you so there's one of these
which went drastically wrong and we can
see that says immediately oh no such
element to timed out when I was looking
for the place header price to be
displayed so it wasn't fired obvious for
some reason that didn't get to the final
page so when you get an error that makes
it a bit easier to troubleshoot does
tell you what you need to know but if
you're not interested in the CSS
selectors you just want to know how does
it behave that's cooled or just tell you
what you're trying to do in terms of
business flow and this helps address the
needs of different audiences as well
because the business guys are hardly
ever interested in the XPath that you
use to write an automated test they're
more interested in the actual logic has
been implemented especially for for
systems were out it is important
I'd like trade trading systems for
instance or banking systems
however on the other hand when things go
wrong it's usually a developer or a
tester reviewing the test report who
need to understand what exactly happened
and that's when we show the stack traces
that's when we show the XPath and so on
because that's actually useful in this
context so that's pretty much all we
have time for except for well leave a
little bit of time for questions this
code is available on if I have my slides
back this code is available on in this
URL or will be available as soon as we
upload the final version so if you want
to take a photocopy of that a photo of
that you'll be able to play around with
this at home but with that I think we
can open the floor to questions we've
got about five minutes for questions if
anyone wants to ask any question go to a
microphone so I can get recorded any
questions are the stickers as well you
know they mentioned the stickers before
we forget we have stickers okay well
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>