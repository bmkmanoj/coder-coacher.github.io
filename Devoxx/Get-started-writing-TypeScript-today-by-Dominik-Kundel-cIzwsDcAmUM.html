<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Get started writing TypeScript today! by Dominik Kundel | Coder Coacher - Coaching Coders</title><meta content="Get started writing TypeScript today! by Dominik Kundel - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Get started writing TypeScript today! by Dominik Kundel</b></h2><h5 class="post__date">2016-11-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/cIzwsDcAmUM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright um thanks everyone for coming my
name is Dominic I'm I work as a
developer evangelist for a company
called twilio a quick show of hands how
many of you know what twilio is all
right that's not too many so far just to
give you a quick idea totally as a cloud
communications platform that allows you
as a developer to easily add SMS voice
video or other means of communication to
your applications using simple REST API
sick blind side SDKs but today I'm going
to talk to you about typescript and
essentially i'm going to give you a
knight introduction about what types
would actually is why you might want to
consider it and especially the
interesting part how you can get started
with it um quick disclaimer there's
going to be lots of live coding in this
talk um so what is typescript um so
typescript started off as a project by
Microsoft and open source project um
trying to solve a couple of problems
that I'm going to address in a second or
but nowadays it's also being used by
companies like Google for example for
the angular 2 project arm so overall
typescript defines itself as a superset
of JavaScript um what that means is if
this is all the language features that
come with or ES 5 so that's the
JavaScript standard that was valid until
last year then this is everything that
came afterwards with es2015 as well as
the two features that were introduced
this year with is 2016 um and then this
is everything that typescript supports
also the bottom line here is that every
valid JavaScript is at the same time
valid typescript and this is a very
important thing to to remember
throughout the talk um and because every
valid typescript is village everywhere
that javascript is villa typescript on
we also first need to talk a bit about
javascript before we can actually figure
out why we need typescript and also can
write proper typescript that will solve
problems for us so let me jump into the
node.js rebel to show you a couple of
things on so all right um so this is big
enough cool um so if you've ever written
any line of JavaScript you probably know
that the the traditional way to declare
variable is by using VAR or nowadays
constant let arm which were introduced
with es2015 oh but the bottom line here
is that you use any of the three and
then you give it a name and you can
assign it something like foo is 42 and
now we have a variable foo armed with
the value 42 um and the thing here is
that contrary to languages like Java or
C++ or something we do not actually
declare a type um and this typically
leads to this or illusion that
JavaScript isn't aware of types at all
and that's actually not the case so
there's a type of operator that allows
us to check the types of different a
different objects so we can check the
type of foo and that's a number so
there's no differentiation between
integers and floating-point numbers
they're just numbers which are under the
hood floating-point numbers similarly we
can check for Strings on them they're
obviously bullion's oh there is
functions so if we create an empty
function um then there is objects so
that's just this curly brace thing that
you might know it's jason as well um so
we have the object unfortunately this
doesn't work with everything um so the
type of an array is object because the
underlying implementation actually
implements in their rate as an object um
so we can't use that here but this
allows us to at least check first of all
the built-in types um unfortunately
javascript isn't really
strict about these types though so if we
try to do something with types where
it's not really sure it just determines
what it should do and that means that we
can if we for example try to add two
arrays um it figures out well I can't
really add to erase so I'm just going to
cast both two strings and then
concatenate the two so an empty empty
array is an empty string so we have an
empty string as a result however if we
actually add two objects or we get the
stringed version of the object even
though even if it would have properties
it would just show this um and then
because that makes sense we obviously
have this one if we change these like
you should be able to with math operator
like plus you actually get a number um
so bottom line here is you can't really
rely on what type javascript is going to
do here um a couple of other things
there's actually another type that is
built-in and that's the type undefined
so that's typically when we have a very
able created that isn't assigned yet or
if we don't pass an argument to a
function and the argument would be
undefined um there's also null but null
list of type object and then because
there are a couple of these weird things
on JavaScript has a couple of helper
functions like array is array that
allows us to actually check if something
is an array on one more weird thing just
for the fun of it anyone know the type
of a new string quick hint it's not a
string it's an object until we call to
string on it um so this way we can get a
string but the bottom line here is that
it likes to cast things the way it
pretty well it's the easiest for it so
um if we have a string and we add a
number to it it casts the number to a
string but if we subtract a number by
cass bow to a number and then foo is not
a number so it's like all right cool so
the result is not a number um all right
so so much to our quick
look into on the world of JavaScript or
so as you've seen the bottom line here
is that there are types in Java Script
but javascript isn't really um
consistent about them because it just
tries to keep your code running on and
this means that in big projects
especially this can quickly turn into a
mess because say you wrote a function
and your colleague arm just roughly
reads or real functions I alright that
seems to do what I wanted to do and
calls it with the wrong parameters or
wrong types or something and as a result
sometime during a while your users using
your product suddenly it get they have
this the whole code implode in front of
their face and it's just not working at
all anymore and it's really hard to
catch these things because there is no
compile step in JavaScript where we
could catch this so what does typescript
offer to solve this problem the first
thing is that typescript is essentially
two things its first of all it's a
compiler that compiled the language
typescript to javascript add the normal
node module so you can either install it
using the node package manager and p.m.
or if you're using yarn already you can
use yarn to install it as well and you
can either install it globally which
will basically just add a command line
tool to your to your path that you can
then use or you can install it locally
for your project which is the
recommended very of approach because
this way you can have different versions
of typescript for different of your
project um and then there's typescript
the language and that essentially
extends JavaScript with a set of type
annotations um there's a couple of them
and I'm going to go through them um but
then the compiler uses these type
annotations to run type check in during
compile time and check if you're calling
functions correctly on top of that
typescript uses this whole knowledge
to then provide you with a better
development experience so they wrote a
very arm flexible on TS server what it's
called um that allows you to plug in
different IDEs for example in this and
leverage this to get additional
knowledge out of your code base and then
provide things like in microsoft call to
the intellisense so more in-depth
knowledge about your javascript or
typescript which functions are available
which signatures they are everything
that you're used to from typed language
all right so much your theory let's dig
into some code so let me clean the
screening in so I'm using Visual Studio
code so that's the arm editor that
Microsoft developed across platform and
that is especially all working well with
typescript arm and right now I have an
empty project here so if I alas this
well we currently only have the note
modules folder so that one has the
typescript compiler that I have
installed so that's version 2.0 point 7
or last night typescript actually
release the release candidate version
for 2.1 which has now support for things
like a single weight on to even down
compile that all right um and so let's
create a new file and we're just going
to call basics TS arm and in this file
as I said every valid JavaScript is
valid typescript so it's right just
hello devoxx to emphasize this and then
since this as well as javascript we can
just execute it immediately with node
and there you can see hello dev ox um
cool so let's say you have your writing
a new function for your code base and
it's the most naive version of a merge
function to merge to a race oh it's
going to take two inputs
and as I say it's a naive approach it
literally is going to loop over the
second arm up second array and then just
push that into the first one arm and
then return the first array and then we
call it so merge one two three four so
again there's a still normal JavaScript
so this just works out of the box we
don't need to compile this or anything
but obviously that's not how you would
call a function like this because why
wouldn't I just read one two three four
um instead what's more likely is that
you have somewhere in your code or two
variables that have been determined by
other function calls are inside your
code base and then you call this
function and this still works flawlessly
because it's still normal JavaScript um
but what might happen is that one of
your colleagues who's working on one of
the two functions that determine a and B
it's like well oh this function should
really return a string for whatever
reason so it's going to return seven
eight or something or 79 whatsoever and
what we see here is that this still
works um it doesn't do what it did
before in the way that we have now two
values that are just strings um but it
still works because all the things that
we were using in our function are
essentially the length property which a
string has and then the index our act
index operator to access a certain part
of the array but this also works on
strings so our code still works because
javascript doesn't really care so how
can we fix this using typescript to
ensure that your your colleagues might
not misuse your code or and cause
potential troubles so we can do this by
annotating first of all what we return
by
also what what the input is that we take
so in all these cases we use the Colin
and then specify what we return in our
case we just don't care what it contains
we just care that it's in the race so
I'm going to specify any array and then
our input one should be any array as
well and then input to as well and even
before saving and I think it's a bit
hard to see here but there's a small red
squirrel line here and if I hover over
it or without me having to have saved
the document or run the compiler the ID
already tells me that well the argument
of type string is not assignable to the
parameter of type any array and that is
because when we declared be we
immediately assigned it to a string and
typescript decided that because we
immediately assign it to a string this
is going to be a string from now on um
which also means that for example we
couldn't assign it to an array now on
for the very same reason um and this
means that we need to in order to
compile this now we would have to go
ahead and all fix our code obviously now
we can't execute this anymore because
this isn't valid JavaScript anymore this
is a typescript now so all of these type
annotations are types with typescript
specific and that means we need to use
the typescript compiler and we can find
this one I have it locally installed to
the project so we can find it a node
module to pin and then there's tsc and
then we just specify the file that we
want to compile um compile this and now
we have a basics JS file that we can
execute and then that works oh and from
this point on our function is a bit more
a bit safer but what if I mean we know
now that the that the string kind of
works as a second argument as well so
maybe your colleagues it's like well I
really liked that functionality for
whatever reason um in that case we can
use the union types to add that as
tential or type as well so we can say
that input 2 is really of any array or a
string on we do this by using this pipe
operator and from this point on if we
hover over input to anywhere this is a
string or an array now so we can put
again foo or something in here and the
compiler doesn't complain so this is
cool because this allows you to be a bit
more flexible and just specifying one
time but what if we want to build a more
generic merge function that can not only
merge two arrays but can also merge two
strings for example so we can go ahead
and actually write everywhere here
string arm and now we have a problem
that input one dozen half or estrela
doesn't have a push method if it's a
string and this is where we need to go
back and think of the quick JavaScript
introduction we had oh so what we can do
here is we can use the type of operator
and say input 1 is equal to string and
in that case we're just going to merge
and put one in input 2 i'm just going to
concatenate the two um and return that
and this means that now the compile
error here went away because Oh
typescript is smart enough to figure out
that hey I you use the type of operator
here so inside here this is clearly a
string and you're returning which means
outside of that suddenly it can't be a
string anymore it has to be an array 0 &amp;amp;
4 because of that the code now works on
all right so obviously this isn't really
maintainable if you if we use three
times the same Union type so we can also
declare new types so let's call this
merger bowl I'm just going to again
specify any array or union or string and
then we can get rid of it in all of
these places so if weary compile this
arm so we have right now or a type
definition here as well as only on the
input function input types and then we
have this type of check but if we look
at the compiled JavaScript on what what
you will see is that all of these type
annotations except of the type of
operator are gone and this is important
to remember when you're writing
typescript because typescript checks
your types during compile time it does
not do it explicitly during runtime you
need to do this yourself which means
that if you're writing for example a
client-side SDK or the private functions
are perfectly protected if you use
typescript for the ones that you exposed
to all your developer to developers to
use or you want to do additional
checking using type of operators or
checking if certain properties or passed
to really make sure that the input that
is being passed is valid so that you can
then afterwards rely on types trip to
kind of propagate this further if you
have a closed code base where you know
that everything is written in typescript
your less you need to do this less often
to do these type checks but the reason
why it doesn't throw in these type
checks by default is because typescript
doesn't want to or kind of put this
overhead load on to your code because
you should really decide when you think
it's worth doing these additional type
checks as a trade-off to performance
because if you would start typing
everything and it would throw in type of
operations everywhere your code would
just get bloated by the time it's being
compiled to JavaScript um all right so
let's create a different function so far
everything I wrote was standard es5
JavaScript as well as some typescript
but I said it also supports arm later
versions of Java Script like year's 2015
so let's create a new file or to build a
database and it's a very naive database
again we're just going to create a class
using the es2015 class classes arm and
it's going to have a content property
there's just going to be an empty object
and then we're going to have a set
function or with it that takes a key
which is a string and the value which is
a number doesn't return anything so it's
void and then we have a getter as well
which is which takes key and returns a
number so this one's going to return
this content key and this one is going
to set the content to the value um so
this is except of the three type
annotations is this normal es2015
there's nothing specific type script
about it um but there are a couple of
things we can do with this so first of
all let's actually use this class so all
we're just going to normally construct
it and then we're going to set a
property so go again with foo and 42 and
then we can set value foo TB get through
arm and then if we compile this and run
this
we get value of foods for you too now I
said there is nothing nothing really
specific about this as for except of
those type annotations the nice thing
though is that under the hood the D bjs
file arm so here you can see it actually
down trans piled the es2015 code to es5
code which means that oh if you want to
use year's 2015 or something and use it
in browsers that might not support it
yet you do not need to rely on
transpiler like babel or other things on
top of typescript if you're already
using typescript um alright so let's
jump back in here now we have a problem
and that's that we can actually access
the content part here and just write
something in here so we could write foo
close bar and if we move this below here
we're actually over writing this arm so
this defeats kind of the purpose because
we don't really want to expose this part
right so we could on the one hand use
the traditional approaches like scoping
and JavaScript to kind of make sure that
this is actually not accessible by right
wrapping the whole thing into a function
or something oh but the other thing that
typescript support is to declare
something as private or protected and
from this point on we actually get a
complaint here by the compiler that the
this property is private and therefore
we cannot access it during the outside
of the class again this is something
that when compiled is actually being
dropped so during runtime content is is
that a public property and this goes
back again to where you need to be aware
of if you're exposing something in the
library I'll be aware of this do your
checks if you're not doing that if
you're using it internally in your code
base for example on the server side or
doing this price of declaring something
as private is sufficient enough alright
so we have this now so we're protected
there
the other thing was that we were able to
just write anything to the content and
that's because we didn't type the
content object so if we check the type
of this content property it's off object
it doesn't it doesn't have any knowledge
about what what's the format of that
object and if we want to type objects or
we do this by using so-called interfaces
so we can create an interface like
internal database and in this interface
we can then specify either properties
like say a key with that is a number and
then if we type this as internal
database we get the complain that there
isn't a key property and that's because
the key here is actually the name of a
property we can make this an optional
property and get rid of that compiled a
compile-time issue but that's not really
the approach that we want to take
instead what we want to say is armed
really this object is holding a mapping
of keys that are strings to numbers on
and we can do this by wrapping this into
angular brackets enter into square
brackets and basically say this way that
we have a bunch of different keys that
are mad at our strings and they map two
numbers so we can save this and this
means now that if I would if I would
change the signature of the set function
to take a string as a value we get a
complaint that we can't assign string to
a number so we already got way safer
code here if we want to improve this
obviously we wouldn't want to have a
database that is that strictly typed in
the way that hey you can only use this
with numbers because that will mean that
suddenly you would copy paste this code
a bunch of times for different different
data types or instead we can we can use
generics so typescript supports generics
to do this so we can create a kind of
fictional type
we call it t data which is the type that
we're going to store and then we can
specify here then our internal database
is going to be a mapping of strings to
numbers but we could use this one also
for other data and then the same way we
can do this for classes as well so if we
change this here um we can then go ahead
and fix this up in the across the code
and then this means now we can specify
that we want to create a new database
with numbers and if we would change this
to strings later or we would hit again
the compiler issue that the strings
aren't assigned can't be assigned to a
number compu centers string let's change
this back to number though all right arm
so we're technically writing note code
right now and one thing that is nice is
if our database could trigger an event
every time we are adding new item to the
to the database and typically you would
the way you would do this a node is you
would extend something from the event
emitter class that is a built in class
in sidenote and the way we would grab
this class is by requiring it so we'd
write const events require events which
is the module and then we have the next
issue on which is it cannot find the
name require and that's because or the
require function isn't something that is
standardized by JavaScript it's actually
something note specific and we can hang
around this by declaring it so we can
say that there is a require that is off
type function and this would just hack
around it but it doesn't really give us
all the goodness of typescript is just
going to tell us then hey there's
there's something now that is required
um and instead we want to leverage
something that is called definitions so
definition files is the approach for
type is the approach that typescript
uses to provide typing information to
libraries that aren't written in
typescript that are written in
JavaScript so that you can augment them
with the additional information so take
for example jQuery or on a note module
that is written in pure JavaScript like
Express on where we wouldn't have the
type information unless we explicitly
write it and this is done through this
definition files the definition files if
you would compile them don't contain any
logic and therefore would be empty or
the result would be an empty javascript
file there are different ways to grab
these files and the past there were
tools like Taipings that allows you to
install these since typescript 2.0 the
approach is to use NPM for this um so
Microsoft build a tool that grabs from a
central github repository where people
provide the definition files for
different packages um and it
automatically namespaces them under the
app types which means that all we need
to do to install the types for node is
npm install at types / node for express
will be at types that express for it
jquery will be at type / express ed /
jquery there are some packages that
already come with a definition file so
for example moment j s or things such as
angular 2 that already written in
typescript or have them bundled up in
their packages you don't need to install
these and typescript is smart enough to
figure this out and find them inside the
node modules folder so we install this
awesome um luckily this file isn't too
big so I could rely on the internet here
um and then we just need to reopen this
because it kind of got stuck in the mode
that it doesn't exist but now we have
here you can see the note require all
part and that means that it actually it
recognized this now from node we can
also see this by the fact that it now
supports to get the deer name or the
file name or anything note specific is
now available as well we still have the
problem though that events is of type
any now and that means we can't access
the event emitter and the reason for
that is that we are just use the require
function but we didn't require a module
at least not according to typescript the
way we do that is actually by using the
es2015 import/export syntax also instead
of using the console operator we replace
it with the import and this means now
that we have the events module grabbed
and then what all we need to do is we
say extend events that event emitter and
from this point on we now extended this
from the event emitter class oh and that
means that we can now go in the setter
and use all of the different
functionalities here so you can see
suddenly we have all these additional
functions that are specific to the event
emitter class such as the omit function
that we can then use to trigger an event
such as edit and pass on the value and
then the same way we can use now DB on
let's move this one line up and listen
to the added event and then trigger a
function that just console logs add it
and the item and then we can compile
this again and we get this added for you
too so it trigger it triggered the event
emitter class oh if we look into the
generated JavaScript again we can see a
couple of things so first of all this
giant block here was attitude or so
that's just a quick kind of hack for um
known in JavaScript to do our prototype
will inheritance so that
just the inheritance if you can't use
the know the class syntax um so it just
uses it here and then you can see here
we are doing again the normal require
actually rather than the arm rather than
the import syntax and the reason why it
knew how to do this is that under the
hood the default module system that it
uses common jazz we could specify other
ones in the compiler or in a TS config
file so um let's create the TS config
file actually so the TS config is kind
of the center of your project so
previously I actually had to run arm tsc
and this file that i wanted to compile
which is not really what you want to do
later because you don't want to specify
every single file you want to compile
instead what you are typically want to
do is either list all the files that you
want to compile or one thing you can do
is are you can use the exclude list to
just specify these are not the things
that I want to compile just compile
everything else um because by default if
none of them is are specified type sir
is just going to compile every type
script file that it's going to find in
the directory and the sub directories
but we can also specify a bunch of
compiler options so the one that I
mentioned was common J the module on
there's a md es2015 a bunch of different
ones but we're going to keep it to
comment is because that's the one that
no Jess uses um and this also means that
now we can drop all of this arm gbgs4
thing and we can just run the compiler
and then we could execute the d bjs
again alright so let's jump back in here
arm so this is cool we just wrote a bit
more complex type strip things however
one thing that you might want to do is
because you probably already have an
existing JavaScript code base would be
to use the typescript that you just used
inside JavaScript with as much of the
goodness of typescript as possible and
we can actually do that so let's create
a normal javascript file so I'm going to
jump into that arm and one thing we're
going to do before we write anything in
there is we're going to export the
database class that we wrote so we do
this by just note noting export in front
of it and that's all we need to do to
export it as part of that module and
then we can grab it in this index jazz
file by requiring that file and then
specifying database and now the cool
thing here is that or when we create a
new database instance and I write d b
dot I suddenly get all of this um
intellisense again even though I'm
writing JavaScript and the reason is
that typescript is smart enough to
figure out that hey that database file
is actually a typescript file and
therefore I'm going to look up what it
is and still run it through the
typescript compiler so we have to get er
the setter function so we can do the
same kind of thing here again um
console.log
something added and then let's just said
something fubar um obviously we can't
use generics or something in here
because this is now javascript is not
typescript um let's drop also this code
and compile the whole stuff again all
right so if we execute now the index
jazz film we just get these something
added on part triggered which makes
sense because that's the code that we
wrote um however under the hood
typescript is a bit cheating all because
the way this actually works is we're not
executing the typescript we're executing
the zoom in the bin we're executing the
D bjs file that is inside the project
even though we are getting the
information from the D BTS file or to
highlight that this is really what
happens arm let's go into here and just
add a console log here like hacked so
this this noise here um and this means
that now if I execute this you can see
it gets the hacked statement so
effectively typescript just figured out
that hate the two files are in the same
folder there named the same just one is
T as one is jas so they are kind of
connected so I'm just going to get the
information from one and I'm going to UM
run the other one um this is obviously
not always the kind of thing you want to
do um instead what you typically want to
do is you want to output the output to a
different directory and we can do this
so um I mean just I think I screwed
around with the sizing here all right um
so let's delete the to generate a
JavaScript files because going to
compile them anyways again and then we
going to specify an out directory
ah in which we are just writing out so
this will create when we run the
compiler now it will create an out
folder that contains two files on which
are the basics j/s and the database j/s
so there's a bit bigger um so we have
these two which are the same generated
files we were using before however now
we have the problem that if we run in
the XJS suddenly we don't we can't
execute this anymore because the DB JS
file is in a different folder oh we
could adjust this by going to this file
and change this to our DB however then
we lose the whole typescript information
that we initially had which was the nice
part there is a trick around this though
there is a beautiful flag called allow
jazz and if we specify allow jss true
it's not only going to run the
typescript files through the compiler
it's also going to run the JavaScript
files through the compiler um and this
has two benefits first of all when we
run this suddenly we have an index jazz
file in the out folder but not only that
we also down compile this one too yes to
a es5 so we replaced const by VAR we
change the arrow notation function to
the normal function statement so we got
all of that suddenly without having to
use a transpiler like babel or something
just by running it through typescript
which allows us that the fact that we
don't need to maintain to transpile errs
at the same time in our code base um
then obviously maybe you not want to a
downturn spoil it but keep it in es2015
so you can just change the target and
compile this and now if we if we look at
the index JS file we're back to kind of
the same thing that we initially wrote
and the same goes for the database JS
file now so we have the database we have
the class annotation rather than this
whole function and prototype part um so
yeah we got that covered one more thing
that all angular 2 users heavily right
now is if you've how many of you looked
into angular 2 all right that's a fair
amount extreme um so you've probably
seen that it uses heavily decorators so
this app notation or to define that a
class is a component for example or
other things um and this is something
that is currently being spect by the
tc39 which is a committee that decides
on JavaScript standards but it's not
fully spec yet it's in stage 2 out of 4
um however typescript actually supports
it built in all we need to do is um
specify the experimental decorators to
be true um because LT will just trigger
warning the whole time and then what we
can do is we can just write decorators
in here so on the way decorators work is
or you can use them on class properties
on classes on input types on input and
you can use them on methods so we're
going to write one for methods that arm
is going to be called log arguments and
basically what this is going to do is
every toy we're going to annotate for
example this method with log arguments
and it's just going to console log all
the arguments that this function was
called with every time it's being called
and then afterwards it triggers the
original function now the way you do
this is you first of all specify a
target so it gets three things passed in
the first one is a target which is the
prototype are that this method belongs
to so the class that it belongs to then
it's a key which is the name of
the method it's it being applied to and
then it gets a descriptor 0 so
descriptor for the people who don't know
what this is is all the way that like
every every property on an object has a
descriptor so the descriptor specifies a
bunch of things so for example if its
innumerable meaning if I would try to
loop over them is it available is it
configurable so can I change it or is it
right to bowl you can specify getter or
setter and it has a value and so in our
case for the method the descriptive
value is the original function so we're
going to save this as original function
and then later we will return the
descriptor but what we do in between is
we're going to overwrite the function
that is associated with this descriptor
with a new function and this function is
going to take all the arguments so this
is the rest operator arm that was
introduced with es2015 also basically it
turns just every argument that was
passed in into one argument that's been
into one array that's called arcs well
and then what we do is we will console
log function and then we can use the
string interpolation here function
whatever the name is was called with the
arguments and then we just do our start
to string so this will just get a comma
separated list of all the arguments and
then we need to call the original
function so we do this by calling apply
specify the context so it's the same
context really and then we will pass and
hear the arguments that it was initially
called with so just read arcs and as all
we need to do and now we can use this
log arguments operator here so if i
compile this again
and then run note out index J s or you
can see a function set was called with
the arguments foo bar and then triggers
the normal function so it says something
at it arm so it's really easy to write
these decorators and in the case of
angular 2 they're hugely valuable
because it just makes the the code
weight cleaner then if you've looked at
the JavaScript equivalent it's a bit
more messy and a bit more complicated or
the other great thing that angular to
leverage about typescript is they used
all this additional typing knowledge to
build the ahead of time compiler which
does amazing things on speeding up the
arm compared the overall performance of
typescript so there are some great talks
online about the ahead of time compiler
if you want to look into that or they go
a bit more into why they use typescript
as well and how they used it to gain
this performance improvement and compile
the things better overall the whole
compiler is very open the language
server is very open so you can write
your own kind of typescript server
around this to interact with the
typescript compiler and build your own
tools arm cool so I think we're done on
this sign so let's jump back into the
slides all right so I've showed you a
couple of options that you can configure
but they're way more so these are a
couple of other examples that you can
use on using the typescript compiler so
first one is jsx if you've written react
before you probably are aware of jsx if
you aren't aware of james exits are kind
of an HTML like syntax inside JavaScript
files typically you would use some user
tool to then compile this into our the
react syntax arm but you can use that
yes config actually to specify that hey
if I have a tsx file so type script file
with this notation compile it
immediately to the react syntax or
you can use the preserve option which
will just preserve it and output jsx
files additionally there are options
like no implicit any or no implicit this
arm so these options allow you to be a
bit more strict about your code
especially with respect to typing's like
when you declare variable always declare
which type it is like you saw earlier in
my first example I actually specified
just VAR a is an array and Java and
typescript assume that this isn't it
right now but you could if you enable no
implicit any you really need to specify
this you need to return specify the
return types all of these things
obviously at one point you might have to
debug the code and debugging generate a
code is not always fun so you can use
the source map option or the inline
source map option to kind of get you
that additional knowledge directly in
there so that your dev tools show the
appropriate code rather than the
compiled code alright so let's wrap it
up so in summary sinica a couple of
things that we can do with typescript
but there are a few things that you
should take away from this talk first of
all you're already writing typescript so
if you've ever written any JavaScript
that is valid typescript so and this
allows you to very easily on board your
code base to typescript because your
code base is already typescript unless
you're doing something really dodgy then
your compiler might complain a bit but
it's just for your best um on top of
that it allows you to write safer code
so especially if your code base is big
um and you have a lot of people working
on it this can quickly cause pain in
JavaScript because there is no safety
net um to kind of catch common mistakes
like calling a function with the wrong
arguments with typescript you can be
safer on this side and make sure that
you catch at least the most common
mistakes and then on top of that it
gives you a better develop
experience both with your own code base
but also with external libraries by
using this definition files so with
these definition files you then less
you're less likely to have to open the
documentation of that page or like run
go around in that code on github to
figure out what it really does and which
functions are available and instead you
can really focus on writing your own
code if you want to kind of go back
through what I showed I wrote a blog
post a couple of months ago that goes
through the same concept and shows you
how you can get started with typescript
it actually uses a bigger existing
JavaScript project and then adds
typescript to it um but it goes through
the same concepts again I also put the
slides up on this URL on which again
then points to the same blog post later
or but yeah oh so you can look at the
slides as well um one last thing before
we wrap it up I would really appreciate
some feedback either through the my dev
ox app or by answering the following
question why SMS um on the scale from 0
to 10 how likely is it that you would
recommend this talk to a friend or
colleague the phone numbers on the next
slide as well with that thank you
everyone my name is Dominic I'm a
developer evangelist for twilio and if
you have any questions I'll be around
until the end of the day and maybe
tomorrow morning so I'll feel free to
have a chat with me thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>