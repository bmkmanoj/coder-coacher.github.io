<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Prepare for JDK 9 by Alan Bateman | Coder Coacher - Coaching Coders</title><meta content="Prepare for JDK 9 by Alan Bateman - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Prepare for JDK 9 by Alan Bateman</b></h2><h5 class="post__date">2017-11-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/uSR5JroBp34" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello can you mean alright well thanks
for staying on this is the last session
of the day and my name is Alan Bateman I
work in the Java platform group in
Oracle on the JDK and this session is
prepare for JDK 9
before we start I'd be interested in
doing a little quick poll for the few
people that are here how many people
have actually downloaded and then tried
JDK 9 okay that's not not not not too
bad for those who raised your hand and
how many of you tried out your your
application or library and everything
just worked Oh
two hands okay that's a surprise how
many of you downloaded it and found that
something was broken and you were grumpy
for the rest of the day okay a few
people okay well you're in the right
session so JDK 9 has a lot of features
and and you've probably seen it a number
of sessions this week the list of JDK
enhancement photos are jep's are in JDK
9 there's quite a list this session is
not about the features in new features
in JDK 9 but I will touch on a couple of
the features near the end instead this
session is mostly about the the
disruptive changes in JDK 9 and about
highlighting themselves you can prepare
yourself when you want to move to JDK 9
are beyond so my colleague Alex Buckley
in in the forward to the book on Java 9
modularity he likened the very deep
invasive changes in JDK 9 to the
tablecloth trick where someone pulls the
cloth from the table without disrupting
the cups and the plates around the table
but in Reverse that is what we had to do
in JDK 9 to retrofit the existing
platform the language the vm to support
modules there's some very deep changes
in order to be able to support this and
be able to do the tablecloth in Reverse
without disrupting our with minimal
disruption to the cups the plates and
the industrial power tools that are on
this table for the last 20 years
some breakages is inevitable but I hope
it's a lot less than
what what you were expecting so just
some quick general compatibility
policies and if I just read this out if
an application our library uses
supported api's and works on release n
then it should work on release n plus
one even without recompilation supported
api's can be removed and we've done a
few of them this time but only with
advance notice
so preserving existing m investments and
is is really really important and it's
it's one of the reasons why so many
people have stayed with java for so long
so given this compatibility policy we'll
actually see how does JDK 9 stack up so
I'll start with the good news the good
news is starting at the top the
classpath works as before class loading
works as before yes there's a few little
details and differences but for the most
part it works as before you are not
forced to migrate your existing code to
modules do not listen to people that
tell you differently they are confused
existing code should be able to the way
it worked without migrating it to
modules you may have heard of some
Muskaan safe it's possible that you're
not using it directly but some library
that you have on the classpath may be
using it that works as before for the
most part you should be able to take
your existing code and to switch to JDK
9 and it should work without changing
changing your code yes the module system
and the tablecloth click trick in
Reverse is an enormous effort but there
was also equal amount of effort went
into preserving compatibility
compatibility was always looking over
our shoulder the other thing to know
what which is part of the good news is
that the mainstream IDs is the idea the
the IntelliJ stand and NetBeans and
Eclipse they all have support for 4/9 in
addition maven and and all the
mainstream plugins have support for JDK
9 already in fact many the maintainer of
these were working with us for a long
time to ensure that they were working
with JDK 9 when it shipped so that's the
good news we'll switch to the bad news
most of the changes that are in 9 should
be transparent to you and should be
transparent to most of your libraries
and but there are some changes that will
require your libraries and to be
upgraded and some of the tools so if you
only take one thing from this
presentation and that is upgrade the
libraries and the tools to a version
that supports JDK 9 before you try to
migrate it'll save you a lot of time if
you're using any of the components that
are shared between Java EE and se and
I'll get into that in the next couple of
slides then you may have to adjust how
you build or deploy Tumbo changing code
just the way I'm talking mostly about
where you get these libraries from a
small number of api's has been removed
and in fact a small number of standard
api is has been removed but it's so
insignificant we remove disease in the
first build of JDK 9 and more than three
years ago and hardly anybody has noticed
a number of non API features have been
removed and some some little use tombs
have been roofed but hardly anybody has
noticed so for that reason I'm not going
to spend any time on those things
because I'm not really all that
significant a big first is that JDK 9
will emit warnings at runtime if there
is some code doing to doing certain
reflective operations I'll get into that
in a few minutes I'm gonna start first
to be disruptive change I want to talk
about is the modules that are shared
between Java SE and EE for several years
and in fact for more than a decade the
standard platform and the jdk roamed the
universe and it ended up assimilating
many many technologies and we've korba
we have web services there's a whole
slew of frameworks and api's that work
their way into the stack into Java Sea
and the JDK needless to say there are
some regrets this is a Java Sea graph
and if you've seen the Java EE graph or
the module graph at previous day boxes
and it was a lot more complicated than
this we've made a little we made a lot
of progress in making this very very
clean and if you look at the names of
the modules and I realize this is the
font is a little bit small but it's it's
it's such a large screen maybe you can
make them out you will recognize several
api's that existed outside of the
platform before they were subsumed
you'll see there the Java management
module these that that has JMX api which
existed as a stand-alone technology
outside the platform before it was
subsumed you see Java naming in there
that's jndi before it was actually
subsumed so there's many many modules in
here that lived outside of the JDK
before they were actually subsumed
however there are couple of modules in
here that were never completely subsumed
and these are very very problematic they
live a double life on one hand they live
inside the platform and they're used by
regular applications on the classpath
and on the other hand they actually live
outside of the platform there is there
is slightly larger versions or newer
versions that are used typically by app
servers are typically used by enterprise
applications and they overlap and and
sometimes you get you get environments
where people are trying to to make use
of the newer version or the EE version
and I want to spend a bit of time on
this but the main point is is that these
these api's which are now modules in
nine are very problematic you can't be
both inside the jdk and outsiders jdk at
the same time I put a red circle around
the modules that are are very
problematic they're up in the top right
of the the module graph here you'll see
there
Java am sorry java xml WS that's the web
services java xml bind that's for XML
fare for XML the binding API and Java
transaction that's a transaction API the
App servers will typically have come
with newer versions are the e versions
of these they actually have super sets
are the complete API where's Java C Oni
defines and in at least two cases here
vary
small subset of these api's there was in
jdk age and older and way to upgrade
those it was called the indoor standards
override mechanism nobody used it except
for a very very few it was complicated
to use so what what people what people
did was is when they're running an
enterprise applications they deployed
the version of these on the classpath
that sara worked but really only by
accident so these have now been migrated
to modules engine in the jdk so how do
you upgrade them
well the module system has an upgrade
module mechanism i'm not going to go
through that here but it's a different
way of deploying an upgraded version of
this api it has to be deployed as a
module but these things outside the jdk
aren't modules so this creates a lot of
problems so they're they're the ones in
red that have a version outside and and
they're trying to be inside at the same
time and then we have korba and i'll get
to that in in a few minutes as to why
that is that is interesting in 2017
there really is no reason for Java C R
the jdk to be the delivery vehicle for
these api's especially when they have a
standalone version that you can download
from maven central and that's why they
have been deprecated in Java C 9 this is
the list of modules that are deprecated
and you'll see why I'm getting why I'm
bringing this up in a few minutes these
are deprecated far removal this is the
new form of deprecation in java c 9
which allows deprecation to indicate
that there is that there is a clear
intent to remove these and in a future
version these modules will go away the
list of modules that are listed here you
have activation transaction XML bind XML
WS XML WS annotation and Cora these are
the 6 that we want to remove in the
future activation is the Java beans
activation framework you may not use
that directly but it's used by things
like Jack's B and Java mail and a few
other things
Java transaction is more interesting to
to Java Java and EE but there's a small
subset of that that's interesting for
JDBC and
and that has to be in the JDK and CORBA
is going away not because it has a
standalone version but just mostly it's
just not interesting in in 2017 if we're
using any of these api's except for
corba do not panic
each of these um ap is as a standalone
version you can download it from maven
central today and they each of these has
a its own jsr and the JCP which itself
eventually moved to over to eclipse with
the current move that actually maintains
these these api's so they have a
maintainer they have sandal and art
effects they don't need to be in the jdk
so why am i bringing it up in this
presentation as a first step as a first
quite aggressive step in 9 we have we do
not resolve these modules by default
what does that mean it'll be as if so
far from the perspective of code on the
class path it will be as if these
modules do not exist it'll be as if the
types in these modules do not exist and
I'll give you an example of what I mean
I'll start with a tiny little fragment
of code that's using the XML binding API
arjax be it's making use of a type javac
XML bind Jack's be context let's compile
it with JDK 9 and see what happens shock
horror it does not compile it did
compile with JDK age 7 &amp;amp; 6
it does not compile with JDK 9 what's
the error there is packaged XML bind
javac sex ml bind is not visible is list
the import package of XML bind is
declared in module java xml bind which
is not in the module graph this module
is not in the module graph that's used
at startup so these classes are hiding
at compile time what does it mean for
runtime double shock are no class
they're founder if I had compiled this
with some previous version and I try to
run it I get a in your class their
founder because it appears the class
does not exist
the JDK has never done this before
remember don't panic I'm actually we're
not saying is this is that you have to
change your code it's it's a change to
how you actually deploy with these these
libraries and there's a bunch of
migration options I'll start with the
first one which is is to say is as these
modules have not been removed they are
still physically present in the JDK
they're just not resolved by default you
can use the add modules command line
option give it a set of module names and
it will resolve those for this example
I'm using the add modules Java X java
xml bind to add this as a root module so
that it would be resolved when you do
this this will work exactly as I did in
JDK 8 while it's tempting to just add
this command line option if you're
compiling or running is remember this
module is going away and the jep or the
jdk enhance for a proposal to drop this
completely is is in the works it's it's
it's hasn't it's been submitted it just
hasn't it's it's we haven't figured out
which version it's going to be targeted
to yet but it has been written and all
the details about removing this and the
compatibility in fact have been written
up so add modules is a short-term
workaround if you're using any of these
api's and but it's not the long term
long term you either go for two or three
number two is is just taking the
standalone version and just put it on
the class path it doesn't need to be in
the JDK just download it and put it on
the class path and it will actually work
the the reference implementation which
firfer let's say checks checks B and
which includes the API and the
implementation they're just they are in
maven they just were cast as regular
libraries on the class path if you
eventually move to modules and you'll be
able to deploy these as modules on the
module path so I hope you can see theirs
as this is this is this is a disruptive
change but it's not just it's not a
change that forces you to change code
it's forcing you to change how you to
build things are you deploy things which
is quite disruptive next thing I want to
bring up is
strong encapsulation now you've probably
heard that modules can capsulate their
internals maybe went Alex's talk or Marx
talk today on on on on modules it's
basically a way for for a module to
prevent code from outside of the module
make access to the internals are
non-public members of our classes in the
modules API so having the JDK s it
encapsulated internals is a big deal
that's what creates a lot of the the
concerns and because a lot of existing
code might be reaching into JDK
internals so let's build up and talk
about what what we actually mean by this
and what it means moving to jdk 9 i'm
going to start by going back over 20
years by digging up this dusty ducks
page from 1996 where it reads another
reroute the java dot star packages make
up the official supported public Java
interface asunder star packages are not
of the support public Java interface
that's the Ducks page no one reads it
pays any attention this has been a big
problem for a long time and in JDK 6 a
simple database was added to Java C to
allow the Java C compiler and made a
warning or an error when attempting to
compile code that uses internal api's
the idea was to add to provide at least
some discouraged discouragement from
using the Sun that star api's and other
combat sun api's that are not part of
the supported api so when you compile
with JDK 6 or 7 or 8 you will and you're
trying to make use of Sun dot start
api's the compiler will emit warnings or
errors here's an example where it emits
a warning if I read it out it reads a
warning and in this case I'm trying to
make use of a class Sun security X 5 X
500s x.509 X 500 name the compiler vez
says a warning X 500 name is an internal
proprietary API and may be removed in a
future release and it prints up more
details about the warning and
of course we all ignore warning so this
was did not really act as much of a
discouragement as it was intended the
important thing is is is even with the
warning once the code is compiled it
would just run on the previous versions
and no no issue now we're dialing things
up again in 9 and we see what happens
when targeting JDK 9 Java C will no
longer compile code with references to
internal api's in the story now this
time we look at the error message for
that's exact piece of code that we had
on the previous slide we got a warning
with 8 warning with 7 a warning with 6
in 9 we get an error the error this time
is saying package son security x.509 is
not visible and then it tells you that
that package is declared in modular base
which does not export it to the unnamed
module forget all only module of means
here is just think about it think of it
as the class path it means this is not
an exported package you're not supposed
to use classes in this now you don't
need to move to JDK 9 this is just to
recognize these kind of problems and
we've been planning for many many
releases to be able to encapsulate the
internal API and one of the steps
towards that in jdk age was the addition
of the Jade EPS tool as j-d EPS Jade EPS
fur for doing static analysis of of
classes to understand what their
dependencies and the references to to
other classes just a quick poll is as
how many people here are aware of J tips
ok good about maybe third to half the
people ok that's that that's that's good
one of the useful things about Jade EPS
is easy is an option - jdk internals
which is a good way you run the tool and
it's in this tool is in j decade
you can run it on class files our jar
files or a class path of classes
exploded classes and jar files and it
will tell you if you're making if
there's any static references to
internal api's so it's very very useful
where possible and j tips has a little
little database built into it
where there's an equivalent standard API
or supported API it has a mapping from
from the internal form to the to the
standard form in this case it turns out
the x.509 is is there is actually a
candidate api x500 principle in the
standard api that that code using this
could use so j tips is actually a Swiss
Army knife lots of useful options so
it's well worth trying this out because
you can do all sorts of useful static
analysis with this so we've talked about
compile time code references to internal
API is it does not compile so let's move
to runtime and see what has changed in
nine so the ultimate goal and I will
we're not there yet is to fully
encapsulate all the internal api's and
non-public members of classes in the in
the public API and and in fact during
JDK nine for I guess almost a year the
early access bills did completely
encapsulate their internals but it
created a lot of problems there's a lot
of code out there that is is is is
making use of internal api's and there's
a lot of code in there that's hacking
into non-public members of classes in
Java lang and and and lots of other
exported packages so that meant a lot of
libraries were failing with with things
like illegal access error illegal access
exception inaccessible object exception
and suit broke a lot of it a lot of code
um
so eventually in JDK 9 it was it was
decided that we give libraries more time
to migrate to the standard and api's and
more time to address technical debt in
those areas so JDK 9 was dialed back
from where it originally wanted to go
and let me explain where we ended up
with in JDK 9 I can read this out all
packages that existed in JDK are open
that's a modularity term to code on the
classpath this allows most existing
hacks to work as before so those
internal api's and non-public fields
have been renamed or it hasn't been
refactoring existing hacks existing code
is hacking in will continue to work
much of the the access to to non-public
members or to internal api's is actually
done through core reflection and either
deliberately or maybe some misuses of
core reflection and to be able to help
identify where that code is the first
use of reflection that does what we call
an illegal reflective access will print
a warning this isn't this is I'll show
this in the next slide this is the first
time that we've printed warnings at at
runtime the warning is attempting to be
to help identify the code that needs to
be to be updated so it detected and I'll
show the example so you can actually see
as much as as to what's going on in
addition there is a command line option
- - illegal - access that allows you to
get more information turn on all
warnings get stack traces or deny all
illegal access and this is useful
because it allows you to get more
information or get run the JDK in a way
that it will run in the future so this
is quite useful to have so here's an
example warning the example we're kind
of using in the slide decks at the
moment is Jason rebel with nothing sorry
nothing against Jason when I was doing
slides last year we picked on the geez
and the Groovy's and the and the
GlassFish is this year or just on the
J's so it's this is this is starting up
the would - with Java - jar and was
giving it the the standalone version of
Jason and the very soon after startup a
warning is printed - standard error the
warning says an illegal reflective
access operation has occurred and then
in red I've highlighted illegal
reflective access by and it gives a
class name that's inside this jython a
jar file - method sun ni OCH SE l CH
channel and then it get FD so this is
this is an internal class within the n
io selector framework that is being
accessed directly access reflectively by
the my code in this jar file so it's
telling you what's what's going on there
it prints out some additional if
please submit a book report to the
maintainer zuv that code and if you want
to get more information you can use the
illegal access equal warned option to
get additional warnings that might
actually occur so this warning is only
printed once and for the first
reflective access and it's useful to
identify and the maintainer zuv that
library can run it with other options to
get stack traces and if they want to
find out exactly where that code is a
couple of other disruptive changes I
think that that are that are important
when you're thinking about JDK 9 and
that I want to talk about the first is
the version string change the Java
versions and the version string in
particular have always been very
confusing there's some very good
descriptions and motivations documented
in JEP 2:23 that's well worth reading to
understand why the version string scheme
changed in JDK 9 at a high level the
main change is that is that after 20
years the leading 1 dot is dropped that
means that what Java dash version prints
is a little bit different from before it
also means the system properties that
expose the version changes here is the
5/5 system properties that expose the
version I've shown the JDK 1.8 GA
version I've shown 9 and there's been
one update of 9 since it was released
901 and you can see what the difference
is so going from the Java version is a
system property that is parsed by a lot
of libraries 1.8 dot 0 is what it was
when JDK 8 g 8 when 9 shipped it was 9
this is very disruptive change in fact
at one point I was hoping that we could
actually put in the JDK 9 documentation
a description of this in 96 point point
font the docs folks said that wasn't a
good idea to put something in but that
size there's a lot of code out there and
that
when it when it parses this it
misbehaves and the misbehaves in so many
different ways I could do an entire
presentation just on code samples that
we've actually seen code throwing
exceptions because I can't parse it code
executing that never executed before
knows code paths that are just stale
code that hadn't executed in years we
have seen many examples of libraries of
thought they were on JDK 1 1 0 or 1 1
and they started executing code that had
not been executed for for 15 plus years
so the version strengths change on its
own and it's a very mundane change is
one of the big reasons that you have to
upgrade a lot of the tools and the
libraries that you're actually using it
may be you may be it may be that you
actually have some code yourself and I
see some people writing things down
they're probably making notes of
themselves as oh I've got some code over
here that a few years ago is parsing the
Java dash version property that may need
to be updated so that's something that
you want to look at in your own code
there are ways to avoid needing to parse
the the Java version there's a there's a
there's a runtime version API and in
introduced in Java C 9 and in time I
hope more libraries and make use of this
so rather than parsing properties they
can actually call this and actually get
the the version and make decisions based
on that rather than the system property
there's also multi release jars and I'll
talk about those in in a few minutes
another disruptive change in JDK 9 is
the change to the binary structure of
the JRE and the JDK a lot of motivations
for this and moving to a modular
platform completely blurs the historical
distinction between the JRE and the JDK
if you're in Mark Reynolds talk on
modules earlier you would have seen him
use j-link
where he created a runtime image that
had a small number of standard modules
and then some some application modules
that is a runtime image so this
historical distinction between this is a
long time this is a JDK that is run
templates tools that completely goes
away with with with with 9m other
motivations are
JDK has historically used jar files
internally RTG our tools jar and that's
a very old zip format technology we can
do a lot better there's a lot of
interesting optimizations that we can do
for the the system classes and start up
around this area that do not involve
using using zip files and there's lots
of other other motivations for doing
this change and you can see this pretty
clear in in the next and the next slide
now this is a very disruptive change for
tools compilers anything that was
reading our thr to Lestat jar so we got
this change in in 2014 to give the tools
as much one way as possible to deal to
deal with this here is the the legacy
are it's there since 1.2 part of it is
part of this layout is complete accident
is there are two bin directories there
are two Lib directories this is a JDK
there is actually copies of the same
launcher in two different directories
it's it's very problematic the Lib
directory has been very problematic
because it contains both user editable
configuration and some and some files in
there that should never be changed
because it just break the jdk if you do
that and so this is the format that
we're moving from and this is the format
that we're moving to and when you look
at JD canine runtime image it's a lot
simpler
there is one bin directory there is a
conf directory and the conf directory
has the user editable configurations the
security policy file the JMX management
configuration file and so on things that
are designed and intended to be changed
it does not contain the things are not
supposed to be changed there's a Lib
directory which it's just so pic that's
where the shared libraries are it's
where other things are there but there
you won't find jar files in there
there's no Artie jar there's new -
there's no tools are as I said this is
mostly interesting for tools and but
it's one of the reasons why you have to
upgrade many of your your tools there's
many other changes I could spend a lot
of time on this is and there are changes
to the class loaders and now class
loading hasn't changed but the
implementation type has changed
there's quite a bit of code out there
that makes the implementation that makes
the assumption that the implementation
of the the application class loader is
the URL class loader not anymore it
isn't that what's it's completely
different there's a small number of
tools and libraries that assume the blue
class path the blue class path has
mostly disappeared except for for tool
agents it's mostly disappeared in nine
so that has certain implications several
modules have been what we call deep
privileged so one of the wonderful
things about having having the the core
platform broken up into modules is is we
can start moving things around and one
of the great things we've been able to
do is move many of the non core modules
away from the bootloader we've put it
into what we call the platform loader
which is the new name for the extension
loader and that allows us to configure
it with a lot reduced permissions
compared to being in the being defined
to the boot or matched to the boot
loader so that's a really really good
change for me a security point of view
what it's a disruptive change that's
cost some class loaders out there that
do things they they assume that all your
platform or platform types are visible
to the bootloader so they may need some
adjustments we have moved to using the
common locale data repository locale
data in nine this is this this is
actually a very brave step because it's
it's very subtle changes to and to the
to locale data this is something that
has been in the works for several years
if you look at JDK 8 it actually has
both cldr and the legacy JRE locale data
and you can actually switch between them
in ace we switch the default in 9 so
that we use the the facto standard and
cldr locale data that may not appear to
be an interesting change but it's very
subtle change and is and it's important
for for for testing especially when
you're deploying applications in very
different locales gdk9 switches the
default garbage collector to be g1
that's a very significant change and
because the performance characteristics
and then and configuration and things is
is different em so that's a significant
change
so the gdk9 documentation has a lot more
details I'm picked out here the
important things that I said I think are
worth highlighting in this session now
let's talk about a couple of features
that help with the migration I want to
talk about - jep's jdk enhancement
proposals to 38 and to 47 so I'll start
with jab to 38 multi release jar files
at the start of this presentation and I
listed out an all big page of of of of
JYP's and what's interesting in that is
the number of new api's that have been
added to the platform and nine one of
the new API is is var handles for
example and that allows a lot of some
libraries to move away from using some
of the the unsupported api's - supported
ap is another one of the Jets you'll
have seen listed out there if your is
the XML and catalog API so that avoids
code that's been hacking into the XML
parser for the last 15 years from it can
actually start using a standard API so
there's new API is in 9 so you might
wonder because of so many people that
have libraries that need to target an
old version but maybe they'd like to
make use of of these new API is when
they're running on 9 and this is where
and multi release jars and come in so
multi release jars do is is the extend
the jar format to allow multiple Java
release specific version class files to
coexist in a single arc and is any
single archive so this is one jar file
that has class files that for the older
platforms and then it also has some
class files that are 4 9 and newer and
I'll give an example by just creating a
multi release jar so you can get an idea
of what I mean
so the jar tool and so I'm using using
the jar totally to create a jar file
named stats jar I'm giving a dash C
classes and dots so that essentially
will zip up all of the classes that are
in that directory and put them into the
jar file that's the same command that
you have in Jade occasional and older
the new option I'm providing to it is in
red - - release 9 and then
also giving it another directory where
it finds the 9 and newer specific
classes so this command is ends up
creating a jar file that has all the
classes that I had before but it has a
new section in the jar file in meta-inf
versions 9 where it has the class files
that it finds in the classes 9 directory
because of this the class of 9
directories what I've given to the jar
tool so the interesting thing in this
example is there are two classes named
helper class and package comm Acme stat
CLI one is in the top-level section of
the jar file the other is in the
meta-inf versions 9 section so let's run
this on H and see what happens
sorry
when you run this on on ok sorry I've
just listed out there's there's actually
typo in my slide here but M when you run
this on JDK 8 JDK knows nothing about
the meta-inf services sorry meta-inf
version section so it will only load
classes from the top-level section so it
will load main and helper from the
top-level section when I run this on 9a9
knows about multi release jars it will
load main dock class from the top-level
section and then it will load the helper
dock class from the meta-inf
versions 9 section because that
overrides a version that's in the in the
top-level section so this is this is a
very very interesting way to be able to
have a library that has class files that
make use of the standard API when
they're on online and newer or maybe
they're using some old way and when
they're running on age or older
so you might wonder when you're how do
you build a jar file like this because
it's it's what this does is it creates a
lot more complexity in the build
environment to be able to build one of
these jar files because now I've got
I've got classes in my environment that
are compiled for different different
class file versions and this brings me
to the other feature that I want to talk
about
which is compiling two older releases
historically in order to compile to an
older release you could use Java C and
then specify source version and boot
classpath actually specify all three a
big mistake that a lot of library
building of libraries have done in the
passes they've only specified two source
and target they've forgotten the good
class path and they end up with problems
you actually have to specify three JDK
nine makes this so much simpler you can
specify - - release and a version as of
JDK nine you can actually compile all
the way back to six Java C has a
database essentially of all the standard
ap eyes that are in six seven eight and
nine so when you compile - just release
six it can it can compile you can't make
use of newer AP eyes when you're
compiling to six and so on so this is
very very useful way to be able to build
a library and have it built build it for
an old version and if you ever get any
modules talk you'll see how we actually
use this to build modular modular jars
and have it be both a module and a
library that you use in the classpath in
older versions so one order tool and I
want to just actually mention is Jay
deeper scan I don't see doctor
deprecated err in the in the audience
but if you see guy going around with a
white doctor's coat and and Assetto
scope is that stock the deprecated er
this is his tool Jake ever scan it does
static analysis tool to actually scan
classes for deprecated API so with it
completely enhanced the deprecation
mechanism in nine you saw how we had
modules that were deprecated for removal
and that we also have this tool which is
very useful to be able to identify
usages of of deprecated API and more
importantly identify usages of
deprecated of api's that are deprecated
for removal that's really really useful
because if if an api is deprecated
removal that is a clear intent that this
api is going away at some point okay so
this leads me to the final section which
is what can i do to prepare for jdk nine
main point is our first point is upgrade
tools and modules to versions that
support JDK 9 I've shown all the
different issues that existing tools and
libraries might have and in some cases
sadly this means a full-stack upgrade
because changing the version string or
changing the layout of the JDK is is
such a disruptive change for the modules
that are shared between SE and and and
if you are using those jacks be jax-ws
you will need and you're making use of
the versions that are in the JDK you
need to at least long term is figure out
how you want to move to the standalone
versions again I'm not suggesting anyone
has to change any code it's just where
you get those will will actually change
run J depths as I said J Depp's is in
JDK 9 j dkh there's a new version and
it's a better version in 9 but it's a
great way of seeing whether you have any
dependencies on on internal api's try
out the JDK 9 bills and look for illegal
reflective and access warnings submit
bugs if you have if you have the time to
do that because that's a great way for
letting the maintainer zuv libraries
that are dependent on internals know
that they may have issues in the future
if you maintain any code that parses the
version string now would be a good time
to go and look at that because moving
from one that 8 to 9 is is is a
disruptive change for a lot of codes
that parts of the version string and
read the release notes there are 43
pages of release notes for in engine in
it for JD King JDK 9 in small font now
you may think that's a big long list but
if you look at the release notes for JDK
hr7
are 6 any the major versions there is
always a big long list of of mundane and
small little changes that JDK developers
attempt to go and document and
communicate for anyone that's doing that
migration it's the whole process of
release notes has beefed up a lot in in
a 9 because there's so many disruptive
changes so that's preparing for JDK 9 we
also need us are thinking about post JDK
9 if you're
the keynote this morning you would have
heard mark talk about a the more rapid
cadence and doing a feature release
every six months and so this is this is
so you're not just thinking about 9:00
now you're thinking about 9:00 and
Beyond
we will at some point remove the the
modules are shared with EE so if you if
so when you when you try out nine first
you may and you're using these api's you
may start with the add modules but
further down the road they are going to
go in way we're on Jay Depp's again
because things are going to change in
the future particularly around
encapsulation a great way of actually
testing whether you have code that
depends on internals or non-public
members is to run with a legal access
equals deny that is the way with JDK 9
to try things out to see how they will
be in the future we will eventually come
good on the uncaps elating all of the
internals so that's a great way to to
try things out now to see what breaks
and version string I've mentioned and
testing the early access bills I think
that's a that's a really really
important thing and so for JDK 9 we'd
early access bills right from the start
so all hundred and eighty-one bills were
all available at like work like
clockwork each week and going forward
there's already JDK 10 early access
bills for people to actually try out as
well so summing up and most code will
just work with our changes and but there
are disruptive changes and it'll
typically be the tools and the libraries
that you're using rather than your own
code upgrade your tools and libraries
beforehand is the best way to avoid most
of these issues so more information and
JDK 9 project page and open JDK has all
of the jep's
so one of the first slides I had listed
out all of the jep's and all the
features in there there's a migration
guide on the oracle site that documents
as many of the the disruptive changes
and how to prepare for them and how to
migrate
and so that's another useful resource
and you'll hear about more about Java 9
in many of the sessions this week so
attend those if you can
so that's it don't believe anything I
said and we have let's see we have six
minutes left if if anyone has any any
questions and please go to the
microphone it's sometimes hard to hear
from the stage no hands no questions all
clear
all right well thank you very much for
attending then</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>