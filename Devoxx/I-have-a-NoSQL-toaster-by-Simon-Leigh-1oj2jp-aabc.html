<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>I have a NoSQL toaster by Simon Leigh | Coder Coacher - Coaching Coders</title><meta content="I have a NoSQL toaster by Simon Leigh - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>I have a NoSQL toaster by Simon Leigh</b></h2><h5 class="post__date">2017-05-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/1oj2jp-aabc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">we're again inflated doing make sure
good morning everyone thank you for
being here early especially if you went
to the party last night it wasn't that
easy to wake up this morning so thanks
for being here and hopefully I can
entertain and educate you for 4550
minutes or so so we're going to talk
about why I would want a no sequel or no
SQL database I will use both terms
interchangeably and about my no sequel
toaster so my name is Simon Lee I'm a
solutions engineer a Couchbase you'll be
pleased to hear that this talk is not
going to be kind of vendor specific on
Couchbase i'm going to cover the various
classes of no SQL databases but if you
want to get in touch with me there's my
twitter handle i'm here on behalf of the
Couchbase developer community our
community manager laura is sat at the
back of the room we have booths
downstairs so if you want to talk about
contribute to the community or if you
want to hear more kind of use cases and
sort of the business side of how no
sequel helps businesses I'll be on the
booth with my colleagues and we can talk
about that for now it's going to be much
more sort of theory and the purpose
behind these these systems so I keep
always I think throughout my career will
be asked this question relationship
between couch space and couchdb aside
from the acronym couch which is a
cluster of unreliable commodity hardware
the fact that both open-source and that
they had some of the same founders and
original developers they're completely
different projects and products couchdb
is an Apache foundation project couch
basis is sort of sponsored open source
project and Couchbase Inc company
supports it for whom I work but they're
very different things so let's take a
step back here and talk about SQL being
the norm everyone sort of the default
choice for databases people think
forever has been
our DBMS and I kind of use SQL as a
analogous to saying relational database
system because of course it's the
language designed to query that kind of
database but let's look at the history
of while mankind with databases in
particular I'm not going to run through
from the library Alexandria but the
first commercial database application
was saber which was IBM helping American
Airlines to design a booking system and
that's 1960 interestingly Sabre is still
a company that's running today one of
the global distribution systems and they
are no sequel users of Couchbase and
other technologies as our amma dais
so the first application of technology
is still very much that companies having
to solve similar problems just instead
of sort of 84,000 bookings for flights
per day they're looking at indicators
Amadeus 7 million operations per second
people searching flight availability so
the problem in the Internet age is
scaled but the relational model Cod's
model proposed in 1970 and then the sort
of commercial launch of Oracle only 10
years later so the necessary sacrifices
to the Dark Gods were made and Oracle
version 1 was released and even then
after that sequel server version 1 is is
1989 so it took sort of 30 years from
the first commercial database system for
SQL to be the the norm and and it's
since the Internet age really that other
systems were designed and so CouchDB was
written in 2005 but that in fact is
based on a sort of Lotus Notes model of
document storage so that wasn't even a
new idea
voters notes preceded it by many years
and the real explosion of new SQL
technologies came after Google and
and respective academic papers on how do
we solve the problem of delivering
content and databases to support massive
web-scale audiences so they they
couldn't keep their relational databases
online and functioning well certainly
not without extreme cost implications
and it's always cost really from the
organization's perspective that effects
you know what what technologies are
chosen so those two papers are published
and then their load of open-source
projects after that things like
Cassandra not necessarily open-source
dynamodb Amazon sort of public version
of dynamo react and all the rest
MongoDB Couchbase calculators arrived on
the scene in 2010 so later than the
initial wave and yes happy days because
they pay my mortgage so I'm pleased that
they came around but the point here is
it took a long time for relational
databases to really be with de facto
norm and so even these these no sequel
databases have precedence sort of twenty
years thirty years before object
database is being around since at least
1988 so this is the key principle of
this talk that no SQL is is not a very
useful term because describing anything
by what it is not it's sort of
necessarily not helpful you know a
toaster is no SQL in sense that I can
put data in it in form of bread I can
get that bread back out as toast and I
don't need a query language in order to
interrogate the toaster but what it is
good is marketing shorthand right to
just distinguish what class of database
are you we're in a broad class and at
least you have the kind of sense for for
calling them something so it's worth
today talking about the commonalities
between no SQL databases the various
different classes and how they differ
what are the good use cases at high
level and how these technologies work
so we'll talk about the commonalities
what makes things no SQL is it because
of easy development not necessarily you
know we as no sequel databases we tend
to say yeah you know developer agility
get things done quickly but it's not
necessarily the case that you don't have
to think about it hard beforehand so
they're not necessarily easy to develop
for or to operate and scale the same
applies with scalability with some of
them you have to think carefully about
how you're going to achieve scale is
your data model going to fit the fact
that you need to scale out to very high
levels and you can make mistakes you can
choose sort of shard keys wrong so
they're not necessarily all scalable
even though all of them claim to be so
certainly not an easy easy manner the
other thing that's often talked about in
the context of relational and SQL is
this acid versus base so your your acid
semantics in a relational database
versus these concepts of sort of basic
availability soft state and eventual
consistency in no sequel databases but
there have been no sequel document
database isms the last time around which
can give you as compliant transactions
foundation DB was one and it got bought
by Apple who then snaffled all of their
code and took it off github which is
very nice of them but it's not
necessarily that you have to trade-off
between these two things because systems
are architected in different ways so
still that's not the sort of common
overriding theme of these systems nor is
having schema or being schema this even
with something like Cassandra you do
define a schema even though you may have
certain columns in that schema that
don't need to be present for every row
but you do still define you know column
family with with a schema yes with
document database is like Couchbase you
have a flexible schema a document model
but they're not all all schema listen in
realsense so I think that the
normalization is the most common
characteristic interface at all of these
systems share in order to get their
performance the necessity of the
normalizing some of your data are pre
joining and pretty aggregating things in
the model that you store in the database
and you see that across all of the no
sequel databases regardless of whether
they are document graph key value store
or wide column stores and that's because
of the problem that trying to solve is
serviced well by de normalizing your
data so you have a data model that tends
to be closer to what you need at the
presentation tier City normalization
certainly is the overriding common
feature of of no sequel databases in
their use touch on one last thing with
respect to these systems yes they all
can use commodity hardware that's often
marketed as a use commodity hardware I
mean in the sense of in your data center
commodity servers no special appliances
but they don't all have to be on
commodity hardware we have customers
using extremely large machines that are
not commodity by most people standards
and other no sequel technologies you
know are available on sort of appliances
and Oracle's technology that certainly
applies to that so why why would I
choose no SQL for a project and I would
say that if you're starting a new
project
don't use another vehicle database
because it's cool because we want to pad
out your CV or because there's peer
pressure to do so this actually happens
even in the enterprise you need to
consider if the problem you're
addressing is solved well by the
technology and if you have lots of
experience using a relational database
you're building a small project you
don't want to go for very large scale
you don't need the flexibility of schema
then just use a relational database
because you
more productive if you have a problem
that you know does need to consider
scaling out to very large volumes of
data or it wants to ingest data and you
don't necessarily know about the form of
that data at the time of ingestion so
you just write it and then inspect it
later
you're saving lob files things like this
are naturally suited to denormalized
most sequel databases and it's a good
place to start but certainly and even
coming from someone whose ultimate
responsibility is to get people to adopt
these technologies I don't want people
to put them in the wrong place
because it makes my job harder when I go
to a customer and I have to say to them
you've done the wrong thing now you need
to be architects it it's better to think
about it carefully and make sure you
choose in the right time so what about
if you know sequel is right well fine
but then when you think about what the
things I need to consider going forward
using a relational database and broadly
scaling can be hard with any system
scaling is hard don't get me wrong
architecting for for high loads and high
scalability is a difficult problem
anyway and you generally need to
introduce things like eventual
consistency and sort of event sourcing
message based architectures as part of
scaling to very high sizes but if you're
trying to do it with a relational
database the easiest way is scale the
monolith that also happens to be the
most expensive and gets exponentially
more expensive as you try and scale one
machine more cause and you reach
hardware limitations if you're trying to
shard relational databases
then you need to think about your
sharding scheme and you can go horribly
wrong with that if you make the wrong
choices end up with hotspots if you need
to change it later doing that
maintenance can be costly require you to
set databases that sort of read only
take databases offline and so these are
the other considerations that you should
have in mind before you embark on
projects using relational technologies
and considering using SQL technologies
the other thing that there's very high
others availability of a system
availability all tiers availability of
my application servers availability of
my messaging technology available 'ti of
my database technology you have to think
about all of these things as needing to
be highly available tiers in your
architecture and at one of our previous
conferences account space conference
Jena co-payment services provider talked
about their architecture and if you go
to kind of micro services talks
elsewhere you will see these tears
appear and using the right sort of tech
at each place and you need to think
about you know availability throughout
the whole the whole stack including the
database and that introduces this
concept of c.a.p
cap theorem consistency availability and
partition tolerance of a system if
systems running perfectly and nothing is
broken then you don't need to
necessarily worry about these letters if
something goes wrong and network
connection breaks I need to decide do I
want a consistent system which is also
tolerant of partitions of the network
the machines that comprise that system
or do I want a more highly available
system an AP system so CP or AP
consistent in partition tolerant or more
highly available in partition tolerant
if I choose an AP system then I'm going
to have to deal with the fact that I
might have eventual consistency and I'll
talk about what that means shortly but
there's the theorem dictates that when I
build a distributed system I have to
make that choice I can't have my lunch
and eat it
the other thing is that a simple schema
for something might be straightforward
and easy designing these data models can
be can be difficult migrating models can
be difficult anyone who's had to take a
database offline to do it take the
application offline knows that that can
be extremely painful
no SQL tries to mitigate the requirement
that you sort of stop the world in order
to make changes now you might still need
to do that but sort of the design
paradigm is your database
should not force you to take your
application down so you should have a
database which is available through
upgrades which is available through
failures and that is generally tolerant
of maintenance operations without
stopping serving that data and that
brings me onto this obviously relevant
picture of a blob fish this is the blob
fish which is a deep-sea fish at surface
level and it's not very happy clearly
but if I show you a picture of it in the
natural environment it looks like a
normal fish it's not particularly
beautiful fish but it looks like a fish
and this introduces the concept of kind
of the right tool for the right job
polyglot persistence you know you could
could use a sort of terms of describe
that I have multiple different
persistence engines databases depending
on the requirement of the application
and there's lots of sort of literature
written on this but if you've got data
that's suited to a relational database
highly transactional you require acid
semantics use relational database if you
want start storing log data you want to
start ingesting supplier data from API
is where you don't know what the scheme
is going to be or it might change
rapidly and you want to be able to
ingest that and not have to have lots of
work to change your application which
ingests it then use the no sequel
database so choose the right the right
tool for the right job without exploding
within your organization lots and lots
of different things because then it
becomes an ops headache but it's
certainly worth considering a balance of
these things all right so these are the
four key databases I'm going to talk
about document databases key value
stores columnar stores and graph stores
and just explain very briefly what they
are how you interface with them and why
you might use them there is some overlap
between all of this stuff and I'll talk
a little bit later on about convergence
but still broadly you can group things
into these classes so
document first this is a document not an
Excel document not the PDF not Word
document a JSON document in this case a
special class of string JavaScript
object notation of course people in this
room will be familiar widely use data
interchange format sort of native
support in most language is now
superseded XML because most people don't
like XML as a nor self-describing
interchange format and also data storage
format in the case of document databases
key points to notice are there's a
hierarchical structure which doesn't
exist in relational databases you can
have a list there and you have sub
documents as well so that hierarchy is
important in being able to model your
data here is a logo slide of the most
common document databases that we see in
the wild out of interest and in order to
win some swag if you come to the booth
later does anyone know what the logo at
the bottom left is who said that that is
correct yeah okay come by the booth
afterwards and get some swag it is it is
Lotus Notes and I mentioned it earlier
but Lotus Notes was a document database
and CouchDB sort of we implemented that
open source that approach the
replication protocol it's still in use
strangely in a variety of organizations
but you know nice friendly logo and
worth putting up there just to say none
of this is new in reality if you're
talking open-source and what we see at
any kind of scale it's only really two
of these that that we see out there in
the wild we think DB of course had their
own problems as a commercial entity and
is now sort of taken on as an
open-source project and another great
technology nonetheless in terms of
adoption Couchbase and MongoDB are the
two largest and they have commonalities
between them
Jason being that the data storage format
but beyond storing that data what makes
a database and if we sort of think about
documents in general Couchbase tools
Jason MarkLogic stores XML possibly
Jason but in reality even Beeson which
is binary sort of Jason representation
MongoDB uses what we're talking about is
Jason nice big just to reinforce the
point and the document database
understands the format of the document
and that's really kind of it it knows
that it's jason and it can interrogate
it and introspective and it can do
server-side things like indexing
querying reproject in that data creating
aggregates otherwise it wouldn't be much
use as a database I'd say this to
distinguish it from key value stores
I'll talk about next
typical abstractions in this case
Couchbase sort of abstractions but
clickable to other technologies buckets
which is analogous to sort of database
documents which you could think of as
analogous to a row of data in the
relational database also somewhat like
tables and that you get groups of
similar types of documents views
server-side views that generate indexes
on the data using MapReduce and then for
a Snickle query language for others
cassandra cql MongoDB their query API so
you have features that let you interact
with that data let's talk about the the
AP is since it's a dev conference how
these things interact with them this is
a CSV of slag the product code the title
or the description in the quantity of
that item very simple so I want to load
that into a document database I show you
an ineligible small piece of code but
the principle of using the stuff I'm
talking about developer agility and ease
of use to connect to in this case
Couchbase I just say create
configuration point to an IP address
and initialize that connection then I
connect to a bucket so it's it's four
lines in that in that method very easy
to to connect to these systems for loads
of data I just read out the CSV in the
first line here create a record from the
CSV for each line create a document and
associate with that document and ID so
now we're coming back to the sort of key
value underpinnings of document
databases each record has an ID which is
its key and the value is this anonymous
portion called content which just has
the title of the record in its quantity
and then I call insert and we'll talk
about typical operations on these
databases but it really is just insert
the document and I can then write you
know out to the console so very simple
to start loading data into these systems
just constructing in this case a
document per row of the CSV and this is
a screenshot of console and Couchbase
here's the key of the records and the
record itself which is now a JSON object
very straightforward simple document
model here to read this out I just say
get me the key so bucket which is the
key space get me that key and out comes
the record and I can write each of the
elements by using the JavaScript
notation this is net code of course
apologies for that now I know we're all
Java fans and then we write out the
information so very trivially easy to
access and write data and that's why
people say you know getting started ease
of use of the developer is absolutely up
there with these systems what operations
do I use at the lowest level up cert
data insert what David if it's there I
insert it update it I delete it or I get
it and read it and that's the lowest
level key value access pattern for
document databases
of course that's a bit blunt I need to
know the key which only gets me so far
you need to also query a database so
query language Couchbase very simple
looks like SQL extended for jason and i
can just project out items where clauses
other databases use different languages
of api's but you know very very familiar
interface gives me complete flexibility
of indexing gayson which can be very
very useful if you think of the supplier
data example I ingest that information
and then I might want to interrogate the
structure from the supplier I can do
that with the query language so last
piece on Couchbase great for devs scales
easily very fast if you want to hear
more talk to me later
here are the key use cases there are
loads of kind of other funky things you
can do but if you're looking at
identifying those areas where you might
choose this technology over a relational
system where you're not concerned about
having the acid requirements storing
user profiles indexing user profiles at
very high scalability levels session
storage content management catalogs a
catalog of products maps of product Maps
perfectly as an entity to a single
document and then scaling those catalogs
out to service you know website lots of
reads per second document databases are
the best general relational replacement
cover the the biggest chunk of use cases
but please don't try and do anything
transactional in any of these systems
really particularly in a document
database okay so we talked about
document databases and they're built as
key value stores but what is the
difference between the two the
difference is that we still have keys
and values the ID and the value
associated with it
but the value here is just anything a
piece of binary data strings associative
arrays numbers any
and the database or the data store
doesn't know about that value and here
is the list of common key value stores
of course most people will be familiar
with Redis very popular dynamodb cash
base can be used the same way react key
value store when we again look out in
the field if you're using open source
technologies the most common ones that
are adopted are these react our us are
struggling a bit but still very widely
used particularly in the
telecommunications industry and they
split as a class into two distinct areas
in memory caches a key value cache and
distributed data stores that are
actually built to be distributed so I'm
going to talk about the latter and this
is my point about not caring what the
data is instead of in a document
database the piece on the right hand
side being Jason exclusively you just
thought whatever you want and that then
means that you have problems trying to
index or query that because the database
may not know probably doesn't know what
data is being stored it's just a piece
of binary blob and you'll see that in
the react example and show you the code
which is very similar to that which is
offer Couchbase you have buckets into
which you put data and you have key
value pairs so you know at the top get a
config create the client and then with
that client insert an actor and the
actor in this case is an object which is
going into the actors bucket the key is
James Bond and the value is Sean Connery
we're going to be coming back to James
Bond shortly to talk about eventual
consistency to get the data out I just
say get same as with document database
from the actors bucket the key James
Bond very straightforward
and again that would look like this I
start the system and then I say get me
James Bond I printed the console but
that's fine for a trivial example don't
do what about this eventual consistency
and this is about who is the best James
Bond
so obviously it's Sean Connery but some
crazy person might say it's Timothy
Dalton which would be unwise but you
know they might say that so one
application says it's Sean Connery James
Bond he's associated with Sean Connery
another says James Bond is associated
with Timothy Dalton and another one says
Roger Moore okay fine if my systems all
online and I keep writing to that same
key the value gets overwrite it I have
one single strongly consistent copy if
someone trips over a wire in the data
center network fails something goes
wrong systems like react choose to have
this more highly available system so
it's always available for writes rather
than strongly consistent which might
mean you need to stop taking right so
something goes wrong so you can conceive
of a system I've got three servers
they're all connected together if I make
changes from application servers
connected to them they all resolve to
one record if the network's partition
between those servers and one
application server rights from connery
one writes Timothy Dalton one writes rod
one writes Roger Moore then I have three
different copies entries for the same
key and I need to resolve that conflict
so the system when it's partitioned when
it's sort of in a failure scenario still
accepts the data but I have three
different copies and typically there can
be only one we have to resolve it we
need to fix it and highly available ap
key value stores typically say to the
user as verify while you fix it you work
out what happened here you work out when
things were written you work out which
record is the is the winner and you need
to then
set that as the canonical version of
James Bond so there are some things that
can help you here there are sort of
conflict-free replicated data types but
a lot of it is pushed back to the
developer and for that reason ap systems
generally are harder to reason about and
to develop for than strongly consistent
CP systems and you know it's a choice
over whether you require absolutely no
write down time but you want you might
have to resolve these issues always say
I can take five seconds of
unavailability for rights in my
distributed system my database but I'm
not going to end up with these divergent
copies of the same ID so Couchbase is a
CP consistent and partition tolerant
system that means we have some write
down time for portions of the data if a
server fails say five seconds before the
cluster heals itself distinct from that
something like reactant DynamoDB that
accept your right but you might have to
resolve conflicts so use case is highly
variable data I just want to throw it in
there I don't care about it caching
objects pojos whatever to serialize them
write them into the store session
storage of course large objects possibly
chunked up across multiple key value
pairs which I can then pull out and what
you tend to want here is very low
latency access things like Redis things
like Couchbase sub millisecond response
times storing complex data types where
you don't need that secondary indexing
that ability to query ok the last sort
of general purpose class is : our data
stores much more familiar and looks more
like a relational database here with a
table they still kind of built those key
value stores where each row is
associated with the primary key
difference here you might notice is that
I have a common set of fields but I have
some missing and not not null
just missing entirely so a row might
have a variable number of columns none
of which are necessarily mandatory the
ones we see out in the field as per this
the ones that we actually adopted by the
open source community widely exposing
Cassandra and I'm going to focus in on
one Cassandra because from an
operational database perspective it's
the one that you would use from an
analytics perspective you might choose
HBase and and the key sort of things to
be aware of here a key space so exactly
as per any key space a unique set of
keys within a key space but within that
column families so this is more like
your tables group related data together
and those column families contain the
same same set of columns within each
family each column family has rows and
columns best illustrated with the
picture taken from the data stacks
website I give them two credits this is
a blog key space I know it's a bit
blurry but you have users you have blog
entries you have sort of subscribes to
relationship mapping column family
subscribers off and we have time ordered
blogs by user so notice here that the
relationships between the subscriber
relationships to handle with their own
column family so you're having kind of
foreign keys there but you need to
handle it manually if i zoom in to a
column family or the column families
themselves you can see that these
service kind of a grouped purpose but
notice again that in the users you have
name and state possible but state the
state column simply isn't in there and
the key to access that row in that
column family is the name of the user
just as it is in each column family but
the values associated with the key in
each column family are different so it
looks like a in some way like relational
tables but it's actually laid out very
differently and architected very
differently
to to create key spaces to create column
families tables this is how I would do
it with with CQL and you know again very
familiar but we're saying here we are
having a schema enforced here so this
comes back to my point about no sequel
databases aren't necessarily scheme ulis
because because we are enforcing schema
there and we're choosing primary keys so
the last example connecting to a cluster
and you're seeing that there are
commonalities in how you use these
clients they're distributed so the
application server connects to a
hostname or IP address I create a
session which is connecting from the
cluster object to a particular key space
which contains my column families and
then I can execute on that session my
queries I can insert into users and here
you can see that I'm specifying the
columns that I'm going to insert so I
need to do that when I write because all
of the columns won't be present for
every row so that's quite a distinction
and I'm associating the values here last
name was the primary key so I'm
associating those values with each of
those entries and projecting it back out
select star and I'm giving in the where
clause the primary key of that row and
just as with the other example I can
just console write that back out bear in
mind in this case we had also types
associated with with these entries in
the document databases we don't have
types enforced against the individual
fields so we have a bit more control
over that here but if we want to evolve
our data model and move from for
instance what's one example email email
is a text field maybe that we wanted to
go to a list of emails and then we want
to have an array of things in there we
could evolve that quite easily in a
document data model maybe less so in
this data model so schema flexibility is
impaired on the cassandra side but from
a scalability perspective
Cassandra clusters scale dramatically to
thousands of nodes in production
places like Apple in the single cluster
that just shows me what I do when I
project that data back out
I mean trivial trivially easy example
hopefully understandable so cassandra
features still something of that
impedance mismatch between my
presentation layer i might have to join
stuff from across different column
families whereas the document databases
we tend to be storing things that are
closer to the application level objects
but it scales incredibly well can be an
OPS headache for their tools to help you
with that very well-suited to analytics
because this data is stored in
contiguous rows so if i talk about the
use cases for this metering data really
large data sets smart metering data is
one of the classics on your use cases i
collect data on an incremental basis its
climb ordered it's all arranged in a
contiguous rows so if I want to do range
scans and aggregations I have all that
data locality to do it the document
databases including Couchbase hash
partitioning your data so you might have
to gather from different machines in
order to do an aggregation okay last
type and won't so much time on graph
databases then add Euler sort of came up
with graph theory and the problem that
he dealt with to to design graph theory
was I have these bridges in kÃ¶nigsberg
how do I can I have a path where I cross
each one only once in order to get from
across all of them but I cross each of
them only once and in proving that that
was actually impossible who invented
graph theory but if you think about
these bridges as relationships between
each side of the river that's what we're
dealing with in graphs databases
realistically near for J's with the
facto standard for graph although we'll
talk about convergence in the other
databases and here we're storing our
entities and relationships and social
networks are the classic use case for
relation
databases I'm interested more in the
relationships between entities than I am
necessarily in the entities themselves
the entity might well be stored in
something that Couchbase is a document
and then I store the relationships those
the complex relationship stuff in a
graph database but your query
requirements are all about how these two
entities related on LinkedIn what's your
degree of separation from someone else
who might you be interested in knowing
these are very different class of
systems typical use cases social
networks dating sites for detection is
an interesting one is the behavior of
this person and the relationships that
they've established like those of other
members of their class parcel routing
traveling salesman problem solving
problems like that going from A to B
what is the relationship between this
location this location how do i navigate
through the nose to get there and and
shopping recommendations netflix
recommendations things like that so
those are the four classes of no sequel
databases there are other specialist
prime series databases things like that
in plus BB but broadly on a general
purpose those are the four that you'll
see in the main but they are converging
I appreciate this doesn't show
convergence it's a damped oscillator but
you know looks like it's converging
anyway systems are converging you can do
graph stuff on top of key value stores
because you can model relationships as
key value pairs and if you have a
scalable key value store you can put a
graph processing engine on top
relational databases let you store Jason
as a data type and they let you to a
degree index that Jason although it is
still seen as somewhat opaque and the
architectures are still you know table
oriented but there is a convergence the
query language
Nicoll is an example it's a superset of
SQL so no longer is there is no SQL
piece you have query languages for these
systems and the real differences are the
underlying architectures and that's why
you should consider the problems that
are trying to solve and whether
systems are suited to the right problem
we were trying to shoehorn use cases
onto the wrong platform so part of that
convergence moving data out to to kind
of edge nodes synchronizing your
documents out to to mobile phones back
and forth that's what a mobile platform
is about being for Couchbase and
thinking that stuff back and forth
having the ability to have a sort of
distributed topology and move data
through system route data to the right
people
converging sort of the mobile platform
into the database
it is the direction that Couchbase has
chosen to go and others might be putting
in kind of at the graph piece on top of
Cassandra and things like that okay we
talked about all these different things
the pieces to bear in mind is that those
equals not useful there are very
distinct classes of system you should be
aware of how your database latest data
out if you're going to choose one of
these technologies of the areas to which
they are suited and less suited and you
know less about sort of grouping these
you know the for document key value on
the graph into one area but to say these
are distinct things and I need to choose
the right one in the right place so that
starts to look like this chance of his
mind my typical stack where I have web
logic and then I have my SQL database
what things look like now is more of the
polyglot approach and you know these
arrows with convergence coming
elasticsearch Couchbase you know things
like MongoDB Couchbase can do full-text
search elastic search is still apps do
the best if you need all the bells and
whistles attach elastic search lots of
people are using that in addition to
relational document databases but
breaking apart logic into services
building architectures where these
arrows to an extent might actually
represent a sort of message bus
streaming topologies things
Casca confluent downstairs as well and
breaking apart logic into components
having different data stores that handle
different things and having services
that own the contract for their own data
ending up with a polyglot persistence
system so one service has its own data
store and it's dedicated to its purpose
and the service owns the contract for
how it stores the data rather than a
database backing everything as in the
sort of previous example because from
here we can have long-running queries
slow everything down if we start to
break things apart have dedicated
services and systems serving them then
you can achieve very very scalable
architectures okay that is it the talk I
hope is really interesting counterspace
laughs developers please come and visit
us we're downstairs
we're giving away swag we're giving away
an Amazon echo dot at half plus one but
you need to be there to win it if you
want to hear more blog Couchbase
developer Couchbase tweet get on the
forums going on stackoverflow message me
come talk to me i'm very happy to talk
more generally not just about Couchbase
and about what our customers build and
about their architectures I spend 95% of
my time not at conferences but with
actual businesses so if you want to hear
about applicable problems and what
people are doing I'm really happy to
talk about that and not just talk about
Couchbase itself so thank you very much
for listening and have a good day
any questions in the room we have 10
minutes or so did I hear you right in
saying that Couchbase was descended from
Lotus Notes
well the couchdb the sort of model of
storing stuff as documents as an object
database and replicating at the document
level is the same paradigm as Lotus
Notes Couchbase is the Zen is actually
from memcache D so in memory key value
store and with the document features of
CouchDB so that's where the name comes
from sort of members with the company
that supported memcache D deployments
members plus CouchDB became became
Couchbase but certainly the the method
of arranging data is a descendant of the
Lotus Notes approach okay thank you very
much everyone</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>