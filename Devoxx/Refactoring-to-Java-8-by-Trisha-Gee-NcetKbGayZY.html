<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Refactoring to Java 8 by Trisha Gee | Coder Coacher - Coaching Coders</title><meta content="Refactoring to Java 8 by Trisha Gee - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Refactoring to Java 8 by Trisha Gee</b></h2><h5 class="post__date">2016-11-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/NcetKbGayZY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">right I was wondering when I knew how to
start and when hello um I guess we're
starting yes so I'm Trisha hello I'm a
developer advocate for jetbrains I work
mostly with IntelliJ IDEA and up source
our code review tool and today I'd like
to talk to you about refactoring to Java
8 in the past some of the presentations
I've done have been around how to use
new Java 8 features and a lot of
presentations you see on this topic are
around like sort of thinking in terms of
Java 8 and how we apply them in a kind
of Greenfield type application and what
I really wanted to look at something
which is a bit more like how we as
developers work in the everyday world
which is we have a code base an existing
code base how do we perhaps migrate this
to use Java 8 idioms and and should we
do that as well so I should warn you I
added approximately 45 slides to this
presentation last night and it already
over and before I did that so I'm going
to talk very very fast and also the
initial content for this presentation
has been given before it DevOps UK so
I'm going to skim very lightly over it
and if you're interested in more details
in the introductory stuff then the video
from DevOps UK is available as well so
yes let's get on firstly let's talk
about why Java 8 before we start talking
about migrating to using Java 8 let's
just skim over this really quickly
because this has been discussed a bunch
of times
firstly it is faster generally speaking
when you use Java 8 it's faster there's
a lot of different reasons for this but
it's probably one of the most compelling
reasons for the business and for your
ops people moving to Java 8 generally
gives you performance improvements it is
of course easy to paralyze which is one
of the main selling points I'm and the
question is you know should you really
but we'll look at some of these examples
a bit later on in the code as well
there's fewer lines of code a lot of the
new idioms lambda expressions in
particular helps to reduce the
boilerplate in your code and that's kind
of considered to be a good thing as a
long term Java programmer I really
didn't care that much about this because
my mind sort of ignores boilerplate but
hopefully
as you'll see throughout this
presentation it actually can make things
much more readable to have fewer lines
of code and less boilerplate lambda
expressions and some of the other
features like optional and streams API
can present you with new solutions to
problems so for example being able to
pass around behavior instead of objects
in terms of lambda expressions can help
you design things in a slightly
different way which can help you solve
things perhaps better or solve things
you couldn't solve before and I think an
area which is under underemphasized for
Java 8 is it does help you prevent or
minimize errors in your code optional is
one of the areas that does this because
we can reduce the number of null pointer
exceptions but also things that lambda
expressions can help us reduce things
like copying and pasting errors and
stuff like that and we'll see examples
of this as well
now before we sort dive in and start
looking at this oh you know what I was
supposed to ask you guys something first
and who's using Java 6 millions of you
you poor buggers I'm who's using Java 7
most of you who's using Java 8 more of
you are we talking about multiple
projects here where you use multiple
language multiple versions because like
some of you just putting your hand up
because you need the exercise and who's
using a Java 8 compiler but really
writing Java 6 or 7 code ok a smattering
of you so that's kind of this is kind of
aimed at that so how do we move our code
forward as well as the compiler before
we start talking about refactoring that
I don't want to talk about our safety
harness before we start rewriting code
before we refactor anything we really do
need a good set of automated tests we
need good test coverage we could have a
very dedicated QA team but I'd hate to
do that to them so I'm autumn ated test
coverage is a much better way of caching
to make sure that we haven't
unintentionally done something we didn't
mean to if performance matters to you
you should have performance tests and
run them occasionally um and I'm not
necessary talk about nanosecond low
latency high frequency trading I'm
talking about responsiveness to the user
so we could be talking about half a
second response times but if performance
my
to you in any way shape or form which I
would argue for a large chunk of you
that's true you need to have some
performance tests to sanity check you
haven't done something silly if you're
going to do refactoring you do have to
decide upfront you as a team have to
decide upfront why you're doing the
refactoring because there's a bunch of
different reasons to do this now I'm
going to talk a lot about performance
but and that's quite a compelling reason
for sort of management or operations but
there are a bunch of other reasons for
example you might want to refactor an
existing code base to Java eight to
safely learn about Java eight and
understand some of the trade-offs so
that instead of having to learn a new
project a new domain and new everything
and Java eight you can be learning it in
the safety of an existing well known
product so there could be a bunch of
different goals for why you'd want to do
this refactoring and they're all valid
but and probably you don't want to adopt
all of the goals at once like maybe one
or two would be a good idea and when
you're doing individual bits of
refactoring definitely limit the scope
so maybe start at a sort method level
maybe subclass level and one refactoring
is I did which I'm not going to talk
about because I keep doing it wrong
every single time is trying to implement
optional and that's because it's an API
level change can impact your whole code
base so you sort of impact like 600
classifiers and you've got this massive
check-in and no one can code review that
and you don't really know what you've
broken so try and limit the scope as
much as possible when you're doing
refactoring certainly when you're
starting off now the code I'm going to
look at is a project called morphia this
is an object document object document
mapper which is basically hibernate for
MongoDB there's a few reasons for this
one it's open source so you can look at
the codebase and have a look at the sort
of before and after of these changes -
its kind of small enough to get your
head around but big enough to have
reasonably complicated bits of code like
you find in a real codebase 3 it's a few
years old so you sort of start to see
some of the some of the archaeological
history of different changes in in
styles of coding and some areas that are
right for perhaps being marginally
better than they are right now
so it's more like a real life codebase
that's a good way of demoing how to use
some of these features let's go straight
in we've got 54 minutes for
about 150 refactorings firstly let's
look at we're factoring to using lambda
expressions this is an area where and
you can use automatic refactoring quite
easily some of the areas that refactor
quite easily are changing anonymously
inner types on predicates comparators
runnable etc to use to use lambda
expressions so let's get straight in um
I put mirroring up why isn't it
mirroring I definitely tested this I
might need some tech support at some
point I do have mirroring setup but
apparently it's just ignoring me I won't
say anything about Windows at all and
display preferences there we go
duplicate these displays apply that keep
changes so now I've got only 103 changes
to show you in the next 53 minutes okay
and let's get my script up so what I've
done is I'm using IntelliJ IDEA
obviously I mean I work for JetBrains
but I would have used it anyway
I'm I will be showcasing some of the
features in IntelliJ IDEA but it's not
meant to be an intelligent awk because
Eclipse and NetBeans do have some of
these features in anyways so it's more a
case of if you know how to use your
tools to locate things like make these
refactorings then these are the sorts of
things you should be thinking about as
you apply those changes so I've run a
bunch of inspections and you'll there'll
be a link at the end which shows how to
run the inspections that's really not
the exciting part of this talk and and
these inspections are flagging up places
where we can use Java 8 features for
example this says that there's anonymous
in a type 4 predicate which is a guava
predicate can be changed to an lambda
expression so we will do that and that's
quite straightforward change
we if we look at the changes that have
happened then we basically get rid of
all the boilerplate we get rid of all
the types and all the method names and
all of everything so we end up with just
the sort of business logic from that
method and that's what we have inside
our lambda expression so we don't need
to worry too much about what we do need
to test it we don't need to worry too
much about the impact of this change
because it functionally does the same
thing it did before so let's skip
straight on to some other examples these
are not the most exciting examples
getting the the idea to the IDE to to
make these changes for us another place
we can do it is we may have been running
and creating runner balls all over the
place so we just replaced that with a
lambda expression and again not super
exciting we just keep the core
functionality of the of the anonymous
inner class so we can kind of apply
those across the board without worrying
too much about it we look at the
performance of that in a minute
another place is callable now if I
reflect to this one what we end up with
is a multi-line lambda expression me
personally I like to refactor multi-line
lambda expressions into a separate
method so I'm going to call this found
ten items and there's a few different
reasons for that one we have a much
smaller amount of code which is kind of
nice too it reads better I can see I'm
doing this until I found ten items I
don't have to kind of pause this light
set of code to figure out what it's
doing and three if there is an exception
the stack trace is a bit friendly if
there's section if the exception is
thrown inside a method like this so I
tend to prefer to keep my lambda
expressions very short or delegate down
to a method now so that's kind of fairly
straightforward oh good well done now
you can see all my notes where I say
don't talk about this and ask them that
I really
ah safety blah blah blah morphia
automatically factoring right so that's
fine
if you've got interfaces and you are
implementing an interface like runnable
like callable and you want to implement
it as as a lambda expression now what
you might find is I bet you any money
when I go out with this it's not
mirroring anymore and you might have
abstract classes with a single abstract
method but unfortunately if I show you
an example of this I've got one here
this is an abstract class and I have a
single abstract method but if I look at
name and implementation of these I can't
turn this into a lambda expression
because lambda expressions can only be
applied to interfaces with a single
abstract method so what I'm going to do
is I'm actually just going to get
IntelliJ to turn this into an interface
I can then flag this as being a
functional interface so that I can
implement so that implementations can be
lambda expressions so now when I go into
my implementation I can just replace
that with a lambda expression so I'm
it's just a small subtle point but
lambda expressions can only be used with
interfaces so you might want to do a
search for abstract classes which you
can convert to interfaces so that you
can use lambda expressions oh this is
not the best way to view the slides I
have a back-up plan oh you know what you
can read that can't you no okay fine
huh there should be a second baht button
oh I know I know I clicked on the wrong
one but I'm just going to have to come
out with that again in a minute anyway
right so let's look at the performance
of lambda expressions because I've just
said willy-nilly you can just apply them
across the board not worry about it
so let's look at one of the examples
here where I had an anonymous inner
class and I converted it to use a lambda
expression
so I've done a performance test using
jmh which is an amazing benchmarking
tool and it shows me that my lambda
expression performs marginally better
than my anonymous inner class so that's
good so we can apply the
and forget about it of course Oracle did
a bunch of work around performance
testing lambda expressions when they
were working on Java 8 so there's a much
more fully featured document which kind
of shows the trade-offs for different
types of anonymous inner classes and
different types of lambda expressions so
you can see that sometimes lambda
expressions don't perform quite as fast
as anonymous inner classes but generally
speaking the performance is fairly
equivalent so you don't have to worry
about it too much unless you're really
you really care about the sort of
nanosecond latency type things by the
way I always find performance charts
kind of confusing because I'm not sure
whether the bigger number is a better
thing or not so I put my smiley faces
and sad faces so that you can figure out
whether a big number is a good thing or
not
so my performance analysis of lambda
expressions is I'm saying
inconclusive to mean you know it's not
really better or worse performance wise
in the examples I've looked at so you
can kind of make your own decision based
on whether you think it looks better
whether you're going to refactor to two
using lambda expressions or not okay but
I've talked about doing just a straight
replacement but I want to talk a little
bit more about that how can we design
using lambda expressions I want to pass
lambda expressions around where perhaps
I wouldn't have done it before so I've
created a structural search to look for
and places where I'm logging something
this structural search says ok I found a
log debug now when I do a log debug I'm
going to create this string and this
variable here is actually a list so when
I call the debug method it goes into the
list it builds up the string
representation of that list and we don't
know how long that list is and then if
I'm not actually logging at debug level
I then just drop that string on the
floor and don't do anything with it so
I've incurred a performance cost that I
didn't necessarily need to take just by
doing just by creating a string and it's
easily done and so often this is why you
often see if log is debug enabled and
you should see log
methods wrapped in something like that
because it stops you incurring this cost
that you don't need to now what I've
wanted what I want to do instead is I
want to create a new method on my logger
which takes a lambda expression instead
and this is a subtle change because here
now I'm providing the recipe for
creating the string rather than actually
building the string so let's create this
method see what it looks like and it's
going to take a supplier of type string
let's call it string supplier and so
then this takes a lambda expression a
recipe of how to build this now
obviously because this is on an
interface I'm supposed to implement that
method on all of the loggers that I have
that I have defined and I don't really
want to go into all the different
loggers and implement this method
especially when I have a default set of
functionality for this method
fortunately Java 8 has default methods
on interfaces so I can create a default
implementation for this and I know what
that looks like I want to say if is
debug enabled then call debug with
string supplier get and only at this
point do I build up that string only at
this point do I go into the object and
try and find the values and smoosh
together the string only if I absolutely
need to and on top of that I don't need
to implement this method in all the
different loggers I've already got the
default implementation right there so
that's good that's good for performance
because I'm wrapping it inside the if
statement the other thing it's good for
is if I look at this class here 3 5 7
when you're kind of reusing code in this
way
copy/paste coding it's quite easy to end
up with with an error like this so I've
got an info call inside is Trace enabled
but if actually instead I'm calling the
the lambda method which has the if
statement inside it I've basically
removed that copy/paste error from
everywhere it's just contained within
the one place so here's in a place where
lambda expressions can help reduce some
of the errors by allowing us to kind of
create the boilerplate in one place and
inject the lambda expression which will
be executed in the
middle let's undo that so we still
compile okay so let's look at the
performance of this lazy evaluation what
I've got is I've got a bunch of
different methods the first two take a
amounts up there the first two take a
constant string which isn't changing I
mean the second to take a string which
is more like the sort of strings we see
when we're logging
it takes some value which is going to be
appended so I have to create that string
and we find that the when you're passing
in a constant string obviously the
performance is pretty good because it
doesn't really have to incur any sort of
cost but when we have to build up a
string but not do anything with a
message this is if we're not actually
logging the message then that blue block
on the right hand side that's where
we're incurring the cost of building up
this string and it's a very simple
string it's just a string with an
integer um and so we incur this cost and
we don't need to with a lambda
expression where we just create the
recipe and don't do the string building
stuff we get the same performance as if
we'd passed in a static string so this
is a good thing
this means that using lambda expressions
to implement lazy evaluation type
patterns is going to give us a
performance win all right
lambda expressions we've got 42 minutes
four collections and streams good the
simplest place where you might want to
refactor collections and rays is to
instead of use a traditional for loop
and use the for each method
so for each is available on a on the
streams API but also on a bunch of
collections so you don't have to just do
collection streams for each things like
lists have for each on it anyway and
IntelliJ will work out which one you
want to use so let's have a look at some
examples of this here we've got an
inspection which says these are all
under Java language level migration my
AIDS which you can't read because I
can't read it on here okay
alright so the kind of simplest example
of this is where we have a we haven't
set in this case we're iterating over
that set and calling some method so
IntelliJ suggests that we can just
replace that with a for each and that's
nice and simple we just lose all of the
for loop and simply say look for every
one of these things call this method so
that's a really nice simple win we can
go further if you want to we can we see
that this variable is only used here so
I'm going to inline that and then we see
this variable is only used here so we
can inline that so I basically just got
rid of a whole bunch of code and now the
code is a bit more descriptive it says
look for all of these types just do this
thing okay let's look at a more
complicated example because you know
life is usually more complicated than
this so here we have a for loop a for
loop an if statement and then we're
adding something into another collection
so let's see what IntelliJ wants to do
with this well that's quite nice it got
rid of a whole bunch of code for me I'm
not sure I can pause what the other
thing does but it got rid of code for me
now if we look at the before and after
what we've basically done is this for
loop has turned into a for each and this
if statement has turned into a filter
and then this code which is the new call
gets put into a map and in the end
everything is added to this to this
collection so that's kind of cool but
sir it's an improvement it's not perfect
because we still got another for loop up
here but I'm it's it's an improvement
and here I'm using IntelliJ IDEA 2016
point three which is due out any minute
now and and this refactoring is an
improvement over the refactoring
available in 2016 point two and I know
that because I gave this talk for 2016
point two in this morning when I did
this refactoring I was like what is that
it's totally different and much better
so this is kind of cool
this is moving in the right direction
but not perfect because we still have we
serve this other for-loop but you might
choose to take some of these automatic
refactorings to move you in the
direction of using java 8 or you might
look at this and go well actually this
is a bit of a smell because really we
shouldn't be doing four loops followed
by four loops full of our four loops
perhaps we should be restructuring our
data and rethinking about the way we do
our stuff so that we can use a single
stream operation and the last example is
another fairly complicated example okay
I did say here we have an if statement I
didn't make any this code up by the way
this is real code an if statement our
for loop an if statement a for loop and
if and then an else now because we've
got an if and then an else this has got
two different code paths so we know we
can't refactor this we kind of refactor
away that if and there else until inside
the stream pipeline because the stream
pipeline really only does one thing but
let's see what IntelliJ can do with it
we can replace it with a for each now we
have a stream a filter a flat map and a
for each so let's see what bit went
where we've got two for loops so the for
loops got collapsed into a single flat
map so that's quite cool that means
we're now doing a single pass a single
iteration our if statement predictably
went into a filter so we kind of have a
little bit more readability here we have
our if in a filter and we have flat map
so that we're doing everything in just
one pass of the data we still have as I
suggested my if-else and another if up
here so for me I think the fact that
this can't be automatically factored to
a simpler stream operation suggests that
I have to take a look at my design step
back a bit further and see if there's a
better way of creating this operation
basically so I can do a single stream
operation
okay so we did that and let's look at
the performance of these things so
here's one where we did the really
simple collapse into using a single for
each and in this case we have the
performances more or less the same so
that's great we can go ahead and
collapse that without worrying about any
performance implications and with the
the first complicated example where we
ended up with a flat map we also get
very similar performance however if you
look very closely you'll see that the
performance is actually pretty horrible
because in the original and refactored
we're getting not 0.6 ops per
millisecond which is it's not very many
so I think in this particular case the
cost of the operations were doing inside
the loop is so high that any cost of
doing the actual loop iteration doesn't
matter so it doesn't matter how we're
iterating over those collections we
still get the same performance on this
slightly more complicated example where
we did a stream and a filter and a map
and a for each we find that the
refactored code is not quite this
performant and here we see the
performance wasn't as horrible to begin
with we're getting sort of thousand
operations per second so here I suggest
that perhaps because it's a faster
operation that's happening inside the
loop we have a slightly higher cost for
using streams than using the traditional
for loop so that's something to be aware
of so sometimes using the new patterns
will not make a difference and sometimes
the new patterns might perform slower
for you
so definitely somewhere an area where
you probably want to do performance test
if it matters for you okay the next easy
refactoring for for loops is to turn
into a collect so a collect is where we
were iterating over some collection
looking at some values and then pulling
them out into another collection
escape that go over here all right so
our first example here this is a kind of
typical piece of code we're going to
iterate over a list of keys we're going
to pull out the ID of that key and put
them into a list of ID's so this happens
to be initialized with an initial
capacity and which may or may not be a
premature optimization aisle performance
test that later if I take that out then
I can refactor it directly into collect
I'm going to inline that so we've got
rid of all of our boilerplate around our
for loop and we just basically do a map
to get our ID and a collect into a list
so it's a bit simpler to understand what
what that code is doing okay and the
next example here we have we're
iterating over an array of fields up
here and we're putting things into a
list of fields so we're going to filter
out a bunch of different values and put
them into a list so if we refactor this
I'm going to inline this variable now
it's kind of a little bit icky because
what we have here which you can't even
see is some slightly complex logic
around which values we care about and I
can get a clue for what that is because
look I've got comment here which says we
ignore static and final fields now I'm
not a big fan of using comments where
you don't need to so I suggest we
refactor this into a method which says
is not static or final and then I don't
need a comment to say I'm only only care
about the non static or final fields so
now my code is much much simpler I just
got rid of all this nonsense and
simplified it down to a single collect
notice however that because we're
iterating over an array of fields we
have to use a raised stream so we're
going to create a stream from an array
there so let's look at the performance
of this
so this was our simple
I want to performance check three things
here one is our original code which had
the initial array size the second one is
removing the array size to see if it
mattered and the third one is to use the
refactor code now it turns out that
initializing the way to the correct size
for an array of size 10 really makes a
difference you get much better
performance for that sort of thing
and our refactor code is the orange
block the orange bar is not looking so
great performance wise for an array of
ten elements I'm over there on the far
end where you can't even see it the tiny
yellow sliver is if we added parallel to
magically speed this up I'm glad you're
laughing for ten elements parallel is
not going to do anything for you okay
because you've just basically split it
up over a bunch of cos and like farmed
out over here and then had to pull it
all back together again for ten elements
is completely pointless
we're parallel starts to come into its
own is them with my performance tests I
only really start seeing good
performance from parallel around ten
thousand elements okay so like a hundred
elements doesn't matter a thousand
elements so we're talking big arrays
we're parallel starts to matter and then
of course it not only overtakes the
performance of my refactored serial code
but starts to get better performance
than the original array code I'm sorry
list code now there are reflection utils
which is where we refactored to use
arrays stream we also don't get much
better performance for using a collect
on the arrays to stream so automatically
using collect is not necessarily going
to give you any performance gains and
you might want to well it's not going to
give you any performance gains it might
give you some performance losses so
you're really going to have to consider
is this really what I want to do now an
area where I think streams is really
interesting is to be able to collapse
down multiple operations into a single
stream operation now developers can't
always think like this which is why
we've had code which sort of iterates
over one list does a bunch of things
takes that list thinks about something
else does a bunch of other things and
then does a bunch of other things you
can collapse a lot of those things into
a single stream operation much more
easily so to show you some examples here
what we've got is we are iterating over
a collection it's a set actually and
then we're going to put some values into
another list and then we're going to
sort that list and then we're going to
do something else with it afterwards so
IntelliJ IDEA suggests we can change
this into a collect statement and in
fact it noticed that because I had a
sort call at the bottom after the for
I'm it can just add sorted into my into
my stream operation so it's just
collapsed that into a single operation
that's pretty cool but we can go one
step further the IDE hasn't noticed this
but we can notice this what are we doing
with this list well we're going to
iterate over again and do something well
that seems kind of silly I don't need to
do that I can just say for each of these
log lines do log line log and then I
don't need to assign it to anything
because I'm not doing anything with it
and I can get rid of all this code so
this I think is where streams give you
the big wins okay I've just collapsed
down to four loops and a sort operation
which is effectively also doing
iteration into a single operation let's
look at another example so here we have
it's not obvious that there's a bunch of
operations going on here but we are
doing we're looping over one collection
and then we do something else
to that collection at the end so this is
also initialized with an initial
capacity so I'm going to get rid of that
and refactor this so that's that gets
replaced with a collect statement now
what happens to it my fields I end up
calling two array on that because it
needs to be it needs to be an array
because I'm passing it in as varargs
so let's simplify this code drag this
out field ray in line this
so now I have a single operation I'm
doing a stream a map I collect - a -
array be warned this is not a single
operation the collect is the terminal
operation from the stream the two array
happens on the list that was the result
of the stream operation there's not a
single operation this is still two
operations however we can still win
because actually you can just call to
array straight array straight away with
a method reference and we've just
collapsed that down into a single into a
single stream operation so this is
exciting let's look at the performance
so our mapping validator where we
collapsed our two loops and a sort
operation into a single stream yeah we
get better performance from our refactor
code it's marginally better by them but
it is better performance so this is
definitely a good thing now the other
thing I wanted to test is my original
code where am i what am I looking at my
original code and oh yes and I want to
test the code and the code with the
naive refactoring to the collect
followed by the two arrays and then the
updated refactoring where we go straight
to arrays so here we see that the
refactor your initial note the naive
refactoring is not quite as great but
when we do a single stream operation the
performance is as good as doing the
original code so um I'm saying
inconclusive because the performance
kind of it depends and it's not
substantially better in all cases but
you have the choice there of refactoring
to use Java 8 idioms and knowing that's
not going to negatively impact your
performance all right
26 minutes great we've got loads of time
we're doing really well why did I say
that something terrible is going to
happen the demo gods hate it when you
say things like that right and any match
this is a new refactoring in IntelliJ
IDEA 2016 point 3
and we are going to type converter again
this is kind of typical sort of code
that we'll find in our code base you're
going to iterate over some array or some
list or something look for some criteria
and then return true or return some
value otherwise return false so this can
be automatically factored into and any
match because that's what the any match
feature does okay you're basically going
to find anything find if anything
matches some criteria again note that we
have to use arrays as stream here
because we're talking about an array
here not a collection IntelliJ also
wants me to replace that with object
equals which is kind of fine it and stop
to you making silly mistakes sometimes
with null pointers etc um so that's kind
of cool let's have a look at the
performance of this must be a keyboard
shortcut for that one of the good things
about this of course is that we can we
can use the magic parallel incantation
to make everything better right
all right using any match on type
converter the performance of using any
match is substantially worse than you
the performance of iterating over the
array to begin with of course parallel
doesn't work this is for ten values so
parallel gives us nothing looking at it
for ten thousand values we're still not
really getting any closer to the
performance of just iterating over the
array and a hundred thousand values then
parallel overtakes and the refactoring
without parallel but the thing is that
array operations can be extremely
efficient especially trying to find the
first value in an array it can be very
efficient for the CPU and the compiler
and basically all parts of your machine
to iterate over an array so sometimes
I'm using the the new idioms is not
going to give you better performance
than that so any match may not perform
faster however there is a caveat to that
I think it might actually be the arrays
dot stream which is going to slow down
your performance in this particular case
we've got a similar thing where instead
of any
which returns a boolean that says does
something match this criteria we have
find first so give me the first vote
first value that matches this for
example we are going to iterate over
some values and return the first thing
that matches some criteria intelligence
on the kind of like I guess super smart
thing it's now using int string range
instead of using if we look at the
original code in so doing them you know
for loop with a 0 up to whatever length
is we can use in stream that range it's
also using mapped object so that we can
get our the value we want is using
filter and it's using find first so
we've got a like a fully stream
compliant piece of code here which is
cool I guess let's look at another
example now here what we're doing is we
create a new array hold on we create a
new array of four values and then we
iterate over that to find out if we
actually have any of the values in the
class that we're looking at and that's
kind of let's inline this and we can't
see this because the code is so
ridiculously long so that's kind of fine
we can create arrays dot stream of this
array that we created of four values we
could do something a little bit simpler
we can get rid of this because I
streamed of and we can give in those
values so we don't have to mess around
with creating any array stream instead
of creating an array and then passing it
to a raised dot stream we can just say
stream of these individual values and
then we're going to use our filter and
I'll find first okay that's kind of I
guess it's a bit more readable than our
for loop with our if statement and our
final example oops
this is kind of a more classic example
where we have some collection we're
going to look for anything which meets
this criteria and return the first one
we find otherwise return null and again
intelligence kind of figure out that
this whole full loop can be collapsed
into fine first but also that our return
null gets collapsed into an or else so
we can kind of add that value as the the
I didn't find it value okay so that's
fine first let's look at the performance
shift f5 thank you killing me what was
it doing fine first right so this is one
where IntelliJ uses an in-stream instead
of using iterating using such
traditional indexed iteration and not
really super surprisingly the the Java
eight code doesn't perform quite as well
as a classic iteration because really
there's just what was there there's just
not that many value so you're just not
going to have you're creating a whole
series of objects and a new industry
when I knew this for a fairly simple
application a fairly simple example find
first this one where we write we've got
four values that were iterating over we
can either do a raised stream with the
with the array or the stream of so I
want to performance test all those
things regardless of which of the two
refactored options I take the
performance is just not as simple as
doing a simple for loop because there's
four values in there I mean it's really
it's not that complicated and the last
one where I think it's it's more
readable and a little bit prettier to
use the fine first again we're just not
getting better performance out of that
that's for ten elements in the list
however of course as you add more
elements to the list and if you want to
paralyze it that's when you start to get
the performance gains of using streams
so find first migrating to using fine
first um is I would test it before
jumping straight down there I'm if you
want readability it's definitely more
readable
if you
but a performance well you're gonna have
to see my final example is a new method
on collections this is not part of the
streams API which is remove if on the
collection and let's look at this entity
scanner now here we had a piece of code
where we're using an iterator we're
looking at every item and then if it
meets some criteria we're going to
remove it from the iterator and IntelliJ
suggests where did all my code go it
just basically gets rid of all of the
iterator Croatian all of the iterating
over the iterator most of the comparison
and sort of the actual remove thing you
end up with with a single line of code
which is much more descriptive
it just says from this collection remove
anything that meets this criteria so
it's a that I think for readability is a
massive win let's look at performance oh
I forgot the keyboard shortcut already
and shift if I'm not gonna have to do it
again now I'm not going back out with
the ID of the presenter anymore I don't
know where I live now right
remove if it's much prettier and the
performance is better so I've said
inconclusive because I wanted to say win
but basically the performance is
marginally better so you can go either
way
but given how much readability you get
from using remove if I would say and the
performance is marginally better this is
definitely a win right summary of
findings so I have a summary and a
conclusion a bit like some sort of
science project refactoring to using
lambda expressions is very easy to
automate you saw me just kind of
applying those across the board and
pretty safe performance wise you really
there's no sort of major gotchas to
worry about in terms of moving anonymous
inner types to lambda expressions
designing to use lambda expressions in
your method calls so that you can do
things like lazy evaluation can give you
some enormous performance wins as well
so that's a good thing generally a lot
of the new idioms in Java eight really
do in
readability and decrease clutter some of
its going to take a little bit of
getting used to but generally speaking
you have less code for example obviously
lambda expressions is a lot less code
using for each four simple cases is way
less code arguably more readable and
using a collect statement can also get
rid of loads of code and you match we
saw we removed loads of code using any
match find first is a bit more readable
remove if is definitely my favorite we
just get rid of all of that crap and
just have a single method call and
particularly if you're using multiple
operations which you can shrink down
into a single stream operation this is
where you get your big readability wins
so this is where we got rid of two for
loops and a sort operation into a single
stream operation which is much more
readable and was better performance as
well and again here where we we got rid
of a for loop and a two array and just
collapse those into a single stream
operation but be aware obviously using
the Java eight new idioms new API s
there will be some performance
implications one way or another so for
example a raised dot stream is probably
always going to be slower than using an
array the reason to use a raised dot
stream is if you can go parallel and
you're talking about big arrays but
generally we found that the arrays dot
stream is a lot slower than just
iterating over an array using for each
or collect may be slower than iterating
over a collection it depends a little
bit there's not really that much in it
like half the speed is not that much of
a big deal in the grand scheme of things
and if the if the thing you're doing
inside the loop is quite expensive then
it doesn't matter whether use a for loop
or a for each and whether you use a for
loop or a collect parallel is probably
not going to give you any speed
improvements in most sort of day-to-day
coding areas unless your data is very
big so it took 10,000 elements or more
then you're going to start to see the
improvements of parallel or if the
operation that you're doing is very
expensive and you want to farm that out
over multiple
cpu's or multiple cause but there are
some cases where you end up with
improved readability and better
performance for example my favorite
remove if I've got loads of time left
what happened right conclusion so
there'll be time for questions which is
novel and I'm not sure I'll be able to
answer any of them
in conclusion should you migrate your
code to Java 8 I'm it defense of course
it does um and I haven't even taught I
talked a little bit about the safety
nets that you need to apply before
you're doing the migrating but you do
really have to think is there a lot of
value in messing around with an existing
system that works perfectly well just to
start playing around with lambdas so it
depends you have to remember what the
goal of your refactoring is so the goal
might be performance it might be
learning it might be readability it
might be so that you can use the code
amongst developers who are used to using
more functional styles for example and
you have to compare the results of your
own fracturing to that goal so some of
those refactorings where we still ended
up with like a for loop with a stream
inside and then an if-else I mean you're
not getting a lot of value from doing
that sort of refactoring so it's okay to
back these things out and decide not to
apply them you need to have some sort of
understanding of what may impact
performance streams are kind of cool in
fact streams are very cool especially if
you can do multiple operations in a
single stream but it's not clear which
things are going to be better
performance than others
there are two blocks of code in this
example where the refactoring looks
almost exactly the same and one performs
the same as the original code and the
other performs worse than the original
code so if you're not really sure what
the impact is on performance do measure
those things your tools can obviously
help you so IntelliJ IDEA NetBeans
Eclipse they are going to suggest places
where you can perform these refactorings
and and that's great and we should use
those things especially if we can
automate things like creating lambda
expressions from anonymous igner types
but as you saw quite often you have to
have a look at the code and think about
what more can we do is there an
additional refactoring or is this a kind
of naive approach to doing this so it's
very much down to us to look at each
- okay sand go okay what is this giving
us what more could I do um yeah that's
bad and I'm supposed to have a link to
further reading which clearly I deleted
right at the start of this talk yeah
magic shift f5 yeah thank you I mean yes
thanks very much
so yes I have time for questions
obviously and this is links to all
references so it's all the codes that we
refactored all the performance tests all
the performance test results and these
slides aren't currently live yet the
updated ones I will put them up probably
sometime before next week probably on
the plane tomorrow
any questions oh yes
right so to summarize the question at
the beginning people were complaining
that the stream performance wasn't
always amazing over time performance has
generally got better because tuning can
happen under the hood while the API
stays it stays the same and the question
is should we kind of persevere with
streams assuming that things are going
to get better and I would definitely say
yes I mean my benchmark results
my initial benchmark results from the
start of this year and have already
improved by the end of this year by
running on the most recent version of
Java 8 so Java 8 continues to get faster
it is it is better than it was and
unless you say like a lot of these tests
were micro benchmarks and micro
benchmarks are not super important
sometimes in the grand scheme of things
this library is for talking to the
database so at the end of the day if
something is half as fast in the code
the call to the database is going to way
outweigh that in which case applying
things like streams or any of these
other things which aren't so great
performance wise is not going to be a
problem if you're talking about
end-to-end performance so answer your
question more questions yes what about
debugging that's a very large question
um debugging that's one of the reasons
why I wanted to show extracting the
lambda expression into a separate method
debugging for streams and lambdas is a
an acquired skill it's a little bit
different um IntelliJ is much better at
it obviously you can do things like put
breakpoints in streams and your IDE will
help you with that stuff
but yes debugging streams is interesting
and quite often if you're in the process
of debugging you'll want to deconstruct
it out into a series of steps maybe or a
series of methods so that you can break
point at the appropriate places does
that answer the question more questions
I think that's it but feel free to come
up and pester me either now or find me
at the JetBrains booth anytime today
apart from when I'm speaking thank you
very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>