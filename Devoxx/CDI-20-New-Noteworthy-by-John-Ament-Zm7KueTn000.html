<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CDI 2.0 New &amp; Noteworthy by John Ament | Coder Coacher - Coaching Coders</title><meta content="CDI 2.0 New &amp; Noteworthy by John Ament - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CDI 2.0 New &amp; Noteworthy by John Ament</b></h2><h5 class="post__date">2017-04-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Zm7KueTn000" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">enjoying
devoxx us so far cool alright so I was
asked to put together this presentation
this originally wasn't scheduled so they
wanted to put on a second deck around
CDI 200 so I decided to split things
between CDI to the new and the
noteworthy features as well as a
separate CDI 2 topic Thursday 250 to
talk about CDI and an se environment so
a little bit about may CD a member of
the CDI expert group along with Emily a
few other things that I've worked on and
there we go so one of the things you
point out is the CDI spec is always
growing we are an Apache 2 license
specification one of the few that are
out there because of that we're always
taking community input and we want to
build on top of the open-source
community we do have a dedicated website
at CDI SPECT org we did just complete
our public review ballot as well so you
can go out you can see what we are
actually reviewing and believe by April
we're gonna have the CDI to final
specification out there for public
consumption well 3 is in the CR state so
you can leverage that today if you're
looking to experiment with some of the
new features in CDI - oh they are of
actively available as a patch for
wildfly in addition to running its
standalone in your se environments I
thought a little bit about this so in ll
20 D I'll be talking Thursday about
using CDI - oh and an SC environment so
because of that this talk is gonna be
very heavily focused on the core as well
as the EE ramifications using CDI I'll
touch a little bit on some of the shared
functionality that's out there but that
talk on Thursday is gonna be focused
very heavily on like the true core as
well as the SE model around CDI
all my material is available on my
github page I forgot to put the full
link to the repo but if you look at the
top of it you'll see it as one of the
bookmarked repositories on github so few
things around the new first the the big
one is the specification split so
starting with CDI - oh we are separating
out a CDI core the core programming
model around dependency injection and
context management as well as the SC
components around it having being able
to bootstrap container programmatically
controlling the bootstrap as well as the
e fundamentals around how to leverage
this in your web applications and your
messaging based applications anything
you might be leveraging on an app server
today there were a number of an event
enhancements that we put in asynchronous
events priority on events for ordering
the ability to programmatically build an
event object which was sorely lacking
from the specification giving you a bit
more control over the true programming
model another key thing is we've
baselined everything on Java 8 one of
the new features you'll actually all the
new features that you see we're done in
a backwards compatible way any interface
that may have been implemented either by
frameworks like camel CDI metric CDI we
made it so that you can still use those
libraries on CDI 200 even though we've
built new functionality on to the core
programming model so similar to the Java
8 specification where default methods
were used we've implemented default
methods and pretty much all the new
methods all the new interfaces that have
been added enhance configuration
capabilities and extensions so one of
the big complaints that we receive not
so much from the end user side but from
the library builder side is the ability
to easily create new beenz without
having to instantiate the ten or twelve
methods required on the bean interface
so we've built out the ability to
configure those without having to
implement the true interface a lot of
those are implements
using functional interfaces so you'll
see a lot of functions consumers
suppliers in use as well as some of our
own functional interfaces that have been
added and the ability to apply
interceptors to produced beans so
previously you could create a new object
you can have a producer method or a
producer field but there is no way to do
things like apply interceptor binding so
we've come up with a way to allow you to
specify those Interceptor bindings
automatically through an interface so
the key thing really one of the first
things that we tackled going into cbi 2o
was the ability was the split out of the
core programming model the java ee based
programming model and the Java SE
programming model giving you the ability
to pick and choose how much of the
specification you want to leverage
obviously you don't get full HTTP
request handling in the Java SE version
of the specification but you do get that
core programming model that we've been
applying Java EE remains the full
fledged feature set and this allows us
to at a later point do things like a
servlet based implementation or a Java
ME based implementation so you don't
have to you don't have to rely on
everything that might not be out there
sorry
no it's so obviously with Java EE you're
getting the servlet specification jax-rs
specification all that integration is
tied into the EE portion of us the Java
SE is really a lightweight how do I
bootstrap a container how do I start in
a stop a request context how do i how do
I apply asynchronous observers in a per
executor basis yeah it's it's pretty
much the core CDI model with a little
bit of things that we identified as
being se specific we've one point we did
talk about splitting out into a separate
SE jar and EE jar to make that clearer
to the end-user about what they were and
weren't using but we realized that it
was two interfaces that would have been
the SE version everything else was
coming from the primary core jar okay
event ordering this I have mixed
feelings about this feature to be quite
frank this allows you to order your
observer methods that would have been
called in any event that is being fired
by your application so if you were
firing some pojo for auditing purposes
or you wanted to capture a login failure
or a login success type of event you can
leverage that through an observer method
however there is no way for us to
control which observer methods were
being called in what order by using the
priority annotation you can specify
through application code I'm going to
call oh really not on the caller side
but on the receiver side I want to
subscribe to this event with this
priority on my reception so if an
exception happened earlier in the stack
you would never actually get that
observer fired to you because it was
already terminated prior to being
invoked I have mixed feelings about it
because you're now putting a very tight
coupling between the observers that are
being pushed out there so I would
caution anyone to be very wary about
when you do and don't want to leverage
this feature programmatic events
previously cd-i one OCD r11 you had a
beam manager fire event method allowed
you to take any payload and just fire
that event there's no type checking you
could specify the qualifiers on that
event but they were never really looked
up for you using get event now you can
build a fully functioning event object
so that you can then chain through go to
the right type of object right go to the
right qualifiers or that object the same
way you would with the injected event
object we're really we realized that we
needed a feature like this to support
asynchronous firing of events we looked
at adding a fire async method to be
manager but it started to become
redundant with what we were already
doing so we decided to introduce the
ability to get event in formally
deprecated the fire event method
allowing users to still use that but
encouraging them to use the get event
object for the full-blown feature set
this is the only way that you can really
control things like your executor
service is going to be used for your
asynchronous events as well as giving
you the clean programmatic builder
interface of specifying qualifiers and
types to me one of our coolest features
the ability to fire events
asynchronously so we never really
specified it in older releases but every
event was fired and observed within the
same bounded context you had a request
scope that thread was inherently always
the thread that received your event we
introduced the ability to fire an
asynchronous event purposely so that it
could be handled and not having to worry
about the results of that event coming
back to you there is no programmatic way
to get the result of an event when it's
been fired you can mutate the input
object however with asynchronous events
you now have the completable future to
go through and
look at what the result was sorry
so if you look in here I've injected a
regular event object oh shoot sorry
there we go better cool so in here we're
injecting the regular event object just
like you would for any other use case
except now we're leveraging the fire
async method which takes in whatever you
want is your payload object as well as
your notification options optionally
there is still a fire async that just
takes the pojo for you which returns
back a completion stage so you can do
things like monitor the result if you're
interested in seeing the result however
you don't have to do anything with it
you can still do fire and forget on
these objects by using the notification
options over here I'm specifying that
everything is going to go through a fork
join pool that I'm specifying with
parallelism of to allowing me to control
the number of threads that will be
executed so if I had two observers each
one would be observed in their own
thread there are some downsides to this
so if you have a exception being thrown
one thread may receive it the other
thread may not receive it depending on
the order of execution so you can also
specify
you can also specify a arbitrary options
it's kind of like a builder pattern for
anything that's platform-specific so you
can do things like tell well that I want
to use a fork join pool instead of a fix
thread pool size and weld will take care
of that for you but unfortunately that
is platform specific so it would be
leveraging something directly from weld
or from open web beans to bringing those
features ok the other thing about
asynchronous events is if you look here
I have an async firing and in a zinc
observing I have to define this as a
contract in CDI 1 oh and for any
synchronous events that you have fire
receive I can define this and in this
case this observer method is meant to be
invoked synchronously whereas this
observer method is meant to be invoked
asynchronously this observer method down
here the sync receive method will not be
receiving this event because it does not
support asynchronous events it only
supports synchronous events I would have
to do this
and now this event will get fired and
received here whereas this event over
here will only be observed within the
asynchronous receiver I can still
monitor it however I have no way of
calling both receivers here so you have
to be very careful when doing
asynchronous that you're ensuring that
the client knows that you're doing
asynchronous and if you are the client
that you are correctly firing a
synchronous or asynchronous event you
know you so you specify the pool at the
firing side not on the receiver side
it's so another way to put it is you're
specifying how the receiver is splitting
off into multiple threads to send the
events rather than how many threads will
actually be doing the receiving of that
event so we're effectively looking at it
as asynchronous from the sender side not
necessarily asynchronous from the
receiver side async events don't support
priority so one of the examples I gave
while ago is you can specify here the
priority of this method
you can specify the priority over here
indicating that this should have a
higher priority however asynchronous
events don't support that because
they're all going to be received
asynchronously we want to try to get to
as many of them as possible however you
do run the case that you may have caused
an exception that caused one event to
not get fired it also depends on the
executor that you're using so even
though I have one observer here my
parallelism is set to two that doesn't
necessarily mean that all of my
observers will get called at the same
time so if I added more methods here two
and three my parallelism is set to two
it's going to wait until maybe this one
and this one are observed before it
calls this method here to handle the
event payload that's come through you
also have to be very careful about
mutating your event payload there's
nothing stopping you in Java from
introducing a setter method here on this
poacher
there's two problems that will happen
here one is that your SAP method could
cause concurrency locks if you are
synchronizing or not synchronizing
you're also not guaranteed which method
is going to be called when so as a
result you don't know what the final
outcome of your POJO is going to be here
you could get into data that has been
manipulated in the wrong way as a result
of firing these in an email way in a
mutable way so be very careful when
you're dealing with these types of pojos
that you're not mutating the payload or
expecting certain mutations of the
payload to occur prior to receiving the
input your context do not propagate with
asynchronous events so if you're doing
something like starting off from a
jax-rs request which has a request
context bound to it you do not
necessarily receive that st. well you
will never actually receive that
original request context in the
asynchronous event so this payload over
here if this event was being fired from
a rest call a servlet at a jax-rs call
there is a request context bound within
the scope of this method however it is
not actually the original HTTP request
that was received so you wouldn't be
able to do things like look up the
jax-rs context for it or have access to
any request context objects that were
bound in the original request it's
always new it's always meant to be
asynchronous it's there's no form of
propagation of those payloads you would
have to build up a POJO here that
actually maintained all that state for
you so if you are looking to use
asynchronous you need to create a very
stateful object to pass over to that
additional thread
okay so Java 8 Java eights been out for
two and a half three years I think we're
now aligning the CDI two Oh
specification to Java 8 everything that
you're leveraging within it has to
compile to Java
you can't compile down to Java six in
CDI 1:1 and CDI one two those were
effectively baseline to Java 7 however
they didn't actually require Java 7 to
do any of their operations so the
supposed to keep the implementations of
those remained on Java 6 for quite a
while I think well 2/3 was the first one
that actually required Java 7 and I
think owb 1.7 is the first you require
1.7 as well however going out of the
gate everything that is implementing CDI
2o has to baseline on Java 8 this does
mean that libraries may need to get
recompiled your application if you're
not already on Java 8 may need to be
pointing to Java 8 to leverage it but we
are expecting that to be as part of the
Java EE 8 specification one of the cool
things added though was the ability to
inline configure beans there's a very
simple example where we're able to add a
bean where previously what you would
have had to do is in all right
you know for help turn off something
so in here in Prior versions you would
have had to do something like this where
you have to implant a beam with all of
these classes or all these methods
already defined for you even though for
your use case you didn't care about any
of these methods you can leverage all
the defaults we thought about doing
things like creating forwarding objects
that were default implementations for
users but when it came down to looking
at what the true use cases were it made
more sense for us to allow you to
introduce configurator objects which
took care of all of your baseline
configuration but still han't allowed
you to over.i things that you really
needed to override so when I call add
beam here I'm getting back a beam
configurator that tells and I'm able to
tell it when instantiating this object
produce it with this call here which is
a sorry it's a function taking in the
instance the instance object here is
just allowing you to do some
programmatic lookup if you need to as
well as destroying it taking in the
instance and the creational context
allowing you to do a very simple
override of 2mil effectively to Lyons
where previously you would have had to
do 40 lines plus of an implementation
just to get to this point makes we're
hoping that it makes developer live
simpler framework users life's much
simpler and you're able to implement
things very quickly
next up this is also Java eight related
so the ability to stream your instances
prior to the implementation of this if I
were to inject any private instance
object objects I would have had to do
something like stream support dot stream
to get a stream object back we're trying
to hopefully make things simpler for the
user so now you can just do objects
that's stream and you'll get back a Java
H stream of all the instances of any
given being that you might have out
there so if you take the classic credit
card payment processor example that has
been used for years on end you can now
go through all of your payment processes
and make sure that they're online just
as an example you can now go through and
just easily loop through them checking
some method within each instance that
might be out there to me the very easy
use case is now you can do something
like filter
yeah filter like Oh objects on null do
some basic filtering the objects get
back to right object you're looking for
and as long as that is resolvable you
can then do real work with that
individual instance or you can go
through and just loop through all the
instances that might be out there which
led us to another feature you can this
isn't really Java eight related it
wasn't quite sure where to put it but
you can now do a very simple instance is
resolvable method previously you had to
do things like if instance is not
ambiguous and instance is not
unsatisfied which gave you very clear
issues like you can check to see is it
is there only one being of this type
available or is it actually satisfied
based on the resolution that I may have
done you can now check to see if that
instance object is now fully resolved
and do work against it so if I did
something like this
I now have direct access through the
one-and-only beam that was identified
through this instance object and able to
do work against it also helps them file
out of your code and also we support
repeating qualifiers so starting with
Java 8 you can now put the same
qualifier on an object I'm sorry you can
put the same annotation on a class or
you can put it on a method in Prior
version the specification we explicitly
forbid that and now starting with Java 8
because you can do it at the language
level we have expanded our support to
allow you to have repeating qualifiers
on your beans this allows you to do
things like specify that something as
both a check processor and a credit card
processor and using the same annotation
rather than having to create the wrapper
annotation around the two makes we're
hoping to make something simpler for you
but obviously we want feedback we want
to hear from the users and get input on
what is working for them what isn't
working for them any cases where you may
have been using annotations in the past
you're gonna be one of you're gonna want
to be very careful as an extension
writer that you are using the get
annotations method in cases where you're
getting qualifiers of a certain type you
can't guarantee any longer that you have
a single annotation available to you so
you may run into some issues with some
frameworks until they get caught up with
this baseline version adding support for
qualifiers of repeating types one in
case where I can think of that you might
run into issues if anyone's using camel
CDI
that may not give you the right
implementation for all annotations so
now on to the noteworthy features these
are things that weren't necessarily
added in CDI 2o
but are very worthy of more talking to
more usage to allow people to work with
them a little bit more and hopefully
find some benefits to what they're doing
so first stereotypes the ability to
declare your own reusable annotations
or different qualifiers as well as
combinations of scopes and interceptors
alternatives the ability to override at
the ployment time what beans will and
will not be used decorators delegate
patterns and the ability to point back
to some underlying implementation for
your use case all the different bean
discovery methods that are out there how
to limit how do you control your
deployment to reduce memory how to work
with unmanaged beans so instead of
having to rely on everything being
injected you can programmatically create
beans on the fly as well as portable
extensions the ability for you to
control things that might be working in
the deployment for you I find
stereotypes to be the most useful
feature I don't know if anyone else is
using them this way but to me they help
build out what your true business domain
is in your application without having to
rely on repeating seven or eight
different annotations on every single
method or every single class it keeps
your class very small and creates
something that's very descriptive of
what problem you're trying to solve in
obviously though these aren't built-in
annotations that you're creating so when
I look at things like spring and it's
use of the component annotation or the
service annotation those are things that
the framework is providing for you
you're not going to find that in CDI
specification but it should be up to you
to figure out what your true business
domain terminology is to pick the right
annotations for your use cases so I can
create a very simple component
annotation which just says every bean
annotated component is immediately
getting the dependent scope type this
makes it available for discovery this
also makes it available as an injection
point I can also say that I want a
service that is always application
scoped as well as always transactional
so anything coming into the service will
start a transaction as well as complete
or rollback transaction if it fails I
don't have to add these annotations
directly to my implementations I can
just put them out there and
they are ready to use I can also set up
things for testing purposes so if I
added a mock qualifier or if I said that
this was a mock service I can add this
to any implementation that might be part
of my run time for my test container if
you're using CDI unit are killing in
Delta spike test control to control all
of your beans at test time you can now
manage them through a single annotation
instead of having to repeat it over and
over again
alternatives allow you to control what
beans will and won't be active as part
of your deployment they don't require
you to make any more changes to your
application structure other than making
the sorry I lost my train floss so
alternatives are typically controlled in
your beans XML however you can control
them through annotations as well the
beans XML format was something we
introduced in CDI 1 oh but its goal was
to allow you to the pull that deploy
based on that deployment descriptor
which beans would would not be active
any time you were to inject this
alternative you'd actually get the
alternative implementation rather than
the original implementation for you it's
effectively doing swapping of your code
without requiring any application
changes however because of that
structure what it meant was your
alternatives were scoped into that
deployment archive are you're being
archived so if you had a war file and
two jar files each of them with our own
beans XML you're now gonna get different
behavior within one jar file versus your
main war file so to fix that we
introduced the notion of global
alternatives the ability to you specify
a priority annotation at the class level
to say that this alternative always
takes precedence over any other bean
that might be in the deployment this
overrode what was in your beans XML and
as a result made it so that you could
use this at runtime and not have to
worry about differences in behavior in
your jar files your war file your ear
file
and then decorators I kind of think of
these three as like the three cool not
often Lee used features of CDI but it's
the ability to just have delegates of
your beings instead of having to rely on
instead of having to rely on creating
interceptors or creating classes that
extend other classes and overriding
which one was and wasn't used it allowed
you to go in and directly say this is
the default implementation I need to add
more behavior on top of that so that
when I get into my use case I can still
delegate down to it to do some amount of
work but not rely on it for every single
use case so if I go here I have some
decorator which just has one method say
greeting I have a default implementation
that just returns the word hello and I
have another decorator the actual
decorator class which I've enabled by
specifying the priority of it saying
that it's going to inject the delegate
which will be some other decorator some
base some implementation of this
interface and I'm saying that because it
has the any qualifier so this will
always wrap whatever is being called and
overriding the method to say even though
the base said something else I'm saying
goodbye' allowing you to delegate some
work down as well as build your own
business logic on top of it being
discovery being discovery is very
confusing to most people it's a very
it's a very strong topic because of how
feature full it is and how much it is
and isn't controlled by what your
application is doing and because
effectively with every release of cd-i
we've made some changes to be in
discovering CDI one oh you just needed
an empty beans XML and what that meant
was classes within this archive were
discovered
and you got no CDI functionality if
there was no beans XML file present we
saw that that was problematic for a few
cases and wanted to introduce some new
functionality so when we moved to CDI
one one Java EE 7 first introduced at
CDI is always on as you deploy your
application your app server turned on
CDI support for you there is no optional
feature anymore
we were Java EE was trying to adopt CDI
as the core program model-making so that
everyone could leverage events could
leverage the dependency injection
features because of how widespread it
started to be used prior to it you had
jax-rs support WebSocket support servlet
support the more and more use cases came
out the more we felt that everyone was
using it within CDI 1:1 and 1:2 we
introduced three new bean discovery
modes which were only activated if your
CDI version was set to 1 1 or 1 2 and
allowed you to control whether every
class was being discovered as a managed
bean only annotated classes with
properly scoped defining class
annotations were being discovered or
none saying I don't want any cai support
in this archive we actually had to
change what some of the default behavior
was around this to handle CDI one two
because people quickly found out that
their maven deployments started not
working when using GlassFish embedded
with EE seven
CDI 2o introduced two new concepts for
you to use bean discovery one is very se
specific I'll be talking about that on
Thursday but also the ability to trim
your archives which is available no
matter if you're using Java EE Java SE
trimmed archives were our answer to
create something that was a little bit
more than annotated but not quite fully
every single class that was defined
within your application we wanted to
ensure that things that had some
annotation on it that we had this
covered we're actually available as CDI
beans even if that wasn't necessarily
what you were looking for so we wanted
to trim that down and say we're gonna
look at all classes but the only ones
that we're going to consider a CDI beans
have to have a scope they have to have a
qualifier they have to be annotated as
alternative decorator
some sort of defining annotation on them
to be picked up so cut it made it a
little bit bigger than annotated because
we found annotated was too restrictive
but we also couldn't change the
definition of annotated because of java
ee rules and then java SE with its own
behavior and requirements i'll be
talking about that on thursday unmanage
means this is really for the use case of
having some object out there that you
want to do some dependency injection
into without it being available as an
injection point so any unmanaged
instance that you might be working with
is not available to inject into unless
it has defining annotations however you
can still instantiate it using CDI using
unmanaged instance to get a reference to
it to work with for a short period of
time you have to go through all the
standard CDI life cycles which are
called out here so you have to produce
it which creates the instance inject
into it meaning any injection point
defined within that class gets satisfied
by some other being in the runtime as
well as call post construct on it so if
it has a post construct method or a pre
destroy method we do support the ability
to call those lifecycle events
optionally if they're defined if
obviously if they're not defined we
don't call anything on that bean and
then finally call get to get back that
instance that was created through this
chain allows you to work with that
object for a certain period of time
within the scope of maybe a method call
or a succession of method
until you're done with it at which point
you have to go back to the original
unmanaged in sense pre destroy it and
then dispose of it making sure that
you're cleaning up any dependency on
that beam so that you don't have leaking
instances floating around
unfortunately the contextual side of
cd-i makes it so that these objects are
always managed the beam manager is
always aware of these instances that
might be available I might be running so
you do have to make sure you're cleaning
up after yourself so this isn't a lot of
code but it's a lot of boilerplate code
at least as I see it so I always find it
very useful that if you are gonna work
with unmanaged means that you come up
with some sort of wrapper around it I
like to joke around about the left pad
too often so this might make for a
really good one class library if you
ever got to it we'll see but you have an
unmanageable object here which manages
for you through an auto closable the
life cycle of that object you're always
calling produce inject and post
construct you're allowing a user to get
the underlying instance as well as
destroying it automatically as part of
the auto closeable chain it makes it so
that this lifecycle over here becomes a
much easier to understand try with
resource POC to get you back that
unmanaged object for whatever period
that you need to use it for obviously
this only makes a lot of sense if you're
using auto closeable and you can limit
your usage of it to a single method but
to be honest with you it's come in handy
for developers who forget to close their
objects and create some amount of
syntactic sugar so the last part of this
is really talking about portable
extensions portable extensions are
effectively how we allow libraries to
integrate into CDI they allow you to go
through discover beans handle any
bootstrap events that you may want to do
at the library level as well as any
application developer when we look at
Java SC to handle the life cycle of do I
need to start up a TCP listen or do I
have
you publish an event out to my history
to some service discovery tool to say
that I am now available and ready to
take events the before beam discovery
event is fired to a portable extension
at the startup of a CDI container and
will tell you that it is starting up
there isn't a whole lot of information
you can do for most of these events that
get fired you don't actually have access
to the CDI runtime because these are in
a pre bootstrap state you don't have any
beans that have been discovered yet
you can't inject anything into portable
extensions but you can instantiate your
own objects process annotated type is
fired for every single class that has
been discovered in your CDI container
and will tell you what the class is as
well as what some of the annotations are
on it process annotated type allows you
to do things like manipulate the actual
runtime definition of that object so if
you have something annotated as a
request scoped you can do things like
check the type of class it is and maybe
change the scope of it or add a
transactional annotation to it at
runtime
after type discovery allows you to look
at just some callback events say I've
discovered all the classes here I can do
things like add more classes at runtime
dynamically to the container at this
point that have been looked up through
some other class loader or maybe they're
in a jar where CDI is turned off and I
need to explicitly turn it on process
injection target and process producer
are fired roughly the same time and they
are fired for every single class that
has been found
every injection point within those
classes as well as every producer that
has been found within those classes so
if I have a class with three injection
points and two producer methods within
it I'm gonna see that class come through
five times three for the injection
points and two for the producers to
allow you to do things like manipulate
those calm
even further most of these events are
designed for manipulation purposes so
you're either adding new things to them
or you're removing something from them
process injection point just looks at
every single injection point to find
within all of your classes to make sure
that it is satisfied correctly and has a
being eligible for them so every add
inject that you see in there is
available to you and you can start to
manipulate them process being attributes
and process being are also fired these
are process being attributes is for the
base class being extends from being
attributes and just has some additional
metadata from their process being
attributes is really for the underlying
being whereas process being is for the
actual beans that has been identified by
CDI and has been wrapped you'll see this
actually get fired in a circle between
after being discovery and process being
after being discovery allows you to add
more beans at runtime every time you do
that it's actually going to go all the
way back to process bean and refire that
event for you
so this can end up into some weird
endless loop we're just constantly
cycling through processes being an
answer bean discovery
you also have process observer method
which just gets fired for any observer
that's been identified it allows you to
manipulate them in some way
after being discovery also allows you to
register additional producer methods
I'm sorry observer methods for event
reception and then you have after
deployment validation so after
everything is run and we've confirmed
that the container is ready to go the
after deployment validation method is
fire event is fired for you this is a
sign that the container is up however
it's before things like the initialize
application scope is fired allowing you
to do things like start up a web
container or programmatically before you
can your application is ready to go so
it's one step prior to the actual runs
and ready to start receiving requests so
that's it that's CDI - and a nutshell
it's a lot of stuff but I'm hoping you
guys enjoyed it any questions so we just
did the we just completed the public
review ballot I think it's called that
happened I think yesterday officially
all executive committee members who
voted voted to accept I think as of
right now the final draft will be
available in April there's a couple of
typos and clarifications that we're
still working through so look out for it
the weld 3 OCR's are available and they
are generally up to par and we we
obviously encourage people to use them
so that we can start finding bugs and
see where we've missed something in the
specification as well as come up with
new features that we might need to add
yep yeah I'll be going through how to do
that on Thursday you can if you are
using Java EE can - play - while fly
though
yep
no it's true
all right well sorry thank you everyone</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>