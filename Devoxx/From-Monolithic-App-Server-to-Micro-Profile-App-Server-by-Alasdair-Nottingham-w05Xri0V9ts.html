<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>From Monolithic App Server to Micro Profile App Server by  Alasdair Nottingham | Coder Coacher - Coaching Coders</title><meta content="From Monolithic App Server to Micro Profile App Server by  Alasdair Nottingham - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>From Monolithic App Server to Micro Profile App Server by  Alasdair Nottingham</b></h2><h5 class="post__date">2016-11-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/w05Xri0V9ts" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay hello I say this is the most
nervous I've been over a 15 minute
speaking session for a long time
probably because I decided to rewrite my
entire presentation at about nine
o'clock this morning and I honestly
can't even remember my first slide so
here goes you know that the fashion
these days is to talk about well the
fashion for ages has been to talk about
everything in these really emotive terms
like I remember when people had
discussions over whether Eclipse was a
fat client application or a rich client
platform because one of them sounded bad
and one of them sounded good and
everyone just uses these terms but
usually there's a meaning behind them so
I work on websphere application server
I've been a developer on it since 2001
and it is what most people would think
of as a monolith and monoliths were very
popular about 4,000 years ago this is
Stonehenge and people would go up in
somewhere in Wales and they would smash
rocks against rocks and form these big
things they would transport them somehow
thousands of miles and they would erect
them and they are still here today but
of course the key thing here is it's a
monolith and nobody's actually touched
it or try to change it for 4,000 years
of course these days this is what I much
prefer thinking about in terms of
building which is Lego and Legos is very
they're all very small bricks they're
interchangeable if I lose one it's very
easy for me to find another one in
amongst the masses of bins of Lego that
I have at home and really in kind of
software developer nobody wants to have
one of these everyone kind of wants to
have one of these where I have
interchangeable parts i can just plug in
and out all the time but we don't
unfortunately live in the real world
software is not like lego most people's
lego creations don't end up looking like
the instructions and
they exactly follow the instructions
when I was a kid I don't think I ever
did anything that looked quite like this
so we all stand out start out and
software with an idea of what our
architecture is and we end up with these
diagrams were used to at least end up
with diagrams and they would show boxes
pointing to other boxes and then of
course over time you know you have to
implement that simple architecture and
you find actually that square should be
a triangle and actually you need a
square room between these two things and
as you progress along these things over
time everything seems reasonable every
single decision is a reasonable change
from the previous one before but very
soon you end up into messy diagrams with
boxes pointing to boxes you have boxes
it should be talking two boxes talking
to the internals of other boxes and at
the end of the day you have bits that
nobody understands and nobody will touch
because here there be dragons and this
is the reality of where we were with
websphere application server it was a
product over a long period developed for
over a long period of time people had
come and gone and we understood you know
we understood some parts of the product
very well and other parts not so well
and why did we end up in in this
position with this kind of monolithic
runtime with dragons hidden around in
places and there are lots of kind of
reasons that you could advance for this
depending on your perspective so some
people might think well developers are
just malicious you know I drew this nice
diagram it's my architecture and I gave
it to a developer and they basically
ignored it and they went and wrote
something else completely different from
the architecture didn't document it
didn't test it and I actually know
people who who have in the past had this
view it's like okay this is the
architecture of course the developers
has done it of course if you're a
developer your perspective is oh well
the person drawing the architecture
diagram has his head in the clouds he
doesn't reality of things what he's done
can't ever work you know it is not
possible in Java to find out how many
causing the processor is but this box
and this architecture diagram tells me
absolutely I need to be able to do that
then of
course your manager wants things done
yesterday if you're in some
organizations your manager isn't
technical he doesn't know how long it
takes to create something he doesn't
know that to build a lego model can't be
done in 15 minutes when it's consists of
four thousands of pieces they want the
results yesterday this is my kind of
everyone in if you're releasing software
what you always want to do is tap the
newest greatest wonderful feature hey
I've got Jake ash might be one thing
that you want to be able to tout it
sounds cool and sexy and useful and
interesting however not all of those
things that you think are cool and
interesting or actually what people
really want what people really want day
to day is the thing that kind of thing
that they use in the product all the
time so that tends to be things like
they don't want to wait 15 to 20 minutes
for an application change to take effect
in the runtime that might be a bit
extreme but and of course the reality is
software is complex organizations are
complex and all of these reasons are in
some way valid in some way completely
invalid there are some developed
malicious developers out there there are
some architects with the head in the
cloud there are managers who want
results yesterday but in general
everyone has a different view everyone
everyone is kind of a mix and you have
people who are completely opposite as
well so with websphere we had this kind
of big monolithic product and we tried
over several years to refactor it in
something that was lightweight and fast
to start and unfortunately I think we
were hitting against this quote which is
a complex system can't be designed from
scratch you have to make it from simple
and when you've got something that is
really really complicated and it already
exists trying to pull away the
undercarriage and replace it right it's
like a house you don't really take the
foundation away and replace the
foundation you have because if you do
that the building collapses and we tried
to do that so what we decided in the end
to do is it was not possible to
completely do a lightweight runtime in a
sensible release cycle so at the time we
started on this path we were doing about
two-year development and delivery cycles
when we came to GA this we immediately
moved to doing it every every year which
seemed like a massive change for our
organization because we weren't used to
doing releases every year now we're
doing them every quarter so every three
months we do a software release and the
way we went about doing it is we said
okay we've got some fundamental
architecture changes we want to make and
we are going to do those over a long
period of time so instead of doing it
all within one release in a two or
three-year release cycle we did stage
one in a in a year stage two in a year
and then stages three four and five were
much faster we moved up to the point
where we could deliver on that every
every three months and we all instead of
having one big product where you get
what we give you and you have to use at
all and if you don't need all of it
tough you still get it we designed
liberty to be based around something we
call a feature and a Liberty feature is
just a small unit of function it might
be the service in servlet container it
might be JSP and it might be jax-rs and
each of those features are just enough
to run an application that uses them and
we spent time essentially refactoring
and pulling out the code from a
websphere run time that we had and then
refitting them inside this this new
architecture we wanted to make sure it
was very simple we had a lot of debates
about how to handle configuration there
were a number of people who wanted to
just put everything inside properties
files but when we tried to do that we
ended up with hundreds and hundreds of
property files and then they weren't
really properties files either because
they weren't name value pairs we had to
introduce some custom syntax to get the
structure right so we end up going back
to xml so the configuration is XML and
we try to keep it as compact as possible
and so we had we had the concept
features we have the idea of the
configuration and we decided we were
going to use osgi
and I've realized my yellow blobs are
not visible I in order to wire
everything together so osgi is
modularity framework it allows us to
create loosely coupled software using
these things could services the services
can come and go and the runtime is it
designed to react to that and it's
worked very well for us the one downside
is I I'm not entirely certain how how
we're going to deal with pixel when it
comes along but we are looking into it
one of my colleagues is currently
involved so and having adopted the OSGi
modularity system we started looking at
how we were going to make Liberty work
and the first thing we did is there are
a whole load of bits of the runtime
component especially the kernel that we
just rewrote we wrote how we did config
we rewrote how we did run runtime
startup and how we did that management
new annotation scanning all these kind
of non run you know non mainline code
paths things that are really important
for getting everything up and running
and we rewrote them based on using kind
of the OSGi backs practices so
configuration is handled by the OSGi
specification for configuration for some
components what we did is we basically
surrounded them that there's actually a
kind of pattern for this in micro
services but I can't remember it is off
the top of my head but we basically
surrounded the existing code that we had
that we knew we had to take pretty much
verbatim we wrote a new rapper layer
inside it and that's how we got it up
and running inside the Liberty
environment and the advantage that we
had here is if we didn't fully
understand what was going on inside the
box because the people who understood it
weren't available we could still make
progress and we have since been able to
make improvements to what's inside of
the box without affecting what's outside
the box and in some cases we had a jar
file which had a load of binaries and we
wanted to keep the code common between
this new architecture in the old
architecture so we over wrote some
classes and we created new merged jar
files so those were the three kind of
patterns that we we use to do it
and kind of what why and that
unfortunately led me to this realization
when we first released it which is okay
even if you set start with your simple
systems collaborating they they do
actually just involve into more
complicated systems and the realization
we came from here is trying to create
simple external simple user excels high
it means that you have we ended up
having to create a lot of complexity in
the runtime so we actually ended up with
some emergent behaviors that we don't
fully understand in the system now this
was a journey that we went through and
we're still going through and creating
this turning this monolithic runtime
into a more kind of micro
capability-based runtime and the it's
similar to the journey a lot of people
are making with turning going from
monolithic application architectures to
Mike reservist ones so when when P we
had finished doing Joffrey seven and
some of the other vendors that been
doing java ee 7 we kind of had a look at
what was next and java ee 8 certainly at
the time we started these discussions
was not moving very quickly it was still
on a multi-year release cycle so and we
recognize that there's a lot of good
stuff in java ee it's not all bad i know
it's got a lot of bad rap and they're a
lot in there that nobody ever uses but
some of the core behaviors and
specifications in java are being used
successfully for micro services but
there are also holes so javi hasn't been
moving fast enough and at the time we
kind of started discussing we weren't
sure if it would speed up again although
fortunately a java one oracle reassured
us that things were all full steam ahead
again so reaction of we've got slow
Joffrey and we've got fast-moving
microservices realm led a set of
companies and Mike who's in the audience
will recognize this try it slide because
I stole it from him so a whole it of the
Chan of Java vendors got together and
said well we want to speed up the
evolution of these new standards so IBM
Tommy tribe by our red hat
hammock and also some community folks
got together and what we wanted to do
was start with a basic kind of
foundation for what we thought most
common new applications would likely use
which was CDI jax-rs and JSONP and then
be able to rapidly innovate and build on
that to to come to a kind of consensus
based approach on new programming models
for some of the gaps that Joffrey has
which could then be standardized and by
working together we can come to an
agreement and iterate more quickly than
the standards have been able to so in
September release one point naught was
pushed out there and all of the thing
vendors on the previous slide have
implemented micro profile it's being
kind of community driven although
there's a lot of vendors involved
there's also a lot of non vendors
involved in engaging engaging and the
current idea of a release schedule is we
did 10 in September at the moment we're
full speed ahead trying to move it to
the Eclipse Foundation that's because
you having a foundation is a good way to
ensure a level playing field of
evolution of the environment want to
have a micro profile oh I'm out of time
micro profile in 2017 several releases
there's above at a two o'clock tonight
if you want to come along and there's a
session where a whole load of us are
getting up to talk about the sample
application written and i will stop
because I'm run out of time thank you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>