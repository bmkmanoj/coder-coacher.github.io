<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Serverless? Not so FaaS! by Matt Stine | Coder Coacher - Coaching Coders</title><meta content="Serverless? Not so FaaS! by Matt Stine - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Serverless? Not so FaaS! by Matt Stine</b></h2><h5 class="post__date">2017-05-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/e59pTjaVPCs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Birgit you play kit do it
thanks s good morning I know some folks
are still walking in but I'm going to go
ahead and start easing in slowly because
I have a 90 minute presentation that I'm
going to do in 50 minutes don't worry I
have actually been to the cutting floor
a little bit this morning but there's
only so much that I can cut down so
listen fast and we'll we'll get there
eventually right so I'm going to swap
over to my normal deck here for this
particular presentation and full-screen
that okay so my name is Matt Stein I
work for pivotal software and and
involved in a bunch of other different
side projects and things that I do I've
been doing this enterprise software kind
of thing for about 17 years now and the
last five years of that I've been
focused on cloud both the building of
cloud platforms as well as cloud
applications to run on cloud platforms
and very interesting fast-moving space
every day I feel like I know less than I
did the day before even though I'm
learning every day so it's a very
strange way of life spend a lot of time
on the conference circuit I've been
doing that for about eight years now
this is my second year hanging out at
devoxx shows and these are always a lot
of fun start a podcast earlier this year
on software architecture and it's been
asleep now for a few months just because
I over committed the first part of this
year as I tend to do but I'm going to be
cycling that back up here pretty soon so
do you look for software architecture
radio on any of your favorite podcasting
indexes you'll find that and we'll have
some more episodes coming out here
pretty soon and a couple years ago I
wrote this book that maybe a few of you
may have seen very short Cliff's Notes
version of what cloud native archit
is actually all about and what we're
going to talk about very briefly today
is really a natural extension I think of
where that is actually going so almost
everything that I say here still applies
even though we're talking about yet
another programming paradigm yet another
deployment topology for software so very
quickly we're going to cycle through all
of these topics some of these are going
to be ten minutes long some of these are
going to be one minute long so don't try
to judge the length of the talk from the
number of bullet points I want to spend
as much time as possible on the demo
section that normally takes me about as
long as this whole talk is going to I've
shrunk it down we're basically going to
do hello world in rapid succession
across all three of the major public
cloud providers and their function
offerings and just to really give you a
taste of what's out there what's really
interesting is that I went to Cerberus
comp in Austin Texas a couple of weeks
ago and two days I learned that the
space has moved incredibly even in the
time since I first built this talk so
very hard to have a talk that's not out
of date an hour after you finish
composing it so if nothing else
hopefully you'll get some jumping-off
points to go do some of your own
investigation and learning okay so what
is this serverless thing that we're
talking about little secret there are
still servers down there you just don't
get to SSH into them in fact you're not
even allowed in most of the provider
platforms to know that where those
servers are or what they look like there
are some interesting exceptions to that
rule but this term kind of got its start
when we got really a
test with building mobile applications
and we wanted to spend most of our
effort focusing on that client
experience but we knew that we needed
some back-end stuff somewhere to house
some data or to help us handle user
account management authorization those
types of things and so this whole
category of you know I just need a
back-end but I don't want to write any
code kind of emerged and you know
started out as mobile backend as a
service and then the mobile part got
truncated off and then it just became
Baz and this is an interesting area but
not what I want to talk about right now
more recently we've started this focus
on what I'll call event triggered
stateless compute containers or the more
popular way of talking about it
functions as a service and this is where
all of the attentions really being paid
right now the back end of the service
category continues to evolve and gain
polish this is sort of the wild wild
west right now and so that's where I
want to focus so why why yet another
cloud platform category because we've
had infrastructure as a service and
platform as a service and containers as
a service and software all these
different things now we've got functions
as a service why do we need yet another
thing the first and most obvious
motivation is we've kind of been
dreaming of this state where I just want
to write code and in fact all I have to
do our write business logic code and
that's in fact all I have to do
frameworks and platforms have promised
this since I've been developing software
this is going to be the technology where
you just get to focus on the business
logic and all the boilerplate stuff that
you don't want to have to care about
actually goes away and this is the next
attempt at that does it deliver in some
ways yes in some ways not yet
and probably in some other ways this is
never actually going to happen it really
just depends on what you're trying to
build and how critical that thing is to
your business you probably don't yet
want to take that thing that if it
doesn't work your business goes away and
put it here just yet but this idea that
hey I know I have some data I know I
want to process it in some way and then
I know I want to hand it off to
something else and everything else you
know there's a ton of things that have
to happen to make that work all of that
goes away and you don't think about it
anymore that is one of the motivations
for for fats the second is I don't want
to run things anymore
so this microservices phenomenon this
wave that we've been writing now for a
few years has made you know the coding
of the individual nodes incredibly
simple although it's made the
composition of those nodes even more
complex but at the end of the day even
though I can write a little web service
that does some interesting things with
very little amount of work when I go
deploy that thing there's very much a
server out there running and now it may
not be a physical server that I'm
thinking about it may be a container
docker container some other container I
don't really care there's probably a
servlet container or a neti container
something out there that's running and
if that process dies guess what your
code doesn't work anymore right so
somebody has to be responsible for
whether it's automation or people or a
combination of the two making sure that
the care and feeding of that process is
taken care of even if there's no work to
do and this is the very important point
is that you know when your code is
sitting there and it doesn't have any
work to do are you still paying for it
in most cases yes you're still paying
for it
it's still burning up CPU cycles and so
you have to pay for those cycles you
have to make sure that it's healthy and
and ready for work to show up whenever
it is that costs you operational time
and effort in the service world the
platform takes care of discovering oh
there's work to do let me fire up your
code let it do its work and when it's
done I'm going to shut it down you only
pay when there's work to do there is no
longer any care and feeding of a runtime
again does that work yeah sort of most
of the time there are some use cases
where that's never going to be
appropriate but there are a lot of use
cases where it's incredibly attractive
and so this is our second motivation
third motivation is my gosh I just want
scale to just work like I don't want to
have to think about you know how do I
design my application to make sure that
it can scale up as it needs to and scale
down as it needs to and things don't
break and things don't get lost and
things don't freak out and again the
design of these platforms is focused on
making that possible so we said oh
there's work to do I'm just going to
spin up your code natural extension of
that there's a lot of work to do so
maybe I should spin up more instances of
your code so that it can handle the
increased volume you really don't have
to think about any of that you've
deployed your function and then the
platform is going to ensure based on hey
here's how much work there is to do
here's how many of these processes I
need to run right now and then when that
work goes away again shut everything
down
now you may be thinking well that's
really cool but and you're right so we
need to think through what those butts
are and how we're going to deal with
them but first I want to kind of think
about
we're cloud native architecture is today
based on the paradigm that's kind of
evolved before service came around so
I'm very interested in architecture
patterns and I've been working in that
space now for several months going back
and studying hey what was great about
the patterns movement and why did we
walk away from it and can we somehow get
some of that magic back and started
thinking about authoring patterns around
cloud native architecture and one
pattern that I've written in the last
few months is this thing that I call
externalize channels and the whole idea
of externalized channels is abstract
away that idea that hey here's my
business logic and that business logic
really is the business logic regardless
of the context in which it lives so
whether that's living in web
architecture a message driven
event-driven architecture in the cloud
out of the cloud HTTP something else
JSON Avro protocol buffers who cares
all of that stuff is interesting and has
its purpose but at the end of the day
the business logic is the business logic
and so can we somehow externalize all of
that other stuff and then wrap it around
our code in an interesting way so there
are in fact examples of these patterns
in the wild one of the more interesting
ones I think is the work that's being
done within the spring team around this
project called spring cloud stream and
spring cloud stream is just the natural
evolution of what has been done in the
spring space around enterprise
integration patterns for several years
but then taking the last remnants of hey
I'm really having to think in my code
about what the integration architecture
actually is and mashing that again down
into a framework or a platform so what
spring cloud stream will do is allow you
to focus on basically three different
types of components I have a component
that
can source data from outside the
architecture so that's the green box at
the bottom on the right so maybe I have
some IOT device whatever it doesn't
matter something that's outside the
architecture that's pumping data into it
and that source component can take that
and place it on a generic output Channel
what does that output channel represent
we don't know we don't care in our code
we then have stepping up on the right
the processor component a processor
component is just what you think it is
it's a filter between two pipes so we've
got an input channel where data is
coming in we've got an output channel
where data is going out and ostensibly
that processor is doing something in the
middle to make the data going out look
different than the data coming in and
then at the top we have this component
that is the inverse of the source that
we'll call a sink and it's job is to
take data from the architecture and send
it out of the architecture so in this
case maybe we're taking some data that
we've processed and we're shoving it
into DynamoDB or cassandra or something
else doesn't really matter stuff is
going out and it's stopping that's its
terminal point now we know that for all
of that stuff on the right to work
there's a bunch of magic that has to
happen on the left which is to take
those generic input and output channels
and actually translate them into
serialization of meThe serialization
deserialization of messages dropping
things on transport layer dealing with
fault tolerance as it takes place within
the transport layer all of that stuff is
abstracted away behind these generic
input and output channels into this
transport abstraction that the spring
team calls the binder and the binders
job is to make everything to the right
of it look the same regardless of what's
to the left of it and to the left of it
could be rabbitmq Kafka Google pub/sub
Amazon Kinesis doesn't really matter
okay I could talk about this for the
next three hours but obviously we don't
have that
so event wise in terms of you know kind
of a sequence diagram of this what you
see is that the code that we write again
that processor component there in the
middle and that blue highlighted spot
where I'm processing a message that's
the only part that I'm thinking about
all of these other events and marshaling
and unn marshaling and voguing of
components and routing of messages
that's all still happening and still has
to happen but I don't have to think
about it as a developer now if you think
about this and you realize well if I
build and deploy spring cloud stream
apps there's a lot of cool magic going
on but I still have to you know stand up
my messaging backbone or make sure that
somebody is responsible for that I have
to connect this transport binder to it
and I have to deploy all of these
components and make sure that they're
running and continuing to run and hey
we've got a lot of cool cloud platform
technology in the cloud foundry space
and others that we can use to help us
with that but ultimately we still have
to think about right would it be cool if
I could take this and shove it in a box
and say you know what I really only am
going to think about the green box and
when we transition into this functions
world that's very much what we see so
this is an abstraction around functions
as a service and again the green boxes
labeled F that's the only thing that I'm
dealing with everything else is part of
the underlying provider platform whether
it's the data sources and I'm going to
talk a lot about data sources here in
just a moment or the actual binding of
you know there's that word again the
data sources to the functions so you see
these little circles on the arrows
labeled T t is for trigger so the most
common
abstraction you see across all these
providers is that I have some data in
some repository whether it's a database
or it's a message queue or it's um if we
squint and look at an API gateway and
think of that as a source of data and it
kind of is it's a source of data for our
back-end API s then what we really want
to do is say hey Glu data source to code
that's going to process that data source
according to some event-driven rule
right so you know when a new object
shows up in an s3 I want to get a
message into my function to allow it to
grab that object and do something with
it or when a new message
shows up on a pub sub channel grab that
message allow me to process it this is
the trigger mechanism and there's a
funny attempt I think to be negative
about functions as a service by saying
oh well that's just triggers for the
cloud and yeah actually it kind of is
but I don't think that's actually a bad
thing it's actually kind of a good thing
so what do we have here you know we've
got some data store trigger new object
shows up in the data store comes into
the first function at the top it does
some processing it's going to drop a
message on to a queue which is going to
trigger the next function which is going
to store data in the database on the
bottom right then the bottom left we
have HTTP requests coming in to an API
gateway guess what triggers another
function to interact with the data
that's being processed based on the top
pipeline now if you start to think about
your application as discrete functions
that do different things to different
pieces of data at different points in
time you can start to decompose your
system into this network of functions
and data sources and some folks call
these functions micro services some
folks call a family of these functions
micro services I don't really care
which one is correct but it's a very
useful and interesting decomposition but
let's talk about the trade-offs obvious
trade-off number one is you are giving
some vendor a lot of control over your
architecture in order to be able to make
all of these things quote unquote just
work a lot of constraints have to be
placed on what type of code you're
allowed to write how you're able to
write that code how you're able to
deploy that code how you're able to
integrate that code with other code if
you don't place those constraints as a
vendor on a programmer they can't
effectively make all the promises that
they're trying to make so one of the
things that we have to be aware of as
folks using this technology is that for
every promise that they make for
everything that they say you don't have
to care about this anymore this goes
away you don't have to think about it
you need to ask okay well what am i
giving up then what piece of control am
i giving up now is it bad to give up
control sometimes sometimes not you have
to decide you have to think about how
critical is this to my operation
that if some other thing that's exerting
control on my architecture is not
working properly failing then what's
going to happen you know how much do I
really feel like I need to own and be
totally responsible for and that's going
to help you figure out well what are you
going to put in a platform like this
what do you not next thing to think
about is this term lock-in that I think
is kind of this doesn't really exist the
way we talk about it it exists but
everybody's locked into something if you
build all of your own software and all
of your own platforms and all of your
own hardware
there and you own everything except the
power coming from The Electric Company
guess what you're locked into all that
stuff that you built that doesn't look
like anybody else's stuff and it's going
to be very hard to move for your from
your Frankenstein thing that you've
created to something else right so so
you're always locked into something and
the most important lock in that we run
into in this space doesn't even have
anything to do with code and I'm going
to I'm going to hold on to that for just
a second because I want to talk about
some of these other things but even if
somebody tells you hey I can build an
abstraction layer for you that's going
to put you above the level of all these
providers and you can just move your
code from place to place to place to
place that's cool but it still doesn't
save you
so hold on to that thought your code
must be stateless you know the I am
we've been talking about cloud native
code and stateless applications twelve
factor all that good stuff and it's
great it's all very good but there are
in fact interesting reasons why you
might want to build a stateful
application that maintains in process in
memory local storage kind of state for
various types of applications guess what
you can't run those here because that
whole cool thing of hey my code only
runs when it has work to do means that
your code only runs when it has work to
do and so any state that it creates
during the process of doing that work if
you don't shove it in a database it's
gone right there is no option of doing
it wrong in terms of oh that application
stateful so it's not going to scale
horizontally you don't even allowed to
make that I mean you can make the
mistake just your codes never actually
going to work so if you need to build a
stateful service of some kind it's never
going to go here at least as long as the
paradigm is as pure as it is today
maturity you want to adopt this stuff
today you're probably going to be
looking at some
rough edges you're going to be looking
at some wrinkles that you don't like
you're going to be struggling with
implementing processes that you think
are fairly fine-tuned in your current
world in this world because hey this
world's only about three three and a
half years old and if you think about
the state of most of the technologies
that you've ever used when they were
toddlers you know it didn't quite meet
all of your needs that doesn't mean it's
bad technology that just means it's baby
technology and that's kind of where we
are right now you know the the service
fast world is really just learning how
to walk and getting good at it but we
all know what happens after young
children get good at learning how to
walk what do they do they start running
and then it's hard to chase them around
so this is a very good time to be
exploring and getting into this space
the developer UX is improving rapidly
but it still is not great it's not my
favorite place to write code not my
favorite place to get into a good you
know test-driven iterative life cycle on
the laptop where I'm kind of banging
away at code and just rapidly getting
feedback it's not quite there for me yet
now can I in a very short period of time
deploy some interesting stuff yes but I
don't feel like I can get into the same
flow as a developer as I do in my older
programming environments where
everything is kind of nicely and tightly
integrated into my tool chain and I'm
not really thinking anymore but the
laptop is just kind of an extension of
my brain and I'm just typing away I
can't really get there just yet is that
going to be fixed yeah it's going to be
fixed I just don't know when but they're
working on it and the providers they're
even represented here on the on the expo
floor I saw them all of them at
serverless comps and they're doing
really interesting things to improve
that
so getting better so very quickly what's
out there clearly the three big
providers that you know of IBM has an
offering as well on bluemix couple
smaller providers auth0 has an offering
called web tasks and then there's a
company called standard Lib that has an
offering as well open source things that
are out there there's an interesting
framework called the service framework
that started out as a way to improve
kind of almost give a rails like
experience to Amazon lambda it has since
extended to support Asia as well as open
wisk
iron do has an interesting open source
offering that sits on top of docker
containers called iron functions the IBM
open wisk offering is actually an apache
project so you can pull that whole set
of infrastructure down and run it
locally Faslane is the thing that was
announced at serverless comp it's really
interesting they are attempting to build
a true standard abstraction on top of
the functions as a service world so
basically the idea is one programming
model to rule them all and then some
shims that will allow you to deploy and
manage that code on a back-end of choice
normally I'm pretty skeptical of these
types of things but watching their
presentation and interacting with that
team a bit afterwards they're doing very
interesting work and they're thinking
about this the right way in my mind so I
think that's something that you should
look at and then clearly me coming from
pivotal in the spring space we have some
interesting stuff coming in the form of
spring cloud function that is very much
in what I would call even a pre alpha
state right now lots of interesting work
being done around the programming model
so if you ever thought you know I'd love
to just write and be able to deploy a
Java util function that's what the
spring cloud function programming model
actually looks like and has kind of the
ability to give you here's where I can
write code and actually take no
dependencies on anything whatsoever
which is I love
of because I hate the fact that every
time I work on a Java project I have
like a hundred and forty seven
transitive dependencies and that stuff
actually matters in case you were
wondering if you ever think about it
when you deploy a Java app that most of
the code you're deploying is not your
code and and sometimes that stuff
doesn't work that that frightens me
especially when I think about the amount
of software that I've written that looks
like that and that people are still
using but spring cloud functions trying
to make that go away for you in some
sense last thing before I do the the
rapid-fire demos it's all about data the
compute part of this while interesting
is ultimately the easiest part of this
you know being able to say hey I can
write a function I can deploy it I can
start it up when there's work to do
there's some interesting problems to
solve there but even if you do that you
do that extremely well and you don't
have any highly scalable performant data
sources to glue that to doesn't really
matter so when we talk about lock-in
using a lambda or a GCF or an azure
functions is really only interesting
insofar as you start dumping your data
into those providers backends now I love
all these cloud providers they're all
doing amazing things but if you if you
if you look at what Amazon you know
proudly highlighted was this idea that
hey we'll back a truck up to your data
center and we'll run a cable into your
data center and copy all of your data
onto the truck and then we'll drive the
truck back to our data center and
reverse the process and people didn't
laugh people said wow that's amazing
that's great where can I get my truck
that means that we're living a world
today where it's still hard
to move data in large volumes from place
to place and if you engage a provider
with one of those services they probably
don't have the service where you can
back a truck up to their data center and
get the data back on the truck and bring
it back home so the more data you dump
outside of your data center the more
you're locked into wherever that data
goes because that data has a lot of
gravity associated with it so you know
the more you embrace this of hey we've
got all these functions and we're moving
it close to the data the side effect of
that as you're moving the data further
away from you and I'm not saying that
that's evil I'm saying it's something to
think about all right so enough talk
I've got 19 minutes to to crank through
some fun demo stuff and we're going to
give it a try so let me just kill this
and we'll kill this as well and do some
fun mirroring stuff okay fun make that
big that works okay so this is not what
you would see if you were trying lamda
for the first time I happen to have some
lambda functions out here that I did not
want to delete because they're part of
my toying around with Alexa Oh
interesting thing if you want to write
Alexa skills the most straightforward
way to do that is to write lambda
functions so there's some fun
interaction there between those two
ecosystems so on Amazon what I want to
do is I'm just going to create a very
basic lambda function and I'm going to
hang out in the node world and maybe
this one okay I want this microservices
HTTP endpoint javascript is the the
lingua franca of this world like every
platform supports a different subset of
languages but JavaScript shows up
everywhere whether that's a good thing
or not you make that determination so
first thing that asks
to do is how are we going to trigger
this function and we can actually look
at the list of available triggers that
Amazon has and you notice they're all
Amazon services they're all interesting
event-driven data sources like if you
were building an Alexis skill you would
pick this Alexis guild kit to hook it up
to the alexa front-end and the voice
processing stuff but we're going to
stick with api gateway just do a
straightforward little restful service
i'm going to make this wide open you
obviously shouldn't do that but this is
a demo you know do as i say don't do as
i do now we're going to configure this
function so what this is is a very
straightforward little crud service on
top of DynamoDB which is a great little
demo we're going to stick with that i'm
going to call this my lambda micro
service and going to take most of the
defaults and everything I need a new
role and we're going to use the simple
micro service permissions which is
basically going to give us just enough
IM to talk to dynamo DB call this my
lambda micro service role and that
should actually be enough to get us
going so we'll go ahead and create that
function and let it fly so what this is
going to do is deploy that code as a
lambda it's going to go to the API
gateway service and create a basic pass
through proxy at the API gateway layer
and it's going to create that iam role
that's going to allow me to talk to my
my dynamodb table that i already have
set up so this should be happy and ready
to go at this point I copy this little
address and we're going to drop this in
here and just to make sure that I don't
mess up when they look at my script
table name my what did I call a table
and actually it doesn't need to be :
equals it used to be double equals and
lookie there
okay so the last time I did this talk
was in Reston Virginia and so that's
what we ran into so I'm going to do
another
record into this database so we'll just
grab this little data format here and
we'll drop that on there and we'll say
hello dev ox and we'll give that a new
key and go back and hit the table again
and there's our dev ox record that we
just put in and we can also obviously
delete that I might want to put that I
want to do a delete operation leat and
table name and key so we'll just clean
out our
original one here that was from the last
talk deleted so I should be able to
query again and see that just our record
is there so that's really how simple and
straightforward it is to get started
with lamda what I think the providers
have done exceptionally well is that
when you go to create a function you've
got a catalog of all this boilerplate
stuff out there of use case specific
options so that you can get started from
not a completely blank slate but take
some code that does something and make
it do what you want it to do so from a
learning perspective it's pretty easy to
get in here and start messing around
with this and seeing you know what types
of interesting interactions can I have
between other services data services
event-driven mechanisms and the code
that I write okay so that's a quick look
at lambda I want to move over and take a
look at in a slightly different order
than I normally do this Google Cloud
functions now before I deploy my Google
Cloud function I need to go take another
step that it doesn't actually do for me
which is I need to create a bucket to
stage my code in so we'll call this my
GCF devoxx bucket and we'll go ahead and
create that so now I have a place to
stage my code before it gets deployed
and then we'll go to cloud functions and
create so we'll call this hello world
we'll keep it there that's fine I'm
going to use my hello world pub subtopic
and then I've got some code over here
that I'm going to deploy
and we'll just put this here and we'll
say my dev ox function great stage
bucket we'll call it G C F dev ox and
function to execute is called hello
world create and so it's going to spin
that up and for this one we're actually
just going to instead of having an HTTP
response we're going to send an HTTP
request or actually we're not going to
do that we're going to send in a pub sub
message request it's going to write a
response to the logs and then we're
going to be able to look at the logs so
GCP still takes a little time to deploy
functions for some reasons so we will
fill the blank space with noise until
the spinning circle goes away there we
go so now I'm going to hop over to test
my function and I need an event trigger
which I happen to have a handy event
trigger down here in my script
so we'll just grab that and we will drop
it into here and we'll say hello London
and test the function
and we're going to watch the little dots
dancing at the bottom of the screen
until the until the log entry is that
it's fetching show up and sure enough
there is the log message that we just
generated my DevOps function hello
London
these things don't really do much true
because we're going fast but also they
shouldn't do very much part of how we're
going to start building applications is
instead of having apps that do lots of
things we're going to have lots of apps
that do almost nothing tiny little
things and then compose them and
recompose them so we're going to get a
little bit more complicated when I move
over to Azure because I want to
demonstrate something to you that I
think is really interesting that
Microsoft has done which is they have an
abstraction that they call binding which
looks a little bit like the binding
abstraction that I talked about in
spring cloud stream so we're going to do
a silly little example to shut this down
where we're going to have one function
that's going to ingest an array of
integers and store it in a database
table and then we're going to have
another function that's going to pick up
the integers from the database table and
sort them and give them back to us would
we ever write this in the real world
probably not but it's an interesting
example of how this binding stuff works
so I'm going to start out and call this
my dev ox functions and everything looks
good so we'll go ahead and create this
function app it's interesting it thought
that name wasn't available for a split
second but then it was so it's now
deploying what's called a function app
container for us which will eventually
show up here in our list thankfully the
Wi-Fi is behaving because the cloud also
has some latency built into it we had
two sources of latency we would have
been in big trouble
so we'll just keep refreshing and
refreshing and refreshing because
there's really nothing and interesting
to look at until this little app shows
up
come on you can do it while we wait
going to find the right spot my editor
here because we're literally just going
to copy and paste code there we go it
says it's succeeded my devoxx functions
great okay so now we've got our little
function app container and we want to
add some functions to it so I am going
to go with again a webhook javascript
thing create a function and then I'm
going to grab this first chunk of code
and what this first chunk of code is
going to do it's going to get triggered
based on a web hook it grabs two things
out of the incoming message a key and
then an array of values it then
initializes this thing called context
bindings output table to an empty
JavaScript array now what we're going to
do with this array is really interesting
we're going to push on to it an object
with a partition key a row key and a
values and then we're going to say we're
done now we said that array any you need
objects that we have in memory are
stateless well what's happening under
the hood is we're going to bind this
array to an actual database so when we
push rows into the array we're actually
pushing rows into the database as well
so I'm going to save this out and I'm
going to grab this other little JSON
blob here called functions JSON and I'm
going to hop over here and replace it so
these are our bindings and what our
bindings tell us is what are the inputs
and the outputs now we've got our HTTP
stuff here input generic JSON off of
request output to response but then we
also have a table name called values to
store which is in Azure web job storage
and we're binding it to the name output
table so when we save this we should
then be able to go over and test
and we're going to take this object my
devoxx values and then this array and
we're going to run based on that and
that function completed so that state
has disappeared except for the fact that
we shoved it into that Azure web jobs
table and I'm going to see if I can make
this work I forgot to initialize it but
we may get lucky so this is as your
storage Explorer and up re-enter your
credentials fun load let's see if I can
do this really fast
ah
love it
Oh two-factor authentication for the
wind send push receive push approve
there we go now I should be able to yes
look at there my DevOps function loading
tables values to store and lo and behold
there is my 4227 twelve twenty seventeen
eighteen hundred great so last thing
that we're going to do is we're going to
create another function internet don't
fail me now and we're going to go with
javascript and I want generic web book
JavaScript again we'll go with just two
here that's fine now I want to get this
last bit of JavaScript code that is
terrible
you should never write code that looks
like this but it works
so all this blob right here is turning
that string based array into an actual
array of numbers so just ignore that
what's really interesting here is this
bottom part that's going to sort that
data now where does the data come from
it's coming from data key well data dot
key where does that initial where does
that value actually come from well again
we have to look at the bindings so let
me grab a little bindings blob right
here and we will hop over to view files
and function Jason again paste that in
so values to store is the table name
again as your wet job storage output
table blah blah blah look at the bottom
row key is curly brackets key what
that's going to do is find that locally
bound value hand it over to the data and
say load the row that has this key and
then put it back into the variable
we're working with and so when that
magic happens what we end up with is
that values which is in now context top
bindings that output table top values is
our array so if that's actually true
what we should be able to do then is
paste in set the right one no let me
just do this yeah I've got one so we'll
paste in a message that's just the key
and run it and sure enough there are
sorted values 12 27 42 1820 17 even
though they were stored in the database
in a jumbled up order so what's
interesting about that I'm writing
JavaScript code and I'm not talking to
Azure api's at all I'm just writing to
native JavaScript objects and then I'm
binding those objects to different
back-end data sources you know I use the
table in this instance could I have used
a message queue instead sure totally
will work and it makes my code somewhat
generic and business logic focused
within the integration architecture is
kind of bound in late based on how I
glue things together with the triggers
or in this case as your calls these
things bindings okay so I've got one
minute left
and I'm actually finished which is
bizarre to me so maybe one question or
have I completely dazzled you there's a
question over in the corner I can barely
see this is the light
yeah so if in case you didn't hear the
question you know what's the TDD
approach to this this looks like hey I'm
doing a lot of copy and paste
development this is looking very like
how we used to do things before we
learned how to do things properly and
you're right part of that is just the
nature of the fact that this is kind of
a demo so I'm kind of showing you things
the quick and dirty way but the other
thing to think about here is that there
are actually CLI integrations for these
things there are ways to integrate your
git repositories directly with the
platform and deploy off of those what is
somewhat lacking is how you start to do
integration testing outside of the
environment there are some emulators
that allow you to do things like run a
copy of azure functions on your laptop
or run a copy of Google Cloud functions
on your laptop and then rapidly iterate
that way and then you know insofar as
you can keep your code generic like this
your standard TDD tools should actually
work but there's a lot of should and a
lot of if and a lot of may be in there
that's where I said the dev ux is not
quite there yet but something to watch
so the short answer is you can figure
out some things that mostly sort of work
but it's not necessarily going to be
smooth and you're happy way of working
for a little while okay so that's all my
time thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>