<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Testing Java Microservice by Alex Soto, Andy Gumbrecht | Coder Coacher - Coaching Coders</title><meta content="Testing Java Microservice by Alex Soto, Andy Gumbrecht - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Testing Java Microservice by Alex Soto, Andy Gumbrecht</b></h2><h5 class="post__date">2017-11-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/mH9TEXhmmwc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning thank you very much for
coming to this session about testing
that's a long talk about to go into you
know take some breaks and so and so on
and we're going to show you some tricks
let's say to develop tests that are easy
to write and more important asset that
are easy to read and we're going to see
from simple one like unit test to
deployment tests and some of the things
are really focused on micro-services
architecture but I would say that 80% of
this light you can reuse it or you can
reuse them even if you are using a mono
leaf approach in your development my
name is Alex Soto
I work in Red Hat my decorator of lot of
the jars calm and also my tutor is Alex
so Toby if you have any question any
suggestion and whatever just ping me on
Twitter and I will answer you as soon as
possible but I don't put here my email
because yeah you can send me an email as
well but then it will you know get a
bigger bigger bigger of my inbox and I
will take like two weeks to answer your
question so it's Twitter it's really
fast
holy moly people this is a lot of
pressure good morning everyone welcome
to devoxx
welcome to our talk on anti-gun break
from commit on the apache tommy project
also on the PMC I'm also a dad but if I
posted my kids on here that just kill me
so you know I'm going to see my kids on
here and the same goes for me anytime on
Twitter just ping me on Twitter were
both very public guys and they're
heavily involved in the open-source alex
is my arquillian hero he's just knows
everything about our Killian if ever I
need anything he's always there from for
me and I tried to be there for him and
we can both be here fees
why are we talking together shameless
plug for the book that we've just
written it's in pre-release you can
order it now a lot of the talk today is
going to be about things that we've
written in this book it's taken how long
to write this book yeah
no it's like I always say that this book
is like so rather familiar it like it's
forever and I kind of got involved with
like hey Andy could you just like write
one chapter and review some stuff and I
think four chapters layering the whole
book we've worked together heavily on
this so if you're interested in this
subject late a lot of the stuff we're
gonna be talking about is in this book
obviously we want to know about micro
services this is for like beginner to
intermediate so we're going to be
talking about what we think of micro
services and how we think you should be
testing the micro services people will
have differing opinions but we need to
know from the get-go what micro services
or we feel a micro services obviously
it's gonna be something small enough to
run in a raspberry pie no one shaking
their head that's rubbish it doesn't
have to run the Raspberry Pi a micro
service is something small but it it's
underlying infrastructure been quite
large so we need to talk about the
anatomy of a micro service what do we
feel is the anatomy Hydra service and I
love this slide this is basically we're
still in kindergarten
was still in preschool everyone's still
learning what a micro service is there's
no one out there that says this is a
micro service and you will not do
anything outside of this box we're still
playing outside of the box there is an
initiative going on for Java EE or eg
for Jay and there's a micro profile
project it's kind of a landing site here
a micro profile IO for many vendors that
are involved in defining what he
believes a micro surface is how it
should be configured how we should speak
to the thing and that has been a
transition to an incubation project at
the Eclipse Foundation so if you're
interested in understanding how micro
services will play a role in the
community then pop along to their read
all the information that's available
there so let's start to look at what we
think is a micro service initially
you're gonna have some kind of resource
what I mean by resource this is the
endpoint this is access to your to your
micro service and this for me and many
other people is the micro so it's the
exposed surface area it might just be
one endpoint one restful endpoint with
one that takes one parameter nice and
small surface area so this that's the
micro of a micro service things that
could be underneath it so we have
controllers which are optional we'll get
onto that in a second
we're going to have the domain which
contains that business logic and this is
just very very standard program design
you're going to have some kind of
repository by repositories you mean
persistence whether that's a simple file
or RM system is failure relevant we're
just going to have something that talks
to a some kind of persistence layer and
then optionally with this controller we
have gateways and a gateway is talking
to another service so that might
actually be another micro service it
could be something like s ap it could be
any other kind of service you can think
of and there's basically films the
fundamentals of a micro service you can
add bells and whistles to this and
people out and say different things
about this but you're going to find all
of these things in a basic micro service
and as we know if we're using our RM
with a big database underneath that
could be huge it could be gigabytes so
you know get away from the feeling that
it needs to run on a Raspberry Pi it's
nice if you have a service that runs on
a Raspberry Pi cuz you can demo it quite
easily but your micro service might be
gigabytes and gigabytes of data and code
the surface area is what you need to
think about when we're talking about
micro service and we're exposing this
micro surface area of our application
and we need to be able to test that
thoroughly testing
so he started with just manual tests
will their quick Alex we progressed
basically through various kind of
testing mechanism so when we started
with manual tests we were talking about
people just writing their own code
there was no framework in place people
start to understand that people
accessing our code needed to be sure
that when they access the code was going
to do what it needed to do and
eventually we had some kind of unit
testing framework that was developed and
people started using testing frameworks
and then within these frameworks they
started saying okay we need some kind of
design pattern so we have TDD and
behavior driven development so
test-driven development behavior
different development and we started to
realize testing was actually integral
part of developing an application so you
didn't just write an application and
then testing you started with testing
and number of your application which is
a very good way of ensuring the
application that you build functions in
the way you're expecting your test says
it should work and then we need to be
testing it production then sorry
virtualization is the next layer which
I'm talking about later but this is now
we have a micro surface it's separate
and we have another micro surface that's
separate and we need to interact with
these different services but when I'm
testing service a do I really need to
have service be running if service B is
a very complex service like sa P or a
simple JDBC call to a database do I need
the database or do I need s ap running
obviously if I'm testing it's not really
practical to go to your employer and say
can I have a cheap copy of s ap to test
against I don't think you're going to
get it down but what you can do is run
tests against the s ap record that
information and play that back and
that's that's service virtualization and
we'll be talking about that in depth
later and then testing and production so
now we have these services we don't just
have this big one monolithic application
that we deploy somewhere we have tens of
applications that we need to deploy and
they all need to work together and so
when we deploy those applications we
need to make sure that they deploy
properly and then they can talk to each
other properly and so we have to test
the deployment of our applications now
so what does this mean in terms of
testing well we have different types of
tests that we now need to employ within
our applications to make sure they're
going to be working when we're still
gonna have unit tests so we're not
getting rid of stuff everything you know
about testing today is still current and
valid in the way you test replication so
no one's going to say you have to throw
something away it's going to be expanded
upon so everything you know and love
today about testing hope we love testing
is going to be consistent throughout
your application we have the next layer
of component testing and that's things
like running an R Killian tests where we
fire up our application server and we
deploy our application in its entirety
to that application server and test the
lifecycle of that application and make
sure that's working we then have
integration testing which is where we
would fire up our application and make
sure that it can collaborate with its
collaborators so if I have a database I
need to talk to you then I would have a
test that simulates the database either
in memory databases or a file based
database locally for the test or it
could be I need to talk to s AP and I
would have stubs in place to talk to s
ap or pretend to talk to s ap the next
step from that would be contract testing
this is where actually you need
application aid to talk to I'm showing
some be and application be shall be
responding in a certain pattern a
certain way and we can record that
information so when service a is talking
to the service be again a partly
virtualization contracts there's
something we put in between and say that
this is expected and this is the
response and so you can actually design
the way your applications talk to each
other through testing and again
deployment we need to test for
deployment and we need to test in our
production environment the goal
obviously this picture is propping it up
we're propping up our tests to pop into
our application we all have the same
goal all the tests have the same goal
and that is to ensure the quality of
your application
and also to allow the the safe future
development of your application so if
you're constantly testing all aspects of
application you make some kind of change
if you're testing properly you can
ensure that that change doesn't break
something and you have some kind of
regression going on the micro profile is
this initiative for Eve Enders it's not
necessarily just EE we are incorporating
spring into the way we do things spring
Bou and we're going to be showing you
tests in various environments so it's a
client this collaboration needs to work
across vendors and we can't just say you
have an EE test and it and it can't in
any way talked to a spring boot test
because they're in competition with each
other apparently and vice versa if you
have a spring application that talks to
a EE micro-service then that needs to
work in every case and so with bolts
lots of examples using various
technologies just to show you that there
is no bias in any direction when we're
testing we're testing everything when
you see this we're going to give you
opportunities throughout the talk to ask
questions so we'd love to get some
feedback on the things we're talking
about you'll see this slide several
times throughout the talk every time you
see this slide then obviously there are
welcome questions and we'll respond to
them as best we can so any questions I
have one
absolutely so we're talking about
contract testing the question is about
contract testing recording and replaying
of responses an invention of scenarios
can we do negative testing can we have
scenarios that break or try and break
our application server yes
that would be obviously negative testing
for contract tests where you would
specifically tailor a response designed
to try and break your application server
and you see how it responds so you're
not only doing positive testing where
you're testing what you're expecting to
happen you should also be testing things
that you don't expect that anymore
before we move on 250 people and only
one question I'm sorry I'm gonna give
you back to Alex Alex easily to talk
about unit testing like I say it's
beginner to intermediate this talk and
there are various people out there that
need to understand what unit testing is
in detail and how we best Jude unit
testing will be progressing throughout
the up to three hours so we might not
keep you here for a whole three F for us
lock the doors
you lock doors right now you could
obviously get up and go whenever you
feel like we will have what we're trying
to have two breaks in the talk after
about an hour we'll have the first break
for 15 to 20 minutes and then we'll have
another break later so Alex okay yeah
now yeah we're going to talk initially
as you need tests because usually this
is the first test that you should write
but the truth is that from the point of
view of microservices there is nothing
new I mean that if your micro service or
your monolith application is design it
correctly then there is nothing new it's
exactly didn't need to do anything
different from micro services or from
manual monolith and basically as most of
you probably know the unique testing is
a testing technique where the code of
the application under test should be the
smallest possible
a snippet to produce the required
behavior right in
if you come from seed this usually this
smallest snippet was a method and
usually in the oriented programming it's
considered that the smallest part it's a
class but there is one guy called J
filled with this young guy from the TDD
ecosystem which says or they are split
unit tests into two categories the first
one is solitary unit test which as the
name suggests is the solitary unit test
focused on testing the unit or work in
an isolated or controlled way
so just you can think about just you
take one class you mock all the
dependences and then you run a test for
this class but also there is another one
which is called sociable unit test which
in contrast of solitary in this case the
class under test also uses its
dependencies and collaborators the real
dependencies and collaborators then this
doesn't mean that you're you are
transforming your unit test to a
component test because one of the things
that identifies the unit test are the
speed so if you have one class that do
something and has one dependency to
another class and discuss it's also
really fast because they do some fast
calculations then you can ask them
together it's fine
this is just a shave all unit test so
normally we work independently from
visually but every now and then we give
each other a hug and so to me to scale
it even if you are using sociable or
solitary unit test at the very end
probably you have some dependencies
which are let's say
hard to write a test together with the
main class or they are really slow so
you need a way to simulate these
collaborators because if not you will
receive a note pointer exception right
and how do this is just using test test
doubles and testable just replaces
production object to one for testing
purposes and in the sense there is a lot
of different test doubles
we have dummies diamonds are just
classes that are passed as argument to a
method but you don't do anything it's
just so your task and compile we've got
fakes which are some kind of
implementation with shortcuts and I
think that the most but they used and
popular one are those embedded in memory
databases right like h2 or it is cql DB
which basically they are fakes because
they are not ready for production
although some people use it in
production but a minute
in general they are used for testing
then we have stops stubs are like like
classes that they store the state for a
future state verification so it's like
they have some kind of memory of what's
happening behind the curtains then we
have marks marks are pretty similar to
stops but the marks do runtime behavior
verification the store the state is
never store so you can say I've called
this method but you cannot say something
like give me all the although all the
values that I that has been used calling
this method and finally we have a spice
which is like a mix between stubs and
mocks or it's like a mocks with some
kind of memory which allows you which
record all the information that happened
on that object but I think that most of
you will agree that the most used test
of all its mocks and fakes
so this is a unit test and this I know
that it was quite a strange first
because I'm not using the criminal case
notation notice that I'm using this
underscores and start with should I do I
delete this because it's really easy for
any reader to read what is the purpose
of this test you should put should find
composers my name and also if you put
this underscores it allows you if you if
this test
throws an exception really easy to check
in a long lock where where is the test
that proves this exception and also see
that I'm using the given when blocks
although this is not a bdd test it could
be but it's it's not I like to put these
blocks it clarifies a lot what is the
purpose of the test and any reader knows
exactly what is the purpose of the test
the readable name using the BDD style
I'm finally the most important thing on
a test it it's an assertion because a
test I mean that almost all test has
assertions and you can do ham pressed or
or even use ham press + J unit but but I
guess that the best way is using a
Sergei that we were going to see now an
example which allows you to put a really
consist we what is the assertion that or
what is the verification part of the of
a test I don't know if you have any
question regarding unit testing or
assert J we're going to see a demo so no
worries ok as I said a so J is like the
best of hand caressed and fixes the
wrong things that
our own ham crest basically srj uses a
dsl approach and this means that it
detects the types of the objects that
you want to serve and it offers you the
suggestions of these methods and this is
really different from hamcrest
in hammers you need to remember that you
have contains I'm Chris matter you have
East Ham Chris matter and so on so far
but in the in butter sergej just allows
you to give you all the methods just for
these kind of types and this means that
this idea friendly so you just do
control of space and you will get all
the all the all the methods and just see
here the first thing that you need to do
for another object as is put this a
starting method which it says don't use
the answer dot J you need math starting
method but uses the sub J one notice
that the assertions are really readable
you can say something like a certain
Moser the name is equal to work on a
mother's mother it's much better than
after that muscle get name is what
removes most of for example but you also
have all problems for example if you
don't want to stick on the equals method
notice here that Moser is an object is
not on a string and I want to just
assert that that the name is what was
Moser I don't want to use the equals
implementation of the composer class so
you can do something like returns
organized Moser composers like the name
of this is a Java 8 lambda so it's much
better than what's happened with hand
Chris where you need to I mean that by
default it relies on the equals
implementation which sometimes is okay
Ryan on equals but sometimes you're
obvious contains an equals that are
great for production but not for testing
this is another example with a list not
it notice here that we have assert that
operas operas is a list of opera so you
can say assert our eyes and then it just
have this has size to which it's just a
method that just are available if it's a
list if it's in a string has size it's
not there then create then you have this
extracting which says ok instead of
having the list of operas I want to have
a list of the names of the operas so
basically we're having this method it
just iterate through all the of the
operas list and get the name and return
a list of strings and the other thing is
that then you can just use contains
exactly in any order and put here the
strings and this method contains exact
in any order in this case requires the
strings you cannot pass he ran in terror
because the list is a list of strings
notice now that well in here you can see
that you I have like two assertions the
first size two and that contains exactly
in any order the two operas what's
happened if has size fails because I
have three instead of two the best will
fail and I will go to a data set oh yes
sorry now it's like three opera so I'm
going to put three you put a three and
you run again your test but then you
miss that that contains exactly in the
order has two operas not three so it
fails because it says it means one opera
so you need to go there fix this method
adding the the other opera and then run
again the test if there are two
assertions okay if there are five
assertions then you start you know like
doing I've run the test fails I fix one
assertion run it as fails I fix it again
the session so asaji has something
called as a soft assertions and
basically what it what it does is just
like this you have sort assertions
softly and this is a Java 8 lambda and
then inside here you just put all the
surgeons in a block and what's happening
now is that if one assertion fails
doesn't matter you just continue with
the other assertion and so on so far and
will execute the four assertions after
that as IJ will check if some if any of
these assertion has failed and if you
had felt it will report as a failure and
said look this assertion and this
assertion has failed so you can now go
there fix them at once and then run
again so you avoid this round trip of
running fixing running fixing write it
fix it which is quite great I'm
following we have assertions the within
this of using ng you need usually what
you're using when you want to test but
your code throws an exception is using
these tests and notation and then it has
an attribute called expected and you put
there the exception that it's expect to
be thrown by the method the problem with
this approach is that power your test
has several lines and you cannot say
this is the line but throughout at
thrown the exact exception so maybe the
exception that you were expecting was
thrown by some code that you didn't
expect to throw that exception so what
half a sergej is a better way to do it
which is like doing using this pitch
catch throw a ball a static method for
it again it has a lambda and you put
there the method that you think that the
or the or where you expect that the
exception should be thrown and then you
simply just do assert that thrown when
the strong is the the the fable object
is instance of illegal argument
exception and with fill message and you
put there the full message so it's quite
readable even better than just putting
expected class and even more readable
that just put try catch on your on your
test method there I mean that awesome
people well we do
is just putting a try cut in the in the
test itself and then put it a fail if
it's not if the exception is not thrown
it just I mean it's a it's a workaround
to do it but not so much readable I
think it's much better this one and also
it allows you to follow this given when
then blocks any question about a sub J
yeah yeah yeah then there is a um yeah
in this case if you have a duplicate if
your I mean the dividual is then you
have a duplicate it will try to find
three objects not too can you know it
will fail can you repeat the question
Allen is about what happen if your
release has a duplicate objects in there
and then you assert then if you assert
in real that there there is three
objects it will fail you will need to
pass through a set and I don't know it I
didn't I don't know we can I will check
it in the demo you have a method which
says contains and avoid the duplication
I mean it's it's a taster so we're not
going to spend the whole time showing
every method a sergej it's just an
example of how to deal with collections
and there are specific methods for
testing for multiple strings and for
random strings so you can have contains
at least these strings so it doesn't
have to be it's a specific specific as
these as this test example was
demonstrating it could be quite fuzzy in
what you're querying for it's just it's
just a taster sergej has hundreds of
methods for all sorts of things like
that
does that answer your question yeah oh
if not we can discuss later or
Twitter's so we said that we need to
mark our collaborators and I think that
yeah I mean that the MOU keepers in fact
it's that it didn't depend library used
for for testing this is Anna studies
shown in Indy hub so I think that yeah
we can say that for mocking in Java that
the fault or Linda the facto tool is
mockito I'm basically it's okay to
defend itself like a pest team tasty
mocking framework for unit test with a
clean and simple API and this is a an
example of how how you can mock your
dependency you can use the first thing
that you need to do is say that this
test needs to use mock one one way of
doing this is just using the Mojito jr j
unit runner and then just just defines
with annotation mark and you put there
the object and then this object will be
mark also you can if you want you can
just use before and then you do mockito
annotations out in mock DS and then it's
just the same but without using the
runner and from two dot i don't remember
exactly in which one body let's say in
mojito - you have a J unit rule where
you can say mojito I mean that instead
of using the mockito annotations in
motion or the runner you can use this
rule which basically says toggle same
find all the fields annotated with mark
and do the at mocking thing I'm finally
if you don't want to use anything and
you want to explicitly say this is a
mark you can just use this static method
which is monkeytoes mark and you pass
the class and then they will return the
mark this instance of I mean that at the
very end is a Java Java proxy so it
returns approximate is the the Mojito
mark within a method so obviously the
first one is going to be producing the
email service for the class that's being
tested you
need to use it in several tests and if
you're just going to be using an
isolated mock for one one test method
then you can just use the mockito mock
to just literally create a proxy of that
object so it's a it's a an intelligent
proxy of the object that you're mocking
that you need to use in your in your
test class so you're not testing the
mock itself you're testing something
that needs to use that mock to work and
then how to use the marks well you just
need to just say when this email email
service must be a mark said when the
mail received body messes with subject
my subject when someone calls this
method with this string then return this
is my message this but this is a
recording expectation also you can do
something like that this is a concrete
parameter right it's it must be dis
string but if you want you can just use
an ending a string parameter which says
just call this method with any string
and then return this is my message so it
then it depends if you want if you
expect a concrete value or not then you
use this much force any string there is
an integral and the photo and this any
object any class I mean that this a lot
of methods with mattress class or if you
expect the concrete then just put the
concrete object there and another thing
that you can do is verify in the marks
and Barry fender marks means that you
want to verify that some method has been
called usually this is used when you
have some kind of void methods in this
case I have a mile service which is mark
and the invoice service is the class
under test which each collaborator is a
mile service so I put I pass in the
constructor the ml service which in this
case is a mock instance and then I do my
service dot cell and this cell method
just sends the email right but it
returns void so how you can verify
that send message is called and it just
called want so what you do is something
like put the walk and then verify that
the mail not it just called once and the
send message the method sends any string
any string that the first parameter of
send message is the subject and the
second one is the body so you're what
you're saying here is that the invoice
that send method internally has called
send message method of the mocked in
this case of the email service instance
also sometimes I mean if you see here
I'm saying send measures any string in a
stream so you said if send message is
called with any string then it's fine
the born is that sometimes this invoice
service might do some business code
they're manipulating anything so you
want to be or you want to verify that
this manipulations are correct and still
the same problem the system the mom used
by collaborator and the send method
returns void so what you need to do is
something like this you need to use one
thing called argument argument actors
which captures the arguments used in the
method so in this case what I'm saying
is like verify that the mail it's I mean
that the in the mail knock object which
is a mail service called once send
message and check that the first
argument which is the subject estas with
in boys and it doesn't matter the body
so if you call in boys that send method
and the email service does not an email
service God send measures we subject our
starting within boys and anybody is not
called then this test will fail so it's
the way you have to verify that then boy
service is behaving I
expect and this is a bonus track yeah I
mean Jane is five became yeah GA like
one month ago so if you want to use
mojito you can I mean every everything
that I've explained it is still buried
in J unit five you need to use the
letter C jar file but if you want you
can use that let's say native unit five
extension which just put excellent with
mojito extension and then you can in it
all you put this and then you can in it
your marks just putting for example as a
as a method argument and you said I need
this person and said when person can
name then return the world for example
and then you can use this mark that
you've created in your unit method in in
the test as a test method parameter so
you just I mean that in the first part
you initialize the mark and the second
part you just use the mark and you say
that the person that name is equal to G
Burt this how it's going to be done all
this mock stuff in the unit five so I'm
going to show you now demo of acid gay
and mockito and then it's really simple
demo this is about a sergej so I have
you need to swap screens oh yeah then
what it'll be very boring there but I
can tell you what it's doing but it's
not the same now then here
now I have again this is example with
maybe you them now I have here the list
of operas this is the same example we've
seen and then what I'm using is the Acer
dot which is that one from a so Jay
operas I mean this is that the thing
that if I do dot I can see all the
methods that assert Jay allows me for a
list of things for example if I do huh
sighs it's it's it says okay you have a
has size or has same size off but hi
size is not for a string so I can do has
size 2 and then I can do again dot and I
can say okay what do you want to say
with this operas I could do for example
contains these as you can see the
contains it expects an opera object it's
impossible to pass here and a string or
something if not the completion or
should have contained contains exactly
the content is a clean and the order
contains only contain only once contain
sequins or contains contain subsequence
so this poly answer your question so if
you have different duplicated objects
but you do contain subsequence here you
can put just the just the sequence we
thought the repeatable objects and then
it will pass as well contain solvent in
the tag lavalla
contains no this is just this thing
about um about a so J so what I want to
is just extract and I what I want to do
is just extract the name I mean that
notice that this is a Java 8 one the
method where I can say just call just
creamy a list of strings and then this
is the strings so with the strings I
cannot do her size there's no Hara size
in this case has size is the size of the
string yeah see if it has been an object
then it's good yeah but if you say
contains contains is it now it's in a
string it's not an opera object anymore
so I can go contained and condemned
poor float and so much not an a salver
flutter and that's all then I can run
the test and if I wear no worries
obviously I'm not German neither if I
not remember I lived in Germany yes just
mix up a little bit so yeah no no it's
the green sir where is he
associate helps you improving your
testing skills just doing control space
the other example I'm going to show you
here is one for mocking this is this is
a an example that you find in the book
which you have a game service which
books hang out testing that is basically
game services it's a example is about a
plane gaming platform and the game
service just connected to TV which is
into internet games database like for
the movies but for databases so it has
this method is just do something like I
have a gbb gateway which is the great
way to connect to this database but also
I'm using here a games HB
in fact it's a local 8 GB such it's a
proxy a procedure object no remote call
or whatever which uses a database so
what I do here is like saying when I
want to subject
I search first
if I if I I mean that these games act as
a local cache so let's say it's like if
they someone has already request me this
game from the AG dB instead of going
outside my boundaries I'm going to my
database and I get
so what I want to test is that a certain
game if it's cash in internal database
but my game service of course needs I
mean that in this case I don't want to
use a sociable unit test because games
require to prepare the other ways boot
up the database and so on so far and of
course a GDP gateway should be not
because I don't want to access all out
of my internet or my boundary of of test
so I need to knock all this kind of I
mean these objects to do it in this case
I'm going to use the mockito g-unit
runner then I'm going to mark games and
I'm going to mark a gave me this is the
person that I need to then Massacre here
is the game with them I'm trying to find
the Zelda again and finally when I need
to record the expectation and what I
need to do is plan games
fine game by ID and they do notice that
is one two three this is this ID don't
return optional because this method
returns an optional because it might be
there or not of game so them saying here
is like when I call games fine game by
ID just return me again a real game so I
know that its cost then here this is the
game service and I need to set these
collaborators inside the real instance I
just need to do service thought games
equal the games and game service
okay now we've got almost everything in
place
notice that I mean that this test will
pass and it involves a sex I will work
if I cry it because it will return the
the object Zelda but you don't know
exactly if this game came from the cache
or not so what I want to verify is that
the HTTP gateway is never called so I
can call verify HDD ID well x 0 so it's
never call dot search game by LD and
it's any ID so I'm doing here is just
saying just find Millie to run the code
and really verify me that a gdb is never
called notice that this is it since it's
a mock you will not receive a
nullpointerexception
so you need to purify it explicitly so
now I can write and it's green so now
I'm verifying that my logic of checking
if there is a cache object or cash game
then return the cash game and if not go
to the HDB it's the first part is
validate of course no real ambulant you
can see here there is more tests that
say show return game from hgtv side if
game is not internal database so what
I'm doing here is just saying phone game
search by ID returns battlefield 4 and
then yeah and then I'm also knocking the
gdb saying find them by ID 1 2 3 returns
and empty so it's not in the database
and then when I just try to call a gdb
then returns me there the game so then
here with the unit test really fast unit
tests remember that this is a unit test
you can verify this logic really quickly
just too big so any question about this
demo yeah
mmm you're sorry can you repeat that
yeah this is this is part of an initial
approach so the question is do we want
any kind of interaction outside of the
test and for this test no we don't so
that's the purpose of mojito is to
contain our test environment if we
wanted to go outside of the remote
boundary then we would need to ensure
that that service is available and that
then would be more an integration test
than unit test so we want unit tests to
be superfast so unit tests are the tests
that developers run all the time when I
start running deeper integration tests
when I start interacting with my
collaborators if and I keep going back
to the ASAP example but it's kind of a
real-world example if I wanted to talk
to sa P in my unit test and F ap was not
available at that particular time then
my unit tests would fail them may give
me a false positive No so I need I need
to mock out sa P and say this is the
class that normally talks to s AP I'm
just going to have the mock all I'm
doing is verifying that my class that
interacts with the s AP mock that's what
I'm expecting to do in a really quick
way so it's kind of the first step it's
not going to replace going outside of
that box eventually we will need to go
outside of that box to verify the
functionality of the object in a
real-world scenario but this is that's
going to take time and these test tests
that we want to run really really fast
every time we do our builds basically
and they don't if you're a developer and
you sat in your machine and you're
running 100 tests you want them done in
a second so these this is what machito's
for us to say okay all this slow stuff
will mock that our or this functionality
that you don't really need just to test
this specific object that's all hidden
and we'll replace that with canned
responses and those cans responses
they encode the super super fast so
these tests run in milliseconds that is
just yes this unit tests and they are
really important to be really fast but
that is not unit test does not replace
anything setting this was like all the
tests are pushing the same and sometimes
I mean others and they said that then we
were going to in fact alien hours going
to cover this component testing which
we're going to call how to run this in a
more real environment let's say unit
that's also really important for con if
you are using continuous delivery
because you need really fast feed but
we're going to cover this by the end of
the other of the session but it really
needs to be fast because you need fast
feedback so developer knows exactly that
his permit has not break anything so
it's really important that they are fast
but now yeah and it was going kind of a
relevant question as completely fill all
that was coming up compiler interesting
story component testing is the next step
on from from unit testing so we have our
unit tests these are things that are
really fast and we've mucked everything
out now we want to take that a step
further so I have an application I need
to deploy an application to to my
application server or application
environment whether that's an EE
application server or spring boot
environment I need to ensure that the
application runs within that environment
and so this is kind of the next step of
putting things together in a more
collaborative way so this is where we're
so using the social social tests and
we're going to be using our
collaborators right yeah this is very
simple arquillian test I'm actually
going to do a bit of a demo at the end
and show you how that all works together
but very simply we're running our tests
now with the arquillians FASS and this
basically understands what defines
parameters or a framework for us to test
our applications so our our application
classes have now been unit tested we
need to deploy them in our application
on our application server and test them
in the real world this goes a little bit
for
the test itself so get color object it's
actually calling a real server so this
test looks really really simple what's
going to happen is the deployment is
going to build a real world war file and
it's going to deploy that to a
real-world application server it's going
to generate a real world client call
test against that application server so
this is very very simple test but it
actually has a huge amount of
boilerplate code that's hidden in the
background and we'll be looking at that
in a minute
so yeah I can you might I forget we have
these annotations injects the URL so the
URL is obviously going to be required to
access the application server because
the application server is running under
a specific context we don't know what
that's going to be usually we generate a
random port for that access and so that
gets injected here and I can use that
injected URL at this point to make the
real world restful over my local network
so we're still not going outside of our
own box we're not testing any services
that aren't there deployed externally to
our server we're testing and starting a
local application server and testing a
local in our own Network same kind of
thing for spring boots so we have the
spring runner very very similar in the
way that our Killian fires up an e
application server
this is going to start a spring boot
application and so all this in we still
have our not servic runner so we don't
want to go outside of our own network
and the mock servlet Runner basically
allows us to speak over the network to
our local machine and auto wire there's
obviously inject in in the spring world
and we test against that spring boot
rest application requires us a little
bit more and again we have all these
examples available later at the end so
if you're missing something here don't
think you need to write all this down
and you'll get all this later but this
again it's just saying
start up my test environment on a random
port and then I want to do a real world
call and we use the template so the test
template from spring basically gets the
URL injected inside it and knows how to
talk back
so the arquillian test injects the URL
directly into the test here we're
injecting a test template that allows us
to talk to that instance and it just
makes a rescue while fly swarm is
supported by the our Killian framework
but we need a act of default deployment
annotation and that it's just something
that triggers well if I swarm to scan
for classes and it builds that test so
it's very very similar and ejects and we
can test against that test and in vertex
which Alex is involved in heavily I
believe for this we need the vertex unit
runner so again you can see we're just
adding a run with annotation and then
telling it what we're going to run
against and obviously the vertex runner
and the spring runner and the pillion
class they will fire up and under still
doing some fancy class path scanning and
they will find all the dependencies far
up the corresponding application servers
or environments for us to deploy our
application in and then we test a real
test against those environments and in
vertex you also need to shut down so we
need it after to clean it up otherwise
it starts a process that will hang in
the background and needs to be told to
shut down and we've got the Tommy Jack
so I start a project it's just a really
simple project and I can probably just
do it here actually
no way yeah doesn't just select all it
I'm not a Mac user I have a nice little
doubt and it just console for me I just
need to console
so this is basically just downloading
this simple little project I can open up
an ID as well it's UN to open yeah I
just need this the first time we've done
this talks of a working this stuff out
sorry oh you get to switch my if you
okay I want to do this in real time just
to show you this is a really simple
project to download yourselves and it
will import and we can just run it
Amira's until it illegal really slow
when it starts applications these days
or loads projects don't go to sleep
not yet and those of you are wake up
well I've told it that the problem is
that we are downloading internet twice
one in the console an hour under stress
for privates month
yeah so this is the project it's very
very simple
I don't know why it's taking forever to
load on this box for me this is the very
beginnings of micro service so it's just
a singleton EJB in this context called
color service it has one end point for
colors so this is the the surface error
is talking about whether a micro service
what is a micro service it's that
surface area this is for me the micro
micro service it doesn't do anything
fancy
apart from take a string color and
return a color object it could be making
a database call it could be making that
famous essay peek all over here this is
just all very much in memory very simple
application and to test application in
our Killian I have my color service test
and this is just going to be the
achillion class so
dated with run our Kilian it's a
standard unit test but in this case I'm
making any deployment so I need to do
some kind of deployment of my
application and to do that we use shrink
wrap had a bit of a discussion with
Tonio last night about spring boot and I
kind of like the idea and it's something
we'll be talking with Alec which is more
about class bus discovery of our
application so the nice thing with the
spring boot tests is you don't need to
define any particular classes for the
test that will just discover those and
deploy them in the spring boot context
whereas with ets we actually build our
war archive or a enterprise archive and
for that we use shrink wrap and so
shrink wrap was literally just adding
some classes and it's going to be those
classes so the color service in the
color class that's enough for my
application to test against and what
this is doing is actually in real terms
is building that war file and it's going
to ship it to the application server and
then run a test against it and here's
that web URL getting injected and here's
a web client accessing that URL
um and so if I just run this which is
just going to be a maiden test expand
this you know this here called the
Tommies are started so this yeah if we
scroll back from the lab you will see
what is actually done it's fired up a
tommy server in the background so this
is the actual server starting up in the
background and it deploys the
application
there we go so this service you arrive
at you can see that's the real end point
and you can see it's on localhost and
it's generated this random 4 3 3 3 5 1
and this is why we need to inject the
URL into our test and this is kind of
imagine it's going on the background so
this is an application server that's
fired up it's deployed a real war file
to the application and it's now
available under this big long URL and
this URL gets injected into my class
they then test against that a test and
shuts down the application server so
although that test looks really really
simple that's the idea it's designed to
be something that looks really really
simple yeah so notice that it just takes
8 seconds so we are just creating the
war file green app a Java EE server I
mean that if you compare with know
nowadays but in the past that were
really really slow to boot up a server
now this is Java 7 server it just boot
up run the test and shutdown and with
just 8 seconds it's really fast so that
is basically a component tests are
taking my application we've unit tested
obviously this color service in color
you've just seen any unit test we would
do we would still have a unit test for
that this is the next step where I'm
actually putting on my application
server deploying a to a real application
server and doing a real local network
test against that that service and we go
back to our slides
so any questions on a Killian component
test or a spring boot tests or component
testing in general it wasn't that dry
wasn't no there's a lot of it so the
question is what if I have thousands of
classes in my application well yes I'm
going to have thousands of classes in my
application and contrack load those
classes do i or do I have to manually
enter all those classes well the answer
that is very simple no shrink wraps are
really really powerful mechanism
understands pretty much everything that
maven has to offer so it understands pom
files it understands class path
dependencies it under understands
libraries so I can add entire using
shrink wrap that was a very very
simplistic example by just adding my two
classes and I could also add jar files
if I have in my libraries directory in
my application I can add all those jar
files if I have an application I'm
writing normally the shrink-wrap I would
create an abstract class with that
shrink wrap that contains the bulk of
that logic and then I would extend that
so I'm returning this war file this war
archive and I can then add to it so in
my abstract class I would have my larger
application and the wiring required to
build that application and I don't have
to add add to my entire application I
can also add dummy files to mock out a
specific functionality that I don't need
for that test but if I want to be as
close to my application scope as
possible then I build my war file just
as I just as I always expect the Maven
war plug-in to build my war file I would
try and build that in shrink wrap in my
abstract class and then for each test
that I'm testing I'm only going to add
the few classes to that shrink wrap that
it's delivering from the abstract class
so it's kind of right once and reuse
kind of scenario
but I can also just import my whole comm
file so this was the conversation that
had last night which is you know spring
route just to scan scans the path and
has stuff and my question was how do I
exclude stuff and this is what we don't
I think I like tests to be more specific
than that and I still think is a really
good idea and I think it's something we
could probably do on the shrink-wrap
sorry yeah well just scan the path I
mean we can import the whole plant file
yeah this is yeah there's a lot of
strategy this way a poor example well
flies form we're going to see now that
it has this ask in class path like is
promote so I would say that even a
component test probably you will need to
add a lot of classes maybe you need to
add 10 or 12 if not probably you're
getting close to end-to-end test but
then in anyway in this will rub you can
do something like add me all the classes
from this package and recursively sub
package as well so you can do put just
the package or even you can do something
like call maven or griddle I mean it
works with profit let's say I'm even
called me bond package then this war
file putting me in this room wrap file
and then just deployed this war so if
you want to do an end-to-end test you
can even generate your war file on the
fly and on the test of course this in
this case you are paying at the time of
the of this of the running I mean the
running time of the test because you
need to run all the built get the world
and then run the test but yeah I mean
that you can you have several ostriches
in this way of with this room wrap did I
answer your question any more questions
before we move on
how robust is component testing it's
good question
I think obviously unit testing is the
it's the most reliable and quick kind of
testing I wouldn't be running these kind
of component tests unless I wouldn't be
running them I made in my regular build
I would have them separate for my
regular build because they tend to be
slow I mean eight seconds for the
application to start up as and do the
test and shut itself down is quite quick
and if you run a whole bunch of tests so
that the the killer is obviously
starting application server our Killian
is now very very mature that how long
have we been developing our Killian now
it's probably eight years yeah yes
English you know initial inroads same as
any software we were buggy but over the
years it's progressed and every single
application server that exists on the
planet is supported by artillery and now
and they kind of know so the vendors
write their own startup routines for our
Killian civilians the framework and we
write the the runner so for Tommy for
example we've developed our own plug-in
for the arquillian runtime we know how
our application server starts that we
know how to configure it and make that
run fast as possible for a test and so
the environment that's been initialized
through our Killian is done by the
vendor and our Killian is like the
initiator of you know do your startup
and do your shut down and do your
deployment they don't have to understand
how they do that the vendors do that but
all vendors have plugged into this
system because it's become so popular
now and I really don't think there is a
ie server yeah even even a server and
several servers for example Tom Couture
jetty it's also supported by a trillion
so you maybe you have just you're just
application with Tomcat and subtler than
I mean it's something to answer
questions they're very very stable now
these tests are just slow so I would
describe them as slow and I wouldn't
run them for every single bill that I
have I'd have them in a separate module
and it's more of more of a well it's a
component test separate from a unit test
and and I usually run them on Jenkins so
when I do a commit it will run all the
component testing for me but what does
about to say is that the killer is the
startup of the application server if I
have a thousand tests I don't need to
restart the application server every
time I have the option of leaving the
server running and then the tests are
just deploying a trivial war file to
that application server and so that
eight seconds for just one test that we
saw here that was a you know a cold
start if I run that again now it would
probably be a little bit faster and
become progressively faster but if I was
running thousands of tests against that
server it they become very very quick
less than less than within milliseconds
the deployment and testing against an
application there is it's the startup
and shutdown at the application server
that costs but yeah stable and I think
with that I'm handing back over to Alex
for rift yeah so you have seen here that
we are starting the blackish on server
and then we use the web client this web
Linus comes from the Java EE spec maybe
you are not using the Java EE or even
you want something more oriented to test
because WebP line is oriented for
production code not for testing code of
course usually your your communication
with micro services is using rest yeah
yeah creating a rest api with JSON or
XML I know that this is something that a
lot of people do but it's not I mean
that there are other possibilities like
there is binary protocols or even
message brokers using a binary protocol
like for example it's doing with vertex
but I would say that in most of the
cases we are implementing my the
communication between micro services
with rest so I think that the best tool
for
verifying rest API is rest assured which
is a testing number it validate its used
for testing and bleating rest services
and it's inspired in groovy and Ruby s
way right and yeah and rest assured just
it's just the way of testing the
resources part of your micro services I
think it's fair to mention right now
that there's no golden rule that a micro
service has to be a restful endpoint the
resource the blue resource at the top
that can be any kind of endpoint Li you
need to publish as a service as a micro
service but the industry has kind of
taken a huge step in the restful
endpoint direction I think that's where
your focus should be on providing
restful resources as your micro service
because everybody knows how to talk that
it doesn't matter what language you're
using or what scripting you're using
everyone has something that knows how to
talk rest these days if you have
something that's not rest then you're
gonna have to do the groundwork to make
that test work for you and this is a
standard way of doing stuff so this is
an example of rest assured
basically what you start is with given
when and then you put here the HTTP
method yet it is not the still method
it's gap and you can put or you can use
a placeholder which is replace it on
runtime and you can put something like
that composer having a look in vomit
oven and then you have a surgeon's with
the response and you said you said after
that so this but it does make this
internal is just doing connection to
HTTP localhost 8080 slash removing from
the oven and then the return must
contain a JSON file which the body's
name and to be lumen Beethoven and you
can even use GA path expressions inside
this body so you can say operas that
size because this JSON has an opera fan
operas filled with of type array you
said operas that sizes one
and operas the name and this is this is
doing exactly the same as with the
example we saw in a Sergey which just
takes the upper all the upper objects
just create a list of strings of with
the name and then has items
Fidelio because it's the only opera that
william bonnez oven wrote of course as I
said now by default as the shirt goes to
http localhost:8080 and if you want to
specify another URL you can just do but
get HTTP example.com and slash and then
you put the other the the placeholder
which is great but notice that if you
have several tests in if you change
example but come to example to.com you
need to go to all your tests and change
the example to example to calm and so I
this what you have is Rico suspect
builder which is a way to reuse the same
configuration across all the requests
and you can reduce the expectations the
path the route the authentication
methods the poor the host the parameters
the heaters everything can be reused
with this Rico suspect builder so
basically you do riggo's build or aspect
Miller new suspect builder you then put
Builder dots at this URI and put
example.com
and then you just do given that spec do
that to build and then ask you to as we
saw in the last example so you can put
this rico suspect builder inside the
factory method and then this method is
called to get always the same rico
suspect builder and you pass this
recursive specular on your test so if
you change from example.com to example
to.com you just need to go to where you
have defined that the record suspect
builder and just put change there the
base URI and all your tests will be
adopted
automatically one of the great things
about rest assure is that it have
interested all the authentication things
so you can put for example if you want
to use oauth2 you can do even of off to
with the access token when bla bla bla
bla so all the authentication it's you
know it's an encapsulated inside rest
assure and again this
alfe thing can be put inside the RICO
suspect builder so if you use the same
token and the similar protocol in all
your rest endpoint you just put it on
the record specular and everywhere is
updated at once and you can use also the
phone and the basic way it also supports
CSRF token and you can even implement
your custom authentication method and
well more features are offers the sure
is that you can implement your custom
answers so it's not just for JSON and
XML you can implement your own protocol
as well if that's one of the good way of
referees that has an SSL support so
usually when you start doing HTTP you
get it a lot of exceptions with
certified certified certificate this
expired certificate is not validated as
one so far so you can do just that
relax at HTTP validation and then all
HTTP connection works perfectly without
all these security mechanisms that are
behind HTTPS you can also use filters so
you can modify the input and the output
of the concern before and after is sent
or received and finally it has some JSON
schema validation just a schema
validation is like x SD but for JSON and
you can say look I want to validate that
my JSON has this structure but I don't
care about the real values so say I want
to be able that to verify that it has a
field called name and it's on a string
and I have a called field age which is
an integer so it just checks this don't
check about the real values so it's also
supported this by rest assure then let
me show you now a quick exam all about
how to do this
this is everyone knows Wi-Fi sworn what
it is yeah you don't know yeah everyone
knows Wi-Fi song
well well first home is like a spring
boot but for Java EE okay so it's like
creating a huge jar with all the stuff
there
and this is a really simple endpoint
which is just don't want that I'll show
you that you will slash composer and you
find a composer and returns the the
answer and this is the test that in this
case I'm using the Wi-Fi swarm approach
with which web forms focus on
micro-services so you can use that as a
real rap thing but you can use also this
default deployment which says just scan
the class but put everything from the
class pass inside this war file or in
this case is a jar file and in case of
microservices probably discuss sense
because they should be small so it
should not be a really a lot of time to
deploy everything so as I said before
you can do given when notice that this
is a DSL well I'm just writing it it
appears everything then you can put here
loot then I can check asserted and the
name is
is also a component test because you are
checking that your resource in a real
environment words as expected of course
the question is and what's happened with
the databases for example in this case
I'm not using any database but if you
were using a database then in component
as you are using this in memory embedded
databases which are pretty fast so now
if I run this test you'll see here that
if it works yeah that it's resolving you
notice that we solving zero out of five
for five artifacts one so far just
scanning the class but then it is
studying the wi-fi's form which under
the need is under throw blasts wildfly
so it's starting by fly server then it's
maybe to deploy okay now it's deploying
whatfox form is ready and it fails
probably because I miss well because
composite looking when we told me this
probably I right now okay
I mean it just thought I'd put an N I'm
going to confine in the internal device
I can run it again but it was this the
problem
and it's the same with these kind of
tests it's the start of the application
server know environment that takes the
time the test is yeah let me the second
and we're only running one test these
become obviously far more valid if
you're running a thousand tests against
that instance that's fired up then
they're all going to be really quick
then that's one chance okay any crystal
Bristol sure good yeah we're gonna wait
for a 15 minute we're gonna take a break
now yeah let's take a break 15 minutes
and then we continue with the spar with
20 minute break 20 yeah it takes time to
get out of here 20 minutes and then we
were going to start with me we've taken
your name's at the door and taking
pictures and stuff so if you don't come
back we know who you are we're raffling
off 8 free free books at the end so if
you want to stay to the end and you have
to say the end if you wanna get out for
free there you go that's bait ok let's
continue with testing now we are going
to start this there Ameena
some techniques that are really more
specific to micro services if you one
was more like an introduction which can
you can reuse in monolith or in micro
services but now it's more things that
are specific for micro services the
first thing that we're going to cover is
service virtualization and probably with
with micro services you have one service
and then you have several other services
that you need to talk about at all with
maybe these services are internal maybe
they are external
but this your micro services has
dependencies with other services that
from his point of view they are external
so the thing is that how we can test is
notice that if one option would be I
have test a as I want I have the micro
service a that has a dependency with
micro service B so if I need to write
the test for
Micro 6a I start up Microsoft is a and
then I start up micro service B and then
I run the test this might work but the
problem is that probably you have tens
of micro services jumper you start with
a V because V has added added relation
to prepare this database then this big
has C and D and you end up by creating
an end-to-end test so to fix this
there is the Serb mythology or called
service virtualization with basically
it's like a light proxy which intercepts
riku's and responds in a smart way and
in a small way I said back because they
know how to detect if if you needs to
capture the traffic the real traffic or
needs to simulate traffic I want and
it's really easy but seen now service
utilization in capture more tap to more
mode probably this is how you're going
to run the first time so one way you
have you have you can do it it's just
simulate your API just say ok I'm just
going to forget about the service B and
I'm going to write a similar
assimilation the problem is that in this
way it's how you understand that this
other service must behave but in but
it's not how can be really be the you
know the protocol implemented so what
you need to do the first time is call
against a real server so let's say that
periodically every week or every two
days or whatever when you think you are
going to run a test against a real
service so you have service a that
connects to a proxy dislike proxy and
this like proxy instead of returning you
cannot answer it goes to the external
network and connects to the service P
then this service B will return around
for it says ok if I go to a slash
composers and slash routine van
Beethoven I'm going to return that real
JSON and then what this service all
these service virtualization
and framework does is just a store these
in the in its internal database and
after that is returned the real answer
to your service a so your test now it's
effectively using real service a and
real service babe but this just happens
the first time what's happening in the
other in the subsequent runs of the test
then you don't need to hit the real
service B you just have the service a
goes to the proxy and the proxy will say
ok you want to go to a slash composer /
with in van Beethoven but you have done
this before
because I have in my internal script
database so what I'm going to do is find
my script find the answer I'm going to
return you the answer that was returned
before and just say and here you have
the answer so now the answer is the real
one although you have not connect to the
service P so service be up to now that's
that's been a mock or a dummy France and
we've now spoken to our real
implementation but we want to go back a
step because we don't want to talk to
service be all the time you can you can
see not now then one of the I think that
the best tool for Java I know that there
is also wired mock and Betamax and swans
far but we've passed all of them and for
me or it's my opinion hoverfly is one of
the best one for service virtualization
it's implemented in all walks myself
it's implemented in go
it's integrated with Java and one of the
great thing about our fly is that it
when you start it it modifies all your
JVM properties so all the JVM connection
properties I modified by our flight so
you didn't don't need to change anything
in your code and and magically your code
will speak to this like protein we're
going to see an example but this in
capture similar mode this is that the
lifecycle I've explained it before but
the whole fight comes with a j-unit
class rule it also has support for the
unit five and just you instantiate the
over five rules out in capture
assimilate mode and you put the file
that you want to be stored notice here
that you have my composes did way and
this composite we do is the one that
connects to my composers service and I'm
using operas comm 8081 I'm using the
real host I'm not saying I'm not putting
here localhost or whatever it's this is
where the real service is running then I
do they get composers which is Matawan
and obviously it returns this gem it
returns the real data and it's a store
and the store file it's something like
this that you have a data and then you
have that the hrickos when you go to a
slice you mean one Beethoven with method
get on poppers calm 8081
then just return status code 200 and the
body and so and the heaters and so on so
far this is the real then what's
happened when I run again these in
simulated mode sorry because now if then
if I run again this test then the operas
come is not going to be you're not going
to be connect to wordpress.com but you
don't need to change the host name
because since our fry modifies all
George ATM network settings he knows
exactly how to deal with this I want to
see that now in example also it has some
similar mode which you can do something
like this maybe your service be it's not
done yet so in this case is what you do
is something like this I want to start
in simulate mode and I want that always
returned but when I connect to API dot
five.com
in with get in a slash API slash booking
slash one then return this JSON file and
play if you check this you said look
this is like mojito but instead of
mocking classes I'm mocking services so
you can think about that service
virtualization and in this case
RFI is like a mock for the enterprise's
it's just you're mocking my service
instead of my classes and it's really
powerful in pieces you have didn't have
the service be developed yet again you
just need to use our five role where you
want to store
unload the file and then just build the
riggers and responds automatically and
as I said since this is like mojito you
also have this verify component so you
can verify that you have called any
flight host with AP is bookings with any
problems or with all you have called
port with this with API booking one and
with this hill now notice clear that you
are abusing anybody so it means like it
doesn't matter which is the content of
the of communication any communication I
want to verify that I have this
communication with both I don't care
about the content and let me show you an
example I have here my service this is
the composure of service I'm running
with in this case even blocker and then
I have here and then I have here my test
which this is a music box
this is service a which is a music box
and I want to connect to service B which
is the composer's to get some
information about a composer so I'm just
putting here a hover fly rule and then
not if hear them in the composer's
gateway I'm putting here the IP this is
that the IP of our house which is my
well this IP with for 80 81 if I you see
here this is the running service and
then I assert that the composer it's
moving van Beethoven when I search for
Lumumba Toman so then I can run it and
then what's happening this test is that
I'm getting the real real service and I
go here
I do the Lukas against the real service
and I get a JSON file and if you check
here in anything that I think it's worth
much this is get composure so JSON this
doesn't exist until you make that call
and when you make that call it creates
that file and then the next round
obviously it finds that file and uses
that file and this is kind of like a
one-time thing so you can get like
you're safe developer if you're gonna be
making serious calls to something like
the famous s AP service you don't want
anyone making those calls they need to
know what they're doing and then make
those calls in a safe manner and they
record this information store all that
and that gets added to the project and
so other developers they never make that
call because that file is in your
project then notice that I'm going to
shut down my service so now my if you if
I do docker PS
you see that there is nothing running
and I'm going to run exactly the same
test I'm connecting to the host I don't
need to change anything and then if I
run again you see that that's this green
as well unless it's quite more faster
than before because I'm not touching the
real service so without changing
anything I can make the you know that's
the test run you didn't need to take
care about changing the house or
whatever it's works magically without
touching anything just basically it's
not magic it's like changing the JVM
network settings but this is how it
works and another that this also works
pretty well if you are using external
services if your micro if your micro
services needs to connect for example to
Twitter API you can just run it once and
then use this test and this data
collected for your tests so you don't
need to need to get some flaky test like
the network is down you reach the
quarter on Twitter and so on so far
to skip the questions we're going to go
to by the end so if you have any
question just write down on your you
know in a paper and then wait because if
not we're going to run out of time so
we've got integration tests um in the
case of insertion test the wall is to
verify that a module can communicate
with real external services this bigger
for a bigger test for now it seemed
component test which is like I can use
an embedded database I can use service
virtualization to mock the other service
and so on so far but at the very end you
still need to cover that my real
database is able to boot up and execute
some queries that my big boy class is
able to connect to the real service and
basically what we are going to cover and
its second what this path so this red
path there so the Gateway incursion
tests allow any protocol level such as
missing HTTP headers incorrect SSL
handlers rigueur response body so in the
gateways you test these things that are
specific to let's say production and in
case of repositories George run as a set
to test against wheel databases so if
you are using for example Postgres equal
your you need to boot up a possible
sequel database and run some tests
against this real particle sequel
database so in case of persistent test
I'm going to show you some tool but you
can even use it in your component test
but as I said the difference is that in
component that you're going to use in
memory database in this case you're
going to use the real database
an example okay of how it works and and
they think that it's going to yeah I
just think I can clear this so this is
like the first attempt people usually
have at some kind of integration test
with their database we've just got two
methods here clear that clear database
insert composed a year we would probably
have some kind of cleanup routine and
this is very ant hoc way of doing stuff
no one knows what you're doing what's in
the clear database method what's in the
answer composes data so this is like a
bad way of doing stuff this is what a
lot of people do without using any kind
of framework they'll go off and create
that connection to the database populate
the data and then test against it or
then clean it up and when that time
comes to hand it over to the next
developer he has to dig into that code
and have a look there's no idea what's
going on so we want to replace that kind
of ad hoc way of doing stuff ie the
wrong way of doing stuff with something
that's much much better
and we'll go back to our Killian so our
Killian the project provides this for us
and this is going to be provided by a
rule and this is just a standard J unit
rule so again we're back into our J unit
context that we understand and know all
we're doing is adding a rule and then
the DB unit and our Killian resource
inject a database populate er so the
rule basically defines where the
database is and how that's set up and
then we populate the data using a rule
and this is just a much more
standardized way of doing stuff you're
using a framework it's write-once and
reuse yeah it's important journalists
here that you don't need the herculean
runner just just a rule it's called or
Killian because it's inside the egg it's
behind the berkeley an umbrella but you
don't need the runner yes we we don't
need to be deploying this to any other
application server it's not a compile it
can be used in that context but this is
just a standalone context
and a very simple way in a j-unit test
of populating the database and this is
not is that this is the file so we're
basically using a Yama file with data we
can generate this file and populate the
database with known data so this is our
pend data for the tests and then we use
an after rule to clean up and we can use
the same Yama file so if I've populated
the data with ten specific items I can
remove those using the same mo file
obviously the benefit using if is
there's a huge amount of boilerplate
code that's just been done by those very
simple tests we don't we don't need to
reinvent the wheel basically that's the
idea is not to get your developers
reinventing the wheel every time they
need to do something with a database
it's programmatic so you can program the
API and it supports many many different
frameworks so this is not just a idea
but relational database management
systems this can be a no SQL database or
no sequel I don't know why I always say
no SQL and everyone else there's no
sequel that's that's the way I learnt it
and we have REST API support so when the
service is running we can actually query
information from the service I'm going
to skip those questions why do people
skip unit tests a unit tests a lot of
times they're slow so we've already
talked about unit tests and how fast
they can be and then we go to a
component testing it slows down and now
we're doing integration tests and we're
adding services and running up says
these things are just going to get
slower and slower and slower and people
wants to keep them and I'm just going to
show you example of the thing that can
be kind of built up using this list
theory
so this is a very complicated into
intestine I'm not gonna go into great
detail on it it's just an example of
showing you that we can do so enter in
test this test actually defines several
rules and we have this thing called a
rule chain this is just standard j-unit
stuff and the I've just made a couple of
rules a Reedus rule and a MongoDB rule
so I need to fire up a MongoDB for one
service and a Regis no SQL database for
another service and I have another micro
service that you need to fire up and
this is just a very very ad hoc way I
like to say the gloves are off so I have
three different services that I need to
fire up for this test how do I do it a
very simple way to do it is using rules
and rule chains I have multiple
deployments so the deployment we saw
before in the Killian test was designed
to create a particular deployment and
here I have my shrink-wrap building a
much more complicated scenario and we
can see that we're adding libraries and
this is again just to show you the depth
of our Killian and actually interesting
framework and the things you can do with
it so this has another deployment and
another deployment so I've got three
different deployments going on I've got
rules going on and this is a super super
heavy integration test but it's kind of
what we need to do to test different
deployments against different services
in a real runtime environment and I can
test in sequence that's a kind of no-no
in unit testing this should be
independent from each other but now
we're not independent from each other we
need to be dependent on different
services and so we have mechanisms not
achillion that allow us to run specific
tests in a particular sequence so I
might populate in one test the database
in another day another test I might
remove that data and assert those
inserts and removals
and we go down all the way once
everything's fired up I'm just testing
that services are available and then
here I've even got a UI test so this is
moving into selenium and drone testing
and actually firing up services for a
web application that has a UI that needs
to be tested against all those running
backs back in services so we can pretty
much cover in fact not pretty much cover
we can cover every kind of scenario that
we have in a micro service and
application server context using the
arquillian testing framework we don't
really want to do that yes we do we
don't want to do that when we have a
better option the better option is not
always available to people that better
option is going to be docking so instead
of having the integration test that
tries to fire up all those different
services and again that's investigated
by your environment the reason we have
the complicated scenario in our Killian
is because you might not have the luxury
of being able to deploy containers and
manage containers in your developer
environment so you need multiple options
and this is where I clean cube comes
along so our Killian cube basically
integrates extremely well with the
docker docker compose and native docker
it allows us to start/stop configure and
deploy containers so all those services
you just saw in that integration test
that were being started by roles in
various fashions or deployments we can
take all of those different items and
place each one in its own container and
start to use our killing of cube which
virtualizes that process away from from
the test itself we can also yeah this is
more your stuff with the prune the cube
DSL so we have the language programming
language that allows us to create
different kind of tests so there's going
to be a spring blue test and the
initializer is a class that we can use
to customize the the start up I'm not
going to show you the code the code in
this slide yeah this is like whether you
define what you want to stall up your
run into this so this is the initializer
it's just very very simply like the J
unit rule that allows us to fire
container and this is just an extension
that's added and this is performed
before the test is performed so yeah
this is mitosis is provided by a spring
boot so you need to do in the spring
Buddhist said look instead of using the
default Reddy's IP and readies for just
use the ones provided by the container
which is like you said you see that they
are saying ready start date IP address
and ready state by import this readies
instance is that the one provided by the
cost rule so what you're saying here is
like would have the spring Bhutan but
the readies instance that i want to use
is the one provided by your Killian this
is what you're doing here so it's
overrides whatever something on the
class path for that specific test and
this is moving on to the Killian cube
example which is what I'm more familiar
with and this is again just taking it
very very simple our Killian test on
making Anarkali interested very very
simple what's going on here is we have a
container that's been defined and it's
called hello world and just adding the
annotation docker URL is basically going
to tell us we need to fire up that
container so the container is fired up
and the request spec builder is the URL
or contains the URL that is connected
with that service so when docker fires
up my particular instance I need a way
of finding it and and the route the spec
builder allows me to find it very easily
and then I can talk to a docker service
in my test
yeah but basically this week was a spec
there is the glass from rest assured so
if you want to use rest assured this
with docker URL and setting a request
specular will darkly and cue will
configure your record spec builder to
connect to the container called hello
all
I think that it's if you do next
yeah this hello container comes from a
docker composed so if you don't want to
use this Parramatta Quay of having to
define all your continuous in a class
rule and define everything you can just
use your record compose files the final
thing and then if it's I mean at the
Vision Source test docker or it's in the
root or is its in source main docker
there are some defaults you don't need
to specify it and if not you can go to
your trillion-dollar XML and say I want
to use these proper file that is located
there and it's called in that way and if
not you just put it in in the for
location then relics it out where that
row or lesser now is a great teacher I
am or user of this stuff I also use it
in production it's it's very much more
works very very well
and it's much simpler way of creating
all those integration tests you know if
you do have multiple services and
obviously the micro service architecture
we're going to be having my option
services I would suggest going this path
and only use the end-to-end test and all
the are killing deployment features if
you don't have access to a doctor
environment the queue example we have
much community I just wanted the maven
this is an example of our client
persistence extension and are killing
queue so you have here both encourage
both testing frameworks integrated no
sorry just here what you can see is that
I'm defining the raddest container and
then I need to define where this server
is
need to I mean that we're a team
persistent extensions need to populate
data and in this case I'm using this arc
link you've create some default system
properties called R cubed docker dot the
the idea of the container and the same
for the port and then here I'm using the
declarative and I what I'm saying is
like before executing this test I'll
start up the Redis container populate
with books dot DS on that book spudgy's
on is this is no come back to the
persistence Testament wanted to do that
this book position is this file which is
just in Redis this is a hashmap what you
said the keys to have it and then the
values of our feels like the title the
hobbit number of pages to 9:30 and then
what I'm doing here is just have my book
service which will connect to this
docker container find a hobbit and then
you desert that the hobbit it's it's
already there so if I run this okay now
I need to pull well meanwhile it pulls
the readies image let me show you the
other example which is the let's just
with alkyl shift - shift yeah this for
deployment yeah ok and then for example
here there is this is another example
which we are mixing two of the supported
technologies because when you are
running with docker you have a problem
that docker are volatile when you stop
it all the data that it's there it's
rich remove it so you need to start a
container populate the schema in case of
sequel databases populate your data and
then run the test and this is what we
are doing here I'm using fly away fly
way is a tool for operating all the
operating that the scheme of the
database so what I am what's going to
happen in this test is like I'm going to
start
Oscar a sequel database when this
positive sequel databases to started I'm
going to populate it with flyweight
schema which is in DB migrations and in
this case DB migrations is it contains a
sequel database which creates the schema
Hollywood and create the table Hollywood
that film with the title on the release
text when this schema is populated then
I'm going to populate with some data
because I need some data there so in
this case I'm using the ML with these
films the title trolls and Murray State
and when all this thing has happened
then I can query the database and
validate that everything is in place and
finally of course I can do some kind of
flyweight clean which basically dropped
everything so I don't need to do DB unit
dot clean and then flyweight claiming
with clean everything it's it's remove
and if now see that this is the previous
test it's green it's it's downloaded the
red is and run if you want I can run
this test and not yeah this is starting
the Postgres sequel database creating
the schema operating with some data then
run the test and then clean everything
and it runs pretty fast I guess you've
seen that it was fast
well now let's see something that it's
more focused on micro-services
architecture which are we have tons of
service interconnected between them and
one of the things that micro-services
architectures makes you or force you
let's say is like each of the service
must be deploy or deployable
independently so you can have five
services and the setup I'm going to
deploy a new version of service C and
one of the problems is that how you can
ensure that when you deploy service c
service a will continue be able to
consume data from this new service
because you are deploying independently
you are not saying I'm the plane I'm the
point a and C you're the point C and all
the structure will reach this the truth
is that sometimes it should be easy but
it's not I mean in my experience with
micro services before using this we face
it a lot of problems of interaction of I
deploy a new service C and then service
a you start failing and why is this
service a it's failing if I found not
anything room service a and it's like
because service B it's change how he is
producing data and this is exactly what
we are going to see now the example it's
ambulance man I mean that I'm not using
any browser then we have a consumer with
version 1 which is deployed with
burdock's and then I have the producer
the consumer is the service that
consumes data from an hour service and
the provider is this the service that
exposes data to another service so
what's happened if I mean that this is
running in up and shift in this case so
I post man I do get billions brew and
then I go to the producer and said ok
give me all the information about a crew
of the crimes it returns JSON file which
is named Moonville and grew and wiki
data Wikipedia well of the crime which
is stalling stealing the moon and
finally the consumer which is that the B
lines
database is just up our upend
it's its own data so you have the name
it grew the area of influence is the
world and then it appends everything
that comes from the provider and that's
great the problem is what's happen if I
update producer to be 1.1 and it remove
the wiki then it might work or not
depending on consumer if consumer
doesn't doesn't is not implemented
taking care that one field can be remove
then it will fail and this is exactly
what contract tests are canta mean that
contract contract at the end it's an
agreement between consumers and pro and
producers on how the API should look
like so I mean it's like in real life
contract is something that you that two
parties agrees on that but needs to be
followed and contract tests at the
Burien provides a mechanism to
explicitly believe I that the component
meets the contract and when I said the
company the company I mean the consumer
and the provider so with the contract
test you verify that the consumer meets
the contract that have an agreement and
the provider also meets the contract
that has agreed with the consumer let's
see how it works from the consumer side
in the consumer side here you need to
generate a contract using a test and you
have the consumer test which is the
responsible of generating generating the
contract then instead of using the real
service B you are using an ax stop
server this is done because you don't
want you don't want to boot up the real
service all the time because as we said
with service virtualization this end up
with with an end-to-end test then what
we need to use this here is the the
client class this is the gateway class
use it to communicate with the provider
so it were easy the only thing that you
need to start doing is just I'm the
gateway I know that I want to get
although kind of grew so I'm going to do
this call to stop server Anna stop
server will return the JSON that has
image own expectations
finally the consumer test will generate
a contract and this is the contract the
real contract that both the real
provider and the real consumer needs to
follow note is that this is really we
said it's almost the same as service
virtualization because you're using a
stop server which has some expectations
and then you generate a contract and
then this contract must be somehow move
to a repository so it can be shared with
the provider because this is the
consumer side you generate the contract
and this content must be consumed by
provider to validate that everything is
fine so what's happening the providers
side basically we have a a test class
which replace the request against a real
service a real provider right so whether
it's happen is it reads the contract and
start to replay all the requests and
response that were stored inside that
contract and this generates a file then
this file is compared with the contract
file and if this real file of the
provider meets the expectations of the
contract everything is green then it
means that my cons I can deploy provider
safely because my consumer my current
consumer will be able to consume its own
data if it fails it works me to stop the
point in this service and there are
several or actually they are like to
consumer like to contractors framework
one is packed and the other one is a
spring cloud contract
spring lock contracts were speedy well
with the spring and all Java projects at
the dole in case of pact but it's a
foundation and it means that there is an
external
that generates in a specification and
this means that it integrates with
several languages of the jvm languages
Scala groovy job of course Ruby Python
go the net swift and yes so it means
that if you are using a polyglot
approach on your micro-services
architecture you just choose the same
tool for all the for all the contract s
and finally it has some thing called
pack broker which is like a hub where
you can store contracts and consume
there it's consumed from there so you
don't need to store them on for example
on a shared folder or not get rip or
whatever you can use this hop and
finally it integrates with our killer
and we discuss our killing our groans it
means that you can use all the things
that we have a spline about or Killian
in the component as in for persistence
for cube but also for pact in the
consumer side it's I mean that since
wait I'm going to just go to the demo
because we're going to see this and it's
faster not is that now I'm going to I
know that you're not watching
I'm a thirty minute
if they have my beelines crimes
application deployed on on an open shift
and if I can open the project which is
the villains let's just start with this
surprise
this is the test right then this is the
test
I'm run I need to run with a pillion and
then I put here the stop server this is
the provider server which is the crimes
and what I need to do is just defining
in the consumer side remember that I
said you need to define the expectations
of the contract so you put your annotate
that you want to define contract for the
provider crimes and for the consumer
abilities because at the very end you
can have the same consumer consume data
from several providers so you need to
specify which provide room which
consumer your your defining then you
define the contract in this yeah it's
the contract and expectation which is
basically said upper upper receiving
grew billion to get all crimes / crimes
as well through method get' will respond
with the status 200 and the body
responds this response and these are
really important because in this in this
in this case what I'm just defining how
my API looks like also notice that part
will generate the documentation with
this so you will have a documentation of
your API as well so everything that is
not defined in the contract then it's
it's like a free field so you need to be
really curious on defining this and then
you just need to run your test as
usually saying that you want to generate
a contract for the crimes provider if I
run now
takes didn't now okay and now notice
that it says green and it said okay for
your incoming your assertion tit okay
notice that here I'm asserting that the
name of the crimes are and the wiki our
Moon and the wiki moon and the Times
Square Jumbotron is the Times Square
Jumbotron
so I'm asserting that that the
expectations that I've recorded here are
currently met and if you check on on
built parks you see here a JSON and this
JSON is the real the real contract this
is the contract this is something that
this JSON will be used by park to
generate the documentation for you and
notice that it says for the provider
crimes and the consumer B lines each
there is these interactions and must
follow this this is the one the thing
that is going to be used on the provider
side what's happening the provider side
is the crime service I need to do
something different which is basically
says I want to use our Killian I'm
crimes and I need to check where are my
contracts of store because contracts are
generated on the consumer side in this
case I'm using I'm using the contracts
folder which is like a dist is good for
for demos but not for production in
production probably you will use PAC
broker or even for example deed server
or whatever and then what the only thing
that I do is just say I define target
target is a class provided by our
Killian and says author that this target
with the URL of the crime service
because this is the provider that if
satisfied the contract so what's going
to happen is like read the contract so
it's reading
with this file and said okay I need to
go to a slash crime to slash guru so
it's going to connect to this URL and
then in this URL we said I'm expecting
the response and then it will assert if
the response is this one is the response
is this one then you can deploy provider
safely if not then you're going to break
something and then if I run the crimes
again I mean that now it's starting the
Pertex service and then when it started
it will start replaying all the hrickos
and response you can see that now here
it's saying I'm verifying the pact
between Billings and crimes
groobie line to plat all crimes return
the response which has the status code
200 and says ok yes
yeah I did this interaction I'd returned
and has a matching bali and says yes it
has a matching body so your test is
green what's happened product for
example is if I go to crimes to crime
and I said look I don't want to what
wiki now said I'm going to remove wiki
from from this poses a wiki now it's not
serialize it to the output if I run
again the project
you have a feller and says basically we
check here we're like here is all the
difference different and said here has a
status code 200 okay but matching bodies
fell because I expected expecting the
weekly field but there is no wiki felt
so before deploying your provider you
get the failure not when you have
deployed to production and then consumer
start failing because of this missing
field
fix it I think that you all need to move
the screen right didn't on the other it
didn't yeah it's everything go - okay
we're skipping questions I guess on that
yeah deployment tests yes sorry before I
got funding confused with this one I'm
supposed to be doing this one and
skipped it on my slides um yeah I can
keep actually it can keep employment
tests obviously when we're generating
all our applications we need to make
sure that you play perfectly well in the
containers that were intending to deploy
them on and this is where we kind of sew
in with fabricate so fabricate is the
interface let's say - OpenShift
and kubernetes and so if I have a
kubernetes cluster and I will shift
cluster I'm gonna be using fabricate to
make the deployment and our Killian is
our enabler as such yeah basically what
what fabricate does is usually when you
you I mean that when you start in the
micro services well you said okay I'm
going to the ploidies to kubernetes or
openshift
and you start generating a lot of you
know kubernetes but EML files each one
for each of the service and you end up
by having a lot of copy place between
all the services because at the end you
always use more or less the same
specific the same configuration for all
the services so what does fabricate is
does is says to you look don't spend
time on writing disk unit sgml files
because I'm going to do it for you
because I have I know what are the best
practices so I can provided you one
opinionated opinionated file for you so
you don't need to deploy need to create
it again and again for all your services
because no um yes so this is basically
the deployment test that we're going to
be running and this is with a new runner
so they are clean conditional runner
class and what we're saying is we
require cuban 80s or OpenShift for this
test if if that isn't fulfilled if it
doesn't detect the requirements on the
class path or as a service running
service then the test will fail before
it begins and if it doesn't it's going
to actually return us the URL required
to access the kubernetes hello world
deployment so that's just going to be a
no deployment of kubernetes hello world
and cube is going to enable that for us
it's basically going to ensure that the
deployment is deployed as a node in a
particular name space on our cluster
environment and then we can test against
it so we're just going to go back to a
standard unit test that makes a physical
HTTP connection to the service running
in a container and so that's the project
or the code for the project and the
project just consists of this simple
command line so it's going to be running
in maven and just running this will
actually deploy yeah this is really a
big test
I remember for in the password you
created the war file and then you take
the support file and put it in the
application server and you boot up the
plication service and you check if it
runs on or not it just you know like a
check that the war file was probably
created all your comfort zone files were
in place and if the services would then
you said ok everything is fine then we
can continue this the same but for
kubernetes and OpenShift and in this
case and notice that now it's public oh
yeah I know what's happening so let's
say you're mine no it's not
so the first test was run that was a
spring blue test so that was testing the
spring boot test works and it can create
the deployment and then the second test
we actually send the deployment to the
container there was a problem with the
security on OpenShift yeah you need to
like it before because you need to
provide the credentials to get into the
cumulus cluster but yeah this is just a
spring boot test that runs locally to
check that locally you can start this
micro-services takes some time and then
after that fabricate will generate all
your IP chief curators stuff
automatically for you
I mean that if you check the project you
will see that please all and there is no
queue Bernadette stuff anywhere because
fabricate we delegate to fabricate of
course it's opinionated but you can but
it's also customizable so you can change
everything
notice that here you see up that saying
using docker image and then I said
adding at the full service spring with
HTTP with port 8080 because we integrate
with birth text spring boot and world
fly's form so we detect the
configuration of spring bootie in this
case and said ok spring wood is running
on 8080 so I'm going to expose this port
because this is what I want and it
creates the service and sounds far and
yeah the problems it takes a bit of time
because then ya know what it's running
it needs to create the docker image I
mean that it needs to create the jar
file create the docker image build the
docker image put the jar put the this in
create the accumulators file put this
docker image inside the docker registry
of the kubernetes cluster then the poi
or send the resources file to the
cluster deploy everything and after now
now I think that it's deployed normally
things like 9 to 10 seconds to deploy to
up and shift and then I in the test what
we have is like I check in but the URL
notice that is run and there is no
followers
substance and then it takes using the
URL with rest assured we check if there
is something deployed there even is
something the plate that we said okay we
know that we are able to take our
application move it to kubernetes
cluster and it's going to start and
notice that if you check the lighting
project you see here here there they
said the lighting project I test for 4e
just and just in the very end of the of
the bill right because in this case are
killing you by the forward it does is
just create a random name of space so
you are not touching your production
environment you are in the same cluster
of production environment but not in the
same namespace which create a random REM
space the poisons everything there run
run this test and then remove this
namespace of course if you want you can
just point to the production environment
you can do it as well but yeah by
default goes create this random stuff
again it's called a test ago they
definitely go into something like
Jenkins I need to go into your
deployment pipeline you wouldn't run
this as a developer on your own box this
will be running on a Jenkins deployment
pipeline yeah and this is you know when
in this case I'm using okay HTTP and
then you get the request and notice that
you are putting the URL of the of the of
the class or or is the URL to access to
this service inside the cluster so we're
not actually testing application itself
we're just testing that we can deploy
the application and the application is
reachable on the endpoint yeah this is
demo and then yeah then and with micro
services something that is really
important is continuous delivery
going really fast to deliver something
you need to pass from delivering from
once per week to several times per day
this has a problem and is that you need
to speed up your test if you run all
your suit all the time you're not going
to be able to run several times per day
because if you want to run all the tests
or everything it takes a lot of time so
we created one tool called a smart
testing this is again a project under
our Killian umbrella which basically is
like usually when you touch on when you
modify one class this class is tested in
three or four tests directly or
indirectly of its their what is used not
all the tests so when you want to run
your tests maybe you have modified this
class and this class is tested in this
test and that's all from the wall suit
you only touch directly or indirectly
these classes in this test so what you
need to run all the tests if you know
that the modifications you have done is
just you just need to run the green ones
because the other ones you know that it
has nothing to deal with with this
production change and that's much it we
have a smart testing maybe next session
which basically to install it you just
need to run well I mean and in the
documentation page you won't see
everything but basically you just do
this call as I sell this URL and I bash
on the root of your project and you will
have smart testing installed and then
you can do something like maven clean
test mean you see a smart testing new
change it and this means that I'm
unaffected sorry
so in this thing you're saying I only
want to run tests that it has been added
in my current commit or it has been
changed in current comment or it was
they are affected by a change on a
production class so it's like saying I'm
going to filter from all my to suit too
sweet to just the new test the change in
test under ones that have a test some
change on the production classes this
has changed in recent versions you can
even create
they'll file a configuration general
file so you don't need to specify it as
a system properly and finally if you
don't want to just if you want a nasty
or you still need want to run all the
suit but order it you have the ordering
method this ordering method with it
badges like chain is saying okay I'm
going to order all my ethics test plan
execution so the first test that I'm
going to run are the new ones then the
change it wants then the fact that ones
and then the rest of the tests then
again you're running all the tests of
course so it's you still you still have
problems for speeding up your build
pipeline but yeah you can you you can
order it and again this is one way to
speed up your pipeline but there are
other sometimes you just deploy I mean
that you have your service you run all
the tests all of them passes your
contractors passes you go to production
and say yeah we are in production but
yeah you breathe environment and this
happens because production is production
and it's never easy to deploy in
production there is a dnas Duras net
different network different kind of nail
works maybe there is some users that
comes from Kenya that has some different
header in the browser that mixed
everything blows I mean and this happens
so what you need to do is test on
production and there are several
techniques the first one is that the
blue-green deployments they were really
blue in the problems basically it's like
I have this I have my service and I have
my users that connects to the blue
service so what I do is like I create my
built-in the development side then maybe
you go to QA and you provide that
everything goes as expected then you
move to staging maybe your problem
manager says yes is what we want and
then we move to the cluster but not in
directly on the I mean in the production
cluster but not
the green yet you put it in the cluster
and then you say okay I'm going to start
doing some kind of a smoke testing to
believe it I'm really not I'm not going
to break anything when you are we are
when you are done with this you move to
Green in Mirman and you change the route
so instead of you so then the users
instead of using the blue one
let's start using the green one and this
the way of how you can test some
production so you just test on the same
cluster then you move to you move to
green and then it's really important to
monitor your application because this
change you can still break something and
then you said okay I'm going to monitor
and if there is any failure that's what
I need to do is just switch back really
fast to the blue because you are not
under plying blue you're just changing
the road so you change the road to green
if everything is fine okay
if you sing your monitor that there is a
lot of fillers then just come back to
blue pretty quickly in case of failures
change to bull but do you all the
techniques the one is currently release
and do you know why it's called canary
release anyone knows Alban know who
don't know why it's called canary
release okay it's called canary release
because in the past in the coal mines
there were some dangerous gases right
toxic gases that humans died after two
minutes of birthing it okay and the
cannery just dies after five seconds so
what they said is that okay I went with
this Henry I will put it on the mine and
if in five seconds I see that the canary
died then I need to run out really
quickly so it's all about killing
Canaries this is why it's called can
really is because you are doing
something exactly the same we've got the
green service with all the people there
and then you have one change this change
was to be a staging and then you put
this change on your blue environment or
in your current environment right
but only an a small part of the users
are able to connect to this to this
change let's say for example five
percent of the users can reach this new
functionality and you start monitoring
if there is no failure everything works
as expected during you increase to ten
percent if there is no more failures to
50 percent 80 percent until you get all
the users with the new future so instead
of just saying us like blue green that
you deploy everything at once it's all
the users see the changes you do it this
step-by-step I'm finally there is dark
launchers and basically the ranch's is
like more or less the same but the
change is used by internal users so
you've got this is really useful for
example Facebook well their own
employees uses Facebook internally so
when you connect from your internal
network from the from your workstation
you you start testing the new features
then someone monitor eyes all these
changes I mean when they say yeah we are
good then they make this public to all
the users it's also happened is if with
Facebook Messenger they did something
similar which they create some kind of
bought on all your pages without knowing
before they so they have Facebook
message essentially implemented but you
didn't know it and they send you the
JavaScript code and they start sending
message
dummy message to their systems so when
you were in Facebook they were doing
this kind of things when they saw that
everything was working fine
they just enabled the Java enabled it
change the flag on the JavaScript and
then you see all load there is Facebook
Messenger but you have it there for
maybe two weeks just this is what I do
and if you want to see a really quick
demo about this
that fancy notebook you were bidding on
on eBay that he didn't get could have
just been them swapping the services
well I'm going to connect okay this is
my to services I have blue service and
green service and this is the URL to
access to this service so if I go here
and I do call this one I got hello from
blue and now I just have hello from blue
hello from Lu all the time because I
just wrote to blue service but what
happens if I said okay now I deploy it
green
I already deploy it and I want to change
to green I just need to do something
releasing it is like oh she said root
backends blue zero ring hundred percent
with just this simple call I'm just
going to green now I have green all the
time
so if it now said oh look I break
something I can go here I can put here
zero and then handle it and then I have
a have blue again and if I said okay but
now I want to just put 50 percent of
users to blue and 15 - great
in then I'm gonna start doing coal now
with law now its blow now it's green now
it's blue now it's law now it's rain so
it's really easy to implement with up
and shift this blue green canary royce
so only you can finish here I think I
said summary basically lessons learned
we're taking something that we know
already which is unit testing and
component testing and we're just taking
everything that we've applied to
monolith applications and adding just a
few bells and whistles a few different
kind of tests to enable a microservices
so we're not getting rid of anything
we're just adding stuff we're not having
to learn new frameworks as such we're
staying within within a unit obviously
if you've never touched our Killian
before then you're going to need to read
documentation mark you know but it's
just building upon something you know
already so that process can be very very
quick anything allowed so we've gone
through and we've covered all our tests
and basically what I've just said we're
just adding we're appending stuff to our
environment and adding a new few new
scenarios so we're gonna be doing more
integration testing with services
running in the background and we're
going to be using it in cube to run
those services for us and we still
continue to test as a team so rather
than just developers now we're involving
everybody so it's you know the plastic
DevOps scenario where everything is now
part of the enterprise and we're not
going to just sit in a dark room and not
talk to anybody anymore we need to talk
to everybody and everyone needs to be
involved in that process especially
because we're going to be testing
deployments
yes secure state
yeah sorry yeah each stage so don't go
off and try and do everything at the
same time it will progressively each
stage you're going to be physically
testing that what you've done works
within your environment and you're going
to be involved in the whole team in that
environment we want to automate
everything so everything we've presented
today can be involved in some kind of
pipeline so we have the classic Jenkins
pipeline everyone knows and understands
Jenkins very very well because we're not
stepping outside of that box of how we
run things
we're staying within usually a maven
environment or a known environment that
we can deploy on Jenkins it's very very
easy to automate everything we've done
today I have no idea what that's saying
is of all the incidents I can read it
for you but yeah obviously things change
the future is never fixed we haven't
gone too far outside of the box on what
micro services are so we presented what
we thought micro service was in its
basic elements things will change the
things we've laid out and things we
presented today and the stuff we
actually have in the book are going to
be stable for a very very long time it's
a principle more than anything else but
be prepared obviously to update things
and ready for change we've provided
links this is all been video this is
live so we can go back and laugh at each
other later and hopefully you can laugh
with us to sit with us not as we're also
be publishing the slides the video will
be uploaded to YouTube and hopefully
you've enjoyed the talk and the things
we've presented today thank you Alex
we have exactly two minutes and 30
seconds for questions I would suggest if
you know you have questions there's a
big subject there's a lot of stuff in
there a lot of information to take in go
back get the information come back and
talk to us tweet to us we'll get back to
you
and we can start some private
conversations you'll find me on the
Apache Tommy project so if you join the
userlist dev list of Apache Tommy I
can't answer all the questions there
Alex is it know from home yeah thanks
very much for time people thank you
enjoy DevOps</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>