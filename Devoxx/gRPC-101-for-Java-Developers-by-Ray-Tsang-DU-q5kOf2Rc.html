<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>gRPC 101 for Java Developers by Ray Tsang | Coder Coacher - Coaching Coders</title><meta content="gRPC 101 for Java Developers by Ray Tsang - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>gRPC 101 for Java Developers by Ray Tsang</b></h2><h5 class="post__date">2017-04-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/DU-q5kOf2Rc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you
and my name is Ray I'm going to talk a
little bit about G RPC today and I'm a
developer advocate for the Google cloud
platform
I actually live in New York but I grew
up in LA and my primary job is to bring
some of our latest and greatest
technology that Google has to offer to
developers over the world but in
addition to that I also like to hear
your feedback in your experiences in
using my twitter handle at Saturn ISM
that is the probably having the fastest
fastest interrupt to getting my
attention and I will be able to respond
to you to your questions or your
feedbacks and aside from technology I
love to travel I love to travel
everywhere globally for falling for work
and I like to take photos and since one
of the photos I took before in northern
China I believe where I was actually
hiking in the desert for four hours by
myself in to find an oasis somebody told
me I can stay as a backpacker I can stay
in the Oasis for free if I watch we just
find it in the desert with a compass and
they said you have to walk there by
yourself for four hours and so I did
anyone here hike in the desert before
anyone no there's always a few by
yourself
haha yeah yeah it's a I was incredibly
young and stupid so I decided to oh okay
so just get the bottle of water in let's
go and two hours into it I look back
there's nothing behind me there's
nothing in front of me
it's just that and when somebody tells
you to walk in the desert for four hours
for a certain direction
you don't just veer off left and right
right if there's a sand dune
you don't go around it you go straight
over it because if you just off by a
degree like I don't know what I'm going
to be after it for hours and if you
never hiked in desert it's almost like a
walk in the beach except a lot more and
you just don't see the end and in there
are defendu so every time you take a
step in what happens your your foot
sinks a little bit and you have to pull
yourself out and it's incredibly hard
and difficult you know it's hot and
humid and
religion reminded me of writing a
traditional j2ee apps in the I'm sorry
but now it's seriously like that's how
it was and and eventually you know I saw
the oysters and what's beautiful it was
beautiful it was absolutely incredible
view and not happy I got there and
that's kind of how I see what I'm doing
for these couple things is I want to
bring you you know the people in the
audience I want to airdrop you with the
helicopter into the oyster so you don't
have to go through all the troubles
yourself and hopefully you're going to
learn a lot about gr PC today so you can
give it a try when you go home as well
and why am I talking about gr PC well
first of all there's this trend of
moving towards micro services right or
if you're building applications you
build service-oriented applications in
the back and in the past writing we're
continuing to do that today and if you
already have a monolith or if you are
trying to build micro services
architecture applications right one of
the things that you're going to realize
is a hope you know know like all these
little components I'm going to be
breaking them down into smaller pieces
but there are consequences they are
going to be cost associated with doing
that the very obvious one is of course
that there's DevOps you need to maintain
these services you need to run them keep
them up and running you need to upgrade
them in maintaining the versions of them
right just like a dedicated application
now you just have you're going to have
more of it right you have to remember
that it's not be more of these things
that you have to do rather than less but
fortunately we have tooling to help us
to manage the instances of micro
services today that we couldn't do
before right through containerization
through container orchestration through
the two links like kubernetes now we can
actually manage hundreds thousands of
instances of your application but one of
the things that people don't usually
think about is how do these services
communicate with each other in many
cases your micro services are going to
be running the back end and they're
going to be going to be talking to each
other rather than talking from the front
end right so some requests coming from
the front hand and goes through the very
first back in and from that back end is
going to be talking to other services in
the back end again and our default
choice has been rest
right Depot choice 10 years ago has been
soap right but we talked about so being
too slow and all that but rest is
getting some similar feedback as well so
the thing I wanted to do is to just
raise awareness to let you know that we
have an option we have a really good
option today to actually to this very
efficiently with binary protocol with
RPC RPC wait a second that sounds very
familiar
I've been doing RPC many many years ago
I thought that's not a thing anymore
right how many people here has done
CORBA hahahaha yes do you like it
me yeah some people do right I'll show
you I'll show you a little example I was
preparing for this table like how do I
do core body for so I saw this really
good website it's a really really good
tutorial awesome tutorial if I ever need
to do core by again this is the tutorial
I will go to and you know I started
operating that ok yeah I remember this I
need a IDL interface definition language
of some sort because we need a simple
language to define our service so that
it can be you know so we can generate
code for other languages that's what
they have done really well before and
then you can generate a stop of course
and the stop is something you can just
inherit or extend and then you can
implement the actual implementation of
the service without having to write a
lot of boilerplate code and then once I
oh this is great this is awesome and I
went down to the client so how do i code
this thing that adds two numbers
together and then that's where I got
into trouble like oh no I remember this
now I got you say after your quest
broker of some sort I need to do
narrowing and oh that I have no idea
what these things do anymore right and
and that's why sometimes RPC has a
really bad rap because it used to be
very complicated to do to make it so
that is interoperable but not only that
we we have easier way to do this in Java
right which are MI and anyone using our
mi today still yeah yeah very good
so I love are mi the only thing there is
that it's not as interoperable right you
can only deal with Java clients
potentially but if you only deal with
our world that
perfectly fine really easy to do it
really easy to write but you know
remember everybody good remember ten
years ago when people said what a second
we need all the services to be
interoperable because Java is not the
only application running in the
environment so then what do we do we
found the most interest and art which is
text right which essentially was XML and
then we created message it's a running
smell and then we had ways to define the
services around that with soap in with
those and all that and and and then I
think something happened people complain
about them being so slow and and people
moved on but if you think about it we're
not so far away from where we are ten
years ago because now we are dealing
with rice that is still text-based
protocol right to generate client what
do we do we got rid of the widow but we
still are creating swagger documents so
you can actually have a good definition
of what the service look like right so
we haven't really done things not that
much differently and also there are
things in rest that just you cannot
express nicely a via rest protocol
because rest is really just you know CR
UD but yet to put the patch right the
delete but if you have a business
operation that you want to implement
right it will be something like
withdrawal or how do you implement
withdraw operation in rest you need
potentially to patch two different
resources how do you actually do that
then we can actually hack around this
HTTP restful protocol to implement
operations right so why RPC well to me
RPC is efficient because it's binary and
it strongly type it is strongly typed as
Java developer I mean strongly type
things I don't want to recreate my
client every single time and it can only
be great though if it's simply to use
write extremely simple to use and
interoperable across multiple languages
so I Google we use stubby okay that's
our internal project code stubby this is
what we use internally for all of our
back-end services we do about we we make
10 to the 10 RPC requests per second via
stubby
in our data centers this is mind-blowing
number I think of the 10 now if you just
think about this being a text protocol
or just even taking one bite more than
necessary that's 10 to the 10 more bytes
per second that we have to transfer over
the place right so somebody was made to
be very efficient and that's being used
internally by Google so what happened is
if I record it correctly right another
company called square they were looking
into a new RPC solution Google is
looking to open-source our PC or stubby
as well and so the two companies joining
forces to create the GRP see so this is
the open source project that is based on
the ideas and implementations of stubby
on the patch and this is basically the
new generation of the RPC framework that
is fully open source now the trick here
is that the G in G RPC does not stand
for Google all right just remember that
it is actually a recursive acronym GRP C
stands for T RPC remote procedure code
framework okay so it is fully open
source it's on github and anybody can
contribute and part of the reason one
here is I want people to you know help
and provide feedback and contribute back
to our repository as well it is simple
to use which we will see in a second it
is designed to be performing as scalable
and also interoperable in the way that G
RPC achieve this is by basing itself on
standard technologies and standard
protocols and most prominently the
transport layer is being is using HTTP
to write anyone here actually use HTTP
to already quite a few in your project
or on the browser yeah yeah on the
project Oh fantastic right so you here
you think your RPC Oh fantastic well
then yeah that's awesome
so HTTP - why is that important well
first of all HTTP - is also a binary
protocol right rather than being able to
tell net into anyone down this hill net
into port 80 and say get slash write
enter and you're actually able to get a
text response with HTTP 2 which is
binary so oh they get the put and all
those methods are going to be encoding
binary which is like one byte or so the
headers are being compressed as well if
you ever look into the
the the actual content payload alpha
HTTP request you're going to see there's
tons of headers and sometimes if your
message payload is slow your header size
is actually going to be bigger than the
message size right so HTTP 2 actually
can compress the headers for you so that
you can have efficient communication
between the server and client now
another really really nice thing about
your RPC is it can it basing streaming
at the first-class citizen now the way
that we had to do this in HTTP 1 is what
we kind of have to hack around the
protocol a little bit to get that
streaming like behavior right when 3v2
streaming is native it's just you can
multiplex multiple strings in a single
connection
ok that's again something that used to
be one cannot do in HTTP 1 you have to
open up multiple connections to do
multiple things in HTTP to a single
connection can multiplex multiple
strings that's coming from the server to
the client or even the other direction
from the client to the server and by
designate bi-directionally from the
client to the server in server to the
client and just to compare and show you
what that feels like
here's the demo page with HTTP 2 and it
kind of loads the HTTP 1 image tile so
all of these images are small small
tiles it's loading I don't know how many
tiles into compose this image so it's
making these non catchable requests to
be HDB 1 and if you run it down HTTP 2
if I ought to refresh this a little bit
to have the connection setup right here
is the HTTP one and if I run the test
again it's generally a lot faster on
HTTP 2 because of the binary protocol to
streaming in fact if you your server
knows what the client needs you can
actually string that data to the client
straightforwardly before the client even
requested so you can also eliminate some
extra hops there ok so let's see what
that feels like and the issues of
comparison the chart it's a nice chart
somebody did they wrote about on this
write a comparison between G RPC and you
know HTTP and JSON right now I don't
feel this is a fair comparison to be
honest because primary protocols of cool
needs to be faster than rest right then
text once right so it's obviously that's
gonna be faster but I think what's going
to be more interesting here is press CPU
per CPU throughput is many many folds
over a text-based throughput right and
this is important why is that what for
two things number one if you're running
in a cloud native environment your
resources are going to be CPU counts and
you want to be as efficient as you can
proceed to you as a cloud provider I
want you to use your CPUs as efficiently
as possible right rather than saying
just go buy more CPUs no no right make
your app more efficient so you can use
four CPUs now the other thing though is
that on mobile devices they don't have
as much CPU power and your battery is
going to be a concern your gr PC will be
able to be able to work on the mobile
device as well and also be more
efficient dealing with those situations
and look at the languages that we
support what you are PC here is just a
highlight of the primary languages C++
objective-c Java goes you CH are below
that but if you focus on three of them
Objective C C sharp in Java these are
the primary languages that people use to
develop mobile applications right so
it's fully supported on mobile and
should definitely keep it a try so with
that being said I'm done with my site
thank you very much
let's get in now so let's see it let's
see what it feels like okay so now the
assuming our people haven't seen this
ready so I have a bootstrap project here
I'm going to do two things I got some
time here is I'm going to do a few
things the first thing I'm going to do
is a simple server right rather than
showing you how to write a restful
server right this easily down I want to
show you how to write a G RPC server and
then you can really compare and feel
what this is like
now before I begin up if I write to the
server the first thing I need to do is
to create the IDL the interface
definition language and the IDL 4G RPC
is based on put about four three so the
first thing I need to do is to have this
profile which is one
editing right now this profile okay I
need to set the syntax to 403 okay
very first thing I need to do I need to
set this profile to using the photo
three syntax then I can
besides what package that this profile
in the content of this profile belongs
to write just like Java you we have
packages same thing here I can say G RPC
GTR PC and now let's use it out okay so
that's my package so whatever I generate
from here is going to be generated into
that package in a now we have generator
specific options so G RPC to compile the
ideal into the actual stops you need to
run it through a generator okay it is a
polo chain compiler and the compiler can
taking options for different languages
you can have different options to set so
for example for Java by default it's
going to generate all of the generally
starts in the messages into a single
giant Java file okay if you don't like
that that's okay you can say Java
multiple files is equal to true what I
will do is to tell the polo chain
compiler that rather than generating
everything into a single giant file
which I personally don't like generate
each individual class into their own
files so I can see this clearly okay and
once you have this preset up then you
can start writing the service in the
payload what the first thing that we
need to write is the actual payload and
in G RPC you've got to define the
request ain't got to define the
responses right and rather than running
a class before we need to use the
keyword message and with message we can
say this is a HelloWorld request and
that will correspond to a troll a POJO
actually a POJO
code hello requests with attributes in
properties inside then I can in this
message I can define what attributes I
want to use so for example I can have a
first name
okay and strongly typed so every field
first name for example will have a type
but in addition to that there's also a
tag a tag is the binary representation
of this field in the payload ok this is
important in rest in JSON for example we
use the actual string first name to
identify this field in G RPC and photo
buffer everything is binary so we need a
specific tag a specific number to
represent this field okay so if the
number is less than 16 that means it
will just take a few bites right
bite actually if the number is greater
not a new experience so the key here is
if there is frequently used field right
now you just know it's going to be used
everywhere a lot dangers use lower
number tags because then you're gone get
more a little bit more efficiency all of
it right so I can do that I can say a
last name it goes to - I think I have
four in 64 a juice equals 3 now that I
live that long but that's ok and then we
can actually do emails in Java we have
in a my enumeration right so for example
you can define you know with selected
choices I can say sentiment this is how
good you are feeling right now I feel
pretty happy I don't know about you but
I'm feeling pretty happy so that's a
zero right and you could be a little
sleepy by now I hope now so sleepy is
equal to 1 and at the end of this talk
you could be extremely angry at me for
being here so I'm going to say angry is
equal to 2 okay
and once you have defined the enum you
can say sentiment sentiment is equal to
4 yeah not bad if you have a list of
things like an ArrayList or some kind of
thing that you have just a list right
what you can do is rather than saying
string so you cannot do this but if you
want to define little is you say
repeated string hobbies for example and
you can do that and I will generate a
list in the in the actual Java file in
finally we can also do strongly typed
maps so you can have strongly typed key
and strongly type value this is so nice
and I'm going called this bag of tricks
okay in live coding is definitely not
one of my packs of tricks here so I hope
everything work alright so as you can
see once you have to define this the
generated things will be interoperable
across multiple languages and if the
language is type type safe right this
will actually generate the type safe
payloads for you as well okay so let's
go ahead and define the response hello
response I'm going to say greeting is
equal to 1 that's the response I'm going
to get ok and once I have the request
and response then I can actually define
the service
so service it's just with the keyword
service I can say greeting service for
example in this service I can define my
operations and the keyword there to use
is RPC so for example I can say RPC
operation called greeting is going to
taking a request and returns a response
ok and not to pretty much it if I need
to take advantage of streaming so for
example if this is taking a streamed
matrix right if you are taking IOT
devices and IOT devices are streaming
data to the server well we are streaming
the request into the service so all
introduced to a string keyword and this
becomes a client to server side
streaming service it will generate the
stuff for you that can take in this
string now if you need to string data
from the server to the client so for
example you said I don't know like the
previous talk talks about reactive
programming right you say hey just give
me like 20 thousand features of Pi
continuously what did you eat well you
can just say stream here if you're
building a chat application where you
need bi-directional streaming is just a
string to both ends and that's it okay
which I'll show you how to build after
this basic demo phrase okay so that's it
that's how you define the service and
then what you need to do is to be able
to generate this stuff okay so I have
the ideal but using then compile this
into you in the translating from ideal
to the Java code and to do that in the
past what you needed to do was to figure
out what type of learning system that
you're running on go find the right
version of the protojet compiler and
then run this long complicated command
line put out see something I and then
blah blah blah and I generate the Java
code to the right directory I didn't
like that at all
that was I was in the past right so now
all you need to do is potentially go to
get up and let's go to gr PC and your PC
Java okay
this is a github repository with older
code here and if i zoom in a little bit
first of all we need to do is to define
the dependency so let's do that so
dependencies
okay and then this is magic right
how many people here use maven by the
way okay oh wow material zero Gradle oh
it's almost half of hat that's cool
so I'm sorry if you're using maven this
is going to be looking like this the
entire block if you're using great oh
it's going to be looking like that
instead so depending on what you like to
use anyone using in you just want to see
yeah
there's always a few there's a waste
view I don't know if it's a ant module
for this to be honest but yeah let's
stick with maven great Oh for now and
let's see so all I need to do is to add
this beaut block here what this is
actually doing is to actually figure out
what operating system you're using and
then downloading the actual policy
compiler for your operating system for
your architecture and then hook it up
into the faces of your maven build so
that when you're doing the maven compile
made them package it's actually going to
generate the stubby this up for you okay
so let's do that so let me do a Klingon
package oh um make sure this is new
right okay so I'm done with that
Klingon package zooming and then in
target Yahoo generated source right so
there's the source and there's put a
buff and I can see to your PC Java I can
go all the way into the package and
here's my tree RPC service right now I
can also find the generated Jabbar
payload so it's also in G RPC so we come
example G RPC and here at the payload
that you can use now remember I set the
option to generate them into individual
Java file so this is why it looks like
if you don't have that option everything
which is being one single Java file okay
good so far and now we can go ahead and
implement the stop so the first thing we
need to do is to create a new class
right so I can say greeting service info
let's now add it to the repo and gonzo
Ming here a little bit the stop is
already generated for you all you have
to do is to expand it and it is called
greeting service your PC info base so
this is the base class you have to
extend and once you extend it all you
need to do is to overwrite the GRP
co-operate
that you have defined now here's the
interesting part and actually some of
the things that's really important as
you go into this world of gr PC for Java
look at the signature
just pay attention to the signature what
we define what what we call a unitary
method unary operation what that means
is I'll give you one request you give me
one response now look at the signature
it looks a little bit different one from
what I expect right if I'm doing a unary
object request in Java what do we do
usually we do public hello response
right greeting and in hello requests
requests but that is not what's being
generating okay what's being generated
it's actually I hate to say this but it
is somewhat reactive it is actually
reactive asynchronous interface right
when you look at it you have an
operation that tasting the requests but
because it's a synchronous operation by
default everything on the server side
into RPC is implemented as a synchronous
operation by default okay whether you
want to block or not is the decision of
the client this is important the server
is always designed to be a synchronous
and scalable like that it's up to the
client to decide whether they want to
block or now so in order for me to get
the response back to the client I need
to code the response observer okay so
what I can do for example is for me to
rather than sit return I can say
response observer and check out the
interface here it is reactive right
because if you look at reactive strings
or reactive Java you actually see very
similar kovÃ¡cs
there's um next that's where you send
the data from the server to the client
or vice versa and then when you're done
you call uncompleted if you have an
exception youko
um arrow okay very straightforward just
that they didn't name it reactive you
know observer or whatever they code they
made their own it's called stream
observer so I can say observer
I'll next and I can construct the
response now another thing that you're
going to notice in G RPC is everything
generated uses the buter pattern okay so
everything that you operate with G RPC
uses pewters okay so here I need to
create a new response rather than saying
you hello response I need to use the
pewter and I can say Butte okay and then
I can set the greeting and I can get the
content from the request and I can say
get first name and pause let me see them
going to say hello in the front okay
hello and then I can also just print
this out because we generate the two
string for you so you can easily kind of
debug what's actually in the package
okay now we don't I say all next and the
server is like okay I'm done
well not quite because when you say all
next which is send one payload to the
client but the string is still open this
request it's not completed yet because
this is an intranet interface what you
have to do explicitly is to go
uncompleted you have to code this if you
don't call this even though in the
definition we said it's only going to
respond with one payload but because
it's an in synchronous interface the
client watchu aliy keep the connection
open until uncompleted is called okay
it's very possible for you to call on
next multiple times in your universe
response but you don't want to do that
it's going to show you a runtime
exception so you don't want do that but
it's very possible to make that mistake
in the API okay so that's how we
implement this service and now we have
to implement a server okay so the server
is what we need to kind of create
ourselves to bootstrap the Deportes and
then to respond to requests on our port
right so rather than the point is into
your existing in a tomcat agility
container we actually have to use our
own implementation of the server which
uses Neddie underneath the thing and
that can actually deal with the HTTP 2
protocol it's not something that can be
easily done today with the increasing
containers right so now I have to go
back to that core bar code to figure out
wanting to write here that was kidding
though so so if you write the server
it's pretty straightforward all I need
to do is to use the buter everything in
G RPC uses viewers
I say server buter let me listen on port
8080 okay and go ahead and boot and
that's it okay and well well there you
go and then let me assign this to a
variable of some sort what is going on
here variable gimme gimme the variable
no there we go I'll click on this thing
said all right introduce variable there
we go
server okay now when you're creating
this new service server you also have to
add or register the service here so that
you register basically the handler to
respond to this tree RPC call right so I
can do add service and new greeting
server simple right so you can you know
do your dependency injection however you
want right create this instance of the
service and then you just pass it into
this add servers in your dump now as
those registered and then you can go
service start this why should we start
listening on port 8080 right and then
you can wait so because it's running the
background thread so if you don't wait
for it your main processes use going to
quit and your server which is died
immediately and you don't want that to
happen so you gotta wait for termination
okay so that is the server that's it
that's let's try to run it how many
people think this will work
oh wow wow thank you oh yeah thank you
one person think this is going to work
that's great thank you so much so let's
see so I got the server running I'm
gonna do a clean so I'm going to execute
this main class see I love Java because
it's type safe I'm pretty sure I'm not
going to get a runtime exception here
but notice that you're working this is
actually working just so you know is be
working because I didn't print anything
else on the server startup so this is
actually running as a daemon it's just
waiting for connections okay cool so
let's see how what the client looks like
so if I go to the client here I'm going
to use a very simple coin here oh this
is going to do is to make the connection
to the server code the servers give you
the payload and get the request back and
when I print it out so how do we do that
in rest or if you spring right user rest
template or if you're using Java
maybe straight up just URL connections
well in G RPC because we're using HTTP
to behind the scenes it
we have some abstraction layers in
between we don't want you to deal with
the transport directly so we hide
everything all the complexity behind the
things into a channel so to be a channel
to get a channel to connect to the
service that we just created
guess what do we use we use the pewter
so we can use the manage channel pewter
full address so I'm going to connect to
the local host whoa nada
and on port 8080 right and I can set
viewed now because I mean a development
environment I need to use plain text now
if it I think oh the job app developer
has knows dealing with SSL sucks in Java
so I'm not going to deal with that right
now somebody's going to use plain text
for now okay and if you look this in in
more detail on how you can actually view
the channel there are a few things you
the channel can actually manage the load
balancing for you this is client-side
load balancing okay so you can have a
load balancer factory where you can
decide on the load balancing strategy so
if you just want to do run Robin you can
just use to send our simple round-robin
strategy that we already provided to you
however you need to know where all of
the services are if you have ping
instances where are those IP addresses
what to do that you need to implement a
nem'ro's over so this is given a logical
name it's job is to resolve multiple
actual IP addresses for the server so
that the channel can be side and know
where to connect to if there's a failure
it's going to move on to the next one
and try right and actually have a open
source code on this where I actually
connected the name Reese over with
Eureka so if you are using Rica for
discovery right you can actually use
Eureka to look up the logical name get
back to client of the server IP
addresses list and you can convert into
whatever dodgy RPC expects and then now
we have client side load balancing G RPC
okay now once we have this I need to
there's something wrong with my IntelliJ
but I'm going to click on this every day
now so introduced I'm gonna say Channel
right here okay once we have established
this connection or this value is
defining what that connection should
look like what you need to then do is to
give this connection to the stop okay
to do that I can just look up the
Trinity code gr PC service and then
check this out and then we can generate
and create the instances of the clients
I stopped and if you look at the client
sites up carefully it gives you three
options this is nice
remember what I said about the service
on the server side everything on the
server side is asynchronous right but
it's up to the client to decide whether
they want to block or not
so here the client has options you can
create a fully async stop which you
listen to the stream of zebra Kobach or
you can use a future stop which you can
use the future to get back and wait for
the result or you can use a blocking
stop then you just block the call until
the data screen returned so I'm going to
use the blocking stop for now okay and I
should do it
there we go that works and I'll call it
stop and I can make the call so I can
say stop dot greeting everything is
generated for me I never have to write
client libraries ever again how awesome
is that how many people here write your
own client libraries to talk with
restful services yeah yeah quite a few
yeah did you ever miss the field or make
a typo not here not the type the types
are going to be opening here so I can go
and create a hello not hell hello
require new buter and food ok I'll be
straightforward I can set my first name
I'm going to say I'm ray send my age and
you say I'm 18 now I can add hobby right
so everything that we put into that polo
file at least I can just add hobbies but
I like photography so let me do that and
I can also I like to travel which is
great and to set that map rather than
getting the map back you would just
generate the methods for you so we can
put an entry like live coding not very
good ok so right so now I can generate
this payload and I can make this request
and what can I then do is to get back to
response oyster what's our key oh it
doesn't like me alright so I'm going to
go here
I'm going to zoom out click on this
thing and response yeah
and I can print this out if I can only
spell print line response okay cool I
think that's it you think that's it it's
pretty straight for it's pretty easy I'm
going to do another poll how many people
think this will work
Wow even after the first try it's a
little bit more people all right fair
enough
let's try it so that's right oh well
that's from before that worked before
but I'm going to do a real one now I'm
gonna do a clean and packaged in execute
all right there's no cheating here and
there you go so they actually come into
the server right make this G RPC request
and I took a little way about this right
because I want to show you exactly what
goes on in every step but if you start
to do this you can write a new service
very very quickly and you can start
consuming it very quickly as well now if
I go to the server side remember we said
we implemented to string so all of the
things I put in here can just be
outputted on on Center out if I want you
or you can log it if you want to very
very easily okay good so far yeah well
but that was too easy
that was way too easy because it's just
a simple request response what I want to
release the show is the power of G RPC
when you actually take advantage of
streaming okay and this is cool remember
I said you can stream from server to
client client to server you can do
bi-directional so to demo demonstrate
that I will show you how to build a chat
application which you RPC and the very
first thing you need to do when you
build any G RPC application is you gotta
find a portal file okay so here I have a
chat photo okay and here I define the
service and I define the payload there's
a chat message which is what the client
sends to the server and I define a
different payload for the server to the
client just so I can differentiate
between the two easily you don't have to
do that in the NT find the service and
to make this bi-directional streaming I
just need to add the string keyword to
the request and the stream key or to
this the the response in that state now
if you
carefully here there are actually other
profiles that we created that you can
simply import these are like classes you
or packages you can import into your
java application I'll actually have the
additional profiles with well-defined
types you can just import into your
existing payload so in this case I mean
importing a time stamp type from another
proto file and then you can reference
well you can strongly type that and
reference to it in your own payload as
well and there's a range of these
different types that you can import okay
so let's go ahead and implement this
this is a vital bi-directional streaming
service and this is actually the stop
that we generate okay so the stop the
the method is called chat right and
remember how we need to send the data
back to the client from the server side
we need to use a stream observer and
this is another thing you have to watch
out for because you have to return type
of stream observer you also have the
request parameter code stream observer
and this is where I get lost
sometimes right this is be important for
you to remember the thing in the request
here the observer here is what the
server needs to send to the client I got
lost here again because then the return
type is actually what the client sent to
the server okay this is a little company
intuitive you're returning an object
that is actually getting data from the
client to the server rather than sending
the data back on the server to the
client
okay that's important so I'll show you
why this is done this way so first of
all for the server to listen to the
incoming messages in a string it needs
to listen from a listener a callback
right so this remote server I'm going to
return it's literally the implementation
of that callback so that the client can
when the client sends to the server I
can listen to it right so this ring
observer this instance when the client
sends something to the server this uh
next method will be called a
and this is where I am receiving oh
sorry receiving the data from client up
to the server and when I receive a chat
message what I want to do I want to send
it to all of the existing connections
that I have so far on this particular
server so I really register all the
existing connections right in this
observer list so what i can do is i can
do i can then propagate the message to
everyone so I can open the string and I
can do for each of the existing
connections let me go ahead and send the
message to them so I'm gonna say oh I'm
next so this is opening up all the
connections that the client establish to
us I'm going to send data stream to the
client okay
and this thing I need to create a chat
message from servers I'm gonna say ms3
okay and check message from server start
new beuter i need to use pewter
everywhere here and i need to click on
this every day now that's weird
okay so I'm going to code this and
message three okay and I can set the
actual message payload to what I receive
from client okay
the first thing I need to do right so
now I receive one message I'm gonna
broadcast it to everyone who is
connected to me and then I can handle
arrows if there's a row that's coming
from the client if you call something I
do what other good job are developers do
we do nothing all right now I just
kidding don't do that for in this case I
want to remove my connection so that
they don't send me the data payload
anymore and if I'm completed I do the
same thing in return this close this
loop and close this lock I'm done and
that is a streaming service
bi-directionally I'm receiving something
I'm sending something out to everybody
else okay so far so good let's run the
server let's clean that to run this and
see if that works any compilation heroes
no okay good bi-directional streaming
done okay I'm done I don't want to show
you the other side this is harder it's
getting now you never find out if this
is actually working
would you now too
you prove this actually works what I
need to do is to implement the client
and what I have done is to create a Java
FX application wait a second is that yes
yeah that's it
so here's the JavaFX application just
package it a little bit I'll show you
what it looks like so it's nothing
special here you can say ray you can say
hello world
OOP and when you click on send nothing
happens because this is not connected to
G RPC yet okay if it actually worked and
I will be cheating I'll be lying to you
so this is not working right now which
is good okay so what I'm going to do is
to actually implement it and hopefully
you'll see how easy it is to do this so
I have done already the bootstrapping
with the UI you know the channels this
is how I'm going to connect to my
service and here I'm creating a new stub
this is actually a async when they stop
this is fully and synchronous right and
for me to call the service chat service
I say chat now here's where things get a
little messy again because this method
expects a string observer okay now you
have to remember what this is actually
do this is actually a listener listening
to messages coming from the server to
the client now okay this is a Kobach
interface over in implementing so we can
receive data from the server and to
implement this for example I can say I
want to display this in the UI so I can
do something like run later and can add
the message to my list of messages in
JavaFX so I can say add and what does
this message mean to look like I'm going
to a string format ooh
string format what am I going to do here
I'm going to have the name and call in
with the actual payload and then I can
get the name from the message so chat
message from the server get message get
me and get from I think yeah and then I
can do a chat message from the server
get message talking this is how I name
my thing please don't mind this when you
do this yourself it wouldn't be that
complicated all right and then I need to
find the buter in the right place
oh it's a pewter
oh no that's it no no Bueller necessary
okay good my head its wraparound buter
in the past couple of weeks so anyway so
now I can receive the message from the
server I added to JavaFX added to the
payload of messages and that's great if
I receive an error here you know I'm
going to do do nothing all right and
word I mean if anything you should you
know print the factories you know I mean
like just don't ever swallow or you know
hide your exceptions ever all right so
here's uncompleted I'm gonna do nothing
as well
alright good and that's it but how the
hell do I send data to the server this
is only receiving how do I send data to
my service well if you look here
carefully in chat it's actually going to
return you a stream observer so
everything here it's based on strings so
this observer is what you need to use to
send data to the service so to server
okay so whenever I hit that send button
I need to send a pelo stream it to the
service and to do that I need to use
this callback to server I can call next
right and this is which is generally our
payload it's a base the connection point
for us and I can say check message
new butor I compute and I can set the
from with the name target text right I
can set the message with message target
text and that should be it
now I have bi-directional streaming or
hooked up with G RPC with two strings
right one to the server one coming from
the server and I'm done but I only
wanted to do this if I click on the send
button so I need to say action right
when somebody click on that button this
is what I'm going to do so for DB and
boom done okay
whoo I think I'm done now it's not do
another try how many people think this
work is off the bat Wow even less holy
wow this is bad this is bad why why is
that it might not bad it usually grows a
little bit it doesn't you never go
backwards you so we know but but but
then it's like Oh
so I have no idea myself either so we'll
find out pretty soon so here's the same
app gan say ray and hello the box this
is the scary part and yes it worked
woohoo yeah not bad but but that's only
with one client
there's only with one client and I'm
gonna run another instance of it so just
to show you how this actually watch me
honey things right now I got now I got
two clients well let me zoom in and I'm
gonna be my boss my boss's name is Greg
I'm not be be like Greg's I hey ray good
job yeah I can actually see you oh well
then why thank you Greg
awesome manager yeah now I can do this
all day chatting with myself
complimenting myself but I don't wanna
do that
right so you can see you can view a
bi-directional streaming service really
easily with just a few lines of code now
of course I did it slower much much
slower and slowly to talk to you all the
details between behind it and so you can
see oh what is this like to use G RPC
and hopefully it is pretty
straightforward
it's nothing much too much to it we made
the experience pretty good the only
thing is you gotta remember is
everything is extreme you have to deal
with the stream observers now there are
actually ways talk to me afterwards
there are ways for me to tie this into a
reactive Java R or R at I can tie this
into observable from our X then you can
do some of these things in a more
streaming fashion that you're more
accustomed to right we can also do much
much more let me see if I have this line
let me go back to this there we go so we
fill the stream another really cool
thing is imagine if you have a back-end
service that's taking in from the client
like a search request like some big
company that I know does this right they
they're taking a search request okay
I don't know which company but I do
alright as you have a car you say search
and then we go through multiple back-end
services we need to do many many things
in parallel but imagine if one of these
services just takes forever to respond
do we want to wait for it is that
important to wave without one single
response maybe not
what you can do in your micro-services
deployment is that you can also set
something that we do which is setting a
deadline how quickly or how long should
I wait for my services to respond the
payload to me and this deadline can be
propagated through the multiple layers
of the nested Services code across
server boundary this is cool so we can
say the master the top service only has
one second to respond and then the
second service to half a second and the
subsequent service to wouldn't have a
second and this entire thing is invalid
now because he took more than a second
it's going to propagate this dead line
all the way down to the last call and
then you can cancel a call you have a KO
by to handle the cancellation as well
you can add interceptors you can add you
can propagate data so imagine if you
have a GWT JWT token or some
authentication token you have to pass
all the way through every layers of the
service you can hand it off in a
metadata int in the context as you heard
this from someone yesterday from the
community right they're doing a mutual
pls mutual security LS across multiple
services which is super super awesome to
do any kind should we do that in G RPC
as well a lot more to it if you are
interested please please let me know
there are many many patterns we can
implement from the micro services
architectural concerns you can transfer
that into G RPC pretty straightforwardly
and lastly if you want to find a code
you can go see my github at Stanton
isn't on the G RPC Java demos if you
want to learn more about G RPC go to GRP
cio and one of the reason I'm here is I
want to you know excite the community I
want you to try it and I also want to
hear your feedback so the best way to do
that is to come to the you know the RSC
or you know find out on Twitter and also
if you can please please contribute and
you can find out how on the lien on the
top so thank you very much for your time
and yeah it's great to be here thank you
any questions questions yes question
over there yeah ah so that's a great
question
so the streaming server side which is
client server is here this one right um
let me think here you probably don't
need to yeah you just need to make sure
it's press safe if that's the case if
you want to sure dying sense yeah I'm
just so much yeah it's easy for me to
just type warning and generate the code
from the scratch yeah but now you can
try to say have a listener that you
can't share but but then you've got be
sure it's type safe though yeah okay
anyone else you know the question you
get question the back yeah
yep
got it so the question is if you want to
add a new attribute or new property to
this payload what do I need to do do I
edit the January code or do I edit the
ideal the answer is always edit the idea
you never want to touch the generated
code because the generated code could be
overwritten
it could be updated you just don't want
to deal with that but one thing I forgot
to mention is to put a buffer thing is
actually backwards compatible when you
define a payload so what I mean is you
can always add new fields as long as you
don't reuse the existing tags right
because the tag is actually the name
that uniquely identify where in this
payload this data should be loan to
right so if you want to add a new
payload here I can say string oh I don't
know rating let me say rating right it's
equal to 7 and I can make an email you
can have poor in poor and very poor
right so I can have that I can add this
field and it's not going to affect the
clients that's already using the
existing photo boss ok that's consuming
it you don't you don't actually break
them if you need to delete a field you
can also do that you just remove that
tag right you can reserve there's a
keyword called reserve my things
research reserve just one or something
there's a keyword called reserve so you
can reserve that types and nobody ever
uses it again and then you can define a
new tag if you want to and because the
ID is still there it's being reserved
whoever is using it can still
communicate with the server each of the
server doesn't see it anymore
right so you so there's no breakage in
the client but the server doesn't see
what is expecting but that's fine you'll
just handle it that way so you can do
both ways every time you do yes so every
time and that is how we define this
income in the palm right so the question
is everytime I update this ideal if I do
you package or not do we regenerate the
ideal and it's completely based on maven
in this case because we're hiding into
the compile phase so every time compile
phases being triggered it will try to
regenerate it right if you want to do
this manually having more
control you can get rid of the binding
so you can always just generate at your
own time okay so I think that's it yes
one last question yeah
oh I see are the interface automatically
version I had to say this but no no it's
not as far as I know it's not
automatically version they do try to
make sure that whenever we generate the
stubs we don't break your existing code
so rather than implementing interface
they have this info base so if you don't
overwrite a new method that you just
added to the service it will respond
with a default response which is an
arrow and the client would just have to
handle that yeah okay cool so thank you
so much for your time here any other
questions come up and we'll come to the
google booth and be happy to chat okay
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>