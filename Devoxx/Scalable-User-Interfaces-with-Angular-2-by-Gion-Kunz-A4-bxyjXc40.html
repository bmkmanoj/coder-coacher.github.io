<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Scalable User Interfaces with Angular 2 by Gion Kunz | Coder Coacher - Coaching Coders</title><meta content="Scalable User Interfaces with Angular 2 by Gion Kunz - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Scalable User Interfaces with Angular 2 by Gion Kunz</b></h2><h5 class="post__date">2017-05-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/A4-bxyjXc40" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay a lot yeah I mean even if you
started with RC and you're now with
final the natural answer would be there
has nothing changed but actually there
changed a lot so there changed a lot but
it's not so relevant for this talk
actually okay I think we can start my
talk is about building scalable user
interfaces using anger or with angular
although it's not so focused on angular
it's showing a lot of technology-based
things with angular but I would say half
of this talk is really about UI
architecture how do we build proper UI
architecture with components so I would
like to start my talk with this question
why components why should we create
components right we have user interfaces
without components before so why should
we now create components and to answer
that question I would like to tell you a
small story and this story is the
parable of the two watchmakers by
Herbert Simon and the story goes like
this there were two watchmakers in a
town and both of them they produced very
nice watches very fine watches there was
horror and temples and both of these
guys they produced really really nice
watches in in one town they were the
only one in this town producing watches
and it was really running very very well
so both of them they received a lot of
phone calls and they had orders and
produced watches and they earned a lot
of money with these watches and it's not
at some point some day horror was still
doing really really well
however tempos somehow
didn't really made a lot of money
anymore and his process kind of had
issues so he really went out of business
completely and after that day horror was
the only one in town who was producing
watches and make all the money of course
so okay what do we get from this story
what do we want to know is why did
horror succeed and temples failed and in
order to find out we need to look at the
watch manufacturing process of both of
them so basically we see we look at the
process of temples first so temples
watches consisted of roughly thousand
parts so a lot of different parts in
this watch watches and his approach was
to assemble all these tiny pieces
piece by piece into one final watch and
there was a problem with this approach
because you need to imagine that he's
building this watch and getting phone
calls at the same time sometimes these
watches they fall off the table while
he's building them and then the watch
was bursting in two thousand pieces
right so he needed to start all over
building these watches also when there
was a defect he needed to go into the
watch find the piece exchange his little
piece put everything two back together
again so it wasn't really working out so
well so let's look at horror and what
horror did instead of putting all these
so his watches also consist of thousand
parts but instead of building all these
watches of individual parts he was
building components smaller components
from these different parts so he took a
few parts built a small component and
then he built larger components using
these small components and in the end
his final watch only consisted of about
ten large components and what when he's
watched
well down when he was answering phone
calls it only burst into let's say 10
components which was great also when he
needed to do a repair job he immediately
knew that this is probably this
component so he just could exchange the
whole component instead of taking the
whole watch apart into pieces and this
is the really beautiful conclusion of
Herbert Simon who created this parable
and the conclusion is complex systems
evolves from simple systems much more
rapidly when there are stable
intermediate forms and complex system in
his stories is the watch right the watch
is a really complex system and stable
intermediate forms are components right
so instead of having all these kind of
pieces into one system you create
smaller systems that work in a larger
context right and this applies to nature
to economy to building user interfaces
as well but still you might think okay
that's a nice story about two
watchmakers how can this really
translate to user interfaces right so
let's look at this really famous UI of
github and we could try to reverse
engineer this and build one page where
we put an element and order element and
another element another element and we
can add some more elements elements
elements you know we could go on and on
and this does look familiar when you
think about the watch making process of
these two guys right this is exactly
what temples did put all these
individual elements onto one page put
all individual pieces into one watch
right it's exactly the same and we have
learned that this is probably not the
best thing to do and this whole story is
just about the reason why this is
right so if we approach is more like
horridest
with his watches then we could see this
whole thing as one component then we
have a smaller component in this case
it's the navigation bar let's say and
inside the navigation bar we have a
search component where we then have the
individual elements excuse me I need to
think a little bit of water so much
Mallory this is actually a much nicer
approach of building user interfaces and
the reasoning behind it is really that
you can build a complex thing like a
user interface much more naturally if
you divide it up in stable intermediate
forms or into components if you like so
there are some commonalities between
artificial and nature and one thing is
the scale so if you look at this scale
here you can see that we are going from
very fundamental to very significant
right so in nature for example an atom
is maybe very very fundamental but
organism is is very significant or you
can go further up like planet universe
multiverse or whatever you want to pick
as a target you always see that you have
a scale from very fundamental to very
significant and the same goes for what
we build right artificial things like
watches but also user interfaces and the
key here is that you achieve a good
distribution across fundamental and
significant you should not only have
fundamental stuff and very fundamental
stuff and very significant stuff that is
really not working out so well and
nature doesn't do this either right and
that's exactly the problem right and
that's what we use to do all the time we
create
pages and loaded them with UI elements
right we had huge pages admin dot PHP or
something like this for example and we
had all these user interface elements on
this on this page and we didn't really
think about creating components and
subsystems instead of putting all these
elements onto one single page we should
really do something like here on the
left we should we need to build user
interfaces that are wrapped into each
other create larger components instead
of just putting elements on a page so
this is probably my number one advice
for you when you think about component
izing don't think about reusability it's
the baddest habit you can have that's
usually our first thought right how can
I reuse this if I can reuse it I will
build a component if not I will not
build a component right that's the wrong
thought you should only think really
about simplicity use simplicity as your
as your goal when creating components
you want to create a simple application
let's take this example of a task list
so this is a very simple task list you
have a checkbox and a title and you're
going to list a few tasks so if we look
at the code of this we could implement
it like that right so we have a quite
large template here is the ng4 right so
we are iterating here which means this
is actually the list and this is already
the task right in there life of a task
and then we have this check box which is
a special check box it looks a bit
different than a regular HTML check box
so we have a label wrappers style it a
little bit different we also have some
logic here and then we have to talk
title so there are different concerns in
this component and I would really
consider this as not really simple this
is not a simple component so I would
really not recommend to go
about implementing something like this
with this template instead let's divide
the responsibilities we have a task list
component the task list components
responsibilities only to list tasks not
how a task looks like right
what is the inside of a task is not the
responsibility of a task list then we
just render task components and in the
task component there we are concerned
about how does it look like and how does
it behave like and we go even that for
that we say our checkbox is quite
complex because it's kind of a custom
animated checkbox and we want to keep
our code simple so we create a checkbox
component and include it here that's how
the checkbox component would look like
so keeping it simple is is really the
key here and the reason for this there
are many reasons and many benefits from
this one is that it really allows us to
focus on our code when we when one piece
of code has only one responsibility we
can easily focus on that and we are not
very good on focusing right we can
remember
I think maximum of or average of seven
things at one time right so we shouldn't
really be concerned about all the lists
and how it the talk looks like and the
checkbox all at once we should be able
to focus on on one layer on one
complexity later and that's one one big
reason of course we also enhance the
fitness and ready for change or
readiness for change and the overall
flexibility because we create these
components let's talk about composition
composition is in my view one of the
most important things not only in UI but
also in development
in regular development or if there is no
UI involved and I gonna show you what I
think are two key aspects of composition
or how you can view composition there is
what I call an intrinsic composition and
there is an extrinsic composition so the
intrinsic composition is when a
component explicitly states he is
consisting of some parts on sort of some
defined parts for example my computer
has a keyboard right so the keyboard is
a sub component of the laptop right so
this is intrinsic it's motivated by the
laptop that he has the keyboard right
however there is also another form of
composition which I call extrinsic
composition and in that case you are in
your component you're just opening up a
free space where you allow stuff from
the outside to be inserted into your
component right so how can we look at
that with an analogy for example we can
see that extrinsic composition as an
empty jar component if we think of a
char we can put something into the jar
right we have an empty jar we can put
jelly into it or cookies cookie
components mmm I don't know this was
there any desert during lunch I didn't
see and it doesn't yeah doesn't matter
so actually we can put anything we want
into these empty chart components and
that's what something like this with
extrinsic composition would look like
using angular it is our char component
and within the template of our char we
have this ng-content element and this
ng-content element is just it's like an
anchor where we specify this is the
location where we want stuff from the
outside to be inserted or projected and
that's the term that comes from shadow
Dom actually content projection and in
angular it's the same
term they call it content projection
this is the place where we want to get
stuff from the outside projected into
our component so if we have our app that
is using a char we can now between the
start and the end tag of our char
component we can put content and this
content will be projected into the char
component so this is a great tool if you
do composition because then you are very
flexible you can for example create
components like this a collapsible a
really simple component but if done
right if done using extrinsic
composition your collapsible component
is highly flexible because you can put
into the component after you've built it
whatever you want right so this
collapsible you just it has a title you
click on it it opens you can click on it
again it closes again right really
simple UI component this could easily be
implemented like this using content
projection in angular so here we are in
the app component and we are using the
collapsible component we're passing a
title input to the component so we say
that this is the title and between the
start and the end tag of our collapsible
which has put our content that we want
to get projected into the component so
let's look at the collapsible itself the
collapsible consists of the whole logic
when clicking the title that it kind of
switches the flag if it's active or not
so this is just this toggling here it
has the title input right so that we can
grab the title from the outside through
an attribute or a property input binding
and then we have this ng content down
where we want the collapsible content to
be projected so this is everything we
need so that angular knows how to
project content from the outside into
our collapsible prefer composition over
bloating and this is a really important
one because
I see this a lot of times projects start
out very clean and then newark new
requirements come and then people start
to modify their components and they grow
and grow and grow and after some time
their components are really huge and
this is really a problem and funny
enough I use the same example as Martin
did in his presentation my example where
we try to reverse engineer something is
also the Chi male lab we didn't talk
before about that right it just happened
so if we look at the Gmail application
we and we try to reverse engineer that
into components we see some
commonalities here right so if we focus
on this area we can see that all these
let's call them message items they look
pretty similar right okay we have some
optional tags on the messages sometimes
we have a time here sometimes we have a
preview text or only a title but they
look very similar so we could actually
build one component to represent them
all right so let's do that but before
that let's look at this one so this is
kind of an expanded message item which
shows you much more detail it also has
different behavior and even the layout
is a little bit different yeah let's
keep that in mind
first of all that's how we could
implement a message item right a very
simple template we have a profile image
we have a profile name title and yes we
have no semantics here excuse me
it's just diff but for the demonstration
it's it's fine yeah so it's really
simple and this is a simple component
there is nothing against something like
that except that it's not very semantic
all right so let's look at this problem
again now we want to click on one of
these items and then it should expand in
something completely different right
maybe uses the same data but
it looks different it behaves different
so how do we go about that well the
simple solution would be something like
this right we just do an G is and then
we have on the top if this is not
expanded which is render how message
item looks like if it's expanded we
render like the details looks like right
and then we have our new message item
component that can do both it can expand
right however we are mixing
responsibilities again this is not how
you should go about that you should
simply use composition and then it's
really really simple if you think about
it instead of creating or making our
message item expandable with some
details we are creating a separate
component for the message item a
separate one for the message details and
then we wrapped both of these component
into a wrapper component which is called
expandable message item and there we
just decide should we display the
message item or the message details
based on that stat estate if it's
expanded or not right it's really simple
if you think about it but we need to
think more in this terms of solutions
when we compose our application let's
talk about data a little bit and
specifically I want to show you
something that you Martin also covered a
little bit with web components I like to
see it as a kind of inversion of control
so let's look at an example and this is
a simple to do app or not even a to do
app it's just a listing app where you
can add stuff so in this case is a list
of fruits you have a component around
this list which let's call it is our
main component is our app component
right the whole app is here in yellow
surrounded by yellow so this
in components we could also call it a
container is keeping our data right so
our data comes from this container or
our main component and then we go a bit
further down in the componentry we have
our list component and the list
component consists again of list item
components so now we are passing down
the data from the container is let's say
the list the data list of fruits we are
passing it down to the list component
and the list component is passing it
down to the list items and then we have
also behavior on this user interface
right we have a clear list button that
is part of the list which is clearing
the whole list we have a new item add
list button which is also part of the
list component and then we have this
list item components which show a title
but at the same time it they have two
behavior that we can remove them from
the list right so now if we looked at at
that in a hierarchy we have basically
our data container our complex colleague
container component which is passing
down data until it reaches the message
item but at the same time and this is
probably a little bit the mind chest
right we are also passing the actions
that were performed on these items on
these components we are passing them up
again until they reach the data
container so let's look at that in code
now we are on the list item component so
we have a title on the left side and on
the right side we have the remove button
so if we click on this remove button we
are calling a method remove so now
instead of performing some type of
manipulation on on data when this item
or this button on the component was
the only thing we do is we tell our
parent that there was a remove event
right we just tell our parents and we
are supposed to be removed that's what
we tell our parents so we are in death
an inversion of control right we're not
executing the action we're passing the
action further up so now we are passing
this up to the list component and on the
list component we are capturing this
event on every single item and then what
we do is we're calling this remove item
method for every item that was removed
and we are also passing an index of the
item that was removed so we now remove
item method what we are doing here is
again we're not doing any manipulation
we are just really ting if you like that
event so now the list is telling its
parent that the item at the index five
was removed to do something about it
right and now finally we are reaching
the app component which at the same time
is the data container and here we are
only catching this remove item event
from the list and then we do something
about it because now we are in the data
container and the data container is
responsible to modify data to manipulate
data and now the good thing about it is
that if we manipulate that data after we
manipulated it this list here is maybe
shrinked by one and then we are passing
this new list down to the componentry
again right it's falling down to the
list and the list is rendering the list
items right so this is really a
unidirectional data flow we have data
going down events going up manipulation
data going down and so on this is really
really clean so what does does it help
to centralize your data
it really really helps because now we
can reuse our to our list in any kind of
context we can create a data container
that is loading some data from a REST
API and then we can render it we can
pass that out data down if there is a
remove event we call the REST API again
remove the item get the new data pass it
down but at the same time we could use
our list component to make the tutorial
part of our application and we just pass
an array down to the list component we
don't connect it to any kind of of
service so we can really reuse this now
in all kind of context because we invert
it to control we reverse the control or
inverse of control
all right so let's talk about change
detection and it is not so easy actually
change detection and what I try to do
here is really talk about the most
important things and I really try to
visualize how change detection works in
in angular 2 or sorry angular 4 so first
of all what we need to understand is how
is change detection triggered in angular
at what moment does angular do change
detection and for this we need to
understand the concept of asynchronous
zones and zone chairs so asynchronous
zones is a concept I think borrowed from
other languages I can't remember exactly
from which but there is actually already
a standard proposal for zones in the
browser which is still in strawman state
state zero but still there is a proposal
so Sanjay is no longer a library it's
actually a polyfill that's actually a
cool trick if you want to make a
polyfill just create a standard
instrument proposal and then create a
library that does that so you have
already discussed country yeah so it's
not sure if this is going to land but
it's definitely a great thing I'm going
to show you what the problem is in this
example so here we are adding an event
listener a click event listener to a
button and then when that click happens
we are starting a timeout of one second
after the timeout we are fetching some
data and if that data is ready we
resolve it so we receive a promise we
resolve the promise and then we call
console.log to lock the text that we
just got from the from this URL so now
the problem is when we for example have
an error here at at this console log um
or when this promise is resolved then
all we see on the console is the call
stack that was executed here when the
event started right that's where we
where Java Script knows this is the
context there is no way in JavaScript
except then closure parent closures but
this is not really a call stack this is
a scope right there is no way for
JavaScript to track to what asynchronous
call stacks you have already been
through to this point there is simply no
way I think there is this a think debug
check box in chrome I have no idea
what's happening there but maybe that's
an approach to do something like this
but here is what Sanjay is does it does
crazy things
it will patch your whole browser so when
you include zone trace it will override
add event listener for all event targets
it will over eyes the promise override
the promise API it will override set
timeout add event listener everything in
your browser will be patched so it's
kind of creating interceptor or proxies
proxy functions so that when you add an
event listener or
you add callback it actually intercepts
this and puts a proxy as your callback
so that it can be notified when this
callback is executed and when it's done
executing and now here is the trick if
you assume you have one root zone and
now it has intercepted all asynchronous
operations so that means that if this
code is in your root zone and now you're
calling an add event listener it will
create a sub zone and then your callback
will be executed in this sub sone so
here we are in a sub or in a child zone
let's call it sub zone one then we have
a timeout with another callback this is
intercepted or there is a proxy
mechanism and we have another sub zone
stop Zone two and then for the promised
we have another callback when we resolve
it this is the third stop zone here and
now since zone J has had has full
control over this if an exception is
happening here
Sanjay s can manipulate the exception
and add the whole trace through all your
zones where this exception originated
from so it contracted it was from a
click that caused a timeout that caused
an asynchronous request on the browser
or to a server and that's really cool
thing and I think they should they
should start implemented in the browser
it's really really beneficial so ok I
can tell you also this if you don't
include soldiers in your browser as a
polyfill angular will not work not at
all it will completely fail the reason
for this is that they are using Sanjay
as for more than just debugging or error
messages they're using Sanjay s to
execute their change detection and here
is why what do you think is it possible
that your application data or state
changes without an event is that
possible can your application states
change without an event like a click
like a server callback executing yeah
you think so how yeah yeah but it goes
to the event loop ok true yeah true
ok it's not I don't only mean Dom events
I mean set timeout indexdb throwing
something back any kind of soccer
connection throwing events right no it's
not possible right so it's very clever
what they can do now is they can hook
into the zone J's API and tell whenever
there is a zone terminated we do a
change detection right because that's
the point where there is possibly a
change and there is no other moment when
change can happen that's really smart
because then you don't have something
weird like a digest loop that executes
all the time or something like this
and you don't need directives especially
just to tell angular that after a click
there should be a digest it's just that
on any browser event there is a
possibility for change so angular will
do a change detection for you and here
is a bit yeah problematic part about it
by default angular thinks we are stupid
developers really because this is a
default behavior by default angular
checks every binding in your components
templates of every component on any
event in the browser so if you have
thousand components in your application
on every single event that will be a
change detection of every binding you
have in your component right imagine
this is a lot of binding checks right
now why why is that it is by default
built on the assumption that you could
modify the state of your application any
time and you can modify you can do weird
things right I could grab a component
that is completely somewhere else modify
some of its states at any event and then
this component there should actually
update right or I could put something in
the window object and then I can grab it
with another event I can grab it from
another component and update my state
right and angular is by default setup
that it works if you do crazy stuff like
this right so if we look at that in a
graph it would look like this we have a
click event and all our application
components will trigger a change
detection so even if the click was here
and you didn't modify anything angular
will still do the change detection and
evaluate the bindings to find out if
there was a change so now let's look at
a concept called pure components pure
components they are built on a different
assumption pure components are only
changing if their inputs change and it
is coming from pure functions right in
functional programming if you provide
the same input for a pure function you
will get the same output right that's
the definition of pure and in angular
it's the same with the pure component if
you provide the same input it will
render exactly the same right so it's
only depending on its inputs not on some
connections to services to data anything
like that just what comes as
in put binding into an attribute of the
element right so coming back to our list
item list component we have one input
item which is a string so we get that
from the item attribute of this
component and then we are rendering this
title right or the item and we have this
remove functionality rhythm remove
button what do you think is this a pure
component yes yes it is if I change if I
don't change this item input the title
it will look exactly the same
there is no reason we need to do a
change detection and that's just how we
can achieve it to tell angular that we
are not stupid right and this is a
component we think it's pure it only
should change when the input changes so
we choose for this component the
configuration change detection change
detection strategy on push and by doing
so we tell angular it should only detect
changes when there are changes on the
input so taking our list as an example
we still have our route component the
data container and the data container is
not pure right this it grabs some data
from a service and then it renders all
the components it's not depending on its
inputs it gets the data from some
services from wherever so we we have
this as yellow here we don't it's not a
pure component the rest of our system is
now flagged as to be pure components
they only are depending on the input so
what happens when we have a click event
the click event is then dispatch took
parent and again to the parent and then
we finally land on the data container
there we are manipulating the data and
now since the data container is not pure
angle it will execute change detection
because red
other components they will execute
change detection on every browser event
right so now we have to change detection
there which will cause the input for the
second component to change which will
cause that input to change and it will
cause this input to change but effect
effectively we have only the components
doing a change detection that we are
really interested in where where data
really changed so building your pure
components is really important and I
think we should build as many pure
components as possible make your
components only depend on the input and
only if you know you need to have some
external data build a container and let
the dot data flow down into your pure
components so this is the lost topic of
my presentation is about the platform
the angular as angular as a platform now
you could say angular is universal it
runs in the browser and it runs on the
server and that's also where this
Universal thought came from actually
also with the initial approaches of
isomorphic JavaScript but I think
angular is a bit more because of its
platform abstraction layer angular just
runs wherever JavaScript runs right it
doesn't it doesn't need a Dom it doesn't
need anything else that it normally
needs you can emulate the platform
however you want because you have this
platform abstraction layer in between by
default angular comes with three
platform types it comes with a browser
platform which is the default platform
that is just rendering regular Dom
elements right so you have your
component tree and the template and then
angular renders HTML or Dom elements
right
then you have a webworker platform and
the web worker is a bit special because
there you have a restricted environment
you cannot do Dom operations in a web
worker right it's this multi-threaded
thing right so if you would give access
to a multi-threaded thing to the Dom you
would actually have a disaster right so
they don't allow Dom manipulation at all
so now there is really a platform you
can just hook in its really simple to
configure the platform you're on a run
angular in and then angular is not
depending on the Dom anymore and you can
run angular in a web worker absolutely
possible and with the breeze and the
final one sorry the final one is server
so in the latest version they also built
have a built-in platform that runs on
the server so they're trying to do more
than just the angular universal package
they try to build a core platform that
is available you can run on a server in
moment which is not only which is not
only no chairs but also JavaScript and
wormans like not owned right or the
dotnet a aspe JavaScript something wrong
time so how about writing a custom
platform and this is actually not as
difficult as it sounds if you want to
write your own custom platform you could
simply start by implementing a so-called
renderer and in the renderer you can
implement the adapter or the abstraction
layer that is manipulating Dom in the
browser but if you implement your own
platform you could do anything in these
methods right you can see this should
look quite familiar if you know the Dom
API right and it is just an abstraction
layer to the Dom API so when you
implement it with something else you can
create your own platform that you can do
basically you can use angular to render
anything you like so let's do a quick
experiment
we would like to create our own platform
which is not rendering HTML because hTML
is lame we want to render a graph on a
canvas and our elements should be
animated elements on this canvas right
so we use the canvas API it's not a big
deal we just implement our own platform
with this render that I showed you and
then we give it a go
so first of all this is how the
application we are gonna render with
this render looks like it's just a
simple listing component which is
listing items every two seconds there is
a new automatically generated item added
to the list at our application for the
moment it's a really simple application
so now we can import our custom platform
that we just built and then instead of
doing a regular module like this is how
you build up the module in angular
instead of importing the regular browser
module we are importing our custom graph
browser module and instead of doing a
regular bootstrap of our application we
use our own platform to do the bootstrap
and that's actually what comes out
instead of and it's the exact same code
as before when you saw the h1 with the
list elements appearing exact same
application code we have just switched
the renderer and now we are rendering a
graph onto a convos so this is really a
nice abstraction of course this is very
playful and experimental but it just
shows how flexible this platform is so
my advice here is just use the platform
abstraction and this is really important
because you sometimes you need to access
the native elements in your application
for example here what we would like to
do we would like to on our component we
also have a host element similar to the
shadow
right so on our host element we would
like to add an attribute data - message
with a value so we can inject the host
element by this statement here in the
constructor we can say at inject element
ref and that's basically the type for
our host element and then we get this
element ref which is basically just a
wrapper around an element it's an
abstraction around the element in
angular so now we can say we want to get
the native element and what's coming out
here is just a Dom element and then from
the Dom element we can use any API on
the Dom element we like to use so in
that case set attribute data message so
now the problem with this approach is
that if we would run that in our canvas
render we would get an error because our
canvas render doesn't have a native
element that is a Dom element in our
canvas render the native element is
actually a graph node which is not a Dom
object and we would have a problem here
because this node doesn't have a method
set attribute so never do things like
this when you access native properties
always use the platform abstraction so
instead of using the Dom API directly we
just inject this renderer that we saw
before we implemented one of these
renders right we inject that as well and
then in conjunction we can use the
render and this element ref to set the
attribute value and now it doesn't
matter on what platform you run it will
always be called through this platform
abstraction yeah so I think to finish up
this presentation I don't really think
it's it's the key message here is how
angular works right for me it's really
important that this whole component part
of this presentation is should make the
value of this presentation I think we
should all say
about how we put our applications
together and that we compose over bloat
that we prefer composition over bloating
our UI component okay so now a little
bit of marketing we're also having
workshops very soon so if you would like
to join an angular workshop with us we
have one starting for starters so who
didn't do a lot of angular 2 on July
23rd and we have another workshop for
advanced users where we do some advanced
topics also composition on July 26th you
can also use this discount code so you
if you are from the Fox days you get a
10% discount and also in August and
September there is the second edition of
my book mastering angular 2 components
which by then will be named mastering
angular components because at the
version we don't trust anymore so yeah
if you're interested in that yeah come
to me and we can talk about a discount
or something yeah
thank you so much
yeah and as far as questions go please
come to me don't be shy come to me talk
to me about angular I really like to
talk about angular I'm really passionate
about it so please come by and and talk
Thanks hey thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>