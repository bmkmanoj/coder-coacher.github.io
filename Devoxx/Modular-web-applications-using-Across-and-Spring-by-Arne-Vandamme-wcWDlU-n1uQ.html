<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Modular web applications using Across and Spring by Arne Vandamme | Coder Coacher - Coaching Coders</title><meta content="Modular web applications using Across and Spring by Arne Vandamme - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Modular web applications using Across and Spring by Arne Vandamme</b></h2><h5 class="post__date">2016-11-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/wcWDlU-n1uQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello there this is it a couple minutes
later than expected but the last
presentation of delphox 2016 thank you
very much for selecting me I'm honored I
hope I will not disappoint this is my
first time speaking and devoxx oh yeah
I'm a little bit nervous my name is
erina I work for a company called for
each we specialize in building custom
web applications with different
technologies and actually we're Antwerp
based where our offices only like couple
kilometers from here so this is really a
home game for me this talk will be about
framework with open source that helps us
in modularizing our spring based
applications so I really want to make
this a hands-on demo as soon as possible
but first I'd like to give a little bit
of context and I have to explain some
things as well so let's go back to the
starting point for us when we what led
us to actually building the framework
that we needed we've been as I said
building larger web projects that used
to be called just you know large
projects nowadays they have much cooler
name called monoliths which makes it
sound very positive right but what we
understand as a larger project would be
like one consisting out of like 10 a
couple of tens of mavin modules right so
in IntelliJ you would also have like
several modules this could be a CMS this
could be a public-facing website but
often in our case it also means there's
like one big base project that gets
deployed several times it could be
branded website or a different
deployment with different settings so we
had these large projects
we're really a big fan of spring the
entire spring ecosystem so they were
built 100% on Java and spring with your
very traditional layered architecture
data layer service layer business layer
controllers very very classic of course
when you have larger projects and you
have several of those you start looking
to sharing some code right so we've been
using custom shared in-house shared
libraries for many years which we deploy
to an artifact repository reuse them and
stuff we've all been doing that however
we were missing something we did not
have a good way to quite easily share
fully functional features shared
libraries are usually quite technical
libraries they contain utility classes
or things like that but we were we were
really missing like a bit of a common
language to be able to like export let's
say a user management section and then
reuse it in in a different application
see what we what we wanted to do was we
wanted to shift the architecture a
little bit from the classical horizontal
slicing that we had for many years to a
more vertical slicing where we bundle up
functional features into modules okay
this is again the word module here I use
in a different context than a gdk9
module or some of the other module types
you've been hearing about deaf Fox but
we want to bundle them up in modules and
within a single module you there you
could still find for example the
traditional layered architecture now I
don't know if some of you have seen the
talk on modular monoliths earlier this
week it's a bit the same idea this is
the shift that we wanted to do but we
were not able to do that very easily we
needed some framework something that
would help us do that with our spring
based applications we
we wanted and needed a way to define
these modules and we had a couple of
let's say requirements we wanted them to
be more or less pluggable okay so either
you you put them in the application or
you don't to compare we used to have big
applications with like if it gets
deployed and several different versions
you might have one big codebase and but
then you use feature flags to decide
I'll hear that song there that song you
want to move a little bit away from that
and just say in that deployment we just
don't put that module there and that one
we put it there so it comes on so when
its own it brings a full set of
functionality now to be able to do that
it needs to be able to create its own
context so that's what we considered
self installing right you plug it then
it needs to set itself up to be able to
do what it needs to do important spring
over the years has actually moved to
less and less let's say I would but I
find at least overhead configuration so
we really want to keep that as limited
as possible as well we wanted more
productivity even than we had before so
that's what we need it that's one of the
things we needed but very important we
looked at the applications projects that
we had and we didn't really have a case
for for hot-plug ability there was no
need for us to like be able to at
runtime update or add a module or
something like that
furthermore we really really want to
stick as much as possible to the spring
ecosystem don't go much beyond that
don't bring in extra dependencies don't
change our way of working stick to what
we used were happy with already because
we wanted to be able to migrate our
legacy applications as easily as
possible gradually step by step so when
we were thinking about this and we were
looking at a way to do this of course we
when you talk about modules you come
into contact with OSD I so we we had a
a couple of discussions and you know is
always the eyes something for us but we
decided it was not really what we wanted
in this case for two reasons like I just
said we had and still don't have any
real requirement for hot-plug ability
runtime reloading of modules that was
not really something we we needed plus
it wouldn't be a much larger shift away
from how you were working which would
make it harder to transform our legacy
application we really didn't want
something where we had to say to the
customer okay to three months and we'll
rebuild the entire application through
better way but then those two months
it'll be very hard to get new features
and stuff like that that that was just
not a fit a fit with us so we came up
with our own framework and we called it
a cross um I only just realized I need
to have a talk with the designer of the
logo but the OS stands for open source
it's not like we built an operating
system or anything like that right I
wouldn't want to get that idea out there
and across is just a base framework that
allows us to define these modules and
helps in it actually defines as well how
you can use them so what we understand
on defining a module is you need to
define the configuration right and
spring you quickly think of like
configuration classes or application
context XML stuff like that the services
they provide but also very importantly
dependencies between modules have a way
that modules can talk to each other
services from one can talk to services
from the other and stressing again what
was very important for us define like a
light layer on how they can set up their
own context right install themselves
migrate between versions if necessary
and of course quite basic how they
bundle and load basic resources that's
what the cross is and it's entirely
built on top of Spring Framework it
started a couple of years ago before
there was actually much
spring boot around nowadays we are
migrating more and more to spring boot
and introducing compatibility there
so I mentioned spring boot but then how
isn't a cross based application
different from a standard spring boots
application and it's different in some
important ways to explain that we need
to zoom in a little bit on the spring
application context now your classic
typical spring boot application has a
single class as a starting point
annotated with that spring boot
application what happens when you start
the application is an application
context gets created that's the red box
over there and you load all your beans
component surfaces they all get
instantiated in that application context
that's the blue dots
so basically simplified a spring boot
application is a single application
context with everything in it and that's
the most important difference when we
look at an across based application with
different modules in a cross every
module is its own application context so
we created an annotation called a cross
application pretty much the same way a
spring boot it's not like we stole any
ideas there and when you use that one
apparent application context still gets
initialized where you do the
configuration of your modules and maybe
some utility beans that get used by
everyone but then all the separate
modules have their own application
context with their own beans components
services in it and that's a very
important difference spring boot single
application context cross based
application context has like number of
modules plus one at least that many
application contexts the big difference
here is has to do with being visibility
or in practice
the ability to auto wire components now
in spring boot application where there's
one application context all beans inside
the context can see each other they can
all access each other they can all
depend on each other and you can have
like they're in the center you can even
have a cyclic dependency
I really wouldn't advise it but it's
it's possible when we go to an
application context hierarchy things are
a little bit different on the right
screenshot module one has its own
application context with several beans
in it so inside module one all beans can
see each other they can depend on each
other that's no problem
now in spring and application context
can also see all beans of the parent
application context that means module
one can perfectly well access any beans
from the parent application context not
a problem there it gets a bit tricky
when we try to do this so I have module
one with its own application context and
module two with its own so they're
siblings in the parent application
context siblings do not know that they
exist so they definitely cannot see
beans from each other because they are
not aware of each other as application
context so in this example module 2 is
not able to wire being from module 1
likewise at the bottom a parent
application context does not know of its
children so it is not able to see beans
pickup beans from a child application
context so that does not work either so
we had to find a way to allow modules to
use services from each other that they
provide to be able to do that module 1
if module 2 wants to use bean from
module 1 module one needs to expose that
bean basically what happens when it
exposes bean is we create some kind of
ghost bean definition in the parent
application context and then module 2 is
able to see that one and can simply wire
the bean it's it's not a copy a clone is
simply a reference to the actual bean
inside the module so that's how modules
can use each other's be important you
need to explicitly define which beans
you want to expose you need to think
about your public API of module at the
bottom we still cannot wire from the
parent application context beans from a
module don't do that sometimes it might
work but don't do that this is also the
reason why in the current version we
cannot just use spring boot
auto-configuration
because what spring boot
auto-configuration does by default is it
puts all its beans in the parent
application context and that would mean
that I might interfere or cannot access
the beans from the modules ok I'll show
you ways to go around a little bit so we
know this works
but there's another caveat a second very
important part let's say module 2 has
been and it wants to put it make it
available for other modules to use so it
exposes that bean then we know module 3
can wire that bean just like any other
component it can depend on it use it not
a problem
however module 1 still cannot and the
reason for this is modules are ordered
which makes a lot of sense you define
dependencies between modules in this
case module 2 depends on module 1 module
3 depends on module 2 and the
dependencies will determine the order of
the module modules and the order will
determine the order in which the
application contexts get created we call
this the bootstrapping ok bootstrapping
is basically creating the application
context of every separate module in the
order but that does mean that if you
rely on a bean well basically it means
you cannot rely on a bean in a module
that gets created after your own so this
is the second important part you need to
think about the dependencies that you
define the
modules because the order is is
important so that's how when you think
in modules is different then when you
just think in terms of a single
application context you need to think a
bit more about how you structure your
modules how you determine the beans the
services you want to expose and put your
dependencies right okay
enough theory let's have a look actually
at some code now so I hope that's a bit
readable I have this sample application
which I'll first start okay as you could
already see here is basically spring
boot based application but it's in a
cross application I'll first show you
the result so it's a simple website we
call the catalog application where you
have one or more categories category has
an item item has a name and a prize an
item can be on sale and the on sale
items are rendered on the home page it's
a very simple website in this instance I
can also switch language it's localized
things like that so let's have a look at
how its configured then you can
immediately see how an application based
on across modules differs so I'll start
with the pom.xml nothing special here
you'll see there's not that much special
either way perhaps the most important to
note here is that we inherit not from
spring i/o BOM but from our own bomb
which builds on top of spring i/o in
this version I believe it's the Athens
platform release over spring for 3
we are alpha 8 either way spring boot 1
4 and we have time leaf
three four rest nothing special I just
added all the dependencies I'm going to
use throughout this demo already in
there which are these modules and not
many of them are used and then you do
see some of the starters of spring boot
present the central starting point like
spring boot application okay first off
this code is basically the code of a
primer series that we're developing some
of the articles are already online refer
to them at the last slide but definitely
all the code is there and it's pretty
much explained committed by commit what
what's happening so our application here
instead of the spring boot application
annotation we have the across
application annotations and we are using
two of what we call the standard modules
across web which basically sets up some
spring MVC stuff and hibernate JPI with
JPA which sets up a shared and the
manager below you can see it's just your
normal configuration class it's just
spring I can import other configuration
classes so I cannot use the full auto
configuration of spring boot but if I
know what I can just import the
configurations it's it's no problem
this class is a weapon we see configure
adapter sets of the locale switching not
very relevant for the rest I have some
entities these are plain and these with
some validator annotations and I'm using
spring data repositories for the for the
entity management the views that we just
saw basic controllers nothing nothing
special there so if you look at it when
it comes to the the code itself apart
from some base classes that I use which
has nothing to do with across itself the
only real difference is the packaging
the fact that everything here is in an
application package
and I'll explain that in a bit that
actually the terms makes automatically a
module the views as I said we're a big
fan of time leaf so there are time leaf
templates and there's some static files
and then there's some message properties
nothing special there if you'll notice I
know we're configured anything of time
leaf I know we're configured everything
of message sources but it it
automatically loads that's one of the
things that across dust for you as I
said bundling of resources it has a
standard way to do that so when we
started this application here I define
two modules black module JPA module if
we look at the output I hope that's a
little bit readable but basically what
it says here is bootstrapping three
modules in the following order hibernate
web module and catalog application
module again this stresses this is
important output it stresses the order
so you define dependencies there you
will see what resulting order of the
dependencies was important here is I
know where to find the catalog
application module this was created
automatically based on the package and
the reason for this is like I said
before if we put our business code in
the parent application context it might
be harder to work with modules so we put
it even inside a single application it
gets shifted inside some dynamic module
so when I started up this application I
I have the entities and a database got
created so I added h2 console ok with
the physical database so a simple
database got created with a database
schema
where my default categories are in and
then some tables of across modules so
how did these get created well this was
done through installer classes now I
have two installers in my project here
in my module a schema installer and a
test data installer installers are
special beans so to speak this is the
schema installer as you can see it
inherits from a liquid based installer
so what it basically does is it runs a
liquid base schema file simple and this
is the test data installer
it's annotated again with an installer
annotation and the only difference is it
uses the repositories to create my test
data and also it only executes if the
def profile is it's active maybe you
noticed but my installer annotation has
a couple of extra values one is version
and one is phase now the face here they
have a different phase the schema
installer has a face before context
bootstrap meaning I want this to be
executed as early as possible before any
of the modules start I want my schema to
be modified and the test data installer
says I want to be able to use the beans
from the module so I need to execute
once the module is available now
installers you could say we've been
doing this and we used to do this as
well why not do this with a regular add
component and an auto wire method or a
post construct method why do you need to
have a special
annotation special location and annotate
the the methods you want to execute in a
in a different way well there's a
a reason for that it's because
installers are a little bit special
right and they are one of the more
important features that we found when it
comes to building self installing
modules so what's the difference um
install our beans are only created and
called if they need executing and once
they're done they're destroyed but
they're destroyed in such a way that the
only thing that will remain basically is
the class that has been loaded in the
class loader there will not be any being
there will not even be a beam definition
visible anymore to determine if they
need executing installers are versioned
and tracked versioning is it's optional
but as you saw on the annotation I can
specify a version number so what happens
is across core will check which
installers does your module define which
versions do they have it will check in
its local repository what are the last
installed versions is it higher okay I
will execute you if it's not higher I
won't do a thing to do that it current
the current implementation needs a
single database so it works on a central
database to track sequel database to
track its installers which is still a
very common use case in a lot of web
applications furthermore it uses that
same database to perform synchronization
every installer is synchronized so if
you have like again a very common use
case till if you have a website which
uses the same database back-end but you
have multiple web servers you deploy it
to and you deploy them simultaneously
you do not want your code to execute two
times in migration for example so that's
what the distributed locking mechanism
takes care of you might notice from
something like liquor base only dis
applies it to any kind of installer and
it's this mechanism that has eventually
allowed us to evolve from doing
sometimes still a manual
migration meant for example a cube a
scripts were not enough to doing
everything through installer beans
basically we can we can add them they
will get executed if they need to get
executed and if it's not like a common
reusable module after a while we can
just throw them away because they are
not relevant anymore lasting as I said
they are bound to a certain phase of the
bootstrap which will determine if they
can use certain beans or not I'll go for
this quickly I left this in just to for
when I published the speaker deck so
installers very important concept for
general module but I still have plenty
of time so I'd like to illustrate a bit
how modules can work and play together
ok so over throughout the years we've
encountered some we noticed that we had
a lot of common code and modules that we
actually used through our many projects
so we decided to gradually just make
these generally available we call these
the standard modules so let's I want to
show you a bit how using some modules
can impact your productivity as well
with written application so I'm gonna
add a debug web module okay I'll just
recompile the code spring dev tools is
as actives or the application
automatically restarted installers did
not get executed because they were
already there okay so now I have my
application and on debug and now have a
whole set of debug development pages and
we used debug web to actually inspect
the across context because otherwise
it's not that easy to inspect a
hierarchy of application contexts so
here I can see that's a bit like the
drawing output I see the order of the
modules and then I can jump to a single
module and see you
which means they have which means they
expose a services to and to others so
debug web is an example I just plug that
in I mean I had the dependency already I
just activate it and we get a whole web
interface another example of how you can
play with that is you know add a module
in a different way because a module
itself can be defined as just being in
the parent application context and I'll
add this is a logging module which will
give us some more information on the
line settings let's enable that just to
show ok recompile don't need to do
anything application will restart okay
done
so that's bring boot dev tools I love
that going back now we see that the
logging module got added and it got
added high up that's because of some
dependency rules that it it defines and
if you pay attention you see that now we
also have an extra menu here ok because
logging module in this case and these
modules they know each other they play
well together logging module knows sees
that debug grab is there and it has
added a logger page where you cannot
rerun time change the low levels and
useful for debugging we also have an
option to enable the full request
response log that comes in which can be
pretty useful if you have like rest
web services it actually shows you the
full body that came in and the full
request that went out but deeper crap
and longing that I just showed you there
dumb still more technical modules right
they they aid us in development process
I'm just gonna put this one at false but
throughout the years we've also built
some modules that help us as I said with
with more functionality that we want
to share so let's say that I want to
have a management interface for my
catalogue and category so I'm going to
add a couple of modules I explain a
little bit on the way you know
recompiling and now it's taking a bit
longer and if you were fast enough you
see that we have liquid base executing
all kinds of things this is for the user
module let's first go and have another
look at our context browser and now I
see there's a whole lot more in there I
added three modules but actually more
were added this is how dependencies
explicit dependencies can influence your
across applications if let's say the
user module has a required dependency on
the properties module you see there so
what happens is across in this case
knows where to find that module and it's
available on the class path it just
pulls it in as well and again the order
is is influenced and determined right so
the dependencies can work so a lot more
modules got added transitively and if I
now go back to the database I can see
there's a whole lot of extra tables at
it as well
this is an example in this case user
module which is more like a general
purpose user domain and comes with its
own installers it installs its tables we
prefix them with um to really show don't
touch these their responsibility of the
user module but we didn't have to do
anything for that of course if you
remove user module they will not be
removed right they'll stay in the
database so let's see what I added now
if I go to admin I now get a new user
interface this is the admin module in
action just provides you with a very
light general administration UI
framework so to speak it sets up like a
base controller a secure path then
spring security and yeah basically
that's that's pretty much it I can login
with admin admin but that user that I'm
logging in with that's not a maneuver
module that's the user module so because
they play well together
if by default our module is their user
module is their user module detects it
builds its user module sets up spring
security usual detailed service so I can
log in this is the administration
section and I noticed that I get a
section entity management that's what
entity module gave me so user module
which I added provides a general purpose
user domain so you get like a user with
one default created through a user can
have a role role consists of permissions
users can be managed in groups and
things like that
it integrates with the Spree security
model so it's something we use for
simple applications where we don't need
a custom much custom security things we
just plug it in there and you get pretty
decent features when it comes to a
security and user management but perhaps
more interestingly is we can now also
manage our category let's say I create a
new category here right and then an item
car with a price I'm not going to go
into too much detail here because if
you're more interested in these modules
the the actual primer does give a
step-by-step more more information so I
can easily add a category and I didn't
have to do a single have to do anything
I just dropped in entity module because
in this case what the entity module does
it's something that we designed we
noticed we have a lot of applications
with entities but there's no real
requirement for a back-end management
interface at least not from the customer
side so what happens is we don't build
one and then we always end up you know
fussing about with in database when we
want to man
check something or not so we said okay
we want like a general-purpose module we
plug it in it helps us it generates user
interface based on Spring data
repositories and it tries to do so as
intelligently as possible and that helps
us have a UI to manage entities but
without having lots and lots of
generated code in the project for those
admin controllers because they're not
really that important if you're into
like this code type thing generators and
stuff you should really check out J
hipster for example there they do great
work on that but of course let me show
you I can customize it quite a bit what
we and this is important what the entity
module does for example compared to a
file and we really build something that
was useful for us we like custom web
applications
meaning we worked a lot with time leave
a lot with jQuery bootstrap specially
back-end so we needed the solution where
we could easily plug in like a time leaf
template instead of a certain control so
that's possible with this so just to
show a little example of customization
let's say I have the category view here
and it's sortable okay but there's no
default sorting so let's say I want this
list to be by default sorted by name and
I want to show also the number of items
so luckily and the module does have an
extension point for that category
so I select the ListView and on the
ListView I want the default sort to be
done on name and I want properties in
order name path and item count now there
is no property item count so I'll just
stay make a fake property give it a
display name and use it get it through a
spell which would be item stop size so
now the ListView is sorted items added
so for well I'd say simple but you can
do some pretty decent stuff with that we
use that for custom views we we switch
to a different approach maybe that's I
have plenty of time so what I'll do here
is I'll check out to one later branch
now that's again all on the primer this
one adds some security and a custom
controller for the administration
interface so if i refresh now well you
already saw a security error there okay
so what happened now oh I lost the
catalog section the reason is the role
has been updated something apparently I
might have not switched dude right ok
anyway um I guess I'll I won't spend too
much time on this but this does show for
example here I have a totally custom
controller that plugs into our admin
interface this controller is your
completely normal spring controller with
the only exception being that it is an
atman lab controller and the reason for
this is that we wanted to make the path
of where ant-man web is customizable so
I know what I didn't do I didn't rebuild
anything
so if I rebuild now and restart the
application it should no longer be
available under slash happening but it
should actually be available under slash
secure no we might have to do a physical
restart must be deaf dude let me down
there we go that's that's better so this
is a way of how yeah now it run certain
new install or installing test users so
that's something we we do for example we
have installers that install a custom
permission and then we have separate
installs that install test users again
this one would be linked to the Deaf
profile to install users with a certain
role now this is an example of what we
call the standard modules that we've all
open open source but it's just an
illustration of how if you you think
modules through and designed them well
how well they can play together but now
I have plenty of time so I want to show
a bit how easy it is to go from our
application to creating a separate
module because so far we've only had our
application built on top of modules so
let's see about checking out a new
branch here wait IntelliJ often doesn't
like when I do this so you can load two
modules
okay hopefully this will this will work
so so in my project now I got two new
modules that got added which are now my
applications if you recall the previous
view I had a catalog application which
defined the single application that's no
longer the case here was the catalog
application but that has now been
replaced by instead of catalog
application I put a class they're called
catalog application module and that's
now a module descriptor that's the only
thing I actually changed in this case
okay instead of the the an application I
put a descriptor with the same name
module needs to have unique name and a
separate resources key this is the
reason why if you looked at it the paths
of the resources both the messages the
templates may seem a bit odd right and
this might seem a bit convoluted the
reason for this is they need to be
unique a guaranteed unique per module
because we do not want any conflicts
when we serve static resources or fetch
templates or stuff like that we're still
working on simplifying those but you
know once you know what they are it's
pretty easy so this module descriptor
defines a name defines a resources key
defines the default components can from
when it gets for its own beans and then
it defines dependencies to other modules
that's it that's all I replaced in our
original project and then I created a
separate application project where I
moved to test data installers too
because obviously test data installers
are usually not the scope of the
standalone module but often the scope of
the application itself right so I moved
those to test data installers that were
originally in my project and then I
created a new application class the
application class that
this one brings an armament module and
the module user module and manually
creates the catalog application module
however I no longer in our original
application we pulled in across web
module and JPA module which helped with
which helps us with controllers and
shared entity manager that's no longer
necessary and the reason is I have them
as required dependency specified on my
module so it knows it will like maven
pools and stuff it will pull them in so
if I run this application which will
hopefully work right
I should pretty much get what I got
before same layout I'm in management etc
frankly I have a demo yeah only I
started without dev mode so the test
data installers didn't run so let's see
if my in section yeah it's available
under private in this application yeah
so this brings in some extra but you
know I get the management interface
basically got everything that I got
before only now I'm making use of a
separate module and I move the
installers inside my own so it's really
straight a point a little bit further of
what you can do I created a second
application again the application
package will contain this the
application specific code right so the
second application which is an other
sample application is a bit simpler so
it doesn't bring in any other modules it
does not bring an out mini-map and the
module user module
none of those it does bring in catalog
application module and it doesn't allow
language changing it just fixes the
language to to Dutch because I don't
bring in let's say use case
here is it's a fixed website with fixed
data and the data cannot be managed it
just comes from some other process I
don't have the administration module
added here so if I want data in there I
need to install it so I created a
separate install that just fixed
installs data in the application and
then lastly I didn't go into that more
in the primer I decided to customize the
menu that the default catalog creates
and also I switched the default template
to show you my extremely well design
skills so let's run the other sample
application which should be on port 8081
so it can get run
there you go same module are we changed
here is the the base layout the products
got inserted through the installer but
there's no sign of any opening module or
entity module simply because all the
beans have been declared either as
optional on the depending on the
presence of module or just using regular
spring boot conditions that's also
perfectly possible so if we compare the
two contexts this one doesn't even have
debug web but you can see here that this
one's much much simpler does not contain
all those modules yes it's exactly the
same base module that we used all we
need to do was take care of thinking
about how dependencies are and how they
integrate so perhaps relevant to know
regular spring boot does life reloading
of templates and message sources and
stuff we we do that too right always
showing you when I enable death mode of
course in a multi application set of I
so man wants to show something and then
and if it doesn't work I'll stop crying
okay
so that and that's the same thing if you
follow the conventions of rest stuff is
where you put your resources that will
work for time leaf template for the
message sources and stuff like that you
don't need to configure anything for
that and that's a cross I showed you a
lot of the things with debugging Patman
web I mean perfectly usable but that's
not a cross court those are like the
standard set of modules we have some
different projects which use completely
different set of modules and that works
just fine the important thing for us was
and still is we're basically working
with spring application contexts we just
need to think a little bit more of our
public API how we separate things but
the framework gives us a nice way to do
easily define dependency set up stuff
run things like the installers so let's
see yeah I'll leave these in but I
pretty much explain most of them debug
web we saw logging module add some
logging infrastructure admin web we saw
as well babe hooks into spring security
user module gives you user domain model
so I added this the three together right
but you can perfectly well add them
separately if you just add a new app you
don't get users you have to do the
authentication yourself if you do just
user module then you just get the user
domain module services and stuff like
that but no user management and so
there's really no need to add them
together and just wanted to illustrate
how well things can play together okay
and the module does some more by the way
especially related to user module we
have one building a health system where
you can manage your clients through the
admin interface we have one hooking up a
security
Ciel building database model hooking in
with user module held up for sinking
things from Active Directory there on
our website if you're interested you can
they're all open source totally free to
you so you can just check them out I
think I hope I have illustrated how easy
it is it's really just determining a
module descriptor and and that's about
it
so I really hope I gave you some context
on on the framework it has helped us a
lot throughout the years in actually
modernizing our more larger spring based
applications we're working hard to make
it even integrate better with spring
boots and spring boot starters nowadays
but I hope I've shown you an example of
how well design modules can can play
together nicely and also how easy it can
be to migrate from like module based
application which was not a lot of code
to a separate module so if you're
interested across the fridge ee is the
starting point from there you will find
all the links to the source code issue
tracker the different modules the
reference documentation all code that
I've shown here is from the primer
series the code is all available with
committed by commit we hope to have put
a simple enough explanation telling what
happened so there are small changes the
articles are still working progress only
part one is published and part two will
be next week the reference documentation
for everything is available on the docs
path and all source code is in bitbucket
if you have any questions you can stack
overflow use the label across we'll be
monitoring that or you can just tweet me
directly
that's it if you're very interested
thank you if there anybody has any
questions now still feel free or just
come on down that's a no thank you that
was deaf for 2016 thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>