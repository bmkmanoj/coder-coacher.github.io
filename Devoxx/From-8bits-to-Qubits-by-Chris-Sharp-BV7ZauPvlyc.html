<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>From 8-bits to Qubits by Chris Sharp | Coder Coacher - Coaching Coders</title><meta content="From 8-bits to Qubits by Chris Sharp - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>From 8-bits to Qubits by Chris Sharp</b></h2><h5 class="post__date">2017-05-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/BV7ZauPvlyc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">we're again inflated do it make sure
okay so thank you very one thank you for
inviting me to DevOps it's the first
time I've been to this conference good
friend and colleague of mine Steve Paul
who I think is in a parallel talk at the
moment has been trying to get me along
to this for a couple of years now and he
asked me just a couple of weeks ago
actually to come and talk at this event
and I said sure what do you want me to
talk about and he said oh just cool
techy stuff and programming and just for
yourself
so with that fairly ambiguous
description brief I decide I didn't had
to think about it and I thought I'd
reflect on my own kind of journey in
computing how I came to work for IBM and
just a little bit of sort of a look
forward as to where we might be going
now I'm a kind of nostalgic retro kind
of guy so hopefully at least some of you
might get the cultural references that
I'm alluding to throughout the pitch so
I called this eight bits to cute bits
why I love being a programmer and why I
think now is the best time to be one so
I've been with IBM for a long time as
evident from my badge and over the last
quarter of a century I've had the
tremendous privilege and pleasure to
work on some amazing technologies some
amazing teams and see a lot of things
happen in the confusing industry over
the last 25 years like for example I was
the first person to create a website in
IBM back in 93 I worked on some some of
our early computer vision and VR work
with research doing digital
fingerprinting as well i implemented
mqtt the first implementation about 20
years before it became a standard I
worked on Grid technologies and then web
service technologies probably the less
said about that the better and then
cloud technologies and also had a great
time working with the games industry
working with the teams that developed in
IBM that developed the processes for the
PlayStation 3 the Gamecube no the
Nintendo Wii at that point and the Xbox
but in recent years I've been focusing
my attention on not so much the what the
how and working on DevOps transformation
work and so I've been around the block a
bit and got a few patents along the way
which is why I've got this title of
Master inventor with an IBM that's about
helping people to come along as well and
I got elected into the IBM Acadia
technology about ten years ago which was
an immense privilege but why did I get
into computers and that's really what
the premise of this talk is about and to
answer that I have to take you back in
time so I'm a child of the 60s but I
grew up really in the 70s so I'm going
to take you back to the early 70s and
Clacton Pierre has anybody been to
clacton-on-sea and I'm not surprised
nobody put their hands up it's it was
the nearest seaside resort to where I
lived and we spent inordinate amounts of
time playing in the arcades there and in
the early 70s arcade machines were
pretty much the same thing that they had
been for the previous 20 30 40 years
they were electromechanical they were
incredibly ingenious does anybody
recognize any of these things that I
when I googled for electromechanical
games I suddenly saw things that I
forgot existed for about 40 years
but they were basically toys on rods and
wheels and rubber bands and you would
control sort of tanks real physical
tanks and it was incredibly exciting but
it was quite primitive so I could
attempt to make the same sort of thing
using you know ethics soldiers on lolly
sticks and a 9-volt battery and a bulb
for an explosion with limited success
but it was at least a possibility but
then the late 70s started to change the
field of the arcades and suddenly we saw
the emergence of digital video games
and these were very exciting the
graphics were quite crude but
nevertheless it was stuff happening on a
TV screen which was completely different
to what we'd been used to and this trend
of video games continued throughout the
70s
and kind of was perfected when it got to
games like this
this game is Monaco GP by Sega released
in 1979 and it was just incredible I
remember playing this and thinking it
can't get more real than this this is
this is this is the real thing
incredible but what's interesting about
this is these video games were still
ostensibly the evolution of the
electromechanical games they were
purpose-built devices they weren't
really computers they were very
elaborate circuits built to do a
specific task this is actually the
circuit board schema for Monaco GP
they're incredibly rare but what's
interesting if you have sharp eyes will
find that it's all just an gates and or
gates and no CPU incredible what could
be done but as I said not really a
computer a very hard wired device and
video games started to appear at the end
of the 70s in our living rooms with the
Atari and television and stuff like that
appearing but they were still pretty
crude and what's more you've got what
Atari or in television decided you
couldn't have there was no possibility
of making your own games and then in
1980 this happened when it comes to
video games nobody compares to Atari I
find in television more sophisticated
and lifelike gentlemen
move over for my friend pick that
Commodore vic-20 Oh a Commodore vic-20
does more than your machines it's a
great computer that also plays great
games like this and this and this a
computer that plays great games under
$300 exactly we didn't know get the
Commodore vic-20 computer for under
under $300 were intact under 200 pounds
in the UK and I managed to persuade my
dad that yep that was absolutely what
was needed for my schooling so I was
lucky to get a 20 and about the same
time my school god Commodore pet as you
can see I like Commodore and these
things opened my eyes to an amazing new
thing the notion of programming suddenly
I could make stuff appear on my TV
screen or that green screen just by
incantations words what eldridge
wizardry is this if this isn't magic
then what is and I knew from that point
this is what I wanted to do with my life
than anybody recognize that listing
you're all too shy or too young
it is certainly basic and it is it was a
game called the valley that appeared in
computer and video at no it wasn't it
was popular computing weekly one of
those things that you had to hand type
in and we carefully hand typed it in at
school
and it took a very long time so this was
my new life but how did we get to this
point where suddenly kids in schools
could play and program computers so to
do that I'd like to just take you back
in time a little bit just to reflect on
how we did get that hopefully everybody
knows who this is
Haidee Lovelace maybe oh that's nice I
prefer this picture to the other one
that most people see Charles Babbage
refer to her as B enchantra's of numbers
and yes it's debatable as to whether or
not she was the first programmer I think
she should get that credit she was
certainly the first published programmer
when she wrote the first algorithm to
calculate the new a numbers and you can
see it is an algorithm as we would
recognize
an ordered list of statements of
operators taking in input variables and
output variables and registers and had
they built the analytical engine it
would been programmed on these jacquard
loom cards and they said the analytical
engine weaves algebraic patterns just as
the jacquard loom weaves flowers and
leaves you get a sense then of where her
head was even if you don't credit her
with being the third programmer what's
special is that she was the first person
to recognize that this had more
potential than just being a better
calculator Babbage was just saying this
is the next generation of his Difference
Engine but ADA so this is a thing that
could unleash human creativity and she
talked about how the individuals and
society might interact with this thing
in the future to collaborate and to
create music and things like that
very very ahead of her time
unfortunately we have to wait another
century before we see the likes again
when we see these three gentlemen
hopefully they're all recognizable
obviously Alan Turing in the middle we
have Claude Shannon and John von Neumann
and what they did for us was to think
about the abstraction of what this thing
might be that we call a computer as an
abstraction from the mechanics of how we
actually built them away from them the
gears or the valves or the tubes
cheering coming up with the theory of
computability effectively and what we
would come to know is the Turing machine
the universal Turing machine
Shannon doing similar things with
digital circuit theory at the same time
but then also doing the same thing for
information processing and separating
how we represent information and
communicate it from the underlying
mechanisms and john von neumann who was
genius in many dimensions coming up with
the abstractions of how we might think
about the components of a computer
rather than it just being this hardwired
machinery so they lay down the
abstractions that enables to start
building things and it was until 1946
which is over a hundred years after Ada
and Charles Babbage were working on
their analytical engine that we see the
first electronic turing complete machine
incidently then little engine was turing
complete or would have been tearing
complete as well then ADA's algorithm
was bug free not bad really considering
it was never invented never implemented
but as you can see on the left there
there's one of the first programmers
again a woman programming ENIAC and this
represents the program for some
calculating ballistics a nightmare it's
all wiring patch wiring the individual
components to program the device so it
wasn't really a programmable computer in
the sense that we'd recognize it and
it's kind of interesting to reflect on
how it's similar to Monaco GP with its
hardwired circuitry you widen those
logic gates and that's what you've got
so programming it was a nightmare
reprogramming it you really didn't want
to go there so let's quickly go through
the next few decades so by the end of
the 40s we have computers but computers
are things that humans literally
physically manipulate to make a program
with we know there are probably around
about the order of 50 programmers and we
know there are less than five computers
by the end of the 40s we know this
because Thomas Watson the founder of IBM
famously allegedly said that he foresaw
a market for as many as five computers
in the future it's arguable whether he
actually said that but it's been
retrospectively considered that had he
even said it in 1943 it would have held
true for the next ten years so we know
computers are horribly difficult to
program the people who are programming
them are very deep minded scientists and
mathematicians so throughout the 50s
some very clever people starting to get
fed up with the way programming was and
so assembly language starts to be
introduced
as a symbolic way of representing the
programs and so an abstraction layer is
starting to appear between the physical
machine and the programmer so assembly
appears Auto code I'm giving Tony
Brooker a shout-out because he doesn't
get enough credit for being really one
of the first people to invent high-level
languages he worked on the mark one at
Manchester he invented the notion of
content associative memory and it was
still the Dean of my computer science
department when I was an undergrad at
the same time John Backus was doing
Fortran John McCarthy a little while
later doing Lisp and then Grace Hopper
doing COBOL interesting that all of
those so sight the reason they did those
things was because they were lazy and
they wanted to make it easier to program
the computer we also see the invention
of transistors and micro programming so
that you can actually use the computer
to load the programs in and do stuff for
itself
and by now we've gone up orders of
magnitudes with programmers and
computers still though a lot more
programmers than there are computers so
into the 60s another abstraction layer
starts to appear before now we only have
programs and computers and your program
is very much specific to that specific
computer that you're programming the
programs had to take into account all
sorts of things like the speed in drum
memory the speed of the turning you'd
have to account for those kind of
revolutions and timings just to be able
to read the memory horrendous so IBM was
building quite a lot of computers by
that and realized that it needed to have
some kind of portability of programs so
you could have a program run on more
than one machine so putting it operating
systems was the beginnings of this layer
of abstraction with os/360
and then we get people like Curt and
company inventing basic beginners
all-purpose symbolic instruction code
realizing that more and more people
needed we needed to program so it had to
be more and more people other than just
really big brain scientists and
mathematicians so basically was an
attempt to try and open it to the masses
more christian nigh garden are they and
I'll introduce similar 60s
as an alternative way of thinking about
it and that's introducing object
orientation and the guy with the hipster
beard there Edsger Dijkstra tries to
make programming more structured so that
people could actually maintain programs
going forward so we notice now that
people are starting to think about
programs having a life cycle and living
beyond just that task that they are
there for and most interestingly for us
I think Ted hatha Intel invents the
microprocessor the Intel 4004 largely
thought to be a distraction and
certainly wouldn't catch on and by now
again another order to order or two of
magnitude increase in programmers and
computers still we programmers outnumber
the computers so by the end of the 60s
and into 70 and I'm one and we have a
few more languages starting to appear
nicholas first having another crack at a
beginner's language with pascal alan kay
starting to develop small talk and
Thompson and Ritchie who in that photo
unfortunately looked like a weird
Siamese twin pair but they are actually
two separate photos together a
developing UNIX and C and IBM introduces
the concept of virtual machines on the
mainframe as an attempt to get people to
use the mainframe for more than just
batch processing and to be able to get
people to actually use it in an
interactive way didn't catch on problem
and by now we're up to a million
programs so in the 25 years in it we've
gone from a very small handful of
programmers to over a million and
hundreds of thousands of computers so
throughout the 70s we've got more
languages we start to see the full
generator generation languages appearing
as well and unix of course gaining
ground but also CPM emerges as the micro
computer operating system and decked
with their VMs and another abstraction
layer appears because now
suddenly computers are going to have to
start to talk to each other it seems so
IBM invented SNA has anybody had the
pleasure of programming in SNA nobody
going to admit to it is anybody familiar
with the OSI 7 layer architecture for
networking one person yeah so that was
like the most Byzantine way of thinking
about networking and the cheap and
cheerful poor man's approach was tcp/ip
and these two went head-to-head okay
for me that's the other important thing
that happened at the beginning of the
70s was those things that Ted Hoff
invented started to become interesting
and most technologies owned by Commodore
comes out of the 6502 zilog comes out
with a Zed 80 or a signed version of the
8080 and Motorola bring out the 6809
and these three chips suddenly cause
what I'm going to call the first
Cambrian explosion with the emergence of
first of all pet and the Apple based on
the 6502 Oh at this point can Olson the
CEO of Dec said there is no reason why
anybody would want a computer in their
home they missed the boat without them
so the first Cambrian explosion arrives
and now we see dozens of different
varieties of microcomputers appearing in
people's houses like me and we're into
the eighties more languages basically
refinements are the same sort of things
that have all gone before notice that by
1970 we'd done all of the inventing in
terms of thinking about how programming
languages might be like functional
languages with list with OO with similar
67 so we see more refinements of the
concepts and another abstraction starts
to become important because now we're
needing graphics interfaces they're
going to be portable so X windows start
to gain ground and the next generation
of microprocessor starts to a IBM
working with others introduces this
notion of RISC processors but the
processors are doing very well at this
time and of course go into the IBM PC
DOS appearing as a kind of hacked
version of CPM
the original Maxon based on the 68,000 a
few more interesting chips icon looking
for something to replace the 6502 and
the b-word and the amiga which rocked
everybody's world how many people here
were there when that boeing demo came
out for the first time maybe we might as
well just be the only tickets it was
like the world had completely changed
nobody's seen anything like that before
unfortunately Omega didn't succeed
what's also interesting I think is at
this point VLSI very large-scale
integration becomes mainstream and it's
no longer possible for people to build
chips by hand and drawing them on sheets
of paper and cutting out the maps from
now on we're going to have to use
computers to design chips which is kind
of sad so we're into the 90s the open
source movement is starting to emerge
and of course that brings with us Linux
as a contender for the dominant OS and
further refinements now we're picking up
the RISC architecture that got done in
the previous decade and we're also
looking for ways to make use of all
these transistors that we're getting a
year on year so FPGAs started be a thing
that might work in the future and then
TBL comes along and he invents the web
and what he did effectively was
introduced yet another abstraction on
top of the networking but to try and
make information programmable
effectively Korb is doing its damnedest
to try and define how computers should
talk to each other and we start to see
again refinements of languages but
coupling that in with this notion of the
web to try and make this information
programming more of a language construct
and at this point
Robert Manette cough the inventor of
Ethernet found with recom this is in the
middle of the 90s when you've got talk
about the information superhighway and
all that kind of stuff and he says
almost all of the many predictions now
being made about 1996 hinge on the
Internet's continuing exponential growth
but I predict the internet will soon go
tacular supernova and in 1996
catastrophic ly collapse well it didn't
and we got more and more languages
scripting languages to try and help with
building on top of the web and so by the
time we get to y2k we've got pretty much
the OS is the Wigan at sea for the rest
of our careers we're seeing other ways
to use transistors to use them as
graphics correct code processes sort of
borrowing back from those days of the
Vic and web services as a way of trying
to define how computers should talk
together so I just want to quickly go
back to 1970 because I picked this book
up I found this in a print room hoesley
which probably hadn't been read for
about 30 years and it's a fascinating
book I would really recommend you having
to scan through this it was written by
Gerald Weinberg in 6970 but published in
71 so he's talking about you know that
era and he was observing the difference
between the amateur and the professional
programmer and of course originally
there was no such thing as a
professional programmer there was just
programmers everybody was amateurs
effectively but as time went on we are
seeing these strata layers appear he
said which makes it the amateur less
aware of what's really going on
inside the computer and this is
interesting observation because Alan Kay
later on said if you're serious about
computers
you should really build your own and I
would highly recommend that and maybe
get a chance to talk about that later as
well we also interestingly as an aside
warned against some trends that he
thought you know might disrupt the way
programming happens in the future this
is 1970 remember and he was saying that
you know teams you really don't want to
have teams in silos you want them to be
able working together in fact you don't
want individual programs you should have
them pairing together you don't want to
be setting artificial deadlines and
you've got to be careful about how you
express goals you certainly don't want
to be measuring their progress and
getting them to estimate how long it's
going to take because that's just going
to make them lie and also you don't want
programmers owning a
program you want them to be a team of
multi-disciplined because it takes a
lots of different kinds of people too so
you need a team of multi-disciplined
programmers to own the whole thing sound
kind of familiar and then at this point
waterfall comes in is the way that we do
software and it takes another 15 years
to get rid of him 15:25 actually yeah
another interesting little observation
that I liked from it was also he made a
stab at what he thought the right traits
for a programmer were which I think
probably holds true today but I like the
the final thing as a good programmer
avoids problems just as much as they
solve problems but the saving grace is
that good programs are not made sorry
they are made they're not born which
gives stupid kids at school like me a
chance to be able to become a good one
so we're into the 21st century now now
Moore's law so far we've been eating
what was came to be known as the free
lunch where we were just piling
transistors are in each year and turning
the clock up each year and getting
performance hits and it was great and
that all comes to an end so yes we're
still getting more transistors but we
can't crank up a clock enough because
the thing would become as hot as the Sun
literally and then we can't cool it so
therefore we're going to have to keep
the clock down which is why we see
clocks sort of maxing out around 5
gigahertz so we've got to do more with
those transistors so we start to build
more cores into the same space I think
this one this is the Cell processor that
we did for Sony the PlayStation 3
because it was effectively at the time
we did it a replication of a
supercomputer on a chip same same
architectures we used to blue-jean our
gene folding supercomputer and its
ability to get more and more processing
by parallelizing work with a start of a
shift a parallelization of course
becomes a trend and so we're also
building super and computers by replic
taking things and this was IBM's
Roadrunner IBM Roadrunner in Los Alamos
containing lots of cell processors
inside it was the first supercomputer to
run over a million calls for the same
problem but it wasn't just
supercomputers and building
supercomputers in that way but we saw
people like Google capitalizing on using
commodity
however just scaling it out so making
things cheap replicatable and
replicating the hell out of them so this
was going to be a trend that then of
course gave rise to virtualization so
virtualization everybody else should be
very familiar now with how the
hypervisor works exposing the the
hardware up to a virtual layer that then
multiple OSS can run on top of and the
kind of variation then came along with
containerization which is effectively
virtualizing the kernel and variations
are those all as ways of squeezing more
power out of the same dye getting more
Portability and basically lowering
overheads of rising running applications
over lots of machines so this led us to
then having what started be called the
data center is the computer and it's
interesting to reflect that as we went
into deploying applications onto cloud
applications and the challenges that
then gave rise to DevOps it was very
similar to the challenges and the
tensions they existed back in the
mainframe days between programmers and
the operators of running the programs so
the programmer would get their program
in a box of punch cards they would have
to take it to the operators to load to
run and to provide the output so there
was this division this siloing and of
course that was a painful experience
that nobody particularly enjoyed and so
we solve that by making the computers
more programmable or meta programmable
so that so that programmers could
self-serve them themselves in running
their programs of course this is exactly
what we did with DevOps
we kind of did it by exposing those
discrete compute and storage and
networking components that you used to
be able to see and physical boxes in the
mainframe as virtual boxes programming
boxes in the api's building our software
architecture out on top of that and then
building higher order services that
would aggregate these things together so
the whole thing then starts to become an
ecosystem that programmers then use to
define infrastructure as code so now
we're not treating just our programs as
as code but also the program ability of
the computers the infrastructure
underneath it as well everything start
to become programmable everything starts
to become code and my goodness didn't we
take it far
I imagine probably everybody is using at
least one item from each one of those
major boxes this is a nice kind of thing
track tabs on github to try and record
all the different frameworks but it
really does show you the layer upon
layer upon layer of api's and everything
being treated as a programmable object
so whilst we're adding layers and layers
and layers of api's and programmability
remember we got all these transistors
getting smaller and smaller there are
programmable elements becoming smaller
and smaller commoditized flowing out
everywhere and so we now start to see
the emergence of the Internet of Things
so we see these things appearing in
virtually every device we have we see
them in you know in our networks in our
cars in our headphones in our homes and
buses and also then using those cloud
computing data centers to be able to
control and augment what's going on by
leveraging this embedded computability
this embedded program ability out
throughout the world
but of course the program model has to
shift a little bit now because we can't
use procedural kind of approaches too
much like that so we have to shift now
towards more of an event-driven
architecture which is interesting
because of course event-driven
architectures are what embedded
programmers have been used to for
decades as well so all of this stuff is
why we're coming into now the era that
we and IBM refer to as the B the
cognitive era and our approach of that
with IBM Watson is because the explosion
of sensors and compute and information
is just beyond ridiculous I mean these
numbers even if they were two orders or
three orders of magnitude out would
still be completely enormous what's also
interesting is that you know we have
gone way past that point where there
were more programmers than computers now
there are not only more computers than
programmers there more computers than
human beings and this trend will just
escalate and escalate which results then
in something like 75% of the stuff
flowing around that we're having to deal
with being unstructured and unstructured
data really needs a different way of
approaching it from our traditional ways
of programming and this is where machine
learning is becoming so popular having
the computer be able to augment how we
think of and deal with writing programs
and processing this vast volume is
clearly the way we're going to be going
for the next 10 years but just on that
path as we're seeing you know going
through bare-metal VMS containers we're
now seeing functions as service or
service architectures becoming the next
trend because in an ever-increasing
attempt to try and bring down the cost
of computing and to make the the
execution of a function as lightweight
as possible this function of service
model and we're using
the Apache ovum whisk project in bluemix
other other options are available as a
way of then making the discrete elements
of what it takes to build a complex
application in this kind of modern world
as lightweight as possible
couple that with lots of embedded logic
out of the edges and then using a
higher-order logic to be able to compose
these things together but for me what
really is interesting is the way this
explosion this democratization of
computer elements has really started the
new movement and this is what I'm sort
of going to refer to as the second
Cambrian explosion thinking about doing
the the the end of the 17th beginning of
the 80s that explosion of availability
of computers into a realm that never
would have dreamt even just a couple of
years ago that they would get their
hands on the computer same things
happening now with a whole nother
demographic of people that would never
have considered than to be themselves to
be interested in computers but this
democratization of digital fabrication
is really changing everything the
availability of additive or subtractive
manufacturing techniques how many people
have got a 3d printer in the room I mean
young - ok how many people have got a
laser cutter or a CNC machine a few a
few more
I bet lots of people have got my control
microcontroller it's like Arduino is or
anything like that yeah yeah yeah a
little bit more and DIY electronics
enabling people to literally build
anything from scratch in their own home
no longer they have to wait for some
corporation to manufacture something for
them to use now you can really make it
in your own home might be this is just a
little project that somebody's going to
go kick starting with to do printables
PCBs at home
the thing is this is also giving rise to
an increase in amateur robot assists as
well so not very long ago somebody
trying to build a robot at home would
have been a hopeless ridiculous task but
now everybody's doing it and I'm this is
a shout out to the the guys down on the
floor there in the the IBM booth doing
the mad scientist thing that group of
people are IBM is who are just doing
this for the fun of things you know just
interesting and this is my friend Luke
the Rozier's personal project Trevor the
robot he's french-canadian so in naming
in English probably and his strength
thing but sorry to anybody called Trevor
so he just got commodity pieces together
built the circuits built the logic and
he's using bluemix cloud services and
other services to be able to then do a
computer vision analysis to be able to
interpret what the thing is seeing to be
able to guide it as well so effect of
being an autonomous robot being
controlled by logic that is hosted in
the cloud wirelessly and this is being
replicated in all manner of different
fields and areas one of my favorite
websites hacker data is just an
incredible melting pot of creativity
there's people doing all kinds of stuff
with all kinds of different technologies
not just anyone in particular but it's
those mashups of things and it is
mashing up because again everything is
programmable I've noticed on the the
front of a magpie magazine this way I
got a Google build your own AI voice
record thing the recognition of the
importance of the hobbyist
the amateur and again going back to near
the early hobbyists in mid 70s the only
people using those 6502 or z80 chips
were hobbyists
like was MEAC and jobs okay they were
building their own computers from
scratch and this gave rise to an entire
industry I think we're seeing this in
multiple dimensions now in many
different kinds of industries and this
one I particularly like is something I'm
playing about whether that moment is
making use of those things that were
just coming out in the 90s PGA's people
are finding all kinds of really
interesting way to use them because they
are so cheap now a board like that you
can buy on eBay for 10 pounds and it is
incredible I'm using mine to replicate
early 8-bit micro computers systems as a
chip all just programming it using VHDL
so you see down at the bottom there VHDL
descended from ADA ADA was a language
that was introduced by the military in
the seventies because there were too
many languages by them and they needed
to standardize so they chose ADA as a
way of saying if you're going to work on
a defense project you're doing it either
so very good at event-driven processing
you've got a whole tab plant effectively
on your desktop when you're using FPGA
you can do whatever you like now
remember we were sort of going away from
specialized stuff to more generalized
stuff throughout the ages but now it's
easy to do that specialized stuff
because it's programmable on the
left-hand side we've got some open CL as
a way of building applications then that
you can just throw at multiple cores and
it be executing on those cores so you
can write the local and CL programs
which are basically in C compile them
and run them on your GPU without having
the horrible funk of having to control
and load up individually programs into
those GPUs or FPGAs or whatever
accelerator you have plugged into your
machine
and now just in the last few months
really we're seeing FPGAs become the new
thing in cloud computing so many of the
popular public clouds now have nodes
that include FPGAs and really beefy FPGA
done are available so you can not only
control your infrastructure as code at
the macro level your infrastructure as
code can also include that really
silicon level so you can for a
particular workflows whether it's
blockchain or whatever you can build
specialized accelerator logic and deploy
that along with everything else
as part of your cloud deployment so this
kind of brings me up to where are we
going now how many people saw the
keynote this morning from the guy from
Sussex yeah that was really pleased to
to see what Sussex was doing with
quantum computing so a computer
scientists we like to break up the world
into the set of problems the set of easy
problems being P as solvable in
polynomial time the set of hard problems
or non polynomial time solvable on the
outside those really hard ones as being
np-complete around the edge and of
course those hard ones and hardest ones
we just can't do anything with because
as we heard this morning with our
computers it exists today there's just
no hope of solving those times those
things in any sort of reasonable time
frame but it turns out that with a
quantum computer a good subset of those
hard and hardest problems sudden become
easy
so they suddenly become accessible
things that we thought we would never be
able to solve suddenly become
potentially solvable and not just
solvable but a problem that would take
thousands of years to solve on a
classical computer if at all would take
seconds two minutes our quantum computer
and as also mentioned this morning
there's a set of problems that
we couldn't even possibly address beyond
NP hardest like simulating quantum
effects suddenly becomes a possibility
and of course there are lots of
well-known hard problems that fit into
this space and become easy like
factoring problem you know the notion of
being able to crack that there's
encryption algorithm within seconds on a
quantum computer so quantum queues are
really good at doing search and as we
heard this morning
it has qubits and it'll bits it still
has the notion of zeros and ones
effectively what's kind of interesting
is you know in our classical computer
zeros and ones are still just
representations of a voltage you know if
the voltage is low it's a zero and if
the whole gauge is high it's a one
effectively the same deal with quantum
where we've got sort of energy levels
energy levels low then it's a zero and
if it's high as a one and then you've
got this weird thing called
superposition which is and everything in
between or both of them or everything
but nevertheless let's not worry about
that so much we've got bits so we
understand bits and then we can string
these bits together like we do in
classical computers we form registers so
you can form registers in a quantum
computer and using this weird stuff
called entanglement you can get some
relationship together and also as we've
explained and it's a really difficult
thing to get your head around or I find
it difficult is that it's not just that
with a register a binary register in a
classic computer can represent one
possible solution in a problem space at
any one time with the qubit register you
can have it represent all of the problem
all of the solutions in the problem
space at any one time so being able to
search the entire space in one pass and
get the measurement back rather than
having to iterate around is it this
compare and contrast is it this compare
and contrast etc etc in an iterative way
you can do it in this super parallel way
I did genetic algorithms when I did my T
which somewhat forward favor as well but
it seems to me this would be a perfect
technique for that because you had to
generate enormous gene pools of
solutions and then evaluate whether this
particular gene was was fit or not you
could do this all in one pass and then
when you measure the result it sort of
collapses back to a particular solution
and we recognize that the way that we're
going to use this is effectively a
quantum computer will be an accelerator
for a classical computer will model the
setup in a classical computer set it off
in a quantum computer and the
measurement returns the result but
what's interesting is it's still just
the same we have these logic gates
effectively we've got controlled-not
gate which is this two-bit operator
which is kind of the equivalent of a
NAND gate
effectively you know you can build any
circuit with a with a NAND gate
similarly with the C naught and you've
got this weird thing called a Hadamard
gate which sets everything up into this
superposition this kind of make it every
possible value but what I like is that
you're we talked about in quantum
computing you're assembling circuits so
we're right back to the beginning of
you're just wiring up a circuit how many
people have seen our quantum computer on
on the cloud so what was interesting the
the the Sussex guys are doing ion trap
we're doing a superconductor model in
the same way in sort of the the the
forties fifties it wasn't clear which
way to go with memory would it be fair i
core would it be sort of electron tube
you know vacuum tubes and it wasn't
evident which one was going to win for a
while we're kind of in the same place
you know there's different ways of
modeling qubits why we like
superconducting is that we can fabricate
the chips using our existing fabrication
technologies so you've got a little
magnification of a five cubits circuit
there that we print onto wafer we run it
at five gigahertz so it's looking very
much like our
Computers any trouble is we got to get
down to ten million to keep it stable
and keep the coherence so you ain't
going to see that on your desktop
anytime soon I'm not sure I my guess
without having any facts to hand is it's
like quantum annealing the same that the
wave does but which is kind of just a
kind of a not as effective but you get a
little bit of a boost I don't know what
I do know is that we've got to get we're
at five to seven bits at the moment we
need to get to about fifty cubits before
things become really worth doing but
we're seeing this 10 times improvement
our speeds every two years so we think
within 10 years we could see that sort
of order and this is what we've made
available on our bluemix cloud so that
you can write your own programs in
quantum assembly language chasm open
chasm you basically build these circuits
there's a visual representation for
constructing the circuits and doing the
entanglement and the Hadamard gates and
stuff or you can write it out in the
symbolic assembler over there you can
write that you can run it on a simulator
at the moment the simulator is quicker
than the real thing
but as we get more qubits that won't be
the case but you can run it on the real
one and you can basically submit it like
a batch processing it's like handing
your punch cards over an operator runs
it and gives you the results back
already there's been something like 110
research papers published worldwide off
the back of running experiments in our
IBM Q so going back to where I came in
at the beginning of this talk why do I
love being a programmer well I think
we've come a very very long way
everything almost everything we can
think of from the subatomic to the
global scale is programmable we've
reduced everything to being an API and a
programmable model
and for me it's still a magical
experience this is you know nothing
about technology this is about
creativity why now well at the beginning
was we saw there was no distinction
between user of a computer and
programmer of a computer there was just
the one person we saw this divergence
but with these Cambrian explosions we
see more and more people getting dragged
into and touching and being exposed to
the notion of programming the computer
we also saw this distinction between
amateur and professional yeah you know
going back to Weinberg's definition of
what made a professional you know not
understanding an amateur not
understanding what's fully going on in
the computer from from the electrical
level up how many people would consider
themselves to be a professional by that
definition today and of course more and
more people who never consider
themselves to be programmers are
programming also that distinction
between hardware and software
you know we added those layers of
abstraction yes but we're also back to
programming at not just the silicon
level but the subatomic level and that
notion of specialized and generalized
those initial computers being built
pretty much for one task going more and
more generalized but now realizing that
specialization is good for particular
problems faces and so being able to
incorporate that specialization within
the context of a generalized programming
model so I feel like we're stood
somewhere around about 1939 1940 you
know we've we've got a vision of where
we want to go we haven't got a clue
what's set in stone you know by 1970
we'd nailed all of the real problems
right and everything else was just
refinements and recursion and you know
sort of making it a little bit easier
but all of the problems although the you
know choices have kind of been nailed
we're not there with quantum
everything's still open and including
the programming models we heard that
call this morning to arms of people
doing more programming getting involved
with quantum computing
you could be another Claude Shannon you
never know but with all that blank
sheets of paper I would lights just
remember of run out of time I've got two
slides left creativity is stimulated by
constraints on the one hand over there
I've got this I just pulled this as a
wonderful example of a retro hack where
somebody ported slack a slack line to a
real Commodore thing people not just the
emulator so he actually interfaces to
slack very 64 and how many people have
heard about fantasy consoles a few
people basically these consoles recreate
what it would be like to create to
create a game in an 8-bit environment
artificially constraining you know the
number of colors size of the memory etc
and the creativity is incredible far far
better than it was in the 80s and
creativity is really important that's
why I got into being a programmer this
is a quote from Tolkien's poem a sopia
Tolkien considered that it was our
god-given gift to be able to create
still sub creators who refer to it it's
a part of what makes us human and Grady
Booch at a talk of the history of
computing museum said software is the
hidden writing of the whispers the
whispers the stories of possibility to
our hardware we are the storytellers
just one last quote I'll read it in case
you can't see it I've quoted a lot of
quotes that we really went bad when
Wireless is perfectly applied to the
whole earth though it's perfectly
applied the whole earth will be
converted to a huge brain we shall be
able to communicate with one other
instantly irrespective of distance not
only this but through television and
telephony we shall see and hear one
another as perfectly as though we were
face to face despite intervening
distances of thousands of miles and the
instruments through which we shall be
able to do this will be amazingly simple
compared with our present telephone a
man will be able to carry one in his
vest pocket
anybody know who said that Tesla and you
know when 1926 ten years before Turing
thank you very much I think I'm Way over
time so I don't know we're drawing on
there's a an opportunity so but grab me
afterwards and talk thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>