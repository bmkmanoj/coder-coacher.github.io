<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Do's and Don'ts with Java 9 by Robert Scholte | Coder Coacher - Coaching Coders</title><meta content="The Do's and Don'ts with Java 9 by Robert Scholte - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Do's and Don'ts with Java 9 by Robert Scholte</b></h2><h5 class="post__date">2017-11-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/tHTmFlVAyAc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right welcome everybody this will be
the last tool selection session for
today great that you're all here so my
name is Rob Jota I'm the chairman of
Apache maven and I'm do doing a talk
about the do's and don'ts with Java 9
it's there for I think about six month
or six weeks but there are some messages
I want to share with you let's see so
when two worlds collide so we have this
maven world and this Java world and with
up to Java 8 they were next to each
other may even running on Java 8 and
maven calling all kinds of things
together with Java and there were no
real collisions but right now with Java
9 you see that it's kinds of overlaps
with with maven and that's especially
the modular system of course so if
you're not careful with your model
modularization you can destroy the whole
eco maven ecosystem so this is the main
message I want to share with you library
builders so those are the developers who
are pushing really libraries to make
central they should be aware of the
impact of their of introducing those
multi descriptors and application bills
I'm pretty sure that most of you are
application builders they should
recognize these kinds of issues
so the whole discussion is mostly about
module names so what is a proper module
name and I'm pretty sure that everybody
recognizes because the first time you
work with maven you had to specify a
group ID and artifact that he well the
artifact he was kind of simple because
that was normally the the name of the
file but what is a good group ID so you
saw quite often that people chose to use
the group ID with exactly the same value
as the artifact ax T by the time you
recognize that people are more aware of
the meaning of group ID and
specify a much better crew body and that
it is not always the same as the
artifact ID in case of modules they must
be as unique as the coordinates of
dependency because it was possible to
put all those artifacts on a class path
and with a module name which is just a
name it it should be possible to do
exactly the same on a motive path and if
you know that the original idea is to
use just a filename that's coming with
collisions and I will show you that so
but let's first go with multi names with
numbers so we had a look at May Central
because one of the original IDs was dead
it was not allowed to end a multi name
with a number and in fact those who were
following the session of Vanguard
he said well you cannot do that well the
specification has changed and this is
one of the reasons why close to 30,000
group are the artifact combinations ends
with a number and you can split them up
into three kinds of groups the first
group I would call them the project or
products names so as you can see
especially Amazon is kind of thinking
about using names ending with a number
and it would be kind of weird if that
number would be removed or replaced with
the name of the number fabricate also
something H to it and especially the J's
are there are a couple of Jr's inside
maybe central and that would result in
just jsr and that's kind of where if
there were only one J's are allowed on
the motive path the next group are first
and libraries and we always come with
this example of comments length two and
three what they did is with comments
length two is that they had contract
they changed a couple of methods so it
was not compatible anymore with common
slang one so what I did is they
introduced a new artifact to D and they
also changed the package name and this
way it is possible to have common slang
and common slang to both on the class
path or on a motive path if they would
have removed this number it would be
exactly the same module and that's not
that's not allowed on a multi path and
the third group that's what I would call
the bridge libraries and as you can see
for instance the last one is a surefire
pretty sure everybody knows but surefire
and it has several implementations for a
specific version of j-unit again if this
number would be able to be removed you
would have a couple of modules with
exactly the same name on the multi path
and that would collide so after a while
and a couple of discussions that the
resolution was that they were going to
drop this proposal and they allow again
numbers at the end of a module name then
automatic module names so for those who
are not aware what automatic module
names are they are based on the vial
name so normally you add multi
descriptor and if it's not there and
here it says otherwise it is derived
from the name of the jar file well I'm
not sure if everybody is aware of this
NPM disaster which happens I think
somewhere in 2016 and they had the same
kind of issue there was an NPM didn't
had a namespace and so there was this
project it was called kick and some
other projects another company wanted to
use that same name and there was a lot
of discussion about it and there was no
solution because there was not so such a
concept as namespace to make this kick
library unique so what happened is I
think the original developer remove
these kick libraries and suddenly all
kinds of projects were broke and I think
over 30,000 project were broken so we
weren't the jigsaw team about these
kinds of issues so what we did is that
in October 2016 we got these statistics
from a central and what we did is we
took a list of all the group IDs and
artifacts at this and we were counting
where the artifact that he was not
unique so as you can see the the parent
if it's large enough the parent is used
in over four five hundred times library
it's over almost four hundred times used
so normally you could put all these jars
on a class path but you can only add one
on the module path okay so these numbers
are maybe a bit mixed because the these
ones are pom files so you can remove
these but all the others you can count
them up and you will get over or these
13,500 rows so may even always said well
we don't like this approach of automatic
module names it's it's just going to
cause collisions sooner or later but the
jigsaw teams team said well we want to
use it because it makes it possible for
application bill to adopt a jigsaw so
what what we did is what the jigsaw team
thought of is we need to introduce
something and that's called that's added
to the manifest file so what we what may
thieves assess is you should never refer
to a library that's just an automatic
module because that name can change
and for application builder you can
refer to it because you are in the end
in control if one of the dependencies
changes that's not really an issue you
can change the code yourself and the
multi descriptor so if you build an
application you will get the math
compiler a plug-in will give you a
message that you are using automatic
modules but it's just an info message
and we recognize an application because
the multi descriptor has no exports in
case of a library
it has exports and the math compiler
plug-in will give you a warning and it
also will have this box around it to
warn you about and the that it is
reverting to automatic modules so if you
are using maven 3 500 or 3 5 to
just-released
you will get a color support and you
will directly see these kinds of
warnings so we have this automatic
module names and like I said it was
there introduced for the ease of
top-down migration but what about the in
the middle library builders this is a
specification as written in the EHR 356
for the modular system and what they say
is they had large applications in in
mind well if you hear my story already
right now then you might think well
maybe it's not that easy for a large
application and what I think is when
they wrote this they had one one large
application in mind and that is the JDK
itself and that's quite easy because the
JDK itself has no external dependencies
or third-party dependencies and they're
all having exactly the same version so
it's not that complex as your normal
applications so this is the conference
example you will always see and I'm
pretty sure that you will see this
example too
or the day after and they will do this
example with my app and my lip and some
Jackson libraries well this and this is
nice to explain the concept of top-down
and bottom-up migration but it's not
really really realistic this is much
more realistic where you have this layer
in between with a lot of transitive
dependencies so let's go through an
example and see what's can happen so we
start with library a it's just an
ordinary jar no module description at
certain moment we have this library B
and it's it's just it's a new project
and it wants to use Java 9 so it's
introducing this multi descriptor it's
giving it a name and it says it I
require a library dot a because that's
the name of that jar so library a says
well I want to help the the Java
community and I will add a module
descriptor and I will call my module
called lip today now here we have a
library and it will depend on this new
version of library a so it can refer to
it by its name so it requires combat lip
today and then in the end we have this
application application D and it is
using both library B and C so I will
this look in the poem so here we have
the artifact D with AB D and it is
depending on both artifacts lip B and
lip C and if we translate that to a more
grow a visual graph it will looks like
this and with including the transitive
dependencies it will look like this as
you can see there are now two versions
of library a available so what will may
even do it will pick the first and drop
last one and while right now we have an
issue because this project won't compile
or run because library C is referring to
calm down lip delay and that's not
available anymore I hope everybody
understands this issue because this is
really the key message I want to give
you if library builders are just adding
in model descriptor the disguiser issues
will happen so we can also switch these
two dependencies so now we add first
library C and after that library B the
graph also see on top B at the bottom
and maple will detect that there are two
versions of library a it room removed
the last ones and picture the first one
and again this one won't compile because
library B is referring to of Lea is
referring to the library dot a and
nathan said well you cannot use it
anymore
because that module is called comment on
lip dot a even though you could say that
based on the file name the module system
could know that this could be some sort
of alias but again the J PMS says that
motor can only have exactly one name no
Scott there are no such things as
aliases so I hope you're all aware that
in this case library B is causing these
kind of issues so they came with this
solution you can add a mod and automatic
module name attribute to your manifest
file and what library B could have done
is it could have said this is my name or
that lip dot B so applications like
application you can use it but because
library a is not yet a module this is
all I can do and this will help the Java
ecosystem to faster adopt and this Java
modular system because libraries are
getting
even though they are not fully motorized
because of the lack of the requirements
there is a point of no return and that
has to do that once a module gets module
name a target remote you name that's
final and from that moment on you cannot
go back anymore so it if you take a look
at library see it was referring to
library a to that I assume this library
has back it cannot go back to version
1.0 because it has completely different
module name
so also be aware that once you are
depending on a library don't I should
pick the first library with the
introduction of this module name so a
couple of strong advices your if you
want to use this automatic module name
be sure that your project is Java 9
ready and that means no split packages
and no root classes I hope you're all
aware what Spectras means it means that
two jars cannot have the same package
containing a class and the next advice
is that you can help the Java ecosystem
to add this module name already in a
manifest file
however pick your module name with care
and one of the advices right now is to
use the reverse dns or this unique
package inside your jar and it makes
sense of course because because of this
package issue it should be unique on the
claw on a multi-part so why not use it
as the base of your module name so
mistakes will happen and in fact we
already had the first issue and that was
SMS six dot Oh Berta
and these are three jars and the first
one is the basic one with on file with
all the its dependencies the second one
is a fetch R and the third one is also
fed gr but there decompile
also contains the debug information this
made it quite hard to switch between
these dependencies and for that reason
we had a conversation about it and they
decided that there's actually no use
anymore to have these fetters anymore so
with a 7-6 dos oh there's only the the
main jar so tips for using Java 9 in
case of maven do not change the folder
structure it's not necessary maybe
you've seen a couple of demos where they
add a special motor name in case of
maven there's no need to do that because
every maven project will produce exactly
one module so just add an emotive info
file in the root source root of your
project
and you don't have to care about a
whether a dependency belongs to the
module path or class path so you don't
have to change something like scopes or
something like that we have this Plex
plexus Java library and what it can do
it can calculate based on module
description and all the jars which which
have them belong to the multi path and
which limit to the class path quite
often there are of course issues and I
would say first go to stay afloat to see
if somebody else hits some kind of issue
second go to the Apache maven Lane and
mailing list and third go to fetch me
that you may even giro to file a book or
an improvement and number 10 contact me
so one of the things I notice is on
stackoverflow is that if you are using
Java 9 you see this source and target
1.9 this means you are already using
Java 9 so I would say just remove these
source and targets and switch over to
Java 9 with release Java 9 this will
protect your application that it is
really running incompatible with Java 9
for instance if you were using source
and target 1.6 and you are using Java 9
it could happen that you are actually
compiling Java and code in your classes
and the compiler is not aware of it and
this especially this release option will
protect you for it
maven already has a solution for it and
it's called animal sniffer so I have a
look at it and it will preach prevent
that you are using different codes
compared to the one you're compiling
with so it's almost time for questions
but I'm quite aware that there are at
least two questions that you will ask
and one of the first is can F every
project become modular and the answer is
no and the reason is is that Java 9 is
really a game changer it introduces new
rules so if you compare the multipath
with class path it is in in a kind of
sense it's exactly the same thing but
multipath has added a couple of rules to
make it more stable so all the projects
based on Java 7 or 8 probably cannot
follow these new rules and actually this
fine because the class path will stay
there forever so I would say if you have
an old project you can try to compile it
on Java 9 but let's stay with
viii and don't add ammo to descriptor
yet once you start with new projects
that's the just a moment to start with
introducing these motor descriptors and
then this question is that's always the
the returning question will may even
generate a motor descriptor and I have
to disappoint you again no and the
reason is is that the the poem file and
the motor descriptor have two different
purposes the poem file is there to
specify the dependencies you want to use
and it will download it either from a
central Oriole it will pick it up from a
local repository whereas the modulus
grater it describes which are required
modules also not all modules are
dependencies for instance Java logging
and the JDK compiler so there is no way
to specify this in your palm file and
there are much more elements in the
module descriptor for instance the
module name whether or not this module
is open you have to specify the packages
you want to import and also specify the
surface if you want to so these are all
kinds of elements aware is and there's
no space inside the bone file to specify
it but yet Deb's can do it right well
yes it can do it but it's based on the
the binary code so we first have to
compile your code and after that
jaidev's can extract a rough multi
descriptor and after that you still have
to remove the packages which contains
the imple classes and etc so this
wouldn't be a solution and the third
reason is actually one I discovered
quite late but that this is about pom
hygiene which of one of you is cleaning
up its bomb and its dependencies quite
often I'm it's quite impressive I'm not
it's the first time I asked this
question there was only one hand and
that is actually the kind of
as I was expecting okay that was a small
room but anyway so the whole issue is is
if you would generate this depend the
the multi descriptor based on a bonfire
you would get all those dependencies as
well even though you don't use them and
the whole issue is that dependencies can
be excluded but requires multi you
cannot once they are specified there
you cannot they must be available on a
motive path so with the dependency
analyze goal you can go through your pom
file and maybe will detect which are the
dependencies dependencies which are both
used and declared and you have the
depends issue which are used but not
cleared so these are actually the
transitive dependencies and the best
practice is is to specify these as
direct dependencies as well and you have
these unused but declared dependencies
and this this is actually the ballast
and you don't want to add these kinds of
dependencies to your module descriptor
so now we have about five minutes left
and I have time for other questions so
who has a question in front
so the question is will who may have
some shall check if the motor name is
unique I don't think so it's not up to a
fish enter two and do these kinds of
things
so especially math and so it's not the
only repository there are a lot of them
in the world Magento is one of the most
use of course but Red Hat and Eclipse
they all have their own repo stories so
there's no way that we can check that so
it's just like class packages it's just
think of it if you have your reverse day
in DNS if the if that's in unique enough
your module name should be fine
somewhere in the middle I thought yes
licensing
okay so the question is its if there is
a thought about licensing of modules and
as far as I know sorry D the Declaration
of license is sorry no I don't think
that's that's something that has been
specified somewhere so it's just you can
specify it in a pom file and it can
indeed be copied into the manifest file
I think but there's no such thing as a
specification for it more questions if
you don't have any questions or you
don't dare to ask them out loud just
come to the front otherwise I would say
have a nice evening enjoy deaf Fox and
thank you very much
Oh</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>