<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Reactive Streams principles applied in Akka Streams by Eric Loots | Coder Coacher - Coaching Coders</title><meta content="Reactive Streams principles applied in Akka Streams by Eric Loots - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Reactive Streams principles applied in Akka Streams by Eric Loots</b></h2><h5 class="post__date">2016-11-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/n_q7sDTANFg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">morning everyone welcome to my my talk
about reactive streams principles
applied in akka streams
what about myself and maybe also about
this picture so this is a picture of the
Botanical Garden in Murano Italy any
people from Italy by accident okay so I
really can recommend a visit to this
garden what does this have to do with
the talk well in fact nothing it's just
my I like gardens and I like trees so
hence this picture okay so really really
cool so my name is Eric Lutz and I'm a
consultant trainer at light and joined
in in July of this year and have about
four years of scholarly experience prior
to that so we'll talk about reactive
streams and about akka streams so we
talked implicitly about akka in general
and this is kind of a quick view of some
of the the bigger companies that are
using occur today so what do we have on
the agenda first of all we talked a bit
about reactive strings in general the
story the the the history behind it and
the landscape and then about the
reactive string string protocol in
particular then we do a small intro to
akka and then we skip to the main topic
of this talk I think which is I guess
dreams and we'll do a demo actually the
demo which is showing you code is the
main part of the of the talk it's about
normally if everything goes right should
be about half an hour and then if we if
time permits we'll have a Q&amp;amp;A now if we
talk about streams it's a very
very broad concept and it's it means
different things to different people so
you have an abundant supply of
definitions available and so forth for
the sake of this talk it's important to
to look at what our definition will be
today right so what we what we have is
that we say that the string is a
controlled flow of data so it's all
about letting the data flow at just the
right rate so classically can have a
stream and stream processing and if you
don't have this second piece of property
you run into you know either having to
drop messages or having a lot of memory
errors so a bit about background of of
streaming that led up to finally akan
streams so everything started in around
2009 when we had the introduction of
reacts reactive extensions in dotnet
let's say four years later we had the
the reactive programming becoming more
adopted on the JVM and some examples of
that were or are the play framework
where a treatise were introduced it
actually II treaties solve this problem
of controlling the flow at the right
rate do you have a key io which as the
name says is mainly about covering the
IO part reading files reading from
sockets streams on sockets etc and then
there is a very nice API called RX RX
Java which was developed by Ben
kousonsan and so each of them have have
different prop properties and is sort of
our implement parts of the puzzle that
needs to implement the the desired
property of flowing at just the right
rate so for example play a treatise have
something that is called pull back a
back pressure and so it basically tells
can tell a sender or a or a provider of
data just to slow down basically at the
appropriate rate but it's quite to be
honest it's quite a difficult API then
we have akka IO so it also implements
back pressure using negative
acknowledgement so it does low live
low-level API it's used mainly in in
messaging its messaging API and then we
have our X Java which implements a nice
API so you have a fluent fluent way of
programming in it but unfortunately it
doesn't implement back pressure so if we
look at a treatise it releases some some
code so it was the released in 2013 but
it's actually a relatively complicated
API that doesn't permit you to easily
write applications okay it's not a
criticism per se but it's it has a steep
learning curve so basically the play the
academia
started looking at common concepts to
come up with something new so what
happened was like a coincidence of of
events for example if any of you have
followed the course principles of
reactive programming on Coursera any one
of you did that so I can really
recommend that course it's it covers
Eric Scala and and also akka
it's very instructive and so Roland Kuhn
and Eric Meyer met in preparation for
that for that course and
started talking about these problems
with streaming later on there were
meetings with other known people in the
industry like Victor Klein Ben
Kristensen Maori Marius Ericsson at
Twitter headquarters and so they coined
this new term called reactive
non-blocking asynchronous back pressure
okay it's a mouthful but that's that's
basically what they started working on
so what what are the goal of this of
this term basically you want to allow
users or developers to to work
asynchronously okay to basically apply
the principles of reactive programming
you should avoid blocking because it's
wasting resources and it cause can cause
all kinds of problems sometimes you
can't avoid it
okay but you in general you don't want
to block it needs to be safe and saving
the sense that it should implement back
pressure to control the flow from the
producer to the subscriber it's a purely
local abstraction and it allows for
synchronous implementations should you
wish to do so and by the way it's also
compatible with TCP because yes TCP is a
streaming protocol that implements back
pressure okay
so in 2013 more people stepped in and so
a reactive streams expert group was
formed with well well-known people in
the industry and Conrad malarkey
colleague of mine implemented the
technology compatibility kits for
reactive streams so this also led to the
release of the 1.0 specification and
five more than five accompanying
implementations
so also there is this enhancement
process in Java that is likely to be
integrated in the following version of
the JDK so that contains reactive
streams now if you look at the three
active Spree streams the specification
and the api's you would say well this is
the API Wow piece of cake okay let's
let's let's get going so you have like
an unmixed
that gets called when a new data element
is available and you have requests let's
say from the subscriber side that can
publish the basically the desire to send
to get more more data so it looks simple
but in fact it it it's not really
because if you have let's say two
implementations of reactive streams that
work together you have an async boundary
between them so you have back pressure
and you basically have a concurrent
protocol that you have to abide to and
so these are actually all the rules that
the producer in the subscriber have to
follow and that's what makes it
complicated and that's why you don't
want to use reactive streams directly
unless you're going to provide something
on top of that and you want to provide
high level functionality so if we look
at the goals of reactive streams it's
this avoid unbounded buffering across
asynchronous boundaries okay so it's
basically implementing the backpressure
things and it's its second goal
important is to provide interoperability
between different implementations of
different libraries so don't use
reactive streams directly and use a
higher-level library such as for example
akan streams okay
few words about
acha so akka is a toolkit that runs on a
JVM basically it provides for a way to
build concurrent applications so if
you've ever built
concurrent application it means like for
example in the past quite a long time
ago well it's still being applied in the
C world or C C++ world you can use
libraries like the threat libraries
basically okay POSIX threads if you've
ever done that you will know that it's
it's quite complicated then Java came
along you you have the concurrency
primitives like synchronized and atop
atomic variables etc etc it's very
complicated simple examples trivial
examples can be implemented quite easily
but if you start building real
applications it starts getting difficult
very soon so it's highly concurrent
distributed out of the box so it's not
an afterthought and it provides you can
build message driven applications
basically using akka and akka has
multiple components of which streams is
one but you can basically have actors
that's the basic building block you have
clustering and remoting so allowing to
communicate between different a
consistence on different nodes you have
cluster charting for scalability you
have a cap persistence that you can use
to implement event sourcing and there is
a kahin HTTP if so if you know if you're
familiar with spray a KH TTP is actually
a new implementation that achieves the
same effect and also very important to
point out is that the api's are
available both in Java and in and in
Scala and under something around the
corner which is akka typed which is
still experimental but it's expected to
be released
in a production version quite soon so if
you look at the actor model so an actor
model is a model of concurrent
computation where you have actives as
the universal primitive of concurrent
computation so this is a few a few of
the ideas behind it so you have an
active and basically you have messages
that are sent to the actor and the actor
can act on this message by either
sending another message to some other
actors or changing its internal state
which is unaccessible from the outside
in a direct way so it can change its
internal state and it can change also
its behavior so it can change the way it
will react to two future messages on the
fly let's say and of course an actor can
create other actors and you build up a
hierarchy of actors that implements your
application so it's a concurrency and
distribution country construct and each
actor gets an address its location
transparent and so what is important for
you if you program an active if you
develop actor code that is that inside
your actor code you can you have this
single threaded illusion so it's as if
you do you'd only really need to care
about walking stuff concurrency in
general okay so it's it's it's one of
the most powerful ways to implement
concurrent applications so here's a
small drawing of of how a typical
typical active interaction works
so these these these characters are are
actually actives in for example there is
an initial message that is sent to an
act
so it has a mailbox that contains
messages it's a first-in first-out
that actor may say well don't know
really what to do with this but I'll
send it to a specialist active that may
be able to take care of it so the
message is received it's sent to maybe a
set of workers in a basically set of
actors in an acting it works worker pool
and one of them responds and then the
this active in turn may send the
response directly to the original
requester okay so this is a typical
example how of how things flow so that's
a general introduction for akka and then
we have access streams so I guess dreams
are built on top of actors actors in
general so akka streams implements the
the reactive streams protocols right and
it has this type of model to build a
streaming application so we distinguish
things sources flows and sinks so a
source obviously it's a source of data
elements so it can be a stream of a
finite number of data elements it can be
a stream of an infinite never-ending
stream of of data elements so here you
see the it can it's hooked up to a flow
and the flow is a general message string
processor okay so it can do
transformations it can perform side
effects such as logging or whatever gate
and then finally you have something
which is called a sync which is taking
in the result and performing some action
on it maybe saving it all the data
elements in a file or sending it on a
pipe network pipe etc etc and we can
have a we have the asynchronous
boundaries it's as possible and more
about that in a second but the important
point is that if you implement a
streaming application
with akka streams you get you
automatically get the backpressure
for free right it's your if the sink
can't keep up or the flow can't keep up
with the source it will tell the source
a slow down okay
so typically if we don't have back
pressure what happens for example we
have a sink that is able to process one
message per second and a source that
emits tennis it wants to emit ten
messages per second well two things can
happen when these messages arrive the
sink and say well overflow I give up and
it just discards the messages that it
can't process alternatively it buffers
them it has a an unlimited an unbounded
buffer maybe but then what will happen
that is sooner or later you will run out
of memory and your application is done
right it's cooked so the way it works
with back pressure is that when before
this can happen this scenario it's
actually there's a back channel that
communicates back to the source that it
needs to slow down and you as a
programmer using of these api's don't
need to think about this basically so
with akka streams you can build up quite
complicated applications quite
complicated flows so here's a kind of a
generic example where we have two
sources we have two sinks we have a
number of flow components that process
the data elements and what you can see
is that you cannot only implement linear
streams but you can actually have
feedback in your system so we have this
flow that sends data elements to this
flow which in turn sends maybe combines
these with from this source with the
output of this flow and then sends them
to another flow but you see that there
is also a flow from of data between this
flow and that flow so you have actually
feedback
you can use and that will actually show
an example of that in the demo now this
is all nice so this is this basically
covers the basic principle of how you
would develop application but there's
also the element of materialization and
materialization is the following so if
you build a flow like like this okay
what you're actually doing is
programmatically is building a blueprint
so you're actually adding stages slide
flows and sinks and sources together and
it's actually not doing anything yet
it's just telling the system this is how
the data elements will be processed and
combined etc etc what actually happens
when you want to run it is that act in
the first step there is an optimization
taking place so it's actually not
immediately you could say the blueprint
that is going to run but it's a fuse but
it's called a fused version of it so by
default if we go back to this drawing
normally you would expect here to be
plenty of asynchronous boundaries right
when the string is fused these
boundaries are removed so internal
buffers are removed and the messages are
directly passed from one stage to
another okay and some optimization can
take place
so in principle it's gonna be faster
than with having the async boundaries
still there but important is that the
backpressure stuff still continues to
world work as seen from the you know the
inputs and the outputs of your of your
flow and then after fusing and
optimizations you can actually run the
flow and or the whole fused system and
for that you need kind of the engine you
know the gears that make the the thing
work and that is called materialization
so you needn't materialize which in the
end boils down to an actor and
underlying a thread of a portrait
basically a thread tool and that's
actually what gets executed when you run
your program if you want you can still
if you have a particular nature that you
can still introduce async boundaries at
any of this you know in between stages
at any point where you would desire to
do so okay all right so let's have a
look at a real application so what I did
is I wrote a small demo application
which is implementing an audio echo
generator and will use if anyone is
familiar with mathematics we use
something which is called or engineering
we use components that are called finite
and infinite impulse response filters
you don't need to run away it's not we
don't really will be doing any any
sophisticated math but that's the
underlying principle and while we're at
it will not only generate echoes but
will also try to cancel them okay and
for this demo I'm using kind of the
latest and greatest
I wrote the application in Scala so
we're using Scala to the 12.0 which also
implies Java 8 and we use the latest
version of a carriages I can't to dot
4.12 note again I really want to remind
you of that is that that I could have
written this application in Java right
so the library the akka streams API are
also available in Java should you wish
to program in Java so what is what is
the finite impulse response filter so
that's the bit of the theory so what do
we have here we have an input which is
stream of audio samples it's a digital
signal and you will see in the code that
every sample is represented as a as a
double okay so it's actually it's a bit
of a waste but it's a 64-bit
floating-point number and we'll run it
through this system that I will explain
in a second and outcomes for every
element coming in something comes out
right and what now how does this work
how does this produce an echo well we
built we use delay elements and a delay
element will be a flow element in akka
streams that takes a double and it will
delay sending it to its output by some
number of samples for example and one
here so if I put in a like a pulse on
the input the pulse will come out here
after n-1 samples then we have another
delay another delay so this signal in
total appears at this point after n1
plus n2 plus n3 examples and then at
each stage stage I take what comes out I
multiply apply it by some factor which
is a number smaller than one and we add
it together with the original input and
same thing here same thing here so you
can probably understand out that if I
put in a word like a sound like blah
outcomes blah blah blah blah okay very
very I think very simple to understand
of course we see a lot of repetition in
here that will help us in implementing
this so we see delay element a
multiplier and an adder
okay same thing here same thing there so
we could say that we need an element
that has two inputs and two outputs and
then we can just chain them together as
many times as you as we want
so the basic building block is until
it's something which we call a delay
line and the delay line as set has two
inputs
it has two outputs it has this
multiplier the adder and some constant
that we put in so we need to customize
that by having being able to create it
with two parameters the number of the
delay and and the and the attenuation
factor okay
so let's implement such such a filter
for example here we have put in some
real values like at the first delays
3,000 samples this the next one 1500 the
next work 4500 and I I chose negative
constants I could also have chosen
positive constants but it's here minus
0.3 0.3 minus 0.2 and minus 0.35 all
right so we'll skip to some coding now
and I'll also switch to to the PDF
actually alright so here's my here's my
codes and so initially I'll be able to
blow to make window showing the code a
bit larger in a second but actually I'm
using a system that allows me to step
through the different stages so I can
move to the to the next step and I get
my my code and we'll build it up step by
step so what we'll start with we have
some supporting code here that actually
is that readable I guess it is
yeah but I want to skip back to the
bottom part and I always use the zooming
function so if we let's move this away
okay so that should be that's bigger
okay so we want to implement the delay
line so what I do is I make a line delay
line flow which is a is an object and we
have an apply method that I can call
pass in so it's kind of a factory
methods okay that can that we pass the
delay and the scale factor right the two
constants that we talked about and I
have two implementations we will only
use the top one in fact but there is an
alternative implementation using a
mutable queue because we want the FIFO
basically and we are using a mutable
mutable state so in fact we have I'm I'm
using an array which is as a length of
the delay and it's initially filled with
0 0 double and I keep a pointer
basically that is you initially pointing
to the first element of the array and
then every time a sample comes in I
extract the sample from the e from the
array using the index I put in the new
sample and I increment the counter
basically and do that modulo the delay
so it's it's like a pointer that is
continuously running across the array
and then I create the end result which
is basically it needs to be of type
iterable and I have my delayed sample
coming out on the top let's say and the
calculated output which is the previous
output times the Delights sample times
the scale factor okay
so if we take this we can write some
tests if I take delay line spec so this
is actually a test that verifies the
proper operation of this delay line flow
and it's using Scala tests three by the
way which allows for asynchronous
testing and so what I do is I first
built a unit pulse which is a source
remember that starts with the
floating-point number one and I add ten
values of zero okay it's a finite flow
and then I write a test using free spec
basically that says okay the deal I have
my delay line and I build it up by
taking the input pulse and I map it by
you know creating the sample n0 and run
it via the delay line flow with 4 and
0.5 and then I run it so i basically
gets materialized here with a sink that
converts it to a sequence so out comes a
future that contains this sequence of
the result ok
and then I can extract very easily that
don't do that in production in real code
this is in the testing I extract the
future value and then I can say ok I
have my eye extract you remember that I
have two outputs now the delayed signal
and the delayed signal with the scaling
so I can say ok the delayed data should
be zero and then the one shifted five
one two three four and the delayed and
scaled data should be the same but the
scaling factor should be applied okay so
let's verify that if we
get our terminal window back and we run
the tests oh sorry
they should oops yeah can't zoom into
this window but anyway you see that it's
all green and that the tests actually
passed okay so looking back here what
we've implemented is basically this
building block okay
now building our F IR filter should be
sort of a piece of cake so if we move to
the next step and we look at our F IR
filters elements so we have remember
that the ley line flow I was something I
forgot to mention is that you see the
utilization of this flow stateful map
concat that's actually very crucial
because we this actually is going to we
have mutable state and if we wouldn't do
this construct we would run into problem
problems if we run this component over
multiple different materialized errs
they will actually you will have an
access a concurrency problem trying to
access concurrent state ok so that
wouldn't work but I can have I've now
some helper functions like for example
feel initial which takes a double a flow
of doubles and returns two doubles as a
tuple okay and what it does it takes the
input and edit which is the sample which
is a double and it returns a tuple
containing the two identical values i've
also a feel initial 0 that does the same
thing but only passes the sample to the
first output and systematically 0 on the
second output and then I have a feeling
select output because in the end
remember I have suppose I have my result
I still have my output at the bottom but
at the top I have something that I want
to discard basically and this is what
fill select out this it basically takes
a couple of two doubles and returns a
double and it does that that by taking
the second element of the tuple and and
returning it on the output okay with all
this in place we can build our filter so
let's open the source for our filter
let's zoom in so this is how it looks
like okay I can build my filter here at
the bot at the top so I say this field
based echo it's actually comprised of
the sequencing of a number of stages I
can say I start with a fit initial
initial remember which doubles out the
the flow the the samples and then I pass
it I use this via so I'm building my
blueprint basically I passed this via a
first Deline delay line flow element
with the appropriate parameters again
through the second flow a delay line
flow the third delilah inflow and then I
select my output I hard-coded some WAV
files in here I use a small library that
I found on the Internet to be honest I
didn't take the effort to go and
implement something with the java media
framework which maybe some people would
understand in the room but anyway so I I
use this welcome dot wah file and I
generate an output file and then I need
to have the you know the the engine
ready that's these these are these three
lines I need an what is called an actor
system on which the code will run I'm
using a dispatcher because I'm working
with futures and I need to create a
materializer
which is done here and then I can say
okay let's run that flow so I take a
sound source which I created from the
welcome dot path which is just
generating a series of double
I run it through the FI are based echo
this is not strictly necessary so but it
shows you some functionality that you
can use in the flow library in the
streams library I group all the samples
in of the elements by thousand and then
for each of them I write frames using
this small library that I found to the
output file and then because this role
runs asynchronously I then I get a
future back and what I do is I wait for
the system to do to complete and then I
sorry I terminate the system and then
complete I close the output file that's
kind of the mechanics that will come
back over and over again so if we take
this and we run it that's done and let's
look at so we have to show you this is
our input file welcome to the world of
Java sound with the new Java sound API
okay you get the picture I guess if we
open the result we get this welcome to
the world of down with the new Java
sound yeah you can control audio
playback for recording new audio okay so
we have two two signals here that were
processed okay let's continue we talked
about finite impulse response filters
but there is also an infinite impulse
response filter and it looks a kind of
the same but there is one huge
difference and difference is that you
you actually can see that this is an F
IR filter like shown here right and its
output here is actually sent back to the
input and added so what you will get as
say if I take the blahblah example it
will create produce an infinite number
of blahblah in the output that if my
coefficients are chosen right will
attenuate overtime okay if you choose
them wrongly you have built an
oscillator but that's another thing so
how do we implement it yeah basically
we've already got adders and multipliers
okay
and this is a joke by the way and we
need some extra tools like zippers and
broadcasts so let's see how we can
implement this we already have a basic
building block because we have the the
the implementation of the finite in in
finite impulse response filter so if we
go to the next step oh yeah sorry
there is one intermediate step where I
don't know if you want to go through
that it's it shows you the the
modularity with which you can implement
things so here I start from a list of
tuples that have the coefficients in the
delays right and I mapped them to a
filter stage and a filter stage is just
a class that contains these values and
then I can say instead of stitching them
together I can say built my F IR filter
from these filter stages and what that
means is that if we go to the filter
elements on this is the function that
actually does this so it's built if I
are I pass it a number of stages I pass
it an initial stage which has some
default value I check some I assert that
certain conditions on my inputs are
correct and then the way actually that
leads at one stage and each stage should
have delays of at least one okay and
then I can using folding I can create my
core flow so this is the chaining of the
delay elements by folding the stages
over an analyst an initial stage
and you see that I take the what's
already been built up and I add another
delay line flow and when that's done I
take my core flow and I I at the
selection of the right output in front I
put that in front of it okay
and I initialize the initial is the is
actually the splitter that duplicates
the data so I won't run this because it
will produce obviously the same result
but it shows you that now my application
becomes very very nice I have just the
specification of the stages and I built
the F IR filter from the stages so if we
now go to the next step we will see how
we can implement the IIR filter and what
we do is we need to translate this in
the world of a caste reims okay and this
is how it could be translated actually
this is not working but I'll explain
about that in a second so we have your
our input we have our output we have our
internal F IR filter and I use a zipper
zipper what does it it takes two streams
and if I have two elements on the input
it puts them together and it emits them
on the output as a tuple of values then
I have a I have to add these two
together remember if I look at this
diagram this is the adder and then I
need to send the result to the output
but also to the input of the filter so
this is the broadcast function that is
needed so for every input it emits the
same value on the output and you can
have broadcast with as many values as
you want in principle and then the
output of the filter is fed back to the
zipper now this one if you implement it
it
work actually theoretically it's correct
but it won't emit any any single data
element and the reason is is that there
is kind of a catch-22 in here because
the zip will only produce something on
its output when it has received
something on its on both its inputs
right now in order for so fine we have
an input signal great but we need to get
a first data element on this input and
of course when there's nothing coming
out
nothing will be coming out of this
either and the field internal field
filter will not produce any datum
element and where we have a kind of a
deadlock so how do we solve that
well we add some extra element and
that's the way it works we have a concat
string processing element and a kick
starter the kick starter is actually a
source that emits a single double zero
what does the con cap to the concat it
first starts looking at its first input
so in zero and it will admit to the
output everything that is coming on in
zero so as long as there's data it will
continue to emit it and in this case
there is only one value so that value
will come out and we have the zero that
we want okay because our anyway a real
filter is initialized everywhere with
zeros okay so that gets actually the
flow that gives the kick that gets the
flow going
so with that zero we're happy we can
this flows through we get the feedback
and because this one is stopped
automatically because it's only a single
element we will now have the flow going
like this okay
go into in one and cycling around and
that should work okay so how do we
implement that let's look at the code so
we see now in our in our coats here of
the filter elements there is a we have a
new function built III are okay which
does some manipulation because I have to
so we I I also built this IR filter from
a sequence of filter stages but then the
interesting thing is that we're using
the graph diesel that is available in in
acha streams and how does this work well
I pass it in this case I've I have a
factory method actually that I pass a
the feed filter okay and then I say okay
I create a flow from from from a flow
graph I have this start element remember
that is a source that emits a single
double zero
I have the concat and I add the concat
to the to the graph basically by doing
this is the Builder the the graph
builder so I say B dot add and I add a
concat
that takes a double okay then I have a
zipper I needed a zipper so I add a
zipper that takes a double that takes to
double sorry and I have a broadcast
function that takes a double and has two
outputs okay here I can specify how many
- how many outputs I want to broadcast a
result and then I have the other and the
other is basically a flow that does the
that takes a topple within and two
elements in and feedback and adds the
two together as a single double so it
takes in a total of doubles and it emits
a double and then this is the cool part
for clarity there's some comment that
this kind of implicit
and we can build up the flow we can say
start goes to concat so that goes to the
first the other goes to the first input
of concat we we have this DSL denied add
domain-specific language so this is
actually saying connect this start to
the input of the concat connect the
output of the concat to the input of the
first input of the zipper then he this
is actually a second statement I could
also put this on a separate line okay
but it wasn't done for that because it's
actually belongs together and now we
take the output of the zip we pass it
through the adder and we brought we send
it as the ink to the input of the
broadcaster and then we take the second
input exactly actually now the backflow
so you see the point the arrows point in
a different direction they point to to
the left
we take the output zero of the broadcast
we send it to the input of our internal
F IR filter and then we send it to the
first input of the concat and then we're
almost done we can say okay we're going
to create a flow shape a shape that
takes a double as input and a double as
output and the input is actually
connected to the input zero of the
zipper and the output is coming from the
broadcast the output one okay and then
we use this iír flow in the build ir
function to create our IR flow if we do
that so we can there's also I didn't
show the tests actually but I have some
unit tests to verify that on a on a very
simple sample but if we run this so if
we run this we will have a new okay I
need to select which one I want to run
so I do the RI IR and if we listen to
the result we now get this welcome to
the world of down
audio playback Ford report new audio
file so you may not be able to tell the
much of a difference but it's actually
containing lots more lots and lots more
echoes and then let's see we have only
ten minutes left
you could say now how could we do the
echo can echo cancellation part right
and a naive way to do it is say well if
I change to F IR filters together and I
swap around the coefficients and well
swap around I change the sign I do some
elimination right unfortunately that
doesn't work why doesn't that work well
if we go to the next step and can
actually I think I wrote this for that
yeah so if we if you look at this
if you look at this we have two filters
and one of them can it's very simple
it's only a one stage delay of two
attenuation factor minus zero three and
the second one is the same delay and
plus zero three okay and we run a unit
pulse again through the two filters
instead in sequence we convert it to a
sequence extract the value and now if we
and uncomment this and this is just to
show you the result instead of writing a
main program so I I check if the if the
fee response is just a one with five
zeros appended to it if I run this as a
test it will fail and let me see if we
go and it's open it in sublime may be
sorry
it's not much bigger you see that the
indeed so the the unit pulse comes out
but it should put you see that actually
originally there was there would be
minus 0.5 that's it eliminated so
there's the first echo is eliminated but
you see that there is minus 0 0 9 draw
this on a piece of paper and you will
understand why but the cool thing is
that I just want to show you the result
now we can ask have some questions and
some some closing out so if I go to the
next step the solution to create two to
eliminate the echo is it's here so what
we do is we start with an F IR filter we
build it we have it here then we use an
IIR filter but we invert I map it I take
the filter stages basically and I invert
the the sine of the coefficients and I
build an IR filter based on that and
then I run my IR filter my my sound
through the IR filter and then through
the F IR filter and let me first show
you that it actually works so I just do
it first through the IIR filter if I run
this program so if I run it I should get
the echos back to before so let's listen
welcome ok that's to be expected
now if I put back the the chaining of
the two filters and I run it
welcome to the world of Java sound
weapon and I have my original signal so
that's that's the demo part one thing to
point out did we demonstrate back
pressure with this with this code
well we actually didn't unfortunately
okay but if I would hook up the what I
wrote I would have a think basically
that interfaces to an audio stream in
like a JMS I would be actually the flow
of the data would be completely
controlled by the rate at which the
audio stream is consumed in the audio
framework okay
and that's basically my talk let's see
if there's a slide wise if there's
anything left yeah maybe some further
information so a lot of pointers to
interesting websites of course the
academisation
the reactive streams organization
there's this I can recommend it this
book by my colleague congrats mulaskey
who is on the core developer on the
rocket team you can get it for free and
then yeah get involved right there's a
gator channels for akka mailing lists
you can get to the sources and here's
also my mail address if you want to send
me questions or remarks and that brings
up runs up to the questions and we have
like four minutes left if anyone would
like to ask a question please feel free
to do so
on the part where you okay you mean you
mean this part right this part it best
basically what it does is that for each
materializer if you have it will create
an instance of of this okay so it has
its own private state and it will not
interfere with with other
materializations okay that's the that's
the short story you should read in it
probably in the documentation about it
more detail yes yeah of course but I
mean we only have an hour so the
question was this is all on static files
can we do this on live streams well if I
could do the demo where I generate the
echoes from a microphone but I hope you
understand that this probably would not
be a very good idea okay because it
would be bad for your ears but yeah it's
it's it is extremely fast because of on
for example the things that that take
place like like the fusion okay so it's
basically building one big functional
transformation of your of your data okay
I haven't characterized this in terms of
performance and by the way I intend to
also make this sample code it's not
really a useful application but it's fun
to play with as you can imagine on on
github okay any other questions we have
two minutes left
oh yeah yeah okay yeah so the question
is I see you using mutable state should
you do that because to be honest the the
person who asked the question is a Scala
developer and says it's kind of against
the it wraps against the how do you say
the hairs
something like that so you're you're
right in part but if you look at it in
essence there's nothing wrong with using
mutable state provided that you know
what you're doing and that you shield it
from the outside world sometimes it's
necessary for performance reasons okay
and you're right too that you could
implement this using purely immutable an
immutable implementation okay that's
perfectly fine but this one is most
likely the one that I shown showed is
probably the most performant okay time
is up I see so thanks very much for your
attendance and as I said if you have any
questions come and see me</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>