<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Hibernate you know it... but actually you don't by Sanne Grinovero | Coder Coacher - Coaching Coders</title><meta content="Hibernate you know it... but actually you don't by Sanne Grinovero - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Hibernate you know it... but actually you don't by Sanne Grinovero</b></h2><h5 class="post__date">2017-11-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/mJDqxfXyNdM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so we're going to talk about hibernate
you know it but you actually you don't
and so what I hope is that with library
which probably everybody has been
needing to use with one project or
another we can still surprise you or
teach you something new because you know
the project is far from that we have
immense amount of downloads every month
very strong interest and the team is
actively working all the time to fix
bugs that you are reporting improve
everything that we can think to improve
and adding new features now the problem
is that there is so much about hibernate
out there and there are so many blogs
and new posts that it becomes a bit hard
for us to know what you think we are
doing and I suspect also for you to
actually know what what's new in
hibernate so that's what we are here
about so I'm here replacing a model
Bernard who's my team mate friend a
colleague he couldn't come so I'm
replacing him but we work on the same
team we have been working on the same
team for a long time so we can go on so
what what do I hope you should take away
from from this is well I'm going to give
you like a general overview of all the
hybrid projects and what's in particular
what's new so that probably if you
already used it in the past and you are
we're stuck on an older version this
might come with some new features and
some new ideas for your projects to come
home now in particular how do you get
news about hibernate so I was looking
around myself recently and I figure out
like so this is something I searched it
on Twitter yesterday and it's like oh
wow Android I didn't know well of course
it doesn't but you know hibernate is is
there all the time on Twitter somebody's
mentioning it like I measure it like
more than once every minute so how can
you find when we are publishing
something new about it and the stress
goes on like we have JavaScript okay
that's totally new and then there is
people recommending it for beginners
apparently like your learn you're
learning to program you you're supposed
to know hibernate well that doesn't
sound retarded right now but it even
goes beyond like social media you are
learning how to do marketing on Facebook
or you have to learn about hibernate
first well that's flattering but I'm
afraid that's not really necessary know
about social media I'm probably doing it
wrong here like I'm not really finding
any of the information that I'm looking
for myself in the community and well so
Who I am I've been using hibernate for a
long time now has been contributing to
it in the past ten years initially on my
own time
and working for a consulting company and
since seven years today
this is actually my employment
anniversary working for reddit like full
time on all the libraries from you know
every workday some week there is some
evenings trying to figure out how to
improve something on it and I have lots
of fun with it so let's let's see what
we have recently well first off it's no
longer just the ORM we have now a full
portfolio of libraries which are
strongly interconnected to try to help
you with all kind of problems that you
might have working in a Java world and
having to interact with your data of
course you all know about hibernate or M
because it's been there for a very long
time you probably know about hibernate
search as well because it has been there
for about eight years now still it feels
a bit eclipse it from all the news
coming out about hibernate or M so it's
always a bit puzzling for us how do I
get the news to you like okay yeah
hybrid search as well no and it's really
useful most of the people I have in are
interacting is via hibernate search
because I'm that's the project I've been
leading more for the last seven years
and while we have hibernate validate or
hibernate OGM have
tools and some other experiments or
helpful repositories but let's focus on
hibernate or m5 first so who's been
using hibernate five or so that's not
many who's using all the versions yes
see that's the victor of liver habit you
have thousands of I wouldn't say even
comments because comments goes in the
fifty hundred thousand commits beyond
hibernate for hybrid three and so on but
we definitely have at least like six
thousand zeros of improvements bug fixes
beyond hibernate for you know going
forward so if you're not using hibernate
five you're really using older
technology which is slow problems some
to integrate with other libraries and I
would really encourage you to to upgrade
and here we're going to see some good
reasons to upgrade so one of the first
things we did in Auburn at five is
really clean up the bootstrap process
like it was very untangled we need to do
all kind of things from the classpath
point of view like we need to interact
with other libraries or the frameworks
counters of other libraries interact
with hibernate itself and of course we
need to load your classes probably load
some configurational resources you might
have some mapping and you know legacy
XML files other kind of sources
annotations on your classes so we need
to discover all these things and all
these different phases and discoveries
extension points custom converters that
you might have around became very
entangled at over the years while
developing new features on hibernate so
we had like a full cleanup of how its
booting and modularity had a lot to do
with this so we want hibernate to work
fine in whatever modular system you are
using or planning to use so whitefly was
one of them is one of them was GI is one
of them it was it used to be really hard
to get hybrids working correctly in West
GI because of all the class loading
isolation not isolations or not really
heavy
in designed up front and of course you
have a nine where we know it was coming
since a long time so I've been looking
at how models could help with with the
system now how does it look
the how does the new booster look like
you start defining service registry and
the service registry is a place where we
contain all the services that hibernate
will need to run so you can configure
this with an external file you don't
have to like there is a simplified
bootstrap API for this especially like
if you're using JPA you don't need to
know anything about this but it is
really useful to know this details so
that you can customize any of the
internals that hibernate that we use for
example you might have a different
connection pool in there you want to
inject it like programmatically so you
just create it and you pass it in of
course having a connection pool is
something that hybrids will need very
early during bootstrap because it means
to verify is this the database that you
told me we're going to use let me check
that is it like the right version and
depending on the version we're going to
maybe change the scheme of a verify some
things and after the initial setup has
been done we need to Reno validate is
your schema matching and you know the
rest countless of nice things that need
to be done but the connection needs to
be there is early on and then we need
metadata about what what your objects
are how they are mapped at what's the
schema and and we have plenty of sources
of metadata so you can add an annotated
class you can define you know you can
enlist a class by a full name or you can
just add you know static XML file
configurations again and after you have
defined a metadata which takes you know
the registry sorry then you can you
combine the registry in the metadata and
then you can finally get the session
factory started so this makes it much
easier for all the integration points to
actually know that we are starting in
the right order with all the rise
configurations of course there is Java
eight support it comes with all these
improve with date and time types
which of course you want to use now and
so you want to map this on your database
so we're supporting these today and well
we'll see later about what the generics
and auto-close come but so about date
and time initially we were not requiring
Java 8 so if you were using hibernate
5.0 you needed this additional may be an
artifact which would contain all these
extension points which were optional but
since hibernate over m51 we actually are
required to run on Java 8 so these are
TIFF these additional dependencies are
no longer needed its merge it in the in
the main project and of course these are
just some examples of the types which
are not supported out-of-the-box by the
by the main library now when it comes to
outer closeable this is very nice so of
course this is around since Java 7 and
it's just a more convenient way to make
sure that resources which need to be
closed it will actually get close when
you're done with them so you can have
this try you open the session in the try
block iam it means that this will
absolutely be closed you don't need to
explicitly write a final block I have a
funny story about this one we didn't do
this for a very long time until somebody
on Twitter asked me why doesn't session
implement outer closeable and we asked
herself well I don't know why doesn't
why doesn't it so it was a half an hour
conversation while the team like to do
how exactly do we want to do it and you
know five minutes coding and then we had
this new big nice improvement in there
and it was astonishing for us to you
know we've been using a seven for a long
time before we actually did this because
we hadn't thought about it and you know
it was your feedback somebody who just
sent it to it and okay I can do that
right you know I had the idea open and
it was very easy and of course so the
session is out to closable and of course
the stated session as well the session
Factory is out to closable as well not
sure if you're needing it and the
scrollable results also they need to be
closed so now they're Auto closable
which has an
side effect of you getting about big fat
warning and the idea is when you're on
actually not forgetting to blows these
things and that prevents um all bugs now
in hibernate 5.2 we did this additional
improvement that the session actually
implements entitymanager directly so you
don't have to deal with two different
objects to do like I'm what what are you
using hibernate native API sessions or
do you prefer entity managers that used
with two different things like an we had
entity managers was essentially like an
adapter of on top of our session to
implement the standard API that's no
longer the case now we remove it we
moved all the methods which provide just
features which are specified in the JPA
is back
they just implement the spec directory
so the JPA interface is no longer
optional you have to use it you can
still code against or hibernate session
if you prefer the api but this will also
implement the entity manager so you can
just assign it if you if you need so
well this isn't just a convenience
actually we have been working a lot on
performance and having an adapter to
wrap around the session really felt like
we're wasting your memory like why do
you need to have one additional object
just to rub something which then drops
the internal services and so we got rid
of that and we'll see some more of these
improvements have done like of course
this single improvement wasn't going to
make like a big change for you but we
have been working a lot on performance
and the combination of all these
differences are pre made a very big
improvement in terms of application
performance so we improved the bytecode
instrumentation a lot now especially if
you have been using these very old
versions of hibernate you might have
seen that you know your entities are not
really your entity classes so that is
like a proxy based on cg lib or some
other libraries like that it's much
smarter now I will doubt our
in practice you will ever see the
difference so we will never ever again
have bugs like that your class isn't
really the class it's meant to or like
it's declaring to be because you will
always ever have a single class
definition which is your entity and we
are not creating additional copies of
this because we actually modify the one
and only class definition this prevents
a lot of really complex situations and
just makes your life a lot easier now
why do we do bytecode instrumentation
the the best part is the well there are
many nice parts actually but another
really performance issue that you might
have seen when you have very large
complex graphs was the dirty checking so
when we are loading an entity you have a
list of properties that were loaded from
the database and then you make some
changes during lifecycle of your
entities and then at you know commit
time we need to verify what did you
change in which of the objects and you
know the objects which are detected to
be changed at how are they detected to
be changed we compare all these
attributes with the original copies that
we loaded from the database now when we
can do bytecode instrumentation on your
entities we don't need to keep around a
copy of the original date data and we
don't need to compare property by
property because we will just inject
some code in your entity which is going
to turn on a flag making sure that we
know this entity was modified and well
there are now maven and Gradle plugins
they use it to just be add and tasks to
perform this going to soon to see an
example of this and you can do lazy
loading of subgroups of your properties
so you can do just lazy loading of
collections or relations of your main
entity but you can pick some of the
properties of your entity and say that
typically you don't want to load these
properties at all unless you are
enabling the group and then we can
actually trigger the lazy load when
you're reading the specific property and
bi-directional management I remember as
a junior developer I was mad
hibernate like why isn't this automated
why doesn't it just work out of box well
it finally works out of the box so how
do you enable these features well on
Java EE we have some properties that you
enabled so it's by configuration you say
you want it enabled and then you can
pick which of these features you want to
be enabled you know in case you want you
don't like some of these enhancements
you can pick up to not enable them now
that's very nice it means when you're
running it in the deploy in container
like wide fly you don't need to know how
to enhance your entities you just need
to enable the feature and your
deployment your war your whatever what
you're deploying on your application
server as soon as the classes get
defined there will be motive modified
and the class definition is then the
only correct class definition it will
have the bytecode in there that we need
to perform this kind of magic if you're
not running in a container you have
these maven plugins so again that's the
group ID an artifact ID and then you
just say during your build of your
project you want your classes to be
enhance it and again you can pick week
which of these enhancements you want to
use and there is a similar thing for
Gradle very straightforward now going
back again on it
lazy properties this is an example so
you have this customer entity and we
have these accounts payable external
reference ID with this basic fetch lazy
it so this is a field it's not even a
getter we're not going to load that
field from your database unless you
explicitly tell us to or unless you are
going to read it then a second sequel
statement will trigger on the database
and we're going to fetch it
transparently so you don't know and of
course for a single UID that might be
overkill but you know when you're
loading large stuff like a blob image it
might you know improve you might make a
big difference on your application not
to not load a large set of data that
you're not needing Association
management
so this is I love this one
you have relation in this case let's
make an example of like the order so an
order contains multiple line items in
there and so we're creating one that
means you have to create an order you
have to create one line item and then
you have to add this line item to the
line items of the order and vice versa
you always have to remember updating
both sides of the relation now of course
this is this is just Java right you're
not even using hibernate yet so you're
you're creating two sets you want like a
set and a relation you want them to
point one to another you have to update
both sides it's plain Java SC you know
there is some that's straightforward but
it is annoying when this is a relational
connection it like the framework should
be able to help you with that so when
it's when it's enhance that with
bytecode instrumentation you don't have
to because when you are setting when
you're invoking the get line items from
add or Whistler's on the set it will
update the other side of the relation
automatically for you
so that you know you don't have an NP
because you forget to do something
simple like that
now speaking of bytecode enhancement in
the past we use the CG Lib that has been
long removed more recently were using
Java Syst
now we also have bite body as an
alternative Rafael who's like the white
body creator contribute it is himself
and that was really nice and we are
thinking that maybe in the future we
should just drop Java cyst which is now
the current pretty much default and just
switch to bite body the reason is there
are two important reasons one is it's
based on iesson so we've been monitoring
what java 9 was doing since a couple of
years who were on this you know tests
early versions of Java 9 program to make
sure that hibernate would you know work
on the day of release and something that
has always been breaking was Java 6 the
the team of Java cysts wasn't relieved
very proactively checking that it would
work at Java 9 as well so we were like
filing issues and finding issues and
they were very nice they were fixing
them so today Java cysts works fine on
Java online as far as I know because I
guess it's everything is quite new now
so it's not battle tested but I assume
is part of the epigenetic a team project
extended let's say extended open JDK
project so the people working on SM are
constantly making sure that item will
work with the latest version of JDK so
it is more convenient for us to maybe
you know rely on ASM than Java C is
going forward in filter now another nice
property of using item is when you're
using Java cysts your entity the
instrumented entity gets injected some
code which has references to Java cysts
helpers
that's nice makes the Java sees library
easier to maintain I guess but in a
world of modularity it means that now
your application when it's deployed it
needs to be able to load your assist
process while we want to clean up
dependencies like if you if you haven't
defined if you have your application
there's no need for Java cysts why it
should we inject this so if you're using
my body this dependency is only doing
the instrumentation phase and then at
runtime there is no dependency at all so
that's pretty nice
another new feature of hybrid Orion is
now it supports s AP Hana and that's
very impressive because it's not really
relational database but it's exposes
JDBC standard API so you can talk to
Hana
this is like an in-memory super data
great platform it it is this in memory
scalable analytics like very modern
database by ASAP and the DSP engineers
contributed many features too like
improvements to hibernate like improve
with special types to
be able to exploit the Hana and gin at
this and of course they contributed a
dialect so that now you can just you
know replace your another database with
Hana and just keep using hibernate as
usual it was all done by the contributed
by them some guidance of course but now
the second level cache improved
massively the the previous version was
allocating very expensive keys for every
kind every time we were needing to
access the actual cash making the lookup
in a cache actually a relatively
expensive operation when you are looking
at like high skill high performance
systems this was not negligible so we
improved these a lot by just internal
design using the newer tools that you
know might not have been available ten
years ago when the second level cache
integration was designed and so the
performance improvements are dramatic
when you're using caching for this case
it's highly recommended if you're if you
need to have good performance and you
you obviously are using second level
cache in that case then the the
improvements are making a very strong
difference now on top of this we also
support now integration with the cache
provider over the J cache standard API
and this was contributed by the eh cache
team so
traditionally in hibernate we have had
like mostly to second level cache and
integrations one was H cache contributed
by the H cache team the other one is in
Venus pan contributed by an infinite
span team both of them maintain their
own integration points and that's very
nice and so that means they also have a
lot of expertise on how the caching
integration actually is best done and so
now you can use J cache which means it's
easier also to plug or play with
alternative caching libraries I guess
you can use you know cache 2k seems to
be a good one hazel caste is another
option and you know any cache which
implements J cache is now compatible
with hibernate
so you can play an experiment now a big
feature is actually reference caching
now as I said before when hibernate is
loading something from the database it
needs to keep the properties that it's
loading from there you know it's just
columns so we're keeping this around
when you need to do the RT checking but
and verify what's actually changes and
now these columns are exactly what we're
keeping in the cache that means that
every time you're loading something
which is in the cache we will create a
new entity instance for you and populate
all these properties with the radio is
that we were getting from the cache but
that means a new entity is being
materialized every time you're hitting
the cache now in a world in which we are
really trying to minimize the amount of
data that's being allocated or run time
by your system allocating this new
instance is a cost that you actually
might want to avoid especially if it's
referenced data so if it's data like a
country you know it's it's always having
the same name you don't need to create a
new instance of friends a new instance
of Belgium every time somebody has an
address who lives in Belgium or in
France you can safely use the same
instance now by safe you use that means
it has to be immutable absolutely if
it's not immutable hibernate is not
going it's going to refuse to use the
caching by reference because if you make
any change - it means that this change
will be leaking to all the open sessions
it might be different transactions and
you know other transactions might see
this change which might be uncommitted
so that's you know that's on a safe
state and you know it's also bit illegal
in terms of the Java memory concurrency
it's not really visible correctly so it
has to be mutable and you have to enable
these caching options and you have to
enable the global option lose the
reference entries now a very big
improvement has been the documentation
it's pretty much been rewritten from
scratch like we throw away everything
and everybody who has been reading the
new documentation has sent us like lots
of things like apparently it's much
better so if you haven't done yet I
would really encourage you go to the new
website the website was also redesigned
and the new documentation is is much
better much clearer we also have a blog
it's indoctrination dot 2 so please
follow this blog because this is where
we blog about these new features when
they come out and obviously as we have
seen before you know even you know
searching on google searching on Twitter
you find a lot of stuff with a lot of
recommendations that I would never
really you know suggest myself we also
have well that's a little memo like how
do you get the session break from the
entitymanager
since now we are encouraging everybody
use the entitymanager since that's the
main entry point but of course sometimes
we are creating or implementing
something new which is not available yet
in a specification so to extract
actually the session interface out of
the entity manager you use the unrep
metal and now this is an example of new
nice feature set GBC batch size this
used to be an option which was global
for a session factory so it would set
what's the batch size to use for all
your GBC statements for the application
but so global not really interesting to
chew on for different use cases now it's
on the session so you can have different
use cases to moon differently let's
switch to the next project hybrid search
who ever knew that hybrid search existed
okay well not too bad but still we are
not there yet so it is about integrating
full-text search in your applications
full-text search is is pervasive like
all applications having to do with
humans humans expect to have like a text
box in which they can type something
really quickly and you find out exactly
what they mean or what they need
that means they expect you to compensate
for typos you know different ways of
expressing things mismatches of names
and all that and this is surprisingly
difficult to tune or get right from a
relational database so we use Apache
leucine which is right and does it much
better more flexible way and it's also
like a Java a nice Java library an open
source of course
so hibernate search is about helping you
translate button fourth your domain
design into the world of the Machine
objects which is based on documents you
see and text essentially so everything
needs to be transformed in text and
extracting tokens of text manipulating
these texts and calculating matches
around it more recently we also have
elastic search integration and going to
talk a bit more about that so so what's
new in hybrid search 5 well the the
biggest let's say 5.0 the biggest news
was that we were having a very strong
upgrade in the seen versions and the
nice part was we didn't change
absolutely anything in terms of API is
for you now it was still a major update
from our point of view because we
exposed to the same directory like we're
not hiding to see how behind some kind
of abstraction you seen it has a very
powerful rich query language well I saw
a query API so we want you to use that
and benefit from all the new stuff
two-seam is making all the time that
means that when we are jumping up to a
very significant upgrade in the routine
version that side of the API will be
different so your application needs to
take into the that into account but our
API has been surprisingly stable and
that's because we don't expose any of
the right methods so you don't have to
bother with writing stuff into seen
because we do that we listen to the
changes that you have on hibernate or M
site so you are making changes on your
database as soon as you commit we make
sure that we make these same changes in
the database and inducing index so those
Hynix is always like a represent
of your database state and then what you
can do on top of this is queried which
is of course the interesting part and
there we expose you like full freedom do
whatever you want with the index we did
a lot of performance improvements and
we're working on the whiteflies form
integration spring boot integration so
you know anywhere where you can run
hibernate you cannot run hibernate
search actually to enable it you just
have to have it on the class pattern
like hybrid or and will pick it up and
you have the additional capabilities
let's see a quick example this is like
trying to conflate some of the features
that it provides so what you can see is
this is an entity and then on top of
that we add its index at this this is
what enables how the leucine powers and
we also use the special extensions for
the indexing engine so the the indexing
is opt-in so you need to pick which
fields you want index it for example or
you don't see so this makes the the
field straight one to be part of your
index you don't have to include all the
objects that you're storing in your
database also in the index because they
might not be relevant for what you
expect people to search so we're making
Street one part of the index for making
city also part of the index and in this
case we are making it sortable which is
another notation and face it this
enables faceting queries on top of the
city what's in soon what what that means
and this is well a numeric field which
also gets indexes the numeric field is
actually optional but you can use it to
like force some behavior and we have
latitude and longitude well they don't
have to match the name of course but if
you have some numeric fields which you
want to have a meaning to run spatial
queries on top of them you annotate them
with latitude annotation or with
to the notation and that's tied up with
the spatial and you can embed relations
now in racine world there are no
relations it's a flat document but it is
a multivalued flat document so we can
embed and de-normalize your complex rich
data structure into the scene index by
using indexes embedded and contained
it's not going too much into details
because we have a lot of stuff now and
this is how a query looks like when
we're using the hibernate search DSL
helper the first thing you need is a
query builder and a query builder is
specific for the type you are going to
look at so in this case we are searching
we're going to search for addresses so
we take the query builder for the
addresses and then so this query builder
this is hibernate search code but what
you can see here is it returns an org
Apache Lucene query as I said before we
expose you to a loosing API and we
encourage you to use it directory so
that you're not locked in for advanced
features that we might not expose over
the cell so the DSL helps you for the
most frequently used cases of course but
you can also like just create a design
query directly now in this case what we
do is we create a boolean query so
that's the starting point to say I'm
going to combine three queries and
that's the three the way we have this
indentation here now the first query is
a spatial query we're going to say in
kilometers that we want this place to be
in a certain radius center latitude
centralogic - that's how you define I
want it to be close to this point in
space and this is a must note these are
boolean queries but it's almost like
fuzzy logic it's about scoring different
results now we also search on the street
name and we use a fuzzy fuzzy matching
on the street name that means typos are
acceptable of course the user who's
writing the street name exactly
right and this is like a perfect match
this will score higher in their overall
results but we were also like going to
accept things which are close enough to
it and do close enough definition is
what defines the fuzzy and we're also
going to assume that we're looking for a
dress which should this means that this
is like not a mandatory filter but we
would prefer the address that we are
looking for let's say we're looking for
an apartment here like and this is my
ideal apartment I wanted to be in this
area and it would prefer the floor to be
above the second because I like that
better now when you're going to query
like this this is going through your
your database in the index form and
going to match with all the results
which have most most similar so it I
mean it's going to give the results
ordered by score so the stuff which
matches most or is most relevant for a
user is going to be on top like you're
running a query you know on the Amazon
shop or on Google what's most relevant
means to be on top and so you can tune
all the aspects of the system to define
what's most relevant for your specific
domain this is how you run a faceting
query so we said on the city's field we
allow faceting and again if you think
about the Amazon interface on the left
when you run a query you have groups and
that this allows you to do exactly that
they need to speed up a bit sorry second
part of running the faceting query it's
a bit more complex because you can
define multiple groups so you want the
query like the results they will be
organized by lists but also in the
different groups that you defined so for
example by city or you know brand or the
things that you're looking for and the
nice part is you don't have to define
the categories of your groups in advance
because it will just infer this from a
date that you're hiring
now a simple query string is another new
feature of hybrid search now very often
you have a single text input you don't
want to have a big form and have people
fill in all the parts of the form you
want one search box and people type into
something and then you want to match
this text with multiple parts of your
index so in this case we're looking for
a book
war war piece with the two keywords that
the two keywords someone is entering and
so we take the query builder for the
books type and then we define we're
going to run a simple query simple query
string is actually the name is the
technical name and the Lusine project
for the kind of person that you're going
to use for this query so you could have
some more advanced elements into this
query and it will take that into account
but in this side this is your code so
this is where you are going to hint the
engine like which of the fields matter
of your documents that should match with
whatever the user is inputting so we're
going to say I wanted to match with the
title field of your the elements of your
documents and the summary but the title
is more important so we're boosting that
and then you run the query now the
return of these queries so I didn't
mention that before but was very
interesting so we're running these
queries on the scene index but to return
the list of books there they're loaded
we hibernate in a transaction and it's
managed identities with their full you
know all the data that you would have by
querying this data from the database now
elasticsearch it's all the same since we
hide you how we write things we can
automatically write in to elasticsearch
use you have to still provide the same
kind of schema so you're defining from
your domain model which of the fields
you need to be index it and when you
make changes we have the hibernate API
this will synchronize on the database
and on your elasticsearch cluster we're
supporting all of the elasticsearch
versions from two to five six which
is the last stable version so we're
trying to keep up with whatever they
release and it's just two lines of
configuration to enable these additional
communities you need to tell him which
indexes you want to store the
elasticsearch rather than on basically
scene so that's one line and then a URL
which points to the elasticsearch
cluster you want to use and let's go to
the next project because time is going
on
we have hybrid OGM this is our adventure
to have you store or use an e no sequel
store using the JPA api these are the
data stores that we are supporting today
one body boy works in Philly's pan works
in their mouth and embedded neo4j works
in a remote in embedded and we also have
experimental support for readies H cache
Cassandra and CouchDB now what works
means that depends exactly on the no
single technology because some of them
might not provide some fundamental
features that you need for example
MongoDB is notoriously non-transactional
that means that when hibernate you know
when you are using the transaction API
on the JPA or in your application server
it just means that we are not going to
flush any change until you commit your
business unit transaction but if there
are multiple operations that need to be
written during this flush there is no
guarantee that they are going to be a
you know applied all-or-nothing because
one could it be cannot do that on the
other side and finish pioneer 4jr for
the transaction also you're good at this
and for example if you're using neo4j it
means you can start writing things into
neo4j and use the transactions and then
you can access this the hql queries or
you can use the neo4j native queries as
well to materialize entities back out of
it so it started as a crazy idea it's
actually matching really well with some
of the non-sequel stores out there how
do you get started with OGM well you
need a dependency and the
tendency here so in hibernate or em you
might be used that it's one dependency
for any database you just have to be
good specific diet with OGM that's not
the case you need to actually pick a
specific dependency depending on which
database you intend to use so in this
case we pick the hybrid or GM neo4j
integration which will depend on hybrid
of GM core and some other libraries that
wheels and then in your persistence XML
you have to essentially change the
provider to the hibernate for GM
persistence provider and the
configurations you have to say I'm using
the neo4j one this is because you might
have multiple extensions and that's it
then you use GPA with normal interface
so we can move on to hibernate validator
what's new in your hibernate validated
phrase well of course there has been
bean validation - you know hibernate
validator is the reference
implementation of the standard so we are
heavily involved with this and there was
a quickie today here by guna my teammate
who's also the specification lead for
being validation so he has been diving a
bit deeper into it well it was a quickie
so not too deep but I'll just repeat
some of the key points the most
interesting part is you can now annotate
arguments on methods and make sure that
so this create user is no longer going
to be invoked if that user is not like a
valid and the nutrional user so this is
a new kind of validation and we are
extensively using the Java eight new
capabilities so that means repeatable
annotations support for the new types
and we can actually validate your show
in error messages to write the actual
name of the parameters that you're using
in the your source code and this is very
sweet I think so here we are defining in
this user as a as a validation
constraint we are saying that this size
here maximum 10 this is applying on the
list that means the world list as a
collection is not valid if it's larger
than 10 but we're also having
annotations in here indeed in the
generic section you see that so that
means that every single string which is
added into this list needs to be not
null it needs to be a valid email this
is a new capability that we couldn't do
before generating and well if you don't
like to pollute your classes with the
bean validation well this already
yeah the bean validation and rotations
we offer now programmatic API so that
you can set them up by configuration and
essentially also validation six is much
faster this is a comparison like an
operations per second you can find it on
our blog this was blocked last week so
it's very recent news we just finished
doing these benchmarks so the big blue
line is the performance of the last
version and then we have the previous
hibernate validation version and this is
the Apache implementation which hasn't
been updated for a while hey but it's
special did you know that hibernate
hibernate is able to query and integrate
with special types in your database so
there is a different with the difference
that you need to be aware of between
hibernate search spatial and hibernate
special hybrid search special uses
Lucene index and it only works in two
radiuses
so you want to find an address which is
close to a certain point you want to
find you know a pizzeria which has a
name that sounds like you know something
you ever heard so fuzzy matching of text
that works on a by distance base but the
hibernate spatial actually integrates
with spatial functions in the relational
database so that can use much more
advanced polygons and so it integrates
with the jts library to have an example
here we are storing the event and this
is a helper from the jts library in
which you can read you know some some
points and so you store this and then
you can do an HTML query
and then you can search for things which
are in some kind of complex polygon so
that's not just you know trigonometric
distance but in complex objects
hibernate inverse there is not much to
say except it was initially a very
welcome community project there has been
much more traction now so we actually
have now fully stuffed with people
working on it so it's finally getting a
much nicer improvement and what's next
hibernate six is coming we're working
very hard on this but it's still a lot
of work the internal we call it semantic
query model the internal way in which
queries are defined is completely
changed you have now this is going to
unify the representation of queries in a
way which actually has a purpose so it's
not just string being upended and they
generated but actually is a goal and so
this is unifying like the criteria API
the hql parser so it's both fasting and
generation it allows us to be to
generate much more efficient queries so
that we can actually optimize the full
shape of the output sequel depending on
your database capabilities there is much
more coming Jam Dex
annotation scanning will make our
bootstrap more efficient and it also
allows us to read your model without
attorney initializing the classes that
prevent some integration points for
breaking and we have Java 9 support and
better modularity so about Java 9
hibernate or M just works as long as we
update because the older versions won't
work I've been in validation the same
story hibernate search as well but you
really have to update to the latest
versions like we only completed
compatibility this summer and we just
know about issues with Java cysts and
other libraries if you're using even a
version which is one year old it's not
going to work nicely out of the box
might need to add some additional flags
but this is in classpath mouth in as
models it's a bit more complex in
particular there are issues with GTI api
cannot be changed into a model yet the
JPA api needs to pass us some additional
things and so it's going to be hard to
make hibernate ship actual java 9
compliant models because we depend on
these and there are no models for these
specifications available yet but as long
as you don't want to have hibernate
running as a model itself
everything is just working fine and we
have just one minute left for some
questions
yes please ok so the question is about
hibernate search and what happens if
elastic search is down while we're
obtaining to write to it now that
depends how you configure it by default
we consider that the search engine can
lag behind so you could configure an
error handle so that you know that error
happened and you can deal with it by
invoking there is a manual indexing API
so that you can repeat indexing of this
but there also is the configuration in
which you can request that all the
updates that need to go to the search
engine actually are part of a
transaction in this case we are using
JMS and so all the changes are actually
committed transactionally in the
database and in the GMs queue and when
the system goes up it should be
recovering from that this is not a
default because it has a performance
penalty and for most people having stuff
you know let's say you have a web shop
that something isn't appearing in real
time in your catalog or your catalog is
acceptable and they will just rebuild
index nightly there is a mass index err
which is
it's it's a job that will scan your wall
database and rebuild index from scratch
so some people just run this mass index
or Knightley's who compensate for issues
like like this one well thank you very
much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>