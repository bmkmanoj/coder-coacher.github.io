<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Debugging Java in Production on Google Cloud Platform by Patrick Flynn | Coder Coacher - Coaching Coders</title><meta content="Debugging Java in Production on Google Cloud Platform by Patrick Flynn - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Debugging Java in Production on Google Cloud Platform by Patrick Flynn</b></h2><h5 class="post__date">2017-04-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/tvfKmM4Esfo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to the debugging cloud
applications at scale my name is Patrick
Flynn I'm the Java tools tech lead on
GCP Google cloud platform and today
we're basically going to develop and
deploy an application on GCP and then
find an issue with it and debug that in
the cloud so this is a picture from the
good old days right I don't know how
long you guys have been in the business
but when I started out as back in 2003
hardware was very manual and when you
wanted to provision your hardware for
when you're ready to go to production
you typically had fill out a purchase
order work with some people in the
organization and wait six months a year
for some machines to be somewhere for
you to actually be able to deploy your
software this is actually a picture of
one of Google's first racks when after
the Google became a private company and
they actually used corkboard
to separate the motherboards and this is
actually worse than the first racks that
I worked with kind of surprising given
Google's reputation but it was cheap and
Google was a scrappy company and so that
wasn't the only bad thing about
developing java applications in the
olden days the other issue was that the
tooling really isn't wasn't where it is
today
typically deployments are like a manual
thing actually let me ask you how many
of you guys are actually developing
backends on Java right now how many of
you do your provisioning of let's say
configuring your production environments
by hand where you actually set up the
operating system install the application
server
No we've got a couple over here yeah I'm
not surprised right and and probably the
same people might be doing the
deployments by hand as well right once
you start scaling that's really tedious
and error-prone right today we have we
have better options right from the from
the infrastructure infrastructure point
of view you can actually provision a
hardware in a matter of seconds that you
didn't even need know that you needed
the day before you can you can benefit
from like fantastic physical security
for your machines great network
infrastructure always up-to-date from a
hardware refresh point of view but even
if you do go cloud if you're still
configuring your machines yourself and
deploying manually you haven't really
gotten all the benefits out of the state
of the art in Java tooling today so I'm
gonna cut the demo and give you an idea
of how you might run and deploy an
application at scale on GCP show of
hands again how many of you know what
spring boot is yeah from from what I
hear this is the platform of choice in
the community right now so what we have
here is basically a rest controller it's
it's actually almost a carbon copy of
the getting started spring boot app with
a few endpoints added to it I forgot
something
my notes so one of the cool things about
well I guess if you care about this kind
of thing about a spring boot app is that
typically you deploy these as jars not
Wars right make jar not war is the joke
that I hear often about this and what
what that gives you is an application
container embedded into your binary
versus you having to make sure that your
deployment environment is as you wish it
to be so so that's pretty cool right
but it's still a little bit of a hassle
to configure your your actual machines
to be to have the environment set up to
be on the right version of the operating
system that you want right so let me
just run this locally real quick we've
had a little bit more space up here if
you guys can see just gonna zoom in yeah
I know so he's really like high-res so
I've zoomed in like the actual text but
I guess I could change the resolution or
is this fine if I just kind of zoom in
like here okay all right so I'm gonna do
the local run another show of hands how
many of you use IntelliJ that's great to
see so we actually have Eclipse and
IntelliJ plug-ins for the Google cloud
platform what I'm showing you here is
not one of our features what I'm showing
you is basically the built in IntelliJ
Enterprise Edition spring boot support
so when you import the spring boot
project you'll automatically create a
run configuration for you I'm going to
go ahead and fire that up and you see
that the app is being built and in a
second it's going to come out so here we
go let's have a look at a few of the
endpoints I have I've got a really
simple hello world that tells us what
version
the application this is and I have a
visit endpoint that does something
pretty dumb it it takes data store which
is a automatically horizontally scaling
database that Google cloud platform
offers our users it creates an entity
with the current time in milliseconds
saves it reads it and then displays it
so let's actually try hitting that
endpoint so here you can see these in a
little bit this is the hello world then
we have the visit endpoint and this
visit endpoint is actually reading and
writing to datastore in the cloud from
my local machine so I find that endpoint
to be pretty boring like how could we
jazz it up right there's some pretty
interesting API is that Google Cloud
offers what would be the workflow for me
to actually start using one one really
neat way that I could make this more
interesting is if I just somehow
magically translated the text that I'm
displaying to the end-user so how do you
do that see the first thing that you
need to do is you know I was in the
right place is open up your palm XML and
add the dependency that's required for
that
so I'm gonna add gunk on google cloud
which is the namespace for all of our
API that are in github and the Google
Cloud translate API we're gonna pick a
point 9.4 alpha and now IntelliJ
automatically adds that dependency to
the class path of the project if I go
back to the demo controller I should be
able to create me it is this one
she will create the translate service
I think it's this one
and now translating the content is as
simple as calling translate string and
then let's see those eight options might
not be options so she look up the API
real quick
so you can find in our documentation
site instructions on how to use wait
believe this is a java talk sample not
what I was looking for
right so if you look here we can quickly
find how to select a source language so
we get translate option dot source
language so it's not options it's just
option in this case it's English and the
next parameter is the target language um
hmm let's see
I guess because we've got Luda in the
house maybe we'll pick French and next
parameter is by using this API correctly
oh maybe not
look real quick you've got okay so the
string goes at the front so let's just
grab this message first parameter that's
it in and get rid of this line of code
right here and we need to return the
actual translated text so do you guys
think this is going to work I'm not sure
after all that kind of hacking away
let's let's give it a try um so close
this out you fresh right I probably need
to restart my server let's go ahead and
do that
spring boot actually with the dev tools
imported will reload on on build but I
wasn't sure if they would do that with a
dependency change so I went ahead and
just restored the whole thing there we
go do you have new Co Java tools demo
that's that's actually a pretty good
pretty good translation and yeah I like
that but actually let me go back to the
API because I saw something that was
pretty kind of cool looking you'd think
I saw that you could detect the language
we would code here and it's late and
there's translate that's tech right so
if we go here and do translate that
detect we can actually pass in a string
and get a source or a target language so
let's try doing that by actually just
adding a parameter to our endpoint so
call it greeting
add a path variable so spring boot is
really popular because it's really easy
to manipulate your API and do these kind
of things so we'll call it I guess it's
just a string with called greeting and
we want to detect what language it is
what does ever turn us the language so
let's go ahead take that and make it the
target language
and if I just do a bill did that do bill
no here we go
if I do a bill we should see spring
restarting itself and let's see if that
worked so this page is not what you're
looking for because I've changed at URI
it's actually visit plus some greeting
when they say I see that's pickle
language hello and Japanese I knew what
this was of course but typing that into
my keyboard is not easy and just just
add that here let's see if this works
there you go
japanese response to japanese greeting
yeah that's pretty cool right so I kind
of love this feature so I want to get it
out to my users as soon as possible so
the next step is let's go ahead and
commit this so by the way I forgot to
mention the Google cloud tools for
IntelliJ has a bunch of support for
various Google cloud services let me
zoom in here if you guys ever have
trouble not with seeing something just
let me know we have the standard app
engine support that used to be available
in IntelliJ ultimate that we ported over
into our plugin that's also available in
community now except for a running local
dev server because those bits aren't
available in community for us to use
we support deploying to App Engine
standard and flex using the stack driver
debugger which we're going to talk about
a little bit later and cloud source
repository integration so with every
Google Cloud project you get cloud
source repositories that you can
basically create not sure if there's a
limit but a ton of code source
repositories within that that route that
project and then you can both checkout
and import into your cloud source
repositories from IntelliJ
so what we're going to do is we're going
to deploy this App Engine
so now I have a few things I need to
figure out right this is our deployment
UI the first most important thing I need
to decide is what am I actually trying
to deploy we support either a file
system jar or war the intellij artifact
system so if you guys are familiar with
IntelliJ and you are an ultimate and you
import a web project it'll automatically
generate a war artifact for you and we
also will inspect if it's a maven
project what maven build outfit is and
allow you to select that as your
deployment source which is actually
probably the best thing that to select
because your build might actually be
customized in some ways to go ahead so
if you're a great person that's an
excellent question we support you in the
sense that you can do your build in
Gradle and then you can select your
deployment target we're working on
trying to figure out exactly what though
so we have some support for inspecting
the Gradle build but it's more difficult
to identify the act the exact build
artifact that you might want to actually
deploy so we don't support it for now so
here I'm gonna select the project I want
to deploy to if you're not familiar with
Google ad platform a project is
basically a context right and the
network's are separate everything it's
sort of an isolated cloud environment
right so I'm selecting Java tools devoxx
we've detected that the App Engine
region of this project is us central and
we tell you here that the App Engine
environment is going to be flexible and
the reason for that is because you don't
have an app engine web.xml if you're not
familiar with App Engine standard you
need an app engine web.xml for it to be
an app engine standard out and over here
we're gonna override the version
typically the Cloud SDK which is the
Google cloud platform SDK that you need
to install locally to to interact with
the Google cloud platform from the
console will generate a time stamp
version when you do a deployment we're
gonna actually just pick a version that
we want right so we're gonna call it six
zero and we are not going to promote
this version I'm going to talk about
what promotion means in that right so
the and finally the last thing is
configuration so what would this is
about really is app engine flexible
environment is two things the first
thing is it's a really easy way to take
your Java or Python or Ruby app or think
ruby and deploy it to App Engine flex
without really understanding the
underlying infrastructure that's running
your application but the flexible
product wants to give you control so
that you can customize your environment
that's part of the allure of flex is
that it lets you install native
dependencies and things like that and it
does that by making the the deployment
unit container so if you select custom
you can actually specify let's say a
docker file and a PMO configurations
that determine various different things
so but for now I'm going to I'm gonna
leave it at auto and go ahead and run
that so what we'll do is we'll oh wait
did I know I didn't hold up
is there a way to cancel this probably
not well that's fine and I'm gonna do it
in kubernetes later so don't worry about
that
that what I wanted to do was commit to
my mice my my project repository because
it's a really bad practice to deploy to
production when the code is not actually
in a source of posit ori but we're going
to ignore that I did that because this
is a demo and so what's going on right
we built the maven artifact now what are
we doing well because this is container
based what we're doing is we're
orchestrating a docker bill that's going
to happen for you in the cloud you don't
need docker on your local machine you
don't need to know what docker is but
we'll look at the deployment target
which in this case is a jar and decide
well this is probably something that
we'd want to run on an open JDK 8
runtime so we take that a docker base
image that's pre-configured with to run
well on flex add your your jar and then
build that in the cloud so that's what's
happening right now it's a little slower
I don't know if you're familiar with App
Engine standard but if you do a
deployment and App Engine standard it
happens incredibly fast because you're
deploying two shared resources in App
Engine flex the underlying
infrastructure that's actually running
your app is like basic GCP
infrastructure so GCE instances are
actually running the code though so they
need to be provisioned load balancers
need to be brought up that kind of thing
so I know what you're thinking right
well maybe a couple of you are thinking
App Engine is this proprietary Google
technology I'm not really interested in
being locked in to App Engine that's an
important concern right
and this App Engine flex is not this
it's not a walled garden right the
reason is because the API is that you
saw me use don't require that you run in
the App Engine Flex environment for
those api's to be usable you saw me run
those locally and they work just as well
right the the base unit of binary that
you're running is a docker image that
you can take and run somewhere else as
long as it runs docker containers right
so really what happens in flex is is
more like a road a path that that you
that is laid for you where you don't
have to make too many decisions but if
you want to stray off there's nothing
stopping you from doing that so I'm
actually going to show you how to do
that first how many of you guys know
what docker is for a start that's what I
was hoping to see and how many of you
guys know have heard of kubernetes
before all right so if you're not
running your docker images on App Engine
or some other proprietary docker image
orchestration system you're probably
going to be running them in kubernetes
or docker swarm right so where does
kubernetes come from at Google we've
been running containers for I think
decades of definitely decades and we
needed a system because we run a really
large scale we built Borg
which is a precursor to kubernetes
kubernetes in for kudos was informed by
the design of
warg and open-source and now has really
gained a lot of curry adoption so what
we're gonna do that's is take the
application that we just deployed to App
Engine flex and deploy it to kubernetes
right so how does one do that well the
first thing you need is a kubernetes
cluster to target so let me go ahead and
create one so so G cloud I mentioned the
Google cloud platform style the Google
Cloud SDK so we're gonna g-cloud compute
container is a sub commands related to
containers clusters create we'll call it
demo app and we have to add scopes to
our instances so that they can talk to
the virus API is like datastore cloud
you bugger and Google Translate and that
I believe this is called cloud platform
which kind of gives you an an aggregate
of all of those so actually start that
off now what this is going to do it
takes around four minutes is sort of
bring up a lot of the same
infrastructure that App Engine flex is
doing but in a way that the kubernetes
master can target okay so alright so how
am I going to take the same app and
deploy it to kubernetes the first thing
I need to do is create a docker file so
that I can actually create a container
and deploy it another thing that I could
have done is taken the App Engine Flex
container which you can you can find in
Google container repository which I'm
going to talk about later but here what
we have is a plain of vanilla docker
registry based open JDK 8 runtime that's
oh yeah I'm sorry let me zoom in
here there we go
okay so it's OpenJDK base it's gonna
it's gonna listen on 8080 and what am I
doing here for the run w get this is
basically how we configure the cloud
debugger to work in environment other
than app engine where we've actually
configured this for you so we need to
download the cloud debugger agent and
then configure it as you see over here
in the Java agent path invocation by the
way the the cloudy bugger agent for Java
is on github and open source so that's
really cool because it means that the
cloud debugger is just this open source
agent talking to a Google cloud platform
debugger service that you can run those
jobs anywhere and all the different
pieces of the Google cloud platform that
used to be siloed and monolith and
monolithic part of the App Engine
standard environment you can now consume
those as independent pieces right so
that gives you a lot of flexibility as a
user the last thing I want to point out
about the docker file is when you're
running an app engine there's a model
but when you're running in kubernetes
you basically just have the the service
model what we want to be able to do with
the cloud debugger is identify the job
that that is running the same kind of
binary so that when we have an issue in
production we can listen to all of those
different jobs running at the same time
so what I've done here is basically
filtered into the docker file the
service name and the project version so
that when I build the image the agent
reports the agent the agents that are
all running as part of the same job are
all reporting the same key to the cloud
debugger master whoops
okay so the next thing that I need to do
is make sure that I build these the
soccer image right actually let me go
ahead and commit this so add awesome
transcript and they zoom in add awesome
translations and commit commit and push
all right so that's pushing up into
github which is another equal thing
because if you're an enterprise you
might not want to have your source on
Google cloud right that night you could
be you might want to have your private
github repo or maybe your own get repo
that you know nobody else has access to
right
if you're using IntelliJ to do to do
your diagnosis you can actually do that
okay so this is our pom right what's
special about it now that allows me to
build docker containers the the first
thing that you'll notice is that I've
configured the docker file to be
filtered by maven resources and I put
that in a directory let me zoom in a
little bit I wait I've created this
docker ready directory which is going to
be where the staged filtered docker file
is put in the target directory and then
I have I'm using this Spotify plug-in
which is a really popular maven plug-in
for Java users to build docker docker
docker images there's a couple of them
this is a the basic one that just kind
of follows a docker model where you
specify your docket directory that has a
docker file specify what your what your
image name is going to be what to
include in the doctor directory and I'll
just call docker build on that and then
the next thing that you need to do is
actually if you want the cloud debugger
to work is make sure that you package in
source context so source code so its
context is a way that we understand what
version of the code is running in
production if you use spring boot spring
boot will generate a get dot properties
file and that is source context we
actually have a build of the cloudy
bugger agent that supports that it's
just not available to end-users yet so
to get around that you can actually just
use the native source context file that
cloudy bugger supports alright and then
finally what you need to do is actually
build actually push the
dockerfile - to docker repository and
this is basically way the way that you
can do it with g-cloud with every just
like we provide a cloud source
repository with every Google cloud
platform project Google provides a
container registry with every Google
cloud platform project that is private
to you so if you are an enterprise and
you want to actually push docker images
maybe you don't you know to have a
docker hub account you don't want to
push public images you can now do that
using a Google cloud platform really
easily and that's free okay so let's
actually let's go ahead and do that but
one thing that I'll point out is that
I've bound pushing to our container
registry to the deploy phase so I'm
going to go instead of deploying the way
we saw earlier I'm going to go ahead and
deploy from a machine that is not my
development machine so that I know that
the source it hasn't been modified so I
can do get pull I'm in the right place
let's make sure
okay
what branch of my own
yeah yeah what do I have here
you think
well this is not the right version
because we've pushed the version that
has oh this is my hold on cat
that's right
so the version master should be okay
play if I go look on github it should be
Java tools DevOps
savage wolf devoxx right I'm not going
crazy here so why is it trying to change
now let's just get reset alright
and
yeah think using get in front of a lot
of people just like my worst nightmare
okay excellent
so let's just make sure that the
Translate API is my pump hum do I smell
yes okay good so that's actually deploy
this so maven ploy unless I forgot
something no bull skip test is that
thank you come on baby
excellent so one other really cool thing
about this machine not being my
development machine is that it's
actually a GC instance on Google Cloud
with really fast networking eight cores
and 30 gigs of ram so it's gonna push
this to GC are a lot faster than I would
have done if I'd done it on my laptop
over Wi-Fi let's see how fast it does it
doo-doo-doo-doo it used to be like 15 or
16 seconds yeah so 31 seconds that's
around like 10 times faster than when I
do this on my local machine so what what
I could also do by the way which is
really cool and part about that story
that I was talking earlier which is that
the individual building blocks of App
Engine flex are no longer this
monolithic piece the ability to build a
docker file from from the cloud is
something that we expose as a separate
service that doesn't need to be used
with App Engine flex really easy way to
do that is to
whoa okay my it's the zoom level that I
think is screwing up my shell so this is
what it would look like g-cloud
container build submit - tag right you
just have all you need is a directory
yeah all you need is basically a
directory with your docker file and your
jar and you tell g-cloud that you want a
g-cloud container bill with the tag that
you want the registry to the the tag you
want to use to push to the registry and
they'll all happen in the cloud for you
so no no longer do you need a local
docker install on your laptop or on your
Windows machine which is pretty cool all
right so we've pushed this this code to
kubernetes right and let's take a look
is it really there
so here's know this is a data store
here's your container registry
so there's two minutes ago v5 on did I
not change the version to V how damn it
okay this was an important step because
if I don't change the version to version
6 V 5.9 is is actually a version that
I've pushed to before so I have to
change it real quick because otherwise
when I bring this up in kubernetes it's
actually going to use the old push that
I have that might not have this code so
let me just do that real quick stato
and commit that so and actually let's
change something else change the demo
controller should say report said Oh
updated version just six commit and push
fortunately we've got our superfast
build machine to actually recreate this
container so it's not going to slow it
down too much go back here first you
first you want to get pull and then
that's redeploy so while that's
happening what are we gonna do well we
can't do much because because we need
the image to actually start kubernetes
and that's what I want to show you next
yeah let's see how long this takes and
that we have a sip of water how are we
doing for time by the way all right I
got a speed-up okay so 24 seconds so now
let's go back to container registry and
v6 auto is there so how do i how do I
actually run this all I have to do is
I'm gonna skip typing because we're slow
in time and coop control over run on
exchange with version to 6 so after you
guys are familiar with coop CL or COO
patrol or whatever you call it this is a
command that you actually target your
cluster with an image with and go ahead
and start that so deployments been
created but this is not app engine flex
this is kubernetes so now there's still
some extra steps that I need to take so
that people can actually hit this
service from external IPs
so what I'm going to do is create a
service by exposed a deployment so this
is the deployment that this is a cube
CTL exposed command which creates a load
balancer that external IPS can come
through I'll go ahead and start that now
that takes a little time so I see your
worship
until service so we can see here as the
internal cluster IP that I wouldn't be
able to hit from my machine and this is
the name of the service demo app right
here and we're provisioning an external
IP which takes on the order of a minute
or so hopefully no more than a minute
because we're short of time
question on on kubernetes I don't
actually know the answer to that
question does anybody in this room no I
guess not no I'm at least in good
company okay so we've got an IP let's
check it out
this better work
what is going on man come on come on
baby not supported well let's just check
the pause real quick the image pulled
back off I don't even know what that
means the image pulled back off
did I give them oh you know I did look
check it out
you see this I mean you can't see my
cursor this is not the right version I
should be V 6.0 oh thank you
now you tell me you're wondering okay
there we go
I have to know I have to edit the
deployment let me go edit point down a
half b5 b6 of course I have practiced
this too many times
okay
there we go so what did I just do I
actually really cool feature of Coon
Eddie's when and edited the
configuration live when Cody sees that
I've respect the service it will bring
down the pods and bring up new pods with
the version that I want right so if I go
pods here is creating the container
that's actually scaled this up real
quick um because by default when I
create a UK cluster it creates a cluster
with three nodes I should at least have
three replicas right then go ahead and
do that one if I can do that while it's
restoring the cluster I guess so there
you go and we've got already a running
instance see if we can actually get that
to serve
yeah there we go fantastic so hello oh
wow we know that's a visit hold on and
we get a Spanish answer right that's
pretty great and we're running out of
time so I'm gonna skip a really well you
know I'll show you really quick that the
App Engine app that we had is also
serving here because because sometimes
you need this right when you're using
kubernetes but sometimes really all you
need is this and that's when you want to
use App Engine flexible environment so
here we have a pinch of flex let me
refresh and we can see that this version
600 is deployed so you might remember
when I did deploy it that I hadn't made
the version change in the label so if I
actually look go and hit that endpoint
it'll save you 5.9 but I think if we hit
if we actually do visit whoo I don't
know very many languages guten tag that
sounds like good is that spelled
correctly yep well it gave me a some
kind of translation I don't know what
language that is okay so remind me what
was I doing okay I was showing you the
scale App Engine here we go really nice
part about like back in the day when I
do did a deployment onto with a new
version of our of our code to the
servers I was in a deployment we had
downtime right maybe it was during the
Saturday maintenance window that a lot
of companies used to do and still do but
isn't really the way to do things today
and I if there was an issue it was an
issue for everybody on the new version
and then we had to rollback right App
Engine flex provide and standard
provides the idea of versions which let
you do really cool things like okay I've
deployed version 6 but I didn't promote
it which means that I'm not sending all
the traffic there so what I'm going to
do is actually
split the traffic let's send you know
12% of traffic over night and that means
that 12% of the people that are coming
in are gonna be on six I I'm probably
not gonna hit it so I'm not gonna bother
but let's go ahead and actually move
everybody over to this new version
migrate
they're really really useful thing that
I'm just gonna do
as fast as possible with App Engine flex
is that with kubernetes I don't even
know how to scale like I know how to
manually scale-up
but I don't know how to figure out
what's going on with my service know
that there's an issue and start scaling
up with App Engine flex it's really
straightforward I have an endpoint here
we'll call it
let's just go to Java tools deadlocks
because all my traffic is going here now
am spot.com low at this endpoint which
is really hard on the CPU right it spins
over the current time generates a hash
and looks for one that starts with zero
zero so much apparently is what what
Bitcoin does I that's what I'm told and
so really what I want to do is I'm going
to generate a bunch of load against that
using Apache bench let's go ahead and
start that and you have to be patient
because that's 10,000 requests 20 at a
time hitting the backend and while I do
that let's talk about another endpoint
right go quick back go back to
kubernetes we'll go I think it was
called hello developers and he zoom in
all right
do you see anything wrong with this
endpoint correct this is not Firefox
although that's a great browser I'm
actually using Chrome so something is
wrong with my code in production and
this is on the kubernetes cluster right
so I spent you know plenty of time in in
my like days working on managed
infrastructure infrastructure trying to
figure out what was wrong in production
because I couldn't actually reproduce
the issue in in on my local machine this
isn't actually a really good example of
that the less
actually see how the cloud debugger can
help me solve this problem right so the
first thing I want to do is is actually
look at my code so this is the endpoint
it looks at the user agent checks if
it's Mozilla and responds Firefox so
that actually makes a lot of sense right
so let's actually this go to the cloud
you bugger select debug and here we can
pick our target these are the App Engine
flex instances that are running but here
I'm going to pick the kubernetes
instance so this is interesting it's
actually looking at my current code and
seeing that the version doesn't match
the version that's in the deployment oh
yeah I'm sorry alright so that's really
cool because it means that instead of
attaching a debugger to code that is not
the code in my current workspace or
slightly different where I'm setting
breakpoints and when do they get hit the
values don't make any sense I'm actually
making sure that the code matches the
actual breakpoint so let's go ahead and
attach to that
and that's set a breakpoint hopefully
you'll stick the checkmarks usually
means that the back end has like
received the breakpoint set it on all
your instances and confirmed that this
is a valid breakpoint now we have three
instances running right so I can't
guarantee which one is actually going to
serve this request but if I actually hit
it
come on demo gods did I this is the
endpoint
so that's if you look at the code the
only place where Firefox is set is at
this line so I'm assuming it has this
line had to actually execute this is see
am I connected to the right let me try
making sure that I actually connected to
the right version and not to aperture
flex and set go stop listening go back
okay that's what I want though is that
what happened so if I said this here
let's try one more time did it done come
on baby
yay a new snapshot was received right
now I click on that we're gonna retrieve
the data from the from the database and
actually tell you what was in the
request and you can see the user agent
right here and the user agent for what
for my Chrome browser let me zoom in
turns out it's starts with Mozilla right
and that's because browsers are whack
and the web is whacked and I'm sorry if
you work in the web so that's pretty
great but you must be wondering well how
the hell does that work right because I
can't set a breakpoint in production
because that would affect user traffic
right the fact of the matter is we are
agent stops the threat of execution at
the line you select captures all the
state and then lets it continue and it's
extremely inexpensive we use this in
production at Google and it doesn't
really affect the service in any way at
all also one thing that we do is we only
capture one sample right the first time
this happens we'll capture it and then
we'll we'll disable that breakpoint so
we don't interrupt any other traffic one
thing that I you know I've got seven
minutes left I wanted to oh the other
thing let's go back to App Engine flex
which we just like hammered with a bunch
of Bitcoin mining stuff let's have a
look over here and see we've got the
instances we've got look twenty
instances of our service running that's
the default max instances that you can
configure by default it's 20 you can you
can make it higher there are App Engine
flex deployments that scale to the many
thousands of instances now let's go back
a really cool thing that I really like
to show people because it's if it's
people's workflow really well and it
matches the use case a lot a lot better
than a traditional debugging session
where you kind of end
and exit is let's imagine that I'm
actually making changes to my code right
maybe I'm working on version 6.7 right
and I'm changing the translations you
know it's just maybe adding some logging
logger info bah blah right and now I
found out that I have actually this
missed bug in production when I want to
connect those them again you've seen
this right we make we give we make the
code match the version so we see we're
back on v6 Auto the logging statement is
gone but the odds are if this is a hard
to reproduce bug it doesn't happen
within the time that you actually set
that snapshot into session so you want
to go back to work right so we've reset
the snapshot and I'm going to stop and
so instead of telling it to stop
listening I'm going to tell it to
continue listening I want to
so we've stashed your changes we've
restored them so you code is back to
where it was version 6.7 you've got your
logger info you go back to work maybe a
week later somebody triggers this bug
what happens you get notified in the IDE
and you can continue your session code
goes back to the version that's in
production and you can actually inspect
the state it's pretty while
no unfortunately you can one one way
that I've seen people actually try to do
this is setting tons of snapshots like
one after the other which you can do it
works and there they are they're working
on improving the experience so that we
can support more of these kind of yeah
it's pretty tricky right like if you're
talking about kind of like evaluating
the code in your local environment with
with a state that you had and the code
might be doing are PCs and things like
that
so yeah yeah so I want to kind of I went
way over so I have to give a shout out
to something that I was also was going
to do in my demo which is this dynamic
logging feature which allows you to
actually dynamically add logging
statements to your production
environment services without actually
having to add logging statements and
redeploy them it's a real time-saver and
obviously you can you can like all your
instances are going to be logging all of
those statements all the time and you
can turn them on and off right there's
there's a command line which is it's so
large points so you can basically see
here that I don't I just don't have any
but you can use the g-cloud CLI to
actually do this right and create a
logging statement what if I have our
points create my history okay all right
let's actually call it quits and go to
questions so we're the tools libraries
and runtimes Java team for Google cloud
platform we're working really hard on
making your life easier on our platform
we are totally open source
we're on github we're on slack come and
find us and file issues and feature
requests if you guys want to take if
anyone's take a picture go ahead now I
can leave it for a second or not and
let's start questions actually all right
in that case no questions I'm sorry
okay I'll be right outside for the next
five minutes</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>