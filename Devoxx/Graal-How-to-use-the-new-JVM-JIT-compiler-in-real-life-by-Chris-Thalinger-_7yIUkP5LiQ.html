<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Graal: How to use the new JVM JIT compiler in real life by Chris Thalinger | Coder Coacher - Coaching Coders</title><meta content="Graal: How to use the new JVM JIT compiler in real life by Chris Thalinger - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Graal: How to use the new JVM JIT compiler in real life by Chris Thalinger</b></h2><h5 class="post__date">2018-03-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/_7yIUkP5LiQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good let's get started and okay so my
name is Chris Salinger I I work for
Twitter I live in Hawaii so I'm back
here now in Europe was good this morning
it's raining now but that's European
weather so first of all who has a
Twitter account in here yeah that's
pretty good
okay so Twitter has a small TM team we
have like it'd be empty before people
there are three to see engineers there
most of the time they are there doing
some support work and making sure that
our micro services run fine and then
there's one she compiled engineering and
this is me so and and if you're going to
tweet about this talk which I would
encourage you to do I saw some tweets in
in my hotel room earlier from the
conference so I knew what was going on
we have this hashtag for our Twitter VM
team so if we can add that that would be
nice okay so why am i doing this talk
I'm I'm doing a lot of growl talks and
and they all have one goal and it is to
show people the advantages of growl and
the main purpose is to encourage people
to try it out okay so this particular
talk is to show people you know in this
talk I'm not showing you how to save
money that would be my other talk but I
want you to see in this talk how easy it
is to just download a JDK and turn it on
and try it out so that eventually maybe
you can save some money that we all as a
community can save bugs and also
potentially to improve growl if we run
more code with it you know we can
improve them on whatever it does
optimizations and so on so after my
previous talks people came up to me and
they usually ask the same questions they
ask me um so is it safe to use because
it's an experimental research
development project
right so is it safe to use how do I use
it where do I get it and exactly these
questions we are going to answer today
sometimes the same emails when they've
actually tried it and they are mostly
complaining that about benchmark numbers
so they were using the benchmark they
were using for ten years right and they
were running it and it didn't turn up as
well as they would like it to and they
most of the times as eight sucks and the
reason for that is they don't understand
the properties of gras
it's kind you have to you have to know
what it is how it works to be able to
benchmark it properly for example okay
so this is all stuff we're going to talk
about today if you want to know more
about this saving money part there's
this other talk I'm doing it's called
Twitter's quest for a holy grail run
time and they're a bunch of I think at
least three or four recordings of that
talk on YouTube so you can watch it on
YouTube it basically looks like this
it's me giving a talk so what is growth
who knows what a chit compile is good
perfect so I don't have to explain that
so it's a java virtual machine
just-in-time compiler that's it oh and
maybe I should say because people might
be confused because Oracle Labs are
overloading the name growl now because
they call they rebranded their whole
strategy to something called growl DM
okay that's not what I'm talking about
because growl VM has all the truffle
substrate VM and the compiler growl in
it and when I say growl I'm only talking
about the compiler so braless is
actively developer or collapse doesn't
there's an official open JDK project the
source could live some github it uses
JVM CI chap 243 we'll talk about this a
little bit later it's it's a compiler at
the phase-in hotspot so that you can
plug in growl and turn it on and use it
and growl is written in Java okay
one of the most important things you
should take away from this talk is it's
written in Java because
this is the main difference between the
existing JIT compilers and gras and this
is also where people make mistakes okay
you guys know what c1 and c2 are okay so
I quickly say that so hot spot people
know what hot spot is yes the JVM in
Oakland shady cave so hot spot has two
chests and kind just-in-time compilers
one is called c1 or clang compiler the
other one is called c2 or server
compiler and both of them are written in
C++ okay so this is what you're using
today and Grob would be just another one
of these which you can turn on okay so
where did I get it as always it depends
and this is unfortunately a slight issue
right now and if I give the talk in
about a month I can delete these slides
because it has to do with with JDK 9 so
JDK 9 has something in it chap 295 it's
ahead of time compilation so it's it's
basically um you know taking Java
bytecode or Java classes and compiling
it down to native code and if we go to
this chap here we'll see ok yeah it's in
release 9 and it's definitely closed and
delivered because 9s out for a while now
and if we scroll all the way back to the
bottom where it says dependencies it
says it depends on 243 the compiling
interface and then it uses growl as the
co generating back end so the äôt
feature in JDK 9 uses growl and it also
says the project will merge growl core
into the JDK and delivered it in Linux
x64 builds and that's the it depends
part so if you have a chatty canine for
Linux x64 you have the alt feature
turned on and that means one of the
modules in JDK 9 contains crawl source
code okay so if we go back here and then
there is this ticket that would add
platform support for Windows and Mac to
ride out native code so that you could
have a OT as well on these platforms but
this is coming in 10 and 10 is coming in
what - Oh three or four days now okay
crazy time is running fast so you need a
chatty cave with JVM CI and a ot and
then this is the case if if you run on
Linux x64 I think what most people do in
data centers and you know on their
servers so you need something greater
equal than JDK 9 if you want to do it in
mac and Windows it's 10 which comes in a
few days so you know so these are the
URLs where you can grab it and will grab
it in a second so the way I'm doing this
talk is it's a little risky and that's
where we are you know running down this
line of wired Ethernet here this talk
I'll do all my demos and on on an Oracle
cloud instance and I'll fire up this
instance now and it's completely it's
from scratch and fresh because I like it
exciting and now the real reason is when
you see talks and people do demos or
when I see talks and people do demos I
always ask myself ok how many hours that
these people spend to make sure the
works right I hope this is not recorded
Sh it it's crazy right I don't want to
do this I want to show you how easy it
is to use it so this I will fire up an
Oracle cloud instance right now and it
doesn't even have Java installed it
doesn't even have kit installed we have
to install this off while we're
doing this talk so so bear with me there
will be a bunch of really awkward pauses
when we're waiting for things to
download so bear with me
ok here we go so or cloud um I'm going
to mention this later as well I'm part
of the Oracle developers champions
program and through that program they
let me use the Oracle cloud for free and
so I can show you this stuff so we are
here in that's called this Vienna oops
oh yeah and the other thing about this
talk is the typing right typing in front
of people is always a little unnerving
so so we're using this Danza IO one
which has four cores if I remember
correctly then we have to set up some
networking stuff right here which is not
really important and then we need some
SSH keys which we grab here okay so my
key and paste and add and launch and
then we cross fingers okay so here we go
so we have provided provisioning this
instance I'm just waiting it another few
seconds to get this public IP address
here the provisioning is pretty fast but
then in you know imaging the thing and
and waiting for the for the instance to
come up will take a little bit so in the
meantime we're going back to the slides
and in meantime I talked a little bit
about me so I who in this room does not
speak German okay cool so it'd be
neutral because yesterday don't even
know so voice tonight bending over
static off Ferguson being in Vienna VA
of in garden drop to the informatics to
get on gets been hurt in America conduit
for Twitter so that was that part so I'm
working on cha VM for for over 13 years
and back in the day so at the University
as I just said I was working on a on a a
VM implementation called cacao you know
it and it back in the day was using gnu
classpath and so we were all the people
working on new glass paths of the Wild
West against you know the big bad guys
Sun Microsystems with the closed source
java and and then when when sun open
source java in 2007/8 you know suddenly
they became more friend
and I thought okay yeah this is a cool
company and then II in 2009 I started
working for Sun and it's very
interesting because the I was still in
Austria working for Sun Microsystems and
the office they had was just over there
in that building complicates the same
building complex we're in right now so
that's where I started working at Sun
and then in I don't know a couple years
later Oracle acquired Sun we all know
that so the biggest three things I
worked on while I was in the hot spot
compiler team at Sun or Oracle was j2 92
which is basically invoke dynamic and
method handles and all the stuff so I I
implemented a lot of this I wrote all
the compiler support I wrote a little
bit of interpreter support I wrote a lot
of the core library lambda form method
Hamblin implementation so that was a big
project it was interesting so if it
doesn't really work well you could blame
me but don't do that because in the
meantime a lot of other people touch the
code so I'm not sure it's not my fault
then I worked on chap 243 we've already
heard that earlier and that came into
the JDK 9 and I wanted this in because I
wanted to be able to have the ability to
use an Oracle JDK an official build and
then you scroll and plug it in and turn
it on right and then after that we were
I was working on ahead of time
compilation and so there there were two
reasons why we did that number one was
for many many many years Sun and Oracle
customers were asking for that feature
they said oh we want a or to compile
stuff and the second reason was we
wanted the ability to äôt compile gras
or any other component of the JVM that
is written in Java to AAT compile it
good so we have that we couldn't do it
if I would have more time for this talk
I could show you how to a ot compile
growl and run with that but
as it is I don't even have enough time
to show you all the demos I have and now
I'm working for the 21 team
let me quickly see if this is up or not
yes it is okay good so what we want is
as I said there's nothing installed on
that machine
so we log in twice because we're going
to compare um situ and growl later so we
need to hear I also told you we don't
even have kids so we need that
installing it I'm sorry my nose is a
little running today so copy this guy
and now could be one of these awkward
pauses no it's not because it's
downloading fast excellent perfect
so I'm sipping typing is important here
we go
okay then we go here we set Java home
because some of the stuff we're going to
do later we'll meet Java home and we put
it on the path because we will run it
all the time here we go Oh typing is
really bad today okay so here we go no I
 it up did I yes I did now perfect
better all right
good so we have we have Java 9 now one
thing that Java has is it has a
command-line option are called list
modules and lists of modules of all the
modules at Java 9 has and the one we're
looking for now is the äôt module so
there's a jdk table a of t module
because we are running on linux x64 if
you do this on the Mac you you won't see
that module so there's another yes
there's another option called describe
module
and we're going to describe the FG
module and it needs two of these here we
go so it has a bunch of contains and
requires and it for example it requires
a module called JDK dot internal be m
dot CI that's the JVM see I was talking
about earlier it's the compiler
interface that growl uses them and it
also requires Teddy K dot internal dot b
m dot compiler and that module contains
the crowd source code so if you have
these two modules and since jdk äôt
requires them they are there we're good
so we could technically you know take
this and say yes and we would see them
right okay these are the two markets we
need and if we have them we can we can
turn on growl and run so let me quickly
over here
Sceptile the home as well the path to
good okay going back to the slides
yeah okay let's keep that so how do I
use it
get a JDK with JVM CI and äôt yes we
check that we have that we verified that
we have both both modules and then just
turn it on that's really it there's
nothing else to it okay so let me show
you how to use it we go all so let me
set a few more things here we're going
to use something called Java tool
options it's a very useful and I haven't
variable that picks up that's go that's
being picked up automatically better
Java launcher and one thing we do is we
use the parallel parallel GC by default
because we're looking at some cheesy
output later it's a little easier to
read and we set a pretty small heap size
and we do this that's wrong we do this
too to settle a a plain a level playing
field for for both
palace because see to you know the other
way around
grah allocate some memory we'll talk
about this more later and and so we
start with the same heap size as the
maximum and it's pretty small so you
know just apples and apples comparison
so we said that we copy that over here
and now we're going to the chaps chaps
and then there's chap 243 somewhere down
here chapter 4 this three here we go and
if you scroll all the way down it will
tell you how to turn it on okay here it
is so you turn on your unlock
experimental vm options because JVM CI
itself is still experimental then you
tell it
Oh an able JVM CI so you just enabled
the the interface in the VM that doesn't
automatically turn on Kerala's to
compile it just gives you access to the
interface okay and then if you say use
JV I'm saying I compiled a replaces C to
both growl okay and then this one is not
really important because we have to we
don't have to name the compiler because
there's only one so it will pick that
automatically so we just grab these
three stick it in here and here we go
okay so if we do a dash Java version
this will happen it says oh we picked up
all these options and here's the output
so nothing really happened right so
what's going on is there did we do
anything wrong or what what's going on
no we didn't do anything wrong it's just
the way it works is JVM CI itself and
growl lazily initialized okay so if
you're not doing anything nothing's
going to happen there is a command-line
option print flags final and we're
looking for TV mci flags on always do a
dash version because otherwise you get
all the crap at the bottom so they're a
bunch of JVM CI flex here one is you
know enable JVM CI that's true because
we turn it on
but the one I'm looking for is JVM CI
properties so I want that here we go
it's a very long list of properties and
properties in the sense of Java
properties because JVM CI is Java and
growl is Chavez all the options you pass
into these two I actually Java property
so - capital D you know you know how it
works okay so there's a there's a pretty
short list of JVM CI properties up here
and then the rest is all Gras okay we're
looking for this one the init time I won
and we just do capital D and that time I
we have to say true chava property so
here we go
okay nothing happened right because if
we look at at the compilations that are
happening so do people know what tier
compilation is just one two three and a
half so chair compilation means I told
you earlier about c1 and c2 and so the
the way the vm execute java bytecode is
first it interprets code right it
interprets a little bit until it gets a
little bit hot and then it compiles it
with a with a tier level at ear level
from from one to three and then
eventually that's c1 and then eventually
will compile it with the tier 4 compiler
which is c2 in a default setup so one
tier tier 1 2 3 that's this column the
third column is the tier level of the
compilation so 1 2 3 all c1 in different
levels of profiling information and four
would be c2 or Gras but there isn't no
no for tier four level compilation going
on so we are not running enough code
code doesn't get hot enough to actually
schedule the compilation and so that's
why JVM CI or growl is not even
initialized so we have to run a little
bit more to do this and for that we
download the Scala takapa benchmark
because we're going to use that later
hopefully if we get there to run some
benchmarks there we go
this might be our first awkward pause no
it's not great left and I have really
awkward pausing in Ukraine at that point
downloading with two megabytes per
second that was long so okay going back
to this one here we go so if we do a
scholar - Elliot it lists all the
benchmarks that the benchmark has and
then we see okay there's something going
on so all this output here is from this
init timer thingy and we see okay JVM CI
is kind of initialized but it doesn't
look like it finishes so what's
happening is it would take too long to
initialize see JVM CI and Gras and
before it's done the the command IX
acute it exits so we have to run a
little bit more than that and so we are
doing a small run of Aurora yoga okay
this looks much better get the
benchmarks running now you know finish a
couple seconds so we initialize GBMC I
hear it took like 78 milliseconds then
it does this compiler configuration
factory thingy where it selects a
compiler and we only have one so that
will be Gras and so then we initialize
this hotspot growl runtime class and
then we initiate the rest system
initializing all of crawl and the
backend for architecture and so on and
then in the benchmark we are using draw
so now we're really using it and I can
you know over here let me copy this guy
so if we run it here with c2 it will be
slightly faster 4.7 okay we're here we
go so 4.7 millisecond 4.7 seconds versus
5.1 seconds so this has to do with grog
compilations and all that stuff which
I'll go into more detail later okay
going back here so now we have to talk
about bootstrapping because the
difference in time we just saw has
mostly to do with bootstrapping
so Grodd is just another java
application in your kbm right it's
written in Java so it loads Java classes
when you start up your VM it has Java
methods right because it's written in
Java and they these methods growls own
methods at some point need to be
compiled because they were getting hot
when they do work okay and and that's
exactly what bootstrapping is right it's
this meta-circular approach you run the
VM and use yourself you're a java
application and you get hot and then you
get interpreted and you compile yourself
but you're the compiler so you have to
compile yourself that's bootstrapping
all right so let me show you a little
bit more about bootstrapping you can do
an explicit bootstrap you can you can
tell JVM CI
oh please bootstrap yourself that will
look like this so every dot is 100
compilations so we're in a little bit
and here we go
so we compiled about 2500 methods and it
took 10 seconds to do that
ok now people would will think ok yeah
that's not really good I don't want to
do this all the time right I don't want
to wait 10 seconds to do this it's even
worse if I turn off cute compilation
because if I turn off to your
compilation we don't have c1 we only
have Gras now we only interpret and we
have Gras and so every compilation goes
through brawl it gets much hotter and
all the compilations taking way longer
so I didn't do it I did oh yes I'm very
sorry - here we go so this will take you
can already see by how fast the dot
shows up
this will take 27 seconds or something
like this so no one wants to wait that
long right you can
run the command line option and then
wait ten seconds for that to show up
right but this is this is now what this
is not really what you're supposed to do
this flag we we sometimes it's useful to
use it in certain benchmark situations
it might be useful to bootstrap growl
explicitly but most of the time you do
it implicitly
as you saw earlier with the have I
deleted it yes I did but you remember
the benchmark random about five point
one seconds versus four point seven like
it's it's not ten seconds right
so the bootstrap can either happen as I
do it here explicitly or implicit like
it just compiles it in the background
when it needs to compile whatever it
needs to compile and so let me show you
that what are we running for that maybe
this let's run that then print all the
compilations and grab four okay here we
go
so these are all the ground methods we
are compiling when we run that benchmark
and it this is this is only the compiler
right we what happens is you run the
benchmark the benchmark methods need to
be compiling and all these that's really
a lot our compiled as well why are you
doing this okay but it's running in the
background it's running on other CPUs
you're not using so it's not that it
doesn't really show up on the wall clock
time one thing you will also notice is
in that third column here it's always
one and there's a flag in growl uh where
is it here come on
there's a flag called c1 only
it's called compound growl with c1 only
and Tier one is it's plain C one
compilation without profiling in with a
profiling code to actually profile to
collect profiling data
and the reason it set up this way is
because we want compilations for growl
methods to be as quickly as possible
because we need the compiler we need the
compiler for our own application so
that's why it's set up this way we could
change this and set it to false and then
growl eventually would compile itself as
well but it would take a little bit
longer you might get better code if if
you're anticipating that you're
compiling a lot of methods late in your
run whatever you're running it might
make sense most of the time it doesn't
matter all right so that's bootstrapping
let me quickly talk about this again so
bootstrapping compiles a lot of methods
so in the non auntie in the ter case
it's at least 2500 and in the non tier
that's even more it's like more 5000
methods and that's eventually what you
actually compile when you do an implicit
I call it implicit bootstrap you can
either do it upfront it during runtime
that's the explicit versus implicit one
and by default on-demand Drog it's only
compiled to see one okay I have this I
have to take this this one out it's kind
of its really a bug but don't worry
about this now okay very important Java
heap usage so a brawl is exactly it's
written in Java that's that's the main
difference between c2 and Gras is every
compilation that you do with Gras it
uses Java heap memory right even
possibly ground methods itself will be
compiled with growl and it will use Java
heap memory so if we if we set that flag
to false and this will happen so most
people tune their heap sizes to exactly
how much they need right we're Twitter
we do the same all right we don't want
to waste any any memory so we tune our
heap says it's - exactly how much we
need maybe one might get megabyte more
because you know but what happens if
suddenly a compilation comes in and
needs 200 mix
that's a problem so this is something to
keep in mind that you will see that
memory usage on the Java heap it will be
used either way because you do all that
memory you know that the compiler builds
up graphs and those optimizations and
stuff so it needs that memory c2 needs
that memory as well but it allocates it
on with malloc on the native heap so in
a cloud world where you where you have
your cloud instance and and then you
have I don't know I'm making up numbers
here and oh you have 2 gigabytes of of
cloud instance memory and you give your
VM 1.5 gig of of that memory I don't
know what C 2 will use native memory
there like as much as it can get to to
compile methods you could technically if
you run with crawl you could give your
VM more memory increase your heap size
and then you won't have a problem but
remember the same memory will be used
either way just in different places all
right
so let's look at this and a small demo
okay so we're logging GC here and we run
this one again because it's useful for
what I want to show you okay here we go
it's a very compute intense benchmark so
it's not allocating a lot of memory and
it's already done
there you go and if I do this one and
let me run three iterations here you
will see there are come there a yeah GC
is happening during the benchmark run
right on the on the Left we see ok these
are system GC once they I explicitly GC
the benchmark hardness dusty is to clean
up the the heap before it starts the
benchmark run we have them over here as
well here but then we have these out
these GC is in here and these are
because we're compiling stuff
right we're compiling the benchmark
methods and the core library methods and
this uses memory these are the explicit
ones again then we have one in this
benchmark run we have one GC happening
and then in the last one
there's no GC happening anymore it's
because at that point in time it's only
what like 12 15 seconds of runtime all
the compilations are done right all of
your company I don't know how many
people have a looked at when
compilations are happening but it's in
the very beginning of your of whatever
you run if you run a small thing I know
it's not exactly true don't but the
majority of your methods let's put it
this way it's going to be compiling your
first one or two minutes minutes okay so
remember this going back to here so what
have we learned
number one we're all users Java heap
memory that's the number one thing you
have to take away if you want to use it
and you think you would run out of
memory then you have to do something
about it at Twitter we've run our most
important services for about eight
months now in production 100% in
production running raw and we never had
an issue with an out of memory situation
it's because our services our micro
service they start up and all the
compilations are happening in the very
beginning but our service is not even
ready to accept requests at that point
in time so it's it's not even using all
the memory right it starts up it it
needs to connect to other micro services
and and then it probably warms up itself
a little bit at that point you're not
even using all of your heat so this is
as in my experience this is not a
problem but it might I'm just pointing
it out that it could be a problem and
memory is being used to anyway eat a
Malaga Java heap right okay how much
time do you have left
14 minutes okay cool so what I'm going
to do is I want to show you two more
things I want to show you the production
demo and for this one I'm going to unset
this I want to download something it's
called fenetre so if we Natura is it's a
framework that Twitter open sourced it's
basically something that we used to
build our micro-services on top your
this Twitter fenêtre it's a lightweight
framework to build fast testable scale
applications bah-bah-bah I don't know
what it is but we use it all the time
okay so we're going to clone this guy
and here we go and I have to do this now
because building it takes four minutes I
think because it's kala right we all
love Scala see it's it's amazing yeah
here's the part where what I said
earlier about setting up your system and
 this does not build with JDK 9 so I
have to I have to add something is all
in my speakers notes in here because
otherwise I would forget so we have to
edit this file here and and exactly like
this and then on top of it I have to set
the trust or don't want to ask me why so
I haven't figured it out and even if I
would I I wouldn't you know set up my
instance now to make this work so I'm
just passing this in and there there are
a couple of examples in Sinatra here we
go examples there's one called Twitter
clone so Twitter clone is a small
version of
Twitter like it had you can you can post
some tweets and it will store them
somewhere and then you can read them so
it's kind of you know a protection thing
it's the best thing I can show you
that's closest to what we do I could
also show
you've been German but that's even worse
than this so I'm showing you that okay
so let's run this I hope it builds
should will take a while okay in the
meantime we're going to build Gras
because the version in Gras are the
version in JDK 9 off crawl is at least a
year old I think it's a version of
December 2016 if I remember correctly
and between from the experience that
that we had at Twitter it's between
December 2016 and March April 2017 there
were a bunch of trial improvements that
we we gained at least three or four
percent worth of performance so you
might want to download crawl yourself
build it yourself maybe you want to work
on it or you know improve it fix it back
who knows so I'm going to show you this
we're going to clone draw from github
here we go
this guy Oracle crawl it grew in size
over time because in as I told you
earlier with the name of a loading in
the very beginning of the brawl Repub
was only growled the compiler but then
they decided to merge truffle in and
then also they they open-source
substrate me am pretty recently so all
of that is in that repo now which does
not clone very fast ok and that would be
an awkward long pause so I'm not sure if
we're going to do that I don't know what
I don't think it's fine
do it what oh that's equals one let's
see
much better
ah that's good thank you I'll use that
in my next version of this talk
okay very good okay cool I know but he
knows that he told me but next time I'll
be the one who knows so then we need we
need this tool called MX it's Oracle
labs they're using it's basically a
script it's a very big script but you
can use MX for everything for building
growl for testing draw for everything
like literally everything every one ever
does withdrawal they you can do through
the script if you've used it that's one
thing because it's easy for people if
you're on board new people like you know
a lot of students have been working on
growl on at the University of Flint and
then when they bring in new students and
they they have to explain everybody how
to do it they have to script and it's
much easier for them to do okay here we
go
so as I said there's truffle in it
there's substratum in here but we want
the compiler so we go in here compiler
I'm going to unset these flags that I
said earlier because I'm not exactly
sure and I have to try this but every
between the talks I don't have the time
to do this I'm not sure what's going to
happen if a compiled brawl with growl if
there's an issue or not so I'm not doing
it now we set Java home so we are on JT
9 and the only thing we have to do now
is MX build that's it and then it should
build and hope it does take a little bit
okay here we go so it's compiling stuff
it's downloading a bunch of dependencies
it needs and then it compiles all the
projects they have draw the way it's set
up it's it's very modular not in the
Java nine module sense but they split it
up in in projects what they call and and
then I in your IDE you have all these
different projects there are many of
them like 40 or 50 I can't remember and
MX the bills if the bill says to make
sure that there are no circular
dependencies make sure no platform and I
always have to be careful when I say
this that no platform independent code
depends on platform dependent code and
all these things so it's a very nice set
up and it's it's made in a way that
people don't make mistakes this build
will fail and the reason it will fail is
because it's building truffle as well
and truffle has it uses FFI and since
this is a very you know there you go it
fails as I said because we don't have
GCC installed right my cloud instance
does doesn't have anything so I don't
have GCC and it could be no I think we
got it
sometimes it's racing a little bit and
then I don't get what I need but here we
go there should be a modules directory
here exactly and this is our modular
char file okay
this module char file contains the
latest version of crawl so now we can do
MX VM dart - version which is just
running Java okay that's really all and
to see what's doing we can do a - E and
they the interesting command line is
this one that's the one that's actually
running and then it's using upgrade
module path to upgrade the module in the
JDK with that module a char file that's
how that's how you can override some
modules in the JDK so if we do
what are we running we are logging class
loading and we run Scala we run my
favorite benchmark again we run this one
and we grab for gravity again here we go
so no ah same mistake it last time I
have to set this again because we were
not running with Gras here we go there
it is okay so we see these Gras classes
are being loaded from the che RT which
is I think Jared T stands for Java
Runtime we for my cover I correctly it's
the file system that reads from the
modules and so we are we're loading from
this module that we've seen earlier
right the JDK internal DM bot compiler
module if we do the same through MX we
see okay all my Java classes are loaded
from the from my from our modular jar
file so if you upgrade the module path
or you run it through MX then you run
with the latest version of crawl and we
can let's just do this run without that
logging stuff let's just run that
benchmark see if it works
maybe it's faster that would be cool
probably not here we go no it's not so
but if you wanna you know play around
with growl just clone it from github
loading it to your IDE you saw it's
really just an MX build and then you
have your modular char file and then
everything you have to do is MX VM or
you could throw the upgrade module path
comment option into into your whatever
on your command line or that the the
Java tools options I have okay let's see
how we're doing over here success that's
good
alright so SBT is always
screwing welcome my terminal okay we're
back again we set this again and now
we're trying to run this and we have to
go down here wait no that's wrong if you
now try examples okay here we go
so number one we have to do is we have
to turn this on
ah no number one we have to do is we
have to add a module because it's still
depending on this Java se da de module
so we have to turn that on then we turn
this on then we do example Twitter sir
clone and then target yes that's what's
called Scala something here we go yeah
we need that and then we need these over
here where are they oh yeah here I don't
know don't ask me why you need these but
we need to pass these to make it work
let's see should come up does some stuff
does some warm-up requests some post
requests some get requests and then it's
it started up it's ready okay so it
doesn't really take a long time to start
up let's run this again through time and
we add a little flag called CI time I
haven't shown you that yet so what CI
time does is let me copy this real quick
CI time is compiling interface time it
will show us how much time we spent in
the compiler in the compilers basically
how much methods we compiled and how
much time we spent doing this okay sorry
let me run this again I have to kind of
when it's up I have to press ctrl C so
that we can compare better okay here we
go let's do the same thing over here no
okay it's done in four seconds all right
okay here we go let's go back up so it's
it's a short example right I mean all of
our services are Twitter and probably
the stuff you're running is starting up
it takes longer to start up than five
seconds but as I told you this is kind
of the closest thing I have to show you
what the production thing looks like so
this started at 36.2 wish and it was
done that 41.4 so that's what five
seconds and over here it's 51.5 and up
to 57 point three so that's six seconds
so it's a little bit slower with growled
and with c2 but it's it's not a lot
right it's not it's we've seen this
early with the benchmark as well it's
not ten seconds right and if if we if
this is only five and if your if your
application starts up in 30 seconds or a
minute this the the difference will be
even less right because the whole
overhead we're seeing here is let me
scroll here the difference we are seeing
here is is in the number of compilations
and so these are c1 compilations and
we've been doing 3,500 c1 compilations
here with c2 with a tiered set up with
c2 but we've been doing more than twice
as many in the Gras case right and it
took about twice as much time to do this
the difference is you remember that flag
that says compile growl with c1 only
that's that right all the croc
compilations are these additional six
thousand methods yeah
yeah oh what's the benefit of using it
oh that would be the other talk how much
time do we have left
see every time but it's the last talk
right it's 42 you need to go to the
airport I can show you it would it take
me it takes me about four minutes to
show you another demo that would it that
would answer your question no no it's a
good question absolutely it's a good
question let me just finish this so with
c2 we compiled about 400 methods here
over here we compiled about 700 that's
the difference between you know core
library methods that get hot because we
run grouse or because we're running raw
more of the core library methods get hot
and so these will eventually be compiled
down here that's the important part we
used about 200% CPU in the situ case
because we were doing you know
application was running and we were
compiling stuff from AVG seeing who
knows and over here it's 300 and so
that's the additional compilations that
were going on and in in the very
beginning of your of your application
run not all of your CPUs will be used to
there will be a bunch of CPUs on the
side that are not being used and you
just use these so the overhead
disappears because you have three CPUs
okay he had a question and I have to
answer the question so this is this demo
it's called a demo let me quickly
crank up the heap a little bit and we
set it to 2 chi otherwise we get too
many GCS and it's difficult to see and
we lock GC and we run this and we run a
benchmark olfactory and we usually I do
three but I'm doing only two now because
we're running out of time and this will
take
one iteration takes about 25 27 seconds
so we just have to wait for that and
then you'll see and you can also watch
the other talk in the other tart the
Twitter's quest for Holy Grail run time
I basically show a trillion of graphs
explaining to you why Twitter save so
much money by using growl it's all about
the money saving part that's why I'm
telling you this whole thing the money
saving is a lot of power yes yeah
it's its power and you know I can't know
you don't know but I'm making up a
fictitious company and my other talk to
kind of give you an idea how much it can
be okay here we go
so that took 25 seconds 26 seconds to
run that benchmark run and we did about
let me run this here while I talk we did
4985 so how much is this like 35 36 she
sees roughly okay to see iterations so
and we just wait for no this is wrong
this is very wrong because we're using
if we don't use the same he'd say okay
sorry all right here we go so this
should run faster
hopefully awkward pause but 20 seconds
awkward pause
the question well we wait for it you
have 30 seconds yeah um I didn't do it
so it was not my idea
I think we'd have to ask Thomas why he
did it but I think it was more of a
proof of concept if he could be done in
my opinion the the biggest advantage
that it's written in Java is that it's
more accessible if you look at I mean no
one's learning to C++ at the University
anymore these days right
but basically everyone can write Java
and it's so much easier to load it into
your IDE and it's yeah yeah you can what
wasn't yeah one of the big advantages if
you have there is something called
project metropolis going on right now or
it yeah it's not no one's really working
on it yet but project metropolis will
replace a bunch of the components in the
VM with with Java written components um
one of the big advantage is doing this
is you own your own compiler so all the
bugs you have in your compiler you can
fix yourself immediately but let's come
back here okay as you can see it run in
about 20 seconds that's pretty good
that's like what a 20 percent
improvement in runtime and one one thing
you will notice we only did like 20 GCS
so what's going on here is mainly two
things
it's inlining combined with escape
analysis the escape analysis in grah the
implementation of escape analysis in
crawl is better it's called partial
escape analysis and it's better and it
can it's can eliminate allocations and
this is why we're seeing less GTS over
there when you can eliminate allocations
two things happen
number one the obvious one we don't we
don't produce garbage we don't have to
collect as much but the other one is the
compile the code compiled is
much tighter because an allocation takes
a lot but a lot of code you know you
probably either have to allocate it on
the T lab or call out to the VM and then
you have to clean out the stuff you have
to fill in the fields if you can
eliminate these allocations and maybe
scale and replace them I'm seeing a lot
of things right now you might not
understand but that's okay
your code gets tighter and if you can
eliminate allocations in the compiler
graph while you're doing the compilation
in the graph the graph gets smaller and
so that means you can inline more yeah
this and this is this is the whole win
this is why Twitter save so much money
way more than they pay me because of
this no not 20 like the factory
benchmark I'm showing here that's that's
really the best case scenario I've ever
seen but it's good to use it in a talk
so I'm almost done
summary turn it on just try it out right
I mean you might save something you
might not it might help you that would
be great you might find a bug that would
be great please file the one fix it
yourself because I've shown you how to
download and build it but if you if they
find it upstream that would be cool
tell me if it works tell me if it
doesn't work I'm more than happy to help
you out tweet me that's my handle tweet
tweet me DM me sent me an email
I'll tell you what to do I'll tell you
what you're doing wrong but I've told
you so much today you're not going to
make the same mistakes as all the people
before you because you know now all
right questions
we do yes pretty much
yeah that that's the answer it's it's
the way so to two reasons when you look
at the bytecode compiled by Scala see
it's very very complicated if you look
at Scot Java C compiled code it's
straightforward and then the other
reason is Scala is has a more
polymorphic nature than Java does and
the way growl does inlining it can
handle that situation better that's why
it with yes it's true and I should have
said it in this talk as well that with
with Scala I'm almost sure that you will
see an improvement with Java it's like a
50-50 chance if you see or not I haven't
had time to try this out I've done a lot
of work with growl at org with Java
obviously now at Twitter all of our
micro services are written in Scala so
it's not I'm I'm glad they pay me to
come here and talk about it if I go back
to Twitter and play around with Kathleen
it probably asked me if I'm a little so
but I just was in Kiev right in Ukraine
and there are a bunch of coupling people
there they were very interested so I
might come back to them and talk to them
again yeah it would be interesting with
other languages do it depends a lot of
on you know as I said how polymorphic
are they how bad is their source
compiler things like this
any other questions yes
absolutely yeah it's just for us
compiler engineers it's better to for it
to be in Java because it's easier to
maintain it's easier to find new people
it would be much easier to use that
compiler and teach at the University all
these things right it's about building
up a community of compiler engineers and
people who are interested yeah I don't
even want to get started to talk about C
2 and how bad it is so yes it will in in
jdk 10 I think when when turns out they
pretty much next week I'm going to take
that one slide out and then I will put
another slide in because in jdk 10 there
will be a chip forgot the name I can
show it to you chip 243 its 370
experimental base Java based JIT
compiler and it's released ten and its
status completed because it's not out
yet but that scroll yeah so in nine
everything I've shown you today the
reason why you can use growl in nine is
because I integrated all that stuff okay
it's nothing that Oracle ever said it
would work I'm just telling you because
I know it does but in 10
they will officially officially support
it as an experimental compiler and from
that day on it basically only depends on
how fast can we get to a point where you
can really replace you too and that
means the more people try it the more
mature it will get in a shorter period
of time because a compelling only gets
mature when you throw a lot of code at
it and a company let's say like or ago
do a lot of testing yes but they test
with the same stuff over and over and
over again what do you really want it's
the crazy code that you guys write
out or the people excuse me the people
before you who already left that code
right so the I think the biggest problem
today is the heap isolation it it's the
the allocations that are happening on
the child heap and they are visible I
think that's the biggest problem you can
if I could go over another hour
no not an hour but I could I could show
you I'd have to do another talk about
this I guess but you can you can äôt
compile ground there so there are two
big issues number one the bootstrapping
and number two is the heap allocations
number one you can äôt compile and then
that's gone the number two with the heap
a solution that's still an unsolved
issue but people are working on it and
will find a solution so a real downside
in in running withdrawal is that's in my
other talk as well it's since it's a
java application it uses about I think
it's like 40 40 megabyte of old chin
memory because it a test state it has
some state right it's not a lot it's 40
Meg's people freaked out about this
sometimes but it's it's not it's not
growing right it has its state and it
will have that state all the time and
then you will use a little bit more of
meta space because you're loading I
don't know how many classes you saw we
compiled like five six thousand of Java
methods so it's all it has to be
somewhere in memory so it's using I
think between 20 it it is noise but
people still freaked out it's it's about
between 20 and 30 megabytes of more meta
space and but you have your SR ease the
people who take care of your services of
whatever you run and they monitor
closely
and if something slightly goes up they
freak out I had this all the time at
Twitter like a series coming running at
me as it's using 40 megabyte more is it
so what we're saving this much of CP
over here
you mean when it's doing a compilation
that's hard to tell because I tried to
basically find this out at one point in
time the issue is the way they operate
and it basically all depends on the
optimizations it does and how much it in
lines you know I I was talking earlier
about you know the doing less GCS like I
said if we can remove allocations in the
compiler graph the compiler graph gets
slow it gets smaller if that happens you
can't compare it it's not apples to
apples anymore so I tried to turn off as
many optimizations as I could but that's
also not really what you want what I
found was it's about the same so in Java
a node object is usually bigger because
it has an it has a header and in in C or
C++ it's it's more tight but what
happens is most people run 64-bit VMs
with less than 32 gig of heap memory and
so that means to run with compressed
oops and compressed oops a pointer is
only 32 bit long and not 64 so there are
a lot of pointers in the compiler graph
because a graph is a lot of pointers and
the point is are only 32 bit long so it
it's a wash 20 minutes over great it
could be a record but I think people are
sick now okay thank you very much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>