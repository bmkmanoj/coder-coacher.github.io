<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Evolutionary Architecture by Patrick Kua | Coder Coacher - Coaching Coders</title><meta content="Evolutionary Architecture by Patrick Kua - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Evolutionary Architecture by Patrick Kua</b></h2><h5 class="post__date">2017-05-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/iDYAtys2oK0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">we're again inflated do it make sure all
right good afternoon so we have quite a
lot of material to cover but hopefully
you'll take away quite a lot of
different lessons about how you
architecture systems will change the
topic i'll be talking about today is
really about evolutionary architecture
and i want to kind of give you some
background as to why this is kind of
important I've been working with sort of
agile methods for quite a while and in
all other sort of environments you know
we talked about adapting to change
responding to change and systems
development as they evolve over time
starting to get shorter and shorter
lifespans and you still have to deal
with a lot of legacy system so when
you're actually building new systems
what do you actually do and you sort of
think about when you're actually
thinking about architecting for change
and that's kind of the heart of what
we'll be talking about and I've kind of
had a lot of experience working with
sort work so it's almost as a
consultancy we work with lots of
different companies help them build new
systems so we're kind of responsible for
things like continuous delivery the lean
enterprise and if you follow martin
fowler his are sort of chief scientists
that talks about a lot of these
principles and a lot of the ideas behind
evolutionary architecture aren't really
new it's just sort of seen through a
different lens of looking at
architecting specifically for change
one of the things we produces too is
probably interest to all of your
technical people is also the TechRadar
and it's a kind of collective view of
what we're seeing with clients around
the world so it's kind of the practices
the tools techniques that people
actually using sort of chart it out in
sort of a different set of rings and
advice about what things are actually
seeing as being painful so you're
holding or things that people are
actually trialing that you might
actually want to think about in your own
sort of companies so there's different
categories around that that you might
actually benefit from we published that
one quite recently in the last month or
so my background is actually around sort
of technical architecture so I normally
work with systems and I work with
clients we actually help them build and
evolve systems that they currently have
and I've worked with sort of tens of
different clients around the world in
lots of different industries everything
from your sort of big banking kind of
organizations telecoms all the way down
to sort of small startups and it's quite
interesting when you actually think
about the ecosystem of
how people make and design systems and
maybe the ones that are a bit more
successful and that's a lot of the
lessons that we've actually sort of
taken with understanding what actually
makes a system changeable over time and
I'm actually working with our CTO who's
Rebecca Parsons and she's on the
left-hand side
Neal Ford who you might recognize from
different conferences as well we're
actually working a book on this and
we're hoping to have probably a first
draft published with O'Reilly so if you
have like early access from Safari
hopefully there'll be something around
some of this year but we should actually
have a book that talks about these
concepts and create great detail as it's
something that we've been sort of
talking about for the last kind of three
years internally and we were wanting to
actually start sharing a lot more of
these ideas broadly now the reason that
we actually think about evolutionary
architecture versus say something like
agile it's really this idea around
thinking about well what are the
consequences if we look at our ecosystem
as evolution
what does evolution actually mean and
what do we have to learn from sort of
biology in this evolutionary sense in
our software world well one of the first
things that evolution teaches us is
really about this idea of change and
that actually change is pretty much
inevitable so in a biology sense you
have ecosystems that co-evolved so if
something will actually change in that
system and the inhabitants and the sort
of species in that system actually has
to evolve in order to compete and evolve
and adapt to that sort of environment
and in all sort of software well there's
actually kind of two major types of
change that I'd like you to think about
and whether we're actually designing for
both of those types of aspects and you
can kind of leave broadly classify these
in both a technical sense as well as a
domain sense now I know most of us have
some sort of Java background development
architecture type background we're
probably more suited to actually really
understanding the technical side to the
area and what changes actually emerge
but actually we're also victims to the
environment of what ecosystem from a
business sense and how that actually
affects the technologies that we
actually have so if we actually think
about that this change is inevitable
then what does it actually mean when
you're actually thinking about the
systems that we evolve
can we actually predict what
architecture we actually will
need in the future and will they
actually be the right choices and if we
actually know that actually change is
going to be coming actually we're going
to be optimizing for the fact that we
don't know what's actually coming and so
rather than actually trying to architect
for too many things up front we're
actually starting to think about you
know what are the possible changes in
our ecosystem that we actually care
about that we might need to think about
and what are the possibilities around
that so what are the things that we
actually care about and I guess this is
kind of a bit of a challenge right and
that I think as the industry has kind of
adopted gel there's kind of this whole
thing around big design up front you
don't need this Dagny and we've kind of
made me flip to the other extreme of
maybe not enough thinking upfront about
what are those possible changes and
there's a balance in between and what we
are sort of trying to nudge is that
there's this idea that's kind of in the
middle that isn't really about crystal
ball glazing and saying these are all
the changes that you're actually don't
have and therefore we're going to
architects for that and we're going to
suspend the program a sort of a three
year architecture and develop this but
actually we need to optimize understand
what are the things that we actually do
want to anticipate and actually make
changes for and that's really the
essence that we kind of pose ourselves
when we were actually talking about this
idea of evolutionary architecture which
is what if we specifically architected a
system for change what would that look
like
how would that drive our decisions and
our behaviors of how we actually
implement the architecture and also how
we actually try to understand how we
support change overall so as I said
we're working on this book and we have a
definition for evolutionary architecture
and it's kind of key that an
evolutionary architecture supports
guided incremental change as they source
principle among multiple dimensions now
it's really quite important to actually
think about what this actually means so
guided means that we're not simply
adapting to the environment so it's not
that we react to what's actually
happening you know if we're actually
guiding our architecture we're making
explicit choices about what we do and do
not use in response to the environment
they're actually having and we're also
trying to imitate the types of changes
that might actually happen and it's
really important that we actually have
this idea of incremental change so I
think particularly when I work with
maybe
larger organizations telecoms or banking
there's this idea of you know we need to
anticipate all this change upfront and
actually we're going to fix in all the
change that we want and make that really
hard and if you've ever worked in a
system like that as a developer you've
probably experienced all these levels of
indirection which make your job really
hard and actually makes daily change and
making changes the system harder as well
so there's a balance in between and this
is where the idea of actually there's
incremental ability is a really key
thing is that it's not just a once-off
aspect of you have an architecture for
change it's actually you're also trying
to increment change through your system
and test whether all your architecture
supports the change that you care about
and it's really kind of cute actually
think about this idea about first
principle of change as the first
principle upon multiple dimensions
because a lot of the architectures we
see are kind of more optimized for one
dimension or the other and not for both
and we'll kind of talk about that and
this is really actually starting to
think about well does your architecture
support change already so we'll have a
look at different types of architectures
and understand what the implications are
for that so maybe some common
architectural patterns that were all
kind of familiar with is maybe your big
bowl of mud so how many people have
maybe done their dependency map and and
seeing something like this before where
all the lines are kind of criss crossed
hopefully you don't have to deal with
that and maybe your systems are a lot
better but we're all kind of used to
this is probably an industry right you
have perhaps your classical tiered
layered architecture where you know you
have different layers representing
different types of tiers perhaps you
have yours on a microkernel type of
architecture and then maybe a bit more
of the micro-services aspect so we'll
have a look at each of these
architectures in detail and actually try
to understand how they actually support
change and more than that what sorts of
changes they actually support as well so
we'll have a look at each of these and
understand maybe what are those changes
and how they actually support stuff so
this diagram actually comes out of an
architectural analysis that we did with
a client of ours where the circle
represents the number of classes in the
system and each line represents a call
out to another class in that sort of
system and so this interweb of calls
actually it demonstrates how much
coupling there is between individual
classes in a sort of system and if we
actually had a bit more of a modular
system you'd probably actually see sort
of strong aggregations of Arts within
one area but certainly not
criss-crossing like you do as part of a
map or in this diagram and so in this
kind of architecture of visualization
I would probably argue that this kind of
architecture doesn't really support any
change so if you need to swap out some
type of technical layer so you need to
swap out your persistence layer there's
probably a whole bunch of classes you're
going to have to change then you've no
idea where you're going to start and as
you start to sort of pull out one
dependency you start to actually realize
this thing is touching all these other
things and that change becomes really
hard as well now if you try to add in
some business features so let's say we
want to change how we price something or
maybe we want to add a new product once
again maybe it's not really clear about
where we go in the system to actually do
that we actually have to do an impact
analysis on the entire code base to
understand well how does that product
actually affect everything and how does
the price thing actually affect other
parts of the code base as well so in
from this kind of perspective the big
baller muds not very good at actually
supporting both our technical and the
domain kind of perspectives and so
obviously if you've had to deal with us
you've probably struggle to actually
make changes to this effectively and
it's not that you can't it's just it's
probably going to be quite a hard slog
to actually get there now we'll probably
move on and probably because the
doctrine of sort of web and frameworks
like spring we probably end up with
something like a sort of shared
architecture in general right so we have
a nice sort of abstraction over the
database we have our sort of MCC objects
that map these things away or using
entity sort of framework attributes you
know we can perhaps what sort out the
implementation of that database if we
like maybe if we're lucky we've done a
good enough that we can actually swap
out for a document database rather than
a relational one and then we have our
nice kind of service business layers and
that's kind of nicely decoupled and then
maybe we have our two presentations here
of actually how we actually render the
screens that we actually care about and
get information in an out of our service
system now this kind of sort of tearing
make sense from a technical perspective
and that
we actually probably want to change out
you know where maybe let's change out
the database where would we go for that
well in this kind of tiered architecture
is kind of clear from our implementation
that we actually change out the
positions layer right and so if we
actually want to change something about
how we've implemented our sort of
service layer we probably go to that
sort of logic layer and that's okay but
if we are actually starting to actually
think about perhaps a domain layer so we
actually want to change the way that we
register customers and that changes our
sort of data model quite fundamentally
we still actually probably have to touch
quite a lot of the code base and we have
to understand which parts of the layers
we actually need to touch an optimist
will mean that we actually have to touch
every single layer in different sections
and so it's not in a very cohesive sort
of unit so argument with our classical
tiered layered structure if we're not
doing very strong modularization is
actually this architecture we're not
done very well is actually one layer of
change we can support our technical
changes but not necessarily the domain
changes of how the business would like
changes support it we still have to
understand the impact on every single
part of a system because there's no
clear separation of concerns horror
vertically rather than horizontally
now another consequence of this kind of
tier layered architecture it depends on
how you've also implemented it so you
know we like consistency because
consistency makes change easier it's
predictable right and what's kind of
interesting is that actually if we want
to add a new sort of attribute so say we
want to persist say a Twitter handle for
somebody on the customer rather than
just the email address you know we
actually have to go through every single
layer if we want to be consistent so we
have to have another attribute on the
screen we need something in our
presentation layer we need something
about sort of business layer but all
it's really doing is calling our
persistence layer because there's
nothing interesting in that and then we
have to actually persist it and have the
field in the database so we've actually
also added a whole level accidental
complexity of things we don't have to do
just because the business wanted
something to change and we wanted to be
quite rigid with our sort of
architecture so some really good
examples of I guess tools are actually
implement this are probably a spring
that we're all from
me with rails and there's a whole bunch
of other sort of frameworks that use
that and so it's not necessarily a bad
thing it's just being aware that these
are the types of changes that you might
actually support and not support as a
results who's familiar with maybe the
microkernel architecture here okay few
hands so a microkernel is kind of this
idea of a core system that supports
certain types of changes so if you've
dealt with a rules engine maven is a
good example different types of things
which define a certain set of behavior
but they allow extension points for
change that is you're effectively your
microkernel type of architecture so the
core of your architecture is based on
whatever the implementation that
microkernel is and then you've defined
extension points that allow people to
plug in extra types of behaviors that
you want now this sort of change can
actually support some types of change in
that if you actually want to swap out
certain parts you can but you will
always be constrained with whatever it
is that the microkernel will allow you
to do now a really good example is if
you've tried to build something that's
much more complex than Apache project
with your core life cycle within maven
you probably realize you start to sort
of work around the core system of the
standard build lifecycle so you start
adding plugins that kind of step over
another part of the maven phase that
does something a little bit different
because the core system you can't change
but you want it to do something
fundamentally different and this is one
of the challenges when you actually work
with this microkernel system is that if
your domain fits that core system really
well then you win you don't have to
worry about that but if that core system
is actually something you want to change
you effectively won't be able to you'll
be other change things of the boundary
but you won't really be able to make
changes to the core system and be able
to support changes like that so from one
perspective you can actually make some
changes but you were always constrained
by whatever it is that the microkernel
actually allows you to do and here are
some really good examples of tools that
were probably familiar with that a
classical microkernel type of
architectures so if you actually wanted
to build an application on Firefox
because it's
plug-in type of architecture but not
make it a web browser you will have a
really hard time making it look not like
over browser because at the heart of it
it is a web browser so when your domain
actually changes you can't really quite
anticipate whether it's going to change
that same sort of dimension now if you
are trying to optimize and you know that
you're building something that's a web
browser something like this can actually
support that but the microkernel will
always sort of constrain where you can
make changes because you can't actually
change the heart of it and this is
actually quite an important thing to
think about when we're designing and
picking tools well there are these tools
are actually helping us support the
changes that we need to have with our
domain because we may not be able to
anticipate where our business is going
to go next and whether or architectures
can actually support that so as I said
let's have a look quick look at not just
a technical side but the domain side as
well so we go back to our layered
architecture we go back to our example
of thinking about what happens if we
actually want to add it with a handle to
customers kind of representation what
parts of the system does it affect it
can potentially affect lots of different
components in different areas now we
actually have something in the
advantages as we adopt maybe Java 9 with
modules that will actually help us
create a lot more stricter boundaries
around parts of the system but in the
current sort of Java ecosystem we have
packages and we kind of have some safety
if we hope that people remember some of
the sort of areas of the code base which
shouldn't interact with other parts of
the codebase but because we can sort of
open up our IDs and import classes
willy-nilly that becomes very hard to do
at a very practical level it's very easy
to sort of violate boundaries of domain
concepts and we have access to
everything which makes it easier to sort
of allow domain concepts to blur across
module boundaries and so in this kind of
architecture where we don't really have
explicit divides between different
components pre modules then we might
actually need to make quite a lot of
changes across the entire system and so
this kind of architecture really doesn't
support our kind of domains shift now
microservices are kind of an interesting
one and one of the reasons if you're
actually doing micro services as well is
hopefully you've applied the sort of
idea of domain driven architecture
you've got highly cohesive services
that actually are kind of independent
from each other and they interact with
each other through very explicit
interfaces so you've done a lot around
trying to understand those interface
designs and each micro-service if it's
done well should have its own
encapsulated technology static now in
smaller organizations it might all be
the same stack all together but actually
in larger organizations it might
actually change now one of the reasons
that this actually works in terms of
thinking about change is that if we
actually want to change the
implementation of some layer within a
particular service we can actually do
that without affecting other types of
services so if we actually wanted to
change the way that we actually saw our
customers instead of being a relational
database into a graph database of some
sort we can actually swap out that
technical implementation without
necessarily affecting and migrating all
the other types of databases as well so
we can actually shift the technology
stack and if we would actually want to
change the customer registration process
hopefully we can actually change the
sort of registration process that deals
with customers at that level without
actually having to touch the other parts
of the system as well so argument when
you actually do micro services done
really well and you can do them very
poorly as well is that these things can
actually support both a technical and a
business domain shift and actually this
is a really good model about why we're
actually seeing more companies adopt
micro services overall because you can
actually move really fast lis and
respond to changes in the market around
what the business would like to do and
we can actually incrementally make
changes to our technology stack that
help us solve problems with the right
tool set incrementally rather than sort
of waiting to do everything at once and
being frustrated actually that it's the
tools are now sort of updated so these
are just some simple examples around
simple architectures that were may be
familiar with and may be viewing it from
a lens of are these architectures
actually helping us support technical
and domain changes and there's a whole
bunch of architectures like reactive
type things and event based systems that
I haven't really covered but it's an
interesting future sort of think about
will it actually help you support both
your technical and your domain changes
according to the pace of what the
markets actually going so we go back to
our destined
of what evolutionary architecture is and
your question is okay this is all really
great how do we actually go about
building something like this and this is
where I want to kind of talk about
different types of principles and these
are hopefully things that you can adopt
that will help you guide whether or not
you're actually building systems for
change so we should look at these kind
of things from both our technical and
domain perspectives now if we're
building evolutionary architectures well
then your technical implementation
shouldn't dictate the schedule of how
changes actually get made and we'll talk
about maybe some practices about how
that actually works as well now if we're
actually thinking about sort of how we
actually build our systems they should
also support fast feedback so we talked
about incremental guided change and if
we're actually going to sort of test our
systems we actually want to make sure
that our systems are fit for purpose and
therefore we need some fast mechanisms
for that so we need to actually think
about whether our architectures are
actually helping us support fast change
as well we need the appropriate level of
coupling now we can't really say we want
no coupling because in order for us to
do something we actually have to couple
things together so things work but what
we're really trying to do is understand
what's the right level of coupling that
we have for our system and have we
coupled things too much to each other
and this is a really key aspect when
you're actually evaluating tools so I'll
talk a little bit about tool selection
later or maybe about the implicit
coupling that we don't think about when
we're adopting things and how it affects
our ability to change a little bit later
and a really key aspect to sort of
evolutionary architecture is this idea
of iterative so really making sure that
we test out ideas that we're not going
to get it right the first time
and that we find ways of actually
changing those decisions and testing our
systems for change as well now from the
domain perspective if we're doing
evolutionary architectures right then we
should have matching business
capabilities and what this means is that
we really should be understanding about
based on what the language that the
business uses we should understand what
parts of the system we might actually
need to change and we should be actually
trying to align technology to business
capabilities to respond rapidly to those
changes in the market as well
now that's really hard if your IT system
Maps nothing at all to the way that your
business operates because you're always
constantly going to have to be working
out well which parts of your IT
organizational development teams need to
respond in order to support a particular
business user whereas a lot of the
industry that we're seeing is actually a
lot more about the IT team more aligned
to around particular business articles
so they can respond to that market need
a lot faster now part of this is
actually a real good test of whether or
architecture supports experimentation
and so this idea of evolution is that we
can't really predict whether or not we
make the right decisions but we should
be other tests for the for the right
decisions if we can get things out so if
we can actually get things out quickly
and we know that it's the wrong thing we
find out it's the wrong thing then
experimentation allows us to hopefully
back that out really quickly and then go
and test something else as well now
around the way that we run our business
as well and this is quite different for
a lot of enterprise architects I work
with you also end up with a bit more of
a decentralized governance model and
decentralized governance is kind of hard
because a lot of enterprise architects
like to sort of dictate what it is that
will be implemented by the entire
organization but if we actually take
anything from evolution we can't really
predict the the results of a whole bunch
of system effects coming into play we
have to understand what emerges and try
to amplify the things that we care about
and to try to dampen the the side
effects that we we dislike and the key
part of this is actually identifying
what is your fitness function and the
fitness function for us is really key
concepts about understanding whether or
system is evolving to the right things
that you care about and so this is
actually a kind of a key concept about
understanding well what is the things
that you actually need to architect for
upfront versus the things that you don't
and in a lot of sort of architectures
that we sort of go to they're kind of
artifacts of assumptions about what the
fitness function are but as a developer
when you come along to add lines of code
to that system you have no real idea
about what it is that you were actually
optimizing for and so when you're
actually going through this process of
identifying your function for the system
that you're building it's really
thinking about what are those
characteristics that are really
important and key for the four
particular application versus the ones
that aren't and this is where we bring
back the idea of your sort of system
quality attributes or non-functional and
cross functionals and really try to make
sure that everyone on the team as they
make changes as they make decisions
understands what are those elements that
are actually important and unimportant
for the things that you care about for
ability to evolve over time and this
will be really different right so if
you're actually trying to design an
architect a mobile application of some
sort that'll be quite different from a
real-time event-based type of system if
you're trying to build something that
will require huge amounts of privacy so
things like a voting application you'll
have different characteristics that
you'll want you know that you might need
to scale to the UK population if you're
building something for the election
coming up and so there are things that
you won't be able to you know that
you'll actually need to design an
architect for but what's really key
around this is actually not just simply
saying we need to do these things and
they're the things that we optimize for
it's actually thinking about what do you
do to measure success around these
things and I think this is an exciting
time of where we are in the industry
because we've moved along quite well
I've actually been able to measure a lot
more of these types of attributes and so
our challenge for a lot of you is really
thinking about when you're actually
thinking about your fitness function
what are the metrics that you can have
to know whether or not successful around
these things and what tools can you have
to actually make these things part of
your tests about whether your system is
fit for purpose in your environment so a
really good example is when you're
actually thinking about high performance
applications what we're seeing a lot
more with companies that can actually
evolve their systems is actually a lot
more automated performance tests in
their sort of production CD pipeline and
what that means is as people are making
choices they can actually run choices
against unknown quantity about what is
successful or not the same thing can be
said with a lot of security tools is
that there's a lot of things that you
can actually test for make sure that
you're being compliant rather than
assuming that you have manual processes
for this as well so a key part to
actually understanding evolutionary
architectures is actually starting to
identify what is what this is that
you're trying to optimise for in your
environment of change because they'll be
singing
you don't want to actually optimize for
and they'll always be trade-offs around
some of this stuff now it's kind of key
because these are the things that are
known knowns so as you respond to a
software developers we should be able to
talk to people and non-technical people
about these system quality attributes
about the impact it has on developments
or infrastructure costs and these are
the easy parts but there's a whole bunch
of unknowns as well and they're the
things that we actually have to optimize
for as well which makes it a challenge
and one of the key things that will
actually help you do this is actually
thinking about how many generations can
your system actually support so when
when you think about evolution from a
biological sense you know you kind of
have to sort of animals of some sort or
organisms and they actually have to sort
of procreate in order to spawn a new
generation and so one of the interesting
things about looking at sort of the
animal world is actually looking at
those generations that can evolve and
adapt a lot faster is because they have
this idea of shorter lifespans and this
faster procreation period because they
can pass their genes on to the next kind
of sort of generation and they might be
a lot more successful and if you
actually think about this from a
software sense what it is what is it
that would be an equivalent for us as
generations what is it that lets us test
whether or not the changes that we made
code functions new tools libraries
something that we've added to the code
base and let us test whether or not it's
actually fit in production so is is the
timeframe for this really long or really
short and a lot of this comes down to
your speed of getting code from sort of
development workstation into production
in use and this concept isn't really new
but it's really key of actually thinking
about how long this is and how long if
you can actually reduce this time to
actually improve the number of
generations you can actually have so
this idea of generations is really this
idea of cycle time and this is stuff
that you'd probably hear about if you're
also living another continuous delivery
sort of space and what you really want
to do if you're thinking about this is
optimized for a short cycle time because
what this means is you can actually test
more of your changes in production a lot
faster and you get more generations outs
in your sort of software and you know
whether or not the changing
make on the right ones but what's really
key about this is a lot of people focus
on how fast does it take for us to get
code out into production and they forget
about some of the prerequisites for
continuous delivery and that's really
key about this idea about repeatedly and
reliably as well and so a lot of
organizations forget about you know we
can actually ship code really quickly
but can we actually do this in a
confident manner that give us our
ability to test whether our changes are
actually successful and so the whole
bunch of practices that help us support
these are actually things that we should
be adopting if we care about agile
architectures as well and two books that
are really highly recommended around
this are obviously the considered
slavery book but also the phoenix patch
yeah the Phoenix project which is kind
of talking about not just the
development side but also the operation
side in the process of how we get
software out into production so there's
a lot of different sort of aspects to
this I've talked about some of the
principles we talked about some of the
key elements of what you can actually do
to drive evolutionary architectures now
one of the difficulties is where do you
actually apply this so if with any tool
or approach it's kind of important
actually understand you don't apply it
to everything and make sense to maybe
think about change in the context of
what you're actually trying to achieve
now when we actually think about tools
frameworks architectures we often go
through this kind of choice or build or
buy we kind of go in our head should we
actually pick a product and build off
that thing or should we actually just do
it start from scratch and then assemble
something from scratch it's not really
that clear-cut it's not really one or
the other it's normally kind of a
spectrum of stuff so our architectures
after a mishmash of some products as
well as some bespoke code and it's
really trying to think about what are
the trade-offs that you get with that
now I've worked with a lot of architects
as they're going through this process of
making choices very early on and I think
one of the hardest things about an
architect is you're trying to do the
right thing and you have a lot of
pressure so you're trying to make as
many decisions as possible but you also
have the least amount of information in
a planning stage and you might commit
too much to things that you don't know
if things are actually going to pan out
in real life and so one of the things
that a lot of people do when they're
going through this process is well when
I'm actually choosing between
it's a bit squirt code what do I gain
from that and that leads us to think
about looking at things through what do
we get from the tools that we actually
pick and so if we look at the types of
options we think about this idea about
build verse by so if you think about
custom code and we're building a
storefront of some sort you know oh
there's a lot of things we're going to
actually have to build we're gonna have
to build you know components that help
us register customers we're going to
have to build some sort of shopping
basket and I have to do some sort of
payment type things we're going to have
to manage searches there's a whole bunch
of things that we actually want to build
because it's all custom code and so
that's going to take a long time and
that's certainly on trade offs are the
other ends you might be tempted to fall
into a sort of cot sort of thing so
components off the shelf or some sort of
software product you know it's really
nice that this vendor offers this whole
customizable thing that allows us to
make changes around some of the options
and configurations around this kind of
platform or product and that's really
good because we're viewing it from the
perspective of how much business value
can we deliver to a client right now
now if we actually look at this through
the ability to change that kind of is an
interesting thing right so if we
actually look at custom code we actually
can kind of make changes that however we
like so we can restructure the code
whatever we like to do we can make the
core product do something that you know
the other product doesn't really make
currently do and we can do it at our own
schedule as well whereas actually if
we're looking at something like
components off the shelf
maybe you're allowed to customize some
things or if you do it'll cost you
significant amounts of money and you're
going to have to wait according to the
vendor of how long we can take to
actually implement that from some sort
of vendor specific schedule and so we're
making sort of these constant trade-offs
around this and this is really kind of
key to think about which is what's the
type of changes that you actually want
to support in the system that you have
do you actually can you predict whether
your business is going to be released
stable and therefore match some sort of
predefined product sort of spectrum or
are you going to be building everything
from scratch so you can actually adapt
to the market as much as possible and if
I think about some of our sort of
emerging startups here in the UK in
particular it's kind of interesting
right because there aren't really any
predefined products around new in
streets and so what we're actually
seeing a lot more were these sorts of
clients is they're building a lot of the
software because you just can't simply
buy it off the shelf right there aren't
standard components that you can simply
put together that allow you to suddenly
produce a new sort of market software
that satisfies the market demand because
there isn't anyone that does that yet
but maybe if you're a more an incumbent
type of system and you're just trying to
maybe create another online presence
maybe it makes sense to use a component
off the shelf and this is where actually
we're thinking about maybe where does
evolutionary architecture fit into this
so we're not actually thinking about the
sort of software that we build the sort
of value that software brings so
commodity software are things that we
don't generate us a lot of value right
it's like stuff we have to have it's a
really good example is maybe the
operating system on your laptop so we
need it to sign up other applications
but it's not really a value generating
thing it's the sort of basis for how we
actually do things and software in
businesses is kind of similar as well
there are some systems that you just
kind of need so office software might be
a really good example of everyone needs
a word processor some sort of Excel kind
of type thing and you don't really need
to make a lot of changes to these sorts
of things so you get security updates as
they get delivered but it's not a key
essential part to adopting a change at
the same pace as the business at the
same time there are some things that you
kind of do need to make some changes to
so perhaps your email system has a
certain workflow that you want to
enforce and there's certain rules that
you want to enforce around how people
manage meetings or rooms and so you do
need to make some changes for that sort
of stuff but once again they're not
really value-adding kind of software
they're kind of supporting software that
helps the business but it's not things
that you actually need to make a lot of
changes to at the same time there's a
whole bunch of software that sometimes
we build that would be potentially high
value generating but we may not need to
make changes to it and these are kind of
your experimental type of situations so
I see a lot of teams that go down and
adopt a lot of sort of the rigorous
automated testing practices they want to
automate the infrastructure do all of
that sort of stuff for experimental
software it's actually probably the
wrong time to do this sort of stuff
because you
know whether or not there's going to be
demand for that software yet and so if
the business says actually we're going
to can this innovation sort of project
because we don't actually go down this
path then you've messed a whole bunch of
time automating things for one use case
you don't get the benefits of that sort
of automation and so these are kind of
your experimental types of software that
you actually don't really care about how
you support change now the key ones are
actually the strategic ones and if you
actually think about you're all sort of
systems in your companies that you have
you'll probably have some pieces of
software and that ecosystem which are
the money makers and these are the
strategic ones these are the ones that
the business always wants to sort of
tweak make a change and is your sort of
differentiator of their shelf now these
are the areas where you actually want to
start thinking about applying
evolutionary architecture to now if you
actually had a product off the shelf and
it's your strategic system what that
also implies is a competitor can come
along replicate your business model and
have exactly the same strategic system
therefore you don't end up with a
strategic advantage now if we're
actually trying to match our software
capability to that we actually want to
be able to evolve our systems to match
that make changes that make our system
really different therefore we want to be
able to control all of those decisions
as much as possible and that's where
evolutionary architecture makes sense we
want to be other support changes from
both the technical side as well as they
product side so when we actually think
about evolutionary architecture the key
thing I want you to think about as you
go back is really thinking about how
well is it that your decision making
process supports this idea of guided
incremental change have you got your
fitness functions identified with the
metrics and have you got some sort of
automation or some way of actually
testing for success have you actually
optimized for things that allow you to
defer decision so you're not - coupled
to a particular tool of some sort we
looked at sort of products cots
libraries and frameworks and the
trade-offs of that versus a custom code
and do you have a way of actually
getting fast feedback so you can
actually get as many generations of your
software out as much as possible and
there's a whole bunch of practices and
tools that you can do that with around
the sort of continuous delivery sort of
space
and if there's anything that you want to
go back to and think about to support
evolutionary architecture on your
particular systems it's really three
elements that you really want to think
about so one is really around this idea
of architectural choices so what are
those tools that you're choosing that
create too much coupling that prevent
you from supporting both your technical
and domain changes how much of it is
driven by a vendor versus how much of it
can you control and also is it important
for the type of system they're actually
building is it a strategic system or is
it something else it's not just the
technology that we should actually be
looking at as part of this process
though because how an organization works
also affects that and also thinking
about to the decision making process and
thinking so if you're actually evolving
a system really rapidly you might have
lots of teams in different ways actually
working making decisions that's
optimized for that particular problem
you actually have to think about how you
govern that and actually what that means
is these sort of Enterprise Architect
role of try to have standards across the
organization comes up with trying to
emerge working standards out of the
group rather than trying to predict and
dictate something from above and assume
that's the right thing so one of the
ways that it often change this role is
actually rather than this idea of the
Enterprise Architect knowing what's best
for the organization is actually trying
to visit different teams and trying to
seed good practices and come up with an
idea of what is the right consistent
best practice for our system right now
but recognize that this will change as
our system evolves over time as well so
our decision-making process of how we
evaluate tools of how we allow people to
experiment to make sure that we can
actually test for these things and know
whether it's a good thing for a new
change in the ecosystem is really key to
allow us to make changes to our system
as well and the third element is really
thinking about the organizational and
cultural elements to this and so this is
thinking about well how do new systems
get architected how do you evolve an
existing system and adopt some of these
practices for a lot of people who have
sort of large legacy systems and they're
thinking about going down this path it's
quite a long way to actually be able to
evolve a system that wasn't really
designed to do that so is there ways
that you actually can grow a new system
on the side of your
to the legacy system and adopt some of
these practices and this is kind of the
approach that Martin Fowler's written up
called strangler architecture
applications right so you're slowly
strangling this old legacy as you evolve
a new system off to the side so that's
the three elements that I'd like you to
sort of think about when you think about
evolutionary architecture I'd like you
to thank you for listening to this talk
and invite you if you have any questions
or comments
yes
hello is it work sounds like yeah I can
so so we have quite a big piece of
software that is quite resistant to
change I think one of the things that
we've found it's nice the the trickiest
bits is when we've got a lot of
dependencies and things yep
or weather even if it's one dependency
that's quite quite quite tied in yep if
that stops being supported or whatever
yep and that could be a problem as well
so I guess yeah do you have any thoughts
on managing dependencies and that kind
of thing or is this a separate topic
ball yeah so I know in dependencies that
are actually key heart to this idea of
trying to minimize the amount of
dependencies and it comes down to really
coupling so the fact that you have a lot
of dependencies is the idea there's a
lot of different types of coupling I
have a longer version of this hope that
talks about maybe implementation
patterns around this sort of stuff but
if you're familiar with the hexagonal
architecture or the ports and adapters
pattern that Alistair Coburn talks about
that's actually a really good example of
how you sort of isolate dependencies
into a single part of the system so a
really good example might be if you
depend on a particular say SMS provider
and you're interacting through a soap
API of some sort rather than everyone in
the system call the soap API you end up
having one part of the system that is
kind of your representation of that the
adapter to that isolated that dependency
and then everyone else uses that single
sort of part of that dependency and what
that means is that changed the domain
change so at some point maybe that SMS
provider becomes unreliable doesn't
scale to what your business needs your
business decides actually we were going
to change that contract we want to move
with a different provider let's change
that on oh now it's like a REST API
where do we go in our system to actually
make a change because we've isolated a
dependency into a single part through
highly cohesive everyone else is
dependent on our custom code for that
actually we can support that change
really rapidly because there's only one
part of the codebase that represents
that so if you're building something new
really thinking about particularly
external dependencies and pushing them
out to the sides of your system that's
the idea with the ports and adapters and
this idea of hexagonal architecture that
can really help with this idea of
putting change and is really good
complementary passion for that if you
have a system where you have a lot of
dependencies in between there's no easy
way around that you have to start
working out how you break up those
dependencies and it's the same sort of
thing when we actually see people move
away from say micro monoliths to micro
services you know part of it is actually
starting to understand what are those
dependencies and that's the key element
of it I'm really hopeful that with
things like Java 9 and the idea of
jigsaw and module stuff is that it helps
us understand those modular dependencies
a lot more explicitly without having to
have separate processes that maybe help
us think about those at a higher level a
lot easier but yeah it's not an easy
thing if you have a lot of dependencies
but if you do I sing them is a really
good way of actually dealing with them
and then trying to break them up is the
other sort of aspect good question
what sort of advice would you give to
someone who is trying to endeavor to do
evolutionary architecture in a
brownfield environment where you've got
sap on one side sales force on the other
some legacy black boxes but you've got a
change in IT direction and you kind of
want to start delivering at a faster
pace you know what because that's the
reality that I kind of see more you know
quite often you know what what gems have
you got for that kind of space it's
quite hard when you're kind of like I
guess an integration vendor to a certain
degree of trying to put products
together and our advice for a lot of
customers is that if they're deciding to
buy products so that means that they're
not really strategic systems they're
kind of things that maybe that they want
to get quick rapid testing off we
recommended customers actually don't go
down and pasture trying to customise
those components as much as possible
it's often better to align your business
processes to whatever the product does
rather than trying to customize that
product because a you'll be locked to a
particular vendor but also you'll be
constrained by the types of business
changes that you want not at the same
pace of what your business probably
really wants it'll be whatever your
vendor will allow you to do so as much
as you can it's really about adapting
business sort of processes that maybe
work with a workflow or whatever system
that you've chosen to go down but the
other side is really trying to think
about how much that you can decouple and
this comes back to the dependencies
thing you're also unique sort of
contributions to the ecosystem of
software so rather than building things
in a sort of proprietary way that gets
plugged in or installed into a
particular product how can you build off
the side and then do lightweight
integration and so what that means is
once again you're isolating the
dependency of some products to an
external dependency theoretically if you
wanted to change that you should only
have a small part but you still keep the
essence of maybe what's unique and
custom to your particular application so
it's really hard because it depends on
what your business you're actually
trying to run but the two bits of advice
are really try not to customize don't go
down the path to trying to customize
products that weren't really meant to be
designed for this because it leads to a
whole world of pain that make it
difficult to test to
you too quickly a cycle and get sort of
fast feedback around that in a confident
reliable manner they're not really
optimized for CD typically and the other
thing is if you're actually building
more bespoke stuff see how much stuff
you can do outside of those products as
a sort of integrated application on the
side through lighter weights integration
mechanisms rather than through some
proprietary tool or ecosystem of tools
okay if there's normal questions thank
you very much for coming and enjoy your
Friday</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>