<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>How Modern SQL Databases Come up with Algorithms that You Would Have Never Dreamed Of by Lukas Eder | Coder Coacher - Coaching Coders</title><meta content="How Modern SQL Databases Come up with Algorithms that You Would Have Never Dreamed Of by Lukas Eder - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>How Modern SQL Databases Come up with Algorithms that You Would Have Never Dreamed Of by Lukas Eder</b></h2><h5 class="post__date">2017-03-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/wTPGW1PNy_Y" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome everybody to the main act of
this conference as every time when the
Java conferences finally converge to the
Siegel talk everyone is listening
because that's something you can use
every day and you will love it how
modern sequel database has come up with
algorithms that you would have never
dreamed of and I'm going to keep this on
a high level because sequel is a very
sophisticated language you can go very
very deep into it but during the couple
of last year's last couple of years when
I was talking about sequel mostly in the
context of the Duke product that we're
selling I noticed that a lot of Java
developers don't know how sequel works
not just the syntax and the overall kind
of feeling of relational algebra but
what happens behind the scene and this
talk is going to be about that and it is
if this title is too long for you this
title will do it as well you will walk
out of this room and think I want to do
everything with sequel because you are
here because you think this cannot be
true right at sequel 2017 this must not
be true and by the end of the talk is it
true though and you're leaving this room
oh my god I'm gonna rewrite all my code
to sequel myself I'm Lucas I'm involved
with Java and Seco and the Swiss
community some of you may have seen me
before I personally believe that sickled
is a device whose mystery is only
exceeded by its power and before I go on
with sequel I have to instruct you what
you have to do when you leave this room
I need you to concentrate and push right
this button this is the right button you
have to push this one right don't forget
okay why do I talk about sequel mostly
Java conferences few people think about
this every day but sequel is the only
ever successful mainstream and general
purpose force generation programming
language now there was this dream back
in the days and was heard in the in the
keynote this morning Martin Thompson
thora talked about all these different
programming paradigms all these
fundamentals and one of these paradigms
is a fourth-generation programming
language this means it's a declarative
language we don't say to the Machine
what to do we just say what we want to
have as a result so we don't tell it how
to do it we just tell it what we want
and why doesn't anyone else talk about
see
a Java conferences I just don't know
it's such a excellent technology who in
here use a sequel I don't see any hands
but I'm sure all the hands are up and no
one else talks about sequel except flat
where it's flat
I think flowers over there perfect
you've heard his transactions talk very
very interesting so flat is a developer
advocate with hibernate and he has this
blog the most important blog and flops
blog is the one where he shows how to
use sequel with JPA because that's the
most important feature of sequel and if
you don't remember the URL I've written
down here after URL shortens this blog
post so you can look it up
very interesting blog post because
there's this API create native query you
should use it right so who has ever seen
my other talk I have this Auto tog I see
hands I mean this one I mean this one
right the tentacle tricks to convince
you that sequel is awesome if you have
never seen this talk it is not that hard
to find just Google tentacle tricks and
you will be overwhelmed by choice of
various copies that I did at various
conferences you go watch that talk to
learn how seagull is awesome and their
tentacle tricks in that talk for
instance this one this is a very simple
single statement so the ones in the
front row they have already mentally
calculated what is the result of this
post quest query and you will see it is
the Mandelbrot set now throw away all
your all your user interface logic you
don't need swing anymore you don't need
down effects anymore right in with
sequel you can directly calculate each
pixel with a single statement but today
we're not going to look into these kind
of tricks we're going to talk about more
basic sequel because we're looking more
into performance aspect and more basic
cycle is still awesome and you will see
this is this sequel ladies and gentlemen
do you think this here is Zico who
thinks this is Seagal yes okay then this
talk is perfect for you this is going to
be the level of basic Ness I've already
talked to you in the other talk about
how sequel is awesome we've seen that so
I'm not gonna repeat myself today we're
focusing on the other two aspects sequel
is helping you be productive and sequel
is fast how can you be productive with
sequel now there are two ways for me to
prove this to you there's one way by
example and I show how awesome sequel is
and wonderful techniques and then there
is a way
to prove this by alternative by showing
well if you did it in Java instead of
sequel what would it look like and I
think both approaches are really
interesting and this is as I told you
this is gonna be a high-level talk a
conceptual story about sequel we're not
going into the deeper levels may be some
next year I will go into the deeper
levels but I'm going to keep it
high-level this time we have this model
here this is an entity relationship
diagram it's a DVD rental store don't
bother about all the details the
interesting thing here today is the film
table and maybe the payment table now we
have business right business is always
asking us things we're programmers we
want to just drink some coffee and chat
and hang out and laugh at stupid memes
and then these business people come and
then send us these kind of things right
so business sends us a request how much
money did we earn with each film on each
day that's a typical question that
business wants to have an answer for and
we have to program this and we're
thinking all right that's interesting
let's see so we have this model they
wanted to see how much money per film
right so we probably take the film table
and the money is over there so that's
the payment table so we somehow needs
the money table and the money attribute
from the payment table and the film
table and luckily the day is also in the
payment table so now we have all the
information in these two tables what do
we do we just try to find out how to get
from A to B this is the path and this is
called a join right so you see we have
to join the film table inventory table
rental table payment table and we're
done
okay let's go do it great so this is the
sequel statement you all agree this is
already I have done my task it's this
easy first I go to the film table
because I want to calculate the money
per film right so I have to load the
film table and then this is the
relationship between film and money
we'll just type all these joints all
these joints typing a little bit and
then we groove by the film and the
payment date to calculate this sum of
announcer this means per film and per
payment date I made this much money that
was pretty easy who agrees this was easy
yes everyone agrees this is easy
let's look at classic Java we're
developers we like typing stuff with
this verbose language right sometimes it
feels a little bit like this everyone
feels like this let's look at how we
could solve this problem Joe first off
we start with a class we need to write
this class right so everyone still with
me okay good
now film is a tuple so we're adding
these attributes the tuple like in the
database we had a film ID and we had a
title and because this is Java this is
not enough we have to add these guys as
well right nothing would be perfect in
Java if we didn't fulfill the javabeans
Convention that is a very gift to
humanity and we add these getters and
setters because that might change in the
future we might implement get film
differently right and then because it's
Java we add these guys as well right so
we have to do this because we want to
compare film so we need hashcode and
equals and who in here frankly who in
here remembers the last time you didn't
implement hashcode and equals the same
way as eclipse or IntelliJ would have
generated the code for it
right so equals is just compare the
first attribute with the first attribute
in the second one you're just doing this
recursively and we're topping this stuff
all the time and we have so much
distraction and because we have so much
distraction we need abstraction right
because Java we're going to write these
guys we must not allow developers to
instantiate new films this is why we
have to have a control mechanism on how
you construct new films and we're
writing a new film factory and because
it's so dangerous you not must not allow
developers to instantiate a film factory
we also have a film factory builder
right so you can actually get the film
factory from the film factory builder
and everything is safe and we have the
management of the lifecycle of all these
objects and there's still a mistake in
this because it's much better to have
interfaces than classes for these things
but what do you ever need to say a face
you also need an implementation and
there you go with the implementation
everything has an implementation and now
only one instance the global instance of
our applications will know these
implementations and that is spring right
so we add those beam annotations I have
no clue if this is correct but probably
it is more or less
we have these beam annotations and our
spring can instantiate and manage the
lifecycle of these Builder factories or
factory builders which provide us with
factories with providers with the film
and then we add some Lombok because
everything we type is so tedious so we
need some more annotations to reduce the
typing and then while we're at it some
generic developer found a new library so
they're adding more annotations there
and that's the next iteration and by now
the guys up there in space in ISS they
can see our code room space right so
that's write your code your average Java
Enterprise bean sitting right there in
Zurich visible from space
now I'm getting distracted I wanted to
talk about sequel right I wanted to talk
about cycle and I'm showing you sequel
awesomeness by example by comparison
there's more comparisons on this website
there go visit it it's very funny and
we've had a talk about this topic today
in the morning which was very
interesting as well and we haven't even
solved the problem yet because we only
have to film now from the film we need
to go to the inventory store rental
payment you remember now this is Java or
sequel it's the same thing there's
actually no such thing as the
object-relational impedance mismatch if
you google this I will have an opinion
on my blog as well on this topic because
in the end you're modeling the same
thing as in the database you're modeling
it again in Java so you're probably
writing something like this from the
film you can get to a list of
inventories so we have a one-to-one
model one timon mapping you could also
map stuff not one-to-one but then you
get into trouble later on but we'll map
this one to one and we're using a
mapping library like this one right so
everyone has seen these annotations here
so we have a one-to-many relationship
and I think you work with these and now
what happens if I do it like this is it
going to be eager or lazy which is
better
let's ask flat lazy is better excellent
thank you flat lazy is the better option
here because eager is a code smell you
can read it on this block very
interesting topic and we're not done yet
we have only declared when we already
had with DDL right with DDI we had to
create table film and we had all the
firm key relationships because what we
really want is this we
the result business is still asking
they're sitting there where's in my
result and now okay this is the job way
of doing it because I want to have the
number of the amount of money that we
made per film and date and one way to
solve this would be a map of film and
each film has a map of date and test big
decimal because big decimals the best
type for money in the old days because
you want to have the precision so this
is the money this is the film and this
is the date and some of you might think
okay let's just do jsr three five four
we have a now a java money API so it's
more semantic than just a big test and
what it tells you what it is it's a
monetary amount and now we go check out
the jump it up there and we see we feel
at ease with this API right so we have
monetary monetary amount monetary amount
factory etc etc and we feel oh my god
okay but we're not there yet
so this was the optimal result type I'm
gonna just leave away the money API for
simplicity for now is this better than
this see the difference
do I want to retain the iteration order
while I fill these hashmaps or do I want
to throw that away
I mean there's a trade-off this will be
faster this might be more correct in
that sense of what I want to achieve so
this is a little bit different but this
would be even better maybe right so we
can discuss these alternative map types
we can discuss these through lengths and
maybe we have that one junior developer
who said I know how these things work
I'm gonna write my own map because what
really sucks here is the doubly nested
map we want to have a single map a multi
key map which supports two keys and one
value and we're implementing this and
maybe there's even library for this and
we're still discussing collection types
we have not answered business question
yet who has felt like this before yes
the result is clear the result is yes
everyone
we're always discussing these data types
and don't get me wrong it's important
sometimes to optimize these things but
sometimes we need to just implement
business logic and that's not
interesting to the business they don't
care about your opinion on linked
hashmap but let's assume this is the
right type and now we're loading all the
films so you see the snark
he remarked there on the method name you
get the idea this is probably very slow
why is it slow who knows we'll just fix
this later
and then the next developer comes and
we'll fix this later right and then the
next one says oh this is really urgent
this blows up in production we don't
know why's films loads of that slow but
let's ignore this for a moment let's
iterate the films and then we get the
map out of the result per film and you
recognize immediately this is the same
type so when we have one film then we go
and fetch that map where we have the
dates to the amount mapping and what now
yeah we have to avoid no pointer
exceptions all the time yeah right you
enjoy writing this code okay because if
this is the first time that we encounter
the film the hash map is null so we have
to fetch it and then you initialize it
and there's a meme for this this is the
beam and then we're just gonna discuss
this all over again right and I'm gonna
collapse this this is the boring part
now it's the interesting part we're
gonna iterate we're looping through all
of these things now we remember flat
told us lazy is better
it's lazy better now how many queries
will this produce n plus 1 M times and
so many queries so every time we iterate
we'll get new queries so maybe eager was
better but probably it isn't it's very
hard so maybe if you Google on a JPA of
blog you find a solution and solution is
an entity graph there's this named anti
graph thing it's a wonderful thing it's
like a sequel query it's just not sequel
so you say I have this graph from the
film inventors rentals payment table you
have all these annotations I'm feeling
like this if you see it but maybe you
prefer this kind of way and remember
this slide from before so this was the
enterprise beam before you edit the
entity graph now you add the entity
graph and now they can see your entity
beam from Andromeda galaxy that's where
it is right there ok now we've done the
looping and now the calculation of the
amount yes
are we done can we just put the amount
with the date that's completely wrong
right that's not the sum of amounts
that's just the last amount in iteration
order we have to put the sum of amounts
in there so that's how we enjoy doing
things we have local variables and then
if that map already contains the key
then we actually do the addition
and otherwise we do the initialization
and luckily Java eats off this at least
this got better we have now these
compute methods so we can do it in one
go it looks a little bit more clean so
we use this but do you feel good about
yourself let me ask you this you're
typing this enterprise business logic
all the time and don't get me wrong
sometimes you need to optimize these
things but most of the times you don't
this may be a report that runs once a
year but it's important that it gets
done tonight and you're still discussing
data structures and meanwhile what
always happens in these situations
business is back right ha did I say how
much money fulfill I meant per film and
store he was wrong right when does that
ever happen changing requirements ok
there are two kinds of reactions two
kinds of program or reactions there's
the sequel Developer Program or reaction
and then there's the Java developer
program reaction to this change of
requirements here's the sequel developer
I got you covered buddy and here's the
Java developer you spent all this time
discussing hashmaps and it's completely
wrong you have to rewrite the algorithm
okay so the sequel developer does this
little thing this was the sequel query
so some white space here right you see
immediately I'm reserving some white
space and I'm putting these store IDs
and now I have the money I made per film
and store on each given date
easy we can yo drink beers now meanwhile
the Java developer he does the same
thing he reserves some white space just
a little bit more code and it's
wonderful you can immediately see that
this calculates the money we made for
each film and each day on each store and
what happens next right you see there's
a map of map of map there's this
architect guy every team has an
architect and the architect says that's
by the way that's this guy he sees
everything you do every commit he knows
better and he has an opinion and he
tells you we cannot have such types
factor this out in a new class and then
you need a factory of course for this
new type and you're like you want to
already discuss because you're you're a
functional programmer you like
structural type you like maps of
of maps you don't need to give
everything a name right you don't need
name everything and while you're still
discussing these philosophies meanwhile
yeah you know what's coming up next
still wrong
did I say deli revenue I meant
cumulative daily revenue that's
something entirely else you don't even
know what is what is the cumulative sum
and you go to the internet right you
choose your favorite browser and start
typing cumulative sum and what does it
mean yes and now you find a result of
you go oh my god it's Friday oh I'm not
gonna do this anymore meanwhile sickle
developer just some white space because
just a little bit more code then go to
stack overflow copy paste this nice
little function here it's called a
window function and we're done this is
the cumulative sum you see here film
store ID date some cumulative sum very
easy to calculate you see the cumulative
sum is the sum of all sums up until that
date wonderful so you get the message
I think Zico is a fourth-generation
programming language in sequel we only
declare the result the database will
figure out the algorithms for us we
don't care about the algorithms in most
of these cases now often we do and we
check out what the database really does
we optimize these things but very often
the database gets it right at least good
enough if we don't really have any
requirements like high frequency trading
where everything has to be super fast
usually it's good enough for the
database figures out and mostly it's
much better than what you would do
algorithms are boring I'm sorry Martin
but no they're not boring they're very
interesting but when you have to do so
many business logic tasks you can't you
just can't think about hash maps all the
time or lists or treat you have to get
there and sequel is the language that
helps you do this what we don't care
about usually when we write business
logic is algorithms we don't care about
premature optimization because that's
sequel query it will run fast probably
and if it doesn't we add an index right
so it will probably run fast and we
don't care about these
details do we really already at the
beginning care about if it's a hashmap
or a list of entries these are two
entirely different beasts they have
different characteristics memory
consumption algorithmic complexity when
you iterate them complexity when you add
something to them but it shouldn't be
that important at the beginning because
business will change everything anyway
we don't care about local variables when
was last time you enjoyed writing local
variables kind of like final int and
then you store something and you need
back again later on you don't you don't
enjoy that you didn't enjoy cashing
stuff yes that's when it gets really
hard because you think ok I'm gonna cash
this one doubly nested hashmap because I
don't want to calculate that all the
time well your cache invalidation
problems will be bigger than your
performance problems and we don't enjoy
writing loops we don't enjoy this we
have to nest a loop and nest another
loop nests and we don't enjoy
initialization or null pointer
exceptions and then we can have a
discussion about optional if you insist
but then you still have the
initialization problem you still have to
initialize the thing even if it's
optional what we don't care about is
business logic and ok a little bit of
indexing because eventually has to be
faster but that's it
now some people claim I really like this
tweet from Mary Fusco is also here at
the conference I showed you an
imperative example there is also a
declarative ish example with Java 8 now
finally we can use streams and streams
are really nice I'm not even going to
decipher what's the imperative example
on top does because the streams example
is so much easier to read you can see
here this is like the from clause so
when you load all the lines from the
file that's like a table right so you
iterate over this table which is the
lines of the file and then there's your
where clause we only want to have those
lines of your file that starts with
error that's like the sequel like
predicate and then we have something
like fetch next in sequel or limit we
only want the first 40 rows and finally
want to have that as a list so from a
development perspective this is much
better it reminds us of this technology
that is actually the best right so a
stream of tuples it's the same thing as
a table and anytime a class is a tuple
if you think about it this way a class
has attributes it's like a tuple with
attributes and the stream of tuples is a
table
and the Select operation in the select
statement it's like math on stream we
get a tuple as input and we get a tuple
as output and this dinked is obviously
the same thing join and flatmap are
pretty much the same thing as well so
when you have flat map then you have a
stream and for each item in the stream
you have another stream and then you
combine these two like with join we're
having is filter that's obvious group I
collected similar similar that's just
names right now when we have this Java
algorithm and we compare it with this
one this will get much better in Java so
we load all the films this will be a
stream of film stream of inventory when
we flap map its to the inventories
stream of rentals stream of payments
still n plus 1 problem here because we
still lazy load everything but it is
more readable and now we have to access
F and I in the collector because we want
the film and the inventory to group by
right so we can do this in Java by
having entries so we have to actually
remember what we flap mapped before we
flap mapped it so we can use hash map
entries for instance with the Java JDK
libraries and we pray for a stack
allocation to happen which is probably
not gonna happen but we have a lot of
pressure on the garbage collection so
this is gonna be quite hard to get
performance but we can get there so we
just add these couple of collectors
collectors here so we have the same
group by experience and then we see this
right so what the hell is this so we and
we nested all these entries in entries
and it but it looks declarative and if
you're using better streams so a little
bit of advertising our product Jolanda
is open source so you can use it or we
had to talk about Java slang which also
does similar things we had it in the
morning I think so there are some of
improvements just in the API perspective
so it does the same thing as the stream
but it has better more convenient API so
for instance we can have several
aggregations in one go this will change
so instead of the stream we would have
here a sequence in the jolanda library
instead of these flat map operations we
would use something like cross apply
like we know from sequel if you know it
so we here we have a nested tuple
film inventory and then we nest this
tuple once more the film inventory tuple
goes into a tuple
coming through a rental payment so this
is how we work with Java right so we
have all these generics we always have
to remember the type
so here we have this triply nested tuple
doubly nested tuple singly nested tuple
and finally the film and we group by
film right we can optimize this more we
never actually needed the the rentals
the rentals table was not useful so we
just skip it we flap map this again so
we only have two payments table this
gets a little bit better
and finally if we group by everything in
one go maybe even better now this would
be with Jolanda almost like streams we
have a kind of more convenient result
set type but the point here is how much
time did I spend on this problem now I
wanted to talk about sickle and you're
all here who is little is ever stopped
right this was a sequel query it is so
easy with sequel so easy and it is so
hard with Java because we have to think
about all these things these languages
these general-purpose languages they
forced us to think about these things
and sometimes that's a good thing but
sometimes that's not the best thing and
sequel solves these problems it has
always solve these problems and modern
optimizes we'll get to that afterwards
solve it extremely fast so this means
it's a great improvement for developer
productivity and I wanted to make this
representative right so how much time
did I spend speaking out sequel and
speaking out Java that's representative
of how much time you spend on these
technologies when you solve simple
requirements like I did right so sequels
productive I've shown this and now the
interesting chapter which we all came
here for well it means signal is fast
you are fast writing sequel but sequels
also execute it in a fast way so this is
the best chapter sequel performance how
does equal work now let's think about
sequel to the language here's again
business business asks how many films
did each actor whose last name starts
with a plane now this is always very
cryptic I'm showing with an example at
this is already the results and we want
to have this result you see all the
actors start with the letter A and
that's how many films they played in
that's what business wants to have as a
result this would be the query now a
query in sequel another language is a
string we send a string to the database
and a string is a very convenient data
structure for these kind of things
because it's a constant and the database
can easily generate
the hash codes for the string and then
do some caching for this string so
there's a lot of work that the database
does only once so when he sent this
string for the first time to the
database it will calculate an execution
plan and then cache that plan for the
next execution so all the work of
figuring out the algorithm is done only
once
ideally now when we look at this
statement the first thing that happens
logically now Seco has a very weird
syntax just ignore the syntax for today
and look what happens logically so the
first logical operation is loading the
tables and by loading the tables I mean
all of them including a joins now
observe again this is logical not actual
the database may choose to do something
else first but logically the table
operation the from operation is the
first one then we apply the predicates
so we loaded all the films and to film
actors then we reduced the films again
the actors to have only those whose last
name starts with the letter a and then a
third operation in this query is
collecting the groups so we create
something like a hash map for the first
and last name and then we aggregate we
can do this in one step but logically
it's two steps so once we have all the
groups we collect all the values in the
group in each group and calculate this
count value once we have the count value
project or this is also the Select
clause and finally the order by clause
so you see the syntax is not exactly the
same order that is actually logically
happening this is somewhat confusing to
new people who are new to sequel this is
the complete logical operations order so
the first thing is from then where then
we have some Oracle specifically because
I'm an Oracle guy I left them in here
then group I and aggregations then
having window functions and then let's
ignore model and then select distinct
Union order by this is the order of
operations and you have to understand
this there's also if you google this
term logical operations order sequel
operations order you'll find
documentation each for instance on
sequel server they also did it this way
this explains a lot of things because
for instance the aggregation step is
here right so when you aggregate when
you do an aggregate function that's step
number five this explains why you cannot
access the result of an aggregate
function in the work
because the where class is already
logically executed it must happen before
the aggregation so you can never see an
aggregation function in the where clause
you don't see that in syntax it doesn't
make sense but if you think about sequel
this way or if you've ever used window
functions that happens now after having
so we know functions are defined here
this also explains why you can't use
window functions in the where clause you
can only use window functions in the
Select clause and in the order by clause
because they happen after this window
step or the Select Clause it's here now
when you do a column alias you rename a
column right so you have an expression
and you give it a name
so instead of count star you write C you
call it C now the Select Clause defines
column aliases and this means that the
column aliases are only available
normally if the database is correct my
sequel guest is wrong they allow you to
do funky stuff but normally you can only
access this column alias in the order by
clause that's the only class because
it's the only class after the Select
clause but has column access does that
explains the thing or two maybe maybe if
this was confusing but the logical
operations order is not what's really
happening any algorithm that produces
the same result as would be produced but
his logical operations order is
acceptable and that is how sequel works
because we only care about our business
logic we care about this logic language
we care about our predicate we care
about business told us we only want to
have last names starting with letter A
that's what we care about in our
everyday work we write thousands of
these sequel queries a day and we don't
care about the algorithms why because on
our developer machines maybe we have 10
actors but in production we have
millions so the algorithm that we think
of is probably wrong because in
production was something else and maybe
we have five customers and they all have
different data sets so on each customer
our algorithm that is linear would be
wrong we need something logarithmic for
this huge customer right so these kind
of things we don't want to think about
this all the time we want to keep our
minds on the business logic this is
already complex enough I mean who thinks
that this was a complex query right no
one thinks do you seen worst queries and
these monsters I've seen 4,000 lines and
they still perform because
no one cares about these hashmap things
iteration things everything we just
declare those 4,000 lines can we see the
actual algorithm yes we can
this will be the algorithm if we're
using Oracle so this is display from
Oracle sequel developer who has seen an
execution plan before yes
no most of the oh I actually
miscalculated this line it's about half
half for everyone else please do check
them out that is where all the answers
are if ever your query is not fast then
the answer is in the execution plan all
the tools I have buttons so in the
sequel developer for Oracle you can
click on this explained plan button and
it will display an estimated planner
it's important it's the estimated plan
it's not the plan that will get executed
but it's what the database thinks will
get executed if it is executed Postgres
pw3 explained queer there's a button for
this my circle in sequel workbench
there's a button for this all of them
have that sequel server already gives
you the option of having the estimated
plan and the actual plan and you can
compare these things that's the best
tooling in my opinion but what is the
actual algorithm let's look at the
Oracle version because I like it best
because it is nicely structured as a
table all the databases have graphs it's
a bit harder to put in our slides so
there are two important columns here the
one is the cardinality estimate and it
says here as you can see I am using a
laser pointer in PowerPoint the database
estimates that our predicate here last
name starting with letter A will produce
six actors so that's the estimate the
database thinks this will produce six
actors and then at some point we'll get
13 rows according to the database if you
remember we actually got six rows or
seven if I remember correctly but this
is not off by an order of magnitude the
database is off by factor two and the
algorithm is still correct for this
little bit of error that database has
when it estimates these things so the
cardinality is an extremely important
column for you to check out that tells
you why does the data sink logarithmic
algorithm is the best or a linear
algorithm is the best or whatever
algorithm mr.
and this is the cost column this is a
bit weird in Oracle other databases put
here something as they estimate the
number of milliseconds Oracle has a cost
that is corresponds to the time it takes
for one disk block access which is a
very weird measurement but it's historic
you just take it as an indicator the
bigger the worse right so you see this
is a relatively cheap query and what
really happens in the correct order is
first thing we're doing is we're
accessing the index now I don't know if
you can see it I'm gonna zoom in a
little bit the first thing is we're
accessing the index that is on the last
name column because we had this index
last name starting with a and that
database thought this is going to be the
best thing because now I'm going to
reduce my result set to six rows instead
of the other option would be just to
load all the actors and then continue
doing the joins but the database decided
to actually go first with the predicate
and then it loads the other columns from
the table that's the second step so
usually when you see an execution plan
you go from the bottom to the up there
are whole different kinds of rules how
you can interpret these they're not very
authoritative they're kind of indicative
of what really happens but with some
intuition you get this so now we're
accessing the active table because only
the last name column was in the index so
we have to go to the table as well
after the index and look up the first
name because the user requested that in
the result and then we load the entire
foreign key relationship into memory now
that's a bit that's interesting would
you have done this and we have six
actors and you think we'll get six
actors so you just iterate six times and
go loads to count the number of films
that each actor played in you do this
six times right but the database start I
get five thousand four hundred sixty two
rows in total because this is a very
small test database so I don't even
bother doing any algorithmic
optimization this is just about five
disk blocks or four or whatever I'm
loading the entire index into memory and
then what I'm doing next is I'm doing
this hash joint operation so a hash
joint operation means I implemented the
join with a hash map where I put all the
results from both sides into it and
whatever sticks around is the result
there's a nested loop during our
algorithm where we take one side and
then you iterate over this side like we
did in Java before that's a nested loop
joint operation so we iterate on one
side and load the other side for each
element on the left side there's also
merge John you can google these things
the different joint algorithms and
finally we do a grouping and ordering so
what you have chosen the same algorithm
what this PD algorithm you have chosen
well maybe you would have thought of
this probably we do wouldn't maybe the
most intuitive one is just seeking six
counts individually now the hash drawn
operation has complexity of over N and
it's the bigger table in this case film
actors right and the nested loop down
with indexes is two times logarithmic
depending on both table sizes so which
one of these is better it depends it
just depends because Big O notation
helps us make the right decision for
large data sets so here are you like
Microsoft Excel for plotting these
things very easy right we have all these
different complexities and as n grows a
linear complexity is much worse than the
logarithmic one we can see that but
sometimes you're here in this area right
so this is a test database but maybe you
have some sample data maybe have some
production data maybe some table in your
production system only has 100 rows so
you're also in this area where the
generally faster algorithm is actually
slower because it has some overhead
right so when you access the index we
have overhead we have to access the
index disk blocks and then we have to
access the table disk blocks if the
table is small we just skipped index so
you may actually be in this situation
where a worse complexity might be better
for this kind of query or worse worse
situation there's a situation called it
works in my machine so developers are
always in this area right so they're
shipped to production then you go to
this area over there and you discover
that all your algorithms or assumptions
were wrong because you tested everything
here with this year so if ever you can
have productive data to develop do it
it's much better you're gonna foresee a
lot of trouble even with sequel because
you were going to ask the right indexes
so if you care about big o-notation
there's a nice website that explains it
all
usually with sequel as far as
algorithmic complexity is concerned
you're only looking at the algorithmic
complexity not the memory consumption
complexity that's more rare when you're
using have any coding stuff with Java
you have to consider both things very
interesting things to think about and I
completely agree with Martin from the
keynote today it's very interesting to
know these things you should know these
things
they're very interesting but you
shouldn't think about these things every
time you write something silly like some
business logic that's my opinion
so it will distract you from the bigger
logic and these languages have been
designed to forget about these things in
nineteen ninety five percent of the time
now think about histograms it's an
interesting thing this is a histogram we
have a bank accounts transaction table
typically banking system and I'm
imagining this system to look like this
in the middle around zero we have all
the little payments like when you go to
a restaurant you pay 50 francs so that's
a little payment or if you are the
restaurant you receive 50 friends so in
the middle in this bell curve we have
much more transactions than on the left
and right on the Left I bought a car I
paid I don't know 20 thousand on the
right I have my salary I get my fifty
thousand paycheck each month right
excellent
now let me ask you a question we have
these two predicates here predicates one
and predicates two one goes from - mm -
mm so the range is 4,000 predicted two
goes from 5,000 to 9,000 so the range is
for a thousand there are equal ranges
but our data saying predicates do both
predicates profit from indexing this
predicate here select almost all the
data we're in the middle of our non
uniformly distributed data so this is
not a uniform distribution it's a bell
curve so in this case if you let the
user select this and user interface and
the database will tell you okay I'm just
going to scan the entire table or at
least the entire data set for this user
because the index won't help me it will
not be selective so if you load the
index first and then you load the table
that's more
than just loading the table entirely and
then skipping about five percent this
however is very selective so we're
selecting maybe three percent of our
data so here an index is very useful so
what I'm trying to prove here is
indexing is one aspect of sequel
performance sometimes it's better to use
a nice sometimes not but you don't care
about these things either well you can
put the index because for some queries
it's good and for others it's not
database knows these things the database
will figure out the right algorithm in
production while you don't even care
about this the database knows how many
rows are returned from a table it has
these cardinalities how many rows are
returned from the sub query or from a
query he has his cardinality is the add
up how much does it cost to access the
disk do you want to think about these
things now we switch from HDD to
solid-state drive you don't even know me
because your product is implemented rise
is installed by a customer and you have
no operations access you don't know
anything about your prayer the poem
production system the database still
does and it optimizes the algorithms
depending on what kind of disk you have
and the cache there's a cache in every
database you have something like a
buffer cache so the database doesn't
just access the table all the time if
your tables access frequently it's in
memory already do you care about this no
database knows these things how often is
the query run is it run once a year or
5000 times a day it's optimized
differently how often is the table
accessed I have many of these bullets
how much memory do we have do you care
about this when you write the business
logic you can't care about these things
all the time that's so low-level that's
that's crazy you have to be more
productive how many processes are
running in parallel right now are we
having an ETL job that keeps you from
running your fast queries because you
have a lot of contention you don't know
while you code this stuff maybe you do
sometimes but you don't know always it's
the operating system doing anything how
does the query perform with this bind
variable so we had those two parameter
sets right the ranges were different how
does the creep perform with this set
with this set are we running on HDS is
SSD flash or Ram now every no sequel DB
vendor will tell you you don't need
databases anymore you need two
relational
put everything in memory we got the
solution for you okay they solve this
problem but all the other bullets are
still there even for those databases
they still have algorithmic complexity
if you run something in logarithmic time
in memory it's still faster than in
linear time in memory it's obvious right
how many locks do we have on our rows as
in flats Tok Tok that's extremely
complicated if you have locking if you
I'm just talking about reading from the
database if you have locking everything
gets hundred times more complicated i
luckily work only with read only
database this it's so much easier so
much more fun everything has a cost now
how does sequel work everything has a
cost parse siegel string produces an
expression tree and this is an
expression tree right so we have a
pseudo sequel statement at the bottom a
plus a minus B and the expression tree
is this graph I displayed just an
illustration so it is parsed into
expression tree and multiple expression
trees are equivalent they can be
transformed into each other so we can
prove this with math if you have one
expression tree here and by the laws of
associativity we can just switch to
parentheses between plus and minus
there are associative these are
operations and now that we have a plus a
we can switch this to two times a
there's also math proof that you can
apply here that's the same thing and now
imagine accessing a is super expensive
right a is on a remote server over the
wire it has lots of latency so obviously
the right algorithm is going to be
better than the left and now someone
fixes this in production some DBA says
oh I find out air can actually speed up
this this database link and it's no
longer the bottleneck and the database
will switch back to the left algorithm
we don't even notice this alright so
this is how a sequel works the best plan
is the one that has the lowest estimated
cost that is chosen and that is executed
and once it is executed the actual
execution cost it's going to be measured
and compared with the estimate and if
the estimate was wrong then we choose
the second best plan all databases
differ in how they actually do this but
when's the last time you wrote code like
this in Java code that profiles your
application in production and then
chooses among five different algorithms
that you actually thought of while you
coded your application you never
do this you don't like doing this your
estimates whenever you estimate stuff
under time pressure you're doing
estimates on your developer machine
you're not doing your estimates in
production there are two times wrong
your assumptions are wrong and then your
productive data is wrong and there's a
special treat if you're using Oracle 12
they can actually even switch the
execution plan in flight while it's
being executed the database has now this
new feature called adaptive execution
plans and while it executes a query this
is mostly applicable for reports but if
your report was estimated to run 30
minutes by the database and suddenly
runs it seems okay this cardinality is
five times higher than I expected it
will run two hours it will switch the
plan and choose something else
so databases are getting better and
better better and I'm pretty sure
machine learning and these kind of
things going to optimize is pretty soon
as well I'm sure this is going to be
researched about production is here your
estimate development environment is here
so this is the reason why you will never
want to code these algorithms in
large-scale enterprise systems yourself
unless there's always an exception
there's always a niche when you really
really really already know your domain
very well and you care about performance
very very much then you do it but
usually don't usually fast enough is
good enough and sequel is fast I've
shown you this super fast and now that
you know of this what do you prefer this
are this this was easy
the other one was hard we could discuss
endlessly about philosophies design
patterns whatever data types data
structures here you don't even have a
choice you just run this query it's very
easy and I talked about sequel
conferences because sequel is the only
ever successful mainstream and
general-purpose fourth-generation
programming language so it was always
the dream of developers in the 70s 80s
when these languages were first
developed Prolog and all these languages
we don't want to think about algorithms
all the time sometimes our blodgett is
so logic and so complex it's much better
to use a logic language lexical it's
functional even it doesn't have any side
effects and it is awesome now back in
the days optimizers were really sucked
it was hard it's still hard it's very
hard to write a good optimizer but today
we have this if you if you spent the
license
money you can use Oracle it's wonderful
Postgres is getting better and better
and even my sequel is advancing so do
try these things out do try out how much
time do you need to write a good
algorithm that can compete with the
sequel algorithm per query right and you
how many queries do you have do we have
this much time to code or just spend a
little bit more money on licensing and
then ship into production much more
easily faster and better so why doesn't
anyone else talk about sequel I know all
these flanks fancy technologies even
JavaScript coders want to code they want
to do everything themselves but are you
sure about that they already wanted to
do that do you really want to discuss
hashmaps all the time can I write sequel
in Java a little bit of advertising of
course you can we have a product that
does sequel in Java and a typesafe way
so I assume I've been here so many times
in different venues how many people use
joke already so quite a few people
alright so you should try this out this
is a typesafe sequel in Java so that
every table and column is a an object
with type information associated with it
everything is type checked by the day a
Java compiler and you can have this
level of productiveness as if you were
writing a stored procedure in Java
directly so people are referred to dupe
like this as well or I've seen people do
this or that okay so what's the key
takeaway of this talk can you do it in
the database yes you can
I've already proven this in the last
talks equals Turing complete we've seen
this Mandelbrot set you can do
everything in principle with sequel and
when I say in a database I don't mean
store procedures I mean Seco sequel is
the awesome thing so procedures are kind
of weird we all agree on this sometimes
it's the better choice but sequel is
really the powerful thing inside of your
database can you do it in the database
today it was so simple everyone can do
this right so you can write these simple
joins very easily it's going to be super
fast and if you think you can't do it in
the database and you need some more
training I do out for that so please get
in touch
there's a 2-day sequel training cycle
functionality this is the first talk and
this was the second talk about
performance we go more into details than
I did today can you do it in your
database
yes all of the databases are super fast
today the modern databases are super
fast unless
using my sickle for instance my sickle
still doesn't have hash joints as far as
I'm informed I'm not sure if my sickle
ate finally implements them but without
hash joints you have a whole set of
algorithms that are not available to you
so sometimes the database is not there
yet but very often it is should you do
it in the database business logic in a
database right so this is the hot topic
of everyone every discussion around
coffee you shouldn't do business logic
and database right
no I'm just kidding of course you should
do business logic in the database
especially when you're using a logic
language it's the best language for
business logic I hope I convinced you
today to long talk titled attract
attention we've seen this title so
you're all here not listening to the
Java 9 talk wonderful this works as well
and will this talk ever end also yes
there is the 10th Siegel Trix talk if
you want to see that as well google it
and you'll find a transcript and the
video of it so you see even more sequel
awesomeness these are my coordinates
thank you very much time is over ok no
questions
and don't forget to vote on your way out
yeah remember that slide in the
beginning thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>