<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>WebRTC Security: is web-based peer-to-peer ready for primetime? by Lieven Desmet | Coder Coacher - Coaching Coders</title><meta content="WebRTC Security: is web-based peer-to-peer ready for primetime? by Lieven Desmet - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>WebRTC Security: is web-based peer-to-peer ready for primetime? by Lieven Desmet</b></h2><h5 class="post__date">2015-11-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/YunkATJKLLs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so good afternoon everybody I hope
you're enjoying yourself at the
conference welcome to my talk on web RTC
security so I'm giving this talk because
I think web RTC is really an important
change in the field of the weapon in the
web architecture and I hope throughout
this presentation you will have the
feeling how it actually is reps the
whole way we are interacting with the
web so little bit about myself I am
leaving this mat I'm a research manager
at University of Leuven
where actually I am coordinating a team
on application security all researchers
on web application security application
security in the broad and also actively
engaged in a wasp I'm a board member of
the Belgium chapter and also
co-organized the European conference
back in Amsterdam in earlier this year
and most of the program director of
second F this is the yearly week-long
training on secure application
development which has already been
running for more than 10 years but back
to the presentation so what I want to do
in this presentation today is giving you
a very good glimpse at what is report to
see all about I will present it first
high-level from an architecture point of
view then i zoom into the communication
protocols and also to the Jeff
JavaScript ApS that are available to
developers and I hope after this part
everyone will have a good enough
understanding of Airport EC to
understand the reporting I will do on
the security and privacy of an
assessment we have been doing on web 40
C but maybe do get a little bit of
feeling of the audience who of the
audience already was developing in
report EC technology only a few hands
who is actually planning in the next
year next two years
to integrate some web RTC technology in
their websites some more let's say 15 20
%
okay maybe another question who is here
for the web RTC port who is here for
security who is here for the web for TC
part the majority security almost all
room so both parts are actually been
present in the presentation so that's
good so but first web part is see when
you would ask me what is web RTC all
about actually I would say it's really
disruptive within the web architecture
because now all of a sudden peer-to-peer
connections become available in the web
architecture but if I take one step back
I never need to explain to laymen
what is what what is C well I would say
we have been using all kinds of
technology in the past to have audio and
video communication over the web
think about WebEx go to meeting a dog
connect link FaceTime and now all of a
sudden all the technology becomes
available from within your browser so
now with WebRTC there's no need to
install any extension any plugin within
your browser all of a sudden everyone
can participate in a peer-to-peer
connection in audio/video communicant
setting and this is a screenshot of a
few years back when the first Chrome and
Mozilla browsers were communicating to
each other on web 40c so as as simple as
you see it right here you're using your
plain browser you're using the
technology in your browser and you're
able to set up video and audio
communication with other parties on the
Internet in a peer-to-peer fashion so
summing up you're actually having
peer-to-peer browser communication you
have the ability to route audio and
media streams across those peer-to-peer
connections and everything is fully
JavaScript and powered it means you can
actually build a whole application
within JavaScript using the building
blocks available in your browser of
course it means that the whole protocol
stack is available within the browser to
enable the web RTC communication and I
will first zoom in a little bit what are
the communication protocols in the
browser being used to enable web RTC so
from a very very simple view on the web
RTC architecture you have two browsers
that want to communicate in a
peer-to-peer fashion they will all load
codes from the central web server so
this is a very classical paradigm and
what a browser is actually connecting to
a web server is downloading JavaScript
code and runs it within the browser this
is step one and typically using that
over HTTP the next step is that the
browser will now initiate a dike
communication to the other peer and do
that with DTLS and SRTP so it means now
all of a sudden your browser is not only
communicating to a server but now it's
communicating to other browsers on the
Internet
and this is a very simple view you have
two parties involved in a communication
model but of course them all multiple
deployments possible with WebRTC and
also the specifications handmade up so
in this way that's very liberal the way
you will use WebRTC in the future
so for instance the simple one is a
two-party video conferencing stream you
have one central server you have two
browsers communicating with each other
in a peer-to-peer fashion but you could
also have the example where the browser
is actually having an appear to be
connection with the server itself so
think about an e-commerce website
nowadays you can already chat with some
employees of the e-commerce site now all
of a sudden you will have an extra
button while you can start a video
conferencing with an employee at the
e-commerce shop and this is the kind of
the helpdesk all scenario
but you could also have it in a favorite
way you don't need to stop with one
signaling server you could have multiple
signaling servers cooperating together
you could for instance use Google as one
server to log in another user is using
Facebook and then in federated setup by
using a peer-to-peer communication
between two users they are not limited
to only connecting two browsers you
could imagine that one of the service is
actually a gateway to existing sip con
installations to existing xlmp
infrastructures so in that sense you
could have a bridge setup where you have
your browser suddenly communicating with
voice over IP phones over the web and
this is only when you have two peers
involved you could also have multiple
peers involved rather than the two peer
scenario you could have for instance
four peers and you can communicate in
different ways for instance this is the
mesh network every entity is
communicating to every other entity in
the communication but you could also say
well one person one of the browsers is
actually the master and install Network
everything gets rerouted via that server
or violet client or you could use
dedicated hardware such as a multi-point
control unit to reroute all the streams
and from their own dispatch them to all
the other browsers again again web part
is C is very liberal none of the
specifications there's any limitation
how you use the technology and also for
a security perspective this is important
because it's so unconstrained they're
also very very ways you can have a look
and have a look at your particular
infrastructure how it could be attacked
this is the basic view so we have two
peers that want to communicate over the
web and for the rest of the presentation
I will limit myself to two peers that
are connecting but
take into account that you can have
multiple piece connecting in a mesh or
store or any other configuration what
are now the communication protocols
being used in WebRTC well we first saw
this thickening part the signaling part
is actually the communication via a
classical server so the client connects
to the server the server might have a
connection to other clients this is
called the signaling part and what it
does it loads the client side context
the code of JavaScript running in your
browser and also reroutes or mediates
all the control messages and metadata so
in order to set up a connection some
information needs to be exchanged
between the two endpoints all that
communication is routed via the web
server by the signaling path and what's
important in the context of web RTC and
that is in WebRTC the whole ceiling
protocol is undefined so it's actually
up to your own application to decide
what is the best signaling protocol to
use how can we actually integrate and
communicate bi-directional between the
browser and the central servers in the
examples I will use later on in my
presentation with the be using socket at
i/o but you could also use WebSockets
you could use any other means of
bi-directional communication between the
client and the server on the media path
is much more streamlined then we
actually want to set up a secure p2p
connection between browsers for media
streams audio and video I didn't mention
before you can also send data so you can
actually send strings from one entity to
another in a peer-to-peer fashion the
protocol is being used there or DTLS you
can think about DTLS as UDP with all the
characters of TLS and on top of DTLS in
order to have real-time communication
secu real-time transport protocol as RTP
is being used so these are the building
blocks that are already present within
your browsers which enable you to
communicate with other parties
I will not zoom into how actually DTLS
SRTP is working this is out of scope for
the talk what I will focus is in how you
actually configure those protocols to
being used in a web 40c communication
and this is actually kind of challenging
in order to set up the media part we
need to do two things first we need to
exchange all the parameters in order to
configure our two endpoints to be able
to see the same video streams all these
streams
so that is actually done by exchanging
media parameters and the second part is
actually exchanging Network parameters
how can we make sure that we can make a
connection from browser a to be across
firewalls nuts and so on and any of the
technologies being listed here is not
new they're actually being borrowed from
previous infrastructures for instance
from sip so now a zoom a little bit in
to how I changed media parameters how I
exchanged Network parameters and then we
can zoom out again to see what does it
mean from an architecture point of view
so the first step is the session
description protocol it is actually
exchanging data about what kind of media
types you're willing to accept what kind
of codecs you have all the information
about yours your screen real estate what
kind of media can actually consume or
produce on my device and it works with
an offer and an answer so the browser
will typically send an SDP offer to the
other side it will receive an answer and
from that point on you know what are the
capabilities of the other side and to
send around the office and the answers
you're using your own custom protocol
via the ceiling server the singing
server has to make sure that the data
from browser a reaches browser should be
and vice versa the way the messages are
structured those are present in the
specifications there are all actually
standardized and to give you just a
glimpse of what an SDP offer looks like
this is an example taken from the from
the specifications and you will see it's
actually one large text-based file you
have kind of key and pair values and
that's also the interesting part with in
processing structured data and in
JavaScript context we would expect that
data to be available in JSON formats
although alike but because we're
actually borrowing those technologies
from the SIP world this is fully
text-based and we will also see pauses
and also mistakes and bugs in the parses
to actually process this kind of data or
tempo with that data this is the port on
media exchange we don't need further
details at this moment for the
networking part I can actually say the
main part of the networking which is
actually the challenging part is making
sure that connection between the two
peers the peer-to-peer fashion which is
actually central in report you see
to cope with firewalls and nuts in
between how does it do that it uses UDP
hole punching and the main idea of UDP
hole punching is you're actually making
a connection to a public server at that
moment a public UDP port is opened on
your net and firewall if the other side
is actually doing exactly the same all
of a sudden you can have communication
between a and B or fell down firewalls
and nuts in place this is the most
optimistic scenario this will not work
with any firewall any not being present
in your infrastructure but this is the
main ID how to connect in a peer-to-peer
fashion between browsers so when do you
have to use which kind of technology to
enable the networking part in order to
know which is your external IP your
external port that public server I
showed you and UDP hole punching you
using a stun server you're actually able
to communicate to that server and that
server will tell you this is your
external IP this is the port that is
being opened this is the optimistic
scenario both parties using a stun
server and they are able to set up a
connection in case that is not working
you might need to fall back to a certain
server and what the turn server does is
actually playing a relay it will relay
for you all the connections between two
peers that are not able to communicate
directly so it will actually take
packets from one side and send them to
the other side and to exchange data
about stun and turn from side to side
you're actually using the ICT protocol
which actually will give you a list of
possible stun and turn alternatives from
one side to the other side until you
find a match between the two networking
points not so important how we actually
configure the stun and turn server at
this moment what's important is that
actually the architecture picture we had
before which was very very simple is now
getting more and more complicated now
all of a sudden in order to set up a
communication between two browsers we
need also to involve servers turn
servers and exchanged I see information
between browser a and B via the
signaling path but as you will already
have noticed the picture is really
really in the top part of the slide
there's still a lot of open space well
there's actually one more thing I need
to tell about the report you see
architecture which makes it a little bit
more secure
this is about identity provisioning in
order to communicate with the third
party on the internet you actually want
to know who is at endpoint you want to
authenticate the endpoint and in order
to do that within web RTC
you're falling back to identity
providers you're asking identity
providers for you to assert a user and
to verify the identity of a user how do
you do that the browser will load in a
very dynamic way code from the identity
provider it will ask the identity
provider to get an identity assertion
the browser B will receive that
assertion it will ask the identity
provider to verify the identity
assertion and only if that matches there
will be an authenticated channel between
browser a and B and in this way I can
actually know that I'm talking from John
or Facebook or Makai from Google and
this is the way it will work with in
WebRTC if I look what is actually done
within the browser itself you're already
having the red code running in your
browser coming from the web server this
is the original code that is actually
running the whole web RTC part now you
will ask the web RTC api's to load an
identity provider it will fetch code
from the identity provider rent in an
isolated environment and call it an IDP
proxy and this is actually done in a
realm within JavaScript and then you
will communicate with web messaging to
the ROM to ask to for an identity
assertion or to verify an identity
assertion and this completes the full
architecture picture we have about
WebRTC every party can he use his own
identity provider to get identity
assertions I need to verify each other's
identity assertions with the identity
provider of the other party and this is
actually all the stakeholders that were
involved with in a very simple case
where browser a and B want to
communicate and this is also the
protocol stack I was talking about this
of course is mainly hidden within the
browser that's the good news now we
actually will look how we developer
communicates with all those building
blocks within the browser so I will give
you a glimpse of the JavaScript API so
it's not my intention today that I learn
you how to program about you see there
are very good tutorials on the web but I
have a different step
we actually looked into I just want to
give you a glimpse of what this program
of within my party see and what is the
difference between custom protocols and
the things that are already available
from web RTC itself
within the browser I think it's fair to
say that the web part is a building
blocks are very well represented already
in the browser it means with like 200
lines of code you could have already
official demo of two parties
communicating over the web and its
client and server code all integrated in
one so I already said the whole web RTC
is fully JavaScript empowered it means
that the JavaScript API is exposing all
the functional blocks within web RTC you
are able to set up peer to peer
connections you're able to handle audio
and video streams and you're also
exchanging the SDP office ICU candidates
so they're actually present as objects
within the JavaScript environment and
now a few glimpses on the api's to be
used for instance in order to set up an
RTC P connection you're just making a
new r TCP connection within JavaScript
give it some parameter configuration
about for instance IC service stone
servers turn servers and all of a sudden
it will start set up peer-to-peer
connection what it will do is actually
call event handlers for the SDP and IC
candidates and that's the next step I
will discuss and show within the slides
so in order to exchange as the be offers
and answers the browser will trigger
event handlers to say well this is the
SDP object you need to send to the other
party or this is an SDP object you
received from an other party and so the
browser will actually trigger those
events and then you will have to send
them for yourself via application
specific signaling so whatever is in
purple within my slides is your own
channel you have to make to communicate
to your web server from point A to B so
that is actually making sure that all
the data you want to give to the other
party is being relayed via the web
messaging the red parts within the
slides or the api's and handles already
present within your browser to handle
the receiving of SDP and IC e or to emit
IC e and
P candidates so this code fragments are
sufficient to exchange data that the
connection will happen so that you have
all the SDP information already
exchanged between the two parties in
order to set up the network connection
you will have a very similar way while
you're actually exchanging data about
the network specifics so here again all
the network specifics about what is your
IP address how to communicate what are
the different protocols you support this
is all realized by the browser the only
thing you need to do is actually getting
in them from an emitter and send them to
the other party and vice versa and this
is the way you're actually programming
the whole web party support in your web
application so again the exact API are
not part of this presentation but you
get an idea of how complex the code is
to actually set up or complete web party
C scenario so by the things that we
showed until now we actually have
already a full peer-to-peer connection
between the two endpoints of course
having a peer-to-peer connection but not
using it for anything useful within your
application is not so interesting so the
next step is actually making sure that
we can have video from our camera and
that being sent to the other party so
what the first thing is to do we will
actually ask the browser for permission
to get our camera or user media and once
it actually approved gives consent to
get our camera we can actually send that
around at the stream to our P connection
and all of a sudden that video stream
will also reach the other party and he
can receive it and consume it and
actually web party C technology is as
simple as that you only have a few api's
you need to implement in order to make a
full report to see communication
similarly you can do that for data
channels and in the end you have a way
to communicate peer-to-peer and it's up
to you to be disruptive in the way
you're using that application for
instance uses already file transfer
applications now all of a sudden you
have file transfer application between
two peers while your file will never be
stored on a central server you have
already very easy communication
platforms like Toki while you can
actually already given one URL interact
in a kind of videoconferencing
without pre-processing with
reconfiguration and this is only the
first step
these are the building blocks within
your web application
good I think this is the basic part I
want to mention about WebRTC before
going into some of the details of our
security and privacy analysis so if you
have any question about the web RTC
protocols the architecture or the api's
this might be a good time to actually
come forward and ask you some of the
questions because they might actually be
necessary to understand the rest of the
presentation it does work so the
question was does it work on mobile yes
it does work on mobile so we had some
tests last year in a lab but we were
using an iPhone and an iPad to
communicate with a party see technology
so it depends a little bit on the
maturity of each of the browsers how far
they go of course in supporting each of
the features but the basic set up having
real-time communication is already
available on mobile so I would say from
what I saw of I represented here in the
architecture the main part that most of
the browsers do not support or not
support at all is the part on identity
provisioning and I will just also
discuss later on why this is really a
tough problem within web RTC any other
question so the identity provider I will
discuss the more detail and so that the
question is how does identity provider
exactly work and I will discuss a little
later in my presentation in more detail
but the idea is you use an external web
application and you're interacting with
that web application to know whether or
not you're a particular user so you will
get an assertion type or out and you
could use that assertion and give it to
the other party to show that you're
really that identity but I will show it
and cover it a little bit more detailed
later remember presentation good then I
actually will go to the most security
and privacy part of the web part you see
and I think it's important if it
reporting on a security assessment that
we're saying which are the attackers we
had in scope while doing the assessment
so the first attacker we had in scope
while doing the assessment was the
attacker residing on the network the
network attacker he is able to observe
and tamper with any network traffic
coming around so if the Wi-Fi is working
here imagine anyone here that is
actually tampering with the Wi-Fi while
you're communicating what is the impact
of that network attacker on your
40c application what is the impact on
the end users the second attacker that
we had in scope is the malicious web
server so that is the servers and could
be more than one server if you have a
federated setup that is actually sitting
in line on the signaling part it sees
all the control and made-up data
messages and contempor with each of
those messages and it also controls the
client-side JavaScript code so why did I
include this attacker in the model if
you're looking from the standpoint of
view that you say I want to make up a
web part you see application of course
you will not be the malicious web server
but you also need to take into account
what is the impact of anything bad
happening on my server to my users
especially because users are expecting
if you have a peer-to-peer connection
that there is some privacy guarantees so
they're not expecting that anyone can
observe the communication that's going
on between party a and B and in the same
line and maybe more practical is the
fact that you also also have malicious
third party JavaScript running in your
application so even if you're not
malicious at all with your application
you could have some JavaScript embedded
embodied in your application that is
doing malicious stuff with your web
application with your web RTC
application and it can be either
included deliberately because you're
using all kinds of API you're using
Google Analytics you use it book using
the Facebook like button and so on
those libraries might be compromised it
could also be that it's injected because
you had for instance across the
scripting vulnerability on your website
and what's important with this attacker
model this attacker model actually runs
in the same JavaScript context as your
WebRTC code you can actually interact
with all the api's it can actually see
all data flowing by in any of the api's
you're using for WebRTC so those are the
three Network attackers it's also fair
to say that in our assessment we always
took the site of the end user we wanted
to protect our enthuse as good as
possible within the WebRTC context and
so in order on analysis we have three
parts we have an overview of the general
observations if you're looking to the
architecture what's in what are the
conclusions that we can draw from
40c i have one part that is discussing
the security impact of this technology
on websites that are actually using web
RTC so what are the weaknesses when
you're embodying web part you see what
have you the take care of what are the
best practices I also have a part on
what is the security impact of report
you see being present in your browser
even if your website is not using WebRTC
so you have a legacy website up and
running right now what is now the issue
of browsers all of a sudden being
capable of running web RTC but I will
start first with the general
observations so and one very
straightforward general observation is
of course that the attack surface did
change over application where in this
architecture in the past all
communication was happening between the
browser and the web server now all of a
sudden communication is happening
between the two browsers directly
without any server being interacting
with them this also means that all of a
sudden all the parts we were typically
doing at the server side like input
validation like sanitization now also
have to be transferred to the client
side for client to client interactions
we can even go one step further we could
even use the remote party where we are
sending data to to attack their web
server so when the web server gets
attacked it's no longer the case that
that particular browser might be
malicious it could also be that the
peer-to-peer connection is being used as
one step to send the malicious payload
to the other party and this is something
that we need to adapt into the web
architectures field because we are not
used that communication is happening
directly between two endpoints we are so
used to client-server paradigm also in
securing our applications that now all
of a sudden we have to think about
another part in to interact with our web
application as a second general
observation was one that we made while
we were actually assessing what is the
web RTC permission model and when I say
permission model actually mean to what
operations within my party see do you as
an end-user have to give consent in
order to run them in your browser for
which of those operations do you
actually have a visual indicator that
those operations are being executed on
behalf in the browser and in order to
actually go over the different
characteristics it might be good to do
some kind of a look with within within
his audience so I would propose whenever
you think that you would like to be
involved as an end user when this
operation executes in your browser just
to raise your hands and then we have a
little count on how many people actually
think this is important to be informed
about to actually control that within
your browser so the first thing is do
you want to be involved when the camera
is actually being executed or used
within your application
of course most of the people will have
have good news it is actually the case
that for any interaction with your
camera the user media you saw before it
will actually pop up on a small dialog
asking the user do you want to give
consent to use the camera be aware that
for camera and microphone it depends on
implementation of the browser but on a
lot of cases if you're using HTTP the
consent will be kind of permanent you
give it now but it also is for the next
hour for the next two hours and so on
okay next question do you want to be
informed of under control on control if
some natural characteristics like a
local IP addresses your VPN address and
all the others are collected from your
browser some people actually wave in the
hands it's smaller than when I typically
talk in the security audience but
unfortunately you will not be informed
or you don't have any control that
network parameters get resolved within
your network browser if the peer-to-peer
connection is being set up between two
endpoints do you want to be informed
that and then peak-to-peak connection is
being set up with other party in a
peer-to-peer fashion what I think I
think a large majority and fortunately
this is completely behind the scenes so
you don't have any control in your
browser you don't have any dialog
informing you that appear to be a
connection is being set up by the
JavaScript context do you want to be
informed that your audio video is being
sent to remote peer majority actually
you're not informed as soon as you give
permission to an application to use your
camera and your microphone it can
reroute that stream and
on their behalf you don't they don't
need any consent to ask where that video
needs to send to so with beautiful
technology in the browser all of a
sudden you have your camera to do all
kind of funky stuff locally on a website
now JavaScript can send that video to
any party on the network sharing your
screen
everyone almost everybody I have good
and bad news the good news is it's not
part of the repartee see specifications
so it means that out-of-the-box browsers
do not support to share your screen
because they said they feel that it's
too sensitive to critical to send the
whole screen state because you could
have password managers or other things
open on your screen so in that sense
it's not available on the other hand
they see the urge to be able to do that
and the way the specification actually
handled is at this moment it is
absolutely user to install an extension
that provides capabilities to share your
screen so the extension wall for
instance of Chrome
allows an extension to capture the whole
screen as one of the permissions and
that extension could then expose that
capability to the JavaScript context so
it's actually up to the user to install
such an extension but whether you will
be informed or need consent on a per
website basis really depends on the
implementation of your extension but at
least it's not the facto already present
in your browser when you're starting up
your browser so it's up to the extension
that you're choosing to share that
feature do you want to be able to select
an identity provider well you're not
able to select any identity provider
you're even not able to verify that the
endpoint you want to communicate to with
the IDP is actually the endpoint you
have in mind I already mentioned the IDP
is being used to know that you're
certainly talking to a certain person of
a certain identity provider
well the browser will check you for you
will check that for you but you're not
able to see what identity you're exactly
talking to because it's all hidden
within a JavaScript context your
application could expose that to the
user but your browser will not expose
that identity to the end user and this
is actually the permission model if
you're looking to the permission model
the permission model of WebRTC is very
it means it can actually do anything you
at once within your browser context
without actually needing explicit
consent or need to dialogue with you to
say we are doing this or this party I
think this is good to make sure that
that technology can be used in a very
user friendly way you don't have to
click three or four dialogues in order
to start up a peer-to-peer connection
but it also means apart from the camera
and microphone you don't have any
control or functionality being triggered
in your browser and especially for some
of the text we will see later on this is
very important to understand that this
is the permission all currently within
WebRTC so these were my general
observations now I would like to go one
step further and to look into what or
the the caveats when you're actually
running your own website you want to run
WebRTC technology in your website and I
want to do that in two steps if he's
talking about communication there are
two packs of privacy first you want to
make sure that the fact that you're
communicating is hidden that nobody
knows that you're communicating to
another party the second part is you
want to make sure that the communication
itself that cannot be eavesdrop done
so the first part is really focusing who
just know that certain communication is
happening within your web RTC
infrastructure and if you're looking to
the architecture picture again you see
several traces where people can note
that communication is happening between
browser a and browser B or let's say
user a and user B so of course the
signaling server because the singling
server is handing over all the
information as the piece I see
information between the two parties it's
actually helping to set up the
communication it can actually view which
users are communicating to each other
in a peer-to-peer fashion if you using a
turn server it actually has the
information about the two parties that
it tries to relay if you using a stun
server while the stun server might be
able to relate to different requests
together to dialogue but it's much more
difficult so for a turn server it's
quite easy to observe that you have
communication for stun server it's a
little bit more difficult to observe
that pattern
the third-party JavaScript actually has
the same properties as the signaling
server within your JavaScript code if
it's also monitoring all the api's being
called in web RTC it can actually quite
easily see that your browser is
communicating a to third-party and
similarly the identity provider if you
create assertions if you verify
assertions you can link both together
and see which parties are actually
communicating to each other and this is
important especially in the case where
telcos were tackled in the last few
years because they were actually
exposing for instance the governments
that communication was happening between
different entities now all of a sudden
you don't need to actually fill
infiltrate a telco to know that
information if you're infiltrating a
popular library like Google Analytics
all of a sudden you can know from the
whole world who is communicating with
what the other person in this code in
this setting and this is something that
you need to take into account the
metadata is just kind of public within
the party see where you have a private
conversation and a peer-to-peer fashion
most people think that that
communication will be totally private
you need so many stakeholders to set up
your communication that all those
stakeholders can make information about
the fact that you're setting up
communication so you can't compare web
RTC with tor or with any other bit of
it's a bit bitter and or any other
sharing platform because here you're
actually exposing a lot of details about
yourself about the other party in order
to set up the communication but more
important let's focus on what happens if
you want to actually eavesdrop and
hijack the connection between the two
parties you want to see the video that
30a is sending to party B and we first
look in what kind of network attacker do
and then we will focus what can other
parties within the infrastructure do the
first part is network attacker the
network attacker the only way to
actually eat soup on the connection is
to set up a man in the middle the man in
the middle would actually interact to
browser a as if he was browser B and the
same with browser B as if he was browser
a and such a man in the middle is
actually very hard to achieve in the web
portal C world because the communication
protocols are well defined actually DTLS
already provide encryption mess
authentication message integrity and the
fingerprint of the certificate which
which you want to communicate is already
exchanged in the SDB information so as
long as you cannot interact or temple
with SDP information the browser will
actually see that there's a man in the
middle in between and will not set up
the peer-to-peer connection so from the
networking point of view report DC is
very well protected
it was not able to set up a man in the
middle between browser a and browser B
unfortunately this does not hold for the
signal components this does not hold for
the web server involved for the third
party JavaScript involved in your
application so again if you see the same
architecture picture what happens
typically if you set up the
communication you're getting information
about the network information from the
stun server you have your own
certificate you're using for
peer-to-peer connections your bundling
all the information as part of the
fingerprint with an SDP
you're sending around that to the other
party but any party on that signaling
part can change the SDP by its own SDP
and from then on you can have a
man-in-the-middle because what the
browser will do is check or verify that
the information or the certificate of
the man in the middle matches the
browser certificate mentioned in SDP and
if it matches it will actually have the
connection in a man-in-the-middle of
fashion so you actually are able to set
up a man-in-the-middle as soon as you
are able to tamper with the SDP
information so the only person that only
entities that can do that in the
architecture or the web server the
singing server or any third party
JavaScript running in one of the two
contexts can actually tempura with the
SDP information can tamper and set up a
man-in-the-middle may be important also
to say the man in the middle scenario is
not the most important scenario to
eavesdrop on the connection
another interesting attack that we saw
during our assessment is that you're
able to clone an existing video stream
and send that over an older peer-to-peer
connection to remote party
so instead of actually being infrared in
between register a and browser B as soon
as we are controlling the JavaScript
context of one of the browsers we can
say clone that videostream clone that
audio stream and attach that to an auto
peer-to-peer connection for instance
with the attacker endpoint so even if
the normal connection is happening
between browser a and B JavaScript can
now actually trigger at the same video
streams the same other streams local and
remote will get rerouted to a third
party and this is actually a very simple
way to interact with web RTC
infrastructure and actually to eavesdrop
on the connection and this is also one
of the best practices that you need to
take into account if you're running your
own web RTC infrastructure make sure
that you're not running third-party
JavaScript within your application
isolated in a different domain and make
sure that no third party is running an
application because this could be the
impact of third party software running
in the application so for the part of
the man in the middle actually the
identity providers will come and help
you for the part of the JavaScript
there's no other help and saying well
make sure that there's no interested
JavaScript running in your application a
good best practice for any web
application so for the man in the middle
to actually tackle that you're using
endpoint authenticity what does it mean
you're actually involving the identity
provider so we start in a very similar
scheme as before you have your network
information you have your certificate
fingerprints and now you're actually
using the identity provider - based on
your identity make a signature on the
keystore understand information you're
actually getting a certificate from your
browser that is now labeled by a third
party saying this certificate is really
coming from living the Smith and at that
moment you're actually able to send that
around to the other party together with
the signature and if you want to change
that and it will never match the
signature of leaving the Smith so the
browser is able to detect that someone
along the path to change the signature
of the particular SDP and this is
actually really helpful and making sure
that man in the Middle's will not happen
with in between browser a and B but
remember this is only one part you
need to set up an identity provider in
any web RTC infrastructure but you also
have to make sure that no JavaScript is
running on your endpoints because
untrusted JavaScript will actually ruin
the whole security guarantees you get
for instance by this technology this is
what you do when you set up your own web
RTC infrastructure but of course we can
go one step further what is actually the
impact if you don't have web parties
here don't let your application I think
for most of the people present here if
you have running web applications that
will be in the case that you're running
you're already your application your
clients now have web RTC technology and
what is the impact of that on your
application and we'll mention two things
the first one is already known for quite
a while it means that if you have the
ability to run JavaScript within your
browser and again the best practice is
not to have any untrusted JavaScript
running in your application it is able
to do I see based fingerprinting so it
can actually collect all the local
network addresses attached to your
device and based on that this is the
first step to actually trying to
recognizance on the network to see what
other services are running or you're
actually in a corporate network and so
on this is something that this already
for instance implemented in the beef
exploitation framework this is something
that attackers were doing before but all
kind of timing attacks and now all of a
sudden they have direct access to all
the IP addresses belonging to your
device so to give you an ID and I see
candidate could look like this where you
actually see clearly see it's UDP with a
certain IP address and a certain port it
actually our websites being set up that
actually whenever you serve to that
website or using already the WebRTC
technology in your browser and say these
are the different IP addresses this is a
slightly modified screenshot of my own
PC at work you see a public IP address I
have for my computer you see the VPN
address and you also see my ipv6 address
so all the information is readily
available to a JavaScript call directly
within the browser it will not notify me
in any way
every attacker can already do that the
moment they are running JavaScript in
the browser
you could say well it's not so big of a
problem because you're right
now at least one of the IP addresses
when you're communicating to that party
that's true but often this is the first
step to attack a local network to attack
a corporate network you ready saying
that I'm behind the VPN you have the
local IP addresses you can do the next
step in attacking the network maybe a
little bit more important is to mention
that there are all the weaknesses within
web RTC that can also have a big
influence on your existing web
applications and then your existing user
base and I didn't find a very good title
for the last thing I want to present in
my presentation but for now let's call
it the holy grail of keeping up all
online privacy and this is also one of
the first times that you are mentioning
this kind of attack to a broader
audience this is something that we
recently found in one of our Rich's
experiments it is all to do with how you
actually using the identity provider I
already showed you the image while you
are interacting with the identity
provider you're running some JavaScript
code of your identity provider within
the context of your browser and that
code is actually generating assertions
and verifying assertions what does the
specification actually say about the
identity provider the first thing is the
identity provider in no way is allowed
to have user interaction so the identity
provider should not harm the way you're
interacting with your user it might not
have any dialogue any iframe or any
pop-up they should not be in the
interacting identity provider with your
end user so the direct consequence of
that is if you want to use an identity
provider within web RTC either your user
is already logged in and you could
already use existing state such as
cookies all local storage or anything
else to authenticate the user and you
generate the identity assertion in case
that user is not logged in yet on your
service you have to fail your
authentication and you can provide and
URL to the application code to say if
you want to Rio tentacle with this
identity provider you might use this URL
in an iframe but you're not obliged to
it's really up to the signaling code to
the code of your web RTC application
whether or not to load the
authentication URL this is the way you
have to interact with
EP what does this mean in practice a vo
or not logged in in your application the
application will know a URL why it
actually can ask you to authenticate for
instance to Google or to Facebook but if
you are already logged in into for
instance Google it will generate you and
I an identity assertion automatically
and it will also include an identity
search explicitly the string username at
the domain of the identity provider so
you will know that for instance leaving
the this Matt at gmail.com is being
authenticated by Google this could be
used of course by an attacker because
now all of a sudden we are able to see
which is the user actually surfing to a
website so if you want to say goodbye to
online privacy think about some
malicious JavaScript code being out in
the world that creates automatic
identities assertions so any browser
that has already the IDP implemented in
the browser could trigger automatic
identity assertions what an attacker
then has to do is to be extracting your
online identity from the identity
assertion so it actually asks you to
authenticate to Google you get the
string in the identity assertion saying
username at domain and you can already
link that information to your user this
is actually gold for a lot of companies
within the internet think about all the
advertisers that we have nowadays in our
browsers I think a lot of you might be
using adblock or anything else but think
about the profile that they are trying
to set up about the end users then
knowing your behavior what type of sites
you're visiting what kind of profile
your user is now all of a sudden an
attacker with this kind of attack can
link that profile to an email address or
to an identity with an online provider
so even if you're using multiple devices
all those different profiles can be
linked together to the same user
actually it's a little bit worse than
that as well think about the malicious
code that knows a set of very popular
identity providers so I would say we
start with Google and Facebook that we
can list up up to hundred identity
providers what we do is we actually
iterate over each of them and we look in
what of the identity providers the user
already was logged in before in your
browser
and we typically have our bus open for a
very very long time and every identity
assertion I get I can link it to a
previous identity assertion and
everything can run without any thing
triggering in the browser without any
notification to the end-user with it
without any dialog and now all of a
sudden the the profile of our surfing
behavior we want to protect as good as
possible and make it as private as
possible can now be linked to exact
identities of multiple online providers
and I hope this is also the reason why
we can wait for the further
implementation of the identity providers
and we're currently interacting with the
specification writers to make sure that
this cannot happen as well because this
is really a crucial part if this really
ships within the browsers if we really
have identity providers being present
already answering those assertions this
will be really killing the whole private
browsing behavior we have currently in
the web and with that I think we can go
to the wrap-up so I have some take-home
messages based on the presentation and
now I presented quite some content
within this presentation so I hope you
have some time to digest what web 40c is
all about what are the security
consequences but I think one of the team
take-home messages I want to say is the
first one is it's one of the first
technologies really changing the pattern
we have within web applications the
client-server paradigm is broken we now
all of a sudden have a peer-to-peer
fashion and we have to take that
increased attack service into account
when assessing your web applications
also if you see exfiltration of web
applications currently we have all kinds
of tools that do exfiltration on the
server side to see that no data is being
leaked now all of a sudden all the data
can be shipped to another browser and
encrypted peer-to-peer fashion so our
expectation tools have might have to
adapt to the new context that the web
browser is interacting a peer-to-peer
fashion secondly we saw that the web
permission model is very very liberal so
all of a sudden your browser has become
a peer-to-peer tool without needing any
of your consent only we using the camera
or microphone you need consent and for
all the rest you have a beautiful you
could use for a lot of different
technologies on the one hand very good
because it could be disruptive on the
other side yeah
we have to think about your browser at
being something very open even behind
your firewall even behind your nut third
when you're setting up web part you see
click into account that having the
encrypted link between the two browsers
the peer-to-peer link will not
authenticate by default your endpoints
you really need to set up an identity
provider and we're currently waiting
until the technology arrives in the
browsers but when it arrives and when
that book I mentioned in the last part
is fixed you really have to make sure
that you're using an identity provider
in your application although take-home
message what we saw within this
presentation is something that we see
quite often when you have JavaScript
running an application is that
JavaScript cannot be trusted
it can do all funky stuff within your
application here we saw that it could
eavesdrop on media streams it could
Network and identity information but
more largely it actually can do on
behalf of the user
all kinds of functionality even within
your own application so I think it's
very good a good best practice to limit
the trust in third-party JavaScript
running in your origin in your domain
and use all the possible best practices
to protect against cross-site scripting
quite often console scripting is set
like well you have an alert box in your
application what can be the impact of
that well for instance exfiltration that
we saw on network information on your
identity or all consequences of a
possible console scripting attack on
your web application but maybe the most
important take-home message of today is
not that we have to be very down about
the whole web part you see technology we
really have to be enthusiastic we need
to embrace a very interesting new
browser capability if I was talking
about file sharing if I was talking
about very out-of-the-box conferencing
possibilities within the web browser
these are really really new browser
capabilities and we we should really
embrace them and be disruptive in this
way and with that I can actually show
link you to a few resources
talking about assessment with it on
security so this is a public report we
have on the web security and privacy
assessment / / TC and we also have a
magazine on the new challenges for web
RTC
both were done in the context of
European
this truce and if you want to go a
little bit brawler you also have the
client-side web security handbook which
spells out what are the things to think
about in setting up your web
applications in a secure way so it gets
a very broad overview what are the
different characteristics you'd need to
take into account what are the best
practices to apply in your application
and I will put those sites online so
that you can find the links to for
further reading and with this and
actually open to any question and I hope
I can answer those as well thank you so
any questions go ahead yeah yeah so in
it Philip so the question was do we have
also material on WebSockets yes indeed
we had earlier assessment all among
others WebSockets and all the html5
technology also that's a report that you
can easily fetch from Anisa but I will
give you a pointer after the
presentation any other questions please
so the question is the the way you
actually can extract the online identity
provider is it something really only
related to web part you see over or is
it more common the way we're typically
using web identity providers or in a
single sign-on fashion or out fashion
the way web part DC is actually using
the IDP proxy is new so this is really a
new way of interacting with identity
providers so even if the browser is not
implementing it yet at the same time
also the identity provider does not have
yet the aps present to interact and give
you the proxy for the IDP so this is
something that will come up but this is
really a wrapper to see specific and
this sense I also hope that we can
change the way it interacts to make sure
that that information is not leaking to
the general public
any other question so thank you for your
attention and don't forget to vote thank
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>