<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Advanced Spring Data REST by Oliver Gierke | Coder Coacher - Coaching Coders</title><meta content="Advanced Spring Data REST by Oliver Gierke - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Advanced Spring Data REST by Oliver Gierke</b></h2><h5 class="post__date">2016-11-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/O8-Jm-QfDBA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right welcome everyone this session
on advanced spring day the rest I was
surprised they pick an advanced session
without picking any kind of introduction
in the first place but it is what it is
so we have to deal with that my name is
Oliver Jia I'm work for a company called
pivotal has anyone ever heard of pivotal
ok that's getting better over the years
it's mostly because of like not because
everyone has to know about the company
but after this spring's force pivotal
will be a very pivotal transition a lot
of people like lost track of what that
company actually is what's what it's
doing I'm part of the spring engineering
team leading the spring data project
which means that everything that's sort
of data related and not taken care of by
the core framework it is like ordinary
that Java API is for data access is
basically on my team's desk which means
we're building api's for relational and
non-relational databases for you to
access data easily right and try to come
up with some kind of programming model
that the knowledge that you gain working
with it is easily transferable something
that you find in other areas of Spring
Framework too and it turns out that
there's one so one special project in
that umbrella project so I guess who of
you has never used spring data before oh
only very few hands that's good because
then you probably if you're familiar
with spring data in general then you
know it's an umbrella project consisting
of individual modules for different
stores for it's a MongoDB for JPA for
neo4j for Couchbase cassandra
elasticsearch Solaria Herrera and
there's one module that sticks a bit out
of that kind of of the above the set of
modules that support individual stores
which is the data rest module 8 it was
kind of round about two years ago where
we thought ok there is this repositories
programming model that you have with the
spring data and we've seen people doing
the same thing
it's over and over again on top of these
repositories which was building restful
api is or trying to build restful web
web api's although some of them like
gets to get stuck in HTTP and Jason and
that's that's it right so let put that
thing became quite popular and this talk
is actually about some advanced concepts
in it or basically taking a look over
the fence of what the project actually
is and see okay how can we apply it to
advanced use cases and how can we extend
it how it can we customize it and what
are the usual patterns that we see there
right I've also highlighted a sample
project that we've created to to show
you the more advanced scenarios that's
called spring rest bugs we get to that
in a second it's basically taking the
the domain in that's implemented in
there is taken from a book called
restful web services by all righty in
case you haven't written it before
highly recommended it there's a
Starbucks kind of like shopping
experience like you order coffee and
then the the orders processed in the
back and then you eventually conclude
the order there's a process in there the
original book implements that using
jax-rs
and yeah just like a bit of blue code
for the hypermedia aspects of the of the
rest web service and like it's been
quite a while ago when I thought okay
that might actually be a neat showcase
for how to do that or implement that the
same scenario with the spring stack and
then Along Came boot and Along Came
spring day the rest and it basically
just allowed me to throw away more code
which is kind of nice and it's kind of
opposed to try the example of okay how
do you integrate spring data rest with
with custom logic with more advanced
logic how to make use of hypermedia and
and the benefits that it actually
provides for for restful web services so
I'd like to start with one thing because
even who of you has used to bring that a
rest before that's probably good
question okay that's not even half of
the audience okay so I probably let me
dive into into the the damn the the
five-minute elevator pitch for what
the rest does before we actually come to
the next section which I actually wanted
to start with but if if we have an
audience here that is not entirely
familiar with it now it might help just
to understand what I'm trying to get to
with that section beforehand so I start
with a with a pretty pretty simple
example just to give you the gist of it
I found them CSV file on the internet
containing all Starbucks shops in
Northern America at some point in time
it's 11,000 Starbucks shops I think so
it's got to be like 10 years ago or
something and it contains all the data
or you know basically all the shops as I
said with their geolocation information
right and I thought wouldn't it be cool
if there was some kind of web service or
just like restful api that allows you to
actually search those those stores based
on your current location right think of
it as an around me kind of
implementation where is the next
Starbucks store right and what I do to
actually implement that is I create a a
model class and we will talk about like
domain models a bit in this talk but
it's a very simple one because I'm not
really into modeling a domain here
because it's a very simple thing right
we just have stores the stores have a
name and an address and the address has
a bit of information and also a location
right that's a that's a spring data
MongoDB specific thing here but I chose
MongoDB here because the the support for
for geospatial queries this is a pretty
sophisticated here it's pretty easy to
to implement those so I have this just
these classes there is a bit of code
using parts of spring batch to just like
read the CSV file and map the data onto
the objects and then store them into the
repository that's not that's not very
very advanced or if you've seen spring
data before that's probably not that not
that interesting here what you see here
is a spring data repository which as you
probably can see is a standard spring
data extends
data interface we extend that's or is
something you should have a look at the
paging and sorting repository because we
will want to use the pagination support
of spring data in our restful Web API as
well and then we declare a query method
here that basically is all we need to do
to actually create the geospatial query
right so we use the Korea derivation
mechanism saying find by address
location near which then as probably the
if you're familiar with string data is
basically translated into the
appropriate MongoDB query by translating
the method name and then eventually
seeing that there's a near keyword and
binding the the parameters is given here
to the Korea when the method is called
right so if that already troubles you
then I'd suggest to look up the example
the details of how that works are not
necessarily important for what we're
going to talk about so so far this is
just a basic spring data repository with
with two entities and what I've done to
the project is I've added the spring
data rest library right there's a there
should be a it's a it's a rest spring of
the rest module here the whole browser
we get back to that in a second but it's
basically pulling in the spring data
rest in pieces so if I now start this
thing
travel application if I now run this
thing the CSV file we use an embedded
MongoDB the CSV file will get imported
so that we have these as you can see in
the log
these 11k stores imported into the
database and we actually get to
something like this that's a funny web
front-end in front of it just to
visualize what's what's what's possible
with that thing so just a I used all my
UI skills literally all of them to
actually come up with something like
this here what it's doing it's there's a
spring MVC controller it's just like
basically powering this form here and we
then use a piece of API that we're going
to look at in a second
to actually build this kind of using
javascript to load the results and then
put these markers on that on that map
right it's nothing nothing fancy so if I
use a command-line client here and pull
that up for you a bit and say HTTP 8080
/ p i we get to something like this what
was it
except application helpless jason that
should do the trick right so we see
there some some JavaScript or some JSON
coming back that has or some JSON
document that exposes some links so the
first of all what you see here is a
format called hal hypertext or
hypermedia application language it's
basically a tiny specification that
defines how links are represented in
JSON
it's not the only representation and not
the only format out there that does that
but it basically it's a very simple one
what there's a lot of others like
collection Jason Styron Hydra JSON API
json-ld whatnot they are much more
complicated and and not complicated
they are like more extensive in what
they're trying to do but what hell
basically says okay there's a links
property and we find an object under
that and that there's like named links
that have hrf values and pointing to
something so how does that stores thing
end up here in the first place well as
you can probably guess it's because of
our stores repository right so we can
actually go ahead and follow that link
to get a list of stores surprise
surprise right so the the fact that
we've exposed that repository to spring
data rest and that's of course like
configuration where you can tweak which
repository is supposed to be expo
exported or not you see that we we get
the results here it's like the addresses
embedded there is the location
information in here and the most
important thing actually is what you see
down here is a different set of links
right and because of the fact that we
had the where was it the repository was
a paging in so
repository spring date arrests actually
leverages that that trade really of the
repository to not return all the eleven
thousand stores which would be
ridiculous here because we would just
create a jason with all the all the
stores but it limits it to twenty by
default again configurable and then
provides some links with well-known link
relations this is not stuff that we made
up but there's like the IANA link
registry basically a set of predefined
link relation names with like semantics
defined for them right so there's
basically some official resource that
says okay whenever you find a next link
you can follow that thing and you find
the next page of a paginated collection
basically right and a client that's
aware of that semantics can then
actually use that and like by that
follow the links and actually go ahead
and yeah traverse the collection so
stuff that we get out of the box another
thing that I want to get to is the
search resource it's a resource that we
expose and we go ahead and inspect all
the spring data repositories for curie
methods and those three methods get get
exposed by by you see here there's a by
location link you've probably seen that
in the in the code there is a an
annotation to customize what the name of
that thing is we're not too concerned
about you arise really whether years a
fine by in there shouldn't actually
matter unfortunate to some clients that
does but a good rest kind is like
looking up links and links by their name
and that could be just like an arbitrary
hash or a full bar or whatnot
if you want you can of course go ahead
and customize that as well just the very
same annotation but I just use that to
make sure this is the thing that matters
all right so we get we of course get
support for creating new stores through
the API we get support for deleting
stores for that API so you basically get
get your domain model inspected
and then actually that two main model
translate it into an resource model
basically and springier us doing the
right thing TM right um so if I show
that to people that the reaction I
usually get is okay this is low but this
basically means you have your database
exposed to to the web right you
basically if it's JPA let's say you take
the color of the columns of your table
flip them by ninety degree and then call
this thing jason and then you basically
have a database exposed actually that's
not what we're doing here really i mean
it it's sort of it but it's also not and
the reason i think it's not is that you
can't get to i mean for that for that
stores thing you'd probably get to the
same resource model with just looking at
the table but if it comes to more
advanced use cases i mean we haven't
seen like a relationship between two
entities or resources modeled really
right there was only the the embedded
thing the address was there but there
was not like an order that was placed by
a customer and these things maybe having
two completely different life cycles and
actually that's something that spring
data rest looks at very intensively
because if you've been if you haven't
been to domain driven design yet it's
quite important to make sure that you
understand which kind of role your
classes and your what JPA just calls
entities and i get back to that fact in
a second what what different roles they
actually have right so what we what we
take is we take your domain model
implementation and try to find out which
for very a very important constable
which of the entities you have are
actually aggregate roots and then apply
some rest api patterns on on top of
those
that's basically what what's bringing it
arrested right so the the thing is that
I'd argue that from a database model
alone you couldn't we couldn't go ahead
and
derive what we do ya period right
it needs a domain model it needs
additional information it needs
information about what are value objects
what our aggregate and what not so the
DVD aspect is coming in quite
significantly and then we're actually
doing I'd argue in in in some cases the
the better thing that you might do in
the first place or something that might
be very cumbersome to implement yourself
if you had to do it all on your own so
the idea is and the question then comes
up okay why do you actually do that um
the idea is that we take care of like
all the boring boilerplate parts that
might make up a REST API but and not
because we think that all the
boilerplate parts or the boilerplate
parts are the thing that a REST API
should consist of because that's just
the easiest thing to do right but
because we want you to be able to spend
more time to actually think about the
tricky parts the interesting parts right
are there any custom state transitions
that I want to expose through a link
right is there any functionality how can
I use hyper media for the more advanced
stuff and whatnot so it's basically
we're getting to a picture that looks
more like this right we take care of all
the boring part and you probably have to
think about okay do I really want to
allow like a store to be deleted well if
not then I actually go ahead and
configure spring data rest that way
that's just a decent default I think and
we will take care of all the older
simpler stuff and you should have more
time to think about the tricky things
yeah we get I think if we come to the
entity to the rest box example I guess
that kind of graphic you does this make
a lot a lot more sense alright so for
the rest of the the presentation I
basically try to stick to two code
samples and demos only and we just like
go through them you find a lot of them
in the spring that examples repository
there's economical repository where
basically we have all our examples
they're usually very focused on a very
particular aspect of whatever spring
data module you're looking at and then
there is this kind of combined thing
spring rest bugs in my in my personal
github for for like a combination of
different things where it's kind of cool
to see that
all of that in action and combination
but it's a bit harder to digest which
part is actually like which piece of
code is not actually causing what on the
AP on right so we've done that before so
I can skip that the first thing I'd like
to look at is a concept called
projections so let's have a look at a
slightly more complex example here
because admittedly the having a store
class and an address embedded in in it
and then like being able to manipulate
those via HTTP is very is like very very
simple right so let's get to a more
complicated more complex example
hopefully not more complicated so let me
try to just run this thing and then walk
you through it what we have here is an
order system kind of it's we are
basically basically of customers we have
orders and the orders consists of line
items right so this is kind of this
thing here order line item customer and
we have I have put the country into the
order because I let's think of this as
the destination for the destination for
for for where to ship that order and in
the end we get back to that in a second
but let's concentrate on the order
customer thing here I've used JPA here
to basically make a point that or to
reiterate on the point I made before
that the order is an entity the line
item is an entity and the customer is an
entity right so to JPA on the entity
manager level they are all the same they
are basically like just like tables in
the database however to the model they
are actually not why not like because
there is
the relationship between the order and
the line items is a completely different
one than between the order and the
customer right the order line items is
the the line items actually belong to
the aggregate of the of the order where
order is the aggregate route basically
which means that I
I can't just arbitrarily add new line
items to my database I have to add them
through the order class so that the
order can actually go ahead and maybe
make sure that there's a minimum total
amount satisfied or whatnot basically to
implement business rules here and
there's also a severe indication that
this is the case is basically the way we
try to map this thing here right the
line item life cycle is completely
controlled by the order if I delete an
order
I also delete all line items that's fine
if I delete the order I don't
necessarily want to delete the customer
who died so what does I mean the the
thing that you can see this on most and
that's actually the fact that spring
date arrest uses is that if you look
closely here there's only certain
entities that we have that we actually
have repositories for right we have a an
order repository we don't have a line
item repository that should be in an
indicator for something and there's like
a customer repository and we have a
country repository go back into into
that in a second right so the fact and
that's basically a fundamental thing to
you have to understand the fact that you
have a repository in place for a certain
entity sort of turns that entity into an
aggregate root to spring that arrest it
of course doesn't necessarily mean that
I mean there's nothing we can we can do
to prevent you from doing the wrong
things but we sort of expect you to
treat these things in your code like an
aggregate root and not actually
manipulate line items around the order
or or what have you so let's have a look
at what that stuff looks like on the API
level as expected we have three links
showing up this time right so we have
the customers we have the orders we have
the countries let's have a look at the
customers or
be much looking the same the same way
that they've did before right so we have
a basically a list here and that's the
the hell the hell way of saying we have
a list of something is this underscore
embedded with a named collection right
so that they can basically make a make a
connection to the actual the type of of
the resource and there's a self link in
the customer so that we can go ahead and
just access the customer directly all
right so that's basically what we've
seen with it with the store let's have a
look at the order yeah yeah them this
way zoom out I can just like zoom in
here and that's probably easier so um
with the order we have a single order
here it's not visible okay the so the
the shades I mean it contains the list
of line items they are embedded but you
see here that the customer is now not
embedded anymore right it's pointed to
and actually we create it we expose a
dedicated resource for that
like the underneath order slash one
there's a dedicated resource to manage
the relationship to the other aggregate
root that's a quite an important thing
if you just went ahead and use like
Jackson or whatnot to load an order
instance and then say Jackson please
render that thing it would just render
the entire object tree because it
Jackson itself has no knowledge about a
relationship to an aggregate root or to
another aggregate root with spring data
with with when when we're inspecting the
repositories we actually have and we can
do these things here because what that
actually means is that we can draw a
line or we can detect the borders of the
aggregate root and actually shape your
your representations your JavaScript or
your JSON representations in in net in
that way here right so it basically
preventing the entire database from
assume that the customer again has
relationships to other things then that
would just like blow up your your your
JSON representation also it's that's
that kind of look at the the domain
model is very much driven from actually
from the update side of things so when I
want to
when I want to put our issue a put
request on an individual order let's go
look at that
I usually don't want to manipulate the
customer at the same time right I don't
want to change the customers name or
even if I yes they basically have
independent life cycles the reason that
they are different separate accurate
routes and first place alright so that
gives us a decent model for updates for
patch requests for conditional gates for
conditional puts what have you the thing
is that we run into a problem here right
assume a master-detail view where we
want to show all the orders and that
that mast of you basically is supposed
to include the name of the customer what
will we create with that kind of thing
here basically the n plus one selects
problem transferred into the HTTP world
where it's probably much worse right
it's because additional requests so for
each entry in the order we'd have to
follow that bloody link here and then
see okay this guy is called Dave
Matthews and then we can just like show
that thing in what have you so we
actually might run into situations for
reading purposes we'd need a another
view on the data so how do you actually
do that the thing the first thing is
that you create a so call or we call
spring at a projection a projection
interface which is as you probably know
by now that spring data loves interfaces
you create an interface that just like
declares the properties that you wanna
that you want to expose that could be
just like the same properties as they
are available on the back in class like
we'd get first thing that last name or
that could be additional properties that
sort of access the target object and
then like massage that into some
different representation you could go
ahead and like with something like this
at being dot call method and then hand
the target in so you basically still
would try to limit the amount of
typed code that you have to write here
but you can actually invoke other spring
beans to calculate values and rich the
representation if you want right it's
not only about about limiting stuff it's
also about like you can also in enrich
your representations here so what does
that look like let's say that the thing
was called excerpt right let's go to the
customers all right and she take the
first one and see that the address is
like a complex object here and we have
this gender attribute in here and we can
then go ahead and say question mark
projection equals excerpt and we get the
representation that's basically
described by our interface right all
this thing that the app that that the
projection is actually available to a
client is like exposed by using a URI
template here that's where the why the
self link is included and a dedicated
customer link so that the client
basically can detect oh I can actually
apply a projection and there's also ways
to find out what values you can pipe in
for that for a thing for a client so we
have created and you can probably have a
multitude of them write different
different excerpt or projections for
different views for different scenarios
so the interesting thing now is that you
can go ahead and declare one of these
exceptions as so-called excerpt
projections which basically means or
what we're telling spring a duress is
whenever you actually point to the the
aggregate route that's managed here the
customer we would like you to include
that and a preview of that thing and the
preview looks basically like that
interface describes you that doesn't
have any any consequences if you just go
to the customer it just like continues
to work however if we follow if we just
look at the orders we see that our order
has now gotten a an underscore embedded
clause that would hadn't been there
before
and then it says okay there's an there's
an embedded like a preview for what
customer actually links to so there's a
there's a connection between that
customer and that customer and you see
there's some some data in here
so if you see that your client actually
needs that additional information
you basically shape a preview the way
you poop you need it and then you can do
a single call say give me all the orders
and will include the name here now that
would just work um and you can actually
build a client in a way and that's even
proposed in the hello specification that
basically implements a pattern like okay
try to look up the thing in the
underscore embedded class like let's say
we are looking for a property called
full name or something we could try to
find it an embedded customer full name
if it's not there take this thing
resolved fall back to the to the
expensive resolution and then try to
find the property right with with the
gender attribute that will work gender
is not included here are that's bad but
we can still get it by getting to the
customer all right this thing here right
it's still there all right
projections that's been it
they're supported like through all of
the in different parts of spring data
they we've even moved them down to the
repository level where we can use those
projections to actually optimize the
query execution and just only query for
the things that you're asking for but
that's just the way they are applied on
them on the in the rest world so lookup
types an interesting concept um you've
already I guess found yourself realizing
that the concept of a J JPA entity is
not really matching or not in all cases
matching what the what the domain driven
design entity actually is right and in
some cases it's even worse there are
things that in your domain could be
modeled or should be modeled as value
objects have to become a JPA entity for
a very weird reason which is that you
might want to control
overall set of available values
that's pretty cloudy I guess but
remember I had the this country property
here right let's assume we are only we
only be allowed to ship to a certain set
of countries and actually the country
list is nothing but a list of strings
really right so it's the idea that's why
I've actually modeled using long box at
value annotation this is actually a
value to my model it's just that it
doesn't have any identity if I say
Belgium then I mean Belgium Belgium
Belgium right so the problem being if I
want to make this and an extendable list
that's managed by the database I have to
make it a JPA entity right because I
want to store the the values that are
available in the database and even more
so I mean I could go ahead and then and
say okay I don't want to I don't want to
export or use the spring data repository
for that but just by I want to have like
the convenience of spring data and then
I create a repository for that and if I
do so let me check that or let's go to
the API I don't even have to change
anything here what does that look like
now because spring data is kind of
assuming that again we have a repository
for the thing so it's assuming to be an
aggregate root which is yeah and not
what we really want because that means
there's no no string belgium for example
showing up here like country Belgium but
there is a country link in here and then
to find that country again I have to
follow that link and then I basically
get my single single property here and
like it's a for like a top-level
resource even right as you can see here
which is weird so we can teach spring
@rs to actually change that to what we
call lookup types which actually just
requires a bit of configuration here we
there's like a it's like value
repository that's the for value
repository there's a configuration
option to to change the way a spring
data looks up
or creates the you are eyes and looks up
the entities and what we basically tell
here is say okay this repository is not
really managing an aggregate it's
actually just a collection of simple
well simple values wrapped into a into a
value type we can actually get to the
value that we want to display my calling
get name and on the other hand because
if we want to issue a put request to the
tutor to the server and then submit
Belgium as string and not as a link and
we have to find a way to transfer that
string into a into a value object
instance again that's why we hand in
their method reference you actually if
anyone has seen or if not if you have
seen Brian guts around you definitely
have to buy him a beer because I was
kind of surprised once more to see this
is actually Java six API backing that
kind of expression right there's like
type checks between those methods that
this thing here takes a string as
argument because that thing here returns
a string and we can write Java six based
code in spring that arrests because we
need to be Java six based for for the
current generation and still allow Java
8 users to to write basically the
configuration down like this and it's
actually type checking all the arguments
which is kind of yeah I'm still
forgetting my surprise but it's always
kind of Wow
anyway let me run our save this thing so
that hopefully or hasn't already
restarted does that work did that work
it worked because now we instead of in
creating the bloody link we actually got
that thing in line here it's to the to
the client it just looked looks like an
arbitrary value but we can still go
ahead and tweak the countries and change
that name to or not change it but create
new countries remove other countries and
whatnot all right okay
value types so 25 minutes left that's
good
conditional requests something that I
just like like to briefly touch on
because it's over scenes from
times as in its and it's actually quite
handy because when it comes to the
discussion of whether rest is suitable
for what-have-you
micro-services these days usually then
the question comes up with like oh it's
so incredibly inefficient because you
need to do a request and what-have-you
and the thing is there's a lot of means
in HTTP to actually improve on the fact
that it's not optimized for efficiency
right if you if you're really into
efficiency then a rest call compared to
let's say Google G RPC invocation is
probably yeah on the on the downside
really it's not it's not it's not as
efficient by definition so the thing
that that or there's a couple of means
that HTTP implements things like caching
Casualty is deeply buried into the
protocol and conditional request is
something that people often over see
what we do here to help you with that is
the head of thing is we inspect a couple
of properties on your domain of domain
objects that again ties into the story
of it's not the database that we expose
but we need or want to know certain
things about your your domain model so
for one we actually detect that you're
using an optimistic locking mechanism
see the add version attribute there and
there's also another thing that comes
with spring data is the ability to get
the last modification date set by the by
the spring data infrastructure and that
these are properties that if like a
casual Jackson please render that thing
would just expose to your clients right
but actually we can we can make better
use of them because there are certain
concepts in in HTTP that allow you to or
that that have dedicated semantics right
the last modification date is actually
well define header in HTTP the version
is actually some suitable very suitable
thing to use for an e-tag value which is
sort of like an consider the hash
over over the entire representation
assuming you're still considering the
aggregate route boundaries but what that
allows us and what we're actually doing
here is that we return the appropriate
headers if you request the customer we
take that etag value and turn that into
that version value and turn that into an
e-tag header and the local date local
last modified date field here is also
turned into the appropriate header what
effect does that have you can actually
go ahead and a client can actually go
ahead and take take a header right so
let's let's say we're doing a first
request here right we just like call
customer slash 4711 and we expect the
attack to be present to be present and
the last modification had to be present
then we could do a thing as a client we
can go ahead and say please like I've
accessed the same URI and then I add a
header saying if non-match etag right so
dear server please only give me the
customer representation if it doesn't
match the version anymore so if it had
been updated by an another client or
what have you
right and then it can actually give me
back not modified so it's not sending me
that megabyte of JSON or what have you
again right the same we can do for the
last modified header and so you can
basically do you can optimize on on
avoiding the the representation being
returned and the other aspect of it
that's not in the test case here
unfortunately but you can also use that
for conditional we put request you can
say dear server please only update that
resource if it's still in version if
match if it's still in version XYZ or
what have you
all right so we can actually implement
use that use that stuff on on the client
and just like works out of the box
there's nothing you have to do yourself
in terms of tweaking Jackson in terms of
like rendering the header and and what
have you make use of that in a client
that's that's what I'm trying to say all
right so for the for the time left I'd
like to like give you an overview over
the more or the the integration of
bringing the rest into a into a more
complex scenario where we want to build
a restful web service that's actually
it's kind of a nice example because it's
it's decently simple but at the same
time it covers a lot of ground that
actually make the hypermedia aspect
shine in that usually come it's a bit
coming too short and in the discussion
and also like implementing a couple of
patterns that you will find when you
bring your building restful web web api
is nicely so what is it about we want to
order be able to order yeah coffee like
in a Starbucks case or what have you
so imagine we believe we want to build a
Starbucks application we can just like
order your coffee upfront then you just
let go to that place and pick that thing
up so the the thing what we've modeled
here is some kind of a state machine of
the order really so we start by placing
the order it could be in us it will be
in the state payment expected and while
it's in that state I can actually update
it right I can add new line items to my
order
I can realize that I don't have enough
money on my let's say bank account or
what-have-you I can cancel the order and
the most important state transition
actually is number four because that's
basically me paying for the order at
some point which has a lot of
consequences the first one is that
there's actually a background process
running which means that there is a
someone's going to go ahead and prepare
my order and the other thing is that I'm
not allowed to cancel the the order
anymore right and that's actually a
tricky thing that to implement or how do
the question comes up how do you
implement that conditionality in in the
client really right so if you have a
client that's not using any hypermedia
at all then it probably sort of has to
detect in what kind of state the order
is and then just the question of when do
i display the cancel button right when
do i do that probably just like
inspecting the the payload of the of the
other json quite quite closely and then
do
do things but we would get back to that
in a second
the thing is I've built an
implementation of of that service again
trying to use quite a bit of the of the
spring spring data spring boot spring
letter S stack and I could it just like
turn out nicely that we could actually
separate two things from each other one
is the general handling of the orders
which pretty much follows like the very
simple HTTP API in patterns that you see
okay we want to use a post to create an
order we want to use a patch or put
request to update the order we want to
delete it to cancel it so it's it's very
much like we can just like use spring
data for the repositories there's not
even a service layer that we have to
implement here because that the logic is
so dramatically simple on the other hand
handling the payments there's like
credit cards there's a credit card
validation going on we actually need to
trigger the preparation when a payment
is triggered and that needs a quite a
bit of manual implementation we go ahead
and do so and then you see that slight
shade of green of green sorry in that
spring it arrests box there which means
that we then use a couple of knobs and
and yeah bells and whistles basically on
to to let spring that arrest or know
about that other implementation and then
also tweak it to to put in some some
guards especially for the for the
conditional requests here all right so
the first the first thing is that okay
we I decided to build the payment or the
payment as totally separate end points
right so I wanted I want to write them
spring MVC controllers myself and the
question is how do I do that with the
spring data rest application and it's
pretty easy you just do it as you
probably would have thought what we see
here let me go here there is in the
order web package there's a couple of
things that we're gonna look into in a
bit you've already seen an order
projection or you know already know what
what projections are there's some event
listener
and there's a so called resource
processor we'll have a look into that in
a second
in the payment on the payment side of
things there is basically a spring MVC
controller here right so it's just like
okay we can receive a payment through a
put request when we when we actually
receive that request we issue the
payment and then there's like some
asynchronous magic going on with like a
threat blocking the order for a couple
of seconds before it eventually frees it
to simulate some somebody doing
something and yeah then we return that
thing we with there's some code in here
where as you as you can see we we have
some api's in actually a library that's
independent of spring that arrests it's
called spring Haiti us to actually ease
the the way you you create links in
those response in those responses I
didn't spend too much time on that but
what you've actually see with with
spring that arrests out of the box
already is very very intensive use of
hypermedia elements right all these
links pointing to each other we use that
API under the covers but as you can see
you can also use them from your standard
spring MVC controller and what have you
right so there's like methods to look up
the payment we can eventually we can
take the received in this case here is
like slash order slash something slash
received and then issue a delete request
where we basically conclude the order so
this is like all the the custom state
transitions that stem from the fact that
we can actually pay and what-have-you so
the question is just the the crucial
point you being you just write your
controller with your custom logic right
and then the question basically comes up
how do you actually integrate I mean as
we've used all these hypermedia elements
in our industry innate arrests
representations we like to add a link
pointing to that new functionality right
that's usually I mean that's the way
you'd integrate those things with links
and the thing is that there's like a
thing called a resource processor which
is a just a one method interface really
the basic
says okay whenever you render a resource
for an order right so a single order not
like a collection of orders whenever you
render a single order please call that
spring address please call that method
and here's the original resource and
then you can tweak that thing and
actually return return either something
completely different so you could
actually go ahead and like plug in your
own like object mapping there but I like
to introduce DT also what-have-you but
it's usually used to just like access
the actual content of the resource and
then add links to it right and that's
what we what we do here and here is
basically the point where we implement
that conditionality right we say okay if
the order is not has not been paid yet
we actually add the payment the payment
link and if it's ready we actually add
the received link here right and that's
like what what they what the client can
then actually use because you don't
actually have to look at a certain field
in the in the response to actually find
out oh do I have to just play a display
the go to go to or check out the check
out button or the cancel button or what
have you you can actually the client can
just go ahead is this link present if
that link is present then I can actually
display the I display the cancel button
right let's say let's start with the
other implementation actually it's a
that's a good point to discuss that the
the fact that we could only cancel the
operation or the the order when it was
not paid yet right
that's it basically implemented here if
the orders not paid then add a link with
the cancelled link relation that has an
interesting effect because if you then
go ahead and build a client in exactly
that way
and say okay if I find the cancel link
then I connect then I display the cancel
button so that the the client can
actually send a request to cancel the
order that actually has the interesting
effect of that a business or a change in
the rule in the business rule that let's
say we decide we can also cancel orders
after the fact that it has been paid
right we don't have to touch
a single line of code in the client with
that we can just add the cancel link
unconditionally right we could just move
that up here and be done with it if the
client is written in it in a proper way
only inspecting that the links and then
finding that link it could would still
just like display the link saying cancel
that thing and we basically taught the
the client a new trick without even
touching a single line of code on it if
you're interested in more in that stuff
there's like an article on my blog where
I go into into the nasty details of why
I think hypermedia is quite an important
thing and especially in the context of
micro services and evolving evolving
those but ok this is basically the the
SPI where you can tweak the resource and
add links to it what else was there to
discuss or there's like in an
eventlistener spring that arrests throws
or publishes events for operations on on
the entity right so in this case here we
actually implement an event listener
that wants to react on an attempt to
delete an order which basically plays
into if we went here you see that that
cancel link or that that cancel state
transition it was only allowed when we
when we when the order wasn't paid yet
which which means that we actually have
to for all other states like for
preparing for ready for completed if
someone tries to attempt to delete the
order we actually have to throw an
exception and then basically return the
method method not allow it in this case
so basically implemented the state
machine in this case I've shown you the
order resource processor that's
basically everything that's that's
necessary for for integrating custom
functionality so we basically use the
the fundamental idea of that a link can
virtually point to anything you could
even point to a different system it
doesn't even have to be the same system
right just implement the payment stuff
in a different system why not you just
have to
put a link into the resource that
actually that's actually pointing to
that and you can you can split them
split them apart here all right so the
question comes up the that's what I was
trying to get to the final thing I want
to just like briefly touched on because
I like to take a couple of questions as
well is how do you actually document
that kind of stuff right so if
especially if you're a hyper like the
rest web services become a bit more more
complex or actually become higher-level
web servers right it's not only cropped
an HTTP crowd by HTTP anymore but you
actually provide business business value
through that through that API and not
just a glorified data access API via
HTTP and the question comes up how you
actually document these things and what
I've made use of here in this example is
a library that we that a colleague
annual consent is maintaining mostly
which is spring rest Docs which
basically integrates or the fundamental
ideas that you write test cases to
verify your API what your API does right
and use those test cases to actually
document what the API does right so that
basically leading to the effect that you
only if your tests break your
documentation will not be generated or
to phrase it the other way around you
sort of have a guarantee that you
document what's actually happening right
so what you see here is an
implementation of the of the order flow
basically so we access the route
resource we create a new order we then
trigger the payment we pull the the
order until it has been has been done
and then we take a received and if we
just go for and create new order you see
there is a call call to the to document
in here and we basically say okay we
want a document that this is the step is
called create order and we want a
document that we expect when we create a
new order we expect a certain link being
present and that link is then pointing
to the payment resource and then that
actually turning turning
up to be a pointer to the to the next
step which is access first-order where
is it trigger payment there's another
thing here saying okay I want to
document how to trigger the payment and
then have the I need an amount I need a
credit card number and once I'm done I
want to find a link pointing back to the
order that's basically just how it works
that in turn causes snippets to be
generated generated snippets for my pay
order flow down here for the for the
call requests the way the request looks
the way the response looks and also
looks like HTTP I into HTTP integration
just like a different different HTTP
client basically the one I've used
before in the terminal and then I have
my my piece of handwritten documentation
in asciidoc and that then just basically
includes the use cases asciidoc and that
in turn includes like all the snippets
and if I take in this thing really
seriously so if I had to put it to
production I probably just like write a
bit more pros than oh I can just like do
this thing we're following that link and
what have you
I've set up this project to actually
when the test case is run to actually
produce the the asciidoc snippets in the
first place and then render the
asciidoctor
into HTML and then eventually make use
of i just render that HTML to a location
that spring boot in turn serves by
default like for static resources in
fact which then basically leads to the
fact that I can use an aspect of the
hell browser let's get to that I didn't
mention that thing before I think I
mentioned briefly mentioned it but once
that's done there's some some spring
addressed module that basically wraps
the JavaScript application so that you
can use that that Halla browser here
that in basically allows you to issue
HTTP requests
but then knows about what hell is and
this plays you see that here see that
the the it discovers the links right and
then see it sees that that this thing
has a title and shows that here there's
one thing about the the hell for me
that's quite important is the concept of
so-called curries which basically means
that there's a well-defined name called
curries that has a name property and
that's telling the client that every
link that starts with that namespace
actually or there's documentation
available for a link that starts with
that namespace and you can get to that
documentation if you expand the URI
template that's here right so we find
documentation for the orders link
relation underdark slash index HTML
anchor orders which then means that you
can actually go ahead and browse the
browser the the payment and the the
actual what is the documentation with
that something we put into the into the
into the hello browsers or not into the
hell browser something that you get with
with spring that arrests actually out of
the box is the ability to
internationalize your your links right
the text for the links enum values can
be internationalized to see I've I've it
had been German before and if because I
use a German German browser or the local
US German and if I switch that to
English then the the server would return
the internationalized values for that
it's just using a spring resourcebundle
basically in a message source but that's
kind of helpful if you go go so far and
let the client just take a client just
take these values that come with with
that thing and then use them in their UI
is because I just remove that again to
see there that baxley you get that for a
German client what-have-you the other
thing we do is that as spring that
arrest knows about I told you all about
the the the different we know about the
domain
and what-have-you we actually expose a
JSON schema for the structure which we
then use in our tiny extension here too
instead of displaying what the hell
browser would do normally displaying
just a plain form we basically take the
JSON schema use another JavaScript
library to generate a form from that
thing and then you can just like go
ahead and use that that form to actually
interact with the API the point here
being is that there's a likely complete
package of us providing your support for
also documenting that stuff and then not
just like documenting and it's your
problem or how to make that accessible
you can actually ship that with the API
you can just make it accessible through
the system right the the API is some not
really the API itself discoverable but
also you get just like human readable
documentation human interactable
documentation here all right so with
that that's basically it from my side is
there or are there any questions so far
there's two in the front one in the back
that's all with you good question what
the question was what about security and
access control there is spring security
integration that it basically boils down
to you using spring security annotations
on the repository and they will they
would just be considered right so if you
want to if you want to prevent admins
from from looking or somewhat non-admin
from looking up certain things you just
like put in a spring security expression
you can of course also go ahead and just
use the URI based security to just just
define your security rules but
I see so the question was about access
control that's what you what you put
into a like accident so you want only
users to be able to delete something
that they have created themselves right
you can you have to put that in the or
that that that into either the curries
like anyway there's support for Spring
data integration with the stream
security for curries in the first place
and that then actually triggers the
triggers T the control of that you still
use the the spring security means
basically that are available for the
careful over there one question and I be
done I guess yeah the question is how do
you discover how what projections are
available the thing is that we are not
only exposing a JSON schema but there's
also a pro file link relation that is a
well-defined one where you can go ahead
and just like create that thing and then
go with rest box orders in this case and
by default it will return a description
format that's that's a pity that's not
working here but by default it's it's
going to return a description format
called Alps application level profile
semantics that basically describes which
state transitions are available and it
will tell you that for the projection
value there are these projections
available so because we have that
knowledge on the server we just expose
it in a in an appropriate format for
that alright I guess we have to take
that question offline happy to answer it
combine the second thank you very much
for attending sorry have overrun of it
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>