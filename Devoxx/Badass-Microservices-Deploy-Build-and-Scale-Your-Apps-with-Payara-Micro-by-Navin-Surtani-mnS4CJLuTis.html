<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Badass Microservices – Deploy, Build and Scale Your Apps with Payara Micro by Navin Surtani | Coder Coacher - Coaching Coders</title><meta content="Badass Microservices – Deploy, Build and Scale Your Apps with Payara Micro by Navin Surtani - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Badass Microservices – Deploy, Build and Scale Your Apps with Payara Micro by Navin Surtani</b></h2><h5 class="post__date">2015-11-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/mnS4CJLuTis" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right we okay to get started doesn't
seem to be oh okay good all right guys
afternoon I'm here to talk about badass
micro-services yeah buzzwords we like
my name is Naveen brief introduction as
to what I've done before worked on JBoss
open-source projects since 2008
currently a consultant for a company
called c2 b2 consulting in the UK and
recently I've started doing some
development work on payara so yes what
is this talk about actually just before
I do continue I should mention this is
actually too quickly slots so I'll
probably wind up going over the initial
15 minutes in total probably taking
about 20-25 minutes or so yes so what
does this talk about we'll do a brief
introduction to payara micro and I mean
ultimately it's the container we're
going to use to deploy these micro
services to will talk about how you can
use it and I've put together some demos
so you know cross your fingers and toes
and let's hope that it works at the end
so yes what is by our micro this is
probably one of those cases where it's
not so educational to talk about what it
is just get rid of it and instead let's
talk about what it isn't so it
definitely isn't a full-blown Java EE
app server it's not fully EE compliant
it neither is it just a web container or
a servlet container it's a bit more than
that
it's neither is it a container for
massive monolithic applications because
ultimately this is here to talk about
micro services and we want to try and
make sure our deployments are small so
yeah cool micro services right we're
already there in that you know waiting
to be let out of that cage to Rilke tech
things to be you know to to build these
small applications that'll be very nice
and easy to manage but a problem is that
we've still got a lot of this old legacy
code and we still have to deal with that
so we're not quite feeling so happy and
instead we kind of feel like that right
you know we could go and just rewrite
everything from scratch but of course
that sort of stuff doesn't quite scale
so we need to find a way to deal with
that to manage it so that's kind of
where PI our micro can come in and help
so we'll take your standard servlet
container your ee container so at your
web container not EE which is what I
said and we add in some EE api's onto it
and that really is the genesis of PI or
a micro it's based off of the embedded
GlassFish that basically gives you the
web profile and and then after we've
we've added in sums and api is you get
this pi or a micro jar file and you will
then be able to like deploy a war file
through the command line which is what
I'll show you in the demos and you can
also if you prefer you can create a fat
jar in a main method and do it that way
okay right
demo time ready okay so the the first
demo that I'm going to show you I had a
couple of issues with with my IDE
importing it in so it looked all
horrible so instead I'm just going to
show you the github links so this this
demo really is just a pretty simple rest
service that makes use of the J cache
api's I'll show you where we go that is
my rest endpoint
it's called cache there's a put method
where you can put in a key
well standard key value store and
obviously you can get it out
the only other class in the application
is oh sorry I was going to say guys at
the back can you see that text or is it
too small yeah okay yeah so fairly
standard easy stuff if you guys have
built this sort of stuff before right
I'm guessing none of this stuff is
really that new but it's pretty small
pretty easy to see okay so what I'm
gonna do actually kill that and kill
that as well start with a fresh one so
the way that I can start start my server
instance is like so this standard server
- char right so that command is just
saying start up the runtime for payara
micro I also need to give it a
deployment in this case
in this relative path right pretty
straightforward right
but there's one more flag here that's
quite important that I want to use which
is called Auto bind HTTP assuming I've
spelled that right so by default when I
start the deployment it or when I start
the server it's going to try and bind by
my HTTP bind my my web container to port
8080 which is standard HTTP right but
when I try and add more onto it I'm
gonna get port conflicts so if I pass
that flag into into my startup what's
what's going to happen is if port 8080
is taken it's just going to look at the
next available port so eight 80 81 if
it's available it'll take it if not
it'll look at 80 82 so on and so forth
okay so we'll start that one up
which hopefully is going to work there
we go let's increase the font size a
little bit
okay see ya as you can see down here at
the bottom it says deployed one more
cool let's let's get the second one up
and again in a couple of seconds we
should we should have that deployment up
and running
cool so now now I've got two instances
out right let's let's try and test it so
what I'm gonna try here on
localhost:8080
I'm gonna I'm gonna try and put oops I'm
gonna try and put that JSON in right so
that data acts as my key and the value
is another so again simple key value
store but that and we can see that yet
the response is coming back without any
content but that's purely by design
that's intentional so it's still a 200
code so we're happy with that now we'll
try and get that out and there we go so
this is all on this is still all on the
same instance right so if I change that
81 there we go
it's in there now just to prove that I'm
not cheating you I'm gonna change that
to dev ox okay so I put that response
doesn't contain any data that's fine
and now if I try and get that again it
says data that works we can also we can
also test failure on that in fact so I
got that on the wrong instance yes on
880 data devoxx
so I'm gonna kill 80 81 and if I perform
again again I know that I still have my
my data so again pretty simple pretty
simple setup very very simple
application right
in fact okay hop in there main thing it
worked
relief alright but what what did we
learn from that did did anyone notice me
have to do anything to set up a cluster
in terms of configuration I'm gonna
assume that's that that's okay because
nobody put their hand up see ya
that it automatically clusters pretty
straightforward the only the only thing
I had to do because I'm using the same
because I'm doing on my laptop I just
had to ensure I added the auto bind HTTP
flag okay
so now onto the next demo which is maybe
a little bit more interesting aha
presentation would good
so this saw the demo what I've set up is
basically just a Twitter stream it's
using Twitter's streaming API so if you
guys are tweeting about devoxx you know
go ahead please do so we'll start
picking them up in a bit and what we do
is we just got a fairly simple easy be
on startup what we do is we just we
instantiate a Twitter client it will
collect all tweets with with the string
devoxx lowercase D or uppercase v and
it'll go and dump that into a queue
so within here I also spin up another
thread which is basically going to start
consuming data from this queue which I
have over here which is in this method
called save Twitter data and I also have
also modeled my tweets like so so all
tweets have the tweet text as a string
my stores like tweet instant you know
when someone set the tweet out I store a
list of string as hash well store on my
hash tags and a list of strings and I
store who actually sent the tweet out
and after that what I'm doing is I've
got a few rest endpoints that I've built
for this so it's relatively
straightforward I just grab the e2b this
is just what I was using for for testing
which is just okay you know if my my
stream has started up okay I should be
able to collect the the number of tweets
so while I'm talking to you about about
the other endpoints what I'll do is let
me kill this as well
so I'm gonna start in this case I'm not
going to worry about adding the Auto
bind HTTP flag because I know I'm only
deploying one instance of it and there
we go
it's deployed up so that's going to
start collecting some tweets in right
and while it's doing that let me well
I'll just show you one of the other one
of the other end points that I had put
together so this is the search tweets
endpoint it's going to return just a
JSON of whatever parameter I give it
it's going to return a JSON of all the
tweets based on a search parameter so
it's going to remember it's going to
collect all the tweets with the string
devoxx in it so in theory if I give it
if I run a search with devoxx I should
get some tweets
get out of there okay
let me just grab something from my
history without that I was using to test
okay so now if I run a search there okay
cool so we've managed to collect five
tweets that's let's run a search on that
this is very likely to break because my
uh it hasn't very good the the way I'm
generating the JSON is really really bad
and really broken so it's in my testing
the number of times this has come up
with some rubbish is very very frequent
so yeah it's actually collected these
tweets really does anybody want to help
me test it now's luck do you want to
sender to send out a tweet can contain
anything just have the string devoxx
endure this is just a proves that I'm
actually collecting some real tweets out
there and well this part really has to
work done okay so I'm going to change my
endpoint that by user and what's your
Twitter handle does look that's about
correct okay so now if I send that
request off there we go so it's actually
managed to collect the tweets correctly
thankfully and yeah one one other one I
had put in was so by hashtag counter
there we go
so the hashtag devoxx all lowercase
we've collected five times out of all
the tweets that we've sent lowercase
devoxx has been collected five times and
yeah so in terms of the actual demo
that's that was more or less that I
actually had a better fist pump for that
one working but again
what no what we learnt is that we can
still create these fairly small modular
services using our standard Java EE
api's and we we can get them live pretty
easily pretty quickly and the the main
thing that I did or another thing that I
did want to show what's a way of which
will be of use if I do
the actual size of that jar file is like
58 mega so it's really small for you to
grab make use of and deploying your
docker containers or even in even on
raspberry PI's so it's really quick
really easy really small and but hence
why it's got the name micro in it right
see ya summing up well what do we see we
deployed a web app through the command
line we built some restful services
using using standard EE api's but
remember that it's not fully compliant
but we've still got the power to do some
of these things partially because these
ap eyes are still quite useful and also
as I said you've got all this legacy
stuff using these EE API is that you can
slowly start moving over in the first
demo we also tested like auto clustering
Escoto cluster discovery and failing
that over as well so yeah that's more or
less that thank you very much thank you
for coming if anyone's got any questions
feel free to come around and ask away
thanks a lot guys</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>