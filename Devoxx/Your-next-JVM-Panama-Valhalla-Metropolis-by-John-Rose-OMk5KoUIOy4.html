<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Your next JVM: Panama, Valhalla, Metropolis by John Rose | Coder Coacher - Coaching Coders</title><meta content="Your next JVM: Panama, Valhalla, Metropolis by John Rose - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Your next JVM: Panama, Valhalla, Metropolis by John Rose</b></h2><h5 class="post__date">2017-04-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/OMk5KoUIOy4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so this talk is about where we're
pushing the jvm where the JVM seems to
be going whether we push or not we're
where we think we'll be maybe even in 10
or 20 years it's we're 10 or 20 years
into the Java ecosystem we think it's
got at least that much time left to run
one of the key ways to preserve and
extend the job and the mission of the
JVM and Java is to make sure that we're
able to do the the jobs that are coming
up in the future and I want to talk
about that today this will be I I'm the
I'm the architect of the JVM not I
didn't by no means design all of it but
I'm the current sitting Oracle architect
within the JVM team I've been involved
with Java since almost the beginning for
for about 20 years now
and so I I want to tell you how it looks
to me and how it looks to our team and
and some extent how it looks to the open
JDK community I don't speak for the
whole community I speak for myself and
my team and Oracle but I hope also to to
speak for where we as a community want
to go with this wonderful technology we
enjoy
however the lawyers instruct me to tell
you not to believe a word I say what I
want to do I want to give you some of
the trends I want to show how we are
taking concrete actions today to work
with those trends it is a complicated
talk I'm going to talk fast I'm going to
I have time for about a minute per slide
or not much more so here it comes
I did not have time to make it shorter
as the elegant letter writer said so
this is a snot this is a slide that I
enjoyed making a couple years ago for
the JVM language summit how many of you
have been to a JVM language summit a few
yeah it's a blast it's always a crowded
room full of crazy people who are
thinking about the next steps for the
Java Runtime we had some we we think we
have some long term goals that that will
hold up over the next
or twenty years and so far two years
into the predictive cycle it seems to be
working we want the Java Runtime to have
a uniform model we want all of the
pieces of data to feel similar so that
the things the reflexes you learn to
work with arrays work on values and
objects and primitives and methods and
types you want to be able to assign
anything to a variable pass anything as
a as an argument return anything as a
result that's sort of a thing you want
strong typing that you want a unified
way to deal with all the disparate
details of application composition and
you want all of this to be very
efficient in memory you want to be able
to have data layouts that can be made
tuned to be as flat as possible you want
to have the data to be easy to make and
then when you when you decide that it's
mission-critical that a particular kind
of data be very compacted very efficient
you want the cooks to be able to expend
the extra effort to tune up that
representation in particular although
the Java VM and language began as a sort
of a better better small talk you might
say or better C++ you don't want it to
be so pointer intensive in order to get
efficient memory layouts today pointers
are actually a higher cost than they
were 20 years ago and in 20 years it
will be an even higher cost probably so
we want to be able to have data layouts
that are pointer thrifty which is a new
a new direction for Java that was not
that could not have been predicted 20
years ago one thing that we always want
is speed and good code computers that
run on bad code well Intel actually runs
on really bad code but that's amazing
how they do it in any case you want you
want code that you're responsible for to
be as as efficiently compiled to the
hardware as possible and we want that to
continue to be true Java uses online
optimization techniques which means that
it can produce better hot loops in many
cases than static compilers like C and
C++
the future I think we'll have less
threads in it or more little tiny things
that used to be threads better but are
more composable and agile so we want we
want to fire finer grained concurrency
and at the same time less degrees of
unimportant freedom to create race
conditions in our in our applications so
I would say the future is post threaded
and so think fibers about that the
future is also interoperable it is not
the case that you can write a language
that is so compelling that everyone will
drop their existing source code and
their existing libraries and go to your
language and code in it for the rest of
their lives right that doesn't work but
what you can do is provide a language
that is really competent to connect
those pre-existing components and and
take those libraries that you already
depend on and combine them in new ways
and make new applications and a language
that does that well well that's going to
be a language that people use more and
more and and maybe in the end a sizable
amount of stuff that will be written in
it but it will still work with with all
the stuff that hasn't been translated
into that new languages that sound
familiar that's really the story of
Java's life it's become a wonderful glue
for applications as well as a something
for writing new algorithms in its own
right and of course you want you want a
language like Java to be general-purpose
you don't want it to be in 20 years we
don't want to look at Java and say oh
yeah that's the code for writing
applications the way they wrote them 20
years ago that's no that's not what it
is today today it's a language for
writing modern applications we want it
to continue to be like that and finally
one of the jobs of glue is to glue is to
hold for more than more than a second
write glue that lets go after a year is
not very good glue you want if job is
going to be used to glue stuff together
you want that glue to last for a long
time you want it to be library quality
which means that jars that were created
20 years ago 30 years ago in the future
should still continue to run I call them
dusty jars and give in analogy with the
old-fashioned dusty decks right you take
a dusty deck of Fortran code does it run
I don't know it's always an adventure
finally whatever the future holds for
new CPU types you know many core wider
data paths who knows what's coming up
persistent memory is a big thing right
now whatever the new CPUs are we want
the JVM and the Java Runtime and the
Java language team to keep track of that
and be able to compile useful programs
efficiently to whatever those new CPUs
are which means we can't just stick with
64-bit Long's and say that's the end of
all our of all of our primitives it is
hard to forecast but sometimes you can
sort of take a local derivative and make
a make an oversimplified vector in the
direction you think you're going and
then maybe when you in the future when
you when you get there you'll say yeah
that vector was off but it wasn't off by
too much right that's what you do when
you forecast by the way this is one of
my two graphics I hope you enjoy it
these slides will be up on on my
presentation page and openjdk there's a
link at the end so you're not going to
be able to read all this and I'm not
going to be able to explain all of it I
in fact I probably have to start going
faster in any case here are some trends
in JVM design that we are seeing right
now here's here's a attempt at drawing
that vector as it looks at this point in
time we think the predictability and
security reliability is increasing in
importance we want to be able to create
JVM packaged applications Java
applications that can be provisioned in
advance to do specific jobs and then
reliably start up quickly to do those
jobs and without and consume only a
predictable amount of resources we want
that resource consumption to be
manageable we want it to be tunable if
they're going to be GC pauses we want
the the GC pauses to be controllable in
length this is a this is this is not
stuff we do today completely well but
we're working on it very hard and we've
made some progress and over the next
several years we'll be making more
progress in addition we want to be able
to take telemetry out of the
and see what's going on with that VM and
control it at a distance so you don't
have to be up close and personal in a
debugger in order to manage it right
everybody knows that's the future of how
computing is going in in big data
centers so we have a number of logging
capabilities and and remote management
capabilities and we're continuing to
invest in those I think that's going to
be important I already mentioned density
flatness of data pointer thriftiness
that's going to be important because
we're putting more and more stuff in
memory because memory is just getting
bigger memory is also getting less
uniform memory goes up to terabyte
scales but it's getting slow because
it's a special kind of persistent memory
so not only does it live after the
process died but it's also slower to get
into and out of get data into and out of
so we need we need to continue to
provide many size fits many
opportunities for creating data
structures not not a one size fits all
kind of Lisp or small talk model
immutability is also important
immutability is the key to avoiding
those race conditions from unintended
unintended degrees of freedom in your
data structure do you really need that
field to be usable all it is is it's an
attraction for bugs when you when you
hand off something before it's been
completely settled to memory and then
someone else reads the value reads the
field before you've stored the value in
it or some attacker manages to notice a
way to get into that field and put a put
a race condition on it that's just
nobody nobody wins from race conditions
it's better to reduce degrees of freedom
and data structure in particular by
locking down immutability everyone
understands that that there's not just
one programming language in the world
the JVM embraces that Java leaves plenty
of room for other languages to run
alongside of it so we want
interoperability and the ability to
choose the language that you want at the
same time we're going to make the best
language we know how to make - and
finally this is a trend I think which is
important to the creators of the
infrastructure of the VM we want to be
able to layer our implementations better
we
want to write so much assembly code we
don't want to write so much C++ code
which quite frankly often feels like the
assembly code we want to be able to
write stuff in Java and in the
higher-level kinds of Java and when I
say stuff I mean the stuff that actually
interprets the Java code so there's a
real meta-circular bootstrapping problem
here but that's it's known how to solve
that we want to be able to create
abstraction that not only for us but
also our programmers and the compiler
implementers too to express only what
they need to in the byte codes without
creating enormous amounts of boilerplate
code at the bytecode level just like at
the source code level we're kind of
allergic to boilerplate we like ID use
to help us expand it we want the VM to
be able to expand boilerplate at the at
the bytecode level invokedynamic is an
example of that we want to we want a
data model that's more flexible uniform
that's value typed and then finally for
implementing the JVM on top of its own
language we're very excited by them by
newer technologies like crawl which
allow you to have a complete code
pipeline that's written in Java
portable job all right some big ideas
that relate to these trends what the
platform should be interoperable with
other nearby platforms
let's make native code and data look
like Java code and data not that we can
make all the differences disappear but
let's bring them together let's heal the
rift let's let's not force programmers
to leave the Java ecosystem in order to
get a tight loop over here or a flat
data structure over here or an off
buffer over here this is why I'm safe
was introduced years ago to allow people
not to have to leave the Java ecosystem
in order to get to native memory we have
better replacements for unsafe such as
project Panama which which lets you get
a native data in a type safe manner in
any case the big idea is to not force
people to go out of the managed runtime
in order to do manage things we talked
about this at the boss last night for
Panama this this is this depends partly
on value types because Java's classes
are currently tied to Java objects and
would think the classes are inherently
tied to objects but they're not a class
is a bunch of named API points methods
and and data connections fields if you
will
interfaces that has nothing to do with
objects necessarily in particular the
piece of the object that a class does
not entail is the identity and
statefulness of the object you can have
perfectly good classes that are not
stateful and that's exactly what we're
doing with value types in project
Valhalla we're creating we're creating
values that do not have the the
overheads and burdens associated with
objects which is headers and pointers
and state and race conditions and yet
have all the other advantages of them
and this will let us have small
lightweight agile data types that can
then be used as cursors into other parts
of the world in other words smart
pointers in C++ you call them smart
pointers a smart pointer is a little
struct right that you can easily work
with it has its own invariants and its
own behavior that that's something we
can do in Java too and that's one of the
that's one of the outcomes of valhalla
will give us ways to describe not state
that is owned by the Java heap but non
state that points intelligently
somewhere else in the universe
interoperability also depends on a way
to bridge from Java code to native code
to
non non Java layouts and the JIT is a
great code generator for this there's
nothing that says that the Java jet has
to generate code only for working with
with Java data structures it's a
perfectly general code generation
mechanism it's comparable in power to to
other code generators like the GCC back
end or LLVM so let's use it for that
this would enable coupling to a wider
range of hardware types data types and
in order to in order to have a if we get
a more a better interoperability story
which is which is what Panama is is
aiming at the project Panama then we'll
be able to write in Java code that
natural and java-like and be able to
work with some Java IDE s Java strong
typing Java encapsulation and yet still
have smart pointers that point to dusty
deck COBOL images or cutting-edge GPU
arrays and be able to get in there and
do the job without without leaving the
comforts of Java one I want to call out
in particular is we have something which
I call an as in statement for Java
that's being prototyped in which you can
make a method handle I hope you have
heard of method handles which
encapsulate a single instruction that
has a little bit of information to tell
the JIT which registers that instruction
uses and otherwise just tells the JIT
drop this instruction in when I call
this method handle so it really is a
NASM statement for Java and we have in
combination with some other technology
some Intel engineers are doing really
brilliant work creating really nice easy
to use Java API s for directly coding
vector loops and this is in my opinion
the best current way to code vector
loops on Intel you I've done it with
assembly language and with the new CC
intrinsics but but this is nicer so
panama is broadly speaking i've
mentioned a couple times
it's the interconnection story it's what
comes after J and I it's the much wider
broader freeway between the manage in
the end managed world as opposed to the
red-tape ridden narrow footpath that
j'ni is one of the goals is that we have
zero handwritten code last night Paul
Santos did a wonderful demo of this
where he showed an API that was a C API
with a header file and in a dynamically
linked library
he ran the header file to a header file
grovel or called J extract it extracted
metadata the metadata was about six
kilobytes in size it was in the format
of a jar which was a bunch of interfaces
real interfaces you could put in your
IDE and look at with annotations about
binding and and then fed that into a
bind
that created classes under the
interfaces that were that could connect
immediately to the data and code of the
C API and it was a ordinary non-trivial
C API with dozens of data structures and
dozens of function entry points and
pointers and care stars and all that
stuff floating around it wasn't
precondition to work with Java and by
the way if you do this the old j'ni way
you have 10 kilobytes of of stuff and
it's not stuff that's automatically
generated by an extractor you had to
write every byte of it it was Java code
and C bindings for the Java code in the
native functions and that's no fun you
also get with with this new approach you
get the directly optimizable calls which
I mentioned earlier you get direct
optimizable access to off heap
equivalent to what you would get from
unsafe but it's all type safe and and
managed for you you also get storage
management abstractions that help you
avoid dangling pointers that is a
problem with C and then finally the
direct access that I mentioned earlier
the jumbo data types like 256 bit vector
in like things those will those are one
of the reasons we're doing value types
in Java in project Valhalla so that we
can interoperate very directly with
whatever data types a a CPU throws at us
even if they're greater than 64 bits in
size and that cool in in the end we want
to provide better glue better use of
native resources anything outside of the
managed runtime of Java another big idea
I already mentioned but I won't expand
on is Java on Java
let's implement the Java stack on top of
Java let's reduce our dependency on
assembly code and C and C++
especially since C++ is moving in its
own direction with its own kind of
managed runtime good luck to them but we
want to use our runtime this is a kind
of a another unification move and in
particular we want to reduce the cost of
ownership for crucial Java technologies
starting with the VM but also
other things I depends partly on Panama
itself because parts of the VM will
always be in see or Hardware sensitive
and so will always need some way to get
from whatever the rest of the VM is
coded in Java to the native parts the
hardware parts but we want to be able to
integrate more and more pieces of Java
such as Grall into hotspot this depends
also partly on hardware level data
structures which means Valhalla with the
flat data and the small value types this
will reduce all of our costs to code in
our own language instead of in C++
currently the whole JDK well that's an
exaggeration but 99% of the jdk is coded
in Java so that's good it's been true
for 20 years the method hadn't run time
was initially coated in an assembly code
boy that was a mistake that was my
mistake
I had to undo it and code it in Java
instead and it's much more manageable
some of us lived through the teething
pain of that the the Ã¤Ã´t compiler is
actually an application of Gras which is
to generate code statically for Java how
many of you know there's a head of time
compiler in Java 9 oh good yeah ok it's
it's so it's well well publicized there
are other experiments we're doing we're
using golf the labs are using growl for
a JIT they've been doing that for years
and it's looking very good it's not yet
ready to replace the server compiler but
it will get there other experiments like
the substrate VM Java and Java needs a
project it needs a unifying project in
the open JDK ecosystem and this is a
this is a working title for you project
metropolis there's no formal call for
project yet we're not ready to put the
pieces together but I envision a city of
tomorrow called metropolis you you may
know the Fritz Lang movie the Fritz Lang
movie by the way that the theme of that
was also healing a sort of a rift
between the heart and the head or
something like that something
sentimental but given that we're doing
heal the rift moves in Java unification
metropolis the city of the future is
a bad reference the idea here is to have
an experimental clone of JDK 10 that
hosts extensions work on the Ã¤Ã´t
compiler and Grall in particular since
Ã¤Ã´t is built on top of gras we have a
synergy there but we also want to a ot
grow itself in a restricted mode which
which will make it a replacement for the
C++ code of the of the current server
compiler in order to do that we need to
probably define something like a system
Java which is amenable to static
compilation and reduction so we'll be
able to we'll have to do experiments
with substrate VM style deployment
substrate vm is a is a another labs
project that you can see christian
Bimmer work works on it and you can see
a JVM language Summit talk from last
summer on that it's called one via one
VM to one compiler to rule them all
something like that it's one of those
sorts of titles oh hold on a gap there
we go so in addition to replacing the
JIT with with java coded stuff the JIT
is the largest piece of the VM right now
it's like I don't know 40% of the VM or
more it's a huge amount of complicated
C++ code I'd rather have a huge amount
of complicated Java code it's got to be
complicated it's an empty complete
problem but at least I want to code it
in a high-level language but for
teething exercises or or starter finger
exercises we want to do some smaller
pieces the VM also in Java and so
there's a list of possibilities of P of
discrete parts of the VM of the Java
Runtime that could be transformed from
C++ into system Java but the big one is
of course growl growl is a very good
code generator as I said earlier on and
it should replace c2 eventually but it
should also replace c1 which is the
client compiler should also replace the
interpreter generator and various stub
generator in other words why have
multiple code generators in our
ecosystem you know maybe there's some
foreign code generation code generator
off on the side that you use for
specialized purpose but if you're
generating stuff that's for the middle
of the Java stack
it should be generated by something we
control ultimately I twenty years from
now there might be zero C code in the in
the in the Java Runtime except for stuff
that's edge edge code to connect to C
api's this will be tomorrow's reference
implementation and it'll be a better
reference implementations today than
today's because when you refer to it for
reference you will refer to high-level
Java code that is easier to understand
and then C code and assembly code here's
another big idea I mentioned it earlier
what's after threads
I think of threads as dinosaurs that
like dinosaurs they are very heavy and
big they usually move slowly they're
kind of dumb or rather there is some
intelligence there but it's like in a
little tiny brain in the current stack
frame that's what's going on all the
other parts of the thread are just stack
frames and other metadata that's waiting
for you to get done doing the important
thing that you're doing and it's it's a
cost that you have to pay even though
all the all the useful stuff is going on
and just one a few little cache lines
near the top of the stack so let's let's
take those important parts and keep them
let's throw away the gigantic
pre-allocated stack frame
let's throw away by the way if it's not
just it's not just reallocated stack
segments it's also the pre-allocated
register files there's tens of kilobits
of State in modern processors for
threads and if you when you swap between
threads you have to load and store
copies of that state get it out of your
processor and then get a new new
snapshot into your processor that's part
of the dinosaur mentality what we want
is to be able to have pieces of
concurrent execution call themselves
almost call each other almost as
efficiently as function calls right it's
an old idea
it's called co-routines or fibers but in
any case we don't want to simulate that
with gigantic threads anymore so we want
to leave them behind with the fossils
this depends on some really tricky cuts
in the JVM because the JVM has been
designed in a threaded model
it's hard to decouple it and and wean it
off of the thread model but we have some
very good insights into how to do that
there have been talks in recent years in
the jvm language summit on how to do
this library work is also required it at
all the edges where you could block
you're assuming that you've got a thread
that can hang around forever you know in
the in the Tar Pits until you're done
blocking and then wake up and pull
itself out of the tar and lumber over
and do something else that's no good
instead you want a blocking API to say
okay I'm blocked put this little tiny
piece of important data on the heap and
go do something else that's mean while
that's useful
no no lumbering dinosaurs will still
need something like threads but
basically one threat one thread will run
any number of fibers sequent you know in
a multiplex manner and that's how you
get huge concurrency wins that's what
that's what fiber like or gogo has
fibers are called go routines and Co
routines but basically when you have
lightweight deep bits of computation
decoupled from the heavy threads and the
threads become draft animals and the
fibers become the intelligent little
thinking dinosaur Raptors or human
beings that are that are writing on top
of the dinosaurs and I can jump off them
when they get stuck in the mud so
mounting and dismounting is the way I
like to think about fibers so we're
doing current experiments for for more
intelligent writing on threads one of
them is better stack walking there's a
stack walk API which which reifies the
stack and is able to see inside of it
and we want to eventually be able to not
only look at the stack but also replace
it say hey I don't like the stack you're
running I have a better idea
run this stack instead I've saved
whatever I cared out about from the
previous stack trust me to come back to
it right now I want you to view this
stuff basically more steerable dinosaurs
again lots of library work is required
and there's interactions of
synchronization which are wonderful
research projects
pardon me while I do a time check I
don't have a clock visible to me okay
in any case the the JVM has new tricks
it needs to learn in order to do this it
needs to be able to take the useful part
of a computation and and lay it down
dismounted onto the heap which means
right sizing and right typing the the
stack framed information right now we do
that really well inside of stack frames
but we don't have the trick of moving it
into the heap dismount and then moving
it back when you want to execute it into
the stack remount but that's those are
tricks we know how to we know how to
create another big idea is value types
everybody's heard of this this is
another heal the rift classes versus
primitives invidious choice between them
how am I going to choose between a list
and an array event oh no one's good
sometimes the other is good at other
times they each have their disadvantages
let's make them look more the same the
idea is to distinguish legacy types
which we call L types because of the
letter in the descriptor from new cue
types which will have the cue letter in
the descriptor the idea is that L types
and Q types are very similar they're
both class based but only the L types
are objects they're the q types are pure
values and so this will let us say int
integer either way they're they look the
same you can you can write your code you
can refactor between int and integer
much more easily the value proposition
for Q types is that codes like a class
it works like an int it's not an object
it's a value but you get all your clasp
comforts so you can do encapsulation and
methods and so forth it depends on Val
how I depends on many things in order to
get this right one thing is we need
what's called parametric polymorphism we
need to be able to have lists of int and
have it work finally that's going to be
good right basically what it boils down
to is right now we know how to do lists
of any L type because L types really
look all the same to the BM the two
types look different they have different
sizes and layouts so we need to be able
to do the trick of lists and arrays and
other things that that are containers
for these variably laid out values but
it gets you to flat data and more
efficient use of memory in order one of
the technical requirements for pyramid
polymorphism is that classes behave
somewhat like C++ templates and that
each template once you give it template
arguments it turns into a not another
class but a species of that class and so
you have a class that's generic and then
you have many species one for each type
argument this again like like fibers
requires deep cuts to the JVM this I
would say is our biggest big-ticket item
and hopefully these are the last types
we'll ever need or the last way of
making types object types are great for
simulation these are much much less
overhead 'fl more direct non simulation
of values the impact of this will be
comparable to to impact some other major
language features like generics and
lambdas but the important thing is it
codes like a class so a few more notes
on parametric polymorphism that what
what it really does it lets you say this
code see this code this code works for
all values not just references to
inherit from a certain interface but int
and doubles and complex numbers which I
haven't invented yet and quaternions
which I haven't invented yet this
algorithm works for all of them that's a
very good thing right we've used that in
C++ with templates it's very powerful it
will be perhaps even more powerful in
Java but you'll be able to build all
sorts of interesting things on it on it
at the same time like the cursors that I
mentioned earlier into off heap data
structures that will be those should not
be objects those should be values a type
variable is the key actor in parametric
polymorphism a type variable says I'm as
placeholder for a type but I don't know
what I am yet I don't even know how big
I am i I know very little about myself
but you you better be ready to code me
for whatever type the user asked for so
that's like a template kind of a thing
it's very hard to do this because
primitives look totally different from
from references so you know we've been
working on it we have some approaches we
have like we're on I think just
prototype for doing parametric
polymorphism primitives don't look like
classes they don't have method
so they don't have super types so but
the solution that looks good today and I
think this is maybe close to where we're
going is to build an efficient mapping
that turns primitives into value types
because that's kind of what they were
there the first of the value typed queue
types and then and then at that point
your generic code has to work on queue
types and el types so it's it's more of
an either-or proposition instead of my
gosh what's it going to be I don't know
what's coming at me and the type
variable and then at the end you say
well if I want to be able to work with
types which could be either/or then I
need one more letter the you type you
mean G Union which is a disjoint union
of queues &amp;amp; L's and at that point you
sort of healed the rift do you have a
type system in the JVM that can work can
refer to anything you can throw at it
from Java plausibly we might do it
differently if we were just stuck with
the primitives and we didn't we didn't
want to add complex numbers and 256-bit
numbers but we want it we want those
primitives to code like a class so we're
having a whole new universe of queue
types and then combined with the l types
that gives you a universe of view types
at the top this means there will be
fewer kinds of types the same kinds of
code will work on all values you won't
have to say well my coding integers or
my coding in today because you code them
very differently right implicit
conversions help but you still code them
very differently so we'll be doing the
templated classes probably and then that
leads to what about can you code objects
like primitives can you do operator
overloading I don't know that's that's a
I'm putting that in because people asked
for it but I'm not sure how we're going
to do that one yet because operator
overloading is a real what you call a
moral hazard it attracts bad actors so
in any case one more word about what
template classes look like right now a
template class looks kind of like a
thing whose constants vary the code
doesn't vary the names in the code don't
vary but the constants vary so the
template class has holes and it's
constant pool which you fill in when you
make a species so this is going to be on
in this is going to be on doubles is
going to be on complex numbers
it requires a lot of deep thinking about
what's in constant pools but the hardest
problem the reason I say it's about
constant pools and not about customizing
code in C++ templates are expanders for
code right but I don't want to do that
because what we want to do in Java is
since we're we're late adopters of this
kind of technology we can make different
choices and be smart I want to avoid
code splitting I want to have one copy
of code that runs for all versions of a
template until you approve that you need
to optimize it for a particular type you
make a hot spot concept huh and then
once you get a hot spot in a particular
species in a particular template then
you do the usual inlining thing and you
get optimal code for that particular
type small our ideas time check can
someone tell me how much time I have
left I'm 15 excellent all right I'll
just speed up even more
smaller ideas these are ideas which are
sort of easier to wrap one's head around
stack introspection I already mentioned
length polymorphism is the idea that an
object might an object of one class
might have a length it's different from
an object of the same class arrays are
like this let's generalize it bootstrap
methods everywhere this is something we
talked about in the previous hour in the
invocation game and immutability you
know that's the removing of needless
degrees of freedom in your data
structure I don't have time to go into
all these so I'm just going to go over
it really fast but I do want to say that
these things all fit together in
surprising ways
each one is understandable in its own
its own right but then when you build
them together you get a system that's
more than the sum of its parts
so we want to be able to walk live stack
frames see even if you have privileges
see temporary values that are stored in
the stack frames to the point where we
would be able to strip us the stack
frames out of a stack record what the
stack was doing throw it away and then
later on reconstitute it and continue
doing it what it was doing from that
point forward sound like a useful
operation like checkpoint restore so we
right now we have full observing
and eventually we want to be able to
edit it various applications this all
this will be on the web so you can look
at it later length polymorphism fused
arrays what if you have a what if you
know that this list is an immutable list
that will always have just four elements
in it shouldn't just be one object with
a header and then four fields of course
it should the JVM can't express that
very well yet but we're going to get
there also strings why do strings have
have a sub object that's an array well
it's just history it's the way it's the
way we've always built things but it
doesn't have to be like that a string
after all it has a fixed length it
should be string header and then the the
bytes or the care is right there after
the F in the tail of the object but this
requires length polymorphism so we'll
get there I think this is something that
we need to be able to do there's some
technical requirements but we'll we'll
we'll get there in particular we need to
be able to build strings with factories
instead of new invoking it that's that
there's a technical problem that that
needs to be solved under the covers
which Java programmers don't even see so
if we fix it they won't even notice
except we'll be able to build better
objects boost our methods everywhere
again we talked about this in detail
last hour but the idea is to double down
on bootstrap methods right now and
invoke dynamic instruction links itself
by appealing to a user coded bootstrap
method with arbitrary static constants
that's very powerful we're using it in a
number of different ways we're going to
use it in more ways in the future but
let's put bootstrap methods under lvc in
the constant pool that's another place
where you get unique value from from
being able to appeal to user code to
link a constant let's maybe if you
invoke a an access point on a certain
kind of a class maybe there's no code
behind that access point until you touch
it and then a bootstrap method runs
filled in the code just in time and then
there's code within that ad within that
object to run maybe a whole method or
even a whole class could be created the
first time you touch it by appealing to
a bootstrap method we want to be able to
there's something called constant
dynamic which there's a
there's a jbs entry for this and a
prototype it's just about to be
published in the open JDK the idea of
constant dynamic is there's constants we
know how to create already but let's
make constants which can generate arrays
lists Maps templates DSL ast in order to
do constants for all these you either
need to add 50,000 new code points into
the constant pool encoding mechanism or
one new code point which says call a
bootstrap method to fill in this
constant which do you think we're going
to do right yeah there are requirements
on this I won't go into there's a design
which is being prototype right now it's
better to look at either last hours talk
or the code that's being that's going to
be posted soon this can be used to for
example compose arrays rather than by
imperative Java code if you ever looked
at the initialization of a large static
array in your in your class file you
probably threw up a little bit but it's
there's there's much better ways to
create arrays than by you know large
amounts of ad hoc byte code lazy
boilerplate this is relates to project
amber which is a language level project
so down there in the VM we don't care
what they're doing up there in the
compiler except when they rain down the
wrong kind of code on us and that point
we turn around we give advice on what
kind of code to handle in this case what
we want to be able to have is to have
stereotyped methods be expressed
declaratively using bootstraps rather
than as you know long lines of byte code
because the bytecode is usually very
boring and only adds bulk to application
startup so boilerplate methods include
things like constructors to string hash
code equals there's also bridge methods
which we know is been around for a long
time and other method builders the
Panama binder also builds bootstrap
methods Panama takes metadata from
that's been scraped from a header file
and binds it down into direct method
handles and methods that access the the
native code and data this is also is
very stereotyped activity and
should be done lazily in other words if
you if you use the binder to create you
bindings to a header file
you should only get code for the actual
entry points that you touch and this can
be done with with boilerplate reduction
technology and methods so you know in
amber you might be able to write a
really interesting class in one line but
if your class file is is 10 kilobytes
then something's gone wrong so this
solution is to is to generate just
little bootstrapping things and then
have those elaborates into byte codes
only when you use them that's kind of
nice um maybe some of you sometimes
people don't write equals hash code to
string not only because it's
inconvenient but also because it adds
both to the jar and they know they're
not going to use it right but what if
you could have that functionality
they're ready to use but you only pay
for it if you use it that's the sweet
spot details I'm not going to go into
details other applications not
interesting right now source code
project amber is exploring source code
syntax is for doing these neat VM tricks
so it's not only for byte code spinners
it's eventually for Java coders so
constant dynamic constants and even
invoke dynamic instructions will in an
in the near future probably be available
to you as a Java programmer to code with
use this power only for good the the
essential idea is to be able to have
constant expressions in Java that's the
basic idea in C++ there's a related idea
called a Const expert function which is
designed to be used to be able to write
even functions that produce constants
very powerful there is a downside to
bootstrap methods everywhere it means
that if you're expanding everything
dynamically you're a OT compiler gets
really confused because it doesn't know
what's going to happen dynamically at
runtime so then we have to teach it we
have to basically leave teach the Jo T
to work together with the bootstrap
methods
immutability I'm going to make a
super-fast commercial for immutability
there are fewer program states to reason
about when you have immutable data
structures Java has always had
mutability by default which is terrible
arrays you can't have in mutable arrays
you can only have mutable arrays you can
only have arrays which have race
conditions in them the only thing we
give you we're going to fix that so
right now in order to deal with some too
many states in your program what do you
do defensive copying problem solved no
you've just doubled the number of states
in your program that's nice
semantic simplicity also enables ahead
of time compilers and jets to predict in
advance what a program is going to do
more accurately and thereby optimize it
if you have stateful holes in your data
structures in your arrays you're just
going to be really cautious about making
assumptions about what's going to be in
those holes in the future that's hurting
performance
imagine if Java had been had made final
by default and there was a non final
keyword I think we'd be in a better
state but you know we didn't know how to
build such things 20 years ago we do now
so there's no excuse
frozen arrays yes please the frozen
arrays are like tail college it's a
fairly relatively small well understood
problem with with too many touches on
other parts of the of the stack so it's
expensive to do and it's always being
overridden by higher priority funding
items so that's my excuse why we don't
have tail call or frozen arrays right
now boxes that really work final fields
really should be final they're not news
flash you can do set accessible and
change them we want truly frozen objects
there's a connection between which I
mentioned earlier between immutability
thank you and I think that's minutes
right yeah okay not seconds
there's connection between mutability
and object identity and and we've come
to in the way we think we're thinking
about this prop these problems to
realize that object identity can be
viewed as a root of many evil
if you can get rid of object identity
then immutability goes away also
automatically but many other bad things
go away too so basically even if your
object is very carefully organized so
that you never write it outside the
constructor you promise the JIT should
trust you but it won't because somebody
might come in with reflection and break
here your carefully constructed
invariants so we want to enforce that at
the VM level but even if you were able
to enforce all the field as being truly
final the header carries state the
object header is stateful what state
well you have to remember the system
identity hash code that you assigned it
see that word identity you have to you
have to if you synchronize on it you
have to remember who's synchronizing it
and how to unsynchronized when you're
done so there's a even at one bit of
state that says I'm synchronize no I'm
not yes I am that is a piece of state
and otherwise stateless object and it's
because of that darned identity so
that's why we're adding cue types two
types are completely identity hostile
they refuse to let you see any identity
there is no system identity hash code
birth cue type only for legacy all types
we're going to leave the legacy all
types alone compatibility is hard that's
the dusty deck problem right but we're
going to add new types that that do not
have the the flawed but of identity so
and also we're going to work on ways to
have some legacy all types that are well
conditioned like value based classes
divest their identity go masquerade as
cue types and then be more optimizable
in that form and then the you types that
I mentioned earlier or the top topper
the last little bits I want to talk
about in the last 60 seconds is some fit
and finish bits that we're looking
thinking about doing in the near future
nestmates which is an uplevel way in the
VM of talking about a circle of trust
that is the single top-level form in a
Java in a Java cup source file
you know how classes in the same inner
class nest can talk to each other and
through their privates the JVM doesn't
know about that we're going to fix that
this is useful because that way you can
have these tiny right sized circles of
trust that can see each other's private
invariants and nobody not even in the
same
package can ever touch it and that's
going to be good in the VM but it
requires a clear definition of what an
estimated so there's not a clear
definition the VM can use right now so
we're going to put it in sealed
interfaces interfaces are great for
information hiding but they're terrible
as a security loophole because anybody
can implement interface will fix it will
allow an interface to be clarity as
sealed this is a proposal by the way
don't listen to my lawyers and don't
don't go to the bank with this but I
think we're going to have interfaces
that can be sealed as if the interface
had a private constructor and was an
abstract class and yet as an interface
it is really very opaque ceiling
granularity should maybe be nest package
or module there's these very useful
powerful concentric circles of trust
that the JVM supplies and finally sealed
fields what's a sealed field well it's a
field that you can read but you can't
write what uses that isn't that just a
final field no not if the private access
guy can write it but only the public
guys can only read it wouldn't we have
used fields a lot more if they could be
public but they couldn't be publicly
written that'd be kind of cool wouldn't
it let's do it no reason we can't do
in-house not too late all right so the
idea there is a symmetric field
accessibility more more accessible for
read less accessible for right all right
let my lawyers tell you again not to
believe anything I've said and yet
here's my last my last little bit here
this is a piece of JVM language summit
graphic and embedded in there is the
secret web address for finding the bits
of this presentation my presentation
folder on CR open JDK java.net and with
that I'm done I'm really glad you're
here
no time for questions
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>