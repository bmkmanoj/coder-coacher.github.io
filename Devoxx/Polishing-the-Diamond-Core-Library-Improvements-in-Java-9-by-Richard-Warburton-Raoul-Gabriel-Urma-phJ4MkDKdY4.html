<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Polishing the Diamond: Core Library Improvements in Java 9 by Richard Warburton, Raoul Gabriel Urma | Coder Coacher - Coaching Coders</title><meta content="Polishing the Diamond: Core Library Improvements in Java 9 by Richard Warburton, Raoul Gabriel Urma - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Polishing the Diamond: Core Library Improvements in Java 9 by Richard Warburton, Raoul Gabriel Urma</b></h2><h5 class="post__date">2017-11-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/phJ4MkDKdY4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">oh hello oh hello how's it going are we
feeling pumped yeah especially the pink
t-shirt team over there hello
amazing amazing effort awesome so my
name is Richard and I'm role and
together we run iterative learning comm
which is a training company and we run a
bunch of training courses around core
Java topics Richard it's a traitor
we've heard the oh because we totally
hipster look at it there thank you very
much excellent but we're here to deliver
a talk about Java 9 some Java line core
library changes polishing the diamond
fantastic and we're also going to use
another Java 9 feature to demo those
library changes which is the raffle Jay
shell so there are no slides in this
talk
who needs slides right just a black and
white terminal yes yes 2017 awesome
so I'm Richard what's the table of
content for this talk well ask you a
question so we have got a few different
things to talk about in this talk first
we're going to talk about some
collection factory methods so some nice
verbosity reducing library changes then
we'll talk about some streams
improvements in Java 9 right my favorite
library enhancements coming from Java 8
the stream API will so also talk about
improvements to the collectors API that
was all well optional and then we're
going to conclude this talk and wrap up
the different things we've seen
different threads that we've seen
so Richard end of tease let's get
started how does this hold on does it do
maps as well this Jay shell that you
mentioned
can you do one question yeah we can do
one plus two one plus two is three take
my money how much money will you give us
for one for secret three we'll talk
later okay okay that's a good
negotiating tactic so it will evaluate
our retreat Java expression
we can add one plus two equals three but
we could also for example put a
statement in here so we can say
system.out.println hello world fantastic
we get hello world printed on the screen
but we can also evaluate more
complicated Java statement some we're
gonna be writing la code in the record
so lot of programming languages
including things like Python and scanner
have this reptile as well so it's great
that each other has it as well now it's
really useful for interactively learning
or making use of a new API maybe that
you want to import or experimenting
works yeah absolutely
let's talk about collections go back
actually what's the biggest thing that
people hate about Java question to the
audience what's the biggest thing that
people hate about Java Richard you call
me asking this question they have too
many things here yeah
Raul what's the biggest thing that
people hate about Java
I love Java there's nothing wrong with
Java I'm actually really low Java robust
language but I've been doing a lot of
Python lately and I feel like Python is
you know a little bit more concise it's
less to write so Java is great if you
paid by the lines of code and of
characters yeah
but all in all a great programming
language that helps you write code as
robust and deploy applications but we
want something a bit more succinct is
when you say it's don't be nice you know
I wouldn't say no to that though I do
kind of agree the GAVI in the audience
that serialization does suck so let's
take a little very simple example of
just adding some words into a list right
so we've got an ArrayList here thanks
amazing and then we're gonna add in some
words there so we're gonna say some
hello hello world from Java okay so our
woods list does have those words hello
world from Java in that's good but oh
man it's just just so verbose to be
adding all that stuff in is there a
better option that we have come on
Richard you know in Java 5 I believe
you know this raise that as list factory
method was added why don't you use that
to make things a little bit more concise
so you're saying when I do a raised or
as list hello world from Java that is a
lot better that is a lot better but this
I raised that as this construct has a
few interesting characteristics related
to it right it's returning us a list of
string words but it's not really the
same ArrayList type that we have on the
example we saw earlier if we see that
what the class is for this it's the
arrays class with this ArrayList inner
class which is a different ArrayList
version that's got some implications
hasn't it well why don't we try and add
another element like what PHP excellent
let's try that unsupported operation
fantastic Java is helping us not have
any PHP in our code base this is an
amazing language feature we want more of
this awesome excellent I love it I love
it but Richard you know it looks like
this is kind of this instance that we've
got here is might be a bit peculiar what
about a method set that yeah to modify
an element inside that list would that
work oh oh that's bad that's worked a
will from PHP sorry sorry
it's a bug in this code we're living the
nightmare here we're living a nightmare
yeah so erase that as list is an array
wrapped up as a list so you can modify
or replace the elements in question but
you can't add or remove from it it's
feels like it should be immutable but
it's not really immutable um yeah so
it's got a particular situation Richard
um so is there anything better that was
added in Java no absolutely there was so
Java 9 adds some factory methods for
collections so I'm just gonna start
writing just hello world here and that
gives us a list with just the words
hello and world in
you know I'd anything to it can we add
anything to it so that's just assign it
to a variable so we can play around with
it so if we try and add PHP boom we
can't add PHP fantastic what was set if
we want to inject PHP into the first
element we can't do it there lovely it
sits in a genuinely immutable list but
it's these even though it's immutable
it's got some interesting
characteristics here it's still
implementing the regular Java list
method so you still have all those new
to t'v operations on there but they will
tell you you can't perform them so if
you say words that get classed and you
know what will be returned because
improves example we saw as internal kind
of arrays realistic class oh well it's
this it's this internal list
implementation from the immutable
collections class so the it's like a
hidden implementation class that's not
really exposed particularly but is
instantiated the list of factory methods
so that's really where you're meant to
get on at it from fantastic what Richard
what about them does this work with sets
for example yeah so that's another
restriction on the array store after
this thing if you don't have a different
type of collection like a set or a queue
you had to instantiate it and then pass
it to another thing they'll copy all the
elements over and what have you
whereas here we can just say a set of
hello world
nice and simple now you program Python
sometimes don't you yeah - has a syntax
it's a bit like this isn't it where you
can just say hello world with some
square brackets around it I mean you
have to make those string literals but
that would work yes so um and it's
really handy right you don't have to
write the list start off it's a bit more
concise and it feels and look like we
working with an array so let's pretend
that you're Brian good so Alex Buckley
or steward and mark and you know kind of
maintaining the the java programming
language you've got a secret keys here
Richard why can't we have this syntax
available in Java it looks pretty simple
right what's the problem I don't
necessarily want put words in their
mouth as such but as far as I'm aware
the main problem here
is that every time you make these kind
of changes where you Alex your syntax
there's a lot of overhead a lot of a lot
of cost associated with it we're just
adding some factory methods ends up
giving you most of the same benefit for
much much less cost it's a lot easier to
test and maintain a library as well then
testing and maintaining language
features absolutely how engineering
costs so we get essentially 80% of the
benefits for women reduce the cost so
that's why well it's one of the reasons
that my effect your methods were added
absolutely so let's try and have a look
at maps as well because they've got some
of the interesting method here so we
have a map dog and you're from Brussels
aren't you
anyone from Belgium here in the house
yes Nolan excellent go Brussels and
Antwerp obviously how many people live
in Brussels well I'm glad you asked
Richard I looked at up before coming
here so it's 1 million a hundred thirty
nine thousand people that live in
Brussels excellent from you from Cardiff
yes is anyone else from Wales here in
the house that's right I'm your friend
it's okay oh well I'm dissing lonely um
okay well Cardiff it turns out does have
more people in I mean I don't even live
in Cardiff these days but it does have
more people in them one it's got three
hundred and forty-one thousand people
there so we can instantiate a map here
from the the city name on to the number
of people live there with this matter of
fact method but there's a thing with
this map but of like the other ones we
saw were varargs
factory methods you could create an
arbitrary size map thought of or set but
of all this stuff we can't do that with
maps can we well we can't in there's the
other downside so if I look at your
declaration here
I could easily make a typo it's not
quite clear what different values are it
looks like you're kind of switching to
Kin values especially if you've got a
long line might be harder to tell where
exactly is the key and what exactly is
the value so is there a more kind of a
dramatic way of instantiating those Maps
Richard yeah well so what there is is
a factory method for the the map door
entry interface which was also added to
create immutable entry objects we've
actually just that's on the map
interface which is statically imported
it here so you can use that to create
entries and in fact there is also a map
door of entries method using some of the
tab completion in the repple there that
takes an entry with the two cities
lovely stuff so we've that does take a
VAR arc so we can take a VAR args
argument with all the entries in okay
excellent so each other a bit more 16
here less verbose absolutely a bit more
succinct a little bit less verbose let's
take a look at what else were gonna be
talking about so you don't talk for an
hour about collection of factory methods
there so wet streams for a while yes as
I said well hold on let's see anyone is
a fan of the stream appear everybody
awesome amazing awesome so there's a few
goodies that were added in the stream
API just to make life a little bit
easier and become a bit more productive
on a day to day basis so Richard this
new factory method that was added called
elf nullable can you tell me a bit more
about it yeah so so to explain what the
earth nullable is for we'll write a
little bit of streams code so our first
version is going to be a java 8 version
so what we're going to do is we're going
to have some configuration locations and
we want to find the first configuration
location or a list of things so we'll
see if we've got an app home property
set for our application I will put some
stuff into that and if that's missing
will back off to the users home
directory as a place to store
information too so let's take our app
home and our user dot home properties
that's whether the Java property for
home directories is and create stream
out of those two values and what we want
to do is if they're present we want to
plot that I'm going to find the first
one of these that's presents basically
ok so what we can do here is we could a
flat map each property name
what's the flatmap operator here for owl
so flatmap is this awesome method that
everybody loves I can tell and it take a
function that's going to return a stream
so that's gonna happen for every element
in the input stream and then they'll get
nested into a continuous stream so what
Richard is going to do here is to
implement a function that's going to
return a stream that contains the value
of that property if it's available if
it's not he will return an empty stream
okay
and that means this way we can get rid
of all those properties that don't
actually have a value and that's where
flatmap comes in so we're making use of
a couple of a different factory methods
here so a stream empty to return empty
stream we need to get our brackets and
parentheses right Richard yeah well I
wonder if I have got it right that's one
of the fun things about this talk is fun
area if that actually works Oh fantastic
yeah so we've done here is we've taken
the property if it's absent if the value
returned was no we returned an empty
stream otherwise we wrapped that value
up in a stream and we just called the
fine first method and stream to find the
first property that was there so if we'd
set at home it would have returned that
otherwise user that home was set so
returned rowels home directory but
looking at this code here can you put
your hands up if you really really love
this code can you put your hands up if
you really really hate this code okay
well if you're paid by lines of code
then it's good whatabout if you kind of
like you're marvelling dislike it and
you were mildly dislike it that's always
a popular option mild dislike fantastic
yeah so I quite mildly dislike it as
well in fact there's a better option for
us for doing this in Java nine isn't
there yeah I mean so ideally we'd like
to be making use of methods that help us
write code there it's closer to the
problem statement here and clearly we're
dealing with the case that something is
not able and we we are having to
implement its walk around using flat
maps so thankfully and you messed the
resided with a string of No
which just does what it says on the tin
here so it it takes the value if it's
not a return to an empty stream
otherwise it will return you a stream
wrapping up that value awesome
awesome so who's a bit more a fan of
this code yeah yes that's a roomful of
hands up does anyone have mild dislike
for it
very few more amazing amazing awesome
awesome so I talked about stream dive
nullable what's what's next well let's
see what the TOC say so we've covered of
notebook we're still gonna Kartik world
up while in the fantastic each rate
method so let's introduce the new domain
here Richard some payments we've got
some we've got some payments they're
going out of our business
look at those values payments they were
what different values haven't they nine
hundred seven hundred five hundred
they're sorted by value yeah right
awesome
so what are we gonna do what's the prom
to solve well perhaps we don't we were
going to look at some expense run look
at some payments who I just want to find
a reports where we know what the big
payments are the ones with higher high
values in so can we perhaps code up some
stream API codes to find the high value
payments may be a greater than or equal
to 500 pounds amazing so what we want do
is to apply a predicate on each of these
elements and based on that select them
or not so we take the filter operation
which is a veil and stream API and it's
going to take a payment and what Richard
is saying here is we're going to get the
value check if it's great a grid of 500
yep
and then finally collect that back into
a list yes awesome okay there's three
payments Richard okay but that's kind of
an okay approach if we've got say six
payments in all this but what if I've
got a million payments and we know
they're sorted is there any way that we
can take advantage of that sort order in
order to only apply the predicate for
the elements beforehand because we know
if it's sorted but once it goes false
it's going to be false forever that's a
fantastic point so especially if the
source is
potentially big or infinite yeah then
we're going to be processing elements
which is not really necessary as soon as
we find that the first one is smaller
than 500 hey we can short-circuit this
whole operation is no need to process
additional elements so we could be
saving some cpu time now in Java 9
another method was added
they actually make use of this
short-circuiting property it's called
take while and it's going to take those
elements and as soon as this predicate
here various to false then we can exit
the operation awesome awesome
so this this is basically wait until
that thing becomes false and then only
takes the heads the elements where it's
big where it's been true but there might
also be another parallel where we
perhaps want to find the lower end of
the list right the things which are
below 500 and we've got the same sorting
property as well or we we just want to
wait for it to turn false and then get
the tail of those elements is there
anything we can deal with to do that I'm
glad your ass Richard I'm glad you asked
because there's its other mess oh hey
call drop well that is exactly that it
returns you to tail from that stream so
it's quite a good way to kind of split
up and input stream as well you've got
take that gives you the head and drop
that gives you the tail so with the uses
we've shown here for take while and drop
while they kind of assume that there's a
finding counter order in the stream
right you know the order of the elements
and it's meaningful because they're
sorted what about if there are unsorted
is there anything we can we can do there
well Richard you might think of a
situation where maybe you're reading
data over the network or from a service
continuously through streaming formation
and at some point you want to be able to
exit from this oppression lay it off
flip it off based on a flag or maybe
based on a disconnect event that happen
at this point you need to kind of switch
off right I mean that's what take while
is handy as well so you could check that
flag inside your take whales flip it off
and then it's done indeed indeed
absolutely that makes really a sense
especially in the case of infinite
streams right streams which are
generated from
some computational function like
streamed or iterate I'm glad you
mentioned stream that a trade Richard
because that's another interesting
factory method I was added in Java 8 so
just so we all have kind of a recap if
you want to generate a stream of numbers
like that I encourage you to use range
closed instead a lot cheaper but this
illustrate this example quite well and
usually it's used for accessing indexes
in an array but let's say we generate a
bunch of numbers here which we are just
gonna print out and the way it trade the
works here is that it gives you an
infinite stream all those numbers are
being generated one after the other one
and I exited the the process here that's
why we start control ceded control ok ok
that's cool but suppose you don't have a
raffle in your production system where
you're gonna control see your code
manually and you've got these infinite
stream things how would we say stop once
we've seen ten values well sequel to the
rescue there's this apparition called
limit I mean you can use to kind of
truncate the size of your of your stream
something as a bandit sighs sandy scales
a limit n just give me ten elements okay
but the limit operation here is
operating on the number of elements that
we've seen what about if we say we add
two each time and we want to stop it
when the value is below ten so we'll see
zero two four six blah blah blah blah
but stuff less than ten can we use that
filter operation from the jar for eight
streams API perhaps to to check the
predicate well let's let's have a go
right filter is for playing your
predicate it's gonna select those
elements so if we run this we'll get
zero two five six eight but importantly
you can see the pool area is not exiting
but it's still carrying on still going
on absolutely so that's that's a bit of
a problem right you don't want to just
have a programmed sitting there burning
CPU running forever now if we'd actually
left that run on for ages and ages and
ages the int that it's continually
incrementing would eventually overflow
go negative and you'd actually start
seeing negative numbers come out of the
bottom as well
so
that's not very ideal i there is it so
perhaps we can use those take while or
drop while operators that we saw earlier
to solve this problem so takeaways good
candidate because again it has this
short-circuiting property so we play
this predicate as soon as evaluates to
false then we're going to enclose the
stream is there anything better than
doing an iterate and a take while well
some programming languages have got this
kind of list comprehension feature I
don't know and was a fan of Haskell here
we can kind of build up this list by
giving a predicate as well on top of
giving any iteration kind of a function
so I think it's about as many fans as
Haskell's there are Welsh people in the
room in August but yes then this
comprehension this comprehension factor
so will you perhaps want to say a
predicate that limits the bound of a
list you're going to generate and then a
function to get you the next entry and
the new version of each rate that was
added in Java 9 has this overload
version that takes an argument which is
your predicate and what that's going to
do is to use that to filter out the
elements but again has this nice
short-circuiting property so we don't
get a infinite stream awesome awesome so
we've talked about streams for a little
bit but there was another feature that
was added in Java right as well right
collectors and collectors go
hand-in-hand we have the stream API so
it's really interesting way to build up
containers out of a stream so when
you've got a mutable reduction use case
you want to build up a list or a map
that's where collectors come in so I
think we've got a list of your expenses
in a local variable here haven't we I
love those it's my expenses because I'm
pretty sure they're yours Richard
because your entertainment here yeah so
you got your 2016 a lots of money spent
on food entertainment some money on
utility 2015 no utility bills whatsoever
I won't tell British gas about that by
the way I promise thank goodness that
this talk isn't being record and going
on YouTube so
let's suppose you don't take those
expenses and find those expenses like
the ones are the groups are different
years are the 2016 or 2015 one what are
we going to do for that
Sir Richard this is the collectors API
here to help us so collect is the entry
point to use collectors and what we're
going to say here is just as a refresher
can you group those purchases based on
the year and what you get as a result
here's a map where the keys of the year
and the value is the list of those
expenses
so the 2016 one was the food
entertainment utility in 2015 which is
travel entertainment man 2015 sounds fun
wait for 2017 in 18 baby whoo okay I
will do so we've got this kind of nice
thing we're kind of grouping by list but
can we do some more interesting
computational tasks like what I really
want to know is how much money I spent
in 2015-2016 call me materialistic but I
do want to know how much money I spent
in those years oh that's that's fair
enough Richard especially for billing
accounting software does information we
need to know so the good news is that
this collectors framework here is really
composable so we can have a second
argument here that's going to say well
what don't you sum all the amounts I
believe and if we run this what you'll
find out here is that for the year 2016
you spend a lot of money yeah living it
large mainly with a large utility bill
but you know living at large in some
sense amazing so that's the refresher
for the collectors and how you can use
them what about Java 9 what about Java 9
what I saw in our table of contents that
there was say a filtering operation in
Java 9 wasn't there so let's suppose
think about a filtering use case here
suppose we take those purchases and we
want to find the purchases that were say
bigger than 700 pounds over a thousand
pounds they're really really be expenses
and I want to group those be expenses by
year what what was the key thing I blew
my budget on in a given year or you blew
your budget on return well this is the
operation hey because we want to filter
out those payments okay
those purchases and if we run this code
here what you'll find out is that 2016
you had an expense over a thousand pound
and to me utility darn you British Gas
darn you yes
so that's kind of okay that's useful
information to know what happened a 2015
did you just delete 2015 now you've got
your girl eyes you've got eagle eyes so
what's happening here is that we
filtering those elements from the source
and the points reaching the collectors
then the year 2015 that element that
contains the yetze and 15 is not there
anymore because the amount is only 700
so it's been filtered out so we have no
way to build up that map that contains
the Year 2015 Richard so what you're
saying is you want to group by the year
and then remove the elements that's
right
don't worry Richard don't worry about a
thing
because in Java 9 there is another
collector that was added that can help
us and it's called filtering excellent I
know I'm gonna be happy after you
mention this so you take again this is
what we call a downstream collector you
compose two collectors together we're
going to take our expense get the value
get the value so this is the same
predicate that we had before
and then it's amount your rights get it
melt and then build that up into a list
so this point now Richard you can see
that we have this map and the key is
still filtering through so we've still
up the 2015 year we still know that year
exists somewhere in our system we know
there were no big expenses in that year
because it was just travel entertainment
a little bit of this there were that
exactly cool cool but I also notice you
know talking of travel entertainment
we've got a few tags we've got each of
these operations tagged by what they're
about so perhaps we could take these
purchases and just find out what those
tags are
well so what we want to do here now is
to extract some data from the input so
that's not like a job for format right
map is okay pattern where you can do a
transformation from one element or you
want to extract some new units and let's
say we get our expense and what you
really want is just to extract the tags
right yeah and then collect that back
into a list awesome there you go now
what you've got there it's not really a
list is it's a list with lists in I know
you like lists Rowell I know you like
lists but this is too much
there's too much lists do you want some
set maybe no it's not really solving the
problem what I want is what I want is
one collection with all the elements in
all right all right well guess what's a
favorite friend flat map flatmap flat
map indeed so what we're going to do
here are you gonna call did there
so again flatten that this suppression
that takes a function out in the stream
and they will flatten all those
intermediate streams so what we're going
to do here is to say well give me all
the tags make a stream out of that the
next element give me all the tags and
we're gonna get one continuous stream of
all the tags so we don't have this
nested list anymore and then finally to
set here will ensure they've got unique
elements awesome awesome so this is
flatten the elements down put them into
one big set entertainment food utility
travel awesome I'm not spending money on
computers but that's ok that's ok
now what about we've got these tags we
had this thing earlier we saw the years
so can we find the tags that caused our
expenses in a given year perhaps well
let's use the collector framework again
because now we interesting and building
a mapping so what we're going to do su
grew by then you're saying by the year
there's another collector richard core
mapping actually lets you do this
extraction mechanism so we're going to
say map paying and here we want to
extract the tags into a set okay
and then if you're a fan of Lisp you
love collectors because you really to
get your pan disease right and there you
go but this is still lists of lists it
is can we I like this but I don't like
too many lists
let's get them flattened back down again
alright so we had mapping can so on
guess what we're gonna have in Java nine
pain yeah yes amazing well let's let's
give that a go so Richard all I'm gonna
do here is to replace this mapping with
flat mapping okay so flat mapping boom
now normally when I see a generic Sarah
on screen I read out the full generic
Sarah just to emphasize how long
complicate and unreadable it is but if I
do that we're going to take up the
remaining 19 minutes of this talk so I
won't do that and simply point out that
flat mapping it needs to take us a
function to a stream in order to flat
map just like flat map took a
functioning to extremely rich and let's
be fair here right if we look at this
airhead I've highlighted it tells you
that well you return this a tag and what
we want is a stream of something right
so it's kind of helpful it's kind of
helpful so um let me the section might
sent to you let's let's fix that up and
instead of having this expense get tags
here what we're going to do is to
provide a lambda expression that will
return a stream so okay expense we get
the tags and then we stream that okay
now if we run this again well yes yes
from the to the different expenses we
can add the expenses up we can find the
big things we can find the tags I can
sack my accountant yes save even more
money boom so that's wrapping up for
collectors and Richard that you know one
of the data type that I'm a really big
fan of but it's really helpful for
muddling is optional right models the
presence absence of value and forced me
to deal we have to see now where they
may not be a value if I need to yes my
API more comprehensible
you know the stream API it supports
optional when say find first to find any
there may not be an element in that
stream so really useful data type so
make it sexier in Java now
absolutely so we involve our property
lookup example from earlier I'm gonna
have our property setting class and we
look up the setting by a name which is
the name of the property and that return
an optional with the value in if it's
present and nothing in if it's absent so
yes they use a home example and if I
just say property you haven't set at
home it's empty
okay so let's evolve that earlier we saw
earlier example to use those settings so
if I take a stream take give them that
app home and given that user home I can
map those values using the lookup
setting by name method reference and
that's gonna return me an optional so if
I want to check I want to get rid of
optional to their empty clear so you
have some empty is a Sun or not and this
mythical least present right now you can
use her to check the state of that
optional object absolutely and then I
need to unbox the optional so I need to
remove elements that are I don't
actually wasn't optional within an
optional here so I want to unbox the
optional to remove the values so I've
just got the value the setting object in
the stream and then I'm gonna do a fine
first the end okay awesome awesome we've
looked at the setting we found the first
one we've wrapped it up in the setting
and we've got that returned at the end
Richard is it is it really awesome it
feels a bit like an anti-pattern who
screw actually explicitly poking the
state of the objects it's definitely
normal this is definitely not awesome
this is definitely moving into the
mildly annoying territory I think mm-hmm
so we've got this is present and get and
usually is present and get in
combination with each other is a bit of
an anti-pattern right yeah I mean it
doesn't feel like any improvement from
what we had before which I've read
before the optional date yeah I was
introduced where we're essentially doing
explicit check and based on that
we are make a plain oppression so it
looks like we're managing the control
flow here whereas what we want to do is
to let the API figure out by building a
recipe absolutely but they're actually
quite convenient method added in Java 9
for this very purpose so if what we do
instead of doing the is present and get
what we can do is we can flat map each
optional and there's a stream method
added in Java 9 so that will convert it
into a stream it's got it's got the one
element in the stream will contain the
one element if the optional empty the
stream will be empty so we'll do that
and then then and find first at the end
gives us the same result but it's a much
nicer pattern for filtering optionals
out of streams to flat map them into a
stream not only that it provides a way
to convert from an option to a stream if
you need to if you've got so many piata
make use of stream you've got a nice
kind of the entry point here so I think
wanted to take all of this talk is flat
map is definitely your friend in java 9
it's more flat map and it will be more
flat map in the future as well
absolutely loads of flat map so I'm not
saying which I do quite a lot of and you
do quite a lot of his travel right
booked flights fly from one place to
another so there's big a little booking
reference here from say London City
Airport to Antwerp and I actually like
got a little class here that will take
our booking and it will look up bookings
given the reference so if I provide
London City to Antwerp it'll give me an
optional wrapping up the booking and
suppose my booking ref was from Cardiff
to Antwerp we will have an empty
optional maybe that's why there was no
one from Wales in the room because there
are no flights from Cardiff to Antwerp
maybe maybe maybe but I've also got like
a little UI class with a fancy 2017
oriented UI that will display me my
check-in page and also my missing
booking page so if I take my booking
reference so you want to say if it's
present then maybe this
play chicken absolutely so let's let's
flip back to the London city to Antwerp
booking so I can say if present using
the optional AP already take the UI and
display the check-in page fantastic so
we see we're checking in from London
city to Antwerp but if I'm going from
Cardiff to Antwerp and I use the same
operation just displays me nothing at
all richer that's no really use
experience here right yeah well it's not
present then display something I'll
display missing booking page so if
present or else do something right
that's kind of what you want to try
typing that and see if it wins amazing
awesome missing so there was a another
method added to optional called if
present or else that takes a couple of
different callbacks the first one is the
operation to do if there's a value
inside the optional kind of true case
and the second one is the missing the
empty optional case as well reads like
English I love it
awesome yes so there's one more thing
that we need to look at and that is
finding the addresses of clients right
so let's suppose we have a string here
which is gonna be the clients name and
for reasons unknown they're gonna be
call the client and what I've got here
is a couple of methods so I can look up
the company details and I can find the
clients we've got different levels of
address book here firstly the company
name in question could actually
genuinely be a client in which case
they'll be in our client database or
maybe they're a company who we can look
up the address of I'll say publicly on
the internet or with Google or Yellow
Pages no it doesn't exist anymore um
with some other database of addresses
and maybe it's just not a company name
maybe it's a typo maybe they've renamed
their company whatever so we've got a
couple of different lookups here so we
can find the client and if there are a
client it'll return us their address in
London let's suppose the
is another company so that's somebody
who's not a client but it's just another
company then running that fine client
for return if the empty option also say
we don't know who this company is but
I'll look up company details that backs
off to say the public database of
addresses will return us their address
and that's in Cambridge
so Richard sounds like you want to be
able to chain up those two operations
together right if if we fail to look up
the client mm then here's another way to
look it up using the company details
yeah specify so there was a method
called or else get wasn't there in Java
right there's or else and oils get and
that would let us do some code on the
the empty value and say for example look
up the company details on the client so
let's try using that and see what
happens
well oh we have a pretty reasonable
error message here it saying look you
you want a function that is returning a
client object because that's what the
the was in the optional itself and
you've returned an optional of a client
is it we you know that lookup operation
might fail and or where else get doesn't
meet these use cases it has to have a
callback but definitely that succeeds
rather than returning an optional itself
is there a Java 9 feature that helps us
all this from well I'm quite clear about
Java does this other mythical or else
quite simply what will happen if we just
run or else and we remove this super
layer here just like that yeah we get
the same problem because or else has to
take a value it doesn't even take a
function to return okay I know Richard I
know so we've got or else who got always
get what about just or well that well
let's try that one fantastic so or was a
method that was added in Java 9 and or
will take a function that will again
return an option on itself so if the
fine if say our client was a client this
will return us London it was another
company it would return us Cambridge as
shown there or there's also a third
option which is
suppose this is just some kind of typo
and that will return us an empty because
typos not a company name here right
fantastic fantastic
so no Richard we talked a lot about you
know there's new additions though yeah
introducing Java 9 so help us make our
code more readable closet from statement
helps productivity that's great
so we've talked about new things that
were ended but what about things that
were removed things thats an interesting
question because we bumped into Alex
Buckley earlier didn't we and he told us
guys you need to make a last-minute
change to your talk 45 minutes before it
starts so yeah we thought let's do that
that's a brilliant idea
hold on hold on that's not the real
story there is not a real story okay so
we had a chair with with Alex and you're
saying how great you need to make some
modification to your presentation and we
then said oh well we have no slides and
Alex said even better you don't have to
change anything you can just talk about
it no changes required yeah
which isn't entirely true so there is
some code that's been removed there's
deprecations there's even dr. Debra
cater in the room who loves defecating
code but there's also code which looks
like it's been removed in Java 9 but
actually hasn't been removed in Java 9
or is at least shipping as part of the
JDK for the moment like Jax b2b any
anyone using the base64 encoding to code
in here or some of those people but also
anyone using Jack's B or the XML binding
libraries at all
that's a more that's a larger number of
people okay so we're just going to use
an example class here so suppose we try
and import the Java App Store XML binder
data type converter so this is a class
that some people use in Jax B which is
for basics before encoding because there
used to be a Sun misc base64 encode or
which actually did get removed in Java
no and the problem here is this data
type you
visible it's in this module Java X XML
bind which isn't loaded at all and I
think the point want to make here really
is that there is code that looks like
it's been removed in Java 9 but hasn't
really been removed in Java 9 because
slash exit yeah because we can come
along to the command line or when you
declare your modules at compile time you
can add a require on and you can say
look add modules java xml not bind and
then it imports without error so there
is also as well as new code there's
other code that's still there in the jdk
that can be used if you add the modules
for things like jax be though I will say
be a little bit careful because there is
actually an impending JEP to remove the
Jax be from the jdk itself so you'll
need to use maven or something to import
it and for that case you need to use
something like the Java util base 64
class for base64 encoding that was added
in Java right fantastic so in this talk
we covered a number of different core
library updates right we did so we
covered the collection factories a
stream API collectors optional there's
other enhancements that we've not
covered including to the completable
future class if you want to find out
about the other editions though Richard
and I we've written a few articles on
this topic on a website so iterator
learning-dot-com we were the oh and what
you'll see is you know we're talking
about the new process API that was added
in Java 9 and you can also find code
samples that we've used in this talk in
those articles and on our github which
is linked from the website ok so I hope
you guys have all enjoyed this talk I
hope you've seen that there's more to
Java 9 as an update than just project
jigsaw we've seen some live coding in
the J shell wrapper and we've seen a
bunch of core library improvements as
well so
you enjoyed all of those thank you very
much for being a great audience if
anyone has any questions there's about
three and a half minutes left in this
time slot so put your hands up in fact
wave your hands about if you've got a
question to ask or feel free to grab us
and run us to the talk we're gonna stick
around for a bit okay bye</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>