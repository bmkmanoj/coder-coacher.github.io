<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Why Clojure?  by Vijay Kiran | Coder Coacher - Coaching Coders</title><meta content="Why Clojure?  by Vijay Kiran - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Why Clojure?  by Vijay Kiran</b></h2><h5 class="post__date">2015-11-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/SLRSOyR47Ro" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to this talk thanks for coming
so this is talking about closure and
this is more of a personal experience
rather than evangelism about closure
this is how is why I like closure and
why I prefer to write in closure most of
the time and the first thing that I want
to talk about is the a bit of experience
of me so I started reading pragmatic
programmers some time ago and there was
a very decent quote from that one that
said hey learn at least one new language
every year so I tried most of the time
so this is my history of learning
programming languages so I started
coding in basic in 1994
let's were fun and then later I wrote in
Pascal and C and then later a visual c++
I did some windows development and then
I started learning Java sometime around
2002 and from 2002 pretty much most of
the time I've been doing Java and
working on jvm languages apart from Perl
and Ruby here and there so obviously JVM
is something that we like because that's
as everybody was pointing out it's a
very technically amazing platform and we
love to hate it because of the
exceptions or the stack traces but at
least you know thank God we have stack
traces and funnily enough this is the
screenshot from from this factories that
I got yesterday trying to connect to
some Wi-Fi Spock here but there are also
privileges being on JVM especially
nowadays there is a plethora of
languages that are available on JVM for
you to choose from and each language has
its own strengths and weaknesses so if
you see the different types of languages
so there is JRuby Jade on Cortland
phantom and free ger of course enclosure
so and and I wanted to pick one of these
languages to try out and learn the new
functional paradigm because I'm more
into functional languages and my choice
was closure so this is more about why
closure and then obviously some people
ask me okay why not ask
so Haskell doesn't have any side effects
so obviously nobody wants them
sir but JVM being the the fundamental
engineering marvel and we want to stick
to JVM so what what is closure so
closure is basically a dynamic
functional immutable Lisp
so it has dynamic typing and it has very
spectacular concurrency support with its
primitives and it runs on at least three
platforms so it runs on JVM it runs on
JavaScript and it runs on CLR
but we really don't care about sila and
and also because it did being a lisp
it is extremely flexible due to its
dynamic nature so you can define your
model or the domain model and then you
are free to change the model whenever
you want so there is no type system to
fight with and it so it's extremely
concise it's it's some people think that
Lisp is one of the most beautiful
languages due to its conciseness and it
also encourages experimentation and
exploration as I said it's a dynamic
language so you get to do a lot of
experimentation using ripple for example
and you don't need to worry about too
much about types or anything so you can
just focus on the business demand this
has been one of the primary reasons why
I like closure so much because the rest
of the thing is basically ceremony that
that's what I see nowadays people want
to try Python and want to try Ruby you
wanna try free go I want to try Lisp or
closure for example so you can actually
focus on the business problem and then
deal with that that's what you're trying
to solve you're not trying to you know
make the compiler happy that's not
that's not going to solve your business
problem so the another biggest advantage
that that lisps have that that closure
inherits basically is the repple and I
hear that every language nowadays has a
wrapper
you know the Java is coming of age a
shell and Scala has a ripple and
everybody keeps on saying it's a wrapper
but it's not something similar to what
you have in in Lisp because unless the
reading and evaluation of different
steps you are dealing with the data
structures but I'll talk about it a bit
later on and also you can do on-the-fly
function definition and
of course ripple is essentially the tool
for interactive development
so why closure because closure is simple
and elegant but that's a that's a big
big claim the biggest claims need
biggest proofs or something so obviously
one of the seminal books in programming
I'm not sure how many people have read
this book awesome ok so there is a list
of books that people say that they read
whatever they want to read and this is
almost false and you know either of
those categories so structure and
interpretation of computer programs for
the people who don't know about it this
is one of the books that introduced this
list from the computation point of view
how how a programming language helps you
to define computations and it defines
that every powerful language should have
at least three fundamental qualities and
ability to create primitive expressions
and some means of combination of
combining this primitive expressions and
also it means of abstraction so it in
closure let's see what what closure
provides so closure has the primitive
expressions which is basically some
people like to call it the atoms or
economic data types so closure has
integers doubles big decimal and ratios
ratios is a proper high level or a
primitive concept so you don't need to
have a weird-looking number there you
can have proper ratio as a as an atom
and you have strings and characters of
course so there's examples there closure
is a string you can have characters
which is basically a backslash the
character itself and then you have
symbols and key words symbols are the
things that you use to name the things
so you want to combine a couple of
things and then give them a name so
that's what use symbols for and then key
words basically they refer to themselves
and you have boolean s-- and you have no
obviously you cannot avoid now you're on
JVM so boolean czar basically have two
values true and false and null is
essentially nil and also there is a
support for regular expressions so you
can write a regular expression by just
typing cash and then put it in the codes
now that is the there is the primitive
expressions now you want to think about
how can you combine the things together
so the combining things happens using
data structures enclosure so you have
lists so lists are basically singly
linked lists so they're prepend friendly
by that I mean that you can keep adding
items to the list and there it will grow
in the front and then as you might have
noticed that the list contains the first
for the first form is creating a list
using the list function and the second
form as you can see it doesn't have the
similar value so the list of
heterogeneous all the data structures
can contain any values in them so you do
not create a type of list that only
contains integers it applies to other
data structures as well as you as you
can see in the examples so there the
then there are vectors vectors are
indexed so they're very fast if you want
to access based on indexes and their
append friendly by that I mean when you
add a new item it is very efficient
because it's going to be added to the
end not not to the front and you need
maps which is basically key and value
pairs so the keys can be anything so in
this case in the first case the keys are
the key words and the second case the
keys are the numbers so there is a map
and then you have sex sex or just like
mathematical sex you have unique values
across the set so these are the data
structures that that closure provides as
a means of combination and also the
other part that thing with this data
structures is that their nests table as
in each data structure can contain other
data structures so as you can see on
line one
it's actually a list from the outer
parentheses and it contains a symbol
hello and the vector names and a list of
strings hi and everyone and then on the
line too you see a vector containing a
list and a symbol 1 and then a vector
again and obviously the third one is a
is a map that has a keyword called
planets and then there is Earth Mars and
Pluto
I still think Pluto is a planet I don't
know who okay thank you at least a
couple of guys so the another nicest
thing with all these data structures is
that they're they're immutable and
persistent so this is what you keep
hearing in all the functional
programming languages that immutability
is
of the key features so all these data
structures are immutable and once you
create them you cannot modify them
obviously that sounds stupid unless you
think about it so when you make in an
immutable data structure then all you
are doing is if you want to create a new
data structure out of that one then
you're going to either append or prepend
to the tree so that's what it is meant
by persistent data structure so closure
implements persistent data structures
that are created by or invented by Phil
Bagwell and then they are there into
Scala as well and also enclosure so
that's it
that's essentially closure I mean there
is nothing else that you need to learn
so closure has no syntax so to learn for
you know there if you know these
concepts then you can read any closure
code because there is nothing else but
of course there is a small caveat
so in closure data structures are code
and code is data structure so you can
produce the code using the code because
what you're writing is data and then the
data is being evaluated by by the by the
closure reader and eval evaluator so let
me show you a simple example like like
every decent programming exercise starts
with the hello world but this is going
to be Hello event so here I have two
lines on this and this program so the
first one is again if you remember from
the syntax or the no syntax the first
one is basically a list list of two
symbols first one is NS and the second
one is a la work so what is essentially
doing is creating a namespace called
hala world so name space is like a
module so you can group functions or all
related things together so you can
define a it's similar to package but in
in some ways and the second line says
okay define a function called say hello
and again the entire line is basically a
list so there is nothing that you don't
know about except that what more
individual things mean and defin is for
defining a function and say hello is the
name of the function and it takes one
parameter which is called a parameters
vector
and that's an event and then you have
the body of the function which is
essentially print hello and an event so
if I run this program this is what I see
so I'm going to call the function using
say hello and then pass it as a
parameter that is going to be bound to
the symbol that is event in the scope of
the function and then it prints hollow
the box and then it returns nil because
PR n itself which is print one line it
should return some value so it is going
to return nil but it has a side effect
of printing something so to recap data
structures are code everything is just a
list so all of the things that you see
in enclosure is are essentially a list
so declarations defining a new variable
Val variable because there is no
immutability there and defining new
symbols for that matter I think that's
much more correct way of saying it and
then there are control structures like
if-else or whatever they're basically
lists and functions or lists as iam as
you've seen in the previous slide and
then there are operators which are also
again just lists of things now this how
it looks like so every list is
interpreted as the first one being an
operation which is either a function
expression or a macro or maybe there are
some few special forms so then you need
some sort of building blocks to build up
your language I'm not sure how many have
you read the paper by John McCarthy
about constructing Lisp so it's
essentially seven forms that you need to
use to construct the entire language so
it is something similar but you know
because the closure being running on JVM
there are a couple of things that are
needed for closure for example to to
account for the lack of tail call
optimization there is a loop and recur
for recursive functions of the loops and
then there is also a trampoline function
that you can use we'll come to that
later and the throw and try these things
are yeah they're just Java try and throw
and so essentially it's a 14 or so
special forms so there is there is very
limited cognitive load on my mind I'm
just an average programmer to learn new
syntax or anything I'm productive
immediately at least from my perspective
now when I contrast that to
some other languages this is a this is a
example from Stack Overflow so what are
the uses of underscore in Scala
so underscore essentially means 11
things and I really love that the answer
ends with there may be others that I
have forgotten so that's pretty awesome
anyway so closure the second reason is
that closure is a functional language
nowadays everybody wants to write
functional languages because we all know
that I think we are in the same page
that we agree that we are going into
this multi-core world of Awesomeness and
we need better languages to deal with
the situation and obviously functional
languages are the way to go and so the
fundamental reasons why functional
languages are better is that they're
easier to reason about in in some
languages more so for example in failure
because there are no side effects at all
and that they're easier to test because
you're defining smaller functions and
you can deal with the functions and then
you can just test those functions as
long as you can you know fight in a
purely functional way or at least as
much as possible and the immutability is
also baked into the into closure as I
was explaining all the data structures
that closure provides they are
fundamentally immutable so you cannot
modify them and this is a big win for
concurrency and possible parallelism so
that's the idea and just like every
other functional language these days
functions are first class so you can
just they're just symbols and you just
give a symbol or a or a name to a
function and you can just keep
referencing them and then pass them
around and do whatever you like
and they're also higher-order functions
so you can that's what essentially what
is the result of functions being first
class and it supports recursion using
loop and recur now obviously the regular
recursion that you're if you know in
scheme or other lisps that's not
possible because the tail call
optimization isn't there so loop recur
is one way like a escape hatch and if
you need mutual recursion then you end
up using trampolining which is a which
is again another function in closure so
closure has that the third reason
closure has great support for
concurrency so this has been one of the
biggest pains
that at least I faced in in in Java
because I built a lot of faux desktop
applications as well using SWT and swing
and a lot of other technologies in Java
and the concurrency is something that is
very very hard to get get correct and
especially for yeah if I'm not reaching
and so that that makes it even more
difficult for me because I'm going to
spend more time on getting the technical
foundation right then actually solving
the business problem so I'd really like
somebody more smarter than me more
smarter yeah than me trying to figure
out all these problems for me so that's
what I think closure provides me so in
closure there are no locks at all so
because there are no objects through
there is no global shared mutable state
although all the state is in the data
structures they are immutable and
they're persistent and there are some
concurrency primitives like varsa atoms
and agents and there is software
transaction memory that gives you
similar transactions fairly similar to
the database transactions so you can you
can replace or or or work with different
kinds of data without worrying about
there are there any dead locks or
anything so to give it a small
comparison about what these things mean
so this is a comparison of different
kind of concurrent primitives that you
get in enclosure so where's are the
things that are essentially thread local
things or objects or whatever the values
that you want to have and that's what
you you have seen so far in in the code
when I created a def and whatever that's
basically ever and then you have atoms
so atoms are our retrial as in you
create an atom and then atom has a state
which could be any data structure and
there are functions that help you to
update the anthem or change the value in
an atom and you can have series of
functions that are going to modify the
centum but everything is going to be
retry below as in it will retry applying
the same value again and you can
dereference an atom at any point of time
in your program and it will continue
giving you the current state of the atom
without you need to know blocking a
thread or anything
and finally they are sorry and then
there are agents agents are more
synchronous and atoms are more
synchronous in the way that you're
updating the code and agents are similar
but they're they're asynchronous so
essentially it will create a different
thread to update the update agent and
then there are refs refs of the of the
fundamental idea behind or the
fundamental construct that you use if
you want to do software transaction
memory the the special feature of the
refs is that they're they are
coordinated that means all the reads and
writes of multiple reps you can do that
without any any problems with with race
conditions and yeah so these are the
fundamental ideas but obviously there is
a these are enough to when you're
working in a single program or when then
you're working in a you know in a
program where you just need to handle
your concurrency in in some ways but
still one of the problems with
concurrency is when you keep creating
these futures or you know the delays and
other things in your program then you
end up having all sorts of callbacks and
weird things so for that there is a new
library called caressing and well it's
not new anymore because it has been
there for some time now and it's it's
it's out of alpha now so this provides
something called a channel based
concurrency so there are different types
of concurrency models in different
languages for example Scala primarily
uses actors or or they say that accuracy
or the best way to handle both
parallelism and concurrency and you have
ingo you have channels which are which
is baked into the language but in
enclosure channels are just a library so
there is no syntax for it you can just
use them by adding it as a library to
your program and it also works on
JavaScript because this is what closure
has been built or built for to be ported
on to different languages or different
platforms so the same chorusing channel
based concurrency which helps you
preventing this callback hell you can
also use it on JavaScript
obviously on JVM it's not that that not
useful because you have multiple threads
on JVM but especially when you switch
javascript if you are writing for nodejs
which seems to be very unpopular here
and then then all you're left with is
just single thread especially in the
browser you only have single thread then
you keep adding this all these callbacks
and promises and whatever that makes
things way complicated so that's that's
the concurrency story that you get from
from closure and then you have the next
reason that I think closure why I love
closure is that closure is practical in
a sense that it's it's very host
friendly so especially on JVM there is
no there is no bridge and there is no
gap between the JVM and at closure
runtime so some languages for example
there was a ruby implementation on top
of objective-c and there is a bridge so
for every object that you see in in
Objective C then they created a proxy
object in in Ruby so that makes things a
lot more complicated and you know that's
one of the leaky abstractions and
sometimes you need to get into object to
see world and in button closure there is
no there is no difference between the
the data is that the data that you have
on on JVM or on Java so strings in
closure or basically Java strings and
all the numbers that you have in closure
they're essentially Java numbers and all
the collections they implement the
collection and there is no conversion
needed if you want to use any of those
proper objects that you have in in Java
so in in in Scala for example you need
to import these java conversions to ship
your Scala collections into Java
verlande and Java collections into Scala
world and all the functions they
implement runnable so there they are
pretty much Irian things and using the
java libraries is extremely easy because
there are a lot of syntactical
constructs that you can use to make your
to make my life easier so there is dot
notation and creating new objects is is
fairly easy and I don't want to go into
the too much syntax details into this
talk you know obviously you guys can
just look at our pond on the network and
the documentation and the next feature
that that that is fascinating enclosure
is that the closures
so this gives me a single language that
I can use to build because mostly these
days I think everything is web
application driven and everybody is
obviously building most of the time web
applications and so that's what I'm
interested in as well and we see that
even the editors are now web based or
the WebKit based that seems to be the
hipstery thing to do these days so we
have closure script which basically
compiles to JavaScript which is
essentially the the core of the language
are pretty much all the features of the
language are supported in closure script
and it has some fascinating tools so for
example how many of you have seen the
brett Richter's presentation about live
coding stuff yeah so it was a crazy demo
I mean when he give the demo everybody
was just jumping onto it and how to how
to make this one in every every other
language possible so in enclosure of
course we have fig wheel which is a
fantastic tool that you can just keep
writing the code and then the browser
keeps refreshing and you can build your
entire application without once stopping
the whole thing and obviously the UI
coding is very easy but you need
somewhere to manage the state and the
whole state management is also
facilitated by then by the nice
immutable data structures in closure
which are ported to closure script
obviously and the availability of the
concurrency primitives only Adam I think
so adam is available and there has been
a lot of integrations with react.js
react.js being the latest way of
building scalable user interfaces and
closure script has been the early
adopter so to speak of react.js and then
they built amazing libraries own being
the first one and reagent is more or
less very popular library in inclosure
world so if you are interested in
closure enclosure script i think you
guys should take a look at react.js
integration stuff and also the closure
script has macros obviously closure
script doesn't have any runtime and but
the macros are facilitated by closure
with itself so you write the macros
enclosure and then you can still use
macros enclosure script so macros for
the people who don't know those are the
things that write the code for you not
for you that means you cannot hire them
to write to do your job but rather
they're going to produce the code and
because it's it's essentially the same
data structures and the other
practicality of of closure is that
closure seems to are the closure
community seems to prefer libraries than
frameworks so if you come from Java
world especially back in the days when
there was charts or whatever then
everybody was building the next big
framework so you just bind to the
framework and you build the whole thing
within that sandbox
within date you know within the
framework but in closure they the
general idea of the community seems to
be let's make single usable libraries
and and let the developer decide how he
wants to build his entire application so
that's that's the thing that I really
like about closure and then if you see I
mean then obviously that means you need
to have lot of libraries so if you see
closures for example that is the central
repository for closure or at least most
of the guys who are doing the closure
right now so they have found fourteen
thousand one hundred and ninety nine
libraries obviously not at a Sipan level
for the perl guys here but at least you
know very reasonable amount of libraries
and practically nowadays you can find
any library that that you want for your
use case and also as I said because
there is a lot of there is no friction
in drop between JVM and enclosure or the
Java libraries and closure you can just
use any Java library very easily and a
lot of these libraries are essentially a
a wrapper around around Java API to make
it more closure friendly for example all
the way from MongoDB to spark to elastic
search and practically every library
that you have these days that has Java
API has a wrapper high quality wrapper
for closure and just just having an
awesome language and awesome libraries
is not enough because you you go through
a lot of paying every day by just
running some tools which call themselves
simple right so they say there are
simple build tools but they're not
essentially they they're the bane of
your existence sometimes and but
closures build tools I mean these things
are even appreciated or rather you know
they're they're encouraged or rather
acclaimed by other people as well that
even from the other languages for
example Leiningen which is like the
de-facto build tool for closure which
uses closure data structure to define
define a project so you see the
simplicity across the across the stack
and obviously you know Leiningen had
been long enough and as a community they
saw some drawbacks in Leiningen and then
there is a boot which is much more task
based built tool for closure
and these are extremely easy to get
started with and that's that's a
fundamental thing that I I really like
in an enclosure community and then so
you have nice language then you have
nice libraries and you have nice build
tools but every day you're going to
spend practically full screen IDE or an
editor so if you don't have any proper
support for an IDE or editor then there
is no way you could write I'm pretty
sure there are people who use notepad
plus plus I saw some awards for notepad
plus plus there but I missed the
butterflies and daily current stuff so
maybe nobody is using that one so all
the editors that that there is only one
true editor obviously that's Emacs and
in access fantastic support with with
cider which is a community driven
project and it's it has amazing support
for closure and the way that people are
contributing to that one is crazy and
the ideas from cider for the people who
are more into Java are much much more
used to intelligent cards then you can
also use a plugin called cursive closure
and that has all the niceties of Emacs
including the the very famed parody
Mord if if anybody is familiar than its
citizen it's a way to edit list code as
data structures rather than data and so
very nice language simple and elegant
nice libraries nice concurrency
primitives and nice editors but uh but
also what you need is programming is
fundamentally a social activity you need
a you need a vibrant community so that's
what I think closure has I have been
part of the closure at least you know on
the on the IRC since 2005 or something
so I keep idling on IRC and talking to
the people and the way they help me out
and the way they explain things to the
new people is fascinating and if you see
that the the size of the community you
know closure mailing list has around
10,000 something members 10,000 569 I
just took the screenshot today and so
there it's it has very healthy amount of
traffic people building newer things and
people using a lot of things in
production and there is also the new
slack thing nowadays everybody needs a
slack channel for one reason of the
other so the closure has a community
driven slack channel or the slack site
whatever you want to call it so there
are on 166 channels group their own
different libraries different for
beginners or for advanced people or
people using Emacs people using IntelliJ
so you can just join in ask questions
and get help from others or if you're
knowledgeable then you can help the
others as well and obviously there is
still a RC so you can join IRC as well
and so you can these are the things that
you can get from the get from the
internet you know from the documentation
by looking up but you need some sort of
a structured way of learning a language
so this is also a bigger bigger question
whether you have sufficient resources to
learn this language or not so for
closure this is just a snapshot of how
many books that are books and resources
and videos available for closure so
there are more than 20 books available
at different levels so you can pick
closure and then
pick one of those books especially there
is a new book by Curran Meyer I think
called living closure that is very
beginner friendly if you want to get
into closure and obviously there is joy
of closure which is even if you don't
want to use closure I'd really recommend
reading that book just for the fun of it
so to summarize why closure because it
is simple and elegant and it is
functional it has great support for
concurrency it is a practical language
and it has a vibrant and friendly
community this why I'm using closure and
I hope some of these reasons might
resonate with you guys and then you
might want to pry it out so that's the
thing that I hope that it would help but
obviously this all still looks like I'm
talking about closure is the awesome
thing and and why you should use closure
but then why not closure so you would
like to know why you know what is the
reason why I should not use closure so
there are different types of languages
available nowadays so I'm trying to this
is just a my impression of the things so
I might be wrong so you have purity pure
languages and impure languages you have
lazy and strict in terms of evaluation
and you have static and dynamic in terms
of typing I'm not getting into weak
typing thing I'm only talking about
strongly typed either static or dynamic
so closure falls into this category so
it is impure as in the the function can
do whatever the hell they want so you
can write printer lines in at any point
of the time that you want to put in and
closure is essentially lazy because all
the functions are lazy in closure so if
you create a range function that is
going to tell that that is if you don't
provide any any arguments then it is
going to give you I don't know 1/2
million numbers but obviously it's lazy
so it's not going to actually fill up
your heap and it's a dynamic language
that's what I explained before it's a
dynamically typed language and maybe if
you lean in to the other way then you
can pick free or for example and then
Frigga has it's a pure language it's
it's a Haskell based language obviously
inspired by Haskell it wants to be a
husk of an JVM and if you want to pick
obviously it has lazy semantics
of the lazy evaluation and then it is a
statically typed language so you have
two different nice tools to pick your
your your pick your thing to your liking
sorry but there is a there is some sort
of experimentation or the idea that how
you are going to use these two languages
so you have the surface area which you
want it to be typed and then you have
the internals where you really don't
care about types here you want to deal
with the data so you can mix and match
different languages and obviously there
is Karla and so Scala has impure stuff
pure stuff lazy things strict stuff and
it is static maybe it's not dynamic well
you can make it dynamic just call
everything anywhere when you're done but
I wouldn't recommend it so please don't
consider this as a as a it's just a
friendly nudge to Scala guys so that's
that's the reason so it depends on where
you where you fall in and where your
preferences are so there is no one true
language there is no one thing that is
going to solve all your problems so you
want to pick the right tool for the
right language so in my opinion closure
is more about a language that is going
to be data centric that provides the
beauty of Lisp and you can pick closure
as a thing so as I I looked up the
schedule and as a follow up I see that
there are a couple of talks coming up
but the next one is by Joe Kutner he's
from Hiroko and he's going to talk about
a bit of closure as well so if you're
interested in web frameworks in closure
he's going to talk about Luminess that
is one of the web frameworks in closure
and also there is another talk by Lutz
he's from pipe safe and he's going to
talk about different concurrency models
in closure so because he's going into a
bit more detail into channels and other
stuff so I recommend you to pick one of
these talks and continue on this one so
that's it for me it's a pretty short one
but I'm happy to take any questions
yeah yeah so the optional types sorry
there the question is how do you work
around nulls okay so the question is
more about if if we can have some sort
of an language level construct that can
prevent the null happening okay so but
in closure because there is no type
system available so you can't actually
capture that information as a type so
all you have is either now which which
is basically nil and most of the time
nil evaluates to false and there is no
as I said type system to capture that
information but I see that happening in
most of the other languages which has
they have different static type systems
any other questions okay Mac Ruby yeah
yeah yeah so the question was about some
languages have wrappers around the
objects but then I said the libraries
are wrappers around Java API when I said
the libraries are wrappers around Java
API they're just a wrappers around the
API and and they provide the objects as
it is for example if you are dealing
with the spark wrapper or for a
foreclosure you get rdd's because
closure still
have pipes they're just dynamic so you
still have those objects with types but
there is no there is no toll bridge for
the objects so you just use our D D as
an oddity enclosure and I can call any
function or any method to quote proper
object-oriented terms any method on the
object so there is no I don't think
they're conflicting statements any other
questions okay thank you thanks for
listening</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>