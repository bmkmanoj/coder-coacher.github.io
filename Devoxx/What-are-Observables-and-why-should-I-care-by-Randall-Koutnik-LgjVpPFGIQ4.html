<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>What are Observables and why should I care? by Randall Koutnik | Coder Coacher - Coaching Coders</title><meta content="What are Observables and why should I care? by Randall Koutnik - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>What are Observables and why should I care? by Randall Koutnik</b></h2><h5 class="post__date">2017-04-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/LgjVpPFGIQ4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright so this is my talk on
observables and it covers two things
observables and why you should care why
it is important why one of these things
we keep hearing about why they are
actually useful in our day-to-day life
and so in this talk we're going to go
through examples and I'm going to try to
avoid a hour of just pure hypothetical
things and never actually looking at
code so let's take through a lot of code
here hopefully doesn't go by too fast
and everybody will be able to figure out
what's going on first and foremost this
is me my name is Randall coat Nick I am
UI engineer at Netflix and Netflix
absolutely loves Rx and all of the
streaming technology because we're a
streaming company surprise surprise and
we do a lot of work with both our xjs
and RX java so what's this rx thing I
keep talking about so an observable well
I mean this is the talk of what our
observable so we'll cover it what
observables r RX in particular when i
talk about it is this implementation of
observables are X stands for reactive
extensions you can find them in all
sorts of languages so if you're not a
JavaScript er that's okay we'll have
some examples of JavaScript but the
concepts we cover will go to net c sharp
java to all sorts of Java JVM
derivatives these things are everywhere
so in order to cover what an observable
is let's cover some ground to make sure
everyone's on the same page this is a
variable it contains a single value stop
me if I'm going too fast not only does
it contain a single value but it
contains that value at the moment we
declare it when we want it to hold the
value it does this is an array it
contains a collection of values again at
the moment we wanted to we say you you
contain these values and it does we can
add and subtract to manipulate it and
all happens instantly
now unfortunately for us in programming
we can't just do everything instantly
that would be fantastic and I understand
that all of our bosses think we can do
everything instantly but it doesn't work
that way so we have to deal with
asynchronous stuff we need to go ask
another microservice or a database gives
me this data we need to make a call to a
back-end we need to work in ways where
the data we want may not be immediately
available and one way of handling that
is to simply block the entire thread
until the data becomes available which
is a little silly now I like to think
about if imagine if my wife said you
know I'm out when I come back can you
help me unload the groceries and I said
yes I can help unload the groceries and
I just SAT absolutely still on the couch
and did nothing at all until my wife
came back with the groceries now I would
be ready at the moment she came back to
unload the groceries but I am really bad
at sitting still and I'd like to get
some other things done in the meantime
so we need some sort of way to say when
the groceries come back let's do
something and we do they're called
promises and in this case we make a
query to a database and then the
variable my promise contains a single
value the data returned from the
database but it doesn't contain it
instantly it says at some point in the
future I will get this data and we
unwrap that but we adding then say all
right when the data comes back do
whatever we want to do with the data in
the meantime move on down the code and
handle other things so so far I've
talked about three different concepts
and none of them are observables but by
process of elimination I'm sure you all
can figure out where observables fits in
so an observable is a collection of data
where the data it contains arrives at
some point in the future so in this case
we have clicks on a button I'm in the UI
space right now so I think a lot about
button
and you know all of the clicks on a
particular button is a collection of
data but it's not all going to arrive at
one point that would be horrific if
every click ever issued on a button
arrived at a single point in time but at
some point in the future there will be
the user will click on the buttons and
since this is an asynchronous
abstraction we need to unwrap that value
in this case through subscribe I want to
listen in to the clicks on the button so
then we get to the key point and if you
leave this talk with one thing this
should be it and observable represents a
collection of values where those values
have delivered at some point in the
future so there you go that's what
observable are I'm done you can go to
lunch early except for that really pesky
subtitle in my talk why should I care
now of course this is the talk before
lunch which is the worst ever
because everyone's hungry and irritated
so I'll try and get through because I
know that everything especially in the
2017 all of developments everyone seems
to be throwing out new frameworks new
libraries new techniques new
abstractions all the time and I'm doing
that too I am contributing to that net
and this is why I think you should pay
attention to observables I think you
should pay attention to observables
because we can build a stopwatch bear
with me for a moment let's thing about a
stopwatch because the stopwatch contains
three sources of information delivered
over time we have two buttons start and
stop those clicks on those buttons will
arrive over time we have a secret
behind-the-scenes thing where the time
will increment as the SOB lodge is
running you've never used to stop watch
before you press Start best start keeps
track of how many seconds of that I'm
sorry I'm talking to you fast keeps
track of how many seconds have happened
since you press Start and when you press
stop it stops
nothing fancy there so let's make an
observable enough talk about what they
are let's actually put one together so
line by line first off declare the
variable tenth second dollar sign and in
observable land often we add a dollar
sign to the end of a variable is sort of
a notation to say this is an observable
you're going to call observable methods
on it etc etc you don't like it don't
know it I use it here for illustration
purposes and that's what the dollar sign
is for next up we have the standard
usual constructor you have new RX dot
observable and we pass a function in
that contains a single parameter
observer so far so good then we declare
a variable that is 0 set that we've got
that then we have an interval because we
need to keep track of things and our
interval every one tenth of a second
will call observer next with the current
value of the counter and then increment
that counter and finally we return a
function that clears that interval so
what's going on here why is why is this
important why is this useful so
observable values over time when we call
we have that Observer that we've passed
in the observer when we say observer dot
next we say I have a new value whatever
that value is I can pass it in and that
lets everyone down the line all of the
subscribers all of the methods and
things we attach know we have a new
value in this case it's a number that's
it that's simple but it could be as
complicated as you know a new chat
message or a new database row to process
things like that so the JavaScript we
don't do typing and finally we return a
new function and that function clears
the interval and this is worth observer
will start
powerful because we have an interval and
it's going to continue ticking along
until we tell the stop and this
observable will not do anything until
someone subscribes and when someone
subscribes it will run all of this logic
create the interval and start sending
values and when that person unsubscribed
says I'm done I don't care anymore about
what you've got for me the observable
run this final function into the laser
there we go and clean up after itself so
what that means is the actual consumer
of the observable does not need to worry
about memory leaks or extra CPU cycles
behind the scenes are all sorts of
really fun things that result in people
calling you at three in the morning
saying the app is broken you don't need
to worry about that anymore so of course
this sounds complicated this is even
though this is only maybe six or seven
lines of code that's a lot of new stuff
to learn so I'm sure the next question
everyone's mind is how do I get netflix
to do all the work for me because I'm
lazy unfortunately there's a way in our
X we have our own observable type called
interval that does exactly what you just
saw there's no functional difference
between these two snippets of code this
one's just simpler and someone at
Netflix gets the headache if there's a
bug in it so all right we've finally
built an observable and found a bit of a
roadblock because this observable the
values of delivers of the number of
Dessie seconds tenths of a second since
we started since we subscribed and so we
don't want that we want to display the
number of seconds so we're we need to
take every value in our stream and
divide it by 10 so to solve this problem
we need to dig into functional
programming and I promise this is not
scary this am I going to talk about
monads or mono ads or mono end of I
don't care this is going to be simple
stuff I don't know all that either we're
going to talk about map
and map is a simple kind of concept it
takes an array and a function or rather
it takes a collection and a function to
be specific an array in this case
applies the function you give it to
every item in the collection and returns
a new collection with the results of
that function so we have a function here
it multiplies the number by to have a
collection 123 result 246 not too
complicated so since it all map map
operates on a collection observables are
collections all we have to do is say oh
right take ten second map take every
item divide it by 10 simple so far now
nothing is going to happen here we can
declare all this code and it won't do
anything cuz no one is listening in
observables are lazy the only do work
when they know someone's going to listen
to them so we need to subscribe say hey
I'm actually going to do something this
is an incredibly common pattern if
you're ever in the UI space is to do all
of your business logic in the observable
get the source value manipulated however
you want and then finally in the
SUBSCRIBE call put the value on the page
so here we're just setting it on inner
text and just plop it there we don't
care too much about frameworks or doing
things correctly because this is an
incredibly trivial example so that's one
that's our behind-the-scenes counter
taken care of and now we've got the
other to the button and again things are
simple so we use query selector grab the
values off the page and then we have
from event as a way to create an
observable and from event takes an
element and the name of an event and
returns an observable that fires
whenever the event happens so far so
simple we can put it all together into
12 lines of code six of them are
variable declarations
and the rest is our actual business
logic that we need to worry about so
it's a start when all of this code runs
there will be no timer going in the
background there won't even be a
listener for click events on the stop
button because we don't care we will
listen to click events on the start
button because we subscribed and for
every click event on the start button we
then take our tenth of a second that
will initiate map over it divide every
item by 10 and then we've got this new
thing because I've been tricky I've
given you homework we have cake until
you know fortunately we can think about
this take until is attached to a root
observable and we pass in a second
observable in so we're going to take
until takes values from the root
observable it's attached to until the
observable we pass in emits a value so
this is saying is continue taking events
from our timer until the user presses
stop all in one line and not even a
confusing mine and finally we have our
subscription which is actually going to
trigger and the nice thing about take
until is when the user clicks on the
stop button it's going to unsubscribe
from both the timer and stop clicks
which means they're d constructors run
no more interval no more click event we
only are running the things on the page
that we're actually going to use so
let's see if I can get the demo running
we have to button click stop nothing
happens no one is listening to stop
click start we start putting numbers on
a page then we can see as the number
increments as I talk and talk and talk
and talk and talk until finally stop is
pressed and we finished the page is no
longer updated there's no timer running
you no one's listening to stop until I
press start again when the whole process
starts over surprise surprise
and we do want to stop that as I go on
so how we feeling that was a lot of new
stuff just to get a stopwatch running I
mean come on you can probably build that
in your sleep with your preferred
language and framework but why would I
building that stopwatch while we are
saying all right how do we time how long
Randall is talking did you notice we
sold a lot of different problems too we
solved the problem of upon an initiating
event do something until there's a
concluding event which means we've sold
drag and drop and if you're on the front
end and you've tried to do drag and drop
you understand exactly what a
frustrating headache it is to figure
this out without observables listen for
the mouse down keep updating the
position on the page until there's a
mouse up revolt will solve loading bars
which are a wonderful source of race
conditions and headaches and torn out
hair but in this case it's just when the
load start listen to the asset pipeline
take until for whatever reason we
stopped loading maybe it finished maybe
the user decided to cancel maybe there's
an error and for every item just update
the loading bar on the page and we're
all programmers so we all know just how
much we love chat rooms when the user
enters the room subscribe to the room
string update the page with every item
until the user leaves leaves the room
then everything will clean up after
itself everything we do in programming
can be modeled like this can be modeled
as a string even if that string contains
01 or infinite infinity number of events
infinite events so okay I made this
sound really nice you made it sound like
we've now solved literally every problem
in programming it that's not true we
still have to deal with that problem I
talked about in the beginning when we
want to deal with data that isn't there
yet so we're going to Netflix then one
here heard of Netflix by the time it
will start up over in los gatos we have
this nice little feature in the corner
called search
and you can click on search and you can
start typing and it will suggest answers
until you finish typing out whatever
movie you want to see and we tell you
that movie isn't available and here's
some other movies you didn't want to see
that we do have but in that that
technique of trying to figure out what
the user wants before they have finished
typing and displaying those results on
the page where you type ahead of what
the user wants it's called
unsurprisingly type ahead for once
aiming is easy but type-ahead itself
building that out is really complicated
because there's a lot of things going on
so this is a naive implementation all
right you now listen for the key up
event whenever that happens grab the
value of the textbox send that off to
the server and when the server comes
back with result but the suggestions on
the page now since we're running you
know on our corporate network that has
400 gajillion megabits per second or
however that works we're never going to
encounter latency your trouble or
anything like that so all this is
probably going to happen in order and
then we release it to production and
this happens these are types a send the
request off here's I'd say B send the
request off then the request for a comes
back we say got it but the results on
the page then the user types see so now
the full queries ABC send the request
off then the request for ABC comes back
I don't know maybe because it was a
longer request there are fewer records
to search so that query happened faster
maybe it got routed through when got
routed through an overloaded router and
the other didn't we don't know networks
are evil and they're out to get you so
maybe c comes back which they dutifully
say hey put it on the page and then a B
comes back beautifully put it on the
page and the user is looking at a page
that is representing results that is not
what they asked for they get very angry
and they go on Twitter and they yell at
you and your boss gets mad and knots and
lots of tickets are filed and you get to
woken up at three in the morning because
something went wrong so if you've ever
worked at a start-up you know how
startups fix this just keep slapping on
patches until
people stop complaining and we can add
in you know keeping track of state we
can put state into the request itself so
the server sends back this is the
request for a B is a request for a B
which means that the back end
programmers have to make a change which
means a hold of deployment and they get
mad at you again this is complicated
this being the talk and observables you
can probably guess what I think the
better way is so let's build that out
with RX and again we're lazy programmers
so we'll build a pipe ahead that
searches stack overflow so we'll start
off the first line we know what this is
we've seen this this is from a stopwatch
from event got an input box gotta rub
the key up event then we see map we
remember what map does it takes every
value and returns a new value from the
function in this case we take the key up
event and just grab the value of the
text box what's the string in we don't
care about the rest of the event and
then we get to switch map there's a
switch map up there really off I don't
maps are but I don't know the switch map
is and it sounds complicated so let's
skip it forget about that keep moving on
in the results area set the innerhtml to
nothing and clear out that ok so we made
a new request to clear out the old
request we CRX observable Ajax you
haven't heard of this before but I bet
we can make a really good guess as to
what it does does it make an AJAX
request and the answer is yes waited to
the URL we pass and it makes a request
and it comes back and serve the ball
comes back will result to the Ajax
request fantastic moving obviously
merging map you're much like the switch
map above you know what map is we don't
know we never to merge map we haven't
talked about merging before don't know
about that let's skip it move on we'll
get to get back to it later and we see
subscribed and we're back at home
territory we know how subscribe works we
know the first function is going to be
for every value add that value to the
results area and then we see another
function with the perimeter this is our
error function
if there's an anywhere in the
application this function is triggered
it's an observable and error something
goes wrong the entire stream will just
crash and die and say and send down the
air for the air handler to say all right
take this in this case just alert just
tell the user k something wrong I'm done
so about that switch in merge Matt I'm
going to dip a toe or a second toe into
functional programming for a second and
talk about flatten and flatten means
take a collection that has collections
of collections of collections of the and
unpack it now sometimes flatten as in
this case unpacks it as much as possible
but most of the time we talk about
flatten we're just talking about
unpacking one layer so we can unpack
arrays as in this example so there are
other things that are unpack about as
well promise it for instance flattening
a promise means to unpack it and only
return the resulting data from the
problem and we can take our two
functional programming concepts we've
learned today and look at flat map and
what flat map does is it maps and then
flattens the result which is annoying
because we call it flat map but really
it should be called map flat but that's
harder to say I guess for so this this
mapping function is fairly arbitrary but
we do end up getting nested arrays and
then it will flatten that out so from
one two three four two array of two
array of four array of six or eight to
just two four six eight because that
one's really simple so what on earth
does this have to do with switch and
merge mat where's maps the easier one
when you take multiple observables and
put them all together that's called
merging so instead of calling it flat
map we call it merge map since we're
merging rather than flattening to send
the arbitrary choice but that's what
it's called an RX land so in this case
response JSON has a proper
called questions it's an array merge map
takes literally and unwraps at one layer
because we're still inside and
observable and just send each individual
question down as a single event rather
than one event containing a whole array
which means that everyone down the line
can say i only have to think about as a
programmer when i write these functions
a single question i don't have to worry
about it erating over raised i don't
have to worry about promises or
observables or anything like that just a
single question which makes our lives so
much simpler and then we get to the
bigger one switch map switch map is a
special kind of merge map it's a tricksy
function because this one is returning
and observable so you remember the whole
no type a B type ABC and also I'm ABC
comes back with switch map does is all
right we're going to fire off a request
what type of fire off a be and that
request is in flight we haven't heard
back from it yet but we got a new value
we got ABC so it says all right I have a
request in flight and I have a new value
so I'm just going to throw away the old
one and switch switch map to the new
value and only pay attention to the new
value so when the new value goes to the
server comes back that's what I'm going
to pass on down the line and completely
ignore the previous one in fact it's
going to unsubscribe which cancels the
in-flight request which behind the
scenes may end up saving us a lot of CPU
time so that whole aab ABC back and
forth all handled and not only that we
didn't have to handle it RX did and
there's another really important thing
happening here the code is executed in
the order we read it because our puny
meatbag minds like to read things from
top to bottom and really really often
code does not execute from top to bottom
because they're calling functions here
and there and you know because this
actually is called but it doesn't
resolve until that does and I with RX
our code executes in the order we write
it we don't need to worry about parts of
the code
till we get to them so let's take a look
at the demo sorry so have our search box
and nice little model here we can see
key eps mapping to get the value
grabbing search results and actually
putting the question titles on the page
there we go and you can see that even
though for requests were made only two
we're paying attention to only two we
actually cared about because we
cancelled two of those requests as
things went on and you can see in a
really terrible manner because I didn't
style this at all you can see that we
did get some answers and put them on the
page how are you feeling alright alright
it'll littell a girl this mapping and
flattening and merging yeah but starting
to see why these can be so powerful and
expressive when we write code so we
heard a little bit about angular 2 and a
couple people were interested in angular
2 so let's look at angular 2 and angular
2 uses RX for all of its asynchronous
stuff including ajax requests now when
they first announced this i got you know
all programmer mad and raging and
started pounding out angry internet
comments and my really loud mechanical
keyboard and one of the developers
mentioned and said actually check this
out here's our super awesome to reach
out to me and post this code and I read
this code and I just kind of moment of
reached enlightenment so let's walk
through bit by bit in this we are going
to pretend to be a new ride sharing
service and uber seems to be crashing
and burning this probably an opening in
the field we want to tell the user the
status of the car that is coming to pick
them up first thing we do grab HTTP and
import statement we've seen import
statements before that's not exciting
we've all seen it livable about interval
it's not exciting either we've you know
that's old news but it's going to a
trigger once every five seconds then
we'd say our responses are going to stay
kick
we're seeing switch map yes we know what
switch map is going to take the value
and then throw it away we'll get a new
value for the old value got it and in
that switch map is remarkably the same
thing we saw before except with
angular's HTTP instead of observable
Ajax angular's HTTP being integrated
into the angular framework and therefore
it can talk to the framework grabs the
car status JSON or whatever and point we
want to hit and then we've got retry
this is a really magical thing behind
the scenes because when things go wrong
when errors happen what do you do you
refresh the page as I like the joke you
know you never put the EU I engineers on
pagerduty because when we have a memory
leak people just refresh the page the
servers don't go down and then people
remind me of all the memory leaks my
pages have had and I showed up in
meetings but in this we have to look at
retry we have to understand a little bit
more about how observables work so retry
and surprisingly is going to retry
whatever it's attached to three times in
fact and it's attached to an AJAX
request the Ajax request shoots out and
it fails maybe we're just on 3g and it's
just kind of coming in and out so or
maybe the servers are overloaded for a
second whatever again networks hate us
so it's something that fails and we can
put a nice error message for the user
sorry our entire service is down good
luck or what we can do is unsubscribe
which means that all of that cleanup
logic is run and then resubscribe which
read triggers an ajax requests send off
another one in fact try three times
before we finally give up so if we're in
an area with a shaky connection or
something like that all of a sudden
we're able to display the correct
information to the user even if it takes
us a little longer and do that refresh
page behind the scenes the user doesn't
even notice which is fantastic
experience so now we can start to see
how an AJAX request even though original
I'm like this is a promise it represents
a single value delivered over time maybe
it's not a single value maybe we want to
retry and things like that
and then finally we take map and we know
what map is is boring come on and you
know grab the JSON out of the request
finally whenever we do end up with a
successful Ajax request we update the
map this is again put the UI the view
logic in the subscribe and finally we've
done a lot there's multiple Ajax
requests being fired off we've got a
timer and all that when the car arrived
a single unsubscribe says I'm done
everyone up the lion clean up after
yourselves and we're finished we're not
don't have all sorts of intervals and
things spinning off using up the users
bandwidth cap burning the users battery
they get a much better experience from
our code so still a lot to go there
let's talk about hot and cold
observables because so far I've been
talking about cold a cold observe bowls
just like we've been talking about
whenever you subscribe ones the
constructor logic tells you to stop you
unsubscribe that goes away you can
resubscribe and it all runs again
fantastic on the other hand say we've
got a web page and there are 17
different components on the web page
that say I want some value about the
currently logged in user okay that
sounds reasonable well just have them
make an observable Ajax request and so
we fire off 17 Ajax requests and that's
it everything works if something breaks
within fire off 17 times two or three or
four per page load and all the sudden
one of the backend engineers comes
running after us with pages and pages of
server logs print it out you guys are
shouting about us how we D dost
ourselves and we've made so many
requests from a single user page that it
brought down the whole back end and
again haha we've got to fix it so we'd
some way to share the results rather
than resubscribe every time let's take a
look at some you know pretty pictures
everyone likes pretty pictures so here
we have how a cold observable looks for
every subscription we create an entirely
new chain which means the cleanup logic
can clean up item by item which means
that we can take advantage of
making networks by just resubscribe
incredible request again the other hand
there are times when we want this we
want one single chain and the end result
goes out to everybody how do we get that
let's talk about Wikipedia because we
were all colossal nerds wikipedia has
the WebSocket stream guitar that emits a
value every time something changes
somewhere on some wicked media page the
US version the Wikimedia itself all
sorts of the meta whatever it'll send us
a value and this is fantastic for
dealing with streaming data or string
and stream data processing which is
where I kind of got my start and just
kind of figuring out how things worked
or if you want to work with
visualizations as well so we start off
wiki stream dollar sign means and it's
observable all right great RX observable
pass in oh got some setup logic whenever
we have a new change value call oh duh
next we know what that does when there's
an air we call Eau de ayer we don't know
what that does never heard of that
before but from the context that we can
figure it out it calls the error
function an error comes through there
and finally when we're done clean up we
know that and now we have a problem
because if we have a lot of different
bits that want to figure out what's
going on Wikipedia and we don't know
what hot observables are we're going to
have a whole bunch of subscriptions a
whole bunch of socket connections and
Wikipedia will actually ban you for 15
minutes if you open up to many
connections from the same IP guess so I
figured this out and then I learned what
hablas irvin bulls were we have
published and publishes what takes an
observable and makes that split so
publishes is making this split right
here and then once we've published we
have two options for how to deal with
the original subscription connect here
we call connect next we say alright
immediately subscribe to the original
function and all we never unsubscribe
just keep listening and passing on data
we're
our list if we have 0 1 or 472
subscriptions which is nice it's simple
it's one connection it will never break
or of and I don't want to say it'll
never break but we'll never unsubscribe
on the other hand it might be a bit much
maybe we only want to use this every
minute of out of 10 minutes or something
like that in that case we have ref count
and ref count keeps account of the
references or subscriptions to the route
observable so so long as there is
someone listening it will emit data but
as soon as the last listener
unsubscribes it will also unsubscribe
from the word observable and pass that
back and forth so I typically use
connect because again i am lazy and it
just works but there are occasions when
i do need the cycles or whatever and i
use ref count these are the two options
and you can see down at the bottom we
have not one but two different
subscriptions pass it into a bunch of
Statistics libraries to calculate
statistical thing as well as buffer time
which is a new one but that one is
simple to takes all the values for 100
milliseconds and pass them down as one
big batch so it buffers up 400
milliseconds then passes it down offers
up passed down which allows us to handle
the data in bash form so we only update
the graphs every tenth of a second and
all of this code not all this explaining
gives us something that looks like this
and we can see all the Wikipedia edits
as they happen and the grasses you
notice can are only updating once every
tenth of a second instead of everything
goes along so a quick summary here
because I understand hot and cold can be
difficult as a more advanced concept
special if you're just starting out a
hot will allow you to split a single
connection a cold will allow you to
retry if you will so we got a few more
minutes you're more things to talk about
let's look at that type head example
because like any good programmer it
could be better this is the first half
added a few new things
we have our again the same thing grabbed
the element grab the value but in this
case if there are fewer than three
characters in the type ahead we probably
can't guess what movie they're thinking
of or what stackoverflow the question
they want if the query is a simply
saying here's all the stack overflow
questions that involve a litter a will
not actually help our user so in this
case will say let's hold off until
they're at least this many characters
secondly we have debounce how many
people have heard of or used debounce
function a couple non hover odds I'll go
over it for a second howdy bounce works
here is I handed a value indiebound says
all right I have the value I am not
doing anything with it I'm going to wait
333 milliseconds before passing it on
and 332 milliseconds later I handed a
new value it throws away the old value
and says all right I have a new value
I'm going to wait 333 milliseconds and
then 333 milliseconds passes is alright
my timer is it up I'm going to pass that
on the practical upshot of which is if
we pay hand it in a ton of values all at
once it's going to wait until there's a
pause in the input before finally
sending the latest value it received on
so if you're a fast typist we're not
going to send a request for every
keystroke we're going to wait until
you've finished typing before sending a
request and even then we have one more
function and this is my favorite because
it takes something that typically would
be really complicated and I've written
so many times before i discovered
observables we have distinct until
changed and distinct until changed we
handed a value that's all right this is
the first value I've seen I'll just pass
it on I have no history to record then
we handed another value looks of that
value compares it to the previous one
says this is different these are two
different values so that new one I'm
going to pass it on and then store it
and we handed a third value so this is
identical this is the same as the
previous value I'm not going to do
anything with it because you haven't
changed only Pat is a special type of
filter that keeps an internal state and
says only pass on when the value new
value has changed something because as
many programmers myself included have
discovered by sending off an inordinate
amount of requests pressing left and
right if you happen to be the sort of
person who fidgets a lot I don't know
anyone like that pressing left and right
an input box is a key up event which
means that we sit there and press left
and right a hundred times going to send
100 requests from the space of a second
or two which makes second programmers
angry again distinct until changed one
line one function all the headaches go
away and on the other side of things we
have their switch map works the same way
we haven't changed that much we've added
in a catch below it so instead of just
blasting an error or retrying as it were
because we don't want to retry in this
case because it's not a relaxed request
at its root excuse me it's an input box
we can catch if there is an error simply
pass this value on and we have pass on
empty set of questions and keep going do
not immediately fail we don't want the
user to suddenly because something went
wrong in the network never be able to
search so have some safety there same
urge map we saw before same subscribe
interesting thing now is now that we've
added catch unless somehow the merge map
dies we will never see this error
trigger we've added a third function to
our subscribe 3 s hope 3 isn't too many
and it is our done function because
there are certain types of observables
that finish Ajax for instance and Ajax
observable can say when my request is
finished or errored over well actually
when my request is finished pass on the
request result and then say I'm done if
anyone is listening in to what I have
tell them I will admit
no more variables no more data and this
can be useful there are other types of
observables that are infinite we have an
infinite stream of data passing through
them they will never call done an event
observable like the one we have here an
input is such an infinite stream so this
function will never ever be called I
only put it there because I wanted to
show off so these are the three types of
functions you pass them to subscribe
dealing with data dealing with errors
and dealing with one the observable
finishes so let's have our third and
final demo close that out it's your new
improves type ahead of lots lots of fun
things that's first thing to do type in
the letter o our filter NAB's it I don't
have enough information to ask the
server now it gets passed filter the
debounce weights then we is a new value
send up a search get the result and then
I can do my fidgeting and press left and
right and the demons will catch it
they're right I'll admit one value one
is still too many nothing's changed
distinct prevents that from happening so
again we're sending no requests off to
the API and we won't get banned which is
no fun until of course we actually
change what's going on so that is what I
have for you today these four people
helped inordinately in me putting
together this presentation Ben Lesh
jafari saying Jay Phelps and Rob Wormald
all fantastic people you should find
them on the internet and listen to what
they had to say and finally I have
stickers they say netflix i hear people
like netflix stickers come and find me
because everyone knows how good of a
develop you are is intrinsically related
to how many stickers you have on your
laptop all right thank you any questions
come on forward</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>