<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Functional data structures in Java by Oleg Šelajev | Coder Coacher - Coaching Coders</title><meta content="Functional data structures in Java by Oleg Šelajev - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Functional data structures in Java by Oleg Šelajev</b></h2><h5 class="post__date">2017-03-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/NWV5IrEg3c0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right Oh excellent
good morning really happy to see you all
of you here let's talk about functional
data structures and Java I cannot see
much of you but I will hope that we'll
have a good session today
so a couple of words about myself my
name is Alex life and I come from
Estonia which is a tiny country just
below Finland and I work at zero
turnaround as a developer advocate
my main responsibility as a developer
advocate is to care about community of
mostly general developers so that's how
I get chance to travel and talk to
people research stuff and everything I
maintain our blog called rebel apps so
if you check it out
I'd be happy you can always find me on
Twitter and ask any questions about
either this session or anything else
I'll be happy to chat and I'm also a
leader of a virtual jug which is a very
cool and the war we took the Java user
group concept and took it online so you
can participate in the sessions and
learn without leaving the comfort of
your own home which is great you are
quite likely the sutural and jug is an
amazing amazing community but if you
would like to join that what one would
be cool as well so zero surround is a
company that does tools for Java
developers and currently we have mostly
two main tools durable supports a
productivity and it can reload changes
to the Java classes at runtime so it
saves you time an extra bowl is a
performance tool for web apps so if you
would check those out my employer would
be happy and they will send me to talk
to more people at the conferences so
without all with all that formalities
out of the way let's talk about
functional data structures and the first
thing that I would like to point your
attention to and ask you is
what does functional mean in the context
of the data structures and at some point
of time I ran a Twitter poll which
unfortunately did - I don't know timing
or something didn't didn't gain very
much popularity but the question is when
you say functional data structures and
when you read the title of this talk do
you think that we are going to talk
about data structures that are correctly
implemented and not dysfunctional in a
sense they are doing what they supposed
to do a list is actually an ordered
collection of items are they so who
thought of functional data structures in
that sense that we're going to talk
about correctness very good we thought
that we will talk about data structures
that are not imperative a couple of
people excellent
who thought that we would use this time
to talk about persistent data structures
that requires a bit of knowledge about
what persistent data structure is so
it's a deeper level
mariya great excellent and all of the
above is so most of the time if you
didn't raise your hand just yet so you
have a very mmm basically blank list and
we can talk about all of the above and I
hope you would find it useful and enjoy
it so we're going to talk about
functional data structures in the sense
that data structures that are that have
certain properties we'll talk in a bit
and mostly is it suited for software
engineering and development programs
when you use the functional programming
as a style and they originated from that
and functional programming is a little
bit different it's a cognitive way of
thinking about programs so this is the
picture of Ted Newerth and he has an
amazing session on why functional
programming matters so he goes from the
basic concepts on the functional
programming and how it is a toolbox for
developers
so you will get immutable values
laziness functions as the first class
citizens partial application recursion
all that is the base of the functional
programming so this is a toolbox so when
you develop your code and your
applications you would know that ok yeah
this is a good bit I could use this
particular thing very nicely for this
particular problem and we would in this
session we would look at the data
structures we would look at the
collections because well data is a big
part of our applications and their data
is the universal thing that kinda is
common for all applications so that's
why in any program you will find tons of
collections tons of the wrappers that
hold the data and allow you to modify
and access that in certain way so you
would have sets and lists and trees and
all that is offered by either the JDK
itself or you as the part of the Java
collections framework or you will have
third-party libraries if you would like
to do different trade-offs and at some
point of time we did some research of
what are the collections what are the
options and the response to that which
is that actually this is a very cool
printable thing so if you would like to
check it further one thing that we found
out is that data structures and the
collections were studied extensively for
many years right so if you have a formal
computer science education then you
probably know that like 50 years ago
even before they start talking about how
amazing agile is they talked about lists
and how to reverse a linked list and and
all the different problems that people
attack here at the interviews however if
you if you look in the internet you will
find that almost all the literature
claims to be language independent and
indeed you can program an efficient
graph library in any language however it
is very unfortunate that its language
independent in a sense
that Henry Ford once said that
programmers can use any language they
want as long as this language is
imperative so it is language independent
but the platform and the way of thinking
how the papers and the implementations
of this the data structures think of
themselves is very imperative so you
write the code that modifies data in
place that uses shared mutable state and
this particular implementation a way of
thinking is not very suitable for
functional programs so in this session
we're gonna look a little bit how to
implement the data structures that you
know in a functional way what are the
trade-offs why is it not as easy and how
would you like to think about data
structures in a functional way so if we
look at the whole universe of data
structures that we have and there is a
hierarchy so the first step will be the
mutable data structures and they are
pretty nicely represented by the Java
collections framework in the JDK so one
of the main prime examples of that is
that we have an interface called
collection and you will have the methods
in that kind of like clear and add
elements and everything like that so the
interface defines our API that we access
the underlying collection and it could
be anything but the Java collections
framework implements mutable data
structures mostly so you will find that
you have in the interface in the API you
have methods that have void as the
return type which is a clear sign that
you are dealing with the mutable thing
so if you command an object to do
something and it doesn't return you
anything back it means that it does
something creates some side-effects
and then operates on some mutable state
and then just comes back to you and says
oh yeah I did this thing so mutable data
structures is what you know from the JDK
library so
a little bit off-topic a void return
type could be seen as a little bit of a
code smell so check your API for that
probably you can restructure that to
return something meaningful rather than
operate on side-effects back to
collections so we have the next level in
the hierarchy of the data structures we
have the immutable data structures an
immutable data structure is the one that
cannot be modified after the creation
and in the general world you will have
you can construct those immutable data
structures by using the unmodifiable
wrappers so you take any collection you
call the unmodifiable list or set on
that collection and you will get a list
or a set that cannot be changed at the
time so this is very interesting and
immutability is one of the core
properties of the functional data
structures so a functional data
structure has to be immutable that is
the definition of that Y being immutable
and using wrappers is not enough because
often if you expose the argument this
other list that you used the original
collection if it if it gets exposed to
some clients they can still modify that
in place so and despite you not being
able to add elements to that wrapper
unmodifiable list collection still your
data could change and that will break
some important invariants and that will
break some assumptions and boost
functionality wise and performance wise
and that would be not very good so if
you using unmodifiable wrappers be sure
to not not to expose the arguments
thanks properly for the data structures
to be functional is that they have to be
persistent and the persistency probably
is very simple when you modify the data
structure it has to preserve the
previous state so it kind of just
modifies stuff in place
we would need some sort of magnification
because only unmodifiable collections is
kind of pointless because just you can
just read the data but what we require
is that when we want to do the updates
they are not destructible destructive
and they create a new data structure and
you will have access both to the prior
version of the data structure and the
current one so if you think of how you
manipulated idea most of the operations
just operate on the data locally so you
do small updates sometimes to the
particular parts and the main idea for
the persistent data structures to make
them actually reasonably fast because if
you just copy large large chunks of
memory you would never get reasonable
performance and you would never be able
to use all those things so the main idea
is that you just reuse as much structure
as possible and just implement the
change in a way that doesn't break that
so you are memory efficient and you will
get persistent data structures however
persistency as the property is not as
easy to implement and that there are
come up a couple of changes so the
functional data structures are by
definition they are immutable and
persistent when your data structure is
immutable and persistent you can call it
a functional data structure the methods
on the functional data structures are
referentially transparent that means
then that whenever you call a method you
can cache the value and reuse that
anytime where you call that method again
if you think about that if you cannot
modify the underlying data and you
always have this access to the
particular version of the data structure
however you call and get data from that
data structure it cannot change so very
efficiently you can call a method once
and then cache the value and be quite
happy with your program it also
simplifies how you reason about your
data structures and collections when it
when you are working in a concurrent
environment when there are many things
trying to access your data at the same
time we
normal collections with mutable state
you would have to guard the access
introduced locks or come up with like
very smart and sometimes not very smart
algorithm to kind of guard the access
with functional data structures you know
and now nothing can change so you are
very free to just come and get the data
as you like and reasoning about programs
becomes becomes much easier so this is
one of the points why you would like to
use data structures perhaps now if we
talk about the implementation of those
we have very strict constraints we have
two problems that first we cannot just
assign or reassign parts of the data
structure at will and then we always
have to think about that when we modify
the collection of the data structure we
have to be aware that we need to support
multiple versions of this collection
existing at the same time so that poses
some challenges to the implementation
and that is also hard to reason about
when when you think of everyone knows
how to implement the tree right you
create a root node and you create
children and then you swap the children
at will when you need to update the tree
and and you know that it is fast when
you think of functional data structures
when you will have to preserve the
existing tree so we have to copy state
all the way at every operation you would
be thinking that this is a slow and you
would be kind of right so you would not
use them in the real code however you
should so let's look at how you
implement data structures even basic and
how you reason about performance of
those when you have that so we will
start with building a list a very
primitive data structure is just the
ordered collection of items and the
functionalist functional implementation
of the list is the cons list which is
the two elements it has its head and it
has its tail when where the tail is all
the elements in the list besides the
first one and since we know that our
list will be immutable we can
always specified that we know the
lengths of this list and we have our
immutable list in a very simple code now
this is kind of useful because we have
all the private members and we don't
have any API to access this as a
collection let's build a new list so if
we would like to add an element in front
of the list what we do since we just
have this conflict we create the new one
we preserve the this instance of the
cons list and we create a new one
pre-painting the element as the head of
the list so now we have if we take a
list and we had like for example list of
two and three and we prepend one to that
list and then we take the original list
repent to we would have a picture in
memory that looks something like this so
there are multiple lists going on every
every element here every square is a
list in itself and they are reusing this
structure as much as possible so and we
can prevent and build the list from from
the left so we built long the list from
short list is it immutable yes because
we do not change the structure we just
create new stuff all the time is it
persistent yes because we always
preserve the access to the previous if
somebody had the reference to the old
list it never changes so they can still
use that can we do more operations on on
the on that list for example can we
follow the list we can because well we
just have to iterate the the list in
itself if you look at this code the most
important bit here is well you can
iterate the lesser using taking the head
and then the head of the tail and then
the head of the tail and so forth until
you have no tail so definitely you can
use that so can you write the code that
is
destructive so we you can see that in
this code we have the assignment and we
reassign the things yes you can it
doesn't change the fact that your data
structure is still immutable you can
distract and the state locally when
nobody sees that if nobody sees that
you're distracting things you're still
immutable and then and cool so you can
fold the list you can also reverse the
list by using those to get a combination
of those two operations so you just have
to go through all the list and add the
elements in the reverse order and this
is a longer operation you have to
traverse the whole the list the same is
if you want to append the element to the
list so you have to kind of opinion from
the left was easy and fast you just
create a new instance and you share the
whole structure appending from the right
is very tricky because you have to go
through a whole list kind of like in the
list linked list manner and then
recreate the whole list so this would be
appending from the right appending to
the list is a slow operations so now we
have to talk about how slow that is and
obviously you can run some benchmarks
and say oh this is slow and this is
faster but when you talk about data
structures you would like to talk about
algorithmic complexity so what you would
like to to be able to say that yes this
data structure this approach is
potentially as fast or comparable in
performance to the other ones so when we
talk about algorithm complexity we talk
about number of functions that say oh my
operation will finish in the constant
number of steps or my operation will
finish in the linear number of steps
from the input lengths or logarithmic so
if you have to traverse the whole list
all the way back you will have to use
take at least linear amount of steps
from the input size if you have to go
traverse it back and forth and force
again so a return trip it's still linear
but if you have for every element in the
list you have to do all that again and
again and again you get quadratic
and that would be much slower so while
this is all coolant nice it's really
hard to reason in terms of proper finite
complexity of accessing functional data
structures so people have come with
amortized complexity and the main idea
of the amortized complexity is that you
don't judge the performance and the
complexity of individual operations but
you know that you would be doing
multiple things with a single data
structure and then we would like to have
the total expense of those operations
together so and this the way amortized
complexity is with reason about several
data structures because it's just easier
that way so and it's also very nicely
mapping on the real world well you did a
lot of stuff and he would care about the
performance of the whole thing rather
than individual things so imagine we
have a list imagine we have a list like
this and we do a series of operations
with admin stuff from the left we
prepare stuff and then we reverse the
list so we know how to individually
think about the complexity of those
operations so pre-painting is just
creating a new instance of the cons so
it's a oh one operations it takes
constant time so in a sense it doesn't
matter how long your list is you can
prepend at a constant time but reversing
things takes the linear amount of steps
so that would be slow so can we assess
how much time this whole thing will take
per operations so if we do the reverse
only every n steps and operations of
such will we get a better complexity
than linear because here we have o some
operations take linear time but with
this pattern we can use the bankers
method of assessing amortized complexity
and the bankers method is very simple
for every operation we just don't count
we don't just count the actual
of that so constant time but we add a
little bit of credit to every operation
so every time we call a cheap operation
a fast operation we get a little bit of
credit and then later we can spend that
on a more expensive operations so the
end prepend operations will give us n
times a of the credit so the total
complexity of this thing will be big-oh
of 2n plus n times this tiny credit and
then we just do some mathematical magic
and we take the end out of the
parentheses and then we just say divide
that by n because we have n operations
in the list so we have the amortized
complexity operation of a constant plus
alpha which is a tiny tiny tiny credit
and you can have it as tiny as you would
like so in a sense when you have the
function list a cons list and you have a
set of diverse operations including
creating the data and accessing that you
know that on average in the long run you
will pay the constant cost for
operations so these operations will not
be much more expensive in terms of
performance that the mutable collections
because they're you would still have
constant time access and here for
operations we have just a little bit
more so using bankers method we will
estimate other collections as well so
the problem with this obviously is and
you could ask me but like what if I
don't call what if I don't call the
prevent and cheap operations often
enough what if I just use like the
expensive operations right then if you
have the code and you expose the API you
will have people on your team or in some
other department the crew only call
expensive operations just to make a life
harder and that's that's for sure so
with functional data structures the best
thing is that since they are immutable
and persistent and they had they have
this referential transparency property
you can cache there is
and if you combine that with delays
evaluation so you would not give the
answer until it's really needed then you
can have the full cache and enabled and
then you would just somebody calls an
expensive operation
you give them a result immediately so
the first call will be expensive the
rest will be very fast so you would need
a little bit different implementation
and it's not maybe as easy to implement
but there are ways to make it fast and
performant so enough about math let's
talk about other collections before
because we are here for data structures
so we saw a list and list is not very
hmm it is very interesting and very
basic data structure but let's talk
about something more real life so let's
build a queue and in particular because
queues are amazing they're good for
communication you can put messages on it
you can stay in the line for public
transport maybe not here but in other
countries less lucky so how would you
build the queue if you have a list who
has an idea now then we can maybe how to
build the queue okay good I can build a
queue like this so I just say that oh my
list is kinda it looks like it here
there are elements behind each other in
order and they can access it from both
sides from the both ends so I just have
a key that is implemented as a list
which is our cons list which is which is
good so now this could be a functional
data structure but it wouldn't be very
interesting because in a list with the
list you remember that accessing the
list from one side was extremely
efficient from from the other side it
was kind of slow so it took the
traversal of the whole list to find the
end so with the implementation like this
your performance will suffer and he will
throw it away and you will come back to
struggling with using mutable
collections in mutable data structures
so you have to be smaller and you since
only thing that you have is a list what
you did you implement a queue
by using two lists duh so we will have a
queue that is represented by two lists
one is the front and the other one is
the rear of the queue and the trick will
be that the front list is in order as we
assumed so the head of the front list is
the head of the queue the rear of the
queue will be in the reverse order so
the head of the rear is the tail of the
queue then the vq if you think of a
picture if you need a picture this is
like that and by the way all those like
very nice diagrams comes from the
documentation of java slang we'll come
to that in a moment but yeah I just
copied them from there couldn't create
better myself so imagine a queue of 1 2
3 4 5 as elements then at some point of
time we can represent this queue with
two lists where the front will be a list
of 1 2 3 and the rear will be the list
of 5 and 4 why is it amazing because we
can easy it we have easy access to both
ends of the key now because both ends of
the queue are the heads of the lists so
we can access them very efficiently so
if you would like to NQ an element to
add an element to the end of the queue
the most normal operation right
what you have to do you just creating it
you because we are immutable so we do
not disrupt the old VAR values so you
create a new queue and you just prepare
the element the real list so now the new
queue will be the same front and the
same rear with one element added you can
see that that this operation definitely
takes what does it take a constant
number of steps we don't do any
traversal you just create any object and
this should be pretty fast so if you
want to tail it here which is a very
important operation so you take all the
queue except the first element you just
use the operations on the lists again
since you don't need you you need
everything
besides the first element you just drop
it and create a new cue out of that also
you can see that there is no traversal
going on so it's very important and to
be efficient so this is how you tell if
you want to implement the peak operation
just to look at the things you can also
do that very efficiently you have the
data in there you just access the cue
from one side you get the head and you
you see the valid values there and the
code if you if you think of the code the
code is pretty trivial right nothing
that I have shown on the slides is just
actually like rocket science for
anything more than three lines of code
so if you assume the right paradigm then
implementing the code in the functional
way could be quite easy as well now
unfortunately not everything is as shiny
and nice and green and unicorny if you
have operations that actually have to
modify the data structure so example for
example you want to DQ an element you
want to take the head and remove that
from the queue so you can potentially
access and consume the whole queue of
elements one by one so if you just peak
at the head and then you pick up the
head again you doesn't change so you
will not get to the processing of all
the elements which would be ashame so
you will need distractive operations
since we have to be persistent and we
cannot change the state our destructive
operations will return a tuple of values
so for example here if we have a queue
of integers and we call the DQ method
the result would be a pair of elements
one will be the result the head element
the integer and the second one will be
the state of the queue after DQ in an
element why is this important because it
violates the contract of the Java
collections framework for for for the
collections so in the queue if you look
at the the queue in the Java collections
framework DQ doesn't return you a pair
it will just return you the head element
and you can reuse the reference to the
key from the old code because it changes
stuff in place so you cannot use
functional data structure as a drop-in
replacement most of the time some of the
time you can but if you are considering
that oh my god I am sold I would like to
just replace all my collections with
functional now just to be so much better
at reasoning about concurrent access
this is not happening
so you will have to change stuff but
however with this approach you know that
the original queue is not affected and
you can definitely do that
so the actual DQ would look like that
so you just return a pair of the head
element of the queue and the tail which
is the rest of the queue how is that
good how is how we can do that and if
with our collection is empty we use math
to ensure that there are invariants so
we would like our key to be in the sense
when our front is empty we should know
that the rear is also empty because if
we just consume the elements from the
front then at some point of time we have
to start consuming the elements in the
rear from the back because it's the
reverse list so we need to ensure the
environment how do we ensure
environments with data structures we
carefully write the code that mutates
those the benefit of functional
collections we don't when you take them
right so we only change them in the
Constructors when we create stuff so the
only place where you have to think about
the logic of maintaining the invariants
is the Constructors so when you create a
queue if the front list that you give is
empty you just reverse the rear and put
it at the front and set the rear for
empty so this is how you maintain the
invariant that when you front is empty
the rear result are empty so when your
collection is empty you queue is empty
it just one you can only change shake
the front however you can notice that
there is the rever
separation which is an expensive one so
now we have to reason about the
performance of this queue again however
you will find quickly that the
implementation of a queue like that
achieves the amortized cost of a
constant operation so oh one and you can
prove that so a sketch of a proof will
be like this so imagine you have a queue
where you have the m elements in the
front and m elements in the rear so the
only time when you will need to decode
the reverse operation when the front is
empty so you would have to call DQ at
least m times to achieve the state where
the front is empty and the rear has to
be reversed so and as we saw using the
banker methods we can estimate that if
we call the DQ m times and then we do a
linear number of operations for the
reversal the amortized cost will be a 1
so that will be quite fast how awesome
is that you can use mass to reason about
performance of your algorithms and data
structures which is I think it's quite
cool so let's go further how to build a
map because maps are everywhere
javascript objects and maps
java objects are not exactly maps but
you can think of them as maps you have a
map collection you try to get the keys
and values all the time so how to build
a map when you have a list and the queue
who has an idea
Mireya so it's actually it's quite
intricate and you cannot just build a
map by combining lists and queues
because you have to have a relationship
between keys and values however have no
fear for the functional data structures
you have a map implementation and
actually several of them and they come
with very nice properties what you would
what I would like you to know about the
functional data map functional data
structure map is that it's typically is
based on the hash array mapped tree tree
as in like suffix tree which is the TR
i.e tree
and it basically what it does it looks
like this so we have a key and you
separate that key into the chunks and
the key is actually the past from the
root node to the leaf node where you
store the value so if you see on the map
the green part of the key represents the
node here so the next couple of bits in
the key are determining which path you
take down this hash array map tree and
then you traverse your key by those
sections and you find the way to some
leaf node and that will be your value so
this is how you represent Maps most of
the time in a functional way so you can
access that your access time will be
quite fast because there are only so
many bits in the key imagine if you have
if you have a binary tree where your
keys are integers which are 32-bit
numbers right if you have the branching
factor of two so every time you can
either go when you see zero you go left
see one go right you will have the tree
with branching factor two and the depth
of 32 because you have only 32 bits in
the key so your access time will be
othor t2 something which is still a 1 32
is kind of like a constant for some
reasonably large values for the
constants so updating this map will go
exactly as we did with all the other
stuff so when you have to change things
or add things you just try to reuse as
much structure as as you can and just
add the pieces that are missing so we
just recreate a single branch there and
then we reuse all the structure before
that and we just reference that the
previous data structure why we can do
that because we know that the previous
data structure is immutable and it will
never change why is it also cool because
we only reference the data structures
that go below the root level so we know
that if nobody is pointing to the old
version
anymore it can be safely
garbage-collected so we are working with
the platform nicely we are simplifying
our reasoning and we can do a map like
this I will not provide an actual
implementation of the map because it
doesn't fit on a slide so that is quite
complex but you are definitely welcome
to just go see that let's go further
let's talk about trees again and this
would be the last data structure that I
want to talk about today
normal trees we all see that but I would
like to talk about the zipper zipper it
is a functional data structure which
allows you traversal and nice
representation of trees with updating
them locally so if you think about how
we think of a tree and this is an
example of a red-black tree it's just a
structure we have root nodes and
children and you traverse that from the
top and then you do something and when
you have to change this structure you
will have to recreate the whole branch
because otherwise you break the
existence existing data structures so
now we're a zipper comes in it's it as
if were aggregates the data structure
and the traversal of that and it changes
the perspective how you see that so if
you look at the tree through a zipper
imagine that you are actually somewhere
in the node inside the tree and until it
actually has it has pointers not just to
children but at a pointer to the parent
as well so now every time you you
traverse the tree you will create a new
node and you will point to the
neighboring elements so we're as if ur
represents a location in the data
structure and it is fairly useful the
coolest bit about that is that when you
need to change the value locally you can
just do that and create a new super
point into old neighbors as well so
local modifications are super simple and
super efficient using zipper traversal
will take a little bit of time but
probably you can pay the cost if you
think about the zipper it's kind of like
the file structure right file system you
it all
it's a tree we know it's a tree but it
always allows the going up one level
data structure so you know where you are
you can modify the files locally and
then you go up and down and and and you
see all the contents back and forth so
now you are probably pretty sold on this
that functional data structures are
amazing and you know that Pierce who
programs in Java most of the time Java
people who who does Scala three hands
who does closure I love closure
I don't program in that that much
anymore but I love it it's Lisp lisps
are amazing parentheses our everything
so back to the so we have the
implementations and the libraries that
provide functional data structures for
other languages now we have them in Java
as well my favorite of them is the java
slang and it is a pretty cool library
they wanted to just initially they
wanted to create a wonderful API
expressive and better than the normal
and then they created a functional
collection of library and it's a cool
piece of java code it's very interesting
we are also lucky that in the evening
the last slot greggers will talk about
java slang more in detail so you're
welcome to join and listen to that talk
how you can use that to spice up your
projects and how to do functional java
maybe better there are other libraries
that give you access to the functional
collections like pea collections and
others but I use mostly Java slang
myself what it does it gives you the
wide set of classes that implement all
possible all mostly reasonable data
structures in a functional way so you
would have the list the pews the maps
the priority queues which is fairly
interesting and then it will give you
additional things so what it's what is
cool about Java slank as well is that
they it comes with a set of benchmarks
they know that performance is a big
question in terms of should I use
functional data structures not so they
provide a set of micro benchmarks inside
the repository and they run it all the
time to ensure that they don't have much
regressions basically what they did they
compared a number of implementation of
different collections and say if you are
interested in priority queue in
particular because it's a very cool data
structure you will have they will
compare those implementations and you
will see some results and you can run it
and see if you would like to run it so
it all the benchmarks are written using
the java micro benchmark harness so it
kind of gives hope that those benchmarks
are not just random numbers and you can
you can look at that say the code for
the benchmarks would be something like
this so if you want to see how much time
the in queuing elements will take just
wanted to illustrate how they do the
benchmarks for the collections they just
take the empty one and append in queue
elements until it's full for a certain
number of operations they do the DQ in
the same way they just take the full
queue and just call the operations that
you know it's empty which kind of
mirrors the normal collections for the
queues or other data structures they
have also a more complicated data
structure of benchmarks like sorting
data with the priority queue so
basically you fill it with numbers and
then you take them numbers out and since
it's a priority queue it will come in
order and when they you run you will get
a result like something like this so
there will be the ratios than the ratios
yeah there will be the report that says
the ratio between the implementation of
say java slang persistent collections
and java immutable collections or
blocking collections and the results are
and here I don't want to point fingers
or say this is good result of this is
bad result that this is the way it is so
safe harbor statement applies here but
in general when you look at those
numbers and iran the benchmarks you will
see that java slank collections or
I run the priority queue benchmarks just
this morning it's a little bit slower
than the mutable blocking priority queue
it's a little bit slower than the
mutable version of the Scala priority
queue it's a quite faster than the
persistent version of the collection of
the protein scholars II don't know what
they do in Scala C but the the results
that I got were a little bit like this
so you know that you will pay the
penalty performance penalty if you use
functional data structures and this is
just priority queue so you kind of just
say that oh Java slank is T times slower
than Java because that doesn't make
sense but you kind of get an estimation
of what would be the performance penalty
for that and what you can do next you
can just experiment and look at the data
and try to maybe use that in your code
and then run your own benchmarks and
your own software to see if that makes
the performance penalty that are worse
for you and you will also see if you
would like to work with collections and
data structures in a more functional way
so as I say the object oriented
programming makes code easy by
encapsulating the moving parts and with
functional programming you minimize that
and then your code is more reasonable if
you would like to know more about data
structures there is an amazing book
called purely functional data structures
by Chris Okazaki and I think it was
released in 98 so quite a little bit of
time ago and then after that a lot of
things has changed so if you would if
you don't like the books and you would
like to just go through the internet and
get more ideas of what the current state
of the functional data structures is you
can check out that stack overflow answer
and that is one of the best the best and
the most amazing stack overflow answers
I've seen in my life so it talks about
what has changed and what has been added
to the data structures functional data
structures saints that okazaki book
which is a classic book so and it goes
this one goes about different Maps the
maps for primitives
finger trees explains the dippers
much more and links to pages article
blog posts and implementations of all
kinds of purely functional data
structures so I hope this was
interesting I hope that we looked under
the hood of how some functional
collections could be implemented what I
want you to take away from this is that
you can be immutable and you can be
persistent and still you can have a
decent performance and readable code so
thank you I think we have exactly three
minutes for questions no questions great
then I think we have lunch in this
during this break
please somebody correct me if we don't
so Bon Appetit</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>