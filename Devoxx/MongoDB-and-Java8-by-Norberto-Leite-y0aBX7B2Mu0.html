<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>MongoDB and Java8 by Norberto Leite | Coder Coacher - Coaching Coders</title><meta content="MongoDB and Java8 by Norberto Leite - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>MongoDB and Java8 by Norberto Leite</b></h2><h5 class="post__date">2015-11-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/y0aBX7B2Mu0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">right everyone welcome to the session on
MongoDB and Java 8 we will be talking
today well for 15 minutes not too long
not to bother you during your lunch no
worries about that but how we are
supporting or how we can integrate our
new coolest application built on top of
Java aids and connect it to our you know
favorite database of choice which
obviously as you might be here sitting
down is MongoDB now we're going to be
looking to the main features of Java 8
how we can integrate with MongoDB a few
of the examples of code snippets that I
prepared for the stock and also talk a
little bit about the reactive driver
that we just recently well a few months
ago released it might be very useful for
you guys if you're building a
synchronous applications or reactive
applications on top of Java 8 so there's
a lot of heightened today or in during
this confidence about Java nine so we
are starting to understand what's coming
on Java nine and a lot of people are
still migrating from Java 7 and java 6
back to Java 8 or to Java 8 and start
making use of the coolest features of
Java 8 but i have to tell you first hand
that we are going to be still supporting
java 6 for a long time yesterday if you
guys been in the java console someone
asked well who's still using java 1.2
I've seen companies still using Java 1.2
because they don't want to upgrade their
system and to critical for them to
actually fix bugs so they understand
their bugs they understand limitations
and they will do you do you use it and
mongodb java driver will be still
compliant with 12 1.6 for a while this
is due to the large majority of
installations out there the JDM at the
end but also because of long term
compliance reasons we will be supporting
java 6 and above for a while so legacy
code support it always going to be there
but that doesn't restrain us from
actually start benefiting from the
new cool things that job eight actually
brought there's plenty of there's a big
list of different things that job eight
brings into the table allows us to do a
lot of cool stuff special alumnus limit
expressions the new data API are type
limitations streams all those things are
very cool I'm going to focus on the
things that I think are more important
from the communication with the database
like MongoDB and the things that are
really important for you every time you
want to process data there's a reason
why we have the lambda functions and the
stream processing API in a new data API
it's to make it our lives easier when
data treatment is involved when we want
to process large amount of data when we
want to do a lot of batch processing or
we want to make sure we are using our
resources wisely we tend to use the both
of these three major features of Java 8
to actually make our processing better
now lumber function they've been here
for a while we could use anonymous
functions before we just didn't call it
London but with the new notations in the
new specification it's much easier much
more comfortable to use it actually it's
very similar if you are familiar with
other languages like Python or even Ruby
you could already start getting a
feeling of how a lump the function could
be actually useful for you and do it in
a savage way so a very tight
relationship with Java it's mostly
allowing us to represent high order
functions making our code much more
streamlined much more well understood
from a processing pipeline let's say
standpoint and it's functional Java for
the win so it's all the people from
scholars finger pointing us saying hey
you're not functional enough Java is you
know very verbose and it's slow and we
don't do functional programming actually
this allows Java to be functional for
the win which is very good and the the
simplest way to call a lambda function
will be just map or flat map or
do some some other kind of operation
like that where you're going to have a
list of objects or list of elements from
whatever data source we have we're going
to process it in a functional way where
we're going to determine the pipeline we
operate over that and at the end we can
just store it back into MongoDB now
that's the most ridiculous usage of a
database inside of a lumber function but
that's probably the best or the most
obvious one as well to actually use the
lumber function to process data related
with it we also have this dream API and
the string of pie is where actually we
get to combine these two things in a
very very close relationship and
actually benefit a lot from it they
allow us to specify our pipelines we
have an operation we define a lambda
function is to remind that we find
another one and so on and we can process
it on call being very very lazy in terms
of processing once you get the resources
available then you will actually going
to be processing all that data and to do
that for example the obvious thing is to
get a batch of a file CSV or JSON file
whatever and start reading that file
creating a stream and then processing
that we can start by you know defining
which collection we want to use like
reading all the lines of a CSV file we
will map that file for each line we
receive we'll do some filtering we will
do some skipping you do some internal
processing for each one of the lines you
can change tags to change names can
change the other files all that stuff
and then we at the end we need to after
processing all that information we need
to collect the terminator operator and
send it somewhere now obviously magari
we can be one of those collectors can be
one of those terminators after you
define whatever you have in your CSV
file or whatever text file you have or
even a string from Twitter for example
you can process all that parse it into a
piece on document or JSON object in this
case pass it on to MongoDB and that will
be the collector for you good thing is
that streams are immutable meaning that
you can rely always on the data and you
I don't know if you guys seen yesterday
a talk on streams and spark
that's precisely where we get the
benefit of doing a lot of compound
processing on top of the stream and then
using that over time and reusing it once
we need it so we can pipeline even
streams of data and process streams of
strings of streams so that means that we
can do a lot of different handling on
the data depending on the processing we
need mongrel beyond the equation here
comes as a finalizer or a terminator of
those pipelines because at the end is
where you're going to persist data the
good thing is that you don't need to
terminate your processing there you can
just keep on doing it and chaining up
more streams as you go along so I dumb
example will be to read all those files
get all that data call a range call the
lists and just build documents based on
that there's also the new date API and
the new data API is basically something
that we always what we be new will be
dying for it for a while now who here
does like java de detail at all no one
likes it right so I don't understand it
you usually use it something else to
process your dates the only real thing
it does is give you the timestamp upset
and that's pretty much the only useful
thing that it does and the new data API
actually supports a lot more like say
structure and very well in this in
format which is great now but the new
data API is only available in Java 8
which is okay how can we use it from
MongoDB because MongoDB has its own date
format it's basically UTC format once
you parse some data date format from
Java to MongoDB will be processed into a
specific piece on data type so how can
we handle these new data types that we
handle from the jail from Java natively
intimately well the first thing that you
probably most of you are just guessing
that you don't know is that the Java
driver or all drivers in MongoDB allow
you to implement codex and codex is
basically mapping
structions that if you pass a particular
datatype or a particular attribute with
the particular set of objects in it you
can immediately Kodak that to a format
that it's known to MongoDB like for
example if your process to passing on
attributes of the document that has the
new job data types you can Kodak that
information into a known data that
normally be understands can be a binary
format or can be its negative timestamp
and then we can process back and forth
from the application so you're going to
have your objects your poachers that
will have new date format great you're
going to have data in MongoDB that is
going to be having its own format in the
meantime the one that does all the
conversions and codification
recodification would be the codec
infrastructure that you just can expose
to your driver and it will handle all
that for you you don't need to be
parsing the mid time so the first thing
you need to do is instantiate a codec
and you can use the the manga vapi to do
that it's basically implementing a codec
instant an instant will be the dot new
day the new date format from a job AIDS
you encode that into a be Sun you get a
B songwriter get the value that you want
and just write that date time value to
where puck time for example that's a
conversion that I'm doing picking up the
instance getting the epic time and
writing that into a decent format very
straightforward it's going to be binary
format so we can basically use it again
and again then you need to define your
encoder and once you have your decoder
as well we just need to do the reverse
operation if you're getting a B Sun
object from the database you want to
retrieve it back as an instant you can
get it for free and the operation that
does that implementation is basically
that together everything glued up this
is not just creating this instant codec
you need to register to register it you
need to basically instantiate it you
need to create a codec registry define
the registry rules first of all you need
to get that information instantiate it
register the codec registry so we're
going to tell the driver driver look
every time you find
something like this or in this data type
you will use this particular Kodak will
set it up tell it exactly what we need
to do with a collect driver and it will
register all the different operations
that you need to map then we just need
to pass it along with the MongoDB client
that we can be using so I'm going to be
client is our driver instance basically
we'll it's where all the communications
to be among the video to the server will
pass through you will tell and register
that particular codec on the client
itself and you just use documents as you
normally do with your mom gonna be
instances very very straightforward
every time you insert it he will be
immediately connected to the appropriate
data type that we are using in mon BB
when you get our fine you will parse all
that information for you it's very very
straight for a very linear and you also
can abstract all this and getting your
architects just to build and define the
structure of data that you want to be
stored on in the database and have your
developers using the new Java 8 API no
problem it's very clean for the
developer perspective there's also the
new RX driver which is the reactive
driver and the reactor drivers are
something that is very very now on
demand because we want to do everything
in synchronous or reactive or make sure
that we don't wait for anything that is
happening on your processing we just
want to do as much as possible in CPU as
your server is allowing you to do so the
first thing that we do in the new
reactive x is to implement the pattern
of observable you have a server it's
basically is implemented in simple
interface on next on their own your own
complete he maintains the communication
back to the MongoDB tell tales the
upload tales whatever actions are
happening on the server itself and make
sure you can react to the operations if
you want to try it out and you want to
build some reactive streams as well can
use this driver I recommend you all to
go there and look at it it does
implemented of the observables so it's
it's
the pattern that we are implementing for
this particular implementation it also
can support back pressure so which is
good if something is happening on your
server you don't have enough resources
you will actually allow you to optimize
it processing for it well I only have
two minutes left I just want to sell you
if you want to learn more about how to
use the Codex now to use this
implementation with Java 8 and with
other stuff with MongoDB you can always
join our courses there for free the next
lessons start on the 5th January go till
the 23rd so you can discuss yourself and
do for carnival and do some of the
MongoDB licenses I'm pretty sure it
would be fun i'll be on the key ways of
doing QA session an unofficial dybbuks
QA session among gonna be in the main
hallway there's a whiteboard somewhere
that has this tag on it I'll be there if
you have any other for the questions for
it we also hiring obviously if you want
to join in and say well MongoDB doesn't
do a lot of good support for java and i
can do it better you can always show for
it so apply we are more than happy to
help you on our team and if you have
other further questions or you can
always yeah it's the slide is broken
welcome PowerPoint so you can always tag
along with my Twitter accounts or just
drop me an email and if you want to see
the examples themselves you have the get
up repository thank you so much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>