<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Project Jigsaw: Under The Hood by Mark Reinhold | Coder Coacher - Coaching Coders</title><meta content="Project Jigsaw: Under The Hood by Mark Reinhold - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Project Jigsaw: Under The Hood by Mark Reinhold</b></h2><h5 class="post__date">2016-11-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/fxB9cVNcyZo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good afternoon welcome to project jigsaw
under the hood my name is Marc Reinhold
I work in the Java platform group at
Oracle this is the third of three
presentations my colleague Alan Bateman
and I have given here at devoxx this
week this is the the most advanced one
in this one we're going to take deep
dive into essentially the science of the
module system that we've designed for
Java 9 just a quick poll how many people
were in any of the earlier sessions
including the University on Tuesday
excellent ok so you've all got at least
some idea of what's going on how many
people have downloaded and played with
the highly flamable very dangerous
jigsaw early access builds ok good how
about just the regular JDK 9 early
access build somewhat less dangerous all
right excellent how many people know why
there are not version strings in require
statements ok and what if you can answer
the question when it's fast ok so Java 9
at a glance in Java 9 the main feature
as you know is a module system that
helps us write code that's more reliable
and maintainable we've used the module
system turn the monolithic JDK into the
modular JDK breaking up the old RT jar
file inside the JDK into dozens of
reusable modules that you can configure
as as you please
kept a 9 also has small enhancements to
the Java language and larger
enhancements to the standard libraries
plus new tools and a search box for Java
doc and then the J shell tool which is
really cool by the way and tons of other
stuff which of course I'm not going to
discuss here project jigsaw is a project
led by Oracle in open JDK it's the
container essentially for all of our
work building a model system and
applying that model with module system
to the JDK itself and working on the
tools to support all of this and so on
and so forth we're standardizing the
module system in the Java community
process in jsr 376 we're also
standardizing the structure of the
modular Java SE platform in the JCP
through the umbrella jsr for java SE 9
so when you use java 9 you will always
be subject to the rules of the module
system there is no escape that's what
under the hood that that's what is under
the hood and it's what most of this talk
is about though I'll touch on some
aspects of the modular jdk near the end
this talk has four parts the first part
explains how the module system works
with the java language and the vm to
improve the reliability of code the
second part is about migrating to
modules we've already heard some of that
in the advance to talk the third part
explains why the module what the module
system is fundamentally capable of
beyond what you can express in the java
programming language and the fourth part
is a bit about the road to Java 9 and
some of the things you should watch out
for so part 1 accessibility and
readability
everyone knows the hierarchy the ranks
of accessibility in the java language
and virtual machine it's simple to
understand it's easy to use and it's
strongly enforced by the compiler and
the VM and this is what we've had for 20
odd years now it has a big weakness
however the only way to share code
between packages is with public but then
you're sharing with everyone so it's not
that surprising that packaged friendship
in one form or another has been
requested many times over the years one
principal goal of the module system is
strong encapsulation to allow a
component to declare which if it's
public types are accessible to other
components and which are not in Java 9
the module system has therefore extended
the accessibility model the lines in
italic here are the new levels of
accessibility reading upwards from from
the
lowest italic line up you can arrange
for public types to be accessible only
within their module you can make them
accessible within their module and to
other specific modules by name or you
can make them accessible to everyone now
as usual you know a migration has driven
a lot of the thinking behind this design
we want to make it easy to place an
existing package into a module and
immediately give it the benefit of
strong encapsulation
we don't want each and every public type
in a package to have to opt into strong
encapsulation this is why we haven't
introduced say a module access modifier
that you could sprinkle inside a regular
Java class file to say that it has
marshal scope that would require
changing every all existing code in
order to do it leverage the model system
we so public types in a package are not
accessible outside the module by default
and here's a really important point
public in a type declaration no longer
means that everyone can access the type
ok public in some sense is no longer
public so what happens if someone tries
to access a public type that's not
accessible well here's an example this
is GlassFish 4.1 it doesn't start on jdk
9 because the VM throws and the illegal
access error the error message says if
you read closely class comm dot some
enterprise dot Security dot provider
policy wrapper in module unnamed module
cannot access class send out security
provider dot policy file in module Java
debase don't worry about the unnamed
module part we'll get to that later the
point is that the policy file class is
declared public but since it's a jdk
internal API it's now accessible only
within the java dot based module sorry
GlassFish you've got to go find an
alternative API in Java 9 modules are
first-class program components like the
classes and interfaces here's the
Declaration of the java dot sequel
module that contains JDBC it's in a file
called module info Java in a directory
named
after the module the compiler treats it
like any other Java source file and
translates it into a module info class
file which you can put in a jar file as
normal and the result is what we would
call a modular jar the package hierarchy
exists in the same directory as usual so
module info Java is outside all of the
packages in the module it's the job of
the module declaration in that file to
say whether a package is strongly
encapsulated or not so it's really easy
to get strong encapsulation for a
package you just don't mention it in the
module declaration to allow other
modules to access a package or it more
specifically to access the public types
of a package you add an exports clause
as shown here you can export to all
other modules or you can say exports to
a specific specific set of modules by
name to give access only to your friend
modules now compile time Java C prevents
code outside of the Java sequel module
from accessing the public types of any
packages except for those three listed
here you get the same compile time error
as when you try to access a package
private type from outside its package in
Java 8 and at runtime this is all about
for the fidelity at runtime the VM
throws and illegal access error as we
should saw with the GlassFish example a
moment ago alright let's dive into the
VM more deeply traditionally
accessibility in the Java platform is
about who is doing the accessing and
what is the public protected private
flag on the target class at runtime the
VM uses the class loader of the
accessing class to find and load the
target class and then the VM checks the
flags on the target class this is what
we've been doing for 20 years because
the VM relies on class loaders people
can create class loaders that only know
how to find and load classes of certain
packages in effect loaders can isolate
one package from another in the top
picture here class P dot C is trying to
access class QD the loader for p dot c
knows how to delegate to another loader
for
any class in package Q such as QD only
when that loader other loader loader has
loaded QD and the VM then check its
flags to determine if PC can access it
in the bottom picture the loader for P
dot C has no idea where to find package
Q so no access to Q dot d is possible
from P dot C now technically this is not
a failure of accessibility because the
VM never even gets the chance to check
the flags of QD instead it's a failure
of visibility QD is invisible to P dot C
still the effect is quite powerful and
useful if the class loader of the
accessing class can't find that load the
target class then it doesn't matter if
the target class is public or not it's
effectively encapsulated whoever sets up
the class loaders sets up the
encapsulation encapsulation based on
class loaders however is not strong
encapsulation
hence the sadface here it relies upon
packages being carefully apportioned in
two different loaders but that isn't how
the JDK works most code in the JDK is
loaded by what's called the bootstrap
class loader
well code on the class path is loaded by
the application class loader spending up
lots of loaders for all of this code if
we were to have one loader for every
module in the JDK would be a
compatibility nightmare and in any case
there's no actual isolation you can
circumvent class loaders by getting hold
of reference to Java line class objects
once you have a class object class
loaders are completely irrelevant and
it's impossible to stop references to
class objects from being passed around
strong encapsulation is about being able
to prevent access even if the accessing
class and the target class are in the
same class loader and even if someone is
using core reflection to manipulate
class objects let's assume that multiple
modules are somehow mapped to the same
class loader in class PC and module X
access class QD in module Y
recall that another goal the other
principle goal of the module system is
reliable configuration to replace the
brittle error-prone classpath mechanism
with a means for program components to
declare explicit dependences upon each
other so in order for PC to access QD
not only does module Y need to export
package Q but module X needs to
explicitly depend on the module Y the
formal name for depends on when we think
about it this way is readability
readability underpins accessibility in
the Java language nvm the accessing
class P dot C must be in a module that
reads the module of the target class
module is y and the module containing
the target class namely Y must export
its package Q to at least the module of
the accessing class that may be - all
modules in the system you can see that
accessibility is essentially a two-way
street X reads Y and Y exports package Q
to at least X accessibility is
independent of class letters just as
before the module system this is
important for two reasons first it means
accessibility works at compile time when
there aren't any class loaders second
that means you can reason about
accessibility based solely on requires
and exports clauses in module info Java
files there's no need to worry about the
class loaders in existence at runtime
how they how they were configured by
code that you might not even know about
in fact the exports part of
accessibility is pretty straightforward
the packages of is either exported or it
isn't but on readability there's a bit
more to say when you depend on a module
you depend on a hopefully coherent
collection of packages that it exports
in some sense those packages are kind of
the in some abstract interface of the
module inside the module hundreds more
packages might sit strongly encapsulated
waiting to help implement that interface
and more than that when you depend on a
module you indirectly depend on all of
the modules it depends
for example if you depend on the Java
activation module with its 35 classes
then you also depend on the Java desktop
module with its guess what five thousand
eight hundred and thirty five classes if
the watchword for Java eight was
functional
then for Java nine the watchword is
transitive
you should think in terms of the set of
modules needed transitively by your
application the indirect dependences can
be as important as the direct ones let's
see how readability handles this I'll
use an example of readability from the
actual graph of jdk modules the java dot
sequel module that holds JDBC requires
the java dot logging module that exports
the packaged Java util dot logging
everyone's favorite logging API this
lets code in the Java sequal module
access the public types of Java util
Logging's such as the logger class you
can see that in some code in the drug
JDBC driver manager is here newing up an
instance of logger what if the api of
the java sequel module rather than just
its implementation wants to use the
logger type for example the JDBC driver
interface wants to return a logger with
this ghent parent logger method let's
look at this through the eyes of an
application module that uses JDBC will
creatively call it Maya
in order to use the driver method that
returns a logger the my app modules not
only needs to read the java dot sequel
module but also the java dot logging
module which exports logger it would be
a pain if the developer of my app had to
remember to say requires java logging
when using the api of java sequel it's
the frowny-face well there's good news
the Java sequel module can take on the
responsibility of remembering look at
the Java sequel module it now says
requires transitive Java dot logging the
word transitive here means that anyone
who reads the java dot sequel module
also reads the java dot logging module
for free
the Myatt module doesn't have to bother
with requires java logging because it
reads java logging thanks to reading
javis equal happy face this isn't call
it this is called implied readability
and it's very powerful it's powerful
because it lets a module be refactored
without breaking its consumers
refactoring modules is an important
going to be as important the thing as
refactoring classes for example suppose
that Java logging has some auxiliary
packages that we'd like to start
shipping in a separate module say log
extras the Java logging module can say
require transitive log extras so that my
app which implicitly reads Java dot dot
logging also now implicitly reads log
extras my app would be completely
oblivious to the fact that this has
happening in essence the readability
model supports a form of downward
decomposition any module you read can be
decomposed into new modules and
readability of the new modules can be
recovered with the requires transitive
clause in the old module so if you think
about it the definition of reads must be
recursive write a module X reads another
module Y by requiring it directly or by
reading some third module Q there's the
recursion where Q says requires
transitive Y and now that X reads y Y
can say requires transitive for some
other module and X will read that too
now
some care is required here once people
require your module explicitly you can
refactor it as much as you like but you
cannot delete it there's no way for a
module to stand in for another by taking
its name as an alias if someone requires
X and X is deleted then the module
system will not start a related point is
is you cannot ever effectively remove a
requires transitive unless you absorb
that other module completely into yours
the use of requires transitive is
essentially you essentially expands the
surface area of the effective api of
your module I said earlier that this
exports parts of accessibility is pretty
straightforward the package is either
exported or it's not well it's a little
more subtle than that it turns out here
are some of the exports of the Java base
mod
exporting a package means that anyone
can compile and run against its public
types there are dozens more packages in
Java to base that are not exported no
one can compile against their public
types even if you make a class file by
hand that refers to a public type in a
non exported package it won't run
but that's accessibility in the Java
language and VM were the accessing class
and the target class are known as
statically what about accessibility with
reflection where the target class is
only known dynamically we think it's
very important that exporting a package
such as Java dot security for static
access does not mean that anyone can
reflect over the internals of that
package because history has shown that
if they can they will here's a stack
overflow question from July of 2016
someone was using set accessible to
access a private field in the class Java
dot security dot keystore the purpose of
this class is and I quote a storage
facility for cryptographic keys and
certificates if ever there was a class
whose private fields should be
inaccessible this is probably the one
the Java security package is exported so
you can code against the public type key
store not so that you can reflect over
key stores internals so just exporting a
package does not allow reflection to
access the non-public elements of the
package public elements no problem
non-public and if you obtain a class
object for a non public type in the
package you can still list its members
but you cannot called get or set on its
java.lang reflective field objects even
for a public field nor can you invoke
call invoke on its java.lang reflect
method objects even if a method is
public similarly if you obtain a
java.lang reflect field object for a
private field in a public type you
cannot call get or set on it even
calling set accessible will not help if
the author of a module really wants to
allow access to
non-public elements via reflection this
can be expressed with a second directive
and that's called opens you can open up
a open packages one by one as shown here
or you can open an entire module by
putting the open-toe using open as a
modifier on the mat the module keyword
itself this allows reflection to work as
it did in Java eight private members of
public types can be accessed and public
members of of private members of public
types can be accessed and as well as
even private members of non-public types
we don't officially call this weak
encapsulation but you can think of it
that way the bottom outline here is that
strong encapsulation is even stronger
than the powerful reflection
capabilities traditionally offered in
the Java platform it's up to the module
author to choose strong encapsulation
and if they do there's no way for
another module to break in the module
system API does not allow one module to
augment the exports of another module
reflectively a module can only exports
its own packages via the API so that's
accessibility and readability
accessibility used to be a simple check
for public or same package in Java 9
accessibility strongly encapsulate
smaadahl internals accessibility relies
on readability which can be direct or
implied and good point accessibility is
forced by the compiler by the virtual
machine and by the reflection API part
two different kinds of modules
everything so far has been about named
modules modules explicitly declared with
a name in a module infant up Java file
now what about jar files on the clasp at
that don't have a module invoke class
file they seem to be often some weird
world of their own to keep the model of
accessibility and readability consistent
we introduced a concept of an unlined of
the unnamed module all classes not in
named modules are in the unnamed module
it's as if everything on the class path
is in one big happy module because it's
a module we can ask two questions what
does it read and what does it export
what it reads is very simple it reads
every named module all of them as if by
magic for free this means anything
exported by a named module can be
accessed by the unnamed module you can
turn a jar file into a named module by
adding a module in for that class and
putting the jar on the module path where
named modules are found jars left on the
class path will not realize that
anything happened that's a big help
for migration the next question is will
what does the unnamed module export
before that that we should ask who reads
the unnamed module remember our goal in
the module system is reliable
configuration we believe very strongly
the named modules should not read the
unnamed module out of the box it would
make a complete mockery of reliable
configuration to let named modules
depend on the arbitrary chaotic content
of the class path so you cannot write
something like requires unnamed or
requires class path in a module infinite
Java file there are no reads edges going
out to the unnamed module of course
there is this is a huge hindrance for
migration because any jar you turn into
a named module can't access the other
jars that are left on the class path the
solution to that problem is automatic
modules you can take a jar say guava jar
and now move it from the class path to
the module path this turns the jar into
an automatic module that's all you have
to do you certainly don't change the
contents of that jar file an automatic
module is named
is a named module declared implicitly
rather than explicitly its names drive
from the jar file named in a very
obvious way
placing guava jar and the module path
will get you a automatic module called
guava
oddly enough as before whenever you see
a module you should ask what does it
read what does it export the automatic
module guava reads everything in the JDK
and the unnamed module it's as if it
says requires unnamed now the hindrance
to migration is gone you can turn a jar
into an automatic module and act and
still access the jars left on the class
path we asked earlier with the unnamed
module exports the answer is all of its
packages in j-unit jar and GlassFish jar
and hibernate jar precisely to help code
that's been moved up to automatic
modules which need to read the unnamed
module because an automatic module is a
real named module another named module
can require it suppose the my app module
says requires guava so there's a read
reads edge from my up to guava what does
an automatic automatic module like guava
export that's easy all of its packages
so my app can access all of the public
guava types my app could even say
requires transitive guava in order to
transmit its dependency on guava up to
its own consumers so anyone who reads my
app would read guava for free so by
moving a jar from the class path to the
module path you get an automatic module
that lets you start building up your own
graph of modules it's not necessary to
wait for every jar in the class path to
be modularized by its author might be
somebody completely different
before you start developing modules that
require it so there are three kinds of
modules we have explicit named modules
such as duck Java dot sequel we have
automatic named modules such as guava
and we have the unnamed module which is
where everything from the class path
goes and between all these different
kinds of modules there's lots of
readability inserted by the module
system for
free to help with migration part three
loaders and layers I said before that
strong encapsulation is independent of
class loaders this means that the model
of class voting in Java nine is
unchanged the mechanism of loader
constraints is unchanged the notion of
runtime packages is unchanged the
java.lang class loader api is
essentially unchanged so in case you
haven't got the message class loading
doesn't change in addition the actual
class loaders in jdk nine are unchanged
from JDK 8 we have the bootstrap loader
we have the platform loader formerly
known as the extension loader and the
application loader sometimes called the
system loader traditionally the vast
majority of JDK classes were defined by
the bootstrap loader critical JDK
modules such as Java dot base still have
their classes loaded by that loader for
non-critical modules however it's
important for security to move their
classes out of the bootstrap loader
modules in the bootstrap loader run with
all permissions which is not ideal from
a security perspective they can only be
deep privileged that is run with fewer
permissions if they're not in the
bootstrap loader
therefore in JDK 9 all the modules
containing Java EE technologies such as
Java 2 korba have been moved as well as
the JDBC modules droplet sequel and Java
sequel rosette their classes are now
loaded by the platform loader frankly
moving a module as big as Java korba
1831 classes and 31 exported packages is
no small accomplishments this deep
privilege Aquila continued for other
models for a few years yet the
application loader is responsible for
everything else a number of jdk tool
modules such as jdk the compiler have
their classes defined by the application
loader all classes and modules on the
module path whether they're in a modular
jar or in in an automatic module like
guava from before are also defined by
the application
and finally all classes on the class
path in traditional jar files such as
j-unit jar and GlassFish jar in our
example are loaded by the application
loader a couple of notes on
compatibility first frameworks that
delegate directly to the bootstrap
loader to find JDK classes might break
on JDK 9 because many JDK classes aren't
there anymore Frank framework should use
the new class loader method to get
platform class loader which returns a
loader guaranteed to provide visibility
of exported JDK classes second the
application loader is no longer an
instance of URL class loader
this was never mandated by the
specification but it was true in
practice some frameworks assume that it
is in order to hack into its URL at its
add URL method and these break on jdk 9
some of them have already been fixed the
only supported way to dynamically extend
the class path is with the class path
attribute in jar files or with the agent
API and java.lang instrument now you
might be wondering where the module
system itself fits into this class
floating story before I answer that
though it's important to realize where
the module system isn't module systems
that have been built for the Java
platform so far are well they're
basically sophisticated ways to build
networks of class loaders they create
loaders that define classes found in
modular artifacts and the loaders
delegate to each other in accordance to
some kind of modular imports and exports
as I mentioned before there's some
encapsulation for classes because the
loaders can hide classes from each other
but it's sort of its kind of weak
encapsulation it's not all that strong a
module system that works in this way
will still run on JDK 9 because class
loading hasn't changed this is one of
one of the big reasons why class living
why we tried really hard not to change
class loading
however the module system in JDK 9 is
quite different the module system in JDK
9 and Java 9 is not a factory for class
loaders but rather a conduit that allows
modules to be communicated
to the virtual machine whoever creates
the class loaders is responsible for
using the module system API to transmit
module names and contents and
dependences and exports to the vm that's
how the VM knows enough to enforce
accessibility it's also how the core
reflection API can enforce accessibility
since it's based upon the VM provided
class objects you can think of the Java
launcher as creating three loaders and
doing the transmission for modules on
the class path now you can see why we
wanted the module system to be
disinterested in class loaders the jdk p
has been factored into dozens of modules
but its class loading architecture has
not changed encapsulation is provided by
true beyond level accessibility not by
class loader based visibility so the
module system doesn't need to mandate
one loader per module it can handle
multiple modules per loader just fine
you'll recall I talked earlier about the
unnamed module as a vehicle for
compatibility strictly speaking I was
referring to the unnamed module of the
application class loader in fact every
loader has its own unique unnamed module
if the BMC is a class being defined by
loader and the VM can't associate at
that class with a named module that was
transmitted earlier then the VM treats
the classes being in the loaders unnamed
module as you might guess the VM always
allows access to public classes in one
of these unnamed modules this all means
that if every class is a member of a mod
that it sorry this all means that every
class is a member of a module even
classes in the jar files on the class
path j-unit jar and class fish are our
members of a module the seventh blue box
sorry seven blue locks in the VM on the
right and the blue box didn't make it
sorry if you have a class object the get
module method will always return a
module object is the main point
the module system introduces the concept
of a lair to associate loaders with
module a layers of family of class
loaders that serve together to load
classes for a graph of modules logically
the Java launcher defines the boot layer
consisting of the three familiar loaders
shown here
it's the boot layer that associates the
Java base and drop it out logging
modules with the bootstrap loader Java
dot sequel and Java korba with the
platform loader and so on a layer is
created from two things a graph of
modules and a function that map's
modules to loaders
layers layers are in fact quite
lightweight on the left is the graph
from resolving the jdk j-link module
which contains the j-link tool for
building runtime jdk images on the right
is a lambda expression mapping modules
to the bootstrap loader and the
application loader creating a layer
informs the module system about about
the packages that will exist in the
program and the modules they'll come
from the model system passes this
information to the VM so that when
classes are eventually loaded the VM
knows which module a class belongs to
and what that module reads and exports
it's like the VM has kind of a shadow
copy of the module graph that it uses
when checking accessibility between
classes because of how class voting
works the module system must enforce
certain constraints on a layers module
graph and on the layers mapping from
modules to loaders let's talk about the
graph first this is the graph of
standard modules in JDK 9 what what do
you notice about this graph it has a key
property anyone no cycles bingo there
are no cycles this is the first and
biggest constraint on a module graph
it's taken almost a decade to untangle
the tens of thousands of classes in the
JDK to the a cyclic and relatively sane
state you see here and after all that
work we would like to keep it that way
in fact one of the motivations for men
vesting in module Ares modularization of
a code base is the knowledge that once
complete
there won't be any backsliding into the
ball of mud that cyclic dependences
allow we are not the only people who
think this java application architecture
is an outstanding book about modularity
highly recommended in a section titled
cyclic dependencies the death-knell
it says excessive dependences
dependencies are bad but cyclic
dependencies are especially bad the book
goes on to say generally speaking cycles
are always bad
however some cycles are worse than
others cycles among classes are
tolerable assuming they don't cause
cycles among the packages or modules
containing them cycles among packages
may also be tolerable assuming they
don't cause cycles among the modules
containing them module relationships
must never be cyclic so that's very
clear right let's turn to the other
constraint on module graphs the second
constraint on the module graph is that a
module must read only one module that
exports a package called P if a module
could read more than one module that
exports P and X as as X is trying to do
here in which module would be be
accessed there is no answer the module
graph is just broken so we defend
against that only marva graphs which
obey this constraint and have no cycles
can be turned into a layer this is
really what we mean in essence by
reliable configuration configuration is
reliable when a module can access only
one version of a package at a time there
are no split packages such as you get
when multiple jars on the classpath
contain potentially different versions
of the same package now you might wonder
if it's possible for X to read version 1
of while at the same time another module
reads version 2 of Y after all X and the
other module would each read only one
module exporting P the answer is that
it's not possible because it can only
work safely in certain scenarios and
outside of those scenarios it's far from
clear that's supporting it out of the
box is worth the complexity
recall that a layer includes a module
graph for which we saw two constraints
and a mapping from modules to loaders
the main constraint on the mapping is
that if different modules in the graph
of a class called C then those modules
must be mapped to different loaders this
is due to a fundamental limit in class
living a class loading can only create
one class called C more conservatively
we say that if different modules have
the same package not just class then
those modules must be mapped to
different loaders the mapping from
modules two loaders has another
constraint that's not practical to check
because it concerns how the loaders
behave at runtime
it's that loaders must delegate to each
other in accordance with the reads edges
in the model graph now the reason for
this is is obvious if module X reads
module Y then in order for X's classes
in one loader to access Y's classes in
another loader X's loader must have
enough information to know to delegate
to Y's loader as their name suggests
layers can be layered like pancakes or
waffles when a graph of modules is
resolved it's actually resolved against
a parent layer in fact you can you can
now edit me with a recent change you can
have it can have more than one parent
thus that then when the graph when the
graph helps to create a new layer the
new layer picks up the parent layer this
allows a graph of module to have what
are almost dangling references that is
requires clauses for modules that the
module system will find an apparent
layer during resolution now on the left
here resolution has set up not only a
reads edge between modules in one layer
but also a reads edge between modules in
different layers constructing a tree of
layers in this fashion is the job of a
framework such as an app server or test
harness layers give frameworks
tremendous freedom to organize modules
at runtime without upsetting the
frameworks traditional use of class
loaders it's it's a lot like the
invokedynamic structure in instruction
in Java 7 it's a way for framework
developers to in
with the VM and a fairly intimate basis
to reify information about the shape of
the program let's look at one scenario
where layers help out layers are how the
module system supports multiple versions
of a module here an app server has
created two layers on top of the boot
layer on the Left the Hadoop layer
reifies a model graphed with guava
version 11 and Jackson version 1 on the
right the JavaScript layer reifies am
autographed with guava version 18 and
Jackson version 2 each module graph is
well formed and mapped to loaders in a
sensible way but the modules in the
Hadoop layer are not aware of the
modules in the JavaScript layer and
vice-versa but note this is all thanks
to a framework creating the Hadoop and
JavaScript layers in the first place the
Java launcher does not create layers
such as this all it does is resolve the
modules you give on command line then
not everything into the in the resulting
model graphed of the application loader
in the boot layer it supports only one
version of each module the reason for
that is to avoid the nightmarish
problems that occur when multiple
versions of a module casually come into
contact with each other it's really only
safe to use multiple versions of a
module when a framework such as some app
server is in control the takeaway is
this just as modules or wrap-up coherent
sets of packages and interact with the
VMS accessibility mechanism layers wrap
up coherent sets of modules and interact
with the class loader visibility
mechanism it will be up to framework
frameworks to make use of layers in the
next 20 years
just as they made use of class loaders
in the first 20 years so that was a deep
dive into loaders and layers modules do
a better job of encapsulation than class
loaders but class loaders are still
around they're still very necessary
layers control the relationship between
modules and loaders assuming the class
loaders respect the module graph a
system that you build is safe by
construction there will not be cycles
there will not be split packages
now assuming all the way out here are
three key points the module system
provides strong encapsulation of modules
by the compiler the virtual machine and
core reflection unnamed an automatic
modules help with migration and the
system is safe by construction as I just
said in essence the module system is a
seat belt it's not a jet pack
if this reminds you of the rationale for
generics well you're right writing a
module declaration makes your code more
reliable and maintainable much as
writing lists of string is it makes your
code more maintainable than simply
writing lists you always knew that your
list held strings and generics let you
say that you always knew that a package
was not for general use and modules let
you say that it's no coincidence that
designing a practical module system and
modernizing the JDK has taken
approximately as long as designing the
generic type system and genera fine the
JDK part for the road ahead
it's it's still quite long although the
module system is conceptually simple
there are changes in Java 9 that
probably won't break user code but might
break framework code I'd like to go
through them quickly there are three
areas of incompatibility in in JDK 9
connected with the initial definition of
the Java SE platform first we've removed
six methods from Java util logging and
Java util jar the first time ever we've
actually removed things the signatures
of these methods made the Java base
module depend on the Java desktop module
and nobody wants that this removal was
announced in the umbrella jsr for Java
SE 8 in 2014
yes this has been a very long-term
project in addition we've removed two
AWT packages that were never supported
despite the fact that they were in the
Java dot star namespace second the Java
EE type shipped with a JDK are not
accessible by default don't worry there
there
this means Corbitt Jack's be jax-ws the
job activation framework in the
a subsets of the Java transaction API in
the common annotation API are not
accessible by default the types are
physically in the JDK image but their
modules are not read by the unnamed
module if you're writing a module no
problem you just require Java doc korva
or Java XML bind or whatever but if
you're running code from the class path
you need to use a command line flag to
activate EE modules now this this is not
meant with any hostility towards Java EE
technologies in fact that we chose to do
this to make it easier to interoperate
with existing copies of those
technologies many of which are not
actually in the JDK third and finally
the version strings reported by system
properties have changed code that looks
for one dot the beginning of the string
will fail on JDK 9 sorry there are
threes three areas of incompatibility
within the JDK implementation first
we've slimmed down the son Mis package
some misc unsafe is still accessible but
son misc base64 encoded in base64
decoder are gone one thing you can do
today is run the Jade EPS tool that came
in JDK 8 over all of your jars there's
actually a better version of Jade EPS in
in JDK 9 early access builds it will
tell you if they're using unofficial
classes such as some misc base64-encoded
and then recommend supported
replacements such as Java util dot
base64 an API introduced back in Java 8
second almost all JDK internal api's are
not exported code that tries to access
types in the sun net WW package or sun
dot security x.509 or conduct sun org
dot Apaches xerxes dot internal Jack's P
I could go on and on about this will
fail with an illegal access error the
only way to regain access is with a
command line flag at least it's possible
third many internal aspects of the JDK
have been overhauled such as the layout
on disk and the implementations of its
class loaders code that assumes there's
a file called RTR or tools jar and in
particular in a particular directory
will fail because those files no longer
exist
scripts that try to patch the JDK with -
ex boot classpath /p will fail on jdk 9
because that flag is no longer supported
and as I mentioned before code that
assumes the application loader is a URL
class loader or the suit of it assumes
all JDK classes are defined by the
bootstrap loader will fail on JDK 9 the
model system tries very hard to support
migration but it takes only one
unmaintained library to prevent my
migration to JDK 9 if that library
cannot migrate nor can anything on the
sorry if that library can't migrate then
neither can anything on top of it in
this regard modules are unusual they
suffer from a tragedy of the Commons
kind of problem whereas most big
features like generics or lambdas let
people opt in at their own pace without
needing to wait for others so preparing
for JDK 9 the single best thing you can
do is fire up JDK 8 and run their
jaidev's tool which analyzed analyzes
dependences actually the single best
thing you can do is run Jade EPS from a
JDK 9 early access build but if you
happen to have eight already that
that'll be the second best thing it can
tell you if your code or the code riu
rely on will be affected by changes
changes in JDK 9 please try the EA
binaries on JDK 9 java.net
the module system has been present and
active in these binaries since March of
2016 plus sorry everything you ever
wanted to know about the module system
is discussed in jet 261 I can't
emphasize enough how much by the
valuable information is in that jab
there's also JEP 260 which the fun
defines the JDK internal classes exposed
in JDK 9 there are still a few of them
Sun was gun safe and Jeb 223 which
defines the new version strings
beginning with 9 and jump to 20 which
describes how our TBR has gone away and
what it has been replaced with finally
Jeff 200 gives an overview of the JDK
modules but if you've already read Jeff
261 there won't be any surprises so
there are direct links to all of these
jets from the jigsaw project page shown
there
I work for Oracle don't believe a word I
say thank you very much we have about 12
minutes for questions there's a
microphone up there on the stand
please use that or if you like you could
you could tweet at me and I'll read
questions off of Twitter any questions
and our questions one yes in this
dependency graph it seems that
everything a lots of things have a
dependency on this java logging module
why is that it's just is that just a
transitive dependency good question let
me roll back show navigator to the graph
where's the graph in that graph there
are two types of edges I will find it
somewhere ok sorry I only pop out of
this there it is
okay in this graph there are two kinds
of edges well sorry their highlights are
three the solid edges are represented
requires transitive
so they transmit the API to to the
consumer the - edges are merely for
implementation so Java if you look at
the API Java dot security about sazzle
you won't see any logging types in its
API so it's a dashed edge most of the
edges going into Java dot logging are
dashed the ones that are solid represent
uses of the Java logging api in the api
of the of the upper module so firstly in
in in many cases the use of Java dot
logging is just an implementation detail
in other cases it's it's essentially
using the API and expecting the consumer
to use the API Java 9 has been postponed
several times already actually not not
strictly right to the jigsaw but how
likely is it from your point of view
that the current schedule will actually
stay I'd say the probability is it's
it's it's somewhere between zero and
100% you know hey I I could rant about
estimation in software projects it's you
know it's just fundamentally impossible
hey it's an impossible thing you you
make an estimate you did the best you
can and if you wind up needing more time
to do the right thing then you take more
time you know we're we're we're not
going to to saddle the ecosystem with
something that's broken just in order to
hit some arbitrary deadline that would
be stupid
it's not the question more explanation
you're under the impression the opens
key word needed a bit more explanation
do you have a specific question I could
answer just know I mean just how
how it works what it does how can you
open another module well opening is not
about opening another module it's about
it you can only you can only a module
can can only open itself right you can
open a particular a specific package or
a set of specific packages or you can
open the entire module which opens all
of its packages and all that open means
is you when a package is open that means
that at runtime all of its public types
are accessible and all of its non-public
types are also accessible if code using
reflection to get to them goes to the
trouble of invoking the set accessible
method that's what open means right then
I was I was talking about the opens
keyword use public opens right okay so I
can I can open every package in a module
by writing open module module name and
then curly braces and stuff right if I
don't write that than in a normal strong
module maybe I have five packages I
export 12 packages that are completely
internal when I don't export and then
one package that contains POJO classes
for hibernates gonna play with right I
can I can say opens just that package
does that make sense
no but nevermind okay sorry feel free to
come down later this is probably just
some simple music miscommunication thing
have a bit of an abuse question a bit of
an abuse question yes is that about Joff
abuse I tend to notice it my work that a
lot of like code I rely on is not
expressly explicitly written as a
library are we see now so basically what
people do is they make everything
private and only things that they happen
to use themselves they make public
somewhere because they need some well I
kind of proceed that the same thing is
going to happen with the modules and I
was wondering what your thoughts are on
it
so it sounds like you're worried that
that that if the author a module is lazy
they'll just decide oh I'm just gonna
export everything and open everything I
don't have time to think about this well
actually the other part around the
people only open up stuff they need
themselves in other packages or
something within their module okay well
well it sounds like they're being
perfectly sensible what's the problem
the problem is that they might not think
enough about public API and therefore
not go through enough links to problems
then they need to be educated right so
so there's definitely a there's
definitely a shift here the module
system gives module authors of both
power and responsibility as we say right
you have that you have the power to
strongly encapsulate internals but
because the module system enforces you
know strong encapsulation it's
essentially impossible for ordinary code
operating in ordinary ways to break into
that so if you're the author of the
module you have you now you have more
motivation to think carefully about what
your API is and what your API isn't and
if you get it wrong your users will be
unhappy and hopefully they'll you know
fire up file bugs or submit patches or
pull requests or whatever to help you
out but ultimately if something's broken
in that way that's not something that
they can fix by you know just fussing
with with the jar file or something so
people wait you know we all we at the
end of the day you just have to hope
that people will do the right thing once
once they're educated and sometimes that
assumption turns out not to be true what
impact do you see on unit tests and
frameworks you know common unit test
pattern being you put the test class in
the same package as the tested class
deprecating access to you know packaged
and protected members and otherwise to
unit unit frameworks that do have all
kinds of nasty stuff ya know they're
they're more mature master
mechanisms to handle handle all about
there's command line flag that will let
you essentially patch the content of a
module you can insert stuff in and you
know the our our own JT reg unit test
framework uses that already you know we
we we've had some discussions with other
other test framework authors and you
know they know about that and they're
thinking about hopefully they'll upgrade
to use that so yeah
all the usual testing scenarios
hopefully we we've tried to think
through if we've missed one please let
us know okay a quick question on Twitter
someone very observant wondered why is
there jdk HTTP server in that module
graph well it's because we are honest
okay this this model graph is the say
that the same graph I should I showed in
the keynote you might notice it's not as
pretty as ones I've shown in the past
the reason for that is that it's
mechanically generated when you do a JDK
9 build you get anything amongst the
many things you get there's a directory
full of dot files that define that show
the graphical structure of logical
subsets of the platform this this is the
dot file rendered into a ping of all of
the standard modules and jdk HTTP server
is you know just happens to be an
implementation dependence of Java dot
XML dot WS all of the other modules
would would show up if we started
showing the JDK modules themselves they
don't show up here because for the most
part they're related through the service
mechanism which is something that would
be an entire another talk to explain but
maybe maybe next year I'll do that talk
all right two minutes 30 seconds go
hopefully quick question is open for
introspection the same as open for the
debugger is open for introspection the
same as open for the debugger no because
if you're a debugger you can already get
into everything right that's that's like
neo with the one big loophole through
which you can drive a truck
intentionally is if you're using a
debugger well you should be able to poke
into anything because well that's what
the buggers do so of course you can
clear
question on Twitter why not recursive
package exports I don't even know what a
recursive package export would be is
there another quick question I mean if
you ask that question feel free to come
down and ask me don't apply to protected
packages why do the visibility rules not
apart slides you showed but the public
will be impacted by vague sports the
same rule apply to export protected the
protected access mode is its own sea of
despair the the complexity required to
explain the protected access mode in
both the JLS and and the VM spec is
basically whenever I talk to Alex buckle
you maintains those specs whenever I
talk to him about this he just like its
total sad face because it's hideously
complex and for that reason I just don't
talk about it in in the in these talks
that you the III could do a whole nother
talk on unprotected and how that works
with accessibility we've tried to work
it out as logically as we can but maybe
we got it wrong if we did let us know
and time is up thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>