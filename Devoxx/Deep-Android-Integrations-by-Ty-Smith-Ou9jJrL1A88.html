<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Deep Android Integrations by Ty Smith | Coder Coacher - Coaching Coders</title><meta content="Deep Android Integrations by Ty Smith - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Deep Android Integrations by Ty Smith</b></h2><h5 class="post__date">2017-04-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Ou9jJrL1A88" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">for a lot of you that aren't really
familiar with what the developer
platform arm of these companies does it
mostly focuses on the external API and
the developer tooling and the outreach
and the partner integration sometimes
and sometimes product focus SDKs and
oftentimes helping a lot with the open
source work that's going on and I want
to talk to a bit about today about some
of the features and experiences I've had
at these different companies and what
they've kind of taught me about building
out these platforms on on mobile and
android specifically and then hopefully
those learners will help you guys figure
out when a better understanding when
you're integrating against these or
provide some guidance when you're
wanting to build your own platforms so a
traditional approach on mobile may look
pretty similar to this you have your web
service running in the cloud and you
have a bunch of different devices and on
each device you may have a bunch of
different apps in each one of them
bundles in SDK or a library that
connects up to your service they have
duplicate data potentially it's coming
down if you're caching data they might
be making similar Network requests
there's duplicate code across the
devices these are all sandbox
individually I think a more interesting
approach on Android is when you start to
treat like the proprietary main
application as a provider of some of
that data or some of those interesting
use cases much like the web service is
treated in the previous example so I'll
walk you through a few examples in some
projects where I've built out some
similar stuff to this where you have one
app you know the Evernote app the oberon
some things with with Twitter and fabric
where that became the provider of these
use cases and other apps on the device
talk to it instead a recent project that
I worked on and excuse the crappy video
capturing video on Android is what's not
treating knew all this day but a recent
project that I worked on was adding and
rewriting some of the deeply
code in the rewrite of the uber app and
for those of you not super familiar with
like deep linking specifically it's a
pretty general term that's used in
mobile just to kind of define the
escapes of using an uri just a standard
web you are i did a napkin handle in
this case this one that we're going to
be talking about is the user clicking on
a deep link and initiating a ride
request for them from a pick up to a
destination spot and potentially adding
in some details for the ride like the
type of card that they want the URI
itself is just kind of a quick overview
it's just using the standard scheme
where where we have the scheme that
defines what the app is registered to
handle potentially an authority in this
case we're using ride requests to
indicate the action that we want to
perform and then we don't really have
any need for a path on this one but
we're using the query parameter to
indicate a bunch of this additional data
it's going to be coming across like the
pickup Latin long there's quite a number
of other quite a number of them and
they're documented on our dev site but
for this example it's all that's really
necessary to talk about and then an
Android in the graph itself we register
to handle that deep link in our manifest
now what's interesting in this case is
you could just use the scheme here with
uber to handle all incoming uber schemed
you our eyes but I'd recommend being a
little more explicit so that you're not
capturing everything that can possibly
be handled in this one example here
we're using ride request activity and so
we've explicitly set the authority that
we're looking for the you are to be
write request so this specific intent
filter wouldn't necessarily capture
other uber schemed you are eyes that are
intended for other other actions to be
handled now this this isn't the actual
implementation and the uber app we
actually do have one specific scheme and
then we're kind of route those out but
if your app is not single activity then
I'd recommends thinking about how to
limit the scoping but since steep links
are kind of this general
term that's used across because mobile
in general and the web its more common
to think of them it's just like a
standard HTTP link that the application
can handle and that the same data can be
provided using an HTTP link that that
Android is registered to handle so this
is where you get the concept of
universal links but what I think is
interesting in handling these is what
happens when the application is not
installed on the device and because
we're using a standard HTTP URL if the
app is not installed the system is going
to take the user to to your website
right that just HTTP link that we had to
lift in the previous example and a
common way that this is done in the
industry if you're looking at some of
the third party providers like branch or
cut some implementations is you'll have
your site that they're heading use the
devices user agent and some of the web
api is to create a fingerprint for the
device and then they're going to Ford
that device in the browser on to
redirect URI that's the Play Store force
on iOS it's going to go to the App Store
but it's going to include a refer query
parameter with some sort of identifiers
so this if you were using something for
affiliation like branch or tune that
might be a unique ID that you can access
later to get the deep link that
originally started it to continue to
flow if you wanted to do a custom
implementation you could just URL encode
the original deep link that the user
fired to come in here but in this case
after we go to the Play Store and we
provide that information in the refer
parameter ideally the customer install
the application and then when it's
launched the Play Store is going to emit
broadcast to your app so if you're
registered to handle that broadcast then
you can get the information about the
refer that installed the application
that's the install refer broadcast once
we have that we can look at the intent
look at the value for that refer
parameter and if that was just a
URL encoded deep link to start it then
you could immediately act on that and so
the user going from clicking the link to
install to opening would continue to
flow that they originally started by
clicking it now if it was something like
a unique ID that was being used with
with tune or with branch or one of the
other third-party services that will
then query their service for that ID it
was generated based on the fingerprint
and collect the information from their
server what the original URL was so that
you can also continue the flow now
that's kind of like the long route
that's a little more interesting using
that Universal link if the user just
clicks on it the app is installed then
by default on Android it's going to
prompt the user to pick between the your
app it's registered to handle it and
potentially the browser so if the user
clicks on your app it's pretty
straightforward they click on the
browser it kind of loses some of the
assumptions of the app is it installed
so you may often see use cases word that
happens and you still get forwarded to
the Play Store but with Android
marshmallow and up google introduced
this concept of a plinking app linking
is this idea that instead of bringing up
the intent picker for that URL that both
your app can handle and chrome can
handle the browser or the URL as well
says hey system I am the official owner
an official application that owns this
domain and I should be the default one
to handle this don't prompt the user to
go to Chrome or the third party apps
that are installed and I think this
provides a better user experience and an
enhanced security model as well so that
the you don't potentially have a
malicious app on the device that could
intercept information especially to
those sensitive in that URI if we wanted
to implement a plinking it's pretty
straightforward we would need to add
this auto verify tag to our intent
filter and this tells the android system
to look over your manifesto for any
intent filters that you have defined and
then go query against the domain that
you might have registered here this
should be the HTTP scheme that we have
to find here not to over one in this
example and then on your web service you
would need to use key tool to grab the
public fingerprint from your key store
or from a keystore signed APK and then
you would want to put a JSON file called
assets asset links on JSON up on your
primary domain and that contains the
fingerprint that you retrieved now when
the system see that on to verify tag
it's going to take the public
fingerprint from your apk and it's going
to match that up against the one that's
on your domain it's listed here in the
assets link JSON and that'll give the
system confidence that you are the real
owner of that and you can handle it you
can also put multiple fingerprints in
here to get multiple apps as well
another common mobile platform developer
platform feature is authentication and
that's usually used to call an
authenticated end point where you needed
a lot tokens or another type of access
token to get the uber API has both
privileged and non-privileged scopes
depending on the impact of the API if
you were just wanting to do a write
request estimate for example that would
be non-privileged but if you wanted to
initiate the the trip for the user
that's going to actually cause a car to
show up to their current location and
charge the money then that's a privilege
scope the music giving non-privileged
access tokens is a little easier of an
implementation you could do that
straight with OAuth and a client ID if
you're wanting to get it a privilege
scope it require a little more of a
configuration on your hand on your part
for that customer security and that's
where the idea of three legged off comes
into play and this is a pretty common
implementation across a loss services in
general this is the idea that in your
client app you have the client ID and
then on in your server you're holding on
to the secret that was generated and
from your application you and
she ate the authentication process you
load up the uber login service in a
webview you click authorize user clicks
authorized on the scopes and it's sort
of instead of returning an access token
directly we return an authorization code
that authorization code is then in the
third party client mobile client they
need a hand that up to their server the
server then uses the client secret that
only is contained on the server not on
the mobile app as well as the
authorization code to exchange that with
our API for a valid privileged access
token now the server has that they can
return that back to the client and the
client can use that privileged access
token to make and to make it
authenticated API requests against the
privileged two end points as you can see
this is a bit more of an implementation
you have to have a mobile app and the
server running I think the
implementation here is a little
off-putting to a lot of people and
that's where some apps have improved on
this a lot you know you have this idea
of single sign-on or native sign on this
idea you would have seen it in facebook
and twitter and a lot of different apps
the idea is that instead of having to
implement the server yourself for the
secret you can rely on the first party
uber app on the device to guarantee that
that is a valid signed user this example
you have the third party app with the
client ID and it talks to the installed
uber app the uber app then loads the
webview or some apps load native views
yeah once that access authorization is
approved an access token is directly
returned to the user they can then use
that to access the privileged API
endpoints there's a few ways that have
seen single sign-on built out before I I
worked on it at Evernote at Twitter and
a doober I've also contributed against
the Facebook single sign-on SDK the most
straightforward approach is using your
eyes directly that's because what this
does is it allows the third party app to
start a URI that
goes into the first party service do you
breath in this case and then on
successful authentication it is that the
uber app then fires a redirect URI the
client app is registered to receive
another approach that I've seen
implemented is using custom actions and
then the client app using sort activity
for results the access being granted by
the user and then the app calling finish
then the on activity result is called
there parse out the the bundle that has
the authorization token that they expect
the Twitter app an SDK was actually
built this way to account for legacy
clients that existed before the public s
UK one out third approach similar to the
second one is to use the Android account
manager that's the idea that sort
activity for result is called but you
have some classes that you implement
that are ordained by the system and you
have an authorization flow that happens
and access took and it's returns back in
the on activity result one of the
downsides of this is that additional
permissions are required and on older
versions of Android wear that still is
problematic for auto updating that can
be both problematic for the implementer
the provider as well as the third party
application that needs to add a
permission just to get at the token the
Evernote SDK was actually built this way
and I'll dive into some reasons why here
in a little bit I think that using your
eyes and the callback your eyes is
probably the most standard approach at
this point it's it's cross-platform it
works well on iOS and on Android and
there's actually an i triple e RFC out
right now for it currently called native
Native sign on my belief it's really
showing that the industry is kind of
standardizing on this approach but I
believe out of the box it has a little
higher security concern than just using
the startactivityforresult in the other
two that we talked about and those
should be mitigated through some of the
app waking like we talked about earlier
we're only one app can handle that
scheme if it's installed setting the
package when we're calling the URI and
using the package manager to query for
the right fingerprint so we'll dive into
how to do both of those in a minute in a
high level approach you know we have the
client app and it it calls it sets the
data being this login service it been
called startactivity the user completes
the authorization flow a redirect URL
was configured by the third-party client
we have a developer dashboard where they
enter that information facebook has a
similar to developer dashboard you know
both services that you work with so this
sort of thing we'll have that on the
completion of that the uber app fires
that redirect URL loud is an intense and
the third party app is registered to
handle that so we can parse out the
access token now as you can imagine
authenticating the user when we're
authenticating the user we shouldn't be
thinking a lot about security if we're
not then it's possible for a third-party
agent especially malicious app to get in
the middle of this flow potentially
trick the user to providing
authentication information or getting it
a valid access token such that they can
create commit fraud on behalf of the
user what at first thing I would
recommend is when you're using these
intents to explicitly set the package of
the application that you know you're
talking to so in this example not only
do we set the date of the data with the
deep link URI here which would be in our
case the login service but we also
explicitly set the package to the
official package that's on the Play
Store calm down to uber cab and I
recommend doing this on both sides so
when the uber app is performing the
authorization before it communicates
back to the third-party client it would
use the registered package from the
developer dashboard that we retrieved as
the as that party set this up and
configured it to communicate backwards
that would help mitigate a malicious
client from calling into it and
potentially overriding the redirect URI
that the ballot third-party headset
another security feature that I'd
recommend implementing is to verify the
public fingerprint coming from the side
the signature in the apk and this should
be done on both sides the public
fingerprint can be obtained pretty
easily using key tool then in the client
application they should be explicitly
setting that or explicitly checking that
the app that they're talking to in this
case combat ubercab is signed as they
expect and if it's not then we can throw
an error where we can return false and
you know abort abort the flow tell the
user that we can't complete the
optimization for some reason on the uber
side we should be doing the same thing
with the client app so when they
register their app with our developer
dashboard they provide their public
fingerprint and we will only talk back
to an application that has their public
fingerprint from their key store now an
interesting caveat to this is that in
older versions of Android you there was
potentially an exploit where you have
this chain of certificates that comes
from the key store and you use the
public certificate that was valid let's
say I pulled on Google Maps I pulled out
the public fingerprint and then I wrote
up a key little Python script they
created a new trust chain where I
specified that the Google Maps public
cert was the signer of my developer key
store or developer cert now I find an
apk with that and I until down in the
device it's a malicious APK it has a
trust chain with two certificates one of
those certificates is the google maps
public certificate with no other
certificates leading up to the root
verification and the other is my
malicious developer certificate now a
common implementation that I've seen is
you would call signatures you'd query
the package manager and it would return
this list of all the certificates and
then the developer would say do any of
them match the public fingerprint that I
expect now if the exploit was being used
that I just described one of them would
match the public fingerprint for google
maps and
this would then pass it cool affixed
that in later versions of Android I
believe in 14 and above it's resolved
and Google Play services also had some
security fixes in place for this but on
older devices especially non google play
devices like devices in emerging markets
and china the kindle other things like
that there's still potential for this
exploit exploit in various places so an
easy way to resolve that is to instead
make sure every single certificate in
the trust chain matches the signature
that you expect and if any of them do
not match then you know that you're in a
in a situation like this I want to move
on to another project that I worked on
when I was working on developer
platforms and that's the Evernote app we
did a big integration with Samsung to
support at vs no tap there were a few
high-level requirements for this project
that we needed to to meet the first is
that the S note notes must be browsable
in the main Evernote app along with all
the other first party content that was
created the S note at s note notes must
open directly into the S note
application when they were clicked on
and upon finishing working with those
notes in the estimate application the
user was returned back to evernote and s
note could on its own create content
directly to the evernote app on the
device and sync content asynchronously
against the Evernote Web service using
the device using application install so
let's go over a little bit about what
that entailed a little bit more and then
I'll dive into some of the components
and implementations we used to solve
that the first thing that we needed was
to be able to get one or more notes from
the Evernote app to the third-party
client that's known and we also needed a
UI action that represented starting the
ListView explicitly in the Evernote app
we needed the ability to create or
update already existing notes and we
needed the ability to delete notes based
on the user's feedback in the S note
we also needed to read account
information from Evernote into the S
note app we need to discover logged in
state and syncing preferences and kick
off that sync between Evernote in its
web service and lastly we needed to get
specific preferences to the Evernote
implementation like the available space
left in the user's account so that we so
that s note could show the right user
experience when an error happened like a
note couldn't be created because it's
file size exceeded what the users quota
was left for the month we could take
advantage of the many standard Android
components to solve these requirements
so I'll will kind of dive in to what
those are the first that we use a lot
were intense so we'll do a little bit of
a deeper dive into those specific parts
of that that made sense we also use the
content provider to solve for more of
the larger sets of data and for batch
content we use the account manager to
provide some of the authentication
information and give a better user
experience for the customers moving back
and forth between the two we use the
sync adapter as well and that was used
to optimize some of the network
connectivity between the Evernote app
and its web service as well as to expose
the ability that for that to be kicked
off and get the syncing information
directly in yes no doubt lastly we had a
bit of custom inter-process
communication that we needed for
additional metadata back and forth so if
we were talking about each one of these
in the project I'll kind of talk about
how we can cover some of the security
and privacy concerns that you may think
would exist in a project like this as
well with some custom permissions
intenser one of the first components
that new Android engineers learned about
when they're when they're learning
android and that's for good reason
there's this crucial way of
communicating between activities between
different applications even and it can
contain a bundle you know just a key
value store with various information and
it allows one component to provide data
to another they do
they're not super efficient for large
payload sizes though I believe that the
developer Docs recommend that you submit
no more than one megabyte in a bundle
across them intent so they wouldn't
necessarily be great for sending a lot
of a lot of these notes through
fortunately they have the set URI method
where you can provide a URI we'll walk
through an example of how we can use
that URI to get larger sets of data out
of the content provider not really great
for multiple operations as well if you
had a lot of notes that needed to be
created even if we split it up across
broadcasting multiple intense that
broadcasting system is running on the
main thread so that could definitely
cause some anr's and a requirement while
we were building this partner
integration was that the user could have
already been using s note have a lot of
content and then enable the integration
which all the sudden needs to sink a lot
of data to the account so we needed to
account for that intense will also allow
you to create custom actions and expose
those and by going a step further we can
kind of use these to create a consistent
API with sets of actions so that that
became more familiar with the developers
coming from something like restful api s
now you can start providing more
functionality from your app to another
app right out of the box by implementing
some of the standard actions for intense
these are commonly used for things like
sharing a sharing an image from one app
to another the first action that's
commonly used at the send action and
that is explicitly designed for you to
send one piece of data from an app to
another butts in multiples very similar
you probably have seen this when you've
been in the photo gallery and you've
picked multiple images to share to
Facebook or Instagram or Twitter the
view action is quite similar to send in
in concept what they're designed for two
different purposes whereas send is
sharing something out view is designed
when your app shouldn't be handling
looking at the file for example maybe
your app can't handle viewing the mind
type of a PDF but the user has a p
yes you were installed they can register
to show that mime type and on
interacting with the PDF from your
application you're the user could be
sent to this third-party PDF reader
lastly is the edit action which is quite
similar to view but it's more for the
concept of you have another application
on the device that can edit a file in
return it back to the calling applicant
back to the sending application I think
that in the Edit action is a lot more
interesting than the others just because
it has a lot of caveats that they go
along with it and we needed to use the
edit quite a bit for some of the content
that existed in the note when we had a
note with just a single attached s note
these are needed to be able to edit that
and be returned straight back into the
app we also use this for the sketch
annotations that you guys may have been
familiar with if you're a user of the
product as well as to implement common
other edits for mime types like if you
had a doc attached to a note you wanted
to edit that in microsoft office and
then they returned back to ever know
when you're done when we create our
intent we just let the mime type for the
file so that the applications installed
on the device that know how to handle
that can and then we specify the data
URI that we have then we can provide
from a content provider and once we
built that out we call
startactivityforresult and we expect it
be calling the sending app to provide a
status to us when they're done on the
receiver side we implement an intent
filter on the activity the handle
editing for that specific mime type and
it allow our apt to be packed picked by
the user from the intent filter then we
need code to read the incoming intense
in this third party application and
match the parameters that we expect and
we can check the mime type we can see
that this is an image we can edit that
and when we're done we want to
explicitly set the result to ok and
provide an intent back with the
information about it and then finish now
on the sender side were notified in the
unactivated result at that point we can
open up the intent we can get the
information from they get data and then
we can progress forward with the flow
but there's a lot of caveats that kind
of come with that basic integration from
send to receive and back to send
primarily due primarily due to
inconsistencies and how different apps
implement this process I really
recommend that you don't send the
original file to the third party
application you are providing the URI
that the content provider is going to
serve to a file and there's a lot of
edge cases with that for example what if
the user clicks cancel and after they
had made some changes to that file
directly now that application may have
written those changes but when they
click cancel it's going to call set
result cancelled and return back but
it's been editing the original file that
you provided assuming you had you gave
it right access as well and at this
point the user canceled the operation
but that third-party application wrote
changes to the file so you're back in
your app and they potentially didn't
have any sort of undo operation that
needed to be implemented it won't really
be clear to the user where that user
experience broke down and it'll just
seem really Jenky and they'll be pissed
that their edit their image was edited
when they hit cancel I recommend that
you instead copy the file send a copy of
the file along to the editing
application and then when you get that
result back prompting the user to
confirm replacing that copy with the
original you can always rely on the set
results or the on activity result
there's certain activity flags that
cause on activity result to be fired
immediately so we found if we wanted to
maximize the ability to edit a file with
a lot of different things on the soul on
the device we needed code in our on
resume to check if the file had been
edited if you had been using it and
potentially prompt the user to do that
replacement another strategy that we'd
worked with was using the content
observer to watch for changes to the
file in the end I think what worked best
was a we just
an md5 checksum of the file and if that
was different than we knew at least a
change had happened then we could prompt
the user again so that they could
confirm the Edit of that or not I talked
about some of the standard actions that
we could use to support things that are
already on the device however when
you're thinking about providing your app
is a platform to other apps you might
want to have a lot more custom actions
that you're using his AP is too used to
the intense and how we built this out
what I ended up liking was kind of
thinking it like restful api s where you
have these data models like a note or a
notebook and then you have these
standard intent actions that can be used
it would be familiar to developers
coming from multiple platforms now
there's no way to really discover these
by default so these have to be these
have to be communicated to your
developer Docs so that the customers of
your application have the sort of
information that they would expect now
in this example something like list is
potentially going to show a UI element
it's going to open up the app in the
list view view is going to do similar
news going to open up the composer but
then you look at create and update and
delete a few of these these can be you
know asynchronous operations like create
expects that it would have a bundle with
all the required data and it would
immediately create the content and then
return back to the calling application
update and delete would do some blur
here's an example of how a color could
start a new note with some prefilled
data and this would end with the user
being in a UI with just a couple things
prefilled now I think that using these
intense this way works great for single
pieces of information for smaller pieces
of information but let's dig into the
content provider so we can figure out
how would work with larger sets of data
in batch to batch data what is the
content provider well it's just a
contract to consume and write data to
your app it's an interface that you
would implement that's traditionally
backed by sequel light however it's just
this interface to be implemented so you
could implement this however you saw fit
this could be berkeley DB it could
just writing things to disk could be in
memory I think we're tents are great for
small snippets of data the content
provider is designed a query and write
much larger sets of data so that you're
not going to run into the same issues
the implementer must define a unique
authority so there can only be one
content provider with that authority per
device so that's that's going to kind of
give you a tighter contract when you
have an application dealing with it
start with a few examples we talked
about the URI earlier in the case of
deep linking they're often used for the
content providers as well a common
implementation musing them with content
providers is to use content is the
scheme to explicitly reference that and
then the authority here needs to be the
explicit authority defined by the
content provider if you try to install
an app that had a content provider that
wasn't unique is actually fail APK
installation here we have the data model
users and we have an ID first user in
the table that we want to look up so
don't do a bit of the basics of like
what the fundamentals of what the
content provider is let's see an example
serving and consuming the data here we
provide the query method in the content
provider so we can match the URI to the
table that we have and if that idea
exists we can append that and then we
can apply the remaining methods in the
query builder and return a cursor so
that the calling application can use
that cursor to look at the data that we
may have once we've doped the content
provider of we have to be able to access
that data and so we'll use the content
resolver to assemble that and hit the
content provider that may exist in your
own application if you you know are
using that as a tightly defined sequel
contract but I think a better use of
this is often in a another application
that they have exported their content
provider so that you can use the content
resolver to query that just like we can
serve sequel light you know rows of text
information out with this we can also
serve files directly from disk and this
is pretty crucial to the Edit
implementation that I talked about
earlier and I think that's a little more
interesting
so we'll dive into that so we do have
traditional methods like query and
insert but this is the open file method
that's implemented in the contras
provider it returns a parcel file
descriptor which is and this method is
similar to the open assets file which is
another interface in the content
provider but that's specifically
designed to return subsets of a file so
that would be great for returning
resources out of an apk where the apks
was it then you want to return one
resource so it's technically a
subsection of the file whereas open file
in this example would be an independent
file that exists on desk or a temp file
that you may be potentially create from
memory or from a network request now
this is this one here is setting the the
mode so that it's read-only so this
actually would need to be changed to
read bright if we wanted to use this in
the Edit example what we do is we turn
the parcel file parcel file descriptor
we can use that parcel file descriptor
than to get out a file descriptor once
we have the file descriptor we can then
use that to get the input streams the
output streams and there's even like the
bitmap factory has interfaces to deal
with the file descriptor directly so a
third party application can query your
content provider with the URI often that
you're handing to them in a set data
method of an intent and then they get
that file descriptor back they can then
read right do all the operations that
they want on that so I'm going to move
on to another component now that we
needed for the implementation and that
would be account manager it's a system
component that allows you to kind of
group accounts show them in one place to
the user that provides a little bit of a
better user experience in my mind it
makes it also some potentially
accessible and discovered discoverable
to other applications that are installed
on the device if they have the right
permissions which was needed for the S
note integration and it provides helper
methods for getting out tokens and
initiating the login flow and some other
things it might be kind of common
it also has air states like access
denied that you would need to implement
and we'll dive into that implementation
in a minute it's any and it kind of
provides a consistency to the end user
they have one place where they can go
and they can see the accounts that they
have authenticated on their device they
click the Add Account from here often
accounts often applications register
that sign up or sign-in flow and that
can be activated from here as well how
would we in our application add our
account here to be used by the user well
we need to extend to classes the first
is the abstract account authenticator
which is just a service that the account
manager communicates with and the second
is the account authenticator activity
which is an activity that you would
create to handle the login in the signup
flow here's a great diagram from the
Android developer Docs directly kind of
describes the flow of using account
authentication using the account manager
we process begins by trying to get out
an account token and there's the success
to that then the callback will contain a
key intent that we can use to get the
information out of the bundle the tanned
it back and or it has information on how
to start the Authenticator activity so
that the user can sign in or sign up as
well and if an air conditioned happens
that's reported back as well so let's
cover a few important implementations of
those two classes that I talked about an
account is one of the methods that we
would be forced to implement and it's
what happens when a user wants to add an
account for your application they click
the Add Account from the account manager
directly you'd want to return a bundle
with information on how to start your
authentication activity so the system
can call that and start it that's the
get auth token is another method that we
would need to implement and this is
what's called when one application wants
to get authorization to your token for
them to use so like the S note app would
call get auth token to the Evernote app
I'm kind of the meat of our
implementation prosto walkthrough we
would extra
we a simple implementation kind of naive
is we can extract username and password
from the account manager more than
likely you have an auth token here
instead but for simplicity sake we'll
use that and then we try to use that to
request a token from the server we'd say
hey Evernote server here's I'm
authenticated please give me a new OAuth
token for this application that's trying
to access our code successful then we
can return that in a bundle to the
calling application but if it's not then
we need to create an intent that
describes the error that can be followed
to go into the login activity the
Authenticator activity if we're
explicitly signing in through the
organic flow of our application then we
also need to explicitly add an account
to the account manager once our flow is
done so we would need to add a user name
and an account type to the account
manager through its own api's we also
need to set the auth token they came
down and then we can populate an intent
with all the extras to be read by the
account manager and we can hand it over
to that and when we're done with that if
we're in the middle of that off flow
that we talked about before then we
could use the account authenticator
result method where we would provide
that intent and we can finish our
activity and it would call back into S
note with this authentication
information they came from the login
flow the other piece of Android
component that we need to talk about to
kind of finish some of the requirements
here is the sync adapter and it's a
little more notorious to get working it
requires you to implement both the
content provider and an account manager
to use often people create a stubbed out
content provider just to get access to
the syncadapter at high level it's a
great efficient way for the platform to
control syncing between the applications
and web services it it's visible to the
user when these things are happening so
that they can understand their own
privacy their own data usage and the
system it already optimizes these a lot
right so you have a lot of wake up
events
where you have the sink accounts that
are kicked off and they'll run together
to be a little more optimal this reduces
the time that the radios on and doesn't
have random alarm managers explicitly
waking up the devices at as many random
periods of time and it can be accessed
with third-party applications which is
what we needed explicitly for dealing
with the Samsung integration you can
also explicitly kick off a sink for
another application if you have the
right permissions and in addition to the
interval scheduling it's also a great
way to get Network tickles and pushes
from firebase messaging to kick off the
sinks as well to implement that sync
adapter we just need a subclass the
abstract threaded a sync adapter and
it's the really the most important
method of this the most important method
of this entire thing is the on perform
sync which gets run it begins the
process this is already running on a
background thread so we're not concerned
about main thread at this point this
example we use the account manager to
get out the account that we have logged
in and we use that information to sink
down some basic images and write those
two discs this naive implementation now
we also need to create a service for the
sync adapter to bind to and since so
that it runs in the same process as the
main application and that gives our sync
adapter access to resources and that
account information lastly we would need
to create a metadata metadata file and
there's some additional flags that we
can set on this like allow parallel
sinks that would be useful for if you
had multiple accounts that existed in
the account manager you wanted to kick
off parallel sinks for each one of those
once we have that all defined we would
add that information to our Android
manifest we would create an intent
filter we'd add the metadata explicitly
and we'd add the service that we needed
as well so that was not that all working
how often should we run the sinks to
sync adapter assuming we wanted pulling
every hour on the hour which is quite
ambitious and your app probably doesn't
need to sync data that often but let's
assume we did for this exam
well you probably implement something
like this add periodic sync but you
deploy this and if you're at has
millions of users your ops people may
come to you very angry a little bit
later on and say hey why are we getting
these giant spikes in traffic on the
hour so your DDoS in yourself at this
point you're like hey the content
provider or the syncadapter putter
supposed to be smart about syncing these
why is this going on well turns out that
many of the carriers send down heart
beats for the devices those often run on
the hour and so the Android device says
hey I'm being woken up on the hour by
apt by Verizon whatever and I just so
happened to have a content provider or a
sync adapter it says hey I need a sink
every hour now is a good time to let
them go download a bunch content or do
whatever they need to do so a better
approach is to randomize that just a
little bit so instead of saying we
wanted every hour explicitly we would
add a little bit of jitter to that so we
have here a random five minutes that we
add to this and now over time we would
get a much more natural distribution of
that another way for us to have inter
process communication that we used was
to implement a ideals or Android
interface definition languages and that
just kind of binds to a standard Android
service it's like in interface but it
uses an a ideal extension and then you
generate code from that aidl extension
you implement that on both sides of the
concrete implementation and then your
processes can talk to each other it
allows you to call api methods directly
across but the sender and receiver both
need the same concrete implementations
and the class is moving back and forth
need to be parcel able so let's go over
a sample implementation of that say we
had a service they could pass messages
between two processes we define the aidl
file with the methods we want to use and
the type support here includes
primitives as well as possible classes
to these and then we implement the
auto-generated stub from the aidl here
and then
limitation we want to do is just logging
the message for the test now we need to
expose the remote service by returning
the binder in the online method so that
any consumer who attaches the received
receives the implementation that we
designed and the service will cash the
result of on bind so if you weren't
quite ready and you return null from
this you're never going to be able to
bind to this after that during that
process lifecycle finally we can consume
the remote service in another app by
setting up at service connection it
receives callbacks for when the
connected and disconnected States happen
but you need to manage all the binding
and unbinding based on the life cycle
like our on resume it on pause what's
funny about on service disconnected is
it only called when the remote service
has an unexpected exception so you need
to explicitly know that when that
happens or when your unbinding or else
you can get into an invalid state so
we've talked about a lot of permission
or a lot of features but we haven't
talked a lot about privacy concerns or
security so I want to walk you through a
little bit of using permissions with
these sort of inter inter process
components the first goal of permissions
in general just kind of inform the user
of what we want to be doing we list
sensitive operations that the
application can perform and the user can
make a conscious decision but we know
how rational users may or may not be and
how often they read these sort of things
as well so the other idea that we want
to be doing here just want to be
mitigating the exploits that could
potentially happen if an app is
compromised by not giving it access to
things that it may not necessarily need
or by putting certain controls in place
so Android permissions fall into four
levels they have normal permissions that
can't really impart real harm to the
user it can change the wallpaper for
example and while apps need to request
them normal permissions are granted
automatically dangerous permissions can
impact real harm they could call a phone
number they could send an SMS they can
get the address book they can do things
like that and the apps need to request
you to user confirmation signature
permissions are granted automatically to
apps that are signed with the same key
store
so potentially you had multiple apps in
a suite of apps they could talk to each
other using these custom permissions
that were signature to find but other
apps that we're signed with the
different key store would not be able to
use those and lastly you have signature
or sorry you have signature or system
and signature or system is very similar
to signature but it also allows system
apps taxes fees as well and this is
designed explicitly for OEM use Android
gives us the ability to declare our own
permissions as well to secure the
objects we've been talking about today
so they must be provided by the
recipient app and declared on the
calling app to grant permission they
were calling you services that specify a
requirement without acquiring the
permission would result in a security
exception and they can be checked
programmatically in Java or they can be
explicitly set in XML the sum of the
components that we defined here we can
look at how to enforce that a little bit
we can call the check calling permission
method on a context to determine if the
coaling application was granted
permission required if it wasn't then we
could throw an exception here and a
caveat to note is that it's easy to leak
permissions on the check calling
yourself permission because it uses your
own applications permissions as well if
you had to find your own custom
permission and if we instead wanted to
enforce this permission in XML we could
just define that here with the Reaper
mention the write permission and that's
going to manage it for us if they were
on marshmallow and up we still need a
prompt the user to that to be accepted
as well all the other components that we
talked about today offload similar ways
to flag that down in the XML but I'm
only going to kind of show this quick
example of doing it with the content
provider so at the beginning of this we
talked about all the project
requirements so I'm going to quickly
show what we use to solve each one of
these for the get notes we use both in
tents and content providers depending on
the size for the list we just had an
intent that started the UI for create up
create an update notes and delete notes
we could also use the
intense and content provider again based
on if it was a single note or contour a
batch of notes for the account syncing
info we could use the account manager in
the sync adapter and then forgetting the
preference information we could use the
content provider to get it things as
well as the bound services to get it
explicit objects so these are pretty
rewarding systems to build out there a
lot of fun building for other developers
but they can be really challenging the
debug my experience many of the
applicant many of the integrations are
device specific like building against an
oem camera it's a common implementation
so setting debug points and in switching
between processes it's pretty difficult
and it can become troublesome and so
with that challenge i'd recommend having
really good logging during this to try
to figure out what's going on and
setting up automated tests with with
lock api's mock integrations to kind of
walk through those flows and while these
can feel like magic when they work well
they can cause a lot of user frustration
when they break down and since things
like set results may not necessarily
always be appropriately used on edit I
think that it's pretty appropriate have
a pretty strong line of communication
with your user on what's going on what
the communication is happening even
consider having something like a beta
channel to use when testing some of
these so you can get early feedback on
your integrations and lastly rely on the
great tools that already exist for
getting these are feedback from the sort
of stuff like account for like mass data
using things like crashlytics analytics
but also think about explicitly seeking
feedback on these sort of
implementations as well I hope you guys
had some great takeaways for my talks
I'm pretty excited to see more apps
integrate with each other in the
ecosystem I think that's a pretty unique
and powerful piece of Android and I
don't think as many apps to it as I
would like so I'll be excited about that
I think I'm a couple minutes overtime so
I don't really have time for questions
but i'll be around and if you guys want
to talk about deaf platforms and android
integrations I'd be happy to chat thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>