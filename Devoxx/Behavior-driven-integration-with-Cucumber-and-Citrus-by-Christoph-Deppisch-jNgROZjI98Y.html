<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Behavior driven integration with Cucumber and Citrus by Christoph Deppisch | Coder Coacher - Coaching Coders</title><meta content="Behavior driven integration with Cucumber and Citrus by Christoph Deppisch - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Behavior driven integration with Cucumber and Citrus by Christoph Deppisch</b></h2><h5 class="post__date">2017-04-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/jNgROZjI98Y" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to behavior driven integration
with cucumber and citrus my name is
Christophe and I'm from Germany
I work work there for a company called
console software and I'm really happy to
be here and to be part of devoxx us so
in the next 30 minutes we will have a
look at two frameworks cucumber and
citrus where cucumber covers the
behavior driven aspects and citrus is an
integration testing framework for your
messaging interfaces so we will have a
small sample application that uses HTTP
rest and JMS and mail communication and
we will combine these two frameworks in
order to have automated integration
tests with behavior driven aspects so
behavior driven development a short
raise of hands who has been working with
BDD before yeah like three people yeah
so it's about communication in your team
and in your company so let's say you
have a group of people in your company
or in your team that are in charge of
creating new features thinking of new
ways to create new business value and
these people know the processes and the
user experiences very well
they are domain experts and they are
product owners and they have new ideas
how to create new business value and how
to create new features what is the next
way to create new user experiences
products and so on and not necessarily
these people know how to write software
and this is good for us so software
developers so we can have a job and we
can write some code for them and these
two groups here they have to exchange
some knowledge so the product owners
they have to describe what is the next
feature all about what is the income
what is the outcome what exactly is the
aim that we want to achieve with this
new feature and we software developers
have to communicate how we can integrate
these new features in existing
applications do we have to write new
components do we have to write new
services and so on and another aspect is
we as a software development we have to
prove that we have made that feature as
it was expected or as it was required
and this communication of this knowledge
knowledge exchange can go deeply wrong
at the very beginning of software
development so when you have bad
communication when you have unclear
requirements or misunderstandings not
even a single line of code has been
written yet but things can go deeply
wrong and behavior driven development
tries to give us some concepts and some
tooling to improve that so it's all
about explaining the behavior of
software and when you think of how do
you explain your ideas and your thoughts
to another person a good idea is to give
concrete examples so if you really have
a concrete example you talk to the other
person and you explain your ideas by
having a concrete example and this is
what gherkin comes in in behavior driven
development so gherkin is a
specification language it uses some key
words for describing features in form of
user stories and these user stories have
scenarios and these scenarios describe
very concrete examples and this is a
very good way to write down your
features and to write down everything
that you need so the key words are given
a certain context when some event
happens then an outcome should occur and
this given when then structure and this
given when when syntax has been proven
to be very good to write down your
feature and to give a concrete example
to the other person that should
understand what you want to want to say
so let's have a small application I have
prepared a small
buuut application it's a voting
application so users can go there and
create new voting is give it a title
give it some vote options and then other
users can go there open voting to some
votes and when we close a voting then we
should see the results of the voting so
a feature specification for this small
application written in gherkin could
look like this
so for creating a voting as a user I
want to create new voting's and each
voting is given default vote options and
then I use a very concrete example to
describe the scenario so I pick a voting
title do you like Mondays when I create
a new voting then the voting should have
two options the default options yes and
no and of course complete feature is
described by multiple scenarios so I can
add another scenario for adding some
custom vote options and in this scenario
I pick the options green red and blue
and then of course the outcome should be
that we have the Board of trans green
red and blue and cucumber as a framework
can read these specification files and
make them directly executable as unit
tests and let's have a look at this so
tray unit offers the way to yeah execute
the tests with the test runner and
cucumber is providing such a test runner
so we can use the J unit run with
annotation and give it the cucumber test
runner and now cucumber is running our
unit test and cucumber will read all
feature files in that very same package
as this class and make them executable
as unit tests and we have to provide
some kind of mapping or it's called glue
code so that the feature file and the
executable unit testing method is
matched and these are called step
definitions and we will have a closer
look at them right now so when I have
this line when I create new voting and
the title then I should have a
method which is annotated with some
cucumber annotation and we have cucumber
annotations for given when then and this
annotation is provided with a regular
expression and this regular expression
should match my line in the future
specification so I have this regular
expression I create new voting and as
you can see I can have regular
expression capturing groups in order to
have the title of the voting injected as
a method argument so the title is
injected here as method argument and
then I can use it in order to create a
voting ID create the voting with the
title and called the voting service to
add this new voting so this is normal
unit testing code then also the second
example here then voting should have
three options again I pass in the amount
of options as a regular expression
capturing group it's the option count
and then I can do a normal unit testing
assertion on the on the voting service
so this is the basic basic idea
cucumber gives us some syntactical sugar
here so we can also provide a beta table
and this data table is passed in
automatically as a data table object and
then I can have some operations on this
data table object like here checking the
size of the options and checking for
each given line in this data table that
the option is available on this on this
voting so this is another way of
describing the the data that is injected
into the into the method and one other
thing you can have optional capturing
groups like the leading the it's
optional it's just a more flexible way
to create your regular expressions so in
the future specification you can write
then the voting should have options or
you can write then voting should have
options it's just syntactic syntactical
sugar yeah so let's have a look at this
in a small demo I have this voting
application here as I already said it's
a springboard web
maybe I can show you this in as a
running application I have started this
spring boot locally on my machine so I
can start this application I can add
boating's here
do you like Java we can open that and of
course yeah we we vote for yes to like
Java yeah okay and if you close the
voting then no further voting options
are accepted very small application just
for demonstrating that and this spring
boot web application of course it has
some controllers here for the rest api
some very basic services within memory
storage of the voting's that we created
model classes and yeah not nothing fancy
here and in the tests of course we have
this cucumber test we have our voting
step definitions with all the methods
that are annotated with cucumber
annotations that match the regular
expressions and then of course we have
the feature files and these are then
written in gherkin describing the
feature having scenarios with concrete
examples and here for example these are
the voting results if we do some votes
then the results should be calculated
right and we can have a top vote like
the most clicked option here and all
that stuff is executable as a unit test
so as it's a normal chain unit test I
can run this from my Java IDE and you
know it's blazing fast as a unit test
should be and we can see that the
integration of cucumber into Java IDE
like IntelliJ is very very good so you
can browse your scenarios you can browse
everything I hope you can see that and
also speaking of the integration into a
Java IDE it's it's really awesome you
have this syntax highlighting here and
you have the highlighting of the
capturing groups that are passed in as
method arguments
you can also jump into the methods here
so we can jump into the implementing
method that matches the regular
expression here so this integration into
your java ID is really really great so
that's for the first short demo here
let's move on what else do we have
we have hooks which is a simple way of
executing tasks before scenario and
after scenario very simple we have
background steps so the background steps
are valid for the whole feature file and
each scenario is built upon these
background steps so this background
steps are executed before each scenario
is executed and these are normal steps
with the annotations then in the step
definition classes with the regular
expressions is just the same scenario
outline is also very interesting this is
a great way for providing test data we
can use placeholders here like the
brackets title yes votes no votes and
top vote and we can give at the very
bottom we can give a data table of
example data and for each line in this
data table cucumber will execute the
scenario and we'll just provide this the
test data to the to the scenario that is
the short introduction to cucumber I
cannot mention everything about behavior
driven development and cucumber itself
please go there and have a look at it it
provides a lot of other features it's
just a short introduction because we
have limited time here so let's combine
this now with citrus the second
framework so citrus is a integration
framework for your messaging interfaces
and yeah we'll just that mean so
software nowadays calls or exchanges
data with other software components
using REST API using JMS using file
based interfaces soap web services of
course they are still there out there
so all these messaging interfaces should
be tested in an integration test and if
we have the voting application here as
example so clients call the voting over
the rest api or as an alternative over
the JMS api and on the other side the
voting app when a voting is closed and
all voting's are done reporting server
back-end should receive some reporting
over JMS and we should send out some
email to the participants that the
voting is now closed and the results are
and this and that so we have in this
example we have three different
interfaces from client side from server
side from back-end server side and we
would test what we should test that in
an integration test and citrus as a
framework is able to simulate all the
surrounding components like sending in
some client requests over rest over JMS
and on the other side
receiving JMS messages as the reporting
back-end and as the main server
receiving mail content so on the client
side and on the server side Sid Rowse
provides us ready to use components to
simulate these components in a in an
integration test so if you combine
citrus with cucumber you have to do one
thing you have to set a citrus object
factory and this is done in the cucumber
properties or over system properties and
this enables citrus to extend cucumber
with some extensions and we will have a
look at these extensions right now but
still the test is run with a normal
cucumber test runner so it's just a
normal cherry test run with a cucumber
runner so all the feature files are read
and executed as before and we can have
some optional cucumber options for
adding a special citrus reporter for
having citrus reports but this is
optional and then in a yeah new feature
we describe we use the domain-specific
language of this voting app like having
a new voting given at a title give it at
both options so this is still speech
feature specification with the normal
domain-specific language but in the
background we are using citrus now to
send out some HTTP calls
to send out some Gemma's cause to
receive JMS calls or at the very bottom
at the line then participants should
receive an email this is the mail
content that should be received over
over the citrus components so in our
step classes as we have this citrus
extension enabled we can use new
annotations like the citrus endpoint
annotation and this will automatically
inject me some some endpoints and we
will have a look at this in on the next
slide and using these endpoints I can
send out some rest call I can receive
some JMS message I can send out some
chain as message I can receive mail
content with a mail server so these are
the ready to use components provided by
bite citrus and we can have the test
runner this is our entrance to the Java
fluent API provided by it citrus that is
able to support you by writing the rest
calls or the JMS calls so the runner is
the entry to the java fluent api and we
can use a client component to send out
some delete method here to the to the
server and we receive in the next action
we receive the response from the server
and we check that the response is HTTP
status okay so speaking of the endpoints
as I said citrus provides ready to use
endpoints for different message
interfaces on the client and on the
server side here in our example we have
a spring beam configuration Java spring
being configuration where we create the
citrus endpoints here's an HTTP client
of course gets an server URL to call and
we have a mail server component and
these few lines create a complete mail
server which automatically starts when
the test starts and is able to receive
mail content so it's pretty easy to add
this endpoint configuration and as I
said citrus provides several components
on client and server side for different
messaging in
faces like sub web services or JMS we
will see that later on also camel
integration selenium integration we will
see that in the demo and so on so having
a closer look at the runner API so as I
said we can use the runner API to send
ups send out some HTTP calls as you can
see we can define payloads here which is
XML or JSON or plain text whatever and
we can use variables in the in the
payloads so at the very beginning I
create some variables here this is for
the citrus runner and I can reference
these variables in payloads with the
dollar curly bracket expression syntax
as you can see here in the JSON payload
I reference this variable so this is a
great way of creating some state at the
very beginning of the test and then at
the further steps that are executed I
can reference of the voting ID for
example to send out and and and
reference all the same voting IDE in
there in the whole scenario and again we
receive some server response and check
that the HTTP status is okay for the
mail server communication here so again
we use the run a fluent API to receive a
message now we reference the mail server
and the mail server automatically
converts incoming mail content to an XML
representation and why is that done this
is done because citrus has very powerful
validators for XML for JSON or for plain
text and now when the mail content is
coming in we can just provide here an
expected mail content and this expected
make content is given here in XML it's
loaded from a class path resource and
then sitter's will just check that the
mail content that is actually received
is compared to the expected mail content
so we want to have the test SM aspects
that we check that the incoming email is
as expected and
again we can use variable content like
the male body this is coming from the
from the future specification and this
male body said as a variable and then we
can reference this in the expected male
content so again citrus is really really
powerful in comparing XML data in
comparing JSON data we can ignore some
sub elements we can have dynamic tests
data here functions validation matches
all that stuff but I can really not
explain all of that right now but the
the impression should be should be there
and last not least JMS communication so
again we create some JMS endpoint this
is asynchronous jam as endpoint we give
it a connection factory that we need in
in Jam as we give it a destination name
which is a cue name or a topic name and
then we are ready to send out and
receive messages over this destination
and again we use the Rama API user
ranaut receive reference the reporting
endpoint here and in this case we expect
JSON payload and this JSON payload again
is then compared element for element and
in this jason validator
we have several options here for
ignoring some sub elements or for having
different orders of that because in
adjacent the order of the different
elements is not it's not yeah it's not
is not valid anymore so let's have a
demo for this lots of stuff and maybe we
can show that in a small demo so let me
close the implementation I have provided
different modules for different aspects
and again
this whole demo is available at Tschida
i will have a slide at the last slide so
you can go there and you can clone the
whole demo and execute everything on
your on your local machine so let's have
a call here at the REST API test
it's a normal unit test and we have all
these step definitions and let's have a
look at the future specifications and
again we are using this domain-specific
language and translate all that into
step definitions and now these step
definitions use the runner to execute
some messaging interfaces let's run the
test to see it running and now yeah the
cucumber still reads this feature files
translates it to the annotated methods
here and in the background we just call
the application that is running on my
local machine over rest over time as and
the main content is also checked here so
hopefully this test is green
very good so all the tests have run
through so maybe we have a failing test
so let's expect a top vote here for yes
although also we have here the no count
so this test should be failing right now
because our expectation is wrong
okay test fails and here you can see
that in the JSON validation the element
name here was expected to be yes but it
was actually no so the JSON data that we
received from the server is not as as
expected here and this is all driven by
the future specification so let's fix
that again so another aspect is we have
to write these glue code in the
background so this Runner with doing the
HTTP calls during the gem as calls and
so on we have to write this every time
from scratch and I thought to myself
maybe we can have some defaults step
definitions that are provided within
citrus so you can use that right away
and I did that so here in the cucumber
options we can load this predefined step
definitions that are coming from citrus
for different interfaces like for HTTP
here and then we can have a feature
scenario where we can write when send
the lead on slash voting then receive
state is 200 okay and when we use this
syntax we don't have to write any glue
code on our own so if I jump here right
into that we see on the on the left-hand
side here that this is coming from the
citrus cucumber jar file so this is
provided by its citrus we can use this
predefined step definition right away we
can start right to have this feature the
syntax here is given a payload and
content type is application J's and
whence and post on slash boding then
receive state is 200 okay it's a little
bit more technical we don't have this
complete the domain-specific language
anymore but it's a it's a great way of
writing yeah technical unit tests or
technical integration tests
behavior-driven for calling REST API and
the good thing is you can mix all those
so still
I'm able to go in here and say given
voting list is empty or what closes the
voting so I'm still able to reference
custom glue code with predefined glue
code it's just a matter of regular
expressions that match in the custom
step definitions or in the provided step
definition so we are really really
powerful here in mixing mixing those two
create our own domain-specific language
how to describe the feature files into
future scenarios let me show you this
with selenium once more so the same
approach I go here and I add the
predefined selenium steps from citrus
and then I'm able to write feature
specifications that use lines like when
user starts browser and user navigates
to an URL then the page should validate
or when we execute some submits with
arguments and we sleep sleep is another
default step definition coming from
citrus and then the page should display
an element with the link text so you see
this is selenium style where we check
elements on the page and if we execute
this test right now then hopefully a
browser should open and the voting
application is then just test it from a
UI perspective so selenium will then
click buttons fill in form fields
navigate through the pages and all this
stuff is using the central selenium
integration with the cucumber
integration in combination good so let's
go back here we can see that all the
tests are green so my time is slowly
running out maybe let's have a quick
look at the JMS stuff so the scenario
here is using the scenario outline
feature this proves that we still are
able to use the cucumber features with
citrus here so in the background we have
like here the runners calling HTTP and
here for example receiving reporting's
over JMS and if we execute that we just
don't send in the data of HTTP we send
it in over gem as we will receive to him
as data as a reporting server and this
proves that we can have all our
integration and all our messaging
interface is tested with one tool with
the citrus no matter if it's HTTP or if
it's gem as file based or whatever you
whatever you can think of and we can
still have this cucumber aspects for
behavior driven development
combined with this sort of integration
testing so if that is green then I can
go back to the slides for showing you
the last slide yeah so everything's
running fine let's go back and let's
show you the the promised slide for the
reading information I hope you got the
impression of both tools cucumber for
executing behavior driven tests citrus
for executing the integration tests for
calling rest and API over different
interfaces the demo is available on
github so if you go there clone the demo
run it on your local machine and I'm
happy to receive some questions in the
last maybe one question if there is one
question yeah
yeah
so the the question was when using
behavior-driven we have a certain buy-in
for the for the client to receive or to
provide this information of writing the
files writing the features and so on and
if this is yeah practical in use so
behavior-driven aspects or behavior
driven development is part two to have
this communication with the client so if
you go to the cucumber site you will
have video we will learn how you can
have meetings where you have all
participants included where you can just
have this feature fights at the end of
the meeting you can you write the
feature files or you should have these
feature files and this has a certain
communication with the client and you
can think of everything and you maybe
you think of aspects that you alone
wouldn't have thought of
so this communication with the client is
a big a big step in in having this
behavior driven aspects here and in this
behavior driven concepts so it is it is
tough of course because you have to have
the clients to work with you yeah but at
the end you will have a feature
specification that is understood by both
sides you will have a common
understanding of what the feature should
look like what is in scoreboard is out
of scope what's the income was the
outcome so this is then what what you
what you receive through the questions
yep
yeah there is a module the question was
do you have any integration with
persistence testing citrus is able to
connect to storage and to have a look
into the storage if there's an entry for
customer with this in that state so you
will have like actions that go to the to
the storage and you can integrate that
with the test runner API so if you have
further questions maybe come to the desk
or open some issues on that github
sample repository so we can have a
discussion there also and I thank you
very much for your time and your</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>