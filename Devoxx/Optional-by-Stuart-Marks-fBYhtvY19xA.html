<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Optional by Stuart Marks | Coder Coacher - Coaching Coders</title><meta content="Optional by Stuart Marks - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Optional by Stuart Marks</b></h2><h5 class="post__date">2017-04-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/fBYhtvY19xA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good afternoon welcome my name is Stuart
marks I work at Oracle in the Java
platform group work on Java the open JDK
in the core libraries area so today's
talk is optional the mother of all bike
sheds I'm going to be spending an entire
technical session talking about a single
API and talk about why we need it how to
use it how to misuse or abuse it to talk
a little bit about this notion of bike
shedding which I talked about in the
title and then wrap it up all right
why do we need optional so let's talk
about what an API looks like without
optional so before Java 8 it was pretty
common to have an API that looked for
something and there's a possibility that
that API might not find what it was
looking for so let's let's describe this
using an example an early in fact this
was actually a real example because this
is one of the one of the api's we had in
the streams API in an early draft of it
we had something I'll call search that
took a predicate and if it found
something in a stream that matched that
predicate it would return it great
well what if it doesn't find anything
that matches the predicate well I mean
what do you do return null I mean you
you that's what you always do with Java
you return null so that's that was the
early draft API of this method in stream
so the example here is I have a
predicate which checks the ID of a
customer so I write a method that
searches a list of customers looking for
a customer with that ID and then it
returns the matching customer or it
returns null ok seems simple enough all
right so now let's say I want to return
the customers name whose matches that
idea that ID ok so we have a nice stream
here we we call our search method on it
and pass a predicate that matches the
customer ID get its name and return that
well that that looks like it does the
right thing except in the case where
search returns null that will throw a
nullpointerexception
this probably happens all the time so
what do you need to do okay
first run your stream and store the
results in a local variable and then do
a check in that local variable against
null and if it's not null then you go
ahead and call get name but if it is no
then you have to do something else in
this case we're just going to return
some placeholder string and this works
this is fine and I think we have to do
this all the time but this is kind of
cluttered the first thing is it's easy
to make this mistake and forget to check
for a null the second thing is when you
do add the check for null it adds a
bunch of clutter to your code alright so
in Java 8 we said okay I think we can do
better with this with this kind of
problem and so we introduced the new API
called
optional it's a generic type has a type
T and it can be an instance of optional
can be in one of two states it can
either be empty or it can contain a non
null reference to an object of type T so
if it does contain a nominal reference
we call that present or the optional has
a value present and if there isn't a
reference of type P in there we say that
it is empty occasionally I hear people
say that it contains null and maybe
that's true in the implementation but I
think there's a very confusing way to
think about it because an optional the
idea of optional is to think about
presence or absence of something
distinctly from null references or not
so in fact I think it's it's it's a
sloppy terminology to say that an
optional contains null so we say an
optional is present or it is absent or
value is present or absent in and
optional there are few specializations
off for primitive values optional inch
long and double not going to cover those
but they're they're mostly parallel to
the optional that can contain reference
now optional is an ordinary class and
like everything in Java every class and
have references to instance you
census and those references can be null
never ever ever use null as a reference
for an optional itself now if you use
stylized uses of optional the way I'm
going to talk about in this talk
it basically is not a problem just
remember don't use null when you have an
optional so what I'm going to do here is
as I go along and going to be
introducing a set of rules for what I
think are proper use of optional so
here's rule number one never ever use
null for an optional variable or return
value and I'll present these at the end
so you don't have to worry about
capturing them all alright so the
rationale for optional provides a
limited mechanism meaning it's we're not
intending to solve every last problem in
the universe to limited mechanism for
method return types I think that's a key
point the focus of optional is on method
return values and so it's also useful
where there's a clear need to represent
no results that's like a finding or
searching example where I think it's
quite legitimate to search for something
and not have a result so you need a way
to represent that and we're returning
null is likely to cause errors and so
you saw an example of that in the
examples a few slides ago where if
you're turned on you if you immediately
dereference it you get a null pointer
exception and it's it's tempting to do
that in code it's easy it's convenient
but it introduces null pointer
exceptions so if you have that kind of
situation that's where optional can help
you alright so let's go back to that
example and see if we can do better so
instead of search what we ended up with
in the streams API was find find in E
and fine first and so what those do is
return so if you have a stream of type T
then find any or fine first we'll return
an optional of type P and it's slightly
different to you don't actually pass a
predicate directly to the find method
basically upstream of the find method
you you fill you put in a filter
operation so that's what we have here we
take our customer list stream it run it
through a filter that looks for a
matching ID fine first we want to find
the first customer that matched
matching ID and then now we have we have
some representation of of a customer
that might or might not be there and we
want to get its name so the example here
is that we want to get the name okay so
there's a problem here because fine
first returns an optional but get name
is a method on customer so that doesn't
work
so we have to do something different all
right so let's let's break this apart
here for the sake of example it gets
better don't worry so let's take the
optional customer return value from fine
first and store that in a local variable
so now we have an optional that might or
might not contain a customer and we want
to get name on that somehow so so how do
we do that there's there's a piece
missing here all right there's a method
called get an optional that gets the
value that out of the optional great
we're done oh well what about the empty
case right it's just like when we
couldn't find a customer that matched
that ID what gets returned an empty
optional what happens when you call get
on auntie optional it throws no such
element exception okay well we haven't
bought anything here because it's just
the same this is almost exactly the same
as what happens if you call call a
method on an old reference you get some
exception thrown so we have bought any
you know this hasn't bought us anything
yet so we have to do we have to work
harder to make this to make this work
right so that's what I'm going to tell
you how to how to use optional properly
so like you if you had a reference you
could test it to see whether it was an
all or non null if you have an optional
there's a method called is present
that's boolean that tells you whether it
has a value present or whether a value
is absent so here's a safe way to
implement our example we want to run our
stream and get an optional customer as
the result so that's a so that might
contain a customer that matches or it
might be empty and so we say if that
optional has a value present
and get the customer out of it and call
get name on it and so that works because
since the optional has a value present
we know get will return that reference
and that's non null otherwise we return
some default value and here I'm just
using the string unknown okay but again
this is this is kind of same as testing
for null versus non null but actually
it's a little bit better because instead
of accidentally calling methods on a non
null reference what optional does is it
kind of forces you to say oh I have an
optional here that means it might be
empty how do I handle this case but
still the code is not very good because
we have to have a local variable and we
have to do this explicit test in here oh
but before I move on here's rule number
two never use optional dot get unless
you can prove that the optional you're
calling it on has a value present right
so if you call get on an empty optional
it throws no such element exception and
that's that's the kind of equivalent of
a null pointer exception so you could
write all your code this way and say if
if it is present or use a ternary
operator or whatever essentially saying
if it is present then get else do
something else and you know that's okay
but but we we can do better and so
anyway
we should we can't we can do better and
we should do better so rule number three
is don't fall into the trap of always
using use present and get instead use
the techniques I'm going to show you in
subsequent slides they're a bunch of
alternatives to using is present and get
alright so there's all family of methods
on optional called or else and so I'm
just going to either quick little
examples here but the basic premise is
if the optional has a value present that
value is simply returned or else
something different happens and so there
are three methods here the first one
or else we'll return a default value or
else get instead of returning a default
value it will call a supplier which is
like a lambda expression or method
reference you can provide but it will
call a supplier to create or obtain that
default value that's then returned and
or else throw will say oh okay this
should never be this net this should
never be empty so throw an exception and
what it does is it allows you to throw
an exception of of a chosen type so for
instance it might you might want illegal
State exception instead of no such
element exception but again the the
thing that's it's a little odd about the
naming here in isolation at least is or
else extract the value if present and it
always does that and then or else or
else get and or else throw will do
different things if the value is absent
all right so there's another method
that's extremely useful which is math
and it's math in a sense of transform
kind of the same the same kind of usage
as the math on the stream on stream
object so what map does is okay so now
this is a recapitulation of our example
here and I'll just show you code that
uses a map so what map does is it says
if there's a value present it calls the
mapper function on it and takes the
result of that and puts it back into an
optional but if the optional empty it
just does nothing and passes through the
empty sort of okay that's kind of a
mouthful but that's exactly what we want
to do here so in our stream example we
got we did search for a customer with a
matching ID and we got an optional of
customer and what we really wanted the
name and so we call math with the
getname method with a meth with a
reference to the customer get name
method what that does is if there's a
customer in there and replaces it with
the customers name so now we have an
optional string but if there was no
customer in there
it's an empty optional now what we do is
we chain or else on to the end of it and
so if that customer was present it was
replaced with the name and then or else
remember the first thing that or else
does is extract the value that's in
there so if we bought the customer we
changed we mapped it into the customers
name and then that's what we returned
but if the optional was empty the mapper
function is just ignored and or else
says return unknown which is our default
value so you can start to see okay we
chained these methods up on optional in
in an interesting way and we can we can
get some really convenient behaviors
here but it gets better because we don't
need that pesky local variable anymore
we can chain these methods right off the
end of the stream so now we have we have
a stream that terminates with fine first
but we can keep chaining methods on it
so fine first returns an optional and
then we just call mapper on it to
transform the value that might be
present in the optional or else we
return some default value so that makes
that makes things a lot more convenient
and neater so you lose the need for
local variables and you lose the need
for explicitly testing conditions all
right so there are few other methods I
want to run through pretty quickly on
optional one is the filter method and so
what filter does is it establishes an
invariant over what value might be
present in the optional and if something
doesn't meet that invariant then it
returns an empty optional so here we
have an example that really came from an
early access version of JDK 9 I think
I've heard that this code has been been
edited beyond recognition so you won't
it won't be in there if you go looking
for it now but basically you know it's
this stuff about modules and layers and
configurations and stuff the exact the
exact case is not that important but the
invariant is what's interesting here
which is we have a config and we want to
make sure that it has a parent and its
parent is the same as our parent and so
that's what this code here does this is
kind of a conventional usage of optional
like I was saying before it doesn't kind
of kind of the conventional thing with
is present and get and if that condition
and and really this is checking the
opposite of the condition that they want
to to assert and so if the opposite is
true then then it throws an illegal
argument exception and so a better way
to rewrite this code is like this so
what we want to do is we write a filter
and that takes a predicate that says
okay we we have a config and we get its
parent and we want that parent to be
present and be equal to our config and
so what what you get at the end of that
is an optional that contains a value
that meets the predicate otherwise it's
empty and in this case if it's empty
that's what's illegal so we say or else
throw illegal argument exception and so
you notice how this this reads a lot
nicer than that that if statement which
had complicated boolean expressions and
negations we get the parent we assert
that it's configuration is equal to this
configuration or else throw an exception
alright so there's another method called
if present and it's pretty confusing
because there's there I already talked
about a method called he is present and
so this one is if present and it's a
little little too easy to get these
mixed up so sorry about that but here's
an example from another example from the
JDK of where we can use this so so what
if present does is it executes a lambda
expression if the optional has a value
present and so the use case here this is
kind of the original code which is sort
of written out so we got a task from
somewhere that might or might not have a
task so it returns an optional task so
the conventional code is okay tests are
optional to see if it has a value
present if it does we get the task out
of it and then ask an executor to run
that task pretty conventional but we can
use the if present method to make that
much nicer
I could say get tasks which returns the
optional now notice we don't have to
store this in a local variable we'll
just chain chain off of that we say if
present and then has a lambda expression
that submits the task to the executor
okay and we can do a little bit better
because I like method references so we
could say get task if present
hey executor run that task and we're
done so that makes things much neater
alright there are even more methods on
optional a couple static factor methods
and this is this is where you get
optional instances from in the first
place there are no public instructors on
optional so if you want an empty
optional you just call optional dot
empty and if you want an optional that
contains a value you say optional dot of
and a crucial point here is that if you
pass a reference to type T that
reference must be non null so you can
never store a null reference in an
optional there's equal to hash code
which do pretty much what you expect and
and it's like you know so what who cares
well it turns out that this is really
useful in unit testing so if you have a
unit test for a method that returns an
optional here's how to here's how to
test fit you say assert equals optional
dot of expected value or certain equals
optional not empty I think this is the J
unit style where the expected value is
on the left in anyway so so equals works
as you expect and in fact compares the
things inside the optionals if they are
both present alright so there are some
new methods we're adding two optional in
java nine there's there's the there's a
method that converts an optional into a
stream consisting of zero or one
elements and then there are couple
additional utilities there's if present
or else which is kind of a mouthful and
there's optional dot or and i'm not
going to go into these in detail I think
the use cases are a little more complex
than I have time for today but they do
come up
menu and again the usual case of you
know you have a stream that wants to
find something and you need to handle
the case where it might be present or
absent and sometimes you need to do
something with with you need to do
something with both the need to take
action on both the present case and the
absent case and sometimes you also want
to combine two optional values in a
particular way so that's what optional
or does all right so here's an example
of using optional dot stream
Smoove we had a list of customer IDs and
you wanted to transform that into a list
of customers right so you run that
through stream and you map that to
customer find by ID so now you have a
list of customer you have a list of
optional customers some of which might
be empty so you have a bunch of empty
optionals inside your list so that's not
very good
so let's filter that on optionals that
are present and then map that to
optional dot get to get the actual
customers out of the of the optional and
that works in Java and it's a little
nicer because we can run that through
flat map and the result of flat map in
the stream so we can compress those two
operations down to one so we can say if
we have we have a stream of optionals we
can flat map those and it just drops out
the just drops out the empty optionals
I'll take questions at the end thing
excuse me I'll take questions at the end
okay now so there's there's another
important use case which is how to adapt
if you're writing new code you're using
optional that's great how to adapt that
code to other parts of your code that
might still be using nullable references
so we have a couple of techniques for
for dealing with those so if you suppose
from let's say from my point of view I'm
working on code that uses optional and
I'm calling into some code that might
return a null so how do I deal with how
do I deal with nulls how do I bring
nulls into the optional world so there's
a different static factory method called
optional dot of nullable
and that allows the reference to be null
and so here's the key thing it doesn't
store a null reference as the value in
an optional so again there's no way to
have an optional present that has a null
reference so if you pass optional of
nullable unknown reference you get an
empty optional I think this throws
people a little bit but I think it
actually makes things simpler because
again there are only two cases see if
you did have an optional that could
contain a null reference you might you
might say oh it's present get the thing
out of it and then still end up with a
null reference which kind of gets you
all the way back to the beginning of the
talk you have to test for null again so
we don't allow null references to be in
optionals and so optional of nullable
with a null returns an empty optional
okay so now you want to go another way I
have an optional that might might be
present or absent and then I want to
pass it to some code that's expecting a
nullable reference how do I do that well
it turns out if you just say or else
null it does exactly the right thing it
converts it extracts the value if it's
present but if it if it's an empty
optional it just turns it into null so
something needs a knowable reference
just call or else Mel on your optional
and I think this is the or else knows
sometimes overused I think that the main
use case where you should focus on is if
you're calling into code or you need to
pass pass a value to something that is
expecting an honorable reference that's
the time to use it otherwise sometimes
people really well people people overuse
tough
all right that's my quick rundown on
proper uses of optional and so there's a
lot of people who kind of grab onto
optional say oh look at all the cool
things we can do with it and so there's
there's use misuse abstruse use and
abuse in all kinds of ways that i think
that optional should not be used so I'll
run through a few quick examples of that
all right so one thing that people do is
they say hmm oh it's really cool you can
change methods and you no longer have to
write if statements so suppose I have a
method called process that takes a
nullable string well I could just do the
simple thing and test that against null
or I could say I'll create an optional
of knowable and then call or else get on
it and have it call something else so
why bother just test it against null
everybody understands what testing
against null means and so if you have
something if you have a reference that's
knowable just tested and null usually
creating an optional just for the sake
of changing methods off of it and then
extracting the value at the end doesn't
buy you anything so here we have rule
number four generally bad idea to create
an optional for the express purpose of
chaining methods and then extracting it
and so I think the the anti-pattern
there I see is when when you use
optional entirely within a single method
or even in a single statement again the
main use case for optional is when
you're returning a value to somebody and
in the return position that value might
or might not be present all right so
there's there more ways to avoid this
statement so this is a weird use case
that somebody asked on Stack Overflow he
he has two optional big decimal values
and he wants to add them together now
since they're optionals there's this
question of what you do if one of those
big decimal values is absent and you had
kind of a strange rule which is if one
is present but the other is absent then
the absent one should be considered zero
okay on the other hand if they're both
absent then return and empty optional so
so that's a little strange
but that was his use case I'm not going
to say whether that's right or wrong so
somebody came up with an answer which is
oh I know
let's stream the optionals and then
filter and then map and then reduce them
it's like okay wait what does this do
again and you really have to understand
the API as well in order to figure this
out I mean it's not the right thing and
in fact when I was going through the
slides earlier I said wait a minute
there's a mistake here oh oh wait no
actually that is right all right so it's
it's really hard to understand and as
well as I understand the the Java eight
stream API is and stuff I still stumble
over this what it relies on is the
single argument the single argument form
of the reduce method actually returns an
optional of what it found what what the
results of the reduction anyway so I'm
not going to go through all the cases
here it's too complicated and it's like
wow this is clever it allowed you to
avoid writing in this statement but you
know when somebody writes clever code
it's it's it's one of these things
that's that's that's too clever alright
so here's another answer and so what
happens is people sometimes get into
this code golfing thing when they say I
can solve your problem in the fewest
number of characters and so here he says
oh let's map the optional and then in
the in the mapper function let's map the
second optional and then chain a few
methods on to that extracted map again
and then say or else the second one and
it's like wow in order to understand
this I actually had to pull out a sheet
of paper and write out all the cases
this guy this guy's really clever
but you know I encourage you if you want
to if you want to figure out what this
does do the same thing I mean if you can
do it in your head
great I can't a lot of piece of paper
and run through all the cases of two
inputs being empty or present or absent
or present and verify that you get the
right result according to according to
the problem statement here I pretty much
believe it's correct but boy this card
is this code hard to understand so
here's the way I would write it and it's
not the prettiest code but it kind of
says exactly what what the issue is if
neither is present return optional empty
otherwise
add some together substituting zero if
one of the optionals is empty so to me
that reads much nicer and it's easier to
understand but it did lead me to rule
number five it's an optional chain is
nested or you have an intern or
intermediate result of optional optional
of T it's probably too complex so don't
write code like that alright so there's
this actually this is thirteen a TN into
the bike shading a little bit but
there's this problem with optional dot
get and so and yell like along are asked
Brian gets the Java Java language
architect in interview a couple years
ago what he thought the biggest mistake
he made with Java eight was and he said
optional dot get and the problem is and
the way he termed it wasn't attractive
it was an attractive nuisance and get is
such an obvious thing to call on
optional yet it leads you down some some
pretty I mean it leads you into making
choice I should say it misleads you into
making poor choices so it's a lot less
useful than then a really short name
like get would indicate you can forget
to guard it right remember one of my
earlier rules is never call get unless
you can prove that the the that the
optional has a value present so that
leads in turn people who are aware of
the problems with get writing code all
around is present and get but they're
usually much better alternatives like
those nicer methods like map and or else
and filter that I talked about before so
really using get kind of tends to lead
you in the wrong direction and so what
we would like to do is eventually
replace get and there are some
complaints about that we wanted to
deprecate get and it caused too many too
many warnings but so get is still there
in jdk nine we may take a swing at it
again in jdk ten but get is not really i
mean yet it's such a fundamental thing
but really try to avoid using it as we
can
right there a bunch of places where
people use optional where they really
and it's not you know it's I'll come out
and say they really shouldn't do that I
think there's there's a way to over use
optional so one of the things people do
is they say well I have an object with a
bunch of fields in it and some of those
fields might or might not contain values
ah therefore I should use optional and
it turns out that there are much they're
often much better ways to represent the
absence of value if you're designing
some kind of data class often something
like a null object pattern is is is a
really good way to do that or you know
sometimes you you know what value are
you going to use so just fill in its
replacement value yes if it's absent or
or actually it's not so bad to have an
actual nullable field as a private field
of an object because you can control
where all the uses of that field pretty
easily when it when that reference goes
outside of your class then that's the
time to start worrying about this is
nullable do I want to tell all my
clients they have to check for null
that's the time when you when you want
to talk about using optional instead of
using optional in your internal
representation so another thing people
do is they say optional oh one thing
that Java doesn't have is optional
program option ulm ethic parameters so
notice where there's a shuttle subtle
shift here I want optional method
parameters therefore I'm going to use
optional well they're really talking
about different things so this notion of
optional method parameters doesn't
actually exist in Java does exist in two
other languages but it's basically you
know the ability to provide or not
provide arguments to a method call
whereas the Java dot util dot capital
optional is a class and so those don't
really fit even though they have the
same name and so the reason you don't
want to use Java util optional to try to
emulate optional method parameters is
that it really
garbages up your call sites so you can't
as a caller you can't leave out a
parameter that's required instead what
you have to say is optional dot empty or
if you actually want to fill something
in there you have to say optional done
of some value and that just adds a lot
of clutter to all your callers so it
doesn't really fulfill this notion of
optional method parameters at all and
then there's another place where where I
see optional misused sometimes which is
has elements inside of a collection so
like a list of optional of customers or
something like that people store that
away somewhere and you know it's you
know it's beyond the scope of this this
talk to talk about that but are you're
representing something it's like why are
you it's just kind of a funny code smell
why do you have a list that contains
things that might or might not be
present why are the empty ones in there
at all and if there are no empty ones
why not just have a list of customers
that makes perfect sense
so usually when there's optionals in a
collection I look at that and say you
know if you if you if you look beyond
that there's probably a better way to
represent that in your application and
optional kind of doesn't buy you
anything there so anyway rule six avoid
using optional and field method
parameters and collections all right a
little bit more on fields here so
optional is a box so we have like the
Box primitives like Capitol integer and
capital double and and and so forth so
those are objects as compared to
primitives which are very cheap so an
optional is a box around a reference and
so it's a lot more expensive than a
reference and so you can if you overuse
optional particularly if you use
optionals in collections or in field
then you can without realizing it
greatly increase the amount of memory
your application consumes and have
caused GC to cur a lot more often so
forth also if you want to get the value
out of an optional you have to do a
dependent load so if you have a
reference
dereferencing it directly you have an
optional that contains a reference so
you have to make one hop into the
optional and then another hop to to get
to the actual object and so if you have
a lot of those things if you have one of
them big deal but if you have a mil any
of them in a collection and you want to
reverse them you've probably created a
million extra cache misses and that
really is going to slow down your
program so so if you use optional very
frequently or in data structures that is
probably a thing to avoid and I think
what leads people into this oh I can use
optional in all these different places
is that people think that optional is a
replacement for null and they go around
their code saying everywhere I'm going
to use null I can replace it with
optional and that's not true optional is
not intended as a replacement for a null
reference again optional is narrowly
focused on the problem of a return type
that might or might not have value all
right now I'll get into a little bit of
the history about the bike shedding in
the open JDK mailing lists where
optional was discussed as in the design
of JDK 8 there were an enormous number
of emails about these they went hundreds
and hundreds and hundreds of emails that
we called these sent to thread and they
raised a lot of issues and for something
you know which is conceptually so simple
optional can need to be present or
absent there are a remarkable number of
different design decisions you can make
so all of these questions were asked at
some point or another the idea of bike
shading came in which is okay so we make
design decisions about how we're going
to design a class and somebody says oh
no you shouldn't do it that way you
should do it this way instead and over
and over and over so the fact is in JDK
8 we ended up with optional that has a
particular design particular design
decisions and unfortunately those
decisions are not to everybody's liking
and there are some things we can do we
can fix it by adding some methods we can
maybe deprecated get that might improve
things but there are some things that
you know that are not going to be the
people's liking and so I'm going to talk
about a couple of them here one of them
is optional is not serializable and this
so in jdk eight the java.util optional
class is not serializable and this is
particularly irksome to people who are
using lavas optional in fact the the
project lead of guava was on the expert
group for Java 8 so in fact the Java 8
optional was descended from guavas
optional so there's a lot of the same
thinking going on there
however lava is optional is serializable
whereas the JDK S is not and the reason
for that is I'm going to have to
compress this pretty highly but we have
this thing that we've been working on a
pipe called project Valhalla where we
want to introduce the notion of value
types value types do not have any
identity and if you look at
serialization in any detail you realize
that it is tightly bound into the notion
of serialized things being objects and
when you see realized something and
deserialize it you get an object back
and an object inescapably has identity
and in project Valhalla we want to have
values that do not have identity and so
making optional serializable will
preclude us from turning optional into a
value type in the future so that's what
we're that's our thinking on this but
mainly and so you can see this in the
disclaimer in the Javadoc if you
actually go look in Java 8 it says that
has this word but basically the rule is
avoid using identity sensitive
operations on optionals and so basically
don't use reference equality with
optional alright so here is here's a
little more probably too much detail on
serialization I'm not going to go
through this I'll post the slides later
you can look through this in detail but
this basically says when you do but when
you deal with serialization this binds
you firmly into the object space and
everything in the object base has
identity all right why not use optional
and field so I talked about this
somewhat before I think this is a style
issue some people would like to do that
and if it makes sense for your
application and it performs well and
it's not a problem I guess that's okay
I'm not going to tell you you're wrong
if you want to use optional infield but
it kind of tells me that there might be
something else going on as we already
talked about the memory overhead and
again this idea that I think some people
want to avoid using nulls at all cost
and so well you know I think that's
trade-off that you have to make if you
want to avoid nulls by creating optional
objects everywhere and doing extra
pointer dereferences using extra memory
and probably even cluttering up your
code tomorrow you know I think the
trade-off that you can make if you want
to but it's not it's not a choice that I
would make myself personally yeah and so
there's some discussion on this on the
on the internet there are a couple
people who are quite vocal about this
steven kolb ORN wrote a blog article
called optional a pragmatic approach and
he goes through a number of a number of
scenarios we have some generally good
advice on fields his recommendation is
if you have a field that might or might
not contain a value just use a knowable
reference and in your API if you want to
return an optional at the point where
you return it is where you create the
optional I think that's a very
interesting approach it's a pragmatic
approach as he put it but I think
actually one thing I did forget to
mention which which that point brings up
is think about your internal
representation differently from your API
the optional construct is an API
constructs it's useful for API return
values but that doesn't mean you have to
use optional in your internal
representation so Stephen has a good
example he says use null inside optional
outside I think that's good advice so
another another reference I have here is
to an article by my current who is here
at this conference he's giving a talk on
his checkers framework earlier and so
here's a link to that article and in the
checkers framework he has what he calls
an ulness checker and so if you have the
idea that you want to get rid of nulls
throughout your code you should probably
take a look at this
because as I said as I said before
optional is not going to get rid of all
nulls in your program it only is focused
on a certain portion of the use cases so
here I say the glass is one-quarter full
right so optional is very useful for
return types but it's not useful for
optional method parameters not useful
for fields not useful for this that in
the other right so okay I think so the
glass is one-quarter full for optional
it's really useful for return types but
you know it's useful for that use it for
that all right so that brings me to the
summary and conclusion here again a
restatement of the design goals of
optional a limited mechanism for return
types where there's a clean clear need
to represent no result and where null is
likely to cause errors all right and
then here the seven rules that I went
through during the beginning I'll leave
these up for a while if you want to take
a look at that and looks like I have a
few minutes for questions so if you have
questions they're mics at the front of
the aisles here the front of the room
there any questions
quick question um to share some of the
possible names for the replacement of
debt ah where did you have any yet no I
I think naming okay so the naming is
hard I think I did have a replacement
which I don't want to say because then
we'll just react to it I propose the
replacement people reacted the
replacement and then that that caused
another by trading argument to spin off
but if people have suggestions well
maybe I shouldn't say this but if people
have suggested tweet him to me
oh actually I forgot to mention I'll get
to you in a moment sir
in the upper right corner of the slides
there's a hashtag if you want to talk
about this on Twitter I'm on Twitter you
can tweet to me on that hashtag I'll
look forward after the conference or you
can tweet to me directly
so yeah question we eventually get
India's empty method if you and key
method for optional oh that's a good
that's a good point because sometimes
it's inconvenient to test for not is
present I think that's the main thing so
it's a little bit of kind of API
syntactic sugar I think you know maybe I
think the thing is if you you know we
need to be bunch of use cases where if
it's over and over and over this is
causing a lot of clutter maybe we could
add it but generally it doesn't it
doesn't add anything fundamental that
you couldn't do using you know not is
present so maybe I know there are other
places in the API where we do have it I
think we have object shot is null and
object non doll or something like that
and those are really useful for method
references so I mean that's a
possibility but it's kind of it's not
not the not the most important thing at
the moment question so my question is
regarding rule number two if you can
prove that the value can be no why would
you even use optional oh okay well so
the again if you think about how
optional is used you're calling some
method somewhere else and it returns you
an optional and so what that method is
telling you is there might or might not
be a value present now
one way to prove that a values present
is to call is present on it and check
the return value but there are other
cases where like in the streams API it's
a little too complicated for me to hand
wave and I don't have the I don't have
the code handy but there cases where in
the streams API some of the methods
return an optional of something but if
you set up your data structures in a
particular way and you are absolutely
certain that that optional can contain a
value and there's no way it can be empty
then go ahead and call get on it but
what you have to do is you have to make
a global assertion about your data
structures in the state of your program
before you can do that and so sometimes
it's straightforward is calling gap but
sometimes it's a global assertion about
your program so that make sense well
maybe we can talk about it after all
coming up with a simple example or
something thank you okay well Java ever
get a safe traversal operator base and
if we're chaining things together
oh love the Elvis operator ah yes the
Elvis operator um probably not I think
there were some attempts to do that in
project coin in Java 7 and there was
some effort put into them and they I
don't you know it's always hard to hard
to say why something didn't succeed I
think this is one where somebody said
all this Adobe ought to be really easy
they prototyped it turned out to be
really hard which is which is not at all
uncommon when you're changing the
programming language I think though the
I think there's this philosophy this is
kind of a philosophical point is as time
goes on we are trying to gravitate away
from away from things that tolerate null
so for instance that the Java 9
collected immutable collections that
that I introduced I'll be talking about
this in my session tomorrow
those are null hostile if you attempt to
put a null in one of those they throw a
null pointer exception and
kind of kind of the same with optional
dot of you try to put a null reference
into that it throws an exception and so
what we're trying to do is say okay
we know there are a lot of nulls out
there we want to avoid using them and so
within the boundary have you know have
safe code that doesn't doesn't deal with
nulls because and doesn't have to deal
with nulls and I think the thing about
the null safe traversal or the Elvis
operator is what it does is it
encourages nulls to spread all over and
every time you write that then it's like
oh well what if it's no now I don't care
I'll just use this operator and nulls
propagate everywhere until you get to a
point where you cannot deal with them
and and and then you're hosed so I think
I I don't think there's any there's any
impetus to adding null safe traversal at
this point any further questions okay
that looks like it thanks for coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>