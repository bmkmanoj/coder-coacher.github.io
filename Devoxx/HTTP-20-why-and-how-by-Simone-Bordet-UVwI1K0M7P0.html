<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>HTTP 2.0: why and how by Simone Bordet | Coder Coacher - Coaching Coders</title><meta content="HTTP 2.0: why and how by Simone Bordet - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>HTTP 2.0: why and how by Simone Bordet</b></h2><h5 class="post__date">2017-05-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/UVwI1K0M7P0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right we're ready
thank you for coming on this session is
going to be about HTTP to the protocol
hb2 is an evolution of the HP 1:1
protocol it's now 2 years old and it has
a lot of benefit will see the mall
during the presentation so let's start
my name is a simile bourdette I work for
an American company called WebP ID that
provides services and support for the
jetty open source project and server
container and so if you study and you
need support for that configuration
migration etc that's what we do
and by through our client we basically
fund the open source project let's go
into HP 2 which is more interesting so
the question here is why why there was a
need to go to http 2 and you know change
the version that has worked for us for
the past 20 years
well this is the reason this one is the
web 20 years ago and this one was the
w3c homepage in 1996 1996 was also the
year that HP 1 1 was actually specified
the ITF published the HP 1 1
specification in 1996 now this page is
one HTML page for 600 bytes it didn't
have an image no CSS at all
this was all browser stuff and so this
was the web 20 years ago and the
protocol that was designed 20 years ago
was designed to serve this kind of pages
fast forward to today and this is the
web of today on this page is from the
CNN about top chefs on this page it's
only this page is actually made of 215
HTTP requests
and maintenance most of them will be to
the cnn.com domain and in actually this
page weights nine megabytes it is 200
times more number of requests just to
make up the page and it is like a
gazillion times more data that you have
to download in order to to get this page
right so what happened well the fact is
that the web literally exploded during
these 20 years on HT p11 is a very old
protocol it is for today's web it is
extremely inefficient it doesn't have
any multiplexing doesn't have reserves
correlation and we will see during the
presentation what these two terms mean
and why they're so important web
developers are now hacking around a
cheapy one one protocol limitations so
for example things like domain sharding
or resourcing lining or image spriting
so how many of you for example have
heard about the main charting a few okay
who's using images spriting here okay a
few as well so these are considered best
practices now but they're really not
they're just hacks around a very
inefficient protocol it's a protocol
that it was probably one of the most
successful high-level protocols over the
history of information technology here
but still it's a protocol that has been
designed 20 years ago and we know what
does it mean for our field you know to
use the stuff that is 20 years old right
it's not even prehistory it's like it's
dinosaurs right so we don't want to use
a protocol there is this old two rounds
today's web also because it's not only
about you know technical things it also
results about human web interaction
human how the humans actually interact
with the web so we have this we are the
consumers of the web and because of
this we want this experience to be
really fast and satisfying for us so if
the website is slow inferring just as an
example that sign on page that I showed
you before complete the download of all
the resources in 28 seconds okay so if
we have to wait this much to actually
read the content that we actually need
that's not good so we want the web to be
super fast so much so that for example
things start to change really fast in
very importantly like for example
Nordstrom is a very big ecommerce site
online for North America especially they
sell clothes line mostly and so they
change they switched their strategy from
optimizing for IT cost mean we buy less
hardware or we optimize the hardware
that we buy into that's not important
anymore the thing that we really care
now is how fast we can deliver content
to our user it doesn't really matter how
much hardware I need to buy that's not a
problem anymore what I want is speed and
there is a very good reason for that
because the speed is the feature gives
you better Google ranking but not only
that it is a business issue faster
website mean more money these are five
studies that have been conducted in the
past they show a direct relationship
between how fast and how good is the
interaction with a website and how much
money do you make so for example our
shop deal another e-commerce website
they reduced the landing page from six
seconds to one point two they made 12%
more revenue 12% and 25% more page views
just by optimizing the website so if you
ask anyone okay are your goal for the
next year will be to increase the
revenue by 12% that's you know not easy
to do but you can do it technically
just make the website faster amazon.com
this is pretty amazing um they have
linked the fact that every time a page
shows 100 millisecond faster they make
1% more revenue so just to give you an
idea 100 milliseconds is a very short
time it is about at the edge of what the
human brain can actually detect when we
close our eyes that's 300 400
milliseconds so 100 millisecond is still
enough for the brain to feel that the
website is faster our brain computes
that and says oh it's faster I want to
stay on the website more and I want to
buy more stuff on this website because
it's really responsive and enjoy staying
here um another one is mozilla.com and
they shaved off two point two seconds
from the landing page of mozilla delorca
that turned out to be 60 more million
downloads of the file for Firefox
browser per year so again if you set a
goal at the beginning of the year and
say hey you have to make things in a way
that we have 60 millions more downloads
of the browser how do you do that
well kind of easily just make the
website faster so point being that
http/2 has been designed two years ago
um to cope with the modern needs of
today's web and it is it has been
designed from the ground up to actually
be faster better and with you know a lot
of future possibilities in a room for
improvement for the future so that HT
p11 is now relegated to the dinosaur era
we shouldn't use that anymore all right
so let's take a quick look at the main
features of the HP 2 protocol and then
we'll will discuss them so the first
thing is that finally HB 2 is not
anymore a textual protocol but now it is
a binary
protocol this is not much for the
end-user but for implementers like us
Gerry was one of the first to actually
implement the hep-2 protocol it is so
much better to implement because it is
much more efficient to parson generate
this is really really important because
he it allows implementation to be really
efficient and use less resources on
servers so the way it works is based on
frames so every time the browser wants
to send a request to a server it packs
the information the request method the
URI dhcp others it packs them into a
frame called the headers frame and sends
it to the server if it is a post upload
then it packs the content of the posting
to a different frame called a data frame
okay and then sends sense them to the
server and the server replies with
another headers frame but this time this
header frame contains the response
headers and you know the status code and
stuff like that and of course the
content that is related to the resource
that is being requested this one is
probably the most important feature for
HTTP to HTTPS way you open a TCP
connection then you send a single
request on to the specific connection
and then you have to wait for the
response to come back you cannot use
that connection anymore
once the request has been sent that
connection is gone if you want to send
another request you have to open another
TCP connection send the request on the
second connection and wait for that guy
to return
so now browsers open at most six
connections to a single domain okay what
does it mean it means that if you have
to download or make 215 requests to
render your page how does it work well
in HP 1-1 it works
this way you open six connection then
you send six requests they travel the
ocean until America are where the server
is based they come back then you send
another six they travel the ocean and
back another six and so forth right by
the time you arrive at 215 well 28
seconds have passed right so it's not
really efficient multiplexing solves
this problem because this is how it
works the blue pipe here is the TCP
connection but in a she'd be - instead
of sending just one request at a time
you can send multiple ones on the same
TCP connection okay and you know the
first this green pipes are called
streams in HTP - parlance and you know
this one was the first one that was
opened then we open this one and then we
open this one however the good thing is
that we don't have to wait for this guy
to come back maybe the processing of
this last request that we sent was
really fast on the server so maybe it
gets responded first but the client is
able to reconcile the these pipes and so
it knows that you know the responses can
come back out of order with respect to
the time we sent them and so but because
they have a unique identifier the
browser and the client can reconcile
this the responses and so you know
responses count King can back out of
order now the default configuration for
a browser is to be able to send a
thousand of these requests concurrently
so when you have two hundred fifteen to
send well that's not a problem I can
just open two hundred the streams send
all the requests together and then let
the server do its job big plus
another thing that hb2 does is header
compression so if you are familiar with
the HP protocol
there are constants that are typically
sent over and over as headers for
example cookies there are constant once
you get them from the server every
single request has a very long string
that gets sent over for every single
quest same goes with the user agent
string it's a very long string that says
what browser is it is what operating
system how big is your screen and stuff
like that but it's a constant okay and
every time you make a request to any
domain you're sending that constant so
what HTP do can do is compressing
deciders and say okay i'm going to
compress this information for the first
request so typical HTP 1 my request is
400 bytes of like a small one without
cookies and stuff um but in HTTP to the
first request is already 250 it's ready
less but you know all the next requests
can go back down to 10 bytes only 10
bytes why is that well because the
second request can say hey you remember
what I sent you before
so rather than sending the whole string
again what it sends is just a single
byte that points back and say hey this
is you know remember the first wonder
that I sent you this is a pointer to
that particular string so I don't need
to repeat the string anymore I just use
a pointer to the string all right so
basically from the second request on and
just sending pointers and the requests
are really really small the last big big
feature are of HB 2 is called HB 2 push
let me explain with the diagram how it
works so this is HP one one typical
interaction to render web page we make
the request for index dot HTML ok
the HTML comes back arrives in the
browser the browser starts to parsing it
while it's parsing it it discovers a I
need a javascript and CSS to be
downloaded okay well these are two
resources I can open two connections and
you know send them in parallel those
resources come back the parser needs to
parse them again and then it discovers
that the CSS contains a background image
and so it has to make another round trip
to get the image so in order to render
the simple page we need three
round-trips again if you are in Europe
and talking to a European server that's
fine the server is in the United States
it's okay it's a hundred 150
milliseconds if you are in Australia the
mean latency to a server like everywhere
in the world is 200 250 milliseconds so
this page is already about one second
super simple page but it's already one
second all the time is actually being
spent by TCP packets traveling the ocean
it's not really computation stuff here's
you know serving static files and stuff
like that so it's very quick but the
time that explained is travelling across
the ocean so there is a thing though on
that it's lacking in HTP 1:1 now if I
ask for index.html and then this page
contains these resources then what I can
do is create a correlation between the
primary resource the HTML and the other
three and say well these resources are
secondary and they always go together
when I ask for you know the index.html
I will need also these other three so I
can group them together into what is
called a push cache right then I can
come in with an HTP - browser and the
server has push enabled and now what I
can do is this
I can make the request for index dot
HTML but then the server says Oh
you need index.html but you're going to
need the CSS the JavaScript and the
image as well because that's what's
needed for you to render the page and so
the server can just push down the HTML
the JavaScript the CSS and image all
together alright and so this goes into
just one one roundtrip so the rendering
in hb2 is three times faster that's it
so this is what the web needed it needed
a way to correlate resources together in
order for the server and the protocol to
be able to say hey I know what you need
here's what you actually need to render
this page alright and so give back all
these resources shaving off the round
three time which is the big problem for
today's web it's not about speed of
internet connections internet
connections are really fast even on
mobile not a problem even if i download
nine megabytes of data that's not much
what really kills me is going across the
ocean right so that's super nice
theoretically but how does it actually
work
so let's demo it and let's see for
ourselves how it actually works so
here's the name so what I've done here I
have artificially slowed down the local
host interface for this demo to simulate
a 200 millisecond delay for the
roundtrip all right so the page that is
going to come next is a page that is
composed of 24 smaller image that
compose a larger image okay it's only 24
I didn't go as far as going 200 of those
just 24 alright so if I find my mouse
and click here on HP 1 1 this is what
happens click
okay so what happened you've seen that I
clicked the connection was established
then a few images were coming down very
slowly and then the last images were
coming down a little bit faster so this
is actually a feature of the TCP
protocol called slow start so every time
you open a connection you're not really
a full speed because the connection
needs to be warmed up all right
and once it's warmed up well it's faster
and so if I now reload this page well in
the browser didn't timeout the
connection so if I reload this page you
can see it's slightly faster because the
connection is now being warmed up okay
but still you see actually all the
images coming down and composing the
larger image so this is how HP 1:1 works
and if I open the console here and I go
to the network tab and I reload this
page this is what you see this is a
typical profile for resistant scrolled
this up so there is a first request for
the index dot HTML and then Chrome in
this case open three connections to
download the first three images but then
you see all this grey area here this is
time spent waiting for those three
connections to actually return the
images so I cannot ask for the next
three images until the first three have
come back and so forth with all the
others it's it's a stair like waterfall
stuff okay this is how hp1 one works so
let's close this for now okay
click good what is that ice up there
maybe
okay so let's go back and okay okay so
let's try now the magic right so suspect
to be faster so click it's immediately
faster okay we haven't seen those slow
stars stuff anymore the reason is that
HP 1hp 2 is much more efficient at using
tcp features and you know the space
already renders faster but what happened
though that the server now has a
correlation between the primary page and
all the images the composed up page so
if i now reload this page now i get all
the resources to be pushed down to the
client and so if I reload this page I'm
gonna say this like click you don't see
the Refresh anymore right it's not like
before you don't see it anymore because
it's so fast and again click that it's
there boom okay so remember the slide
that I gave you before this is money you
doesn't have the look of money but this
is actually money for your business
because this fast people stays on your
site your business is going to make not
10% but like a lot more
it's just joking but you know this gives
you an idea of what does it mean to use
a dinosaur protocol versus a modern
protocol that has been designed for
today's web 2 years ago this is the
difference now if we look at the profile
for this let me go again to the network
tab here
and reload the page all right so let me
just move a little bit around Algy I'll
be off camera but the unit just to show
you so what happened was this there you
go
so the first request this is connection
establishing then this is the download
data so the first request came back for
index dot HTML but the server figured
out oh but you also need 24 images to
compose your page right so here the mug
and so you don't see the other 24
requests because there are no requests
it has already been pushed everything
has been pushed on the first round trip
and so when the browser sees and parses
this HTML page what does it do it says
ok I have an HTML page or look there's a
pointer to an image I should fetch their
image from the server but before I do
that let me look at it's already in the
cache and then he looks in the cache and
said oh but the server already pushed
this image to me so it's here already
let me use it so I don't make the
request anymore because I already have
the image in the cache and same goes for
the other 23 other images and you know
boom your page is there already so big
improvements um there's no there's no
reason to stay on a ship e11 anymore
alright so let's switch back to the
presentation which has gone back at the
beginning but smooth forward ok so I
hope that by now you're convinced that
HTTP 2 is the next thing that you have
to do Monday it's it's not anymore it's
not a technical thing well it is a
technical thing but it's also a business
thing ok this stuff
has a direct correlation with money with
your business so you don't want to be
beaten by your competitors because you
stay on a 20 years old protocol you want
to be on the edge and the protocol is
already 2 years old everybody supports
it and so you want to go back to your
jobs on Monday and you know start
thinking how do I deploy hb2 for my own
website and so let's see how so um what
is it that is required every time you
need a nature p2 browser to interact
with an HTP - server you need the TLS
TLS is SSL okay so you need HTTPS on
your website if you don't have that
already well then it's not good because
Google ranking takes that into account
if your website is over TLS you have a
higher Google ranking so you should
really go to TLS well that's a good news
because you used to be that you should
pay for certificates right you should go
to a certification Authority and pay for
a certificate something like hundred two
hundred dollars per year but turns out
that now there are certification
authorities like let's encrypt it gives
you certificates for free so if you have
a nonprofit organization or even your
business company like our own website
web daikon is using let's encrypt
certificates and it works like a charm
so on the issue of buying certificates
it's a known issue anymore ah you know
it's 2017 things improve um however the
protocol is flexible enough that if you
use a shippi - on the back end
then you don't really need to be
encrypted if you are within your data
center then you can use ACP in
clear-text hb2 in clear-text
however you must verify that all
intermediaries allow ACP - this means
for example load balancers ok you need
to make
sure that your load balancer is hb2
enabled or that it does support HP - so
typical configuration for for the Java
development or deployments are browser
apache or nginx as reverse proxies and
then calling back into tomcat jetty or
you know undertow wall fly whatever this
is used to be like a standard
configuration
it's an old the configuration it's a
configuration that is good for it to be
1:1 but not good for HP - the reason is
that the browser can talk to HP - to the
front end but nginx
and Apache can not yet talk HCB - to the
back end
they were resorted to to go back to HP 1
1 so let me tell you a war story about
this we have a customer they use a study
that had this kind of configuration now
the problem is that on this front side
they were getting thousands of requests
per seconds this means that these guys
in order to fulfill those requests and
had to open many many many main
concurrent connections to the back end
in order to fulfill the thousand
requests per second on the front end but
if you open these many requests what was
happening was happening that the back
end server were killed by the TCP
overhead of opening those connections
and keeping them open and stuff like
that instead if this traffic was a CP -
you would be able to open just one
connection and multiplex all the
requests into that one single connection
that means a lot less resources you can
buy on Amazon or you can fire up another
zone smaller machines because you don't
need all the resources that you are
needing before so that means again
saving money for your business alright
because you need to pay less for Amazon
so typical good configuration is this
one that we recommend using H a proxy
but is it proxy is an example for
example also the f5 our load bouncer
supports this configuration so what you
have here is basically HB 2 encrypted
from the browser to H a proxy HT proxy
performing the TLS offloading and then
talking to jetty in clear-text HB 2
within the backend right this is a very
good solution because in this case your
application which is here it is now able
to use HP to push because the protocol
that is talking is a CP 2 before it
couldn't because this protocol here was
a CP 1 and so even if the application
could push data down to the client
the protocol wouldn't allow it and so
you know you're stuck with a dinosaur
configuration for no reason
so upgrade this is a good way to go
there are other solution my point here
is you know you have to go back and
study what do you have what is it that
you need to upgrade on the Java world
jetty 94 we have a server and client the
supports HB 2 we we run live on web tied
akan but also Tomcat the HP -
implementation for Tomcat has been
written for Duncan 9 but has been back
ported to Tomcat 8.5 while fly 9
under-21 394 ok HTTP is a client only
for Android so you can use it if you
write Android application you can talk a
shippi to with servers the good thing is
that for Java 9 there is not only
modules but but also there's a few
improvements for HCP 2 in particular
there's a new HP client and this has
been moved to the jeddak incubator so
it's not really part of JDK 9 but you
can find it in the incubator
and there's also support for server 4-0
will support hb2 and a bunch of feature
so servlets will have AP is that allow
you to programmatically push resources
so for example you can have logic that
does that something like oh if the
customer is a gold customer then push
the data and make his web experience
faster but if it's a guest well then we
don't bother pushing something like that
right
so um JDK 8 is required so upgrade JDK
if you're not made angelically 9 as a
support for a very specific feature
called a LPN which is a prerequisite for
HP 2 to work it's kind of a low-level
detail but it is in Jericho 9 so if
you're playing with implementing this in
in Java ah it's it's there and we have
already implemented it its life since a
couple of months and so we have tested
that this support for a LPN works in
Jerry canine we have already implemented
it and so yeah this is the new API
available that has been added to Jerry
canine order to support al p.m. so again
Jerry provides a pure HB to client it's
very easy to set up so this is how you
would use the 1:1 client and this is a
one line change that you need to make in
order for the jetty HTTP client to speak
ACB to you just change the transport to
be the one that uses hup-two so all good
right um
but this wouldn't be a keynote if I just
gave you good news there are bad news as
well on HP 2 and so on what are the bad
news about HP 2 well 2 years of past and
so now we have a little bit more
experience of how HTTP works in real
life so let's see this one is a web
title calm web site
right from crumbs in from Italy to
United States and back your renders in
less than one second in HTP one one okay
so you see here the where the grey lines
are waiting for resources to come back
it's not pretty
okay yeah so let's go to hb2 now your
renders in less than 600 milliseconds
it's already 30% faster and so look at
the profile for the resources that have
been asked they all start at the same
time so I asked for the HTML comes back
parse the HTML figure out that I need to
download maybe a 30 something resources
here Oh send them over to the server
okay and all together then there are
some that are really fast and come back
very very very immediately some are
longer to compute on the server but
that's okay but if I use Firefox instead
of Chrome are things don't go that well
anymore so this is due to differences
between implementation in the browsers
so chrome is probably really efficient
Firefox a little less but wait because
that's not the end of the story um well
there's edge of course so we can all
start making jokes about Internet
Explorer or edge browsers for Microsoft
so it's even worse almost a second but
there's a big one in here so we tried
Firefox which was the slow one from
Australia and Firefox is actually
consistently better than chrome when the
latency is higher so what you see here
is a trade of an engineering trade-off
that the Firefox and Chrome implementers
have taken and summer says ok I prefer
to you know be able
to cover this use case better than the
other one so measure yeah as I say big
difference between implementations and
you know relatively new protocol there's
a lot more that we need to figure out
about HP - let's ask it listen what is
the good thing about HP - is one
connection per domain which is very
efficient at the TCP level we've seen
this multiplexing the demo was you know
awesome but what is the problem if we
have packet loss and that single TCP
connection goes down and you have 20
outstanding requests on that single
connection now suddenly you have failed
20 requests while in HP one one you had
six connections maybe one experienced
packet loss you still have five good
requests that will come back and you
just lost one now here it's it's a bit
worse so you see fastly is a CDN they
have an awesome presentation at this URL
where they present the data that they
experienced and so what happens is that
when they measured on HP two versus a
should be one in packet loss conditions
then they turns out that HP one this
downloader protocol is still a little
bit better than HP two so not very good
so what is the solution
well Google there was the initial
proposal for speedy before and then HP
two came up with another protocol called
quick quick UDP intimate connections now
they're not using TCP anymore over the
Internet now they're using UDP and this
is a number of benefits because now they
have designed this protocol to have zero
round-trip connection establishment like
you don't need ignore the three-way
handshake that you have with the city it
has built-in crypt
features and it can do connection
migration for example if you have your
mobile phone and you're downloading
stuff and you happen to cross a cell
boundary where maybe your IP address
changes well with quick you don't lose a
single byte while with disappea there
would be a broken connection because
your IP address changed and so you have
to restart the download but quick has
been designed to support this connection
migration feature what is the present
problem with this is that this single
protocol now has transport cryptographic
and application concerns everything in
just one protocol and there's people
like Paul Henning camp which is the guy
behind varnish the powerful cache that
says history of protocol design has
taught us that we layer protocols on top
of each other we don't mix them together
and so you wrote an email where we're
saying what do you think about quick and
he said well I recoil in horror so not
everybody likes quick plus it will be
very I mean D effort to implement will
be especially in Java would be quite
large so let me wrap up the ski note
where I really hope that I gave you new
ideas to try out on Monday that was the
whole point of the keynote conclusion is
that web developers typically don't need
to do anything ah the ATI that they're
using will still work with HP to our
application we'll be able to leverage
new features if you want to use them you
don't have to do any more HP 1:1 work
around no domain sharding no image
spriting all that and it's not needed
anymore on the deployers the people that
actually care about the data center they
have to be a little more aware of what's
going on they need to implement TLS so
you need to have in your company a
process that renews the certificates
every three months or every year so if
you don't have the process in place
already you I have to have it because
otherwise your domain expires and it's
not good you have to upgrade your server
container and you have to upgrade your
network infrastructure for example load
balancer and stuff you have to verify
those so very good news are a modern
protocol
please teach hiv-1 or think about
ditching hiv-1 one and go to HP two
because thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>