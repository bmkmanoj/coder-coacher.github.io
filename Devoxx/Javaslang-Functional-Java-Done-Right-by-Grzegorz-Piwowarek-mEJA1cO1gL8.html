<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Javaslang - Functional Java Done Right by Grzegorz Piwowarek | Coder Coacher - Coaching Coders</title><meta content="Javaslang - Functional Java Done Right by Grzegorz Piwowarek - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Javaslang - Functional Java Done Right by Grzegorz Piwowarek</b></h2><h5 class="post__date">2017-05-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/mEJA1cO1gL8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">una dua okay looks like um we are ready
to start
okay so first start I'd like to
apologize deeply to all of you because
there was a serious mistake my talk is
not called the Java trunk functional
Java done right but waiver functional
Java done right so deep apologies go to
Oracle because we have nothing to do
with Java slang I don't know if you all
know the story but recently Java song
was forced to change the name world to
waiver because of some legal issues
basically the having the Java word in
the name of your framework was let's say
controversial and since we had quite
quite a nice stickers
Daniel Dietrich the owner of the project
turned off opened his laptop come in
coasted and so that actually when you
look at Java upside-down it's supposed
quite like a waiver well if you replace
ace with lambda so this is how the name
originated from and yes basically we are
talking on about something that used to
be known as Java songs well so actually
defined the nice thing was that we had
satellite speakers and now you could
like basically just cut the waiver out
of this end would work well I came up
with my own proposition and created Lala
length from three free speakers but for
some reason no one treated me seriously
okay so I'm I'm Gregor's pure verdict I
work in Poland in a software house
called talk besides this I I'm a retired
CIA player yes
that was a thing and well I retired
musician as well yes that used to be a
thing so if you want to find me anywhere
you can find in me using this Twitter
handle will get cap handle Instagram
handle LinkedIn handle and some other
size that I probably not mention would
not like to mention publicly
okay so let's go to the to the talk
globba 8 release happened well three
years ago exact well pretty much almost
exactly four years ago and it was very
special release well first thing is that
we've been waiting quite a long time for
new release the second thing is that it
promised us some new tools some new
tools to play with known from other
world other world of functional
programming like lambdas optional
streams so the excitement about Java 8
was quite quite a huge one okay so
everyone was very excited but after
playing with Java 8 for a while people
started noticing that this functional
Java of obviously it has lambda
expressions well-nigh syntax for lambda
expressions because you still were able
to pass behaviors in the past using
anonymous inner classes um we got also
tools like optional stream compatible
future and actually not much more so at
some at some point people starting
starting and started noticing some likes
and complaining
some people were also complaining that
even some very basic operations well
could have been much could be done much
easier ok because we got rid of some of
the boilerplate but well there is still
quite a lot of boilerplate to do with
given with such simple operations as
netting through our elements in a
collection so basically people started
complaining about that in Java we got
only free functional control structures
with namely optional streams and
comfortable future and if you have other
I have no idea what this is
so in other function languages you had
much more tools like this ok there in
Skype I have try either in has because
IO monitors and other stuff well why not
bring it to Java 12 I don't know I am
NOT you to
this question the other thing is a very
nice feature to have is memoization
which is basically a form of caching on
on on some functions there is no signal
as a function lifting there was no
subscriber anticipated pattern matching
um
no typos even after many years we still
if you want to have first our tuples we
either need to implement them by
ourselves or use one of hundreds get
projects on github the other thing was
that optional for some reason were not
realizable nor iterable the official
explanation for this is well it very
good but not very convincing because the
explanation goes like states that it's
not selectable because it was not
intended to be okay so the other thing
is well the biggest problem for me
personally person personally was that
there was new tools introduce you a new
API but since Java you need to be
backwards compatible we ended up with
situations where we had some API is
using like some legacy conventions and
some new using new ones for example in
one classes we would have a method that
would return optionals and another would
return just naked
objects it could be it could be knowable
and this is a problem okay because if
there's lack of consistency in happies
and it creates problems
another very cumbersome thing was to
deal with directly exceptions in run
diffraction exam the functions
I'm not sure if you realize but if you
have a look at functional interfaces
provided by Andrade okay you will see
that those methods inside they don't
have any pros cross it create a problem
because now if you want to create a
lambda expression with a body well and
call some method in a body that will
produce a checked exception it's a
problem because now you need to manually
dress try and catch it and you really
just swept it under the rule
under the carpet well usually basically
either just repackaging an exception to
a random one or just just ignoring it
well it can be really painful especially
if you have like a very long stream art
with a very long strain and yet imagine
that in every basically in few of them
you have methods that can throw an
exception and from your point of view
you might be interested only in the fact
that the whole stream resin exception
okay you are not included you don't care
about every single like the part of the
stream okay it's important if there is
any exception well it's a help because
you need to put try catching in every
step so yeah this could be really
painful the other thing is something
that people call type pollution um if
you go if you can look at functional
interfaces in JDK you will see that
there may quite a lot of new keywords to
remember a period or you have function
that represents a simple generic
function well if your predicate for
functions that return bullion's you have
consumers for functions that don't that
return void you have suppliers by
consumers unary operators binary
operators by functions and the list of
names keeps keeps growing okay
so at the beginning if you and you get
even you get when you familiar with the
API it's problematic okay because
suddenly instead of a faction function
you get something that's called binary
operator and you have no idea what this
could be so of course the other it could
have been like the names could have been
organized in such a way that he it was
more intuitive the other thing is that
the thing that I mentioned before is
that even some various into operations
were still quite quite boilerplate heavy
and could having done much easier well
obviously the list of all blank slack
from the functional point of view is
much longer but let's stop on this point
and go
further but before we jump straight into
Java Franco sorry guys waiver let's have
a look for a second at this nice short
method signature let's burn a minute or
two well let's pretend that those two
minutes are over so when we look at
method signatures well we can notice
always like three or four things we have
some list of arguments we have type that
get returned there is the name of the
function and names of the parameters and
when we see all of the all of this
information we have some already we
already have some intuition about what
could happen in the method itself well
so now I think looking at this you might
think that well I might be returning the
same list I might be for example
processing all those elements in that
list maybe upper casing all of those
strings maybe maybe adding some other
strings those three that are already
there
well the problem is that that Java
language allows us to make things very
unpredictable in some pockets and points
so let's go look at my implementation so
this is what I what I made as you can
see here a lot of weird stuff is
happening over there because as you can
see over there
I'm checking I'm using internal state
for making the condition I'm throwing an
exception which can be seen as another
exit point of a function
I'm modifying current state I'm adding
some Constance's come from the upper
world
I'm modify I modifying global State
notifying local state put about mutating
everywhere everything around and
whatever is possible
and now imagine situations were where we
need to debug source stuff okay it can
be well it can be real problematic and
but the biggest problem is that if you
compose your solutions from
unpredictable building blocks well it
all adds up and
you end up with a big pile of
unpredictable code so what we have here
we have sway we have the list of what
actually when you look at methods so we
need to look at them not only at stuff
that we see okay because here we can see
only so we have released of params we
have lists of return values names and we
can't base our assumptions or what
happens inside only after this
information because there it is that we
should consider an input or arguments
all possible situations that code like
influence the outcome of the function so
in this case all potential input that we
have skew is of course declared perms
but we have also instant state and
global state they all can influence the
results that we get and when it comes to
outputs its there are even more
possibilities because except for value
that did the declared value that gets
returned
you can mutate an instance state that
will influence the that will be an in
potential input of another method okay
and you will mutate also global state
that can be another that can influence
something else and end up with a big
butterfly effect basically well also we
have of course you can mutate params and
throw exceptions which are obviously at
some point of return value where well
indicated not declared explicitly so now
let's imagine situation if we have only
declared params as all potential inputs
and all need declared return value as a
potential output this is the situation
where basically when we know the input 0
and when we know all of those blocks it
can become a totally predictable ok we
can compose our solution from small
blocks very predictable blocks and and
this is and when we compose them there
are too much big chance that it will
eventually work without any additional
problems so there is some common
misconception that function up that the
presence of lambda expressions and
language some somehow
make it functional it couldn't it could
be it could have been seen when the
Worman they were discussion from method
reports regarding JDK 8 and when well
many people were stating that this
language is no functional obviously it
could not have been further from the
truth
um actually if you try to Google if you
try to find like a very nice definition
for the functional programming it's
actually very hard to do I mean I never
managed to like find like the complete
definition but I found a really good one
for for this particular talk so
functional programming is about writing
cue functions about removing hidden
inputs and outputs as far as you can so
that as much of our code as possible
that describes relationship between
inputs and outputs if we write code like
this we end up with we compile we end up
with stuff that usually is predictable
and and works on the first try so
object-oriented programming is about
composing composing objects functional
programming is about composing functions
and smuggling blocks that that work and
now if we deal with small functions
small predictable elements we mean my
potential spots where you can make
mistake okay since we are dealing with
strong static typed languages let's
leverage this okay and let's end up with
a code that has a bigger chance of work
telling us something is wrong without
actually running it yet so in order to
achieve such stuff there are two
concepts that needs to be the severe
cold one is imitability
and the other is referential
transparency immutability is pretty
intuitive it's about is when you create
objects and you can't modify them
afterwards of course it creates some
limitations it's it might be much harder
to program using you know objects that
don't mutate at all but there is also
much
you get you get original result from
this are that you get much less errors
the other thing is refresh or
transparency which is all about
situations where we have functions or
methods and if you call some method with
the same set of parents that sort of
parameters and you should always get the
same result
okay and it doesn't matter if what was
the global stir it was the instant state
was the moon phase okay it should always
be the same result well we have that
functions we can call them referential
transparent which means they are well
basically 100% predictable so I don't
see Mario here but many people many
people have some the misconception about
functional programming because people
say that well the real world is mutable
and has a lot of side effects so
functional programming can't remove all
of this and yet this is true function
programming can't remove side effects
and a little bit ability from a real
world but by leveraging strong static
typing and abstractions we can pretty
much encapsulate all of the stuff and
deal with it in such a way that we don't
deal with problems that meet ability and
side effects cause so functional
functional programming as you know we
could could we could pass behaviors in
Java 7 6 using anonymous functions oh
but it still well if it wasn't
functional Java right now we have nice
impact for it it's still not functional
well if you really wanted to use it for
example Google guava there you had some
immutable collections there some nice
API for some stream like API but still
it was super painful to program like
this well if you can if you want you can
program functionally without without
numbers and other stuff but
really hard to program functionally if
you don't have right tool for the job in
this case let's have a look at Java
collections API it's one of the basic
building blocks of Java and if you go
through all of the methods you will see
that methods like add remove clear at
all if you look at the return values you
will see that they usually either return
nothing or they return a boolean or
something else basically some metadata
is repeated to the result ok but there
is no he so this all suggests that the
whole collections API is mutable ok
because if you add something to this you
don't get a new list with a new element
but you well if you get a void between C
read the collections on the word on
which you call that method to get gets
changed ok so even if you want it so it
can be super hard to them if you want to
program using immutable structures it
would be super painful ok in guava you
had something like immutable list
imitable map and i don't know if you
remember what they were still methods
like as removed but what would happen
there they would draw instead of just
doing anything they would just throw
exceptions operations operation not
supported or something like this ok so
it was super uncomfortable for use and
it would create situations like well
this is very very famous case when you
program to have a stash set which is
immutable has a half set where you put a
mutable object inside well obviously
when you put something in a curse that
the hacker get calculated basing on the
current state of the object so if you
modify it after this you end up with
silly situations like well use
identities of those objects well good
luck with debugging this so this is
basically where waiver comes into play
this is waiver it makes look quite
complicated but basically this is just a
new collections API for for Java plus
set of tuples and new
functional interfaces there are also
some experimental features like pattern
matching but we'll get to that
so the when it comes to Java Zonk
sorry waiver there are three building
blocks of it there is the Samba which
will serve as a new new basic functional
interface will have tuples and the new
nighty interface of value representing a
container that can call the value or not
so when it comes to new functional
interfaces they are super predictable in
Java 8 if you have if you want to have
functions well function their faces with
more than two parameters unfortunately
you need to you need to define your own
well the other thing is they even
created if they provided functional
interfaces that have more than two
parameters it would be hard to remember
the names okay because its function by
function try function odd function Quinn
the cool functions
well my Lang English vocabulary can't
handle this well so when it comes to the
waiver it's super predictable okay
because you simply have one type of a
function you don't have by predicates by
consumers by unary Prague the binary
operator consumer suppliers and other
stuff crazy stuff like this everything
this is function okay you have functions
which have a number at the end of the
class name which denotes the rarity of
the function so if you are looking for a
function that has like seven seven
inputs you don't go for well seven top
you don't go for function and seven so
this is super super intuitive the other
super nice thing is that all of them
come with like add another additional
set of functional interfaces but checked
interfaces which have first clause in
the method representing the body of a
lambda so whenever we want to deal with
it we have a possible
using the Select function about function
instead and even if you want to convert
a trig function to function well like
you can do it in a very very easy
we're using some inbuilt static
functions besides this they all support
function composition which was actually
already present in JDK version of
functional interfaces other than this
you have listing which is super nice
come to concept which we'll get to in a
soon
there's occurring support of carrying on
all of them and memorization my favorite
one so let's have a look at lifting he
met in the world of mass a functional
programming come from the world of
mathematics so we don't have something
like exceptions okay if you have F f of
X equal to zero there is no option that
suddenly due to the weird do some more
phase something bad happens so here
whenever we have let's say we have such
function and we have here division ok so
obviously in this case we'll have well
there will be if you provide B as a zero
we'll have an exception but this is but
if you look at the types you don't
really see this information to this that
this equation could well this could
happen anywhere
lifting applying the lift operation
changes the return type of the function
so we perform a lifting and now we have
a function that returns
option in verbs our return result in an
option so we never have exceptions now
but in case when exception gets thrown
we get an empty optional ok so this can
be pretty handy well assuming if you
don't really care about the words or
what was in the exception the other call
quite useful see quite interesting not
that useful fingerings although actually
managed to you that once or twice is the
way in which we can represent the
functions of higher artists than one
if you have a function of a let's say
art it is bigger than one you can always
represent it as a function that returns
another function of a lower era T so as
you can see here we have function -
which represents summing we can easily
create a new instance converted by using
carried an instance method and now
instead of function two we get function
authority of one that returns another
function well it might look pretty
abstract but the idea is pretty simple
it called we are converting the function
in such a way that now we don't need to
provide all parameters but we can
provide them one by one it can be super
useful for deriving new functions based
on what you have already so if you have
your function in such a form you can
easily apply partial application so for
example now we can use a PI apply only
one parameter and basically we change a
function representing assuming of two
elements to function that always sums
one element to toe okay this is very
very basic example not very useful but
if you compose like bigger solutions
it's actually quite useful we had I was
building at my job the commence scanning
engine we basically the whole like the
processing part was one big Java stream
well Java sang we was in very Waiver who
are using and it became super handy that
at some point we could just make period
use carry functions and just perform
partial application instead of that
rewriting everything to get simplified
forms of those methods and now when I
use Asian my favorite part so we are in
the world of functional programming we
operate on functions that are
referential transparent and after and
they always return same values and they
don't make any any surprises so
basically if we know that function
returns always the same result for the
world for the same in the set of inputs
why not just cash results well of course
we can do this so if we have like a
function that lets say take quite a long
time to come well there were the value
takes quite a lot of time to compute why
not actually just crack well sketch them
after calling them calling the middle
for the first time yeah obviously it
works and it's quite very quite easy to
achieve because there's only one one
instance method memorized that convert
the function to the one that catches the
result so you can see now if you're on
ice well the example is very bad but
shows how it works very nicely well so
let's create a function of mass random
well it's the total opposite of what we
want to referential transparent means
okay because we accept actually
math.random to return another value each
time it's called well so let's break it
so we can memorize my friend on and now
now if we call it ethically to first
time the value gets cached and after we
call the apply second time the value
gets returned from the cache and we
always get the same value okay so that
would be all for the functional
interfaces part let's have a look at
apples now so sometimes in the code we
have situations were we don't well we
could create for example new class for
returning like few values together but
the situation's were well we they don't
the don't really reserve and you could
well deserve a new class to be created
in such case we can deal with tuples
which are basically like a form of an
anonymous object typed on most objects
for example if you have a look at scala
and other languages like this for
example when you when you zip two
collections together you need to end up
you end up with like a new collection of
pairs of elements okay so for example in
that case you don't need to create an
a new class but we can you can miss at
Apple and on the subject that holds two
together so obviously it's immutable as
you can see the name of the top of here
is purple too so again it's super
predictable because if you want to have
at Apple of eight elements well you go
for Table eight
and obviously all of them can be created
with the off static method and obviously
the API is quite rich because you can
now are you created at Apple now you can
manipulate it easily using methods like
map or transform any other fingers you
can get even stuff like to sequence a
well if you want to iterate after all of
them well if you really want to and so
the last the last the the most
interesting thing is the value interface
which represents the container that can
hold some value or not those those types
are like those are options which you can
which you probably already know from
Java 8 well it's similar to optional you
have try which is in this case something
similar to optional but it says no
ability you deal with exceptions that
can be raised in any point other thing
is we have lazy which brings lazy
initialization of values to Java well
and again with some really nice map
filter API you can either you have a new
future you have special validation monad
and what's super interesting that all of
those all of those containers they
extend iterable at some point so this is
some like the common denominator between
the the Java world and waiver world and
but okay but optional try why would you
extend an interval well because actually
if you think from another side from
different perspective you know notice
that option that optional can have zero
element or one okay so it is
kind of far off correctional turbos can
called max one element
same with trial AZ in other things like
this actually it can be super useful in
some situations that we will see in a
second was also super nice is that the
whole new gelatin collections API also
extended to iterable so if we want Java
and waiver eater interoperability we can
achieve it by they are connected with
iterable actually recently there is some
experimental feature and there will be
more experiments about returning collect
collection views that either will be
there is a concept the guys are
experimenting with this they will be
returning that we will have you will be
able to achieve interoperability not
only by using turbos but also by using
is used that internet standard JDK
interfaces but delegate all the methods
to underlying waiver objects so option
as you have been expect it works similar
to the optional but additionally so IP
is pretty similar you have map flatmap
and if you want to get default where you
have great or elles there are few
additions but pretty much everything is
is pretty much the same additionally of
course it's salvageable so it makes some
things much easier and here let's have a
look how we can leverage the fact that
optional is a terrible
well so imagine situations where you
have a list of optionals and want to you
want to filter out only values that
exist not optional
well so now you have few options but the
most popular was were creating a stream
then you would need to manually Suter
all optional set have something inside
then call optional get-well which
basically will be probably deprecated to
another future Java releases and then
finally collect everything to list um
well it sounds like pretty well quite a
lengthy operation to do something but
it's pretty simple
but let's now imagine what happens when
we know that option becomes
iterable if it becomes iterable we can
perform a flattened operation that
operation means that we are flattening
the nested structure so if you have
iterable holding turbos we can flatten
them to only one level so if optional is
an iterable tool we can pretty much
collapse it and it means that when when
you are flooding flooding they collect
the next collection its ends up in
situations where optional becomes
something it's all if something is in
the optional it becomes that method
value and if optional is empty it just
collapses towards nothing as you can see
here you can see we are to producing
flood map using waiver only in one line
and the funny thing here is that few
talks ago some guys and the audience
notice that if you have a identity
function o to all it looks kind of like
a no L so it's quite easy to remember
that not all
I can't unsee it now ok so another thing
another tool is try try it you know it's
already too like optional for dealing
with exceptions so the API and
everything is pretty pretty similar okay
you have map flatmap that were filters
which looks just like in optionals and
just like in the whole current function
programming you have the same looking
api how it works is when you have
situation that when you are doing some
action that can throw an exception you
can wrap it into a try and elaborate a
very nice API for doing with exceptions
so here we are creating basically new
instance of uri and as we know you are
ice can throw many different types of
exceptions and now we can perform some
declarative operations on it in this
case we want to extract the scheme and
if it was successful we can get it all
returned and unknown in case if some
exception was thrown on the way
of course the whole if you dig deeper
you will find much more like exception
specific methods for dealing with it
another thing another interesting thing
is lazy which as you probably expect has
the same API says try optional and
others but in this case we can deal
creatively with lately initialized
values so if we have a very long
computation and we don't want to take
calculated eagerly we can create lazy of
that particular complication and then
use the same API else in other examples
for expressing our our will what would
we do with this value if it got
calculated so here we have lazy of VLC
which is very which states for Burnley
on computation then we are calling
object to string using map and string to
uppercase thousand map so after creating
the lazy instant this is only expression
of our real it did it what didn't get
calculated yet everything will get
calculated only when we actually wait
for the value you think get method so
the other super interesting thing about
doubled waiver our function data
structures and when we are discussing
imitability well it has some benefits
but it's not always well there are
always on traders for example if you
want to deal with immutable immutable
data structures well you always seem to
create a copy if you want to modify it
so now you may imagine situation where
let's say you want to add like few
thousands of elements or few hundreds
thousands of elements to list well
obviously we'll probably to create a
copy after at the addition of every
element well and this can be super
inefficient but wise people came up with
the idea of persisting collections which
is basically an internal idea for
building
immutable
data structures that well don't waste
that much memory so if you really want
to learn I mean discount the whole
subject there's this talk from devoxx
from the driver go guy I forget his name
now sorry definitely it was called
functional data structures
it has like a one-hour talking about
this house implemented but we need to
remember that the core idea is to make
this data structure recursive so instead
of just copying copying and creating
copies of everything we are trying to
reuse parts that were already existing
in this case we we can save quite a lot
of memory on this and now if you have a
look at the sequence the secure keys and
jela song you will see that you have a
lot of times that are it sounds pretty
similar to well torture it now you can
arise vectors stacks list queues streams
but there is one thing I'd like to point
you which is a stream which might be
pretty confusing because in Java 8
streams are are not collections this is
basically a very fancy form of a
iterator for dealing with stuff and but
this is not something that calls
elements but here stream is a full
collection so yeah we are not limited to
stuff like that using it only once so
this is super nice individual imitation
but he it was implemented from scratch
and now the amount most the best parts
of all those types in Java Frank is that
when you all when you use the code
compression tool from your favorite IDE
you will be mind-blown with the amount
of tools that you have over there well
you probably can't see all of them just
but it's important if you see that quite
a lot of them I remember when I was
living with Java 8 at the beginning for
me it was well when I was looking at the
stream API it was overwhelming but after
some time I was noticing legs for
example there's no possibility of doing
these things using a custom comparator
ok custom echoes method and this would
be super useful or for example you can't
zip two streams together this is the
super limiting in some cases and you
need to describe yourself with some
external libraries for this but here
basically everything you might you might
need is it's already there so if you
want to of course you can do basic these
things but you can distinct by using
custom comparator and custom function
you can add elements to stream which was
super cumbersome in graphite you can
even return combinations or
cross-product of all elements that are
in the stream ok you can cycle stream ok
converting a thin stream to infinite one
and so on and so on
of course so even if you find something
something if you are if you were looking
for something useful for you and you
didn't find it you can always go to
github write an issue and it will be
implemented our guys will explain you
very politely well why it won't be this
is also the other very very interesting
thing when you compare two different
community for example remember when I
was starting functional programming with
Scala there was this mailing list and I
remember that whenever people were
asking some questions
well you might they might have got an
answer that was something like go to a
mentor a school learn basic math and
then come back well but this guy's on
waiver are super super committee
friendly so I remember that recently my
friend submitted a very big pull request
to the waiver which got closed but
instead of those very like authoritive
know instead of their create Daniel
created a very big like blog post about
it to explain why explain some technical
world design decisions that were made
and why this one implemented so it's
super polite and super friendly so even
using this new tools you can do crazy
stuff like this one if you want to well
impress girls or make your
random hate you the other thing that
guys are experimenting with is pattern
matching which is basically a very like
extent be very extended form of
switch-case known from java well
obviously we don't have well there is no
native language support for this so it's
super limited and but still it can be so
helpful in some situations so when
you're thinking about pattern matching
in relation to switch case it was pretty
similarly okay because you have some
value that you're switching and some
cases that it can fall into so for
example here you can see that we are
matching the eye and it can be in well
there are free cases it can be even can
be odd and can be well something else
that in case if it could ever be so as
you can see here we are using predicates
for specifying well if the defeat if the
value fits or not in this particular
case and we have a special dollar sign
brackets for representing wildcard in
this case it might it might doesn't make
more sense because as well after two
cases we know that it is exhaustive but
it's unnecessary in other cases well if
you don't you if you don't create an
exhaustive case it you can always use
option instead of off and well it's
upgrades if it doesn't get net uganda
prevent optional well except not much
empty optional obviously this is not
going to get much more interesting
because you don't until you can even you
are not limited to using predicates but
you can put all 12 values inside so you
can not using predicates and particular
values it gets even deeper because if
you if you you don't you are not limited
you can you're not committed to using
like six values you can create patterns
so for example here you can pair we can
magically case the cases using like
knowing only part of the object if you
look at the second case
you see that you have a local date all
here you have here all local dates with
2016 and doesn't matter which month or
day or day it is
well you just and get access to it later
when you calculate the value so it can
be super useful but can be super
cumbersome if you want to use it with
your own with your own classes because
of what obviously it might look super
weird but this needs to be generated
okay
the separate project that allows you to
generate your own patterns which can be
on some not very comfortable okay so you
can also perform pattern matching using
actual types so predicates cases with
fractional values and actual types so
it's the equivalent of instance of and
obviously the pattern matching comes
with the set of predefined predicate
basically from everybody of every basic
scenario so it makes it super easy to
compose your cases from them if you
would like to look at the real life
scenario it you have summation like here
where you have cases with different
parameters and on the right side you can
see that there are some methods that
should be run when the problem in one of
the parameters was present obviously you
are not limited to using pattern
matching stand alone you can combine all
those tools together you can compose
tries with optional for example and with
pattern matching when when we're
covering and when you when you connect
all those tools together it creates
super fluent nice API that that can be
read very very easily and there is a
much lower likeliness of handing kapu
some unexpected stuff in there so
basically this was the reviewed the
short demo of the waiver library waiver
core but waiver is much more than this
there are additional modules that that
that can be used the one very
interesting one
waiver JWT I don't want to know what's
inside obviously you have special
modules for pattern matching if you want
to experiment with this there is a
property testing framework waiver test
additionally you can waive rejection for
like of course sub for Standardization
distillation support rejection and
waiver render and you like experimental
tools the guy are playing great they're
playing with so basically that would be
all I hoped you liked the new tool that
will inspire you to well write more
functionally in Java thank you very much
and we don't have much time so just
catch me after and ask some questions
thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>