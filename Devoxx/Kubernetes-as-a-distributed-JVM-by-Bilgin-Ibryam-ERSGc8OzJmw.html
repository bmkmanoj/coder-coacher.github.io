<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Kubernetes as a distributed JVM by Bilgin Ibryam | Coder Coacher - Coaching Coders</title><meta content="Kubernetes as a distributed JVM by Bilgin Ibryam - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Kubernetes as a distributed JVM by Bilgin Ibryam</b></h2><h5 class="post__date">2017-11-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ERSGc8OzJmw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everyone
thanks for coming to my talk my my name
is bill guinea Bram I work for res head
as an integration architect and in my
day job I used primarily Java with
projects such as apache camel active in
Cusick self-grasping boot to create
integration solutions I've put some of
my learnings in a book called camel
design patterns these days we run those
projects more and more on top of
kubernetes and
OpenShift and what I want to share today
with you is how running these Java
projects on top of openshift has changed
the way I think and design applications
yeah so let's get started even though
the top is the topic is around
kubernetes and Java just wanna say that
there are other cloud native platforms
and most of what we say today applies
also to other platforms in the same way
it also applies to other languages not
only as java the interesting thing is
that most of these cloud native
platforms nowadays kind of offer similar
capabilities for developers they all
work with containers they have the
concept of a deployment unit which in
kubernetes is a port in some other
platforms for example in Amazon ETS
orbit ms-dos is task group they have the
idea of recurring tasks that can be
executed by the platform provides you
with service discovery and load
balancing capabilities on Amazon is yes
that the application load balancer on
kubernetes this and that is the service
they have the possibility to do
scheduling and label stuff and provide
isolation ok if we have to solve a
problem or design something in
object-oriented programming what are the
tools we have typically we have
abstractions such as object classes
metals loops conditionals and
patterns the most famous one being the
gang before patterns but but we rarely
think only in that abstract level using
Java we also have additional things such
as threads maybe we will use Maeva
modules to do build time resolution
jigsaw to the runtime isolation packages
in classes to do encapsulation and using
all that basically we end up we may end
up with something like this this is an
example of spring cloud spring boot
paste the distributed application where
we have a number of micro services the
statistic service account service
notification service which uses
libraries such as ribbon to do service
discovery history to do a circuit
breaking and other clusters around like
Eureka for service discovery config
server so as the Gateway but the point
is having a couple of bare VMs we built
everything on top of it in Java and we
form lots of clusters of java
applications for different purposes now
if we go into the kubernetes world
kubernetes offers you a new set of
abstractions and primitives that you can
use to solve your developer challenges
and the primitives we see here such as
containers pods cron jobs configs map
these are not admin or ops tools these
are actually primitives and abstractions
for developers to use and solve and
create a solution and patterns and
principles which are built around which
being created right now with using these
primitives if we get to put a Java based
service in a kubernetes world it would
look like this so you have your java
application in a container which which
may have a volume map to it using or
whether that's config map or secret and
your container will have distribution
budget for that will control how it
scales down it can have a horizontal pot
autoscaler to scaling it up to have a
service or ingress to control how
external
consumers can access it it will be
controlled by one of these controllers
you see the diamond set replica sets
data set or and those will be created by
something high-level like a deployment
in cron job the point is this this model
is very different than having a java
application on a VM where you do
everything inside the JVM here the java
application is actually fully coupled
with kubernetes it in order to do
something useful it has to integrate
well with all these kubernetes
primitives and and actually you can use
this component is primitive to solve
your challenges you don't have to do
everything in Java you can do the
service discovery using kubernetes
services you can do the config
management using a config map rather
than a config server inside the JVM in
this table I have basically put a set of
concerns and how we solve them in Java
and also examples how do those map to
cover Nettie's this is more if you're
coming from a Java world you want to see
how a concept in Java maps to kubernetes
world basically in a distributed world
for example if the way we encapsulate
behavior in the JVM is by implementing
them in classes and instantiating
objects packaging in jars and the jar
becomes actually out unit of rails and
sharing around in the governance world
the equivalent of that is the container
image where you have a container image
that's been instantiated as a container
and you share the container around the
deployment unit typically in Java world
is a set of jars whether that's a
warrior or another jar that contains the
jars in kubernetes that's the port which
is the collection of containers to do
encapsulation we have we can use classes
packages modules in Java in the
kubernetes world that would be the
container itself and different
namespaces now as for the other runtime
behavior for example if you have some
kind of preconditions typically in the
job world you can
those new your constructor by validating
arguments and things like that in the
kubernetes world is something called
init container
init containers are a set of containers
that would run when the port starts up
and these containers can perform tasks
such as validating any kind of
precondition weight on connection
perform certain kind of initialization
about the post installation tasks for
example if you are using spring you can
use an init method to perform an action
after your object has been created in
kubernetes you can use a post start hook
that will be called by kubernetes once
your container has started similarly
before for pre destroy before your
object is garbage collected you can use
in Java the finalize method and hope
that it will be called or use some kind
of shut down hooks in kubernetes there's
the proposal around differ containers
this will be set of containers that are
executed when your pot is shutting down
but the difference is with kubernetes
primitives you perform these actions not
an inside the single process but across
multiple processes that are spread
across multiple machines so these are
kind of the distributed equivalents of
of the primitives if you wanna execute
tasks in Java we have threads through
various way of controlling that in
communities we have job which is another
container that will be started to
perform tasks if you want to do
something periodic we have timer in Java
in cornetist you can use a cron job so
the platform will start at a previous
five time interval port with the
container execute your logic and shut it
down so you don't have to implement the
logic of scheduling inside the Java you
can delegate that to the platform and
just implement the business logic in in
your in your application and we have
similarly
things to do in the background for
example in Java we have diamond threads
that to the garbage collection base to
control the health of the JVM in
kubernetes there is diamond set which
where you can run stuff that runs before
anything else on the cluster
to do maybe location installed in the
local creation agents and things like
that
and from configuration management in the
Java we can use environment variables
properties but in kubernetes we have
something called config map which
basically lets you distribute these
configurations across multiple processes
now if I have to imagine or to show you
how that looks like at least in my head
kubernetes is like a distributed
application runtime which controls lots
of java applications here some of these
applications may be interacting between
themselves maybe there are two applicate
two containers in one pot and they talk
to each other of a local host the pot is
controlling these containers as well the
containers may be talking to each other
over volumes you may have a cron job in
kubernetes that controls your
application starting and stopping or
there might be a job that's controlling
but the point is kubernetes turns into a
distributed runtime where you can have
multiple JVMs doing stuff and kubernetes
will control the life cycle of all these
processes for you here I've just
collected few examples basically some
benefits that kubernetes provides on top
of what a JVM would and these are just
benefits purely focused for developers
okay kubernetes is also used by admins
and office people but it's its DevOps
too so developers are also finding
benefits using it for example the first
one I find you really useful is the fact
you can create an environment or an
isolated pool of resources with one
command that means if you wanna do a
spike or do you do some tests you can
easily incorporate this create a
namespace
but to deploy your applications and you
will not have any kind of resource clash
named clash with other namespaces once
you have a namespace then the second
thing is how do you copy your
application to that namespace in the
past we have to basically once you have
the
developer we had to STP to VM copied
here and there with kubernetes that you
don't have to do anything the scheduler
will find not that has enough resources
to run your container so you can
completely forget about the placement
aspect which we had to do manually in
the past once you have placed your world
then the question is how do you start
your application again in the past we
had to copy over you know maybe
application server check the locks that
it has started
maybe check some endpoints and validate
that it has started with kubernetes
deployment it can control how your
application has started how it should
take down the old version start the new
one and do things like rolling
deployments recreate deployments even
Bluegreen and can releases but the point
is this also declarative activity and
you don't have to worry about it any
longer
another point is about application
resilience typically this is at least in
the Java world that is associated with
hystrix if you use micro services and
you wanna do circuit breaking some kind
of bulk heading you would use hystrix
but only by using containers and some
kind of container orchestration you get
additional benefits and basically you
get protection from all kind of errors
you can see here for example if your
application has some kind of infinite
loops and consume consume a lot of CPU
shares kubernetes and the resources will
control that so it doesn't take other
applications down if you have any kind
of memory leak at least application will
be restarted so it won't die straight
away it can protect you from other
things such as this hoax for poems and
you can do it one circuit breaking and
bulk heading outside of your JVM you can
put that in a sidecar or something like
a service mesh and have it provided by
the platform rather than doing it inside
your JVM and you get additional benefits
like auto scaling self-healing etc
another point is service discovery we
used to do that also in the JVM you
would have some kind of agent in your
service that registers it but that's a
zookeeper agent Eureka agent and then
the consumer would look up the registry
with kubernetes that is happening but
it's happening outside of your process
so when you start your container it
registers itself to the registry and the
consumer can do server-side discuss
service discovery but the point is
inside your JVM you don't have to worry
about the service discovery aspects in
addition here the new thing that's
becoming popular these days as service
mesh which lets you do things like
circuit breaking and service discovery
even tracing outside of your application
so you don't have to add a tracing agent
in your JVM you can do it at a platform
level as well and I would say that's the
last point that everything we talked
about so far all that can be written
down in the ml file and execute it so in
the past we used to have all the
information about how an application is
deployed how it should scale up and down
how many instances there should be all
that was on some kind of document org or
a wiki now all this information is
written down in the ML file it is
created by developers together with the
application and it is executed starting
from dev environment to test to all
environments so it's an exec executive
and declarative application topology in
this talk I have just briefly touched on
the primitives so cloud native
primitives like containers and pods but
once you have new primitives there are
new principles same way we have the
solid principles in the object-oriented
world that deals with
objects and classes in the cloud native
world design principles around
containers so I'm talking about this
tomorrow
there are also design patterns which is
about how you group your containers to
get in a port to software recurring Pro
issues the patterns such as sidecar
Ambassador adapter and lots of practices
around it if you're interested more
about these topics check out check
this white paper and maybe the book
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>