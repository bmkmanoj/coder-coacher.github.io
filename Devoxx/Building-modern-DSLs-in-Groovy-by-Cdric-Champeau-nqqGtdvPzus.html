<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Building modern DSLs in Groovy by Cédric Champeau | Coder Coacher - Coaching Coders</title><meta content="Building modern DSLs in Groovy by Cédric Champeau - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Building modern DSLs in Groovy by Cédric Champeau</b></h2><h5 class="post__date">2015-11-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/nqqGtdvPzus" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so thank you for coming to this
session about groovy before we see
anything on screen just let me know who
you are how many of you are already
groovy users today okay so you've been
about half of the room
how many already implemented some decels
using groovy okay how many of you do not
know what is a DSL right so maybe you
should come to the front right so this
session is about building these cells
using groovy today and I am working from
Gradle this slide where is written using
Gradle and asciidoctor
and actually the title is not that nice
because in groovy we can remove all the
semicolons and the parents let's change
that in my slides right now okay it's
saved and hopefully it's going to be
updated yes
so now we ready to start much better
so who I am so my name is selling
shampoo I'm French I said already and
I'm working for Gradle if you have
questions about Gradle if you are not
yet the Gradle user know why you should
migrate to Gradle can you talk to me
after the talk I implemented some
features of groovy recently some
features like the static compiler
creates something that we will see which
is markup template engine and I started
working with groovy a few years ago
and my main focus was actually about
DSM's in groovy so I chose groovy for a
very particular reason and I continued
to work on that topic improving Roo
itself and then I eventually became a
committer
and now I am working on groovy as what
we call a committer
and the apache software
datian so groovy is not that despite
what you could hear here here and there
ruby is very well alive you can suddenly
pull requests we're very happy to do it
to merge everything so the topic today
is more ESS suggest for you in the back
what is a DSL is a language that could
be either developed by yourself or
external which is aimed towards a
specific domain so we have the typical
example that we use generally is sequel
which is a language dedicated at
performing database queries so there are
some key concepts in this as many many
concepts you find many books about the
essence how you should design etc but
the concepts that we can find here like
focused which means a single domain
readable which means that the target of
the DSL is not a machine it's really a
user a human so usually you want to read
the code of course practical to use and
this one is especially particular for
groovy it means that you want to embed
the DSL into an existing application or
enhance an existing application with DSL
capabilities so we're going to talk
about that if you have questions during
the talk
mm-maybe yeah
given that the room is going to be a bit
difficult to interrupt the talk but if
you have a question maybe you can just
try to send me a tweet under groovy land
DSL hashtags and maybe in the end I
could read it and answer your questions
feel free to do it okay so why you would
choose actually groovy to write a DSL to
implement a DSL and there are some very
particular features of the language that
make it possible
to do it first of all and main
is really that the syntax of groovy
itself is very lean it is very clear and
it's so easy to make it readable
so the syntax of the language makes it
possible to create languages tear cells
which are very practical to use as a
union and this is a key concept the
second one is scripting because as I
said you probably want to embed some
scripting features into your application
and have maybe say a language dedicated
some features of your application not
all the features but some particular
features domain in your application and
that requires to execute the geocells at
what got run time so when I said that I
started using groovy using the essence
it is actually true and I started doing
groovy DSL in the context which is very
different from what I do today and was
using groovy to implement some natural
language processing engine and the
language that we used was a DSL
designing groovy and that DSM was
targeted at linguists not developers and
it was interesting to have groovy to do
it because the tool that we had at hand
was the same for the linguist and for
the developers and we see that there are
all the advantages of doing that next
point but groovy using groovy is that it
supports meta programming so meta
programming can be seen sometimes as
something magic but magic exists in DSL
I mean we live in a world full of magic
everybody knows about that
the problem often is that users don't
understand the magic because there's not
magic in fact it's metaprogramming and
what you will have to do is to try to
make your DSL not look so magic at all
and meta programming techniques in
groovy you have to kind of meta
programming techniques the usual one
which is the easiest is runtime meta
programming which means that you will
change the behavior of the program
basically at runtime and you have the
other side of things which is compiled
time without programming so you take a
script you modify it during the
compilation of the script and then at
runtime nothing happens in particular so
groovy provides the two aspects and each
of them have some advantages and some
disadvantages and last point is really
obvious groovy is a language which is
supported by all the main ideas that you
have today so eclipse IntelliJ NetBeans
VI that Emacs obvious
so Emacs users may be okay so it was
also important for me when I chose
groovy actually because those linguists
were using the same language but also
the same tools in they had actually
support from the IDE so when they're
brought to rules that were using
IntelliJ in that case it was very
practical so let's start the topic was
building Jesus in groovy today because
groovy is more than ten years old now
and it has dramatically changed since
version 1 and you have many many options
to do the same thing
but also it means that today the way you
would write a DSL is very different from
the way you would have done it ten years
ago so the little yeah maybe you can
just skip that maybe the little
disclaimer that I should say is that
when I said that some language is old it
doesn't mean that it doesn't work
doesn't mean that it doesn't do what it
should do it means that in my opinion it
shouldn't be done that way today and
it's very different from saying it sucks
right if it does the job okay you have
no reason to change it but today if you
want to implement something maybe there
are some ideas that you can do so just
some examples of what I call old looking
DSL the first one is actually
interesting and I'm an intelligent very
happy user and actually one of the key
features of integer is that you can have
a DSL that describes DSL and this is
made to support completion and what it
does is that you write a script which
enhances the comprehension that the ID
has about your DSL at editing time so
you can provide some hints to the IDE
for completion for the types etc so it's
a diesel that exists today in integer
and it's actually interesting to know
that you have that tool 10 if you want
to provide user spot but when you look
actually at that DSL it looks pretty
much like code it is code actually very
much like code so you have some words
verbs you have some actions but really
it's not very user friendly and more
importantly it relies on that syntax
so I think that most of you said they
were familiar with groovy if you're not
familiar with Ravi this is an app and
what is the problem with maps what are
the keys available you know you have no
idea what you should put here there and
there when you want to have completion
typically so the user will have to read
the documentation and are you happy with
reading the documentation when you use a
framework usually no its last result
because the documentation sacks a second
example how many of you are great uses
okay so I need to explain that so the
first version of gray's which is a web
framework written groovy have an
abstraction layer on top of sequel
queries to simplify everything so you
have some entities in that case I have a
personality and that method that we have
there looks like it looks like a static
method but if you take a look at the
code of the person class there is no
such method it doesn't exist it's not
defined on the person class it is
totally dynamic so it means that when
Ruby sees that method at runtime and
it's important to understand that it is
at runtime when it sees that method it
finds that actually it starts with find
and then it will pass the method name to
try to find what it means in that case
it's pretty obvious find by last name so
I'm trying to find something in the
person catalog folder store
string and that's a query that's a
sequel query which is created in the
hood so okay
that works but it has some problems
first one of course is that what if you
write it wrong what happens well of
course you have unit tests or maybe not
so it will feign production on a Friday
evening okay so maybe we can do better
and the last one in that example is
actually the final method and that one
comes from groovy itself and this always
annoys me I hate to have to write this
it why do I have to write it everywhere
I know that when I am integrating on a
person list I know that the object that
I will manipulate inside the clutter is
a person so why do you ask me to say it
explicitly explicitly and I want to do
it I just want to say find all alive
done the Gradle also has some problems
with the essence how many of you are
happy with the IDE support in Gradle
well those of you who use Gradle come on
like is one hand please thank you so can
anyone tell me what is the difference
between the two snippets of code that
have it there if you know Gradle of
course if you don't know Gradle it's not
problem sorry now
yeah heard you last so that's the answer
do last so Gradle has this specific
syntax which is the double arrow here
and what it means is that the code that
you see here is executed when the task
is executed whereas in the second case
what you have here is some code which is
executed when the task is configured so
Gradle is a build tool which is made on
the notion of a ton task graph so there
are two phases configuration phase where
you configure all the tasks that must be
executed and then once you have the full
class graph you can execute the build so
if you forget that what happens is that
you execute some code when the tasks are
supposed to be configured not when
they're executed and I think for such a
huge difference in behavior two
characters are not enough so you should
never do that and I would probably if I
were to redo the DSL today I would
probably remove that and force people to
use the to last block and the do last
block exactly means I want to do that
when the task is executed and it is
explicit so the idea behind that is
really that if you have something which
is important and has a semantic
difference which is important it should
be visible in the DSL and the goal of
this cell design is not to be as short
as possible it's not that it's to be
readable and understandable if it's
short and readable it's better but be
careful
other thoughts about groovy if you
remove the semicolons you're not
building a DSL you're just writing
regular groovy code and it's actually
pretty funny because even if it seems
very obvious just try to search Google
for groovy DSL for my favorite library
and often what you will see is a Java
library and a code snippet is just Java
code without the semicolons no it
doesn't make it true VDSL and the same
it's not because you remove the
parentheses that you're creating a DSL
you just having some syntactic sugar
nothing more so when you will design
your DSL what is important to think is
what it will bring to the user compared
to a plain Java or plain your favorite
language code that is very different the
problem as I said is that in groovy you
have many options and that is true for
implementation but it is also true when
you will design the DSL and especially
it's very easy to create many ways to do
the same thing with the different syntax
funnel users often this is not very
pleasant because if you have two ways to
do the same thing one day the question
will be what is the difference between
the two and if your answer is there is
no difference you start to have problems
that's my opinion
the last one is try to be idiomatic so
it's just if you ever saw the the tongue
that Jian gave without being idiomatic
in Ruby groovy with style if you did not
go on a web site you have a full section
of groovy that is specifically aimed
towards how you should write your groovy
today if it was it's language without
any knowledge of job okay so the next
steps is really what we want to do today
what is a new Gradle new groovy sorry
diesel how many of you use puck good
so this that's funny
why why don't you you should you must I
mean it's a pain to write unit tests or
maybe you don't write this okay so it's
a pain to write unit tests but with
spark it's it's it's so easy and it's so
readable so if you don't know Spock it's
okay if you don't know spark just read
that given when then it's
behavior-driven testing so given
something when something happens I want
to check that something it's very
readable and actually what Spock will
let you do is also to attach models to
do to the level subjects or level so you
can put a string there you could put a
string there you can put a string there
and what will happen is that the test
report that you will have will have
those strings inside and it is very
interesting because it means that when
you produce the report actually your
manager can read it and it's readable in
a human form but it's not the most
important aspect here what is
interestingly Spock is probably oldest
modern Rivi DSL because it's the first
framework that heavily relies on a stick
transformations if you don't know what
nasty transformation is and be afraid it
doesn't bite its code generation to be
clear macros
maybe VB uses their so it's a macro and
what you do there if you try to execute
that go into a regular groovy source
code it wouldn't behave like if you do
exactly the same with inspark
and that is because spark transforms
this code into something that can be
executed as a test so it is a technique
that you can use so in just an hour I
won't have any time to explain to you
how we can do that I can manipulate you
to code but the idea is more to give you
pointers to give you ideas of what you
can do oh we back to grains so I said
that grace had a problem with the
dynamic find us and actually this solved
it the solve that problem raised free
and in grace tree have new syntax which
is person dot final you have all the
words you can use fine you can use you
know much better than me you can do
queries and the syntax that you have
there is very it's very interesting for
multiple reasons first of all can you
tell me what is the packing storage
engine in there no you can't so it
totally abstracts the fact that I could
use MongoDB for example there I don't
care actually what I care as a user is
to say I want to perform a query I don't
care about the packing engine I want to
perform a query in the queries that last
name is talk and that guy should be
still alive probably is going to be
empty so what is the difference with the
previous example in grace the first
example that I showed it was a method
and the method name was dynamic here
what I have is a method which is defined
and this here is actually transformed at
compile time not at run time so if you
make a mistake in your query you will
have an error at compile time when you
compile that query compile source code
so you have much more feedback and
actually much earlier in the development
phase that doesn't prevent you from
writing your tests but at least you have
some feedback because even if the
dynamic failures were very practical in
rhenium practice they weren't very
limited and you had the feedback much
much later
Radel also has a new kind of DSL so if
you look at that code this is how in the
future you're going to use Gradle to
describe what is your software if you
use maven today you don't describe
software you describe plugins that you
use you describe eventually you can
describe maybe how you have additional
source sets maybe but you don't really
describe what is your software and how
it is composed in this example what we
have is that we'd say in Gradle here's
my software model in my model I have
some components in my application one of
them is a driving library which is
called main and actually to compile the
Java source I have a dependency on
something which is my tip interestingly
I'm saying
okay this main library is only meant to
target Java 8 where is my lip well
actually my lip is another component of
my library on my software it's also
jaden library this time this component
targets two different platforms john
line service 506 what I could do is also
describe
specific dependencies I need for Java 6
on jealous 5 for example if I use
features of level 6 in Java 5 it would
be a problem but if I have a backbone
library maybe I can use them yes maybe I
could describe the dependence is
specifically for that variant that's
nice but also I have that API block and
if you so maybe some of you were at the
jigsaw talks this week that's exactly
the same concept you describe what
packages are in your library and
actually the packages that are supposed
to be exported to consumers so if I have
in my my lip library a package which is
internal it is not visible to the
consumers so it means that if my main
library tries to access a class which is
not in the exported packages it's going
to be a compile time error so you have
today with Java 6 Java 7 Java 8 you have
today in the same behavior as what you
would have tomorrow with jigsaw and you
have it to David Gradle and more
importantly today you choose to use Java
9 we will generate the module info file
for you so you can get prepared today
and the idea is that this DSL is
specified exactly for one aspect
describing your software model rat-pack
maybe some of you were at the rapid talk
it's a web framework and it is very
interesting because it's very modern in
its designs using Java it minimally it's
totally asynchronous but the DSL that we
have a groovy is also interesting
because it's very clear you have a Rat
Pack top level and then you have some
handlers with getters you can describe
everything you want it is readable I
mean I can understand that
actually this is something that will
render when I do a get it is
understandable just reading it and what
is important with rat-pack is that this
can be statically compiled so you can
have errors at compile time two very
nice how many Jenkins uses yeah so maybe
you're already using the Jenkins job
diesel it is also some kind of modern
DSL because it is very readable it's
using the Builder syntax it is very
simple to understand what it does
there's only one problem on that slide
can you spot it yes it's using maven
okay so one more example the market
template engine and this one was
designed partly because I was fed up
with the existing template engine
because I am NOT an HTML developer and I
hate to forget to close a div tag it is
so annoying I mean if you if you just
read some HTML and you have all those
blocks and you forgot one live there you
doomed
it is terrible so what I wanted to do
for the new groovy website is having a
template engine that would do that job
for me so we have a syntax which is a
builder it doesn't look very special
nitramene
but what it does is very complex
this whole code can be statically
compiled it doesn't know anything about
the HTML method it doesn't know anything
about body method I could use my own
tags still it would be statically
compiled
had some features that will let you
import all the templates combined
templates have some composition features
you can check out the dogs if you're
interested that but what is nice is that
what I'm doing here it's just one way to
declare what are the types of the
objects I put into the binding of my
template before it is rendered so doing
that I am declaring that I have a
person's variable into my template which
is available to my template and its type
is a list of strings right and I said
when the template is going to be
compiled it is statically compiled so
what will happen when we reach the
person's here persons exactly exactly
something which is into the binding so
the template engine knows that it is
into the binding so it knows that P here
is a string and when it would try to
create list item with P dot name what is
going to happen compile time error so
the second advantage is that when you
compile the template not when it's
rendered when you compile it you have a
compile time error so you can catch the
errors in your templates much sooner too
and that's really another example of
what I think modern Diesel's should care
about it's having early feedback you
certainly don't want to have something
failing in production so if you have the
tools to do it why not if you don't have
the tools of course you'll have no
choice rely on runtime and fair and
runtime if if you have the tools you can
try it and the second aspect is that
this is not born from day one you can
incrementally improve your Dessel and
incrementally add some
checking at compile time it is still
very doable to do that and that's
exactly how it was designed in the first
place
it wasn't time checked the idea was more
to have something statically compiled
able but not type checked and you can do
it you can do that so we have tools so
Dutch I'm going to talk about that
so back to the basics closures are
everywhere in groovy so for those of you
who are not familiar with cruisers it is
exactly that the block that you see
there is a closure so it's an HTML
method and it has exactly one argument
which is a closure and a closure and
groovy is not like a lambda in Java 8 a
closure in Ruby is really an object it's
a first-class citizen so it's not
translated into a functional interface
it's really something which is of a
clasp closure so you can manipulate it I
mean it's actually interesting to
manipulate it so closures have new
annotations that were added specifically
to improve ID support and to improve
type checking so we see the second tool
that we are going to use is
computational customizes anybody knows
what they are okay pasty transformations
so the macro stuff some people use it
already
okay type checking extensions I'm going
to talk about that and the last one is
very easy you can use the groovy shell
and ruby shell is actually my favorite
tool to debug Ruby code just write some
code you can have access to the ast
abstract syntax tree so easy so use it
closures so let's fix the first bag well
no it's not a bag it's something that
shouldn't have been
done that way in groovy the collect
method that takes it and it's ugly I
don't want it anymore
so let's fix it okay this looks weird I
have to write so much code to do that no
no no no really not actually this more
than that just focus on that this is the
implementation of a new collect method
that I called my collect and what it
does is just setting the strategy of the
closure resolution and the strategy is
where at runtime we'll look at when we
call method or property so when we do
length it's implicit there's no this
here it's delegate dot something so it's
delegate dot something because I'm
saying
delegate first it's a simplification you
have all the the documentation to
understand what the different strategies
for delegation are in groovy it's pretty
easy to set the delegate you can even
generate code to do that
what is interesting that now I have a
super method which is help extension let
my collect because I like my collect
that takes a string list and yeah I
don't have it anymore victory and it's
super diesel no well it's not that super
just because I have to write all this
that's a bit annoying
well isn't no because I can fix it I'm
just going to add descriptive fine that
I will find in class path and I'm saying
that it's an extension module actually
derive in writing and this is why I use
the wrapper class called help extension
and doing that come back
here okay so it's a static method and
actually the first one the first
argument I have is a list and what I'm
doing is decorating lists with a new
method some decorating list with a new
method which is called my collect and as
soon as I write this descriptor this
method becomes directly available to the
list and groovy so it means that now I
can call my connect that way and it's
much nicer so groovy lets you do exactly
what it does to JDK classes when you see
the URL table get text method if you
take a look at the JDK does not get text
method on URL class yet in groovy you
can call my real vodka text and it's
exactly implemented that way
you create a static method with the type
of the element you want to decorate as
the first arguments and then the
arguments of the method and doing that
you decorate existing elements so it
might it might really look a bit leery
to do that and it might not look like
best practices and developments but
actually in the context of diesels it's
very practical because this allows you
to enhance existing DSL
imagine that you have that builder
syntax and that you want to add a new
method to something which is inside in
an element of the closure
Hiroki you can do that with an extension
method because you know the type of the
delegate that you're decorating so
without having to change the source code
of the initial DSL you can update it and
you can add new behaviors so it's very
useful
declaring the delegate type is exactly
what the delegates to method is about
and this is done for two reasons as I
said first one IDE support second one
type checking when we have that method
sorry when we have that method how the
IDE knows that actually you don't need
it it doesn't know you know it as the
death of designer but the idea doesn't
know and it doesn't know because this is
code that has to be executed to
understand what is the delegate type but
use the etho designer you know it so
please help the type checker please help
the IDE and tell it okay in the context
of my closure the type of the delegate
is going to be first parent dot first
generic type what does it mean the first
parameter of my method is the list of T
so the first generic type is a T so if I
use that method that list of strings I
know that the delegate is going to be a
string if it's a list of integers I know
that the delegate is going to be an
integer problem solved so there are many
options that you can use and then
against you tell actually the ID what is
the type of the delegate the first
version is very obvious just give it the
type and you can very far into what you
specify it that okay so far so removing
ceremony and this is something special
for Venkat because he always likes
ceremony code so when I say is your
distal self-contained what I mean is
that if your decimal is supposed to be
executed into an isolated context such
as a strict rule Street in a rule engine
a Gradle build
so a griddle script it has some context
it has some knowledge about the
execution context so what you should try
to do is remove everything that the user
shouldn't have to write so typically I
consider that a user of a dessert never
have to write an import impulse is for
developers you want to know that import
class X a user doesn't care about
imports and in case of the linguist that
I had as a user they didn't even know
what was an import what was the class
doesn't make any sense for them so if
you try to tell them okay you have to
write import something for the yo script
to work says what why do I have to do
that if it asked them to write new foo
equals new foo doesn't make any sense
but doesn't mean new an actually I vote
for the removal of the new keyword in
groovy if you want to remove it doesn't
it doesn't make any sense to have a new
keyword i mean it's pure arbitrary
syntax and the last one is avoid usage
of annotations just because annotation
hell so if you look at the spring boot
application today you have more
annotations that you have code yeah
before it was more XML so one link for
another what is the some type some type
single abstract method type so it's very
easy in fact it's a type a class and
that class has a single method which is
not interested so you can have it in an
interface or Raqqah have it on an
abstract class and this is the case here
with handle class and you have to
implement the handle method because this
is the only one that you have to
internet and this is super hardly please
do not do that for your users don't
force them to write new
Alvar right Voigt handle they don't care
what I want to write is serve print
message done no ceremony code and the
good news is that you have that for free
and Ruby as soon as you have a son type
as a method parameter you can use the
clutter there some of you could say it's
pretty similar to what you can do with
lambdas Java but lambdas are limited to
interfaces whereas in Ruby you can use
abstract classes it doesn't mean that
we're better in Java at all it's just
that you have more information and more
context you can do that
so yeah use some types and use the
features that the language provides to
you compilation customizers are exactly
about removing that ceremony code so
here my script for the user will serve
and if you try to compile at what will
happen it will compile okay but actually
you don't know where the serve method is
defined if I have the code here I know
that actually serve is a static method
on the web server class hmm and it has
delegates to with a service pack so
actually what happens inside is a
specification of what I want to serve
that's nice but how can I avoid writing
web server dot this is ceremony code I
want to remove that how do I do that
computation customizes and what it means
is that you will configure the context
of the script and in that case I want to
do a star import of web server so I want
all the methods of web server which are
static to be available directly my
script
so I'm configuring the script with the
add static stars on the web server class
so it means that when Ruby will contain
that script web server
serve is going to be found on the web
server class and I don't have to use
import come at my web server star you
don't need it remove it and your users
would be happy so you have multiple
compilation customizes the import one is
just what I showed a ste transformation
customizer is interesting because it
will let you apply transformations
transparently so when I talk about
static computation it is actually
implemented as a nicety transformation
in groov itself so if you want to
compile static lean your scripts you can
do that using HT transformation
customizer
and then you don't have to put an
explicit compile static everywhere
that's interesting the secure one is
probably the most badly lame thing ever
in the groovy code base and I chose the
name so blame me for that and the idea
that well the ID for me was that the
security that you can see here applies
to the ast it doesn't apply to any kind
of secure context in the context of
security policies of Java no it's not
it's about restricting the grammar of
the language and it can be interesting
for some dear cells imagine that you'd
easily want to implement is just an
arithmetic calculator you can do with
the security customers you can say ok in
that context in discrete it is not
allowed to create a class it is not
allowed to call a method it is not
allowed to use a closure and then what
the user can do is very basic one plus
one done and if you try something else
then it fails at compile time thus also
a customized is something that lets you
do that kind of manipulations to adding
customizers the est train secure
customizer you can do it on a purl
sauce find basis so it lets you
implement conventions imagine that you
have a folder which has controllers and
a folder that has views you can apply
different transformation based on what
folder you have this can be interesting
for framework designers okay so we have
about minutes left let's talk about
type-checking extensions the goal of
time tracking extensions is really to
give early feedback to the user an early
feedback is really what I want to do - -
to enhance my goal as a DSL designer is
not type safety type safety is a bonus
which is not a goal for me type safety
is cool for user for the IDE it's called
for the developer it's good for you you
won't type safety
probably because types they give you
that that cage you cannot extend you can
call something which is not in the type
so it's really cool for user developer
but the user doesn't care about types it
doesn't want to know but types it cares
about the domain he cares about the
model types don't care but type checking
extensions are a very cool way to
provide that knowledge to the type
checker and help the compiler understand
the DSL so how does it work when I
showed you the example of the mock-up
template engine it heavily relies on
that the idea is that when you apply
type checking or static computation to a
script because the compiler has no
knowledge of all the imports that you
added of all the
sorry the model that you use it doesn't
even know about that HTM the method that
you want to call it doesn't know
anything so what will happen if you try
to compile that statically errors
everywhere
cannot find method variable is not
defined etc etc etc and the idea behind
type checking is that extensions is that
you can capture all those events and
react to them so the type checker will
say okay here there's something I don't
know about its an undefined variable can
you tell me what is the type of this
because when you will implement that I
know that you will provide it to me I
don't care how you provide it to me I
just want to know the type because this
is what I care as a type checker so you
can tell the time to care okay if I find
persons in my script actually it's a
list of strings I don't find a method
okay
this was the type of the receiver this
was the name of the method you have some
arguments since I do some type inference
I can provide you with the types the
info types of all the arguments and
maybe we'll all that information you can
tell me actually what is the written
type what is the inferred written type
of your method so I can totally extend
the behavior of the type checker and it
will understand everything that you as a
designer of your lesson you know about
you can explain to it everything that it
will find into the binding so there are
two aspects with that the first one is
that groovy makes a clear separation
between type checking and static
completion and it was important to have
that difference because if you want to
implement that the first thing that you
want to do is user feedback
you don't want static compilation at
first it's a bonus to be faster it's a
bonus to be statically compiled but what
you want to have it actually provide
more errors to the user and what you can
do with that API
is providing more users than the
compiler can provide so imagine that you
have a string and you recognize that it
is a sequel query if it's Java code it
will see a string it doesn't know
anything about it
if using groovy you can recognize that
this string is used in the context of a
sequel query you can pass it and if it
has passed area you can fail at compile
time so you can do much more than what
the static compiler can typically do the
second aspect is that when you compile o
scripts you first apply type checking
because the compiler will not know how
it is to pose to compile the persons
that we had in the template the call to
persons how is it supposed to know that
it has to find it into the binding it
could very well be into a base template
class so a field in a class not
something in a map so it doesn't know
how to get that so it was important to
separate the two aspects having a type
checker and having static computation
because the first step which is easy to
do is providing the types to the time
checker and what is hard to do is to
transform the script into something
which is statically compiled able and
that last step is what makes the the
market template engine faster basically
because it is not Terramax code is this
statically compiled code but it's harder
to do so yeah you will have the slides
on my account and you can take a look at
the documentation for it and we're very
happy to have some feedback on the
features ok so five minutes left maybe I
will just hand it over to the conclusion
so what we learnt we learned that
using the syntax of groovy you can do
many things you can even totally
transform the input into something that
doesn't mean what it looks like we
learned that actually using those more
than yourselves you had a common pattern
which was the Builder pattern and the
Builder pattern without ugly it and
scoping is very important because at
least I as a human unlike you have
something which is readable as a block
it keeps you focused you know that
within that context you have everything
at hand so you have to use the delegate
and if you start using the delegate you
can help the IDE and you can help the
type checker so to do that you have to
use delegates to and one other
annotation that didn't have time to talk
about its closure parents and is aimed
towards helping the type check what is
the type of the parameters of the
closures because in all the examples I
gave here there wasn't any parameter but
you can have parameters to closures and
you can explain to the type checker what
are the types last this one I consider
at least this is one of my objectives in
Gradle you should rely on imperative
code as a last result so everything that
can be described as a specification
should be described as a specification
and last if you have to write some
imperative code somewhere to describe
some specific thing that you have to do
you can do it but it should be the last
thing to do because code is not what
users want to do they want to define
their model and for questions
nobody that's not surprising
yeah so is remove it a default behavior
or ruin Oh to remove it you don't need
it just delegate you easy enough because
to remove it the notion of delegate is
bundled into the language you have to
use type-checking extensions as soon as
the compiler doesn't know about
something so maybe maybe in the delegate
actually you can have a method in the
clutter which doesn't exist when the
type checker would say hey i didn't find
it on the delegate i didn't find it on
the owner i didn't find it in the scope
so please help me
so this is where you would use a type
checking extension I said I would check
you Luke if I had some questions because
people are showing and usually didn't
want to pass publicly and I now have any
network so no questions ok so if you
have questions can talk to me after the
talk
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>