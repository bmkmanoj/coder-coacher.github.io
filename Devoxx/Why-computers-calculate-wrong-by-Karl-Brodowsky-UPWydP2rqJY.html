<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Why computers calculate wrong by Karl Brodowsky | Coder Coacher - Coaching Coders</title><meta content="Why computers calculate wrong by Karl Brodowsky - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Why computers calculate wrong by Karl Brodowsky</b></h2><h5 class="post__date">2016-11-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/UPWydP2rqJY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everybody I think we will get
started now we talked about why
computers calculator on and that's
something we say computers are very good
in calculating so that's exactly what
they did in the early times and where
they still do but if we program them
wrong or whatever then they still don't
do what we want and this is especially
about the core capability of computers
the numeric types and of course in in
this conference using Java so anybody
heard about the year 2000 problem 16
years ago or 17 years ago it was a big
deal and yeah the young the younger ones
maybe don't but the older ones do so the
issue is how many digits does a year
have and usually we say two because
we're lazy to write or sometimes we say
four and maybe it laziness is not always
the best thing in this case so let's see
where we are in this world where we talk
now we talk about integers so we have a
quiz we just take two billion yeah
decimal two billion so this is a number
that can be expressed with an int and
then we add this thing to itself and we
multiply its to itself anybody has any
idea where we would get with this thing
so if you have an idea where this comes
out can you lift your hand or so sorry
overflow that sounds good but let's see
it just gives this it just gives you an
egg ative numbers without complaining is
just like that okay so that's important
and what we can know about this is the
range of an integer is like 2 to the
power of 31 negative of it to 2 to the
power 31-1 and that's what can be
expressed and it just stays within this
range whatever happens yeah so that's
what we have to deal with and the thing
is they
we have something called modular
arithmetic so if you ever went to some
University classes about algebra and in
math or IT in math or whatever then
maybe you came across this thing and if
not then you can see it here because
it's something that we actually know
because if you look have you ever let me
see sorry have you ever seen this device
it's a very familiar device and that's
actually what modular arithmetic is so
if you have like ten o'clock and then
you go for hours later then you are two
o'clock yeah the same with a minute and
a second so give this silent overflow
and it just counts on but it resets
itself yeah and so we just think of this
clock having not only 12 hours but
having 2 to the power of 32 digits yeah
and that's exactly what we have so we
can just rebuild the plus/minus and
times this looks like a lot of noise but
actually it's not so hard you know this
percent takes the remainder module of
something yeah so you do division with
rest you throw away the quotient and you
just keep the remainder and this
remainder thing that you have there we
normalize it so it becomes into this
range where the end is and we do this
with a long yeah and the long is
somewhat bigger than the end so for the
moment just trust me that it's right and
if you want to think you can figure out
that it's actually okay but if not you
can do the same with big integer and I
did some example of it so on the primary
slide you saw the github account and
you'll see it in the YouTube video if
you like and I tweeted it also and that
you can see examples i did it with big
intent long ok so then
we rebuild the addition subtraction and
multiplication so we just do these
things and then we apply this normalized
method that puts it into the range of
the integer yeah and so we now use
something bigger but we force it to
downgrade it to the int behavior so we
do the quiz now again with Long's but we
do our own methods yeah and loan would
allow this result to be last four and
then enough zeroes but here we have
forced it this way and let's see what
comes out there and you see it's exactly
the same as the int as you probably
remember all the digits but it is yeah
so that's what we actually have and the
question is if this is really the right
default because as an application
developed this modular arithmetic is
normally not what we are thinking of but
we have to know it's what Java does with
the primitives the long does the same
just give more digits okay so that's the
weakness of the ins other language is
some of them throw exceptions or some of
them just go to a larger type or
whatever but here it's like this so we
can address this issue we have to think
about our ranges so if we program
something and then we use integers I
mean integers an abstract point of view
yeah integral numbers then we should
think how large can they grow and really
think twice because then sometimes they
grow larger than we anticipated but it
should really work out and never
overflow and we can consider does it
really fit into an int safely okay or
does it fit and along and if not we can
use the big integer yeah but what you
always think you have to think about the
intermediate results also you met has a
long calculation and the final outcome
is very well in an int but you multiply
and
I'll and then somehow you get weird
results and these things are nice
because they don't happen when we test
with a simple 123 example everything
works well and then we go on production
and then we do the end of your
processing and then we get the big
numbers here so maybe this is a thing to
think twice so in Java we have the good
news we have the big integer we can
usually afford the extra overhead of
using it but we can't afford is wrong
results yeah and there is an issue if
you want to dig deeper into this you can
discover the overflow of int by looking
at the data before and after the
operation so if you like you can
investigate this but I won't tell you
now the bad news is this big integer is
a bit clumsy to use you can't use plus
minus x you have to fall back to
something like add and multiply and then
you don't see the formula you have to
spend some time to think so let's let
the next issue is is anybody of you
using floating point who has used the
double of float in the last 12 months so
we are not talking for nothing here so I
give you this quiz we take a one yeah
then we divide it by something with 20
digits then we add one then we stop
tracked one again and then we multiply
it again then we should get something
what do you think what we get is anybody
have an idea one would be nice but we
get a zero yeah that's that so let's
investigate why so the double has a
limited precision it's actually quite a
good powerful type it has 64 bits so
it's a lot of space but we can always
exceed it and this 20 digits is a little
bit too much so it does something that
is
usually not so bad is discursively
significant digits it's the best it can
do but now the important information was
exactly in the least significant digit
so it was discarded so the question is
how do we deal with this again I would
say the most important thing is that you
should know what you're doing ya think
what I'm doing here and that's that and
if you do complicated calculations and
you don't know yourself it's no problem
but you should get people involved to
know it there's people who know
numerical mathematics you can find them
maybe personal or in the internet or
whatever but look at it don't do wrong
programs just because you don't look and
there's also the possibility to use
other types than double but there we get
the next thing so there is a possibility
to use big integer or long and actually
you see many cases where you can just
rethink the thing in integers so for
example if you have money amounts you
can think of sense instead of euros and
then you don't have decimal points
anymore and then you are in much much
safer terrain okay and the other thing
is you can use something called rational
it's not a native Java feature but
you'll find libraries for that and this
rational thing is not so bad it doesn't
have rounding errors you can just as
long as you add multiply divide and
these things you can just do it and it
just becomes exact whatever you do but
there's of course issues the numbers get
huge each apply each operation kind of
doubles the amount of space that you use
so even if you do relatively trivial
operations you will always get huge
numbers and it will become slow if you
do real big calculations so that's
something that you have to keep in mind
it's not the thing that you can just
always use and then the other thing is
if you use double sometimes you
use these things logarithm sign seek and
and whatever these this transcendental
function square root and for rational
they don't exist but they don't fit in
rational with the result so that doesn't
help us and for that reason we have to
consider other options so there is
something called bigdecimal and this big
decimal is kind of the natural overflow
if you just want to do something like
double but with more space and you can
use this big decimal and you have
something that is very very valuable you
have an explicit control of the
precision so you can say I want exactly
this kind of roaming and then you force
it like that and just don't get some
default which might be wrong for you
it's of course much slower than floating
point and then when you look at these
sine and cosine and these things it's
very unnatural I haven't seen this
combination in my life projects but you
can find libraries if you use that and
of course again you come across this
issue if you want to write plus minus x
you have to use these method names and
you don't see the formula without
looking twice what it's really doing but
you can use it there's another approach
which is very interesting that is using
intervals so when you say you do
floating-point operations you always
round in some way and you can round in
both ways and if you do that then you
can keep both results and by that you
can at least say my result is within
this range you can be sure about that
and there's libraries about that and you
can go that way but it's a little bit
unfamiliar and I I just say it's
possible and it's useful if you really
need need it we come across another quiz
and you see this number 02 and now we
have this percent a I have to explain
you
that is the hexadecimal representation
of it of a floating point number so what
would we get there anybody has an idea I
just show you it's this and everybody
knows it i mean floating point you get
three point nine nine nine nine nine and
means for so more reason to worry but we
have to be careful because this is hex
and the 9 is not the highest hex digit
it's not this guy so we are really in a
bad area and the reason is in the
decimal system you can express
everything that is a fraction where the
denominator is dividing some power of 10
and here we can have the same so you see
the 17 one-third of course you get this
periodic thing in decimal system but
here we have of course the binary system
and there it's not powers of 10 its
powers of 2 so only if we have
denominators that are some powers of 2
then we get a nice representation and
the 0.2 is already a power of 5 in the
denominator and in dual in binary system
is no longer representable neatly so
that's the thing that we have to deal
with and you can just think that this is
the same as in the decimal system but
it's just applying to other numbers so
the question is how we deal with it and
the issue is is the decimal system in
any way a part of our business logic in
some cases it is in some cases it isn't
really if we calculate bridges for
example they don't care about decimal
system it just has to be stable and if
we calculate it in base 3 calculation is
right now is right and in that case it
doesn't apply but in other cases the
decimal system is actually part of our
business logic for example if we do use
euros and cents and do use the euro as a
base for whatever reason then it's very
much part of our logic and we can
rethink of course in intent long again
that's the most obvious approach we can
move to bigdecimal and then we are in
decimal system then we are clean with
this so the only thing that I want to
keep in mind is never ever use double to
express money yeah let's just no go use
integers use bigdecimal whatever but
double is just not right okay I've seen
it but please don't let's that's it so I
guess I just repeat there's three issues
that I told you the one was the integer
it uses modular arithmetic without
telling you the one is the double it
just has a limited precision and it
discards the lower end and the other
thing is the double it uses binary
system internally and so if you have
something that's neat and decimal system
doesn't have to be nice and binary
system so that's everything I could tell
you and then we have a little bit of
time for questions if you have some
otherwise yeah I wish you good luck for
the rest of the conference okay
and here you can see the github also
yeah where you see the examples for it
yeah yes the strict FP is basically just
tweaking the behavior of the double a
little bit and it's enforcing it that
it's independent of the hardware
everywhere the same and actually if you
look at the source code of the floating
boat implementations you see that it
does pretty much things like strict FP
although in other areas where it doesn't
have to but that's if you really want
reproducible behavior you can use strict
FP and you pay a penalty in terms of
performance and you're sure it behaves
the same on each VM and if you don't use
strict FP then you can kind of allow JVM
to cut corners and to be a little bit
faster and to be pretty good results
okay</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>