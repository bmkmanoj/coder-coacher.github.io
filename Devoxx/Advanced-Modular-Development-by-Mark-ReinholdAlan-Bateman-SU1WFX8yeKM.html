<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Advanced Modular Development by Mark Reinhold/Alan Bateman | Coder Coacher - Coaching Coders</title><meta content="Advanced Modular Development by Mark Reinhold/Alan Bateman - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Advanced Modular Development by Mark Reinhold/Alan Bateman</b></h2><h5 class="post__date">2015-11-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/SU1WFX8yeKM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning welcome to advanced modular
developments my name is mark i work on
java my colleague Alan Bateman will do
part of this talk as well and we should
have plenty of time for QA so we've done
a couple of sessions already this this
week we did prepare for jdk nine
yesterday and intro to modular
development yesterday also today is
advanced modular development and jigsaw
under the hood later which is a deep
dive into in jism technical details well
all of this is about technical details
while all of a reminder of all the
sessions at the end just out of
curiosity how many went to introduction
to modular development good good you're
ready for this talk then okay so this
talk is in in two parts the basic theme
here is okay you've got a system it
already exists you have some jar files
you have some third-party jar files that
you downloaded from maven how do you
convert all this Vermont into modules
and their two basic approaches you can
go from the top down you can think about
migrating your application first or if
you're a library maintainer you could go
from the bottom up and think about
migrating your libraries so the people
who use your libraries can use modules
more easily so the first part is about
about the top down approach application
migration that's what I'll cover and
then L and we'll talk about library
migration so typical applications heart
a typical application has three layers
you've got your jar files on the top at
the bottom you have the JDK or the dairy
and in the middle of this sandwich is
the filling right you got a bunch of
jars that may've been downloaded from
the internet for you and you just threw
them all in the classpath and hopefully
hopefully it all works in in jigsaw
we've turned JDK into modules such as
Java dot base and java dot logging and
java dot sequel and xml and so forth the
benefits of modules are twofold right
there are it's it's reliable
configuration so every module
specifies what other module it requires
there's no need for the classpath and
strong encapsulation so no module
outside of no modules internals can be
accessed by a module buy it buy it some
other module if this sounds good you
might be wondering how to turn your
application into modules let's put some
names on these jars to get started let's
assume that the main application is in
my apt are and it has some helper code
in my lib dodge are let's assume further
that the cloud of third-party jars is
actually small in this case it can be
simplified it's just Jackson the JSON
processing library so Jackson comes as
three jars there's core and data bind
and annotations if you look closely you
might see that the current version of
core and data bind is 263 but for
annotations it's 260 we don't know why
that is but there it is to run your
application today you have to ensure
that the classpath is set up like this
you wouldn't have to bother with all of
that if my app jar and my lib dodge are
turned into modules like this now
turning jars each jar into a module is a
fairly natural way to proceed it's not
always possible especially if the jars
have cyclic dependencies amongst their
classes but let's go with it for now so
migrating from the top down whenever you
see a module you should ask what does it
require and what does it export let's
ask that for each of our prospective
modules my app in my lib one way to find
out what a module might require is to
run the jdubs tool on the current jar
file jade apps is a tool it's in jdk 8
so you probably already have it it
analyzes classes and jar files and finds
whatever classes they refer to in other
jar files this these are the results of
running jade eps on my app jar and my
lib dodge are the classes of my up jar
make use of classes in jackson core r
and n jackson databind jar and of course
also my lib dejar plus my APR uses
classes from the java-based module like
java.lang.object and java.lang.string
and some classes from the java sequel
module my lib dodge are only uses
classes from java
bass so that's nice and simple with this
knowledge we can write module
declarations for our jar files here's
the module info Java file for my lip all
it requires is java dot base we don't
actually need to write that the compiler
will and will insert it for us if we
don't but you can write it as you want
to now jade eps can't realistically help
you with exports let's say that my lib
exports a package called calmed at my
apt libby util to the my app module that
we're going to make in a moment this is
a qualified export because it's specific
about which other modules can access the
package if a module is not named by up
than it cannot access that package now
let's turn to module info Java file for
my app it requires my lib our newly
created module and java dot base and
java dot sequel and of course we know
it's going to use jackson so we'd like
to write requires jackson core and
requires jackson data bind does that
mean we have to write module info java
files for those two that would be a pain
because we're not respond own thuy don't
maintain those jar files those are
maintained by by somebody else if only
there was some way for jackson jar files
to become modules automatically if we
could do that then we could write the
module in fata java file for my app like
this but requires jackson decor requires
jackson databind and then we'd have a
beautiful module graph with my app
depending on my live in jackson core in
jackson data bind and also on java dot
base and java dot sequel the answer to
this is a concept called automatic
modules an automatic module is a jar
file that you put on the module path
rather than the classpath you don't
change it you just put it on the module
pass once you do that you have a real
module you don't make any changes to the
jar file the module name is derived from
the jar file name in an obvious way that
module exports all of its packages and
it requires all other modules once the
automatic models spring into existence
for the jackson core data bind and
annotation
the model graph looks quite different
the automatic models basically require
everything that is they require each
other and all the modules in the JDK
image and all of your modules as well
this provides the maximum possible
compatibility surface for code in jar
files you might think that the module
system could run J depp's on the
automatic models that start up and try
to figure out what modules they require
but that doesn't really help for a
couple of reasons the first reason is
that libraries you find in the filling
of the sandwich often make use of core
reflection the java.lang reflect API or
method handles to load classes
dynamically jdubs can see the use of
quarry flexion but not the classes that
will be loaded because of course the
names of those classes are computed
generally at runtime the second reason
is that automatic modules are more
powerful than modules you declare in
module in without Java because automatic
modules can access types on the
classpath we don't want to scan the
classpath at startup trying to figure
out what jars might be accessed by
automatic modules in general that would
be quite slow so the module graph does
get pretty messy with automatic modules
but it's better than when everything was
a jar on the classpath for example
there's no arrow from my lib to my app
so there's no danger of code in my lib
accidentally reaching into my apps and
journals on the classpath code in my lib
jar could access code in my app dodge
are quite easily and that's what causes
all those maintenance headaches down the
road if you think about it the classpath
is is pretty crazy with just ten jars
you get 100 way possible ways for code
to interact the classpath is the
ultimate in erasure you thought generics
were bad whatever you know about the
structure of your system the classpath
throws it away and connects everything
to everything else this means that
conflicting classes and missing classes
and generally slow look up every time
the vm needs a class which is pretty
often with modules you're telling the
compiler and the virtual machine what
you know about the structure of the
system and finally they hear you
speaking of the compiler let's see how
you run it we've got the Jackson jar
files in the lib directory we treat them
as automatic model simply by moving them
onto the module path with the MV option
we've got the my my lap and my lib
source in the source directory we tell
Java Sea about this with the new module
source path option this is necessary
because there's a new level in the
directory hierarchy for modules its
source / model name / model info Java
and then all the rest of the source
files underneath that the result is
class files in the mods directory we run
jar to build my Libby are based on the
classes in mod / my web then we run
George build Maya BR from the classes in
mod / my app because the jar files have
module in photo class files they're
modular jars for my apt are we also
specify the main class and that's stored
by the jar tool in the module info class
file you can now run your modular eyes
application with this very simple
command line all the stuff from the
classpath in the past is now wrapped up
in the module in photo class files
remember the explicit modules are
located in the M Lib directory and the
automatic jacks and modules are located
in the lib directory to recap we
modularized the application with two
techniques first we build modular jars
for our own code by writing and
compiling module info de Java files
second we created automatic modules for
third party code simply by putting their
jar files on the module path so this is
top-down migration as I said you can
also do migration bottom-up and to just
discuss that here's Allen
so this is my favorite part of the
presentation because I can say to you
ignore everything that mark has told you
in the last 10 minutes ignore everything
you've heard about automatic modules
what we're going to do in this part of
the presentation is actually work on the
library itself and make it in explicit
module so we're going to use exactly the
same scenario in exactly the same
libraries that mark use in the first
part of the presentation we will assume
for this part of the presentation that
the the three Jackson jar files that we
have are good candidates to become
modules will assume that there's not
split packages there's no cycles and
what we essentially want to do is move
these jar files from the classpath to be
explicit modules on our module path so
anything green in these slides here are
our modules so we're we're essentially
working from the bottom and in this
scenario mark work from the top exactly
like Mark said earlier in the prayer in
the presentation any time you start
thinking about modules you have to ask
two questions what do they require what
do they export we've got three modules
we want to create here so there's six
questions that we're going to ask so in
order to generate the the understand
what the dependencies are and what my
require clauses are going to be in my
module info the first thing I'm going to
do is run Jay depp's again this time I'm
going to run it on the three Jackson jar
files so I can understand what is the
dependencies between those and what
other libraries and plant platform
modules does it depend on so in this
example we can see that the there is
some there is some dependencies from the
Jackson databind module to the core and
the annotations jar files and but
otherwise it's just dependencies on the
platform modules jade eps isn't the only
way that I could figure out those
dependencies if this is a maven project
then i can look at the palm there may be
other ways that as well that i may get
find out what the dependencies are if I
draw a module graph of that this is what
I actually see I see the data buying
module at the top dependencies and core
dependencies on data bind the
all have a dependency on java-based
because as we said yesterday every
module has a dependency on java based
whether whether it explicitly requires
it or not there's also some dependencies
on java sequel and java XML in this
example so now i'm going to try to i'm
going to start to write my module info
so i'm going to write the SRC / module
that info what i can i can do a little
bit better and at least get j dips to
create an initial java info that I'm
that are going to edit and in a few
minutes so there's Jade epson JDK age
it's it's enhanced in jdk nine with new
versions with a with updated version and
then in the jigsaw bills we have more
features again it's become really the
Swiss Army knife of static analysis so
there's an option on Jade eps that will
generate a module info from a set of jar
files and it will generate them into the
the SRC directory because we're doing
static analysis we now know what what
these library statically depend on and
that will help that would give us a good
start in writing the the module info
source file so in this example it
generates them into the SRC directory
same structure as we used in the other
presentations SRC / module name and then
it's the module info goes into the top
level directory of the the module now
let's see what we look at one of the
module in folsom jdubs generates and
we'll see what it looks like so there's
a big blue it's quite a large module
info in this case because Jay depths
does not know anything about which are
the exporter packages which are the
internal packages so it generates this
big an export clause for every single
one of the packages in the jar file for
dependencies then Jay dips is doing an
analysis on the signatures of the public
methods in those each of those each of
the types in the jar file and when it
sees that there's a public type for some
some other module it will generate the
requires and public so this is this is
part of the implies readability that we
talked about in the in the in the intro
slide yesterday so for these for this
there are methods that have that have
types in the Java sequel java XML and
the Jackson annotations and Jackson core
m modules so that's why it's requires
public for all four of those
dependencies now if I was the maintainer
of this library and we'll assume for
this part of the presentation that that
I am then I will know immediately that
some of these packages are not part of
the public API I don't want them in my
Java doc I don't want them exported by
this module so i'm going to edit this
this module info to remove the packages
that should not be exported and we will
assume for this example that any of the
data input packages are internal to that
module should not be exported by the API
so we will delete those lines so assume
that I've edited the generated module
info generator by Jade eps I'm going to
remove these lines so that these in what
I think our internal packages should not
be exported by by this module so I do
this for all three and now I've got a
reasonable module info that correctly
expresses the dependencies correctly
expresses the the exports from each of
the three modules we do exactly the same
as as marked in in the first part the
presentation will go on now to compile
and package those three modules so this
is the Java Sea and the jar commands to
compile and package the the three
modules so they're organized in our
modular source directory structure SRC
module name and then the class of the
source files for the the module or under
that the Java Sea command i'm using here
is a multi-module compilation and with
Java Sea in the Indian the examples
we've shown previously it was compiling
one module at a time it's possible for
Java Sea to compile multiple modules at
a time with a multi-module compilation
and the way Joe vecinos to do that is
when you give it a dash module source
path and so I can tell it this is the
this is the source directory all modules
under there and should be should be
compiled
and then using the jar command and this
is this these are in this is enhanced
option so the jar tool that will create
me a modular jar so it will essentially
just jar up all of the class files
including the module in photo class
files and create me a modular jar to
this jar command each of these jar
commands i'm using the dash dash module
version to add additional metadata at
packaging time so this is where i'm
adding the module version information
margin version information does not
appear in the module declaration it's
totally non interesting to the to the
compiler runtime to the java language
but it is important for information
purposes and this is the place to put to
add the version information packaging
time so now I've created three modular
jar files that and this is what we end
up with from the bottom again we have
our platform modules now I've got my
three modular modules for for Jackson
and this is a nice clean module graph
the dependencies are clear and the
module declarations have clear exports
for what each each of these modules
exports we will now go on and run this
no running this is a little bit more
complicated than that one mark is doing
because I've got a mix here I've got a
my app main application is my jar and my
lib that are still jar files and
everything else is module and underneath
so this is what my my command is going
to look like so a mixing class path and
module path so the command will
initially look a little bit complicated
so I've got my three package Jackson
modules in the in lib directory I've got
my application and it's helper library
my lip on the classpath so I've got dash
MP is short for dash module path that's
where it will find the modules Darcy PS
my class path and this is my to jar
files my app and my lib there may be a
thousand modules in them in lib
directory the runtime has no idea which
modules you want to resolve because the
jar files
that are my main application here is is
is on the classpath we have no idea what
what module should get resolved so that
is why there's an add mods option like
like the slides we had yesterday in the
intro Jack where we were mixing
classpath and module path we have to use
the add mods to tell which of the
modules in that we want resolved in this
case it's going to be the checks and
data buying module that we want resolved
because we know that it has dependencies
then on the other the other to the next
slide I want to show what happens when I
run this and this might initially look a
bit scary but it leads to the next part
of the presentation how we explain some
of the work that's involved in porting
some framework like libraries to two
modules so I'm going to run this and see
what happens and what happens in this
specific example is I get a scary error
message the message is actually in X is
is is an inaccessible object exception
what's going on here why did Mark not
get this when Mark ran with our
automatic modules earlier on even this
magically worked why is that and this is
we get into this in the next couple of
slides but the important thing is with
automatic modules in the first part of
the presentation we're getting
readability for free here we're going to
making the effort of actually going
through the work of port in library to a
to a module and we're not necessarily
getting this and readability for free so
explaining this error this this
exception that we're seeing there is
code in the in the Jackson data bind
module that has been handed a reference
to some type in some some other module
it's it's it's attempting to call set
accessible on that on that type and it's
getting an exception which is which is
new so what's going on here so back to
our little module graph that we had a
few minutes ago and this is the
readability graph we have the Jackson
data bind requires and the the core
annotations therefore reads those
modules it requires are under and and
reads a number of platform modules but
what's happening in this example is
there is some type in the my app or my
lib jar files on the classpath that are
being handed to the data bind module and
that is this clap what we call the
classpath is is is something we call the
unnamed module we get into more of that
in the under the hood later on today if
you remember from read in order to be
able to access some in order to be able
to access the type it you need to read
the module and it needs to be public in
an exported package in this case the
data bind module does not read this
unnamed module it does not read the
classpath so how we going to fix this
and this is what we want to get into in
as part of adding modules is to to the
to the platform there's there's a new
type in java line reflect that provides
you the the core reflection equivalent
of java.lang.reflect.method.invoke on
class to get the module that that class
is a member of so it's very easy to
ought to be able to get a reference to
the to a module for a particular type
java language will define the whole
bunch of methods and you can find out
the module name you can get information
about its original module descriptor and
so on there are two methods on there
dealing with readability you can ask a
module if it reads another module and a
module itself can opt in at run time to
read another module so the readability
graph that we had in yesterday's in
intro slide this is a readability graph
that is generated at startup based on on
the dependencies but it's important
particularly for frameworks that need to
access types at runtime in other modules
there is naught X and those modules are
not known a compile-time they're not
known as startup these are just these
are just typed in modules that where the
class preference will be given to that
framework at runtime so what we can do
in the case of the Jackson data bind
module is
we can update the readability graph so
that the Jackson data buying module
reads the module of whatever type that's
being passed at runtime and we do this
by calling the ad reads so the simple
patch to this module is to is to is to
get the module the java.lang reflect
object for whatever type it has been
handed and then do an ad reads to add a
read from itself in this case this that
get class that get module gets my mom
the module for myself so this is code in
the jackson data bind getting a
reference to its own
java.lang.reflect.method.invoke to this
unnamed module again unnamed module
thing class pad for now we get into more
the details as us on unnamed modules in
the under the hood later T later today
okay now i want to put everything
together we've got mark has done the as
moved the application and my lib to
modules we've we worked on the library
now and we've gone through the we've
gone through the pain because there is
some pain for some libraries when you
when you move them to explicit modules
and we bring them we'd bring these all
together so the second part of the
presentation we started with the
platform modules we've moved the three
jackson modules to explicit modules by
creating module descriptors recompiling
them and repackaging them we take the
two modules that that mark created in
the first part of the presentation and
wheel add them to this this graph and
what we have is a nice clean dependency
graph here there's no cycles everything
is is modules now I go and run this
assuming that every one of these one two
three four five modules have been
packaged up as modular jars in the
lib directory then the command line
reduces down significantly I can I just
specify the magic path where to find the
modules and what my main module is and
it just works each of the each my lip
will have the dependencies and the
transitive dependencies on the five plus
the platform modules they'll all be
resolved as startup and it just works so
that's really good and now we're just
going to quickly show how we might
actually create a custom runtime image
with with these these modules so I'm
going to go back to the jail Inc command
that we introduced in the intro slide
here and I'm going to create a runtime
image so I'm using the jailing tool
which is the linker that we have in in
jigsaw to create a runtime image which
with for this application so the jail in
command i'm specifying here i give it a
module path where it's going to find the
modules i'm using the add mods option to
tell what modules to link into the image
and giving it the output directory where
to generate that runtime image the
module path in this example has tutor
has two directories i'm specifying to it
one is where to find the package version
of the platform modules assume in this
example there's an environment variable
jdk mods where the package form of the
platform modules are an m lib is where
I've got the package form of my Jackson
modules and Maya and my lip I'm going to
look inside that generated image I can
see the familiar bin directory where I
have my launchers the conf directory
we've got the configuration there's a
Lib directory which wonder the lib
directory is is where all the classes
and resources are stored in some
internal format and then if I look in
the bin directory I see I see the the
launcher tools that are in this runtime
image in this case there are three
familiar Java launcher the key tool
which is used for managing certs
securities and isn't that is in the
cords in the base module therefore you
have to have a tool to manage the search
that's why that's there and most
interesting is there's a my app tool
that has been generated into the bin
directory that i will use in a few
minutes to run the
the application if I do bins / java /
list mods and for this example assume
that list mods is going to list the
modules that are in this runtime image
we see the modules that have been linked
into this runtime image we see the for
platform modules based logging SQL and
XML because they're the for platform
modules that are transfer lyric wired by
these by my application and it's
libraries we see the three Jackson
modules that we've linked into the image
and we have my app and its helper
library my lip so that's quite nice
we've got we've got whatever it is 479
modules in that runtime image so that's
quite nice I can then run it with a much
simpler command Java dodjem my app I
don't need to specify any application
module path because I don't need to be
searching the file system anywhere for
jar files there in the runtime image or
you can do a little bit better and
ignore the Java launcher completely and
just run my app so that's nice and
simple right just just to summarize what
we've got to so far is is am with the
automatic modules that Mark showed in
the first part of the presentation and
the explicit modules we did these we did
this migration totally independently and
that's the important goal with the
module system is is is that there is the
freedom to adopt and move to modules at
your own pace we can module eyes
applications before we marginalize
libraries and in the case of libraries
we can moduli 'he's them for the most
part independently of other libraries
and that's really good because otherwise
it'd be very very hard for the world to
eventually move to modules because
there's always going to be some jar file
somewhere that hasn't been maintained in
10 years that someone transitively
depends on with the ability to be able
to adopt modules at your own pace is
really really important and key to that
is what Mark showed in the first part of
the presentation is being able to move
some libraries as jar files on the clasp
at
they move those jar files to the module
path as automatic modules so that's that
that's an important part of the
migration story and adoption and the
other part then I wanted to get across
with wood and specifically picking out
that the jackson data bind module is for
some libraries there's going to be a
little bit of work to move them to
modules know the libraries it might be a
little hard might be a bit harder it
might be more work to do but I've just
picked an example that is a framework
like of library the M where it needs to
have some code changes in order to work
as an explicit module an explicit module
is where I go to the effort of writing a
module descriptor and either repackaging
or recompiling and packaging that module
so there is some work that has to be has
to be done when for some libraries when
you move them to modules so I think our
main message from this from this talk is
go forth and module eyes can be done at
your own pace so mark do you want to
come up for questions so if you left
loads of time for questions today we're
we're back in room five at 10 to six for
the advanced advanced section are under
the hood as it's called to go through
the signs of modules ok so for QA we can
do it by if I owe two channels when is
Twitter if you tweet at the jigsaw
hashtag and assuming the Wi-Fi stays up
all the way we could take questions that
way or if you're in the room and you're
not shy you can raise your hand and I
will run around like a game show host
and give you the microphone so that the
recording is actually audible so anyone
in the room mmm it's going to be tricky
if you remove the export of some module
or some packages from your module then
it might be that you need fewer public
requires can jaidev's infer that
automatically in some way or do I need
to figure out myself with you my modules
that I don't actually need to require
publicly anymore okay so if you drop
exports then you're making an
incompatible change to your library so
there there'll always be some impact on
the consumers of your library because
they may no longer compile they may no
longer run and what Jade eps does
attempt to create the the right if you
rerun jdubs it will create the it will
tell you if it it will generate a module
info that has either the requires are
requires public depending on whether
you've got types of that dependency in
your AP is or not it okay so I think
you're asking whether jaidev's takes
into account of the existing module info
it's just sit did the jdubs doesn't know
anything about the module info datz m
dot java file it just generates it it
doesn't it doesn't modify any existing
one that you have there maybe it's
something it should it doesn't yeah
maybe so prefer for the case of an
existing module if you if you modify the
module declaration in in the way you
suggested detecting so we're already
thinking about but there's already
featured to trip to Java Sea we're
thinking about adding to let you know
that oh you're exporting a package and
you should probably requires public
something else so that modules that use
your module will get everything they
need the do I think you're what you're
suggesting is perhaps the duel and java
sea would be the right place to detect
that it could see the module the module
info and tell you oh you're doing it
requires public on on the this other
module over there but you don't actually
need to so we should note that down and
and put that in the bin of
additional things to think about
somebody right here and I wonder why
don't you need versions in your module
info perhaps I missed it in a previous
page but that's okay that's a that's a
that is probably the most frequently
asked question so so i can i can i can
give a prepared answer in in in the
present design our view is that versions
are bests hand version selection is and
dependency management all of that it's a
really hard problem and it's best
handled by build tools such as maven and
ivy and Gradle they've already tackled
this hard problem they've got ways to
deal with conflicts and exclusions and
all that messy stuff we came to this via
path of actually implementing the first
jigsaw prototype which did do version
selection and as we got further into
that we realized oh wait a minute so you
know maven her gala they're going to be
doing version selection too and they
each have their different algorithms and
ways of dealing with it we're going to
do something is should it be one or the
other or something you know more ideal
we're actually we were on the verge of
integrating a thing called a Sat solver
boolean satisfiability which is
basically a big pile of heuristics that
can do a near-optimal job a version
selection and and we were thinking well
that's a really complicated thing to put
in the java runtime you do we really
want that and so pulling back we noticed
well no let's just not do version
selection so the so the model that the
model system has proposed doesn't do it
it relies on your build system to do it
if there's a version selection problem
the modulator it's a module system see
if you put two if you put two modular
jar files in the same directory of the
module path the jar files have different
names but inside they have a module the
same day the runtime the compiler
they'll just stop nope that's an error
that that's it that's your problem to go
fix go change your palm or your build
file whatever to fix it so that the
module system doesn't see conflicts now
the bottle system does accommodate
version
information because it's important for
exceptions of debugging and so forth so
when you package up a modular jar with
with the enhanced jar tool you can
specify as an option a version string
that will be stored in the module in
that class file and that's available by
reflection so you can show up an
exception exceptions message strings and
and in compiler errors so that that's
that's the approach we've taken it it
may seem surprising but it we're trying
to fit into the existing ecosystem while
also trying to provide a foundation for
the future if we were doing if we if we
had done all of this in 1998 then we
probably would be doing version
selection but we're not so
you're doing all these commands with
Java and modules is their progress being
made on maven to add commands for that
okay so yes we would hope in time that's
the ecosystem will take on and be able
to support modules and so the early
access bills and everything that we've
shown here is there really only
available since sep tember so it's a
very short window so but just a general
point just about modules and if Alex
were here Alex Buckley one of our
colleagues was here then I'm sure he
would he would actually point out that
and when lambdas and method references
and other changes to the language in the
streams library were added in in the
eighth time frame then the changes to
that were actually very localized
compilers IDs how to add support modules
is a much larger effort it's not just
the platform providing modules it's the
entire ecosystem has to actually upgrade
itself in order to support margins not
just the IDS it's them it's the mavens
as the cradles as a whole bunch of the
ecosystem will actually need to be
upgrade this is a really fundamental
change to the platform so it's going to
take some time to for all of the tools
in the under ecosystem to be able to
support modules so yeah it to that to
that point we've we've already spent
some quality time at javaone with a
couple of the maven committers jason van
Zille is a member of the expert group
for the bottle system jsr so is hans dr.
so you know we were we've done that done
a lot of ZAR social work to establish
connections and and working
relationships so that these important
tools can be upgraded well let me skin
let me skim Twitter here can I ice a
little isolate a library and a lisa
through module and export it through a
different package with jigsaw no
I mean in in general in a mechanism in
the vm that would make a class appear to
be in a different package is actually a
very deep thing many years ago we
actually considered it we asked the
question could we enhance the vm so that
you could make a class appear in a
different package than what it actually
is and it turns out to be really really
hard to keep the vm fast when you do
that so we're not going to do that what
will happen with shadow classes will
they still work sure what about
versioning yeah like I said frequently
asked question it's a different version
of the question did I didn't hear about
any sort of version range support no you
didn't that's true yet another version
of the court same question will job a
ship with a mod for repository now well
it's a to answer to add a little color
to that so e for java 8 and earlier you
can download a jdk image or a jerry
image the smaller thing one of the
deliverables for nine will be what you
can get a jdk image you can get a Jerry
emit image another download will be a
directory full of the platform modules
there won't be jar files they'll be in
this other format called jay mod if you
want to build a custom image you need to
download whatever set of platform
modules you need for the target of your
image but i think another part of that
that answer would be that in time
libraries that are published a jar files
today will be published in repositories
as modular jars right i mean that we're
hoping that you the existing maven not
central which everyone knows gloves will
become a repository full of modules and
and as well as other things that haven't
been migrated where there's no there no
plans for oracle or anyone else so far
as i know to create something brand-new
that's just modules why why would we do
that when David central is already
established and quite popular will
optional dependencies be part of jigsaw
yesterday's spring boss
mentioned that it requires that funny
you should ask because we had a
conversation with Jurgen holder
yesterday about this very topic the
original jigsaw prototype did have
optional dependences in it Jurgen does
make a compelling case that we might
have to put some back in we took them
out a couple years ago in a big phase of
simplification but maybe we need to put
them back in so sort of think about that
their questions in the room just an
optional dependencies one or we were
able to get away without those in the
GDK because of all the refactoring that
we did to move to services which is one
way to eliminate optional dependencies
so the question is about Jay link so if
understood well with jaylene can you
create a lot more specific version of
your application would it be possible to
cross-compile for example any window I
want to create a bid to booty teen
docker it would be possible yes you
absolutely can can cross link as long as
you have the dream odd files for the
target platform yeah and that's really
important for embedded applications you
don't necessarily want to be running J
link on your your pyre your atom board
or whatever yes oh trust try out the
jigsaw early access bills you should be
able to try this out there's a couple of
more advanced options related to
targeting little endian big endian and
so on if you go to the jailing help you
get some of the options on that what is
the name of automatic model is it the
name of the chart that's put in the
module pass director go what you would
is considered to the name of the meeting
no I think that the question is how is
the name of an automatic module computed
you take you take the name of the jar
file you lock off anything that looks
like a version string you change
anything that isn't a period to a period
and that's basically it it's very simple
yep it's the name of the jar but
transformed into a proper module name if
you look of any of the artifacts in
something like maven central you quickly
guess what the module name is
hi it is possible just a Java compiler
gives me an error if I export an API
that uses a non-public required module
we refer to John of the the honourable
gentleman to the answer we gave a few
moments ago sorry yes we're Java Sea
will eventually have a warning for that
exact condition if you if you export
something that uses a type from some
other module which you did not require
is public and it's just opportunity also
taken if you try to access this new
system if you try to if your public API
public method refers to private or
packaged private member's can we also
get a general warning for that and there
yeah but if java see I believe already
does that right Alan I'm not one hundred
percent sure on that but it's but it's
something that really fits in to ensure
we have got the right implied
readability yes it would be certainly if
it's not there should be it would be
desirable warning or error in that case
suppose I have a library that is going
to need changes ad reads we are
reflection when moving to the module
system and I still want to maintain
compatibility with jdk 8 is there going
to be any support for that steps Shen
more so it needs class dot gap module
right so I think this is a kind of a
specific question about if you're trying
to make use of api's inversion any but
you're actually trying to target you
want the this generated the compiled
code to still run an end up one then the
typical things you do is use core
reflection or you complicate your build
environment and having some classes that
are for N and some friend minus one so
it's the same type of problem also one
thing to have a look look at is some of
the work that's being done on multi
release jar files for JD canine so that
there can be a code in a jar file that's
specific to a
release that's that maybe also way it'll
company the build environment of a bitch
but it would get you to the point we
allow you to get to the point where you
have a jar file that is exactly what you
want okay couple more questions from
Twitter mixing multiple versions of
third-party models is it possible by
something usage in in different own
modules so in in in the in the simplest
approach to using modules there is no
support for multiple multiple versions
in the case of a simple application if
it's using the classpath today our
assumption is you only have one version
of any particular artifact or any
particular component on your classpath
if you have multiple versions of some
component on your classpath today then
your system is already broken and no
module system will help you with that
problem there there are more
sophisticated scenarios where you do
need to manage multiple versions of of
some module if you're writing an app
server for example you know each web app
you load might want its own different
version of apache commons collections
and there is there is a way to do that
with an advanced feature called layers
which i'll discuss in the under the hood
talk later today but out of the box if
you're just using the application module
path multiple versions are not a thing
do you see any issues applying modules
to the Java EE class loading model where
we're trying hard to up to avoid any
such issues obviously we've we've
reviewed a bunch of this stuff with
various Java EE spec leads an aspect of
the model system we haven't covered so
far yet is how does it relate to class
loaders many maybe all module systems
that have been built on top of the
platform have taken the approach of
using one class loader per module in it
in an attempt to get some amount of
isolation between modules the thing
about class voters is they don't
actually provide isolation they prevent
it's better than nothing but it's but
it's not realized isolation
the approach we've taken in in jigsaw is
to be as neutral as possible with
respect to class loaders so if you have
a system today that's spinning up its
own class loaders whether every class
loader has it whether every model has
its own class loader or you have
multiple modules per class loader is
entirely up to you the model system it
only requires some consistency in the
way that modules are mapped to class
loaders we know that every every
existing app server has its own way of
managing class loaders our intent is to
let them retain their existing class
letter architectures and be able to
slide the model system in underneath
without having to change that there's no
versioning in jigsaw now another version
job and I'd modules have fewer features
than osgi for good reason yes so oh
you'd like me to elaborate well alright
so SGI if you're if you're writing a
really sophisticated application that
needs the dynamic lifecycle features of
osgi the dynamic service registry and
and and the enhanced security model and
all of that is a fine tool for the job
osgi yeah since it's built above as in
the example as i mentioned a moment ago
since its build on top of the platform
can't provide true isolation so that's
one reason why we've done something
different because we can change the
language in the vm to have actual you
know modules as actual components with
with true isolation via access
controller rather than visibility and
also what we have is something that's
simpler that we think will be be be
easier to use and and easier to adopt
for most kinds of non sophisticated
application and applications and guess
what most applications are not that
sophisticated so the this module system
has never been intended to replace osgi
we've always had a strong commitment
that osgi needs to be able to work on
top of this and and we're already
exploring ways in which osgi could work
well and
and even expose a jigsaw model as an
osgi bundle for a set of OST I bundles
running on top of this model system so
there's definitely interoperation but
it's not the same thing and for some
good reasons alright more questions in
the room maybe on the side yes hello is
it possible to repackage an existing jar
as a module without the source code if
you just have the jar file and the class
files yep you can do that you can you
can draw the jar and compile module into
that class and redraw it good luck with
maintaining that long-term but yeah I
don't have the source code you can do
you can do that yep you've condemned the
cyclic dependency between the readable
things of modules before but with the
example of Jackson you've added a reads
to the app module again so that foods
create a cycle and maybe more
importantly if you want this to work
should you have the classes that would
be accessed by Jackson also exported in
your application or not right so there's
two parts to that so just on the on the
cycles in the graph I showed there
there's there's no cycles in the initial
dependency or readability graph but
cycles will naturally arise at runtime
particularly when there's frameworks
that are involved that are being handed
references they have to add these
temporary read ages in order for them to
work so yes the cycles can happen in the
readability graph at at runtime I think
the second part of your question is is
sort of a general question about
serializers and other frameworks that
where you're handing something some some
type to this framework that needs access
that it then and minimally that type
needs to be public in a packet in a
package that is exported to that to that
framework it may be exported
unconditionally or it may be exported
specifically to that framework
otherwise the framework will not be able
to access
I have a question zinnia treats what's
the scope of that modification that a
global modification to the Ritz graph
which is well it all the time until the
jb amends or is the temporary for the
method invocation ok so it's so adding
adding a reed edge is does me taste the
readability graph but it's not creating
any strong references that will prevent
that module from being unloaded orgy
seed there's there's no delete reads but
though the monograph at runtime is is
append only it's it's not immutable but
you can't remove anything run it yes so
I was wondering if there is a way to
prevent different modules to export the
same packages absolutely and then if in
fact you cannot have you cannot have two
modules in the mod for graph related to
each other with the same packages so
packet package conflicts are just
completely forbidden that's your split
back a split package is a sign of a
broken application generally moving two
modules in the type of refactoring that
you might end up having to do in order
to move the modules will be eliminating
split packages and eliminating cycles I
have a question you said that the HR
base is added to every module
automatically is it added that byte code
level so I could theoretically generate
the glass without java-based or is it
added at runtime ok so this is if the
module in four dots module info java
does not have requires based in the
compiler will automatically generate a
requires java base for you but you could
you could you could use a sm or similar
library to generate a module infotech
class file that didn't have requires
java dot base in it and I'm what is what
is the prototype do at this point it
should either fail or the processor will
fail yeah we'll jigsaw beyond up to our
next year's release we'll see
it's software sorry you're here to see
if there's an empty is well if there's
an empty module module in four then it
will actually fail but if someone else's
if he's got a requires an another module
that does requires on choirs public on
base then that'll work that's true yeah
interesting corner case it is a chronic
case our interface modules and provides
still in I'm not sure what an interface
multi services well right provides as it
provides us about services so an aspect
of jigsaw that we haven't discussed this
week because there's already so much to
talk about his services there's there's
additional syntax in module declaration
so a module can specify that it uses
instances of some service type also that
it provides a concrete implementation of
some service type and that that's
important information for the model
system so that if you have service
providers in your module path the model
system will pick those up and do it
additional resolution because the
providers might need modules that are
not required by your application
directly and the module system can also
implement consistency checks around the
the accessibility of the various types
and classes so services alle menschen
mentioned these are earlier they're a
very useful tool for decoupling modules
and they are in the system we could do
all probably a whole never talk on
services and maybe next year we will so
so that there they are there if you read
the the various documents off the
project page you can you can learn more
about services any more questions in the
room
hey I'm picking up on Jackson particular
might follow up on the spring discussion
but the you showed that injects and you
had to add the ad rates color did you
actually patch it yes and how many
places you have to patch it do you mean
to drip out Jackson arranged the ransom
drop the checks in Jackson source code
itself when you show the failure on set
accessible right when it was trying to
access the application class and you got
a failure you showed the snippet like
basically Jackson in those places where
ever it would try to access an
application class to invoke an
application class it would have to do
the idiot rich thing right basically say
like I want to actually my modules
supposed to be able to read that
application classes multi all right that
means when it might be a central place
in Jackson but my question is have you
actually patched it in in a way that the
checks and then properly ran eventually
in that example yes it's it patch
exactly like that that is the tooth the
two lines of code that we added and we
ran an ongoing like literally in the
Dakota did the set accessible to usually
I mean most remix have kind of a
delegate why they say like instead of
non-public here method or construct I'm
trying set accessible true then red so
it might be a reasonably central place
in most most code bases right but I
think I think what you're getting to is
is is that some frameworks if you don't
know that code base you may not know all
of the code paths that it might go might
might go through so it requires some
knowledge I think of the library in this
particular example then all the examples
that that we've used these presentations
are real we did actually modify the the
Jackson databind module with exactly
those two lines and ran that application
and form a from the right to do so and
the at runtime and is accurate dementia
scenario for example is a framework
generally allowed to do this at reids
call just for any other module daddy DS
receiving a class from okay the the ad
reads and there's also an ad exports can
only be done by module itself and it's
totally independent of whether you're
running with a security manager
you can't just add arbitrary read edges
from other modules to other modules you
can't break encapsulation by changing
some other module not run time to add an
arbitrary exports a module can only can
only export some of its own packages you
can't change some other module and
breaking calculation and a model can add
read edges from other modules to itself
wait you just adding read edges isn't is
is not really a security issue adding
exports definitely is this is why I
module can only occur you can't modify
another module make it export more
stuffing in India and main it it's the
same kind of fix for any frame of the
users reflection really to talk to to
interact with an application class so
that's nerm that's hibernate that's a
few places in spring may I'm wondering
from the spring perspective how we are
going to address this it's basically an
easy enough patch right kind of a
conditional code path literally right
we're saying when we run on JT canine
when there is the get module thing on on
the class we do the air treats by
default right we just do we do this
unconditionally right do we have to just
well we know that we are interacting
with an application class so we can kind
of unconditionally try the address right
we almost have to so we attempt the
actual implication yeah so it's kind of
a trying to some degree we are already
indicating that intent because we're
calling Seth accessible true but I guess
so I mean yes and there are those who
argue that if you invoke that accessible
in the way it should automatically add
the read it and listen yeah I mean for
example yeah and maybe it should with
that but that seems like like a
redundant way to approach it yeah am I
from a migration perspective the most of
the fur amex will already have that sort
of code in there but in order to compile
against get module in that reads any
particular to compile module info they
have to compile in jdk night it might be
an easier way out for quite a few of the
libraries and frameworks to just go the
automatic module way yeah i mean boo
wait we'll think about it yeah but we're
out of time so
we not from spring perspective we try to
do it or agree we need to stop now yeah
that's all right thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>