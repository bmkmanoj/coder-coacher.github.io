<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Language of Actors by Vaughn Vernon | Coder Coacher - Coaching Coders</title><meta content="The Language of Actors by Vaughn Vernon - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Language of Actors by Vaughn Vernon</b></h2><h5 class="post__date">2017-08-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/gHqxPV_lT_I" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right let's start all over again
this is a talk about the actor model and
a crossroads of the actor model between
also using domain-driven design so
hopefully I can give you a compelling
reason to look into using both of these
one being more of a technological
approach one the other being more of a
strategic and tactical approach to
implementing domain models if you want
to keep up with my latest work I suggest
that you follow me on Twitter and here's
a very interesting person do how many
here know of Admiral rear ha Rear
Admiral Grace Hopper you okay not that
many actually but Admiral Hopper was a
computer scientist and and actually
writing software for a long time
you can look her story up on Wikipedia
but the interesting thing about Grace
Hopper is that she was very much into
not wasting computer cycles or Network
cycles or any sort of areas of
performance now she was practical in
that she didn't expect someone to spend
an inordinate amount of time tuning an
insignificant part of their software but
she also emphasized not wasting
nanoseconds so I attended a live
presentation of Grace hoppers probably
30 years ago and one of her famous
manoeuvres during her presentation is
that she would hand out what she called
a nanosecond and a nanosecond was a
piece of wire
like you know copper wire in a in a
plastic coating about this long and
Grace Hopper said this is the distance
that light can travel in one nanosecond
and she said there are too many
nanoseconds that are wasted on by
software developers and she would
admonish software developers to clean up
their act to write software that was the
most performant that it could be in a
practical way of course on the other
hand we all know of Donald Knuth and
often Donald Knuth is quoted as saying
premature optimization is the root of
all evil okay a famous saying and I
think probably most of you here are
aware of of that statement by Donald
Knuth and who Donald Knuth is on the
other hand did you know that that's not
exactly what Donald Knuth said not
exactly what he said this is actually
what he said we should forget about the
small inefficiencies say about 97% of
all the time premature optimization is
the root of all evil yet we should not
pass up our opportunities in that
critical 3% I'm going to argue that
these days there's probably more than a
critical 3% because of the sort of
roadblocks that software that is not
written to be highly concurrent runs
into and so I'll make an argument for
concurrency in the age where concurrency
is almost entirely necessary because of
the kinds of hardware shifts that we've
seen in production of micro processors
and so forth
but you know something else that donald
knuth said he said people who are more
than casually interested in computers
should have at least some idea of what
the underlying hardware is like and then
notice this otherwise the programs they
write will be pretty weird so what does
that mean I think that applies today
because possibly even more so than then
back then but I remember when I started
programming you know close to I don't
know almost 35 years ago and I had to be
very concerned about the hardware that
my software ran on I was first writing
professional software on the very early
editions of the IBM PC and we had dual
floppy drives we had an 80 88 processor
and normally just about 256 kilobytes of
RAM so being concerned with how software
worked made the difference between a
COBOL implementation on the PC believe
it or not you could write COBOL for the
IBM PC 35 years ago but it took ten
diskettes to hold just the executable
pieces of the program and whenever a
portion of the program was not available
on the diskette a message had to be
popped up for the user to change the
diskette for example from diskette
number one to diskette number five plug
that disk at number five in close the
latch for the door of the drive and then
press some key to allow the program to
continue operation we took software that
very software redesigned it using the C
programming language and we were able to
contain
in the C program implementation of this
on a single diskette and we even added
more functionality business
functionality and even some technical
maintenance and housekeeping
functionality to that software and it
all ran completely in less than 256 K
and it was very fast and our customers
loved it so I think that we have to take
Donald Knuth advice in the day and age
that we're living and understand that if
we don't write software that has the
potential for being concurrent in its
solutions and also very distributable
then our programs or the software that
we're writing can be pretty weird we're
all familiar with objects I hope most of
you are anyway and when we deal with
objects such as the two objects here a
client object and a server object we're
used to the fact that when we make an
invocation from the client object to the
server object that that invocation will
cause the client to block until the
server finishes the request that we've
made and returns whether it's a value or
no value at all control goes back to the
client and finally the client continues
to operate this is a completely blocking
environment and so what we need to do is
potentially shift our thoughts from a
blocking environment to a non-blocking
environment in order to write software
for today's hardware that is not pretty
weird and this is why I make this
statement
in the year 1973 look at the way
processors were what kind of processors
was available so the clock speed of most
processors in 1973 was less than one
megahertz and there were probably about
seven to eight thousand transistors
available and Moore's law played out
which was actually stated in the 1960s
but it continued to play out for a long
time in that processor speed continued
to grow and expand and so did the
transistors so that we were seeing you
know every year like a 100 percent speed
increase in processors or at least every
two years which was the prediction often
times it was less than two years but
notice in about the year 2003 so 30
years after 1973 the processor speed
just basically tailed off it doesn't
mean that we aren't getting faster
processors it's just that we aren't
seeing the kinds of processor speed
increases that we did when we were under
Moore's Law as far as processor speed
goes interestingly transistor numbers of
transistors has continued to grow over
time but the clock speed of CPUs has not
so what do we do about that what does
that imply about the software that we
write so that we aren't writing weird
software one of the things that really
matters today is the number of cores on
the processor not the speed of the
processor or the cores themselves so
while we see maybe a 30
cent increase in in the generate one
generation of a processor to another
like this Intel processor what we
generally tend to see is actually more
cores while they're not much faster
cores there are many more cores
available and so maybe when we start
thinking about the number of cores
available we're going to say to
ourselves hey I can write multi-threaded
software finally it's really going to
count because I have a number of cores
that I need to to make the kind of
process or progress that I need in
concurrent software development and so
you get this idea that threading is
going to be easy now and it's going to
be efficient because of all the cores
but what do you think actually happens
to many multi-core designs or
multi-threaded designs so here's our
dream right we're going to create a work
queue like you see here and this work
queue has one thread that is feeding new
work into the work queue and so you
could call this or refer to this as
single writer but the problem with this
is there are actually multiple consumers
to this and this design sort of implies
that we have at least four cores
available so we're going to have four
threads running one is feeding the work
queue and the other three threads are
taking work out of the queue and working
on it
okay that seems like a fair optimization
to our software it's very easy to design
this and to make it work we can all
succeed with this right actually what
happens with this kind of design before
we know it is that we realize that
sometimes the thread that feeds the work
you cannot operate fast enough to keep
up
with the threads that are taking work
out of the queue and what happens in
that case is we have to start using
synchronization such as Java
synchronization to block so that any
changes to the queue will not overwrite
the point that we're you know the the
worker threads are ready to go
especially for we're using a ring buffer
and other problems start to happen like
in other words there's only going to be
one thread thread number for that is
accessing in this particular scenario
and notice thread 2 &amp;amp; 3 which are also
worker threads are blocked and the
thread that's feeding the queue is
blocked because thread 4 is reading it
so thread 2 &amp;amp; 3 are waiting to get their
next work to do finally thread 4
finishes and let's say that thread 2
unblocks at this point and gets some
work to do and it goes and accesses an
entity and then thread 3 gets its next
task to work on and it accesses the same
entity because there are two work items
or tasks to perform on the same entity
which one actually gets to the entity
first thread 2 or thread 3 well it's
entirely up to the scheduling and how
that works out it could be that that
thread 3 accesses and gets its task
after thread 2 and yet still makes its
way to the entity before thread 2 does
it's possible and so what we see is that
thread 2 and thread 3 are both
contending for tasks and contending for
the entity that they want to work on
essentially what's happened is we've
turned our multi-threaded very simple
work queue into a single threaded
application
so really when you think about it
multi-threading is not straightforward
and ultimately there's also a statement
that's that's been made among the really
you know let's say multi-threading or
concurrency elite in the Java world that
claims that most multi-threaded software
written in Java is wrong so what do we
do about this situation one option that
we have is to use the actor model the
actor model allows a sender let's say
putting this sender into the client
position so it's the client and the
receiver is the server so thinking back
to that object example where we had a
both a a sender client and a receiver
server the sender can send a message to
the receiver or server and the sender
does not block neither does the server
or receiver block that is because
messages are sent asynchronously so
instead of invoking methods on an object
we are sending messages to objects but
other than the fact that we've decoupled
temporarily the exchange of requests
between a client and a server there's
really not much difference between an
actor and an object in fact someone who
is noted as if not inventing the idea of
object-oriented programming at least
highly highly refined it and this is
Alan Kay and Alan Kay said that the big
idea of objects that he had in mind was
asynchronous messaging messaging between
the objects and we'll come back to that
thought but shortly after small talk 71
was released as in 1971 in 1970
three Carl Hewitt and some colleagues
came up with the idea of the actor model
this was a design that was articulated
far far ahead of its time
in Carl Hewitt's day of or in the
beginning of the actor model as a day in
1973 as I noted before clock speeds on
processors was less than one megahertz
and there were about seven to eight
thousand transistors so indeed Carl
Hewitt was well ahead of his time now
have you heard the statement before that
it seems like with all technologies all
sort of revolutionary breakthroughs or
innovations in technology and
programming approaches that there's
always someone who discovers it in
academia and that it's discovered again
in industry and this is actually at
least as I understand that what happened
with Erlang so Joe arms start strong and
others needed to solve some problems for
telecommunications and they came up with
an idea that essentially was the actor
model although again as I understand
that they had not read the formal papers
and and other industry material
literature on the actor model before so
in 1986 you know 13 years after Carl
Hewitt and colleagues do their work on
the actor model the actor model is
rediscovered in industry so a big step
taken there now note that even in 1986
having you know multi-core was not an
option and even having many processors
or even duel processors on machines was
at least unusual but by the early 2000s
such as 2003 when those processors speed
started to drop off
companies like Intel and others started
to recognize the need to produce the
ability to run multiple threads at the
same time and one of the first
breakthroughs that we saw in that area
was called hyper threading and then
following that was multi-core and Jonas
gone there of acha fame came up with the
idea to take the work that was done by
Joe Armstrong and Erlang and bring that
to the JVM and the Scala programming
language and then more recently a new
language has been written called elixir
and elixir runs on top of the Erlang VM
and and that occurred in in about 2011
so do you see the trend that we're
starting to move to a prolific
availability of multi-threaded support
through the actor model to allow
concurrency that is because it matches
what the hardware is allowing us to do
so this brings up the idea then of what
is reactive software anyway so reactive
software has four basic tenets to it or
characteristics one of those is that it
is resilient it's elastic another is
that it's responsive and all of this all
of these three capabilities are
supported by the fact that reactive is
message driven so are these messages
command messages or event messages or
just messages actually it doesn't matter
because all of those concepts are
embodied in message driven so responsive
this means that regardless of the
growing demand on a piece of software at
any given time
the software will continue to be
responsive and produce results at the
same rate that
was under less load resilient means that
when a crash occurs in the software that
the crash is not cascading it doesn't
bring down the entire application or
subsystem that where the crash occurs
now tell me with by show of hands how
many of you actually know what to do
with an exception when a service that
you're using underneath and I don't mean
even necessarily a distributed service
I'm just talking about an object that
you call on to do work throws an
exception how many here actually know
exactly what to do about that exception
and how to make the object recover from
the crash that has occurred to it and
have a successful outcome regardless of
the crash yeah we agree usually what
happens is the exception bubbles all the
way up even to the user interface and
the user is told what you just requested
didn't work try again later that's not
very helpful especially if we have a
better solution for them and resiliency
in a reactive software implementation is
quite important and the reason for that
is that the software the client that
calls on the service to perform a
request in its behalf
does not have to deal with the exception
or the crash that occurs on the server
when you're using reactive instead or
especially with the actor model instead
the parent component or parent actor of
the child who crashes is the one who
knows how to deal with the crash help
the child to repair itself and then send
it on its way to perform the action that
it was intending to
perform and the only thing that the
client actually has to worry about is
did I get a response if I didn't get a
response then I'll ask again and I'll
just keep asking until I do get a
response or there's some sort of timeout
that occurs but at least we can then
give a kind of intelligent response to
the user and allow the software to be
both resilient and responsive elasticity
means of course that a solution a
subsystem can grow and shrink as needed
according to demand and all along this
is all driven and sewn together by the
ability to deal with messages as the
messages occur so why is the actor model
so important now well we have a lot of
advances and I did mention cores
multiple cores but let's just think
about the the decreasing expense of
storage the decreasing expense of memory
the fact that networks are becoming
faster even more reliable even though we
know that networks in general are not
reliable there are still networks that
are much much more reliable than we've
been used to in the past the fact that
Internet of Things matters these days
and is will probably continue to grow in
in usage where there will be many
billions of connected devices and all of
these things are basically cheap but to
re-emphasize the fact that cores matter
note what can be obtained today rather
commonly and without very much cost so
the the Xeon processor the Intel Xeon
processor can support up to about 88
cores and then if we decide to
coprocessor with the xeon phi we can
actually get two hundred-plus cores on a
single processor and actually it's not
even uncommon at all for processors to
to support teams of of cores or or even
you know 24 cores or 30 some cores so
even at that we have the ability to run
a lot of simultaneous requests and
respond to those the actor/model also
allows us to embrace latency whenever we
introduce the network we are
automatically introducing latency
because as soon as we make a request
over the wire we don't know whether that
wire is going to be fast we don't know
if the server on the other side of the
wire is even going to be available is it
is it clustered or is it single instant
single node we don't know but one thing
is for sure if we design for latency in
our software latency will that will then
not have a limiting and devastating
impact to the operation of our software
and when we design for the actor/model
we expect latency there will always be
latency because sending a message from
one actor to another actor always
introduces latency we will never get a
blocking response back from another
actor so if we treat everything as
actors we are embracing latency and we
are preparing ourselves for success on
the network another thing that I like to
point out and I and I state this on a
fairly regular basis some of you may
have even seen a tweet that I produced a
couple weeks ago I saw this you know
other tweet that was quite interesting
and the the assertion by this developer
was you are not Google do any of you
remember that tweet maybe you saw it
and I said I say this often and it's
actually rejected often you know so many
developers want to do things that put
them at the scale or at least allow them
to pretend to be at the scale of Google
of Amazon eBay Netflix and so forth and
yet that's rare very rarely the case
that we're working in that kind of
environment and yet why would we choose
to use the actor model when we're not at
Google scale frankly it's because we can
do more with less
if our solutions currently run on dozens
practically possibly scores of servers
even hundreds of servers the chance is
quite high that we could reduce the
number of nodes involved in our solution
down to just a few because our software
is running much more efficiently than it
ever has before because of the use of
the actor model so consider the ability
that concurrency and distribution gives
you in the overall solution to actually
simplify the entire topology that you're
faced with on a day to day basis so the
actor model as I said supports direct
asynchronous messaging it's lock-free
share nothing so there's nothing in the
actor model that requires blocking or
locking at all the sender and the
receiver of a message do not need to
block in order for the message to be
given to the sender even if there are
multiple senders simultaneously it
doesn't have to block and there's a
share noting environment where actors
never pass out an internal reference to
their to their state that allows another
actor to twiddle with that state without
sending in a message so messages must be
sent to get any state mutated in the
entire system
an actor has the opportunity to prepare
for its next message which means that
when one actor sends it a message it can
decide that a state has transitioned to
the point where it can become another
kind of message listener and when it
becomes this other kind of message
listener it will then be prepared to
deal with messages in a different way
than it would have under the previous
state this is called become if you're
using akka and actors come in systems as
it said one actor is no actor as in Carl
Hewitt making the statement one actor is
no actor actors come in systems and
therefore you may have a variety of ways
that actors are representative systems
in this case like akka is a hierarchy
and we set up hierarchies of actors in
order to be resilient and provide
supervision in a hierarchical way and
actor concurrency of course we expect
concurrency but this illustrates
concurrency at a very interesting level
do you notice these sequences that are
occurring sequence 1 sequence 2 sequence
3 but wait a minute
there's a sequence 2 in a sequence 3
down there did I make a mistake with
this no what we're talking about is that
the 2 number 2 sequences are happening
simultaneously as the router actor is
asking for a scheduled event a timer
event to be registered for the router
itself the router has also already sent
a message to a receiver and the receiver
will react and now there's a race
condition and I don't mean a dangerous
race condition I mean an optimal race
condition that says will the timer time
out and will I get a message that tells
me that the timer timed out before the
receive the receiver of the message
provides a reply a successful reply to
me
if I get the timeout message first it
means that we're going to tell the
client that we failed or timed out if we
get the receivers reply first we're
going to tell the client that it
succeeded now when we use actors how
many actors do you think are practical
if you're thinking in terms of maybe
some kind of messaging mechanism
it might sound to you like well if I had
50 you know message listeners in my
application that might be all that we
can deal with maybe we even have 100
message listeners so we have a bunch of
consuming competing consumers spread
across our our particular subsystem but
actually remember that actors are very
much like objects in fact they're just
like objects except we do not invoke
method on the methods on them we send
them asynchronous messages and so
actually having a million or more maybe
even several million actors in a single
VM is not unusual at all so actors scale
another thing that can be daunting for a
software team is the fact that the
architecture of a typical Java you know
sort of NP or multi-layer solution can
be quite complicated this is called a
ports and adapters or hexagonal or
hexagonal architecture or maybe you even
call it the onion architecture but look
at all of the components that a
programmer needs to understand and
become expert on in order to use this
kind of architecture so we look at it
tipped on its side and there are a lot
of different concerns along the way that
we need to learn how to deal with with
the actor model however I think that
this produces the opportunity to have a
what I call the simplicity stack where
literally we have a UI with controllers
backing the UI in our simplified
architecture and literally the
controllers can be the
components that hand off messages
directly to the domain model and you may
be concerned that this is going to make
the controller method very busy actually
you can write a controller method that's
five or ten lines and lengths easily
probably even mostly five to seven lines
of code that will handle this entirely
without any problem at all and once the
actor domain model object has controlled
by means of it receiving and processing
a message what it can do is simply emit
an event and therefore we have a command
event based architecture which is
message driven which is resilient
elastic and responsive so how do we
cross the the bridge over into DDD land
with actors so we of course have Eric
Evans seminal work on domain driven
design and his book that you know
continues to sell at near number one
raid in its category and on Amazon which
means it's really picking up popularity
and and not just popularity in terms of
interest but popularity in terms of full
recognition that DDD matters today and
it's helping a lot of teams to succeed
so we can use the essence of domain
driven design such as the bounded
context and a ubiquitous language within
a bounded context which gives us a
semantic understanding of the components
that operate inside the bounded context
and as they do so we understand as a
team everything that works in our domain
model works because we have built a
language around that the semantics
around that and it's not only the object
names or the or the class names or the
actor names it's also the names of the
operations and and the deep
understanding of the business sense
that's involved in having a model that
works
beautifully if you will in terms of what
the business needs and the mental model
of domain experts you also have the
ability to map various bounded context
since you are using smallish bounded
context with domain driven design you
will always have multiple bounded
contexts or even unbounded legacy
systems such as big balls of mud that
you're going to be integrating with and
when you do that you're going to need
the strategic design tool called context
mapping so there is a bit of detail
involved in understanding these two
major concepts around strategic design
of DDD and I suggest that you look into
those they're very powerful tools so
today I think that what we face as
developers is a demand to keep up with
the churn of business where the business
doesn't just churn on the same old ideas
but the business turns on brand new
ideas even on a daily basis how do we
keep up with that how do we make
releases to the new ideas the demands
for new business direction I think that
domain driven design is an excellent way
to tackle or you know make the
complexity surrender and and we tame the
complexity of these new business
concerns and as we tame the complexity
of these we're doing so through
knowledge crunching we're learning
everyday about what the business needs
in order to succeed and not only to
succeed but actually to to be prominent
in the direction of their business and
actors can allow us to make rapid
progress on this when we shrink down the
architecture to a very simple
architecture it can help us not only to
reason better about the software that
we're producing but actually have less
new
moving parts and focus on the actual
business aspects of the software rather
than all the architecture that's
surrounding it and all the components
and layers and and the need for massive
garbage collection that we fall into
many times so think of the actor model
actually as a way to accelerate your
development and here again I need to
emphasize that Alan Kay the inventor of
the small talk language said that the
actor model retain most of the the ideas
or what he thought were the good
features of the object idea so the
person who invented object-oriented said
this is what it's really all about and
you know when he said that the big idea
is messaging Alan Kay said that there's
this Japanese word I think the word is
ma or something like that roughly spoken
but ma means the space between and maybe
even Conrad is here he could correct my
Japanese if I'm wrong about that but of
it as I as I recollect it means the
space between objects and so he is
talking about the the fact that messages
between objects is the really important
thing not the implementation internally
of the object itself and actually we put
so much thought and so much energy into
it into the internal implementation and
design of objects that sometimes we
forget that really the most important
thing between objects is the MA or the
space between that is communicated on by
sending messages between them and so
because of that we have the opportunity
to implement the ubiquitous language for
a given bounded context by use of actors
by actors sending messages and the
messages actually reflect the the spoken
language that our team shares together
so for example we have a command message
incoming to an actor and the actor
produces another message which is an
event message all of these messages are
are very very important because they
carry the ideas of the ubiquitous
language and in addition the product and
the backlog item actors that are
involved in in these two stories or use
cases or scenarios are themselves part
of the ubiquitous language how do we do
DDD then I mean you know oftentimes we
wonder how should we use domain-driven
design in a real project I think that
these sort of five points are the most
important at least to me they are DDD is
about talking to your customer whether
your customer is a colleague and your
own company or whether your customer is
outside at some other business that you
consult with and once you talk to your
customer you should be able to write
some very straightforward scenarios
about what their business is looking for
we iterate on everything that we do
including the scenarios maybe we can
actually produce only two or three
scenarios or maybe just a few more and
from that it allows us to get into a
strategic level of event storming and
then as we iterate on that we're getting
a deeper and deeper understanding and
then we can go into a tactical level of
event storming which again is iterative
and then finally we are working on
implementing acceptance tests and the
model code where we're actually
projecting the ubiquitous language right
into the domain model and we're
iterating on that as well and we
continue to iterate on all of this
having more and more conversations with
the business so this is event storming
you can read more about it in my
distilled book there are other
resources available online for
understanding events storming and I'll
be going into this more tomorrow in my
lab at nine o'clock in the morning but
essentially we take the the design level
event storming and use that to implement
aggregates or domain driven design
aggregates as actors with the use of
command messages event messages and we
iterate on that an interesting approach
to implementing an actor internally or a
domain object internally is to try to
make most of the internal parts of the
actor immutable because actors are
naturally mutable state we do have to
allow some things to mutate but we can
limit that down to actually just one
variable and the rest of the actor state
can be treated as immutable and in fact
in a very functional way transactions
are controlled by the aggregate itself
so we don't need a transactional layer
above the actor and we're emitting a
corresponding domain event which can be
used in a eventsource way so here's a
brief look at a naka persistent actor
that is is fulfilling the role of an
aggregate named product and this actor
allows us to bring in or accept an
incoming command message it translates
that to the corresponding event and then
emits the event that will be stored and
and it will also represent the state of
this actor internally as the stream of
events builds up and we can mutate the
state as you can see this is done in a
very functional way where we're
replacing the previous state with a new
state and yet the actual product state
object itself is immutable and used in a
functional way so this is as simple as a
client can be and think of this
as being the client at the controller
level we simply send the message to the
product after getting a new actor
product with a unique identity and that
message is handled as an incoming
command which will then produce an event
and from this we have the ability to
then interact with different bounded
contexts and as we do so we're
translating one ubiquitous language to
another ubiquitous language as the
messages cross context boundaries and so
are reactive subsystems or reactive
services build up into whole reactive
systems now one thing that I have
neglected to warn you about is that when
you start developing reactive systems as
a whole we have to say hello to
uncertainty in fact we have to embrace
uncertainty and I'll be talking more
about this down the road I'm not going
to go into detail right now about that
but here's a resource that I have if you
don't have the opportunity to attend my
lab or workshop tomorrow morning at 9:00
a.m. then take a look at this github
repository which has a set of slides
that basically matches this presentation
roughly speaking and it shows you
actually how you can use domain-driven
design with actors in at least four
different languages and four different
actor models so one is Scala with akka
another one is c-sharp with net another
one is elixir and another one is pure
Erlang so that's all that I had today I
hope that this has been instructive you
can read more about domain driven design
I have quite a you know heavy duty
reference called my red book or
implementing domain-driven design and I
have my distilled domain-driven design
book which has been released for roughly
a year and then also a book that gives
us a good idea about how to use the
actor model so I welcome questions
afterwards but we need to end this
presentation now thanks again for
attending</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>