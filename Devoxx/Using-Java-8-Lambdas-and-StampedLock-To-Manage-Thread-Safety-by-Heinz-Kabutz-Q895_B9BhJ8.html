<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Using Java 8 Lambdas and StampedLock To Manage Thread Safety by Heinz Kabutz | Coder Coacher - Coaching Coders</title><meta content="Using Java 8 Lambdas and StampedLock To Manage Thread Safety by Heinz Kabutz - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Using Java 8 Lambdas and StampedLock To Manage Thread Safety by Heinz Kabutz</b></h2><h5 class="post__date">2017-05-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Q895_B9BhJ8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Birgit you play kit do it make sure now
this talk is about three different
things
it's about stab block number one how
many of you how many of you know what
stem clock is okay so one person it's
good if you learn something
it might not be useful but it might be
mildly entertaining and then we'll learn
a bit about lambdas some if you'd know
what lambdas are whoa okay G and then
something about var handles how many of
you know what var handles are okay so
two people have viola sauce so you will
learn something which is good now the
the first question is why should you
care what stamp block is why should you
know about it or where would you use it
now the okay not another question how
many of you now want to read write
lockers okay then let's actually pretty
close to lambdas and that's scary
because that is not a very good class
you shouldn't know whether it is should
put your hands down next time somebody
else do that
it's like saying do you know what
reflection is don't say yes and the idea
with the stem talk is that it gives you
the read/write capability of a
read/write lock but it also and the real
intrigue read/write lock the read lock
is what we call a pessimistic read
pessimistic means that whilst I'm
reading
nobody can modify nobody can get a right
look that's means pessimist agreed lock
so the non exclusive pessimist agreed
lock that's sort of the reentrant
read/write lock with the stamp lock and
you can also do an optimistic read which
means whilst I'm reading somebody else
can actually do a write without without
any problems now the optimistic part
allows you to read fields whilst are
being modified so if you've got a class
where there are multiple fields and they
summon variant across those fields then
the stem clock can help you to to
to read quicker to get better throughput
less blocking less contention and still
be correct you have to be but careful
that you don't accidentally end up
causing exceptions because the
invariance could be temporarily broken
whilst you reading so every case of
things like error index out of bounds
exception x' and class costs exceptions
and things not products different things
like that
now it's also quite a lot faster than we
entered readwrite lock to use if you
need that type of functionality have a
look at stamp look and there was one
example some company I don't remember
who there were some financial guys they
wanted to have the trove collection
framework they want to be use that in a
multi-threaded environment
now trove the idea was is that it's like
a it's like a collection of primitives
so if you want to have for example in a
map of in too long for example then with
a normal hash map you would have integer
objects pointed to long objects and you
don't have great data locality and you
don't have and you have a lot of extra
extra objects or extra memory being used
to store this and so the idea was trove
is if you have instead just you know
interets and and long arrays for example
something like that it's basically use
the lot less memory having primitive
collections but it's not thread safe and
so what I did was they wanted to to make
it a thread safe but in a way that when
you reading
you're not blocked by a writer or the
writer is not blocked by reader all
right and they didn't stamp locks
they're basically hacked into that
changed it and use them block to make it
faster and now the stamp block has some
advantages this one's faster secondly
you can upgrade a read to a write lock
that sort of was the whole point of that
previous puzzlement before we started so
if it's not on the recording that's too
bad
sorry and now it also makes you look
smarter than your colleagues because
next time when you somebody says do
notice this time clock because you can
say yes
I know I've got no dear how it actually
works but I know what it is at least
which is quite cool now here's what it
looks like it's basically clusters Java
8 and it gives you read and write
functionality and also optimistic read
so basically if you say right lock on
the stem block you get back a number
this number will every zero but it might
block there are other methods like try
right lock which can return 0 if the
right lock is not currently available
and we've got to try convert to right
lock so this would allow you to convert
a read lock to right lock to try to
convert a read lock to right doc with
the lantern tree drive drug you can
never upgrade a read lock to right look
but with this you can try it might not
work but then it's again it might work
ok the next one is unlock unlock right
so with unlock right it checks that you
really are holding a write lock rather
than read lock or an optimistic read
before it does the unlock so you get a
really good monitor set exception or
something like that
if you get it slightly wrong ok and now
limbs interesting about stem clock and
this is not a feature is that it's not
reintroduction are try and get a write
rock again within the same thread it
will deadlock so that's that's one of
the things you need to be aware of and
the other methods I've left out you can
check it out yourself
then another if you're doing reading
this is what we call a pessimistic read
it's a non-exclusive read so multiple
threads can read at the same time get a
read lock at the same time again you get
it the same type of method to get a
number back or you can have an unlock it
can plug invert to read lock so you can
for example try over to write off to
read lock you can try and convert an
optimistic read to read lock em and
unlock read would again check that it is
actually a read stem before unlocking it
and there's also a general unlock which
unlocks any sin
read or write doesn't matter
now we also have optimistic reads and
this is not a lock right because it's
nothing is locked it's not pessimistic
it's optimistic and we're saying here
that the optimist agreed would return a
0 if the right stamp is currently being
issued so if somebody if you call
optimistically but somebody has is
currently holding a right lock it won't
block you it will immediately come back
with a zero now one of the keys is that
you never check whether 0 you always
assume that it's not zero because you're
being optimistic you're not being
pessimistic you're saying well you know
I'm sure it won't be zero and then you
just carry on working and once you
finish to you doing your work you then
check has the mean time anybody acquired
the right Rock or maybe and the right
block was actually acquired before I
start maybe the stamp was zero so after
you after you've read the fields in two
local variables then you call that a
date and you then gets back true or
false whether or not it's possible that
somebody has modified the fields and
therefore broken and invariant by the
time you come back so that's true volts
all right I live on the island of Crete
and a few years ago we had a live
crocodile walking around Crete now you
can buy almost any pit that you might
want in Crete including including of
course as we discovered crocodiles right
together with ak-47s and there's a
there's a working functioning German
tank on Crete and some in the sauce and
you know in the mountains in the south
so yeah the crocodile in this crocodile
was walking around Crete and and they
discovered it and they thought this
can't be true this must be like an April
Fool's joke they even gave him a name
called cephas because that's a very
common Cretan name and he would he'd I
had because and it got too cold it does
actually called and Crete
well we're you London yes it's warm here
too sir but it gets called and and now
imagine if you want to go from one place
to another so I wanna go from position
naught comin or two fires comma fires
and I want to go in the diagonal line I
don't want to go and accidentally become
crocodile food so I want to go from
there to there right so that's good I
don't want to ever see an intermediate
State a broken invariant where I'm
seeing a partial update of the position
but because then I become crocodile food
and that's not very comfortable so there
that's bad we don't want to see crockery
we don't become fertilizer for the for
the lake and and so in other words we
want to move x and y together but they
are two different fields I've got a
position with a double X and a double Y
and I've got a stem block inside now the
move is very similar to reentrant lock
or ancient readwrite lock or synchronize
actually because basically what you're
doing is you're saying I'm getting a
right lock I'm saying that no one can
actually read or update this whilst I'm
working with it and we update x and y
together x plus equals delta x and y
plus equals Delta Y and then finally we
unlock the right lock okay so when we
read it we want to make sure that we
always get the correct position we don't
want to become crocodile food so the
first thing we'll do is we'll try an
optimistic read we'll try and read X&amp;amp;Y
in two local variables if we succeed
that's fantastic then we happy if we
don't succeed then we could try a few
times and see whether or not we now
again successful within a reused amount
of time and or we can say that if we
can't get it optimistically we're going
to do a pessimistic read now a
pessimistic read it still allows other
threads read at the same time but it
won't allow another thread to write
while some busy reading so this is the
little benefit here and the
the algorithm looks something like this
is sort of the general idea I first say
stamp equals s other plastic Club Thomas
agreed and this might get back give back
the value 0 if it's 0 then somebody else
is busy writing or might be busy writing
they have acquired the right lock so
they might be updating it so we're not
sure that the state isn't dirty but we
assume that it's not 0 because if we
check that it's there or not we are
delaying we increase increasing the code
path from the try to the validate and it
decreases our chances of being
successful that's what we never checked
we just say ok it's not going to zero
with us can it continue and we then read
the the fields into the local variables
and you have to be slightly careful here
because when you do that you might read
dirty state so you might actually end up
with air index out of bounds exception
ok
now you obviously know that it doesn't
cost anything to cause an area set of
bounds exception oh it's very very very
cheap to cause one of those exceptions
you know that you knew that oh that's
very few ok it is very very cheap to
cause a class cast exception and I
really sort of bounds exception a null
point exception that's it's a it's a
it's optimization that put in because we
are such dumb programmers that we cause
these things all the time right so you
might sometimes see in your vineyard
well you might sometimes see in your
output in your log output and null point
exception without a stack trace no
Specter it's just no point exception
you've seen that ok
maybe you'll also see class cast
exception maybe you'll see how any sort
of bounds exception with our two stack
trace now you've done that before
all right it's when you do it many times
in the same place it optimizes that and
it takes where the freedom is getting
you to get back an empty null point
exception or any sort of bounds
exception so actually they are almost
for free you don't pay the price of of
fill inspector a so
get sector s so it actually ends up
being quite cheap you know let's go back
to this you need to be careful here that
you don't end up violating getting
exceptions because you are possibly
reading dirty state but we assume not we
assume everything's gonna work fine then
after we've done that we validate
whether or not the stamp is still valid
which means and first of all stamp is
not zero and secondly since I acquired
the stamp no one else has asked for or
right stamp now this it can happen of
course it'll get false positives it can
happen that um that when validate comes
back it comes back as false but actually
the state is correct but we're just not
sure that there's not a lot dirty
because of course you don't know when
it's really going to be written so it is
earring on the set on the side of
caution of it so in my algorithm here I
just try a single time but it could try
three four five times before going for
the pessimistic read and so now we do a
read lock and we we update the state and
this means that no one can actually get
the right lock last we're doing this and
after that we unlock the read again and
now we've got the the field values in
the local variables and we can use those
for the calculation the way that this
would look for our position is like this
we would first of all get current X and
current Y read them into X mind to those
now there might be invalid you might
have 0 comma 5 in any happen see if
these drawers we don't want that
and so we check afterwards and if it's M
if it's not valid then we simply try
again with the pessimistic read look
right the four move on with any
questions about this this algorithm yes
sir
okay
the question about X&amp;amp;Y do they need to
be volatile they don't need to be
volatile the try optimistic read is
already a volatile read and the
validators is another memory barrier so
you don't need to make your fields
volatile any other questions all right
very good great questions thank you now
I want to show you a slightly different
approach to this how you can also write
this using sort of value holder objects
so this is going to Atomics atomic field
update is unsafe you don't know if it is
I'm not talking about this stop this
from the recording okay but anyway hi
this and and then also the the VAR
handles which is the driver nine stuff
and instead of doing the the code the
way we did it we could also use atomic
references so we make it a holder object
for example because it's just two
doubles I can make a double array of
size two or I could make another class
inside that holds x and y right final
field XY so in the mutable class I can
do that too and my atomic reference
would now have a pointer to the double
array and then I would I would have
inside the move method I'll do something
like this I would say double array
current common x equals the new double
array so I want to create a new order to
write a new double array to replace the
old double array and oh then they do
current equals XY dot get so I get the
current value that's that's inside the
Tomic reference and and then I then sit
the next array equal to the current zero
plus Delta X and current one plus Delta
Y so I work the array not contains the
new position I want to write to I then
try to write it now you to support
concurrency you need to have hardware
support without hardware support is this
doesn't work it's
you need it so the hardest is what we
get a something called compare or
campaign set and a complete set is a
method which which what it does is it is
a tries to update the memory location
but what you do is you pass in the
existing value so you pass in the value
current let's say I'm expecting it to
still be equal to current and if it is
equal to current and it doesn't stop and
it changes it to the next one if it's
not equal to current something else has
updated in the meantime then it will
come back with false and you'll have to
try a second time okay so this is the
typical algorithm that you'd use for
this this is a non blocking algorithm it
doesn't this if I have five threads
which all call move at the same time one
of them will progress will actually say
success and the other four will have to
try again so there's always somebody
making progress at every single time in
theory one thread could forever retry
but in practice that won't happen what
doesn't happen fortunately so this is
how the atomic reference works atomic
reference means that I've got from my
position object I've got a pointer to
another object which is atomic reference
and from therefore appointed to another
object which inaudible array and another
way of doing this with something called
atomic reference filled up data M which
means I can store my double array inside
my position directly so this is my
private volatile double array and then I
can make my atomic reference filled up
data this update allows me to do a
compound operation I contain swap
directly on my field so I've got one
less indirection for accessing these
fields and in this case I do want to
mark it as volatile right because I'm
going to read the value of the double
array a little bit later I'll show you
that so the tradition is if you're using
reference field of datas then that case
you want to always make your fields
volatile it's different to stamp block
you don't need
for stem block but here you need it and
now the algorithm done here is almost
exactly the same as there's a previous
one except the way that we call compy is
we're different now um how many of you
have children that's pretty good so
you'll understand this in this analogy
and when my mean my son was very small a
friend of mine told me you never have to
tell your children anything what they
can do what they can't do what I should
do what I shouldn't do you don't have to
tell them anything because they will do
exactly what you do
very good lesson and I always keep that
in mind when I saw my son doing the
things which weren't right it's like
well you know what when I was 18 yeah
he's actually not that bad it is think
about what I don't know is 18 this is
being recorded okay scratch said two
peas in it and so what I'm saying is um
we we do what our parents do now our
Java parents are of course the people
who wrote the jdk but in a way sort of
imagine there are parents right and in
job up to driver six
they were very happily using atomic
reference field of datas for example of
concurrent length queue they use this
atomic reference field of data and we
complain to the method you know this
thing is actually quite slow because
every time I call contains it it says
hmm I wonder if this is if you actually
have a permission to do this and so
they're always checking and checking it
and that's all text time so they were
very same we said can't you change it so
that it's fast so that you can do it
very quickly
and they said no it's impossible
contoured right you can't make this
thing fast because otherwise you'd have
safety violations and blah blah blah you
can't do it so what they did in Java 7
is they started using something called
unsafe all right now unsafe use you say
untested get unsafe to get this on safe
plus and if you show this to Java
program logo means I want to know what
this is all about you know I want to see
how this works
and then so
current linky was rewritten to use
unsafe instead of the atomic reference
field of data and before that people
didn't really pay too much attention on
serving some people using it but most
were just using field updaters or
Atomics directly but now that the
parents were using it it's like well you
know if the father smokes can't the son
smoke you know and so it's sort of
perpetuated and it became a very very
commonly used class I'm not going to ask
for show of hands as to who uses unsafe
that's we're going to I can talk about
that right but here's how it would be
used if it actually worked because get
unsafe is any allowed from system by
system classes and you find the memory
location within your object the offset
inside the object of where the field is
all right and then you say unsafe dot
object okay you find that over here was
object field opposite and of course you
have to make sure that that's correct
because if you get the offset wrong
you're going to update random places in
memory you can peek and poke into anyway
in memory with unsafe and I've done that
and well fortunately it only does that a
core dump but it could be much worse
than that right if you're not absolutely
careful you're going to hurt yourself
and again I've made the volatile the
double array volatile so it's a mess
before and then what you do is you say
unset for campaign swap object which is
the same as complained set before but
now you specify the object that you
updating the field on and the XY offset
and current communists so all of those
get updated and now when you want to use
unsafe or the answers you'd only use on
test all right because if using Java
AIDS
they have magically managed to make feel
that that as fast after all it was
possible all right so this reputation of
unsafe must be faster is not always true
it's like quicksort is not always quick
you despite the name no and it is unsafe
you can do all sorts of bad stuff with
it so we don't want to use it we want to
rather
use Java 9 now M I write to job a
newsletter and if you are on that you
want to say hi here's a link you can go
on to say hello and ask questions and if
you must subscribe you can subscribe it
and now what I want to say is the VAR
handles are a better way of doing unsafe
right because with our heads Java 9
stuff you have you have the ability to
to not peek and poke into random place
as a memory it wraps it for you of it
and there's an interesting article here
by Doug Lee that that describes how you
should use it and sort of the different
types of of accessing of fields most of
us know volatile and non-volatile or
plain plain access but they're also two
other ones these get opaque and setup
egg and there's get a client set release
so if you want to know what they are
have a look at this article it explains
it very nicely and it also the speed is
the same is unsafe so you're going to
have the same performance but it's it is
not unsafe it says and so here for
example I've got now a fourth version of
this the position bar handles
non-blocking and what I do is I have to
find I have to create the VAR handle for
my for my fields I did like this I'll
say mace it handles would look up so
there was a class called var handles but
they threw that out there very good base
at hand so basically what it does is it
sees whether inside your class context
where you are currently calling it from
you've got the permission to actually
find that var handle to find that field
so you specify the the class to look in
and this the reason they've got that is
also support in a class so they're also
duval handles and inner classes comma
the name of the of the field which is X
Y comma the type which is a double array
and it gives you back something called a
VAR handle which you can use to
update the campaign set and in a
volatile read a peg get at Exeter Peck
etc on a field and here's the registers
are basically the move function and this
looks very similar to done safe except I
don't have to pass in the memory offset
so I can't make that mistake anymore and
I don't have to sort of jump through
hoops of trying to get hold of the
unsafe field right sort of for
variations of the same thing now they
have got something new in Java 9 for for
doing a real campaign swap is you up to
now even though it said over here it's a
compare and swap it is actually a
campaign set it returns of boolean it
doesn't return the memory location it
birthday but over here we have a compare
and exchange volatile this what this
does is it it returns the value that was
there so you use it divided to the new
value but you get back that whatever was
they've if it's the value if it wasn't
equal to current and so I've written
this I think it's correct
it seems we correct swap resolved equals
XY I've put it into the swap result to
start with and so that's what feel I'm
going to use for for holding the swap
result and and I check whether the soft
result is equal to was not equal to
current if there's not equal to current
then I'm going to try it again so the
idea is that instead of sort of reading
the value and then sorry instead of
trying to write it and then reading the
value tried to write it and then having
to read it again we if it fails we
already have the value in hand we don't
have to do another weed to get the dart
and I was very excited about this also
this going to be much faster though the
other mechanism and the turns are that
and the high contention the sections are
being slightly slower so very often with
concurrency things are a bit
counterintuitive
as always of performance as well you
know you have these you have the lots of
benchmarks out there and from the past
which might have been true in the past
but which nowadays are not true anymore
and things has changed then one of my
favorite ones was recently I found out
that the fastest way to generate a
string from an INT is not as I thought
interested up to strength but double
quotes plus I write and I always thought
to double cross Messiah was the lazy way
that's like the guys do too too late to
do the proper way they're too lazy but
but because it's such a common way they
actually just optimize that one so it
was actually that they've ended up being
faster then the the diligent in a hard
working way which is much longer so very
often in a piece of change your code
it's not such a big difference right but
it is a slight difference you can
actually measure it it's because of the
optimized string concatenation yeah so
um the distance from origin is extremely
easy with this technique you can simply
say read the current read the XY into a
current and then we can say hypotenuse
on the current array so very very quick
reading is incredibly fast and it's even
easier with other three techniques with
the VAR handle and the unsafe and the
atomic reference field up ladies let me
say current equals XY and then Massa
plotting is current zero for current one
of course you can't say math hot pot XY
0 comma XY 1 so you can't inline the
current because then you might have
invalid state also the very strange
things can happen you can actually have
a situation where the the current naught
is the old value and the current one is
new value all the other one it can never
kind not be the new value but current
one being the old value you don't have
any guarantees in which order that is
going to be written so once you have
concurrency going on multiple threads
writing at the same time
because if all these part-time
instructions you actually don't know
what's going to come out it's and it's
very risky okay now um this is a
conditional change idiom I've put it
into my slides and you can get my slides
from I'm sure devoxx will have a date on
but I'm not going to go into the details
of this what this does just to give you
a views it it allows me to upgrade a
read to write block so the thing that
I've showed in the beginning before we
started with the math tips that actually
developed this one you can actually try
to convert read Rob to write lock but
this particular algorithm is very
complicated to understand and doesn't
actually give you much better than much
better performance in fact it's really
it's easier to simply get a write lock
check that you at the right position and
then unlock the right log so not to
bother upgrade it just keep it at the
right log always in most cases that's
going to be faster so as we just uh
forget to make interests and and if you
wanted to do this with four handles you
could deluxe is also quite quite easy to
do but I don't want to go to the details
because it's really in some cases it's
not worth it to write it with the more
correct or more efficient way because
the you know the easy way ends up
actually being faster isn't
I mean for the fullest awkward amount
ah for which way was it now so I've
gotta find my place again it was here
this one okay so why do you synchronize
for example so the reason okay so I'll
repeat the question the question was why
should I bother using a stamp lock when
activity synchronized or reentrant lock
okay it's a really good question and how
many of you know the method computers
absent and concurrent hash map computers
absent okay so okay so not that many but
10% computers apps and there's a new
method that you put into into hash map
to allow you to to compute objects if
they're not being if the values aren't
in there so for example if you've got a
map with a key comma a list of values
then it's very convenient method you can
just have so for a key and then a
constructor or supplier of an array or
of a list of values so it's very
convenient coding pattern the problem is
that they try to guarantee in the
concurrent hash map that the the
supplier or the function that generates
the actual value is any called once so
if you've got a concurrent hash map
where you you have very often the same
key being accessed or some it's a ready
to be a small set of keys but using
compute of absent you end up with with
very high contention on the map and
actually see blocked blocked state so
it's being blocked
because of synchronized so contention is
something that that can really hurt you
in performance because you'll end up
with with with lots of threads being
blocked you can't utilize all of your
available hardware because the threads
are blocked if your hiya system time
because of the context switches and the
toaster box set and and as a result we
want to want to avoid that want to be
able to read without being stopped by
somebody else's who's busy writing and
similarly when we write we don't want
anybody who's reading optimistically to
be in to to stop him from writing so the
concurrent hash move at the moment
allows you to modify with several
threads not not you know not the
infinite number fades but several number
of threads at the same time you can
modify it because they write to
different parts of the concurrent hash
map and when you read it they do
volatile read so the rant you don't have
the cost of locking when you're reading
so if you do a comparison between a
fully synchronized map and a concurrent
hash map you'll find that the concurrent
hash map in most cases going to be much
faster and and so that's the benefit of
having of separating the reads and the
rights okay if it's a very short read
then it might not you might not notice a
difference but was this you you actually
will notice a difference and if you do
if you have some threads with your
writing and so much reading this reads
going to be incredibly fast ok so it's
another way of doing thread safety which
which will give you a better performance
but what I'm saying is that if you if
you're doing mostly reads even this is
not the fastest so if you're doing
mostly weeds this is going to be faster
the the vol handle or unsafe or the
field update is going to be faster than
that so these are two alternatives any
other questions
can you work off heapify handles and I
don't I don't remember we had a
discussion a bit about that but I
actually don't remember um I'm not sure
I I know it was a topic but I don't know
what the conclusion was of the topic all
right
and we're we we are here so we've done
that so this is only for gaming interest
right now and one of the things with
these algorithms is that sometimes they
can be quite annoying and difficult to
master how many of you have wanted
reentered Locke to be Auto closeable go
phew so so what that means
Auto closeable it means that if you for
example open the file you can open it in
a try block in a tri round bracket and
then it automatically gets closed at the
end of the trial founder of the tribe of
your trike locks so even if you have an
exception it still closes the file and
you might find if you work with the
tiller genu you have a file you're
opening a file input stream it's on that
it gives you warning it's or suggestion
it says don't you want to wrap this in a
trial with finally or try with resource
and so it automatically gets closed and
unfortunately they didn't do that for
Locke they did do it for file lock by
the way so far Locke does get closed at
the end of the in a supplier try block
but they didn't do it for the rent rent
lock and it would have been really nice
because it would have meant that we
could we could we could write our code a
bit easier a bit simpler to write the
code we just say try locked or blocked
off right lock and at the end it
automatic it's unlocked they didn't do
that so and you can do it you can sort
of code around it you can make it own
I've got a newsletter if you look and
website look for look for try with
resource and lock you'll see it but it's
not not standard so another way to do
this of lambdas lambdas are very
convenient for making this it's
pluggable
these wonderful catch with lambdas I'll
get to that in a moment and so here's
the old move I basically did this all
this manual work of getting a write lock
Delta plus y plus Delta Y and then an
unlock code right now this is of course
less convenient than just saying public
synchronized void public synchronized
voice is easier to do than just having
all of this code but wouldn't it be nice
if you look at the code at the bottom
where I would say stem clock stem clock
idioms dot right clock are part of the
stem clock within a lambda that does the
update that basically does the body of
this code and if you do something
similar for reentrant locks as well if
you wanted to and so this is what the
idiom would look like you'd basically
say static method right floss taking a
stamp block and a runnable of the right
job and this would then update the get
the right lock call the run method and
unlock the right so here comes the
problem with lambdas checked exceptions
right and text exceptions are something
which they didn't anticipate would be
such an issue they should have because
internally they've got this thing called
sneaky sneaky throw where they they take
a checked exception they're basically
like a whatever I exception secret
Eclipse River and they actually
converted using using a type array John
generics into run time exception and
then they then I throw that and then I
convert it back to whatever it really is
so the when you throw an exception at
whilst the program is running and
there's no check whether or not the
actual artists rather or not it just
throws it and so so the the checked
exceptions only happening at compile
time where it checks whether or not
you've got the permission to really
throw that done does this just like
i'ma see if it's every minute or how
they what what is maybe you can figure
out why it goes off at what time anyway
so so this is a problem if you want to
throw exception from here you need to
use a callable or something else but
then you have to worry about the
exceptions as well so it that is a
problem generally with with lambdas and
I'm I mentioned to the student to the
architect of lambdas and he admitted to
me that he didn't anticipate it would be
such a problem even though there is a
class could uncheck IO exception ah they
should just give us a class called
unchecked exception that wraps any
exception but there they don't so and
here's the the distance R origin the
sort of the the the the optimistic
reading and I'm I'm doing a read at the
top I'm doing the read again at the
bottom and then I've got a calculation
with that so one could rewrite this with
idioms as follows I could I could make
it a current array and then inside my
read I would read the X&amp;amp;Y into the two
parts two halves of the array
unfortunately you can't just have local
variables X current X and current Y
because the the fields that the
variables the X is from inside a lambda
has to be final or thick to be final so
that's why I'm using an array and doing
that
now you need to be careful if you use
IntelliJ because intelligence sometimes
gives you bad recommendations for
example let's say that you're up listen
if you're accessing a field let sodium
what you're modifying a field from
inside a lambda not a field sorry a
local River from inside a lambda
what what what they'll do is they'll say
to you you know you can't in order to do
that but if you want we can
automatically fix that by changing the
local variable into an array of size one
and then you can change it okay so
that's sort of a water you know Auto
completion feature to make it work
but it's very dangerous because when
that happen you if you don't do it
correctly it for example you've got
you've got a stream and you make it into
parallel stream then it's no longer
thread safe and you won't pick it up
very easily so be very careful of that
autocorrect feature where they want to
go where they want to to change your
local river to an array because it's not
necessarily gonna be thread set in this
case it is because the idiom itself is
protecting it but if you were to read
the current if you have to do this from
multiple threads at the same time
updating this current it will not be
thread safe all right and then last we
used our pots and we did our botany is
on the current Lawton current world and
the optimist agreed yeah so this is what
we're going about this wrong wrong here
okay so here's here's our the committed
would look and the the actual reading
would be just a runnable we need a trend
and i'm doing this possibly twice and
then the actual computation would be a
supply of some type that i'm giving back
and most likely the reading Letran will
be inlined at run time because it's very
short method all right now the
conditional change idiom again this is
academic interest just that you can do
it you know you'd have basically there
two factors two parts here the one is a
supply of type boolean true or false
that we're using inside the while
statement up here and the second is the
actual actual update and so you could
put those into two lambdas one lambda
gives back a billion other lambda is
again a random or that we'd use and so
this is how the actual idiom would look
but i want to spend time on the school
it's really academic interest now this
is i'm not the only one with this idea
of half using lambdas to to make coding
idioms easier to do they also did this
inside atomic reference inside atomic
reference we of course have contained
swap and completes or compensate but we
also now have an accumulate and gate
which takes several parameters and it
basically does the update for us so it's
going to have the looping inside to to
do the update
okay so lambdas will help you to to do
the to to implement the occurrence of
current currency idioms more easily more
correctly and there is an example when
it's used it of course can increase
object creation rate although the SCAF
analysis our friend it can reduce that
some cases and another thing is the
whole thing was with four handles that
that's driver nine stuff and there's
some people are still thinking about
whether they should move to twelve eight
but and some to Java 7 and you know but
it's the future and we need to go there
whether we like it or not because before
you know it it's going to be end of life
for Java 8 and you'll be stuck with
trying to maintain Java 8 code and
trying to patch the source code yourself
so you do want to move it to draw the
line as soon as you can as soon as
possible
and they've now moved most of the Java 9
classes to use var handles instead of
unsafe not all because of bootstrapping
sometimes they need a class to do to
implement var handles and so they
obviously can't use var handles for that
but for the other ones it's for other
ones it works and do have any questions
any more questions read the relevant
equations already is it
and it seems that a lot of those
examples and patterns are like low-level
and obviously you need to know your
access patterns to pick the right one
yes so my question is what are the
chances that one of those patterns will
be ported to let's say Java Runtime and
it will be able to detect what does your
use case and you will be able to adapt
itself is there any chances because
obviously that once we commit to that
code and we decide on a certain use case
the chances that someone will understand
it correctly are many more so a question
is really should we care and or should
we just stick to two good old-fashioned
synchronized okay interesting thing
about synchronized is that it's become
popular again it was like when Java 5
was released it was very unpopular like
Nvidia was going we want to use range
block range with Walker interlock and so
we entered lock became the thing that
really does and the reason why is that
under high contention rented lock was
much better than synchronized so
performance wise that was a good good
thing to do and but then what happened
is that the reason why it was so much
better was because of a bug in
synchronize and they fixed that concerns
the driver 6 they are pretty close
uncontained it synchronizes much better
than than rental block and it's easier
to use so and you should prefer
synchronized if you can't if you've got
the choice you synchronize so if you've
got a system way you you are always
writing synchronize as your friend and
for example concurrent hash map in Java
5 used reentrant lock in Java 8 they
change it to using synchronized so these
are moved back to synchronize and one of
the reasons is that synchronize is more
reliable than reentered lock for example
you have it can happen with rented block
that
you you're trying to get a lock
but the locks not actually given to you
even though it's available can happen
there bugs and reenter block now they
fixed a few offers from drivers heavy to
driver aids but it still is risky using
a rented lock plus you might be the
idiom wrong might put the lock inside
the try not outside the try and stuff
like that so you actually have have
quite a high possibility of getting it
wrong with rented lock and even if you
look and are benign the copyright
aerialists which always used to use
rented lock now also use a synchronized
in reentrant income copyright errorless
so they there is this move back to
synchronize the time that you're going
to think about using this as if in
production you discover that you've got
high contention on a synchronized lock
that's when you start looking and saying
can I do this differently and the first
step is not to take stamp clock the
first step is to say can I do this
thread locally instead of doing sort of
using any locking can I use a functional
approach we are not doing locking that's
the first approach but sometimes you get
to the stage where you can't go that way
where you need to have some shared
resource that is accessed from multiple
threads and in that case a stamp block
can help you aren't your question good
I think time's up if I'm going to be
round today so if you want to come up to
me sailor welcome</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>