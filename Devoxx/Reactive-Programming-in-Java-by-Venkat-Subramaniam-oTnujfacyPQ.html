<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Reactive Programming in Java by Venkat Subramaniam | Coder Coacher - Coaching Coders</title><meta content="Reactive Programming in Java by Venkat Subramaniam - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Reactive Programming in Java by Venkat Subramaniam</b></h2><h5 class="post__date">2017-04-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/oTnujfacyPQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright let's get started good morning
welcome to the session on reactive
programming in Java my name is Venkat
Subramanyam we're going to talk about
reactive programming in general and then
we'll talk about some examples how it
works so let's get started I want to
first talk about reactive programming
itself so the first question I will
start off with is the question why yet
another programming model why can't we
just be happy with what we already do
well one thing I've realized is we work
in a field where about every 10 years
will give a new name for what we already
do and get really get excited about it
so this time around things that get get
us excited are things like reactive
programming micro-services and things
like that well it turns out reactive
programming is really not new it's been
around for a very long time in a way if
you really think about it it's kind of
like it's what extreme programming did
well extreme programming didn't have
anything new and what was really new
about extreme programming was there
really it brought together certain
practices we should really focus on in a
similar way the things that reactive
programming bigs together has been
around for a while but what we have to
programming really does this brings the
emphasis for really why we should focus
on those four specific things it talks
about so it's really a rehashed
programming model that emphasizes on
scalability and response since
positiveness but the question is why
should we really care about it and why
now well I'm almost nostalgic when I say
this but I remember the days when I
would wake up in the morning while the
coffee pod is brewing coffee my modem
will connect and reconnect and I can
hear that whoosh noise in my in the
years and then of course I would call my
friends and ask them what baud rate they
are getting today well those days are
long gone now we are dealing with
devices that are constantly connected to
the Internet always connected every one
of us carries around multiple different
devices with us every single day and as
a result we have applications that
constantly are working with data passing
data around well the second significant
thing that's happened is if you really
look back about 10 or 15 years ago
companies made a software available to
their employees and made their employees
available to the interent public well
those employees were using the system
are called captive users it doesn't
matter what they think about on the
other hand we have applications being
available to real-world users now well
it doesn't matter what the size of your
company is I bet you have more customers
and users than number of employees so as
a result we have a lot greater demand on
applications now then once we did years
ago and then of course we are also
talking about various different devices
constantly communicating well forget
about you know smart phones and watches
we're talking about earrings and nose
rings and tongue rings all internet
enabled very soon what that really means
is we are looking at devices that are
connected to us many constantly
monitoring our health status imagine
your doctors can be notified about your
health status even before you realize
and they can you know come down to help
those days are not very far away so we
are talking about applications that are
constantly exchanging data we're also
talking about high volume high frequency
what we call as big data that that's
where we look today as well in a lot of
different applications so it's a it's a
way to really structure and scale
applications this particular idea came
from Microsoft Research Eric Meyer
created this idea of reactive
programming and it's been around for
quite a number of years before it gained
popularity in the field of Java and in
JavaScript it's been around in the
darknet area for a fairly long time but
but but main idea is the word reactive
in this case simply refers to the
ability of a system to respond to
stimuli and activities as they happen so
when it comes to these applications I
want you to step back and rethink about
this just a little bit if you look back
at the past 20 years what have you been
doing for a good portion of that time
well we can pretty much summarize that
into one acronym which is crud so most
of the applications we've been building
is crud applications we create data
we've read data we update data and
sometimes we delete data but at some
point you wake up one morning and ask
the question is everything a crud
application is it possible that maybe
you've just gone overboard
maybe we're just thinking about
everything else crud maybe not
everything falls into
this category well it turns out that is
actually true that there's a lot of
applications that don't quite read data
process and set the data back like the
way we think about it there is a wealthy
of applications that are interested in
processing data that might be flowing
through as time goes on and we want to
be able to respond to these activities
these are intermediaries imagine you are
interested in processing stock data as
the stock data comes through throughout
the day the stock market is changing
you're not reading the stock data from a
database per se all you're doing is you
are responding to the stock data hey I
want to purchase the stock price at this
particular time but but I want to wait
until this price really comes to that
particular point and when it does I want
to really act on it I don't care about
anything before I don't care about
anything after that price is reached
that could be an example or it could be
a device you're monitoring and when the
device reaches a threshold you want to
respond to it it could be the fact that
you're listening to the weather
information and when the weather changes
certain pattern you want to respond to
it so a lot of these things don't belong
to the correct model we have been
talking about so we need to really
rethink about well this brings us to
four different concerns that are
extremely important and one of them is
we should really think about how we
develop applications for these kinds of
applications and one of them is to think
about message driven applications so we
want to be thinking about building
applications where I'm going to go out
and say that using a distributed
transaction on a centralized database is
so 20th century we should rethink about
how we bar model applications maybe
these disparate parts of the system
should be exchanging messages with each
other rather than trying to use a
centralized database or even distributed
databases
well applications have to really think
about elasticity I got a client I asked
them how many users do you have on a
typical day and they said we got about
200 users on a typical day I kind of
laughed and said really 200 users you
guys are multi-billion dollar company
you got 200 users and they said well you
asked us on a typical day how many
people we have and we have to end 200
people using but two and a half days in
a month about 50 million people use
their
so how do you scale for something like
that where hardly anyone uses your
systems most of the time doing a little
admin stuff here and there and then
about two to two and a half days in a
month
50 million people jump on your system
and I'm going to say that trying to
maintain a local infrastructure and a
staff to maintain it is really
ridiculous in this time and age we
should really rethink about how we build
systems and this is what cloud computing
has really shown us we can be extremely
elastic we can be time-based elastic or
load based elastic when the demand goes
up you're going to make more revenue
because of the demand you can bring in
more systems to support your demand and
then when the demand diminishes you can
have these systems go away well the
cloud computing and elastic services
have shown this to us we can definitely
leverage that that's the other thing
that reactive programming greatly
emphasizes the third thing it emphasizes
is resilience resilience is so extremely
important look at your own smartphones
for a minute for me how many
applications do you have on your smart
phones I bet you have about hundreds of
applications on it how many do you use
on any given day you probably use a
dozen applications what about the other
applications well they're pure crap in
fact you're so angry at them you have
left them there to die they don't
deserve for you to touch them and even
delete it that's how we feel about
applications that are performing not
resilient at all so we should really
rethink about how we build applications
resilience is extremely important
because if applications are not very
graceful in their failures we are not
going to be very happy dealing with them
over time this reminds me of an
experience I was in a conference not too
long ago when a gentleman came to me and
he said he was my student a few decades
ago I've been teaching for about nearly
close to thirty years now at the unity
of Houston and one of this he said I
took your class on distributed computing
back in 1998 I said oh I remember that
time when I was teaching that course he
said I want to tell you a story I said I
love stories tell me a story he said
while I was in your class and
distributed object computing and we had
a final semester demo and I was doing
the demo and right in the middle of the
demo you walked up quietly to my
computer disconnected the internet cable
and then said continue and the project
failed and I failed the course I said
I'm really sorry to hear that you failed
my core
is why would you want to share such a
story with me he said well because
there's a good news after this he went
on to say because that's the last day I
ever did that mistake and you went on to
say you see now when I program
I don't just program the happy path I
start with the things that could go
wrong and I build resilience into the
application and then he said well these
days when I code I don't take this so
lightly in my office he said in front of
me on the cubicle I have a picture of
Evel blanket in front of me and then I
look at this picture every day when I
code and I don't make this mistake I
don't think we want to have pictures of
Evel venket in our desk or on the office
but the point is we got a program for
resilience that's extremely important as
well well then of course we want to also
think about responsiveness well we can
think of applications that are working
but we are living in an age where of of
instant gratification we're not going to
just sit around and wait for
applications to respond we want results
now when we want it fast
well a good example of this would be to
think about you know infinite scroll for
example well you scroll through this
application one morning which usually is
slow it responded very quickly and
you're like wow that was pretty
instantaneous and then you realize at
the very end of this particular page you
scroll up and there is nothing and
before you could realize that if there's
nothing it fills up the next part of the
data and that's an example of how
applications can take the time to work
while you are processing part of the
response so it can be very responsive
responsiveness is extremely important
imagine you walk into a store and the
store is pretty busy and you see the
clerk who is busy with some customer
what do you normally do you probably
look around for a few minutes look at
the ceiling look at the floor and you
walk away because there was no response
but on the other hand you make an you
walk into the store the clerk makes eye
contact with you says I'll be with you
shortly and goes back to help the
customer who's already there
you probably waited for a good 15 20
minutes why did you do that because you
felt you are important even though you
know you're not the point really is that
that is the whole idea behind this is
when there is responsiveness we have a
loyalty of than the users and absolutely
the applications that are not responses
are the ones that lose users very
quickly so these are the four
fundamental things that are essential in
building applications we're going to use
message driven to communicate we're
going to be using elastic services we go
to program for resilience and be
graceful about failure and of course
provide for responsive applications as
well so what is reactive programming
well it is a programming model where we
build applications using these these
things to make the application really
resilient responsive but how do we go
about doing this what can't we just
build applications using multi-threading
well sure we can use multiple threads
but imagine what happens when you create
threads that's the easy part then we got
to worry about race conditions about how
the threads communicate and so on that's
very very painful in general well and
also if you really think about it when
you create threads there is no really
good way to communicate between thread
well we could use futures for doing this
well if you think about futures though
what our futures do the futures
basically are going to return there to
you when the application computation is
over but you could go about and call a
future and the minute the future is in
your hands what do you typically do you
turn around and call get and wait for
the response to be given to you
that's no future at all that's wasting
resources while you're waiting for the
service and also it's really hard to
work with it oh wait a minute can't we
all be happy and use callbacks if you
think callbacks are a good idea I've got
a suggestion for you just walk quietly
next to a JavaScript programmer and
utter the word call back and watch them
begin to cry uncontrollably because we
have learned the call that don't work
really well at all in fact the
JavaScript world has moved on to use
promises and other things and even
reactive solutions for that matter so
what is it really that we are trying to
tackle what what are we getting to
really well the first thing I want to
emphasize is maybe it's time to think
beyond crud I'm not suggesting that we
wouldn't program in card anymore but not
everything we do probably has to be
correct the second thing I would ask is
what if we start thinking about data
flow computing what if we start thinking
about applications where we have a
source of data that made emit data and
we are intermediaries that would receive
the data and as
you see the data we would perform our
computations and in turn emit the data
moving forward to the next one in the
series and we can have a series of
things that can respond to these
applications maybe data flow computing
is a resurging once again this again is
a concept that's been around for a very
long time but it's receiving special
attention right now but to understand
this let's take a slightly different
example and and play with it so what I'm
going to do is to take a small problem
I'm going to look at a way to solve this
problem and then see how we can go about
you know rethinking about this problem
so for this I need a volunteer who has a
smartphone and who is interested in
helping who wants to help me don't be
shy
who wants to good sir what's your name
Leo you can be right there but you I
want you to give me information about
three things I don't need your
smartphone I just need you with your
smartphone so so here's the question for
you can you tell me the start price for
these three things Google Amazon Intel
and Microsoft I want to stock prices for
these four things all right Leo we're
waiting for you do you have the answer
for us leo uh almost he says he's not
fast anybody thinks he's not fast enough
for us all you have is just one price so
far yo this is disappointing
no he's too slow oh here guys look if
somebody's helped as well
well thank you leo Thank You leo you
were wonderful
so you likely demonstrated how the
worldwide weight works so what did he
demonstrate there are several things
Leah did not notice but you saw me and
Leo together there are several things
that happened here thanks for help well
first thing Leo did was we sent a
request to him what did you do
immediately start on the job and he's
just nose-down at several point I said
this I don't care I don't want you to
work on this anymore
he did not notice this at all just like
a web services a web service kind of
goes nose down working on things and
what happens when the rest service
eventually donek says and the result
there is like what did the user go these
are gone for a long time ago right
the second thing is you go to a site you
make a request the fight is taking too
long to respond what do you do you
wanted to help so what do you do you do
a push button that sends two threads now
working that's exactly what I did to Leo
as well
I kept nagging him more and now in
addition to looking at the answer he
also had to keep responding to me this
is not going to help us at all but
that's the way we've been doing things
for a very long time so you nicely
demonstrated in fact he kind of branched
off to something else along the way
which is pretty smart but this actually
happened in one of the sessions a few
months ago I was doing the same talk and
somebody like Leah wanted here but right
off the bat he hit something instantly
what you did towards the end so when I
gave him the four stop he says that
gentleman said I'm not going to go look
up these prices immediately he recruited
four people around him he said you find
the price for Microsoft you find the
price of Oriental you find the pressure
Google and by doing so he demonstrated
not only can a system suck you can waste
a cluster of machines as well well the
point really is that it doesn't really
have to be this way we got to really
rethink about the way we do things so
how do we go about rethinking this and I
want to say efficiency is attained not
by doing tasks faster but by avoiding
those tasks that shouldn't be done in
the first place
so the goal really is to not run faster
and faster and faster but to rethink
about how we actually do our work do our
tasks maybe there are tasks that we
shouldn't do does the user really care
about this can I postpone running this
maybe until a later time and can I maybe
do this minimally well I'm going to show
you some examples but before that I want
to kind of connect this as I was
learning about reactive programming
there's a void in front of me and I
don't understand where does the skull
fit together and one of my realizations
was this is a really nice segue from
functional programming because to me
functional programming really is not
about immutability functional
programming is not about higher-order
functions while those things are the
components ingredients are part of them
to programming for me the real essence
of functional programming really is
function composition and lays
evaluations so
if we can attain function composition
and lazy evaluation well then we can
more effectively use the ideas of
functional programming while social
programming kind of takes us all the way
to the dorrance is here you go we got
laziness for you we got function
composition and reactive programming
takes you right from there and says well
now that you can use function
composition and you can be lazy in your
evaluation let's leverage those ideas to
move forward that's where these ideas
come from so where this is taking us is
our yes observable so what is observable
well it is the observable pattern but
with certain differences in it the first
is you're going to be pulling the data
in the iterators whereas an observable
the data gets pushed towards you it
could be synchronous or asynchronous
well a lot of times pushing synchrony
are asynchronous too early in the game
makes the application extremely complex
and hard to work with well the beauty in
this area is it can postpone you can't
postpone those until a later time so the
observer really has a couple of
different interesting things to make
this happen for us well the very first
thing about observable is that it's got
a data set channel and a bear channel is
through which the data keeps strength by
emitting or transmitting towards you but
what what do we do when things go wrong
well then things go wrong you want to
handle the errors but the worst thing
about errors is we call them exception
maybe you should have called them normal
because they can happen at any time
so rather than throwing exceptions at
you observables have a separate channel
for the errors themselves sick wait
there is a data channel and there's a
error channel well the data channel has
the data the error channel has the error
and of course anytime there's an error
to the error channel there will be no
more data coming through their channel
and and that's a way for you to know
that there's an error and of course when
you respond to the error you're not
going to be pushed more data towards you
kind of like the circuit breaker model
and of course I mentioned there could be
synchronous or asynchronous let's take a
look at how these things can evolve with
a quick little example here so what I
want to do here is I've got symbols as a
collection here so I'm
to say stock server I'll go and say get
feed over here and I'll pass the symbols
given to us to the get feed method
well the get feed is going to of course
give us the data as it's going to happen
but we got to implement it somehow well
it turns out there are several
implementations available for doing
reactive programming on Java there's not
one solution you could use any of those
different solutions I'm going to just
use one of them which is rx Java which
is implemented by Netflix apparently
they had some screaming problems to deal
with so they decided to open-source
their solution but the ideas are pretty
much the same the aps are slightly
different here and there but you could
go away and use this in some other
library if you wanted to but the ideas
observables really is pretty dominant in
this and I'm going to say observable of
stock info is what I really want to use
here so I start with an observable and
that observable as you can see is coming
from the i/o dot reactive X start
observable so how do I go about creating
an observable how do I use it we'll come
back to that part in just a few minutes
so we'll move on to this side over here
well now that I have an observable on my
hand I'm going to say that's the feed
and then of course I'll go ahead and say
got observable and I have an observable
at my hand but I want to go ahead and do
something with the observable have not
done that yet we'll come back to that in
just a minute going back over here I'm
going to say observable dark create and
this uses the idea that we don't want is
a constructor but we will use a factory
method to create an object so we are
seeing observable are create to create
the object so in this case I'm going to
get a subscriber to be given to me and
I'm going to go ahead and emit into the
subscriber some data as it as it so
happens so we need an emit method for us
to be able to use this now so the
observable is created the observable
gives you a reference and observable is
nothing but our data stream oh wait a
minute let's quickly talk about what is
the difference between observable and
stream as we know streams in Java 8 well
there are a couple of very key clear
differences in them well they both
streams in Java 8 and
observable our data emitters so they
both are going to emit data towards you
but the stream API in Java aid do not
deal with exceptions at all on the God
on the other hand observables have a
clearly separate data channel and error
channel for one so they have a better
handle on the exceptions or errors for
you and the second thing of course is
that the they both are lazy of course so
they could be sending data at any time
they will be pushing data towards you
but the way they handle data is one of
those differences if you will in how
they handle would with things so in this
case I'm going to create a emit method
and then the emmett method I'm going to
go ahead and say this is going to be
receiving a subscriber and it's going to
emit the data so I'm going to say start
emitting over here so we can actually
see that particular method call as well
but right off the bat let's go ahead and
run this and see what it's going to do
and you can see that it said god
observable but it didn't do anything
more just to emphasize the fact that it
is absolutely lazy so it's not going to
do any work until you really demand a
connection to it and say I am really
ready to process your data it doesn't
really start emitting any data is that
lazy well now that we are receiving here
why don't we go ahead and do something
with the data so I'm going to go to the
feed and say subscribe and now I can say
outpoured so in this case I'll simply
say system dot out print line and I'll
just print the data in this case so that
we can see the data being transmitted
towards as well of course in this case
I'm not still emitting any data so when
I go ahead and run this code though you
can see it said God observable it said
start emitting data but the start
emitting data really happened because we
truly subscribed to the data
well now what I'm going to do here is to
go back to this emitter and I'm going to
say at this point why don't we say
awhile true in this case and then I'm
going to say well we got the subscriber
on our hand but I also like to have the
symbol given to me as well because that
would be after all pretty useful to have
so in this case I'm going to pass the
symbol to this as let's say the second
parameter so now I can say
in here well now they have the symbols
at my hand I'll say symbols doc and then
I will go ahead and say stream I'll use
the Java eight stream this is purely an
implementation detail at this point then
I'm going to say math and I'll say stock
info and I'll call a fetch method well
the fetch method of stock info is going
to go out and get the stock price parse
the data and give it back to as a stock
info and then once I have the data I'm
going to say for each and in this case
if you give me a stock info I'm going to
say subscriber dot on next and send the
stock info to that particular oops wrong
one and in that case I'll say stock info
and then I'm going to say stock a stock
info and I will just go ahead and send
the stock info to this object at this
particular point well in this case of
course the map is going to return a
stock info we could receive the stock
info and pass it on to the subscriber at
this point or we could just simply use
the Java eight syntax and say well we
could simply use a double colon on this
but the whole point is here in respect
to the syntax you can think of this as a
mouth of the data channel where you
start emitting the data through the data
channel of the observable and of course
now that you're emitting the data from
here the data should be arriving on this
other side args Java itself does things
within one particular JVM but if you
really want to go across the jaebeum's
there are other solutions again one
example of this is vertex vertex
actually uses rx Java API but wraps and
gives you the ability to go across
machines as well so you could use one of
these different solutions to deal with
so as you can see this is getting the
data and Google is pretty close to what
Leo pointed us to us so thanks Leo gain
but you can see that the data is
arriving at this point but this is just
transmitting the data for us and we are
receiving the data so but what is the
where does this lead us to well there's
the synchronous solution we are
transmitting data but where we really
want to go from here is an ability to
interact with the systems and
communicate across these different
endpoints so in here imagine you have an
observable sending data to words you
but there are times when we should be
very mindful of resources the observable
the source is using resources to talk to
you and you are using resources to
receive the data as well and if what if
there is no more data coming towards you
it would be nice to be told that there
is no more data coming towards you well
this is where I said there are two
channels well I kind of lied to you
there are three channels there's a data
channel to which there will be data
coming through does the error channel
through which an error may come through
and there's a complete channel through
which a signal for complete comes
through well the way the observables
work typically is there might be a zero
or more data coming through the data
channel so imagine there's there data
coming through the data channel and at
any time it's going to tell you there is
no more data well it's going to send a
complete signal and the minute it sends
a complete signal the data channel
closes up and there will be no more data
coming through the data channel well
just to illustrate this point let me go
back here to this code and say in this
case let's say count is less than let's
say three and I'll go ahead and start a
count is equal to zero and in this case
let's go ahead and increment this count
for our purpose and then in the very end
I'm going to say go ahead and say
subscriber on next and then send a new
stock info let's go ahead and say info
of dummy and then a zero point zero as a
price just to you know illustrate the
point about the way these channels
actually work so when I run this code
you can see the data is being emitted at
this point and the data is going to be
pulled from the service it looks like
maybe when a connection is a bit slow
here so it's not respond oh there you go
so it starts moving okay it's terribly
slow alright so now we can see
eventually it's a dummy zero point zero
but on the other hand I'm going to go
back here and at the very end of this
I'm going to go ahead and say subscriber
dot on complete and I'm going to send a
complete signal well on the receiving
end I'm going to go ahead and add one
more thing for now I'll just say system
dot out print line will it worry about
what this is in a few minutes but I'm
going to say I'm receiving no data but
I'm going to simply output done over
here as the very very last one well if
you look at these things these
three lines are really the three
different things that we are talking
about the first line is your data
channel the second line is your error
Channel and the third line is your
complete channel so there's a way for
you to receive data one of these three
channels for you so you can either be
receiving data to the data channel edit
through the error channel are the
complete signal to the complete channel
but in the sense though notice that I
put a dummy out in the very end after
complete but remember that once they're
complete signal comes the data channel
close up so that's why in this output
you note as it says done but it never
received the dummy out as the output
that's because the minute complete
signal was sent that data channel closes
up and this becomes purely and no up
it's never going to leave the observable
and go to the client and of course the
observer or the client or the subscriber
can do a clean-up operation right there
this gives you an idea how you can send
a signal from the subscriber to the
observable to the observer and say that
I'm done but what about the other way
around there are times when you want to
unsubscribe as well so for example if I
go ahead and say give me all the stock
symbols and the prices and the observe
will start transmitting the data to me
but at some point I realize the price of
the stock is my favorable price I want
to perform a trade I no longer want to
get the data from the server well I
could send an unsubscribe and say thanks
but no thanks don't send me any more
data so this gives an opportunity for
you to unsubscribe from the source and
say don't bother sending this to me
anymore so in this case what you can do
is you can throw in an unsubscribe as
well well we can do a little bit more
work for that so what we could do in
this case is we could go ahead and build
up a new and we could say observe we'll
call this as my observable so I could
create my own observable right here
observer rather so I can create my own
observer and in this of course I have my
observer and this observer can of course
implement a certain methods that are
required for starting to observe
so we could implement a bunch of methods
on this on this observer
well this observer of course is going to
support the interface that this
subscribers expecting which is the
observer so we could go ahead and create
a little class here so we could say for
example new observable well observer
rather and then we could say I want to
implement the methods that this guy is
going to expect so let's redo this right
here so we can say feed art subscribe
and you will call it as observer and
then this is going to be the stock info
of the observer that we would like to go
ahead and implement it well in this case
of course we're going to implement these
these methods so what are the methods
I'm going to implement for for this
purpose well I'm going to implement the
method which is the on next we saw that
earlier so this is going to be simply
the stock info that I want to respond
with so this is going to be a part of me
I made a mistake here this should be
info rather so that's a stock info
that's the observer going to get back to
us so we can simply say I'm going to
receive the stock info and this case of
course I'm going to say print out the
stock info so I'll just print the stock
info given to me I can also print the
complete signal right here ignore the
error for now and then of course I can
say done right now but I can also do one
more thing for example let's say on the
next I could say if the stock info dot
value is let's say less than oh let's
say about $40 we could immediately say
output a you know unsubscribing so we
could say unsubscribing and we could
then send a request to unsubscribe well
how in the world can we do this well we
could say in this case we are receiving
a disposable so I will go ahead and
store that away here as disposable and
we will store that into a variable so
disposable equals the given disposable
and then we can nicely go back here and
say the disposable dart and then we
could dispose off and say don't bother
sending me any more data so we can see
the transmission of the data starts up
depending on how the internet is going
to send the data well as the data
arrives the middle bit
less than a 40 we can unsubscribe right
away and we're not going to get any more
data moving forward that is an example
of how we can go ahead and unsubscribe
from the calls at any given time so the
observers can say don't bother sending
any more data to me and that way they
can be very mindful of resources the
server is going to use as well well that
gives us an idea about how we can
process it but the big elephant in the
room of course is how do you handle the
errors
well errors are something extremely
important to deal with properly so in
other words what happens when things do
go wrong well when things go wrong
imagine you're on a multi-threaded
application and in a multi-threaded
application when things do go wrong you
want to be able to know a what went
wrong and you want to be able to handle
that well when you have thousand threads
and if several threads begin to fail
there's no real good way to communicate
all the information a multi-threaded
situation it becomes really hard to work
with it what we're going to do here
instead is exception handling is
something we have really struggled with
throughout ignore the history of
computing well what did we do a long
time ago we said we're going to return a
result if the result is positive it's a
good data if the result is negative it's
an error then we realize gosh that
doesn't make sense because the data
could be negative - and then we try
something else this was the days of the
80s we returned an error all the time if
it is zero it's good if it's not zero
it's an error yeah that's awesome
but wait a minute worse the data oh you
will send an extra parameter to the
function the function will fill the
parameter with the data and return to
you that made things very clumsy for us
to use and one of the errors you had to
deal with was that the function forgot
to fill the data in the first place our
Houston forgot to send the proper holder
for it okay that didn't go really well
then what did we do we said we're going
to do exception handling exception
handling was wonderful wasn't it because
a function could throw exception and you
could simply ignore it with an empty
cache block that was frustrating I can
tell you a week doesn't go by when I
plead with the programmer
please no empty hat blocks back didn't
go very well at all and there's another
thing when something goes wrong what
happens it throws an exception at you
how civil is that how would you feel
when people throw things at you
well the after programming is extremely
civil it doesn't throw anything at you
it hands you the error and says here you
go and shakes your hand and says we'll
be civil about this that's one of the
really nice things about it it takes the
exceptions but it gives you the
exceptions through the error channel
very nicely let's see how that works
actually in this example so I'm going to
go ahead and say system dot out and
let's say print one well we know that
this is going to be the data channel
coming through but I'm going to say
given an error I'll go ahead an output
error right here in uppercase and then I
will say plus over here and then I will
just print the error and then finally
here comes the data we'll say output
done to say that we're going to receive
the output as the complete signal well
when I run this code in this case of
course you can see that things are going
well and you are getting the data and
eventually you're done but on the other
hand let's say in this case I'm going to
go ahead and increase this to let's say
300 for a minute but I'm going to go to
my stock info and in the stock info at a
random time I'm going to blow up with
the old oops ran into trouble but notice
this is going to throw an exception but
this guy is not dealing with exceptions
however the reactive system say is oh
wait a minute you are transmitting
emitting data and while you're the
source of the data emission something
went wrong and things blew up we're not
going to just simply you know throw
we're going to capture that exception
and send it as a as an error in other
words errors are first-class citizens as
well you're not treating errors at
something secondary you are treating
them with as much respect they deserve
as the data deserves and that is one of
the nice things about it so when I run
this program this time though notice it
starts emitting the data but notice when
things did go wrong when it blew up
randomly that exception was
grabbed and notice the word ever in
front of the message that error came
right from there whereas the exception I
threw really had boobs ran into trouble
and that shows how that exception over
there was grabbed
but politely given to you through the
error channel in a way that you can
actually handle furthermore when the
error does come out the data channel
closes up there will be no more data
coming to the data channel and you can
handle and deal with the error properly
on your side so that shows how we can
handle errors as well
very nicely well I want to just touch on
just a few remaining things in the time
we have that we need to really think
about as other considerations I showed
you a fairly simple example here of an
observable and an observer where the
observable image data and the observer
is is is using the data being
transmitted but there are typically a
lot of different things we would
normally want to do let's go ahead and
remove this error for now and then we'll
continue further now in this case of
course if I run the program that's going
to start transferring data for quite a
while as you can see in here but there
are things you can actually do quite
effectively along the way for example
notice the prices are ranging from $800
on one side to you know all the way down
to $35 and so on but let's say that I'm
actually interested in only certain
values that I'm interested in observing
well what I can do in that case is I can
nicely use this approach to build up on
these things very nicely so for example
if you go back to this code I'm going to
remove these messages for just a minute
so we can just see the data coming
through you can see that in this case
once I turn it on we're going to have
the data coming through and it displays
all these data I'll stop this for now
but what I can do is I can say well I
don't want to see all the data you know
imagine for a minute that you are
dealing with a situation where you are
looking at the device the device is
transmitting data and you are not
interested in all the data well let's
say for a minute
I'm I'm an observable and I'm emitting
data constantly and let's say Leo here
is an observer he is interested
receiving some data I'm sending but a
little bit later he says you know what
hate this is great but I don't want
everything that you are emitting I only
want certain things that you are sending
and not other things well unfortunately
I don't want to deal with Leo's requests
well not that I don't care about him but
we'll use a technical term for it
it's called cohesion and single
responsibility principle right well I'm
going to do what I'm going to do I don't
want to start customizing what I do for
just one of my observers but because
somebody else may really care about
everything I send so what do we do
what's going to have an intermediary
right now this intermediary says dory
about it I'm going to sit between Leo
and and this observable venket and it
says I'm going to start filtering out
things that Leo doesn't care about
there's a very powerful model as you can
see notice we have the feed up there but
the feed actually is right this one
returned by the get feed method but
right here I'm going to say dot filter
and I'll say stock info over here and
then I'll say in this case stock info
dot value that I'm going to get from Ed
is let's say greater than 40 so we can
immediately say well when the observable
is going to start emitting data towards
me
I can take the data the observable is
emitting and I can start filtering the
data that gets emitted right here let's
see why there was no too happy about it
so I can start filtering and I can say
stock info and then I can say stock info
dot value is greater than let's say $50
and then you can say I'm going to start
emitting data but only if the data is
I'm going to send data only the data is
greater than add value not otherwise now
the beauty is you can take this seed but
you can put multiple intermediaries that
are observables to what's upstream but
they themselves become observables to
what is downstream so on one hand they
are observing on the other hand they can
become observables downstream as well
and they can start filtering things as
you can see no price now is less than
$550
point likewise you can do other things
as well you may say okay bank add back
would be really nice if you can give us
a little discount on the price so we can
say stock info now we can say stock info
we could provide the stock info tower
ticker but we could take the price given
to us the value rather and then we could
say 0.9 and you start getting a 10%
discount on the price so you can see the
prices no longer or $800 much less than
that so we can have these kinds of
intermediaries working really well but
not only can we do this we can also get
to a situation where we can nicely say
that I want to receive data but I don't
want to be bothered by a lot of data so
you could say something along the lines
of you could say a dark take and I'm
gonna say let's say five so this says I
only like to take five pieces of data
and don't bother with me any more data
once it doesn't spin filter and take
well filter is kind of like a little
slap it will block a data and say can go
through or would let some data go
through so per data it might block or
release think of a cake as like valve so
it is open to begin with the data keeps
going but when the condition is reached
the wild closes up and no more data will
go through in fact it's a little bit
more than that the take isn't observable
that will start transmitting data in
other words it will talk so whatever
data is Bank Ryan being transmitted will
go past it but when the condition is met
it is going to send an unsubscribe
upstream and it'll send a complete
downstream so notice in this case when I
run this once the value five is reached
the the cake is going to take the
responsibility of transmitting a
complete signal notice that done came
actually from the take sending a
complete signal and that is already
baked and well the take of course is
going to give us only an ability to take
on five data but it could be pretty
logical as well you could do a take
while and you can say that
while this condition is true keep
sending data when that condition is not
true anymore stop so in this case you
can say keep sending me data until a
certain stock prices this value but the
minute it reaches a threshold quit
sending me data I don't want to hear
this anymore you can be very logical
about it likewise you could take do it
not only a take while you could also do
a skip and a skip while as well and then
you can be the opposite of what it take
is doing so but then of course this
works great but when you have multiple
observers how things actually work well
this is where a difference between water
called hot observables and cold
observables come in a cold observable is
the default a cold observable will
maintain multiple sessions concurrently
so in other words with Leo subscribes to
my my observable I'm going to be
transmitting to Leo at the same time
when Sarah subscribes that's a
completely separate session so in other
words it's like me messaging I'll be on
a message session with my wife a friend
of mine may join in I'm gonna have two
distinctive sessions I'll say stuff to
my wife and I'll say different stuff to
my friend they both are in completely do
two different messaging sessions I am a
cold observable on the other hand it is
possible that my wife is chatting with
me when one of my son's come along and I
might decide the topics of common
interest I may put them together on a
message now I become what's called hot
observable because both my children and
my wife can participate in the same
conversation with me I maintain one
session not multiple sessions so we can
have these kinds of distinctions between
if all the observer observers are
viewing the same thing from the
observable or are they having
distinctive sessions we can manage that
also very effectively as the case may be
but not only that we say okay this is
all great but what if the observer is
transmitting data at a certain phase and
the subscriber the observer is not able
to keep up with it what are we going to
do well this is where what is
called back pressure comes in so a back
pressure is where you can configure how
the system is going to respond when the
rate of transmission changes suddenly so
there are a couple of different options
one one back pressure is back pressure
drop meaning I don't care I'll be
processing at my pace if the day is too
fast just get rid of the data when I'm
ready I'll get the next data there are
some situations where that is the right
thing to do there are other times when
you want to buffer the data so there's
an on back pressure buffer which will
put the data into a buffer and you can
be pulling the data out and processing
it at your pace while the data keeps
streaming in and gets buffered again of
course that only makes sense if there
are peak periods and non peak periods
where you can recover and start
processing data so these trying to
produce you can also do what's called
throttling where you can start rattling
and saying I don't want to be getting
this data at this pace I want to Eddy
the pace at which I get the data there
could be a lot of noise from this and
then when their data settles down I want
to receive it one example of throttling
is where you are let's say observing
somebody typing on the keyboard
my wife says I'm extremely good and
typing back spaces well that's kind of
annoying right because we type in and we
delete type and delete type in delete
and you could say why don't I let the
user type and stabilize what they really
type then I would take what they type
and process that that's when you could
be using things like throttling where
you give them opportunity for the noise
to settle down and then you can process
the data all of those approaches come in
really really handy so to summarize what
we talked about the idea behind reactive
programming is to be able to really
create a system with elastic message
driven very responsive and also very
resilient and there are so many
different solutions hopefully this gives
you an idea about what we active
programming is all about if you're
interested in not going to record
examples I showed you here they are
located at that URL on my downloads page
I hope you found that useful</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>