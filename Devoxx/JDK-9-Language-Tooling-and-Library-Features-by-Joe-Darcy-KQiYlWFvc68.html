<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JDK 9 Language, Tooling, and Library Features by Joe Darcy | Coder Coacher - Coaching Coders</title><meta content="JDK 9 Language, Tooling, and Library Features by Joe Darcy - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>JDK 9 Language, Tooling, and Library Features by Joe Darcy</b></h2><h5 class="post__date">2017-04-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/KQiYlWFvc68" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello thank you for coming here this
morning my name is Joe Darcy I work in
Oracle's Java platform group and I'll be
speaking today about JDK 9 language
tooling and library features there's a
lot of material in the talk today if we
don't have time for questions at the end
you can tweet your questions to the
hashtag here shown on the first slide
I'll also be tweeting a link to PDF of
the slides after the talk this is a very
important slide from Oracle's legal team
they want you to know to not trust very
much what I have to say here today they
call this the safe harbor statement
however is one developer to another if
you're interested in safe harbors there
are many other safe harbors in the area
we could talk about so I'm happy to
share some tips on those after the talk
quick survey of the audience of which
JDK trains you're using in production
JDK 9 early access with jigsaw cutting
in jigsaw any hands there well about the
other JDK 9 early access build some
people downloaded them that's good
perhaps a few more you will download
this after the talk dedicate so most of
the audience using JDK 8 it's very good
from if you is back people still on 7
maybe 1/4 the audience for 7 still
stalled release 6 a few more hands there
and admit it it's ok we're all friends
here
KD K 5 or earlier I a few few very
people do admit well there are many new
features are since then perhaps so
you'll be able to get motivated to
upgrade by the end of the talk quick
overview of what's in JDK 9 JD canines
been in development for a number of
years and the ship date the early for
the general availability is coming up in
a few months in July as I mentioned
there are early access binaries for two
lines of development both the main line
one and one with jigsaw features that's
a little more cutting edge JDK nines
being developed under the auspices of
open JDK so there's a project for that
their various mailing lists you
the source code if you're interested
there's also various adoption groups one
of the initiatives we expanded for JDK 9
was to reach out to various open source
projects to have the muse of JDK 9 early
access builds along the way so we can
get more feedback about what's working
well and what's working less well
throughout the rest of the talk I'll be
using the term Jeff these are JDK
enhancement proposals and they're a
process we use to manage feature work
now in the JDK and Duke needs you yes
you to download these early access
builds try them out in your CI systems
and let us know what's working what's
not we are fairly far along in the cycle
for JDK 9 we're one of the ramp down
phases but there's still time to send us
some feedback and let us know how it's
going the capsule summary of JDK 9 the
largest feature in JDK 9 is modularity
this has been in progress for a number
of years under project jigsaw and
modules bundled together multiple
packages and offer a stronger
encapsulation than jar files earlier
this week there have already been a
number of DevOps sessions about
modularity which you may have already
seen this is a very large change it's a
language change to the in a larger
change of the platform there's a new
kind of Java file a module info file
that allows the dependencies between
modules to be declared Java C compiles
those files then at runtime the Java
commands also been updated to enforce
the same kind of dependency restrictions
declared in module info files there's
various other supporting changes as well
such as in Co reflection and the
language model API as a large language
change it did affect many parts of the
platform project lambda and JDK 8 was
also a large language change however the
modularity changes in JDK 9 are somewhat
bigger in the sense that they addressed
the programming model more fundamentally
with modules you're able to program in
the large at a different granularity so
you have different questions to consider
when you're designing your application
library in terms of what the module
boundaries are not just what set of
types you might have there are their JDK
9 related talks at devoxx there are some
early week my colleague
l gave a talk yesterday about the sharp
edges of JDK 9 I like to think of this
talk today is covering not only the
sharp edges but also some of the rounded
corners personally I prefer the classic
og profile as shown here there are a
number of other data k9 related talks
later today as well I'll just highlight
two of them now
Trisha key later this morning is going
to be talking about tooling support in
IntelliJ for JDK 9 and this afternoon
Minaj plot is also going to be talking
about the Eclipse support for JDK 9 with
modern development of course it's not
just about the support from language
feature that ships in the JDK we also
want to have good support in tools such
as iges outline for the rest of the talk
I'll give a brief discussion of the
stewardship philosophy we use in the
Java platform group toward evolving Java
just give some sense of the size of JDK
9 JD 9 is a very large release in the
terms of number of bug fixes this is a
graph comparing the JDK 9 bug fixes per
build to JDK 8 and we've had a higher
fix rate 9 and the release has gone on
for longer we're starting to level off
now this is a from a week or two ago so
there are a lot of good good changes in
JDK 9 those changes span a number of
areas there's tooling improvements
language changes and library updates
sometimes the features are well
delineating into these buckets sometimes
they cross over so this is just a rough
outline of the rest of talk and if we
have some time at the end I'll take
questions and answers stewardship the
approach we use to stewardship for Java
is not the same approach that we do say
by Denethor in the Lord of the Rings
films we have a more benign in the
supporter view of stewardship for Java
under the last seven years under Oracle
there's been a consistent top priority
for the Java platform group which is to
keep Java vibrant part of keeping Java
vibrant is keeping things that work
today working tomorrow and that brings
us to a discussion of compatibility and
the general evolution policy we use for
Java and that general evolution Paul
the for compatibility is we don't want
to break binary compatibility as
defining the Java language specification
and what that means is we want to keep
programs that link today linking
tomorrow we want to avoid introducing
source incompatibilities and we want to
manage behavioral compatibilities so
this extends to language evolution as
well it means that we want to continue
to recognize old class files even all
the way back to those 1440 5.3 class
files from jdk 102 we want to limit the
cases where currently legal code stops
compiling and we want to avoid a change
in code generation that introduced
behavioral change surprisingly and we
don't just want to keep everything the
same because then there'd be no progress
so there is a balancing act between
stability in progress with the
recognition that there is a lot of value
in good compatibility and keeping things
working so we've talked about there's
three dimensions of compatibility so
we're spying and behavioral so we could
view those as defining a little vector
space like you might might recall from a
physics class and we have different
policies about compatibility for the
different kinds of releases we have so
for instance if we have the quarterly
security updates those have a very small
region where they can make incompatible
changes so you recognize by this box
here we want to have some behavioral
change after all if there's some bad
code that we want to stop working we
want that to stop working so that would
be incompatible for an X point for
example and maybe there's a little bit
of source coding ability we allow for a
larger update release say 8u 20 or au 40
there's more fixes going in more
features so we'd have a larger region we
allow there but in both cases we stay in
the source behavior plain meaning
there's no binary compatibility change
that we allow because we want people to
be able to easily update to the update
releases without having to worry about
their program stopping to link the
situation's a little different for
platform releases like JDK 8 GA and now
especially JDK 9 we have a larger
ability region to play with more
behavioral change more source code
change and with enough justification
even some binary and compatible changes
and we'll see one or two examples of
that later in the talk so a good example
to help illustrate the different kinds
of behavioral change policy we can look
at the specification of hash set that
iterator it says here you get back an
iterator and the elements are returned
in no particular order that means if
your program relies on the order your
program is kind of bugging it also means
that we are allowed by the specification
to change the order but that doesn't
mean we always change it so what is the
compatibility impact if we did change
the hash that iteration order well first
its binary compatible the set of methods
isn't changing so there's no concern
there it's also source compatible for
the same reason it's not going to change
how your code compiles however it is
this third kind of change it is a
behavioral change and we know people can
in do in facility lie on the iteration
order we even have some examples of this
in our own jdk code base that bite us
now again therefore this kind of change
changing casts that iteration order
would generally be out of bounds for an
update release but it would be something
we could do and have done in a platform
release and we do this today to take
advantage of better hash algorithms that
are developed over time so if you want
to learn more about this for a
particular release you can look at the
release notes and compatibility guides
they do use this source by new
behavioral classification there's this
document was produced along those lines
for JDK 8 and within the next few months
there'll also be a similar guide
produced for JDK 9 so how is data canine
different as I mentioned before it is
allowing a larger range to make
incompatible changes and this is to
further the long term evolution of the
platform there are some things we
haven't done before so for instance if
you would lie down the existence of our
char for some reason that file is no
longer there one of the cases where we
broke binary compatibility involved some
unfortunate use of the beans API in
far-flung parts of platform J
java.util java.util jar that's part of
the base knowledge we want to be able to
keep the base module nice and small but
in a few cases it used part of the beans
API which pulled in all the desktop
module so we didn't want to have the
base model to include all this hop as
well so the solution to this was first
to deprecate these methods in eight with
a warning they'd be removed in nine and
now we've gone through and removed them
a nine so that is a binary incompatible
change if you relied on these methods
they're not there anymore however we
thought it was important enough to have
a better bod pob module D competition to
the platform to make that change and if
you're interested in defecation matters
we'll be saying more about that later in
the talk and I encourage you to follow
doctor deprecated er who takes care of a
delicate Pat ability on Java deprecation
on twitter onto some of the tooling
improvements first up is J shell in the
list community there's been a long
tradition of providing a read evaluate
print loop called the repple as a way of
interacting with the language if you
coming from the Ruby or Python community
you have similar functionality there and
on the VM side if you work with Scala a
ruby enclosure there's also this kind of
repple you're used to so what about Java
what wouldn't a repple be nice for Java
as well we thought so too and that led
to the JDK 9 project of adding J shell
and I'll give a quick teaser demo of
that here and that is not the window I
want
okay so this is Jay shells new command
in the JDK this is JDK installed from a
recent did here on early access so we'll
wait for that to start up here so what's
the first program you write in any
language hello world so we can excuse me
type down here now we see it comes back
right away
so we executed a first Jake shell
program so this is just actually new
string back to us but you notice we
didn't have to say public static void
main string args so forth so there's
much less ceremony to get started here
we can just start playing around we can
also say declare variables so let's say
we want to have a double variable tau
and we want that to be equal to two
times pi so we know there's a pi
constant to find in the math class we
can tap complete for math here and then
we know that pi constants there so that
autocompletes and then we get that back
to us of course we don't want just
fields we also want methods so let's say
we want to find a method square that
takes a double and squares it
now this methods in our environment so
we can complete on that and we can
square a towel and we get back something
that's about the right size so that's
good
there's also command line editing so if
we want to say take the square of the
sign of the value and add it to the
square of the cosign we should get
something close to one and that is
indeed what we get so going back to the
slides so as I mentioned there's less
ceremony for students getting started
and Java you don't have to worry about
what public static void mean on the
first day but this isn't a feature just
for people new to Java it's also a
useful tool for experienced developers
this might be a good way for example to
start experimenting with those new and
nine JDK nine library features the
implementation of JCL leverages many
existing JDK technologies and the lead
engineer for Jade shell my colleague
Robert field will be giving a talk about
this later today if you're interested to
hear a lot more about it next up we'll
talk about Java doc for many years Java
doc output was done to the 4.01 HTML
standard a few years ago there's a new
HTML standard html5 so now you can opt
in your Java doc output to be html5
instead of HTML 401 although we don't
have any videos enabled by default how
many people have used a doc length from
JDK 8 no hands well this if you're
concerned about the semantic and
syntactic correctness of your Java doc
you can now check that using dockland
either as part of Java C or as part of
the Java doc command one of the changes
to document one of the improvements we
added in JDK 9 was packaged filtering so
for instance in the JDK build we only
dock
the Java and Java ex packages and don't
bother worrying about the Javadoc
correctness to the same degree for the
implementation classes say in dedicated
star or some not star the Java doc
checks you can enable or disable these
individually they range from things from
syntactic well formulas of the HTML to
semantics checks to make sure your FC
and link tags have valid targets if you
write doclets we've updated the doclet
api to have a better foundation the old
doclet api was done very early in the
Java platform I think it's fair to say
it doesn't it didn't follow what are now
considered best practices for API design
and we were able to re-implement this on
a more recent language model and reuse
that from another part of the platform
another feature we added to Java doc is
a Java doc search box and we'll have
another quick demo of that okay so this
is the Java doc output for a recent JDK
9 build you'll notice the frames view is
not no longer the default with those
three panels if you still like that you
can get it from over here four frames
and now in the upper right hand corner
there's a search box so let's say we
want to search for math we see here the
search returns results in different
areas it searches over the names of
packages the names of types in the
signatures of fields and methods and we
see all all of those showing up here in
the search output and then you can just
select to go directly there we've added
modules in JDK 9 so this also works over
modules for instance if we look for the
base module it shows that as a module
result and we can also look over the
packages in that module we usually lose
camelcase naming convention in Java and
sometimes the method names are kind of
long so let's say we wanted to find out
the Javadoc for equals ignore case we
could type that whole thing out but
that'd be a little inconvenient so we
can use cam
okay search instead so we go equal and
then ID for ignore and now we can select
which of the two methods we want there
so it's a nice quick way to look up
information in Javadoc now so you'll
less often you'll be tempted to use the
search engines to find things in Javadoc
you can just use Javadoc itself the
search feature is implemented side in
JavaScript so it's runnable locally you
don't need to have a server to do this
as I mentioned it indexes over all sorts
of names and signatures present in the
Javadoc from type names to the module
names you can also using a new tag to
find your own index terms that will show
up in the search the next two features
I'll talk about concerning the
transitioning from one JDK release to
another multi release jar files and the
Java C dash dash release flag so first
will be about cross compiling with this
new - gasps release flag so Java sees
along been across compiler you've been
able to use Java C to compile from the
current J today back to older ones I've
written a blog entry about how to do
this it's also in the Java C man page
and there are three things you have to
set for your Java C command to make this
work properly you have to set the source
version you're using you have to set the
target version and finally you have to
set the bloop class path to the boot
class path through the earlier JDK
release related to this we've changed
the policy about how many source and
target versions we support instead of
going all the way back to the beginning
we now have a version of one plus three
back
we started this in JDK 8 so if a JDK 9
that means for source and target we
support nine eight seven and six however
six is deprecated and a warning is
issued when we use it so following this
policy and JDK 10 the six option isn't
supported anymore but used to have ten
nine eight and seven and seven is
deprecated and so on so why do you need
to set the boot class path well let's
take an example here of JK Library in
JDK version 10 there's one method foo
that takes a double Letton let's say in
JT
plus one an overload for foods out of
the takes an INT and let's assume that
these are semantically equivalent but
it's just a fast pass for in stove it it
would follow all the usual behavioral
the compatibility rules we care about so
this is a perfectly reasonable library
change for the JDK now let's have our
client library that calls two so if we
take the client library here and compile
it against JDK n plus one what does the
call of foo mean so Fouchier takes an
integer argument so then if we go over
to JDK n plus one which of the two foo
methods is going to get put into the
class file this is going to be the
method that takes a double of the method
that takes an int it's going to be the
method that takes in it right that's
about the most specific method that's
what the spec says to have let's say we
take that class file even if it has the
class Hall version for the older JDK n
version now we run it against JDK n
what's going to happen we're going to
get an error or something like this at
runtime no such method error now if we
decode what the error message says here
it basically says I'm looking for a
method foo in the in the library class
that takes an integer that's what the
eye and parentheses means and of course
in JDK n there is no such method because
we only have the method foo that takes a
double now to avoid this sort of
mismatch this is why you need to use the
boob class path from the older version
when you're cross compiling so we've
known about this problem for a while and
people could keep reporting bugs about
it in food alright well we'll provide
some help in JDK 7 if you use a the
older source of targets and you don't
set the booth class path will issue a
warning you can suppress the warning if
you want so that's fine we thought that
would prevent people from running across
this problem but we were little too
optimistic about that we still had bugs
coming in about this so we thought about
it some more in for jdk 9 we thought you
know what we know what people want to do
here they just want to cross compile to
the older version so why don't we
provide that functionality directly
instead of having people to approximate
themselves
so that's exactly what we did with the -
- release and option that's semantically
equivalent to specifying the source
target in boot class path and now that
boot class path information is provided
to Java C stored in the compressed form
as a additional bonus the information
available and release release - after
Lisa and only the api's we think you
should be calling so those are the Java
SE e api's and the exported api's of the
jdk so things like the those tempting
Son Nhut star api's are not covered in
now and you for - after issue have the
same set of options as for source and
target so if you advantages here if you
were setting the boot class path
previously you don't have to worry about
managing that artifact anymore where do
you get the boot class pass from some
people use the maven plugin animal
sniffer and he will use that plugin one
or two hands so that did the same sort
of checking that shouldn't be as
necessary anymore because it's built
right onto Java say write write in Java
C it also means that if you using Java C
from manure releases you can take
advantage of bug fixes and some possible
for performance improvements that might
have gone on since the earlier jdk
another feature we've add to help each
transition to newer jdk is multi release
jar files so if you have a library
application it would be inconvenient to
have to distribute a jar file one for
jdk n and another Ek Tha n plus one so
people instead will distribute a single
jar file you compile against the oldest
jdk they want to run on that has a few
consequences it does slow down the
adoption and new features because it's
awkward to use the features in the new
or jdk sometimes you can get around that
using reflection but that's slow and
somewhat awkward and the modularity
features in jdk 9 make some of those you
shouldn't be using them api is harder to
access so this wouldn't work quite as
well so you're trying to rewrite it now
is multi release draw files the idea is
pretty simple there's a common shared
area across all versions but then under
the meta in area there are jdk platform
specific
overrides you could have a little ride
source eight nine and ten that take
advantage of nine and ten specific
functionality the multi release jar
files are created using new options to
the jar command and the parts of the
platform which consume jar files of the
jar API the Java the Java command in
Java C have been updated to be multi
release aware next I'll talk about some
of the language changes non modularity
language changes that have gone into JDK
9 the first of those would be in milling
project coin so the term milling a coin
refers to putting those little ridges
around the edge of the coin as shown the
silver dollars here the motivation for
this was when coins were generally made
of precious metal like silver or gold
people tend to shave down the edges of
the coin and then sell that separately
kind of a debasing the coin and by
putting the ridges on the coin it makes
it more obvious that that's going on in
preventing that so in the same idea for
milling project coin one you maintain
the value of the coin features over time
by filing off some rust rough edges that
were left at the end of the JDK a seven
as a reminder these are the project coin
features from JDK seven and three of
them have small updates in JDK 9
these are the updates we'll be talking
about three of them are for project coin
there were some similar situations for
project lambda where they had a few left
overs to take care of and those were
handled under milling project corn as
well so the first of these changes we'll
talk about is safe varargs on private
instance methods so back in jdk 5 or 6
you might have written code like this
you have a listed list of strings and
you want to initialize it using a razor
as list one of the platform methods so
that should be fine so you have a
genuine february in english and italian
here so then if you did a compilation of
this you get a warning like this warning
uncheck generic array creation from bar
X parameter type list of string array so
this message sounds a little a little
concerning what's going on here is
basically a bad interaction between
arrays and generics from the VAR args
parameter of arrays ah des lists and the
language specification requires an a
warning being issued in the situation
because something called heat pollution
might be going on there might be a
misleading that the compiler can't prove
that things have the proper type so
while it's correct in the sense of you
want to warn when this situation might
possibly occur nothing bad actually
happens in this case so this is a false
positive in the errors uninformative so
we prefer not to have these false potted
positive errors we don't have to so for
that reason we added this safe varargs
annotation back in JDK 7 and say for our
basically says compiler please trust me
I I will I'm swearing that nothing acts
bad along those lines is happening in
the bogs method so you don't have to
issue the warning and we added this
annotation to a number of the platform
methods including arrays out as list
now this annotation there's a few things
it removes various warnings from the
method declarations but more importantly
it removes warnings from the method call
sites that is all the uses of these
methods so users wouldn't get this
uninformative warning message anymore
now because of the design of annotations
annotations are only inherited for
classes not interfaces or methods that
means we can only use the safe args
annotation on methods that can't be
overridden so what are the kinds of
methods in Java that can't be overridden
we can't override final methods we can't
override static methods we can't
override constructors because from a
certain point of view at say the VM
level a constructor is this a very
special static method it has the same
kind of feel to it but there's a fourth
kind of method you can't override and
that is a private method and we forgot
about those when we were doing project
cloning JDK 7 so in JDK 9 now we added
them this is the corresponding part of
the Java language specification and we
were just able to add of two words to
cover the language change here so this
is a very small language change we'd
like them under nice and simple like
this because they're often much more
complicated and surprise us but there
were no surprises here next I'll talk
about the affected final variables and
try with resources so as a reminder
you'll be familiar from using a jd7 rate
you got prior three sources so you have
your resource are in a block and now you
manage it and this is roughly equivalent
to this where the compiler inserts a try
finally around your block and it makes
sure that close gets called on your
resource if the resource is not null
it's actually a bit more complicated
this about exception handling so in
terms of full disclosure this is the
folder screw ring here which is a more
involved but we don't have to worry
about this the compiler takes care of it
for us so what's the structure of the
resources to be managed in JDK 7 the
rule we ended up with was you had to
declare a fresh resource variable for
the resources managed by the fire
resources statement that wasn't the
original proposal originally you could
pass in any expression that had the
right type inside being Auto closeable
meaning that the object in question had
a closed method but we found a problem
with that so let's say we have a
resource R and then we manage our with
the chars resources statement and within
the block of the tribe's resources agent
we make our point to a different object
so what should happen now when we get to
the end of the block which object should
have it's closed method be called should
it be resource one should it be
resourced two should be both of them we
decided we preferred not to solve this
problem and the way we didn't solve it
was to not allow you to just pass in an
arbitrary expression you have had a
fresh variable that had to be final so
that was a little so that that worked
but it's a little annoying to have to
declare a fresh resource variable
because there's some times when we know
this situation can't occur you can't
reassign the variable if it's final and
you can't reassign it if it's
effectively final effectively final
means you could declare final and you
just haven't gotten around doing that
yet so what we do now in in jdk 9 is we
allow you to use an existing variable as
long as it's a final effectively final
so instead of writing code like this
here where we have to have this second
resource just to manage our resources
statement we can just pass the final
variable R right in there and this works
fine we avoid that problem of not
knowing which show
object to call clothes on it this wasn't
too hard to do with a grammar level we
just expand the grammar a little bit to
allow variable access and the
specification change corresponding need
is here now you might initially think
that this would be very small spec
change is a sentence or two or a few
words because maybe you just want to
call allow say a local variable that's
fine or effectively final but we don't
want to allow just local variable that's
final effectively final we want more
orthogonality between the features so
even if you have something like a final
field of a new object for an anonymous
class that should be allowable too and
that's what this change allows so
diamond with anonymous classes so
diamonds are formed under the earth at
great depth and pressure and we'll have
to go a little bit down the rabbit hole
to see what's going on here but
hopefully worth the trip so I'll be
using this example of a box type for the
next few slides you can think of a box
is a simplified collection so it's a
parameterised type you can put object in
and get objects out and so we have an
example here we have list of question
mark that's a wildcard type and let's
say we want to put that into our box and
using diamond so so that's fine now what
the compiler has to do at this point is
infer what goes between the angle
brackets so Java is still a statically
typed language even if it's not
explicitly typed what that means is if
we have programmers don't put in the
types for the angle brackets of the pram
drive types the compiler has to do that
work on our behalf instead in the
process that that done by which that's
done is called pipe inference so inside
the compiler works what happens is it
infers this type list of capture of
question mark well this sounds a little
little unfamiliar so what what's going
on here is that this is something called
a nan de notable type this is not a type
we could write ourselves in the program
however it is a type available inside
the compiler this is actually a fairly
common implementation technique for
compilers where there's a richer type
system in
by the compiler then is directly
available to programmers so capture
conversion this is a type operation and
basically it means inside the compiler
each of the wildcard Jesus question
marks which means there exist some type
is replaced by a new fresh type variable
inside the compiler some particular type
variable so it's converted from a
wildcard captured given a particular
name this is described in the JLS and if
you're interested in the sort of thing
if you're reading this part of the Java
language specification it's good to have
a type theory manual in your body now
box disease class it can be subclassed
including being subclass anonymously
again we want our features to to
interact and be orthogonal but this
anonymous sub classing is a bit of a
problem for diamond as we'll see the
next slide or two so let's say we wanted
to compile this anonymous subclass how
would that look so it's a class so it
needs a class file so we'd have a name
somewhere light box dollar one and as a
class file it has to be translated into
a class file with the full set of
attributes so in particular the generic
information about a class is put into a
signature attribute in a class file the
signature attribute only can hold de
notable types the grammar for signatures
doesn't allow non de notable types so
the grammar does not allow for lists of
captures question mark in particular so
this was rather unfortunate when we
realized this in JDK 7 because this is
now a problem we can't and can't write
out a class file that has the
information needed so what's happened to
your well we've had language
interactions over time way back when in
turn class is routed in jdk 1.1 generics
were added in jdk 5 and generics and
inner classes interoperate just fine we
made sure that occurred then in JDK 7
diamond was at it so pair wise diamond
in turn classes work just fine in pair
wise diamond in generics work just fine
after all that's what we're trying to do
but if we combine diamond inner classes
in generics we have a visit from bag
this is Duke's evil twin brother who's
looking to deface coin with our battery
acid here
so this is the case of today's problems
coming from yesterday's solutions as our
language architect Brian gets like the
second so as a result of when we found
this in the JDK 7 we had to have a quick
solution and we decide just to not allow
diamond with anonymous classes at all we
thought that was a little unfortunate
and when we were finishing up the jsr we
did know that it's feasible that future
platforms we could allow use of diamonds
when creating anonymous inner classes as
long as the inferred type was a notable
basically as long as that bad case that
can happen there's no reason we couldn't
use diamond and that is indeed what
we've done now in a Java 9 to allow dye
move anonymous classes as long as the
inference works out fine this is the
spec spec text needed to do that it's a
little involved but luckily we have the
spec guys to do that for us diamond in
JDK 7 by our experience is quite
effective
it was able to get rid about 90% of the
explicit type arguments of constructor
call sites and we think with diamondden
anonymous classes in mine we can get rid
of much of the remaining 10% we've had
good experiences updating jake oak jdk
code base to use this in particular
these calls to privilege action next up
is underscore no longer an identifier
name this has been changed unfolding
over a number of years and releases part
of project lament in JDK 8 was not
allowing a single underscore to be used
as the parameter aim for lambda this was
to avoid confusion with the wunderbar
feature of other languages you might
have used and while in JDK 8 it remained
legal to use a single underscore as a
name in other context you do get this
warning from Java C letting you know
that this might be going away and indeed
now and 9 it has gone away so why would
we do this this is against our usual
compatibility policy of you know keeping
the programs that compile today
compiling tomorrow we want to reclaim an
underscore for a single on the score for
some other purposes going forward there
are a few potentials there may be a
partial diamond if you're partial
witness or a official way to say I don't
care or variable not used
to get rid of them and some more
particular uses are being discussed
under one of the Jets for upcoming JK's
under a JEP three or two part of a more
lamda leftovers work next private on
interface methods again these are one
another one of the project lambda
cleanups project lambda added default
methods to interfaces that is methods
that can have bodies so they're non
abstract now at the VM level it was
convenient and necessary to have private
methods in interfaces to help implement
these however private methods and
interfaces were not valid at the source
level in JDK 8 so now we've changed that
in JDK 9 you can have both private
instance methods as well as a private
static method and why would you need
these private methods in an interface
you can have them as helper methods for
the other default methods so they're
quite useful for that purpose next I'll
talk be talking about deprecation and
imports this was one of another few
small language changes so his background
a few years ago in the JDK say at the
start of JDK 8 we had some unpaid
technical debt we had over 10,000
warnings of our own code from our own
compiler so that wasn't a great
situation to begin and over the years we
worked hard to not knock down those
warnings so toward the start of jk9 we
had about half as many about 5,000 in
between the start of JDK 9 in about
build 47 we went down from a few
thousand warnings all the way to zero
we're quite happy about that we turned
on excellent W error in our build and
discovered our open code close code and
all the other code in certain parts of
the platform now if you look at our
might files today this isn't quite true
anymore there's still a few dozen it was
true for some time it was true for many
builds but we currently have a few dozen
warnings remaining of a new and nine
category so we haven't quite gotten
around to fixing those yet but maybe
after the conference I'll be able to fix
those in 9 and those warning free you're
mostly warning free modules include the
base module desktop in core things like
the compiler we didn't get around to
covering
other parts of the platform so people
often talk about technical debt I'd also
like to talk about technical dividends
there's some benefits of doing this
since we have exterior warning we don't
have to worry about forgetting to
declare so you a version UID there's an
equals hash code check from Java C to
make sure you're overriding one when you
do the other there's possible security
benefits the go-to fail go to fail
security issue from a few years ago is
similar to having an unintended switch
on a fall through and that is one of the
conditions checked by Java C errors and
in that diagram the very low lowest
bottom level was about deprecation so is
it really acceptable to have deprecated
items and I've written up some advice if
you want to try to remove the Java C
errors from your own code base so
deprecation errors we had hundreds of
them there are a few ways you can
resolve them you can remove use of the
deprecated element that's preferable in
some ways but you can't always do it you
might need to keep how exposing that
functionality for your clients you can
propagate the deprecated annotation to
the youth site now in some in some ways
the cure is worse than the disease right
because you're expanding rather than
contracting the amount the amount of
code that's deprecated so the last thing
you can do is you can use the suppress
warnings annotation to declare that yes
I know I'm doing it but don't worry
about it it's okay so let's see how you
might use that you have your client code
you have your deprecated library so when
you compile you get this warning say
fine I can't I don't want to make this
deprecated yourself like you have to
keep using deprecated libraries so
you'll just apply the suppress warnings
annotation like so right at the top of
the class that looks good so then you
compile again and you still get a
deprecation warning so what's going on
here well if you look a little more
closely what's going on you're actually
getting a warning in this case from the
import statement because you're
importing a deprecated library this
warning is mandated by the JLS now you
might say well that's not a problem I'll
just apply another suppress warnings
annotation on the import statement you
can't put the annotation now it's not
syntactically valid
so this morning it's well-intentioned
but it is kind of unhelpful because if
you can suppress all the other uses of
the deprecated type why can why do you
get this warning from the import
statement and you shouldn't have to do
something like change to using a fully
qualified name everywhere to get a
warning free program @w a little silly
so we change the language specification
in 9 to not require a warning in this
situation and with that it's now
tractable to clear a large code base of
deprecation warnings and the existence
proof for that is the jdk code base it's
off so there's a more changes to
deprecation in jdk 9
what does deprecation mean it's been
around for a long time does it mean it's
harmful does it mean it's going away and
if it does mean it's going away why
haven't you jetty cake guys removed
anything or just remove one or two
things after all these years well we
needed a richer set of tools to help
manage this and we did that by changing
the deprecation annotation in JDK 9 to
have more information in particular we
added a method that says for removal
that's boolean whether your appliance
removed or not and what this means to
the types we've applied it on in Java
Sea on the JDK if something is
deprecated for removal true we intend to
remove that item in the next major
version other release so the items that
are deprecated for removal true in JDK 9
we plan to remove in JDK 10 now there's
a new lint category for this removal the
category haven't quite finished cleaning
up yet in our own code base so that
there's an extra warning if you're using
a for removal true item as opposed to
just a normal deprecated about them
there are updates for this throughout
the platform from the language spec java
c and java stock there's also a new
static analysis to add a deborah's can
that will analyze your class files and
jar files and let you know when you're
using deprecated API s and deprecated
for removal api's so you can clean that
up on your own without recompiling
finally I'll give a brief overview of
some of the library updates that went on
in the release first there's a new
versions string scheme base
for many years we've had 1.5 1.6 1.7 1.8
you'll notice the one dots never
changing so we decided since it's not
changing it's no reason to have around
so we dropped it so now the version from
JT 9 will be something like not instead
there is a some entering work done with
strings in JDK 9 there's a new internal
representation for compact strings they
use a byte array instead of a car array
so they're often denser so better memory
usage like garbage collection and the
like there's also a separate effort to
provide a communication channel
interface between a Java compiler in the
VM to have better string concatenation
the shapes of string concatenation a
Java compiler emits and the shapes that
a particular VM can make go run fast
kind of change over time and this is a
stable point that can be used to get
better performance on that common
operation a few a few notes on
collections so how many times have a
written code like this you want to have
set of strings it's on modifiable so
you'll you'll get a hash there you'll
put a few things into it and then put in
wrapper this is kind of taking up a lot
of space for what it is so we might do
something like this instead we use a
raised dot as list and then we have the
wrapper there it's shorter but it's
still kind of long there are other
coding techniques you can use the double
brace trick with the anonymous class I
don't even show that but this is still
rather rather clunky for a very common
operation
so in JDK 9 we don't have to write code
like this anymore we can just write code
like this which is much nicer these
there's a static factory methods of
added to list set and map these return
unmodifiable collections maps and lists
have randomized iteration order in my
colleagues two remarks worked on this
feature we'll be talking about this and
other collection changes in jt9 later
this afternoon delvia objects is a type
that has various utility methods we
expanded that as well to have some
additional options for checking for null
and checking for indices very common
did math as I am we had a few changes
there as well use multiply add which is
a hardware instruction for
floating-point that's getting more and
more common if you do things like
lexicographic array comparisons we now
have intrinsic support so we can use
hardware instructions to make that go
faster on platforms with that approach
also changes in concurrency and var
handle for more advanced programming a
lot lots of other changes too that was
just a few highlights so in summary in
jdk 9 we're making fundamental changes
to the program platform with modularity
but we have many other changes as well
and modularity and the other changes are
geared toward encouraging the long term
evolution of the platform so dhoop here
in the US is of legal drinking age Java
has been around for over 21 years and we
want a Java to be around for for many
more decades to come after this some of
these language changes and other changes
are planned and unfold over multiple
years and multiple ESA's and we have
better tooling now to help manage that
transition both for ourselves and for
Java users this is being done in open
JDK so if you want to get more involved
you you're welcome to follow there and
those early access builds are available
today for your evaluation so so please
try out the jk9 early access to it early
access bits this is a URL to the slides
here we have time for some questions now
and you can also tweet questions the
hashtag on the final slide thank you
if you have a question please come up to
one of the microphones in the aisles
my question is them did you consider
array slicing in 4/9 and would you
consider in the future array slicing
could could you say what you mean by
that
like in Python where you can just slice
up an array by using syntax of the
language yeah the question was do we
consider array slicing that that was not
considered there are more array based
changes coming but I don't think that
one is one being discussed I'll be down
here if there are other questions thank
you for coming here today</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>