<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The many shapes of Polymorphism by Luca Molteni | Coder Coacher - Coaching Coders</title><meta content="The many shapes of Polymorphism by Luca Molteni - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The many shapes of Polymorphism by Luca Molteni</b></h2><h5 class="post__date">2017-03-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/7PfNo-FMIf0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so again I guess we can start so they
just told me they didn't know what the
count what this talk was about this talk
has a very and suggestive name the many
shapes of polymorphism thank you thank
you for having me here my name is Luca
Moulton II this is the my Twitter
account and this is the company I work
for that's called gold money we do
digital payments with gold check it out
if you're interested let's focus for a
while on the title it was a joke someone
get the joke not to anyone
one yes yes I knew it was funny
not really funny but at least
interesting something that makes you
think to get the joke you already have
to know what polymorphism means but
don't worry we're going to explain now
but is it is a metal referential joke
you know the many shapes of mei of
having many shapes something like a
recursive definition something like that
so what is polymorphism it is a very
complicated word for me to pronounce you
may have heard it before
probably in a university if you haven't
told it in university then there is a
problem it means the state or condition
of being polymorphic which is pretty
obvious polymorphic comes from the greek
which means poly means many and morphic
morph will means figure a shape so
polymorphic what means occurring in
several many forms aperi and a different
forms in different developmental stages
so it means having different shapes so
the joke was the many shapes of having
many shapes yeah thank you it's someone
laughing in our case so in the real
world there are many shapes of
polymorphism this definition in
particular is taken from biology we're
not going to see this today
but I'm going to show you someone
something I'm sorry this optical
illusion enzyme is a mean of
polymorphism for an example the Rubens
base this is an optical illusion I don't
know if you can see it as typical you
probably already know this is depending
on what you see and how your brain
interprets the image you get a vase or
you get two faces this this is actually
being polymorphic because it has two
different shapes at a different time but
I like it because it's a also a metaphor
for our work I mean you're writing your
code and you think your code has a
structure but probably another developer
thinks that your code has a totally
different structure have you seen have
you thought about it but probably our
programming our program looks more like
this one this is a little fee by Escher
it's probably really really famous there
is two different houses the one above
and the one below and the the ceiling of
the first hours below is actually that
I'm sorry the yes the ceiling of the
first house below is the the floor of a
second one do you see it it's quite nice
isn't it so also this one is a metaphor
for our programs because the first
programmer came instead of being a house
from the from the floor so it creates
some abstraction and it comes to one
point then another developer came and
thought that the ceiling was actually
the floor and created a whole new
abstraction on top of it so now we have
this shape in the between that is
neither the roof or ceiling or it's both
at the same time what do you think it's
quite interesting so then there's this
cute image I found on Twitter because
everyone has to put good cute images in
a presentation so at this time I wanted
to do all so this is this is not being
polymorphic this is just ambiguous
because it's obviously a dog okay
it's nice I love dogs so this is God
kind of dog I would like to have or if
you want to choose a more serious note
the classical wave particle duality of
light and if you think this is different
from optical illusion this is the light
depending on the experiment we do it
behaves like a wave or behaves like a
particle so it's being polymorphic okay
how is this related to programming first
of all we have to understand why we use
types in programming language I really
hope that you use types too to do your
daily job we do we use type to model our
data but we also use type for this thing
I took this definition from this really
famous book which is called types and
programming language is a really
complicated book by this Benjamin C
Pierce
so let's read the definition a type
system is a tractable syntactic method
for providing the absence of certain
programming behaviors by classifying
phrases according to the kinds of value
they compute so we want not only to
model our data but we want to
demonstrate then our code certain
behaviors are avoided or impossible
that's the true meaning some are true
meaning of a type so in this case we
want to really understand what we use
types because when we are using type we
have to deal with this polymorphism
let's take another two definition of
polymorphism this one is taking from the
wiki of Haskell so a value is
polymorphic if there is more than one
type it can have so now you we're trying
to understand what polymorphism means it
has to deal with types when a value in
our program has different types is being
polymorphic exactly like the example we
seen before or this is another example
which is probably better is taking from
darkness through strobe the inventor of
C++ he says from the point of view of
functions it means providing a single
interface to entities of different types
this is probably the most classical
definition of polymorphism
okay so you're starting to get a grasp
of what volume of his is but now we're
going to see some real-world examples so
that you can understand why we could
need polymorphism can you imagine having
a programming language that is not
polymorphic of course there's a
rhetorical question but there is a
language we're going to see some example
that in some way it's not polymorphic
and it's called Oh camel which stands
for objective camel but we don't work
don't worry about it this is the first
example we see no camel the syntax is
pretty obvious we see there is a value
called sum which is the sum of 1 plus 2
and returns 3 1 &amp;amp; 2 are integers and 3
the result of interest pretty simple
isn't it here's the another example
we're trying to sum here 1.0 1.0 plus 2
and this thing doesn't work in objective
camel why let's let's read the the type
system arrow this expression is type
float when an expression was expected of
type int so this is not being
polymorphic we're trying to summon two
different types the first type is a
float and the other type is an integer
and with plus we can only sum two
integers as clear so the correct
definition if you want to do a float sum
between two types in akumal we have to
use this operator which totally looks
like the one we seen before
the plus but it's the plus dot and the
result is of course three three dot
which is a float
did you get this it is simple because if
you want to some integers use plus and
if you want to use it to some flow to
use plus dot but it's also really boring
imagine it every time you have to use
different types you have to define a new
operator or a new method so that's why
you're trying to we're trying here to
understand together the meaning then in
the need of polymorphism soon in our
implementation we're going to struggle
to find common names by the way I don't
think that plus
dot is a pretty good name for something
to float I don't like the name imagine
if you have to do something together
bigdecimal well you're going to write
something like plus plus dot dot I feel
like that it's just crazy you think
about we need something a big
polymorphic we need to have an operator
the works regardless of a type of a
number we have and it can have hopefully
the same semantics or more or less by
the way that that is obviously different
from the Java C sharp and C++ being
where plus you can sum whatever you want
you can sum integer it's pretty obvious
but I have to say it also there are new
discovers in type system but so many
times these discoveries are written in
papers and they're not appreciated by
the community the programming community
not not that much because papers are
really hard to read and there are
sometimes full of strange symbols and
sometimes we we would like to see new
things we are we the computer
programming community is like stuck in
object-oriented has been stuck in our
generated programming for like 20 years
but there are new products or paradigms
I don't know how to pronounce this why
the reason why we're stuck is that we
are practical we want to get our jobs
done but in very same time we we don't
we don't search for the paper for the
original paper of the object-oriented
programming as we take as an example we
study object-oriented programming as it
is the best thing in the world but no
one really reads the original paper from
the 80s and the 1790 to see ok
why was the purpose of jet oriented
programming why was the purpose what was
the purpose I'm sorry for subtyping for
example but that's good that's good for
us because we get our job done with our
system our tool so that's good but there
are many other things and I'm going to
show you today so this is my path this
with the polymer films is use defines
the shape of our code so we spend so
many time deciding if we want to put a
comma before or after the list or if you
want to make a space between all the
curly braces or something like that some
petty question but I never heard some
someone say something like which type of
polymer feels does your language support
have you ever heard something similar or
maybe this question this question is
really famous in every forum in every
every time you see something like people
arguing and fighting and insulting each
server say we know you should use a
dynamic language you should use a static
language my never never I heard about
people fighting over a type of
polymorphism and today I'm here to fight
on the type of an arm so why not yes you
can argue on them on anything so imagine
you can discuss over everything so
imagine that's a dream something like
that you go to work and you get to
choose the programming language
okay so Luca you have to create a new
project and you can choose your
programming language and I say something
like okay I need this library in this
library I may use Java I may use C sharp
it may be easy to find programmer that
work in C++ or something like that but
we never consider which type of
polymorphism my programming language
supports but that's important that's why
I'm trying to say to you today I have to
say this also polymorphism is present
also in dynamic language but I don't
know much about them because I never
used that so I just skip the part I'm
sorry if there is someone strongly
believing in a dynamic programming
language I'm sorry this is not a
presentation for you let's see some
examples of programming languages and we
see here okay I wrote in the first line
Java C sharp and C++ mostly because they
support the very same subset of
polymorphism we see it later which one
was it they are then we put a comma
which one the
language we seen before which is kind of
strange then we see Haskell how many of
you do know Haskell yes the number of
hands is constantly increasing every
year something maybe next year everyone
will know Haskell now is more like than
3/4 of the room so Haskell is more like
the most advanced programming languages
in this list and it's kind of
interesting because we see that later
so there's Go Go is a new programming
language huh I see are his hand so is a
go fan and I was the guy behind you or
whatever so go is a new programming
language this is funny because the
designers of Go decided not to implement
the polymorphism in the same way within
it in the last 20 years we see that
later also we they did the same in rust
rust has a different model of polymer
films which if you think about it is
funny because we thought we were stuck
in object-oriented programming so
subtyping inheritance something like
that and then in the last programming
languages we see something new which is
always nice so there are three kinds of
polymorphism the first one is parametric
also called generic polymorphism the
second one is subtype polymorphism and
the third one is hoc polymorphism please
note that this is a totally arbitrary
classification because in many papers
and books you see our classification you
may see for type of five types and we'll
do this to just keep it simple let's
let's speak about genetic polymorphism
which is that probably the most simple
one this is an example that you may all
understand this is a very complicated
method that takes an array list as an
input and it calculates how many
elements there are so it just iterates
over the list and some so the
polymorphic part here is an ax T
parameter which can be any type do you
remember the definition we see from the
Haskell wiki the first definition of
polymorphism when a value can be of any
type that's the case of genetic
polymorphism in fact in Haskell generic
volume efficient is very well
implemented so if we use this
thing we create an array list them we
put things together I'm sorry things
inside and then we count the value
inside the the number of values we see
there's just two elements so they were
introduced in Java five I think I just
checked before in Java for you had to to
create a new list put things together
and when you have to get the things from
the the list you had to cast it the
example the caustic is the operator
that's just basic Java but I had to tell
then when happening in Java five is that
now you don't have to to cast the result
is pretty clear it's a simple please
note that the implementation of generic
polymorphous is different from
programming to programming language for
example in java we have type a ratio
that means that the generic types are
totally stripped by compiler we don't
have them at runtime while in C++ you
may have meta programming with template
that means there are macros and upper
process so that something like that is
that all clear it is the simplest one so
let's go to the most interesting one
when I start working in 2007 where I
don't know why but in my application
there were so many web services well own
many web services web services something
like that so every method was something
like this say buy a product and you have
to instantiate the web service and call
a web service so you have to reduce the
user have to associate a web service it
was a really bad code of course you see
many duplication and I wish I was fresh
out of a university and I decided to use
polymorphism so I decided to put the the
the common behavior in an abstract class
and I thought I was using subtype
polymorphism do you see I'm sorry the
common behavior here is instance hitting
a new web service this is probably that
the worst code ever written but it was
my first job so I didn't know that
I was putting the the shared Khan Younis
upper class and then we were using
something like this we were instantiated
a part of web service and I called the
byproduct method but I thought I was
doing polymorphism but in fact I wasn't
because class is the share code are not
polymorphic at all they're just share
code together we're using the mekinese
me used for subtyping object-oriented
programming which is called inheritance
to share code among the subclasses I
want to be clear if you're making a
superclass
is some some subtypes and you don't
instance eat them polymorphically and
you don't pass them polymorphically
you're not using polymorphism you're
just sharing code using inheritance and
that is important because subtyping
could be implemented even without
inheritance and this is there's a paper
written on this but no one really did so
we stuck with the java c sharp a style
in which if we want a subtype we have to
use inheritance well instead subtyping
is more related to a meaning of
substitue bility which is a really
complicated word form it's pronounced
there's a form of type polymorphism in
which a subtype is a datatype that is
related to another data type the super
type but some notion of substitutability
meaning that the program elements
typically subroutines written to operate
on elements of a super type can also
operate on elements of a subtype which
means that if i have a function that
takes a super type I can pass whatever
subtype of the super types and my
implementation should work if of course
if we respect the famously scoped
substitutability principle which we're
not going to talk today by the way the
example we seen before could have been
expressed using composition rather than
inheritance by writing that the exact
same code in another method as just to
do the common part in fact if you really
books if you read the books on
object-oriented programming something
like that you see that often you see
these these tips or about use
composition already rather than
inheritance because inheritance creates
really tight couple classes and then
we're going to see the problems now
let's try it some real subtype
polymorphism so I told you we work in a
gold money it's we do digital payments
with gold so we have this trait this is
an example taken from Scala
treaty is an interface there's a metric
called show is real
simple mitten and we support two types
of different currency the Fiat and the
metals the Fiat is the classical
currency used every day use the euro the
francs or something like that and metals
can be everywhere everything from gold
to silver to platinum to palladium and
in our topology here is not of course
production code but it is just an
example the the fiat and a metal extends
the money and in this case implements
the era logic in a pretty different way
if we're trying to print to show our
Fiat we just print the amount which is a
big decimal and the currency together if
you want to to to show a metal since
different metals can be counted in
difference weight value I mean grams or
ounces we want to convert a convert
everything to grams before printing it
is that clear
this is butter matching is the syntax
color clear lexical a syntax we are
really hope so
so this imagine like a switch statement
if the case is gram let's print it as
grams if it's ounces let's convert it to
answers by multiplying 428 and then
print it so now we're going to see some
polymorphic usage we have this function
that takes a money which is the super
type and I just print whatever money is
being bought so you have both so in the
first case I am passing two francs you
have bought two francs and I'm passing
them 10 gold and they say you have both
time called ground is this clear so now
we want to to add some new behavior to
my class in this case and we want to add
a new method that is called serialize
the returns are reapplied because I want
to save this kind of money
so this serialize method is simple as
similar to the example we seen before is
really complicated in my case to
serialize Fink because I have to
distance it anew sir Eliezer I have to
call dispose on a sterilized imagine a
really complicated piece of code here
you see there is shared code among the
two subclasses
but the usage is polymorphic as we see
before then we have a safe method that
takes a money and they call just the
money sterilized
but the problem is what do we put the
share code we may be tempted to put the
serialize code in the superclass but
then we are coupling our implementation
to this actual implementation of
serialize method also we will be mixing
domain logic and behavior it's something
that should be totally separated
probably the logic serialization the
opening a file or writing on the
database it shouldn't be in our domain
object we see our designer evolving yet
again if we try to add another
implementation another method to my
money class of course I should be
allowed to some feed some metal together
right
so I created in a superclass limits this
method called plus which let me some
different money take a look at the
signature the signature takes a money as
an input or returns another money so it
takes it returns the super type not the
subtitle that's pretty important because
when we are going to implement this
meter we're losing type safety of course
the first line we have to check if the
the parameter passed is an instance of
what when we are going to need then we
are going to make an assertion in this
case it may be a and if something like
that that the currency of a Fiat is the
same and then we're going to return a
new Fiat clear this is the
implementation in the case of a metals
in the metals of course we have to check
that there we are trying to some metals
with metals because of course we cannot
some Fiat with metals then we have to
check that weight and weight type in the
metal type is the same then we return
let's see what we do when we use this
actual method we create a new Fiat we
sum it with a new Fiat one front with
two front we print it the repple says is
a Fiat but the return type is actually
the superclass which is a money can you
see that I wrote you the type of the
result superclass let's call a money and
this is not a really good thing because
to being polymorphic we losing type
safety
we can do better but first of all let's
see how we could calculate the sum of a
money let's imagine that someone has
already written the sum for us and they
expose a metal like these like some that
take a list of this maratona bigdecimal
how do I fit my feet my my money into
this sum there are incompatible types so
you can see we have emitted that is
polymorphic that the letters some
different money of type we have another
method but this type of polymer fiends
doesn't match together lucky there is a
solution for this there is a pattern in
the Gang of Four book which is called
the adapter pattern which we are going
to see out now and this pattern let us
adopt a different interface with
different types so if we try or and
maybe ask our colleague to write an
adapted version of a sum we see that
this sum version instead of calling
directly the plus method on bigdecimal
with what is going to to call is the
emitter defining another interface which
is called number like of a that means
that we are not calling our types
directly we're calling an interface
we're going at rate we're calling a
trade so now we can create an adapter
between the two version between the sum
method and the Armani type that uses the
plus we implemented before do you
remember so this is adapter money is
something like number like money extent
number like money it has a method gets
do you see the point no of course not
it has am it'll get that lets i'll
return the value and then the plus just
call the plus method we've used before
so now we're going to use this money and
when we create a list of fields as we
did before and then we can call the sum
adapted method by lifting by creating in
our list of fields calling map on the
list of field a number like money so we
have a list of field we are transforming
it in an adapted version in the adapted
version is polymorphic we can
deductr versions to the Sun and we're
going to return the Sun so now we solve
that problem we have 50 francs did you
get it it's pretty cool because we can
use external libraries with my custom
data type but we can do more because we
want a more type safe solution and I'm
what I'm proposing to you is instead of
creating an adapter for money we're
going to create an adapter for Fiat and
we're going to create an adapter for
metals and instead of calling the plus
method polymorphically we're going to
call the monomorphic version can I say
monomorphic non mushroom whatever is
recorded so we're good we're copying we
are replacing we're taking the our
implementation of Fiat and putting in an
adapter and you see this implementation
is easier because since I know that the
argument passing is already a Fiat I
don't have to check do you remember that
before we add the first line which was a
cast that has to check if the argument
passed was of the correct subtype here
we remove that also see that the return
type is an adapter version of Fiat so
when we call this meter now we have to
do the very same thing we have to take
the fiat map it to an adapted version of
fiat and then we called the sum but
instead what we are getting is a result
which is a Fiat you see result type safe
what do you think it's pretty cool it's
easier because the implementation is
easier is more type safe because we get
the type safe of course we can do the
same for the metal we just have to
create two adapters one for the fiat and
one for the metal as i said before we
can move the implementation of the fiat
but we could do even more we can do the
same thing for the various first meter
we taken in the first slide which is the
show method and instead of taking of
putting the show method in a in my
subclass we can create an adapter for
show which is diff
in the case of fiat and in the case of
metal and we could do that also for
serialize this is the result type as you
can see these are anemic types are
really easy there don't have any more
any behavior inside the type all all the
thing we care about is in the adapter
version in the adapter class so this is
totally different way to program have
you ever seen such a code I mean you can
do also that in skin in Java but imagine
if you have a colleague that every time
that eyes to create an implementation
creates an adapter I mean you would
think it's crazy but that's an
interesting thing I mean have we really
tried to compare this adapter style
versus the subtype style I mean the
adapter is more typesafe we seen that
the doctor let us reuse external
libraries different concern has split in
different part that means we can split
the stylization in the sterilization
file we don't have to put the
sterilization inside the the java class
but there is boilerplate every time i
have to add a new implementation i have
to create a new adapter but I also have
to lift adapter by hand I am my type I
have to create an adapter of types and
then passing the adapter of type
polymorphically to another method also
the adapter pattern breaks this
encapsulation thing this is not real a
problem because the monitor is of course
immutable but it breaks it so here's the
deal
what if there is a programming language
yes yes what if there is a programming
language this is the common way of doing
polymorphism or another programming
language where this is not the most
common way of doing this polymorphism
but is a typical idiom that you see in
many libraries you already know the
answers type classes that's the solution
so this is a definition taking also from
the wiki of Haskell
it's called type class is a structure
way to control hoc polymorphism or
overloading
what do you think I have I shocked you I
should have so this is an example of
type class written in Haskell they used
a reuse the terminology from
object-oriented programming they're
actually meaning different thing class
is the type class so that it's not the
typical class of Java or a Java code
well instance doesn't mean an object but
means an instance of a type class is
equivalent to an adapter and as you can
see in a skhul creating adapter I'm
sorry to say something like that
creating instance of a type class
doesn't take much code and I must say
this is the only way I repeat to doing
polymorphism in Haskell Haskell doesn't
support subtype polymorphism and guess
what you can write any programming or
any program you want even in ASCO it's
pretty incredible if you think about it
it's totally different so the the the
other programming language in where type
classes are present but they are not
written in the language that using
libraries is Scala but to understand the
type classes in Scala you have to
understand many many internal things of
the language and so it's really
complicated it's really out of a scope
of this talk so type classes is a
synonym is a way to achieve this hidaka
polymorphism which i think i may think
is probably superior to type type
polymorphism not because it's more
powerful it's actually less powerful it
is called a doc because it allows
polymorphic value to exhibit different
behaviors when viewed at different types
it uses an appropriate prepare
appropriate and sorry implementation for
each application of a function base
another type of the arguments in fact we
already used a doc polymorphism any time
in our java code this exemplar is pretty
common overloading overloading is a type
of a doc polymorphism and in Java it's
really simple you can use
only four four simple thing in this
example we have these two some meters
one take the integers and the other take
the doubles so we can reuse the name of
a metered that's where the hoc
polymorphism ends we've seen before that
the harder polymer films is far more
powerful than than this overloading
thing is over not in fingers may I say
useless I mean yes because if you think
about it it's just a convenience thing
to to recycle some method name but it's
not really as powerful as may get these
another example is equal but it's the
same to see so is it everything better
in type classes another polymorphism no
because there is only one thing that the
type class cannot do type class cannot
provide new types at runtime do you
remember the definition we seen before
the notion of substitutability the
really complicated word it means that
our runtime at runtime I can provide a
subtype of my superclass and my code
will still work if we respect the
contact of a disk or substitute of
liberal principle this is a thing that
you cannot do with type class when you
add a new type you have to recompile the
whole thing but I don't think that only
for this thing we should use subtype
polymorphism I think the problem is what
I've told you before that we accepted
subtype polymorphism as the normal
things to do for twenty years
because we never really inspected the
pro and the cons of each implementation
what do you think also you tell me later
what you think also when we try to mix
different types it's seen the example
before I told you was a doc polymorphism
I tell you I totally was subtype
polymorphism but there was actually
genetic polymorphism mixing different
type of polymorphism is complicated and
sometimes it doesn't even work when we
make subtype polymorphism with genetic
polymorphism bad things happen I want
our UI if you're interested that you
should check about it have you ever
heard of people saying variance problem
a covariance problem
that's when you're trying to make
subtype polymorphism and genetic
polymorphism which are two different way
to do polymorphism they cannot fit
together when instead generic
polymorphism works perfectly we've a doc
polymorphism in fact I don't want to say
always anything but in a scale the
generic by the genetic polymorphism
another polymer FISMA are used together
to restrict the type we're going to use
okay so conclusion how many times do you
have you're not really 15 minutes is
perfect
first of all polygons programming
just a quick digression of particle
programming as I shown I've shown you
many different example for many
different programming languages I think
this is a really important thing if you
haven't start learning new different
programming language you should start
today because as we as we saw different
programming languages implement things
in a totally different way and I think
that in 2017 we cannot just stick to a
programming language we should learn
different because once we learn
different programming language we we
learn and we discover the the prior the
count of implementation and something
like that in fact there are many
different start of programming you have
you should try different one if you want
to choose another programming language
don't choose a programming language that
implements the subject a polymorphism in
the same way you're already used if you
use Java for all your life don't learn
c-sharp
it's useless it's the same language it
has the same syntax it support the same
type of sub polymorphism which is
subtype a generic and in a doc of course
try different one try or camel
try Haskell try amel something like that
because only in that way you're going
scala of course the language i use every
day
because there are many different start
up our programming and any every style
is different of course so here's the
point can type classes replace subtype
polymorphism I don't know sorry I have
to tell you I don't know I probably
don't have the
the knowledge to demonstrate
mathematically to prove that you can
express every possible program with type
classes instead of using subtype
polymorphism
but I think that it maybe if we exclude
for a second the needing of providing
new type at run time I mean maybe it's
not a matter of expressing the same
program in a way or another way because
one is another or maybe the problem is
is there an example that is better
written with subtype polymorphism a
rather than with Ted classes if we
assume we are using of course a language
that totally supports type classes and
that's us right side classes in a very
small way because of course if we are
using Java and we have to create a new
adapter every time we have to create an
implementation of course we cannot
substitute that what do you think see I
don't have a thing with object-oriented
programming with that there's this quote
I really enjoy see that the problem we
object-oriented languages is that they
got all this implicit environment that
you carry around with them you wanted a
banana but what you get was a gorilla
holding a banana had been tired jungle I
always yeah this is a quote from the
creator of Ireland our lang I'm not sure
if really he is bad I found it on the
internet so must be true so what you get
I never quite get object-oriented
programming because it always felt like
I don't really know where to put this
kind of thing I mean I want to add on
your behavior where do I put in a
superclass I have to create an adapter I
have to read a whole gang of four book
on it I don't know I and I feel that if
it weren't for some time if there wasn't
subtype polymorphism think could be
easier and we like easy thing okay I
quoted a skull because a scale is really
famous for being difficult but if you
think about it by excluding subtype
polymorphism a scale is actually simpler
what do you think
so our type class is only for functional
programming languages no that's an
important thing we're not talking about
it's just a case I mean that the Scala
has kept ramming a functional
programming language because you could
implement type classes in in every
programming language a atm you have for
example do you remember that in front of
the first slide that when I showed you
different programming language that was
rust rust is a procedural programming
language heavily inspired by functional
programming language in which support a
style that is similar to a doc polymer
FISMA to type classes to do polymorphism
so I pretty much finished here and I
have an addendum though so this is my
Twitter account this was a heavily
opinionated talk I said many things that
could be wrong of course because I'm not
a computer scientist maybe even computer
scientists are wrong okay whatever so if
I said something wrong just tell me
don't worry and this is my Twitter
account or write me an email and
something like that so now you have two
possibility I have an addendum or you we
could do question time what do you think
at the end of addendum is there someone
who has a really good question I want to
ask really opinionated I'm sorry you are
right yes I'm sorry yes yes of course
thank you just wait for the microphone
please
you can't see you see only alive so
first of all thank you for the awesome
talk ah thank you so we all know that
type systems is a complex topic do you
think that it if it would be part of the
generic toolbox of every software
engineer it will be a better thing in
practice or it's just too complicated -
just to be clear are you asking me if
every programmer should use the type
system or you asking me if everyone
should understand these kind of things
okay do you really think this is complex
I mean if you I may agree this morning
at the keynote I was thank you for the
question and this morning I'm the
keynote I was shocked because Martin
Martin Martin Thomson showed us the the
toolbox every engineer should have and
he talked about polymorphism also and I
feel quite because I had a presentation
polymorphism and even I think yes this
should be in every toolbox of every
programmer who wants to use type system
you cannot you shouldn't really use type
system without understanding how
polymorphism works because in the end
you're going to use polymorphism of
course you're not going we're not going
to use programming language with like oh
camel which has a different method on
every types we are going to pass in the
end you're going to use polymorphism and
you have to understand what's happening
and you have to understand which which
case used in a in which other case so
yes this this should be part of every
toolbox I don't find it complicated but
it may be because of my experience every
pair every developer is own experience
of course I come from a functional
programming language where this kind of
thing is kind of normal thing so I may
see why people is why someone may be
scared about only here in the word
polymorphism or hadaka polymorphous it
doesn't mean that you shouldn't be
scared of course
that's pretty can I say simple because
easy I don't want to say easy it's hard
a thing I mean if I had to explain this
kind of finger to my mother or to my
wife it will be pretty complicated
because we have to understand one of
type system here he is what he behaves
so they're not easy of course but there
there is not much thing you probably
know already more complicated things
thank you is there another question one
two three four five time out so let's
see the addendum we have five minutes
Scala is a bridge from the Hopi to the F
P word okay
in the very words of the creator Martino
deskey he wanted to create a bridge a
language that you can use functional
language paradigms and object-oriented
paradigms so as you can imagine Scala
you can do subtype polymorphism and
hidaka polymorphism and now we are in
this strange situation where some
libraries use the first while some other
lives they used the second and in some
code you see people using type classes
for everything and in some code you see
mixing type classes with different
things
I personally but I'm no one of course I
personally don't think this is a good
solution because we see in the scala
community also in which I speak a lot
that some this question comes or often I
mean should I use type classes or not
and then this is even worse because
Scala is something like type class
something you'd remember the number like
example that there is in a standard
library so the standard library suggests
you that you should use type classes but
instead some other things are
implemented using subtype polymorphism
also this is a big problem with type
inference type inference is the way the
compiler lets us this let discover the
types without you telling him in Scala
the type inference is not
and the reason why is it because it's a
poor subtype polymorphism comparing to
the type inference algorithm of Haskell
which is perfect that can resolve the
types in every moment so if you think
about it this subtype polymorphism is
kind of I don't know it's kind of
creating problems sometimes I read on
Twitter that people hate subtype
polymorphism an what was it you you
wrote something about subtype
polymorphism Oh Lucas write something
even my other friends from the Scala
community in something like I wanted a
subtype polymorphism to get destroyed in
2017 but it was in this thing so it's
possible award without subtype
polymorphism and I wish it like that so
we have three minutes
I guess we're we're done thank you for
your time thank you for the conference
and have a safe journey coming back home</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>