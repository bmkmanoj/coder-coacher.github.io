<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Design Patterns with Kotlin by Murat Yener | Coder Coacher - Coaching Coders</title><meta content="Design Patterns with Kotlin by Murat Yener - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Design Patterns with Kotlin by Murat Yener</b></h2><h5 class="post__date">2017-11-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/stVBm3A5uDc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right I think that's time
very impressive crowd for 5:30
considering there is amazing beer
outside so I'll move fast I have over 90
slides 30 minutes which gives me roughly
20 seconds per for each slide I work at
Google but not on Android or Kaplan I
work on Google home Java champion xgd
and I happen to wrote a book on design
patterns it was a Joey book but looks
like I can't stop using design patterns
on any language I'm doing I'm working on
so this was a talk which I did with
Razor Ramon at JavaOne I can own design
patterns with Joey so first this is not
an official Google Talk so if you're
looking for something like that you can
leave the room join another session as I
mentioned I work in the Google home team
so neither coupling or Android is my
daily job this all my personal stuff so
why this talk simply because design
patterns makes you look cool smart geeky
if you have an ongoing technical
discussion with a co-worker
you can either the warm the discussion
if you just throw up some patterns if
you have some design patterns in your
bookshelf they look amazing you can just
tweet or Instagram some photos and all
your friends will just think you're
amazing that to be honest it just makes
your life easier when you're building
software so this is really funny
according to Dykstra object oriented
programming is a terribly bad idea and
actually if we just roll back and think
about it
design patterns came up after c++ was
ruling the software world so Gang of
Four explains design patterns were the
first people who wrote the book and are
kind of found the design patterns eight
idea design patterns are descriptions of
communicating objects and clauses that
are customized to solve a general design
problem in a particular context and this
is from my book I can't just say it's
what I something I said it's basically
because the collective wisdom thing is
something which everyone says so
basically design patterns are collective
with collective wisdom of many smart
developers before you who had pain and
come up with an idea of solving an
existing problem which occurs most of
the times so coupling what Scotland
cutting is a statically typed language
which runs on JVM it can be compiled to
JavaScript or the compiled to Java which
I'll show in the slides
it's interoperable with Java code works
with the existing Java class libraries
and also adds its own stuff like mutable
and immutable collections it's designed
and developed by JetBrains and according
to Wikipedia it's named after an island
like Java but actual Joe is after after
named after the coffee welfare espresso
and other stuff was taken so probably
that's good enough
so some tools first Java to Kaplan
if you're using IntelliJ and since we
are targeting Kaplan probably you should
you can just click code and select
convert Java file to Kaplan and IntelliJ
will do the work for you instead you can
just create a new coupling file and
copy/paste your Java code there and
again IntelliJ will ask you if you want
to convert the code and does the job for
you and something more interesting is if
you want to switch back to Java from
coupling you can go to two tools select
coupling and show
coupling by code which will bring up the
byte code which has the decompile option
and when you click the compile it will
give you the Java code so most of the
flights are prepared using those tools
so in the slides if you see these
symbols it means it's Rd written in Java
or coupling all converted from one to
other so let's move can go for design
patterns with
coupling first creational patterns
singleton so singleton basically it
tries to ensure a class has only one
instance and provide a global point of
access to that instance the classic
implementation is like making the
constructor private double locking
strike static initializers or in arms of
course it must be thread safe ideally
reflection safe and a lot of frameworks
platforms such as Java EE spring Android
users Singleton's so if we just look at
a naive Java example we have the static
variable which creates the singleton so
it's not lazy loading and there's a
static method which basically lets
anyone to access the singleton and as
you can see the
constructors of course private so if we
convert this to Kaplan we see something
interesting there's something called
object basically Kotlin doesn't have the
statics symbol so we have something
different and basically this will
replace the whole singleton class with
this much of God if we do something
nicer with Java and follow best
practices and of course joshua bloch and
create an enum singleton and see how
it's converted to Kaplan we see actually
it doesn't try to change it a lot and
creates a thing in our mean Kaplan and
it's basically much or less what you
would expect when you switch between
Java to cut lines if you try to write
something native in Kaplan with by just
leaving your Java knowledge aside what
you need to use is the object and create
a single term with object syntax what is
interesting is if you d compile this to
Jerome yeah and object makes the
singleton without any additional effort
if you D compile this into Java you'll
see actually cotton is doing a lot of
stuff in the background and it's
basically lazy loading loaded and
reflection and I forgot work now my
and quite saved singleton salt the good
the bad the ugly this is not about
coupling basically about Singleton's
Singleton's are good for expensive
object caching global access but all use
can cause problems especially if they
are not lazy loaded if they're lazy
loaded and they can cause delays and the
octave part is sometimes they're
considered as an anti-pattern next
factor method factor method is basically
defines an interface for creating
objects and the idea is encapsulate the
object creation into one place so if you
need changes in the future you don't
need to change a lot of different places
in the code so let's see a factory
method example in Java we have a car
interface and two different brands which
implements the car and we have a factory
which creates the car we want as test
with the parameter nothing interesting
so far let's switch the coupling and
that was actually the only example which
gave a compiler when I did the
conversion which I'll explain why but
basically we have the same interface and
concrete classes except for the
parentheses and less lines of code
captain is pretty good with that
almost every slide you'll see less lines
and we have our factory which does
almost the same thing but in this case
our cut line cannot return now because
in coupling now is it is treated
differently than Java so what we need to
do is to place an Elvis operator so now
return typeof null is a valid return for
our method
and he tried to write a factor method
native in coupling I couldn't come up
with anything better than which coupling
created from Java except for the Alice
operator which I typed initially again
the good the bad ugly these factory
methods are very easy to implement they
are really efficient in encapsulating
the object creation the bad part is
although it might be enough most of the
time you may prefer to move to abstract
Factory because if things get a little
bit complicated you won't need that and
the part is it may create complicated
mythical if you don't need it and just
put it to show off so abstract Factory
again it's a turn to encapsulate object
creation and provide an interface for
creating objects it's a creational
pattern very similar to factory method
and the thing different in abstract
Factory is each subclass its own Factory
by the way it's commonly used in many
SDKs and especially in JDK continued
from the previous examples we again have
the same interface and same brands this
time each brand has its own factory and
again we have one factory which returns
which creates the right factory and
returns the right brand you want to
create when we convert this into
coupling again we don't see something
special until we come to abstract
factory here you can see a companion
object and it basically has the function
method again why we have this
because we don't have the static notion
in cutland so coupling creates the
companion object which acts like a
static method in this case if we want to
write this in Kotlin again without using
the java knowledge we see something
different here there's an inline
function with reified january some stuff
and i don't really have a lot of time to
dig into this but basically this is used
for accessing the superclass of two
objects so without any casting coupling
can decide if all the or Marcedes if the
method passed is out there method is
without doing any object reflection so
if we D compile this to Java this time
we see something more complicated than a
lot of lines the interesting part here
is the bold part which uses the
reflection get or create coupling class
basically this is the part which the
refight part kicks in again abstract
factories encapsulates objects in favour
of organization and as create objects in
a safe way the bad part is specially
compared to factory method it introduces
more classes and over use will introduce
many classes in your project so again it
use it only if you need to builder
builder is a very effective pattern if
you need to create more than one
constructors
it's basically we
efficient in construction of complex
objects by the way each first slide the
first item is from Jenga for so they are
it's the definition of pattern in
getting all four terms
unlike factor method and abstract
factory builder doesn't really target
polymorphism basically tries to minimize
the constructor our Lord uses another
object to build the third target object
in the in the needed steps and basically
creates the object we need with the
parameters we need I'm using a very
simple example here usually you wouldn't
be needing a builder for just two
property but let's say for the sake of a
simpler code which will fit in the slide
we have a person object which has names
our name and if we try to create every
different variation of constructors rule
and still end up with one empty one name
one surname and name surname
constructors instead we can just create
a builder class which will set name
surname or nothing and in in the end
when we call the build it will create
the person object so this is basically
the basic builder pattern and we if we
just convert this to coupling again
we'll see less code first the person
class gets simplified and as you can see
both properties are now can be known so
they're not really required and coupling
basically creates internal builder class
which sets the name or surname
but what if we want to write it in
native coupling things get super easy
because coupling has optionals
so basically with the optionals we can
just give default values and we don't
need to really use complicated builders
so in this case if we don't pass an
argument to surname it will be not and
if we compile this cut one-line coupling
into java we end up with a longer java
class and if you check the method so you
can see it actually there are more than
one constructors and basically coupling
is doing the dirty work here and
creating all the needed stuff again the
good the bad the ugly
thanks to optionals builder pattern is
not really needed in coupling optionals
are nice much easier to code but may not
be as self-explanatory as builder
pattern someone who has been using
builder pattern for a while or even not
for a while can easily understand what's
going on the code but optionals might
not be that clear if you not don't know
the parameter list and what you need to
set and the ugly part is if you need to
do really complicated stuff you may need
the builder especially if you eat some
libraries work let's move to structural
patterns I'm short on time so facade
basically hides the complexity facade
pattern is used in api's here is an
example which the sponsor of method
calls and it's very prompt to exception
things to that stupid line I put there
which will probably
throw an exception a lot so don't do
this at home it's just for their slides
and if we convert this to Kaplan
there's nothing special basically Curtin
is trying to just convert everything and
writing it in Kaplan doesn't change a
lot it's just the font size but still
shorter so let's skip facade is they're
just good for hiding the internal
complexity and making it easy to change
in future without breaking the client's
decorator so decorator is super super
nice they add behavior at runtime to
objects much more flexible and
extensible than in inheritance and
allows functionality to be divided
between classes with unique areas so we
have a pizza interface bass pizza which
implements that interface meat topping
rage' topping so how we use it we create
a bass pizza then toppings and each
topic at the constructor receives the
previous item so basically it's wrapping
objects over each other and are creating
the final object if we convert this to
cut line it's again much less lines
so basically coupling that's the same
thing but we don't need the additional
code and writing this in NATO coupling
doesn't really have anything more to it
so here we can see the Java two cutting
tool does almost all the work so the
good part is unlike inheritance with
decorators decorators it's very easy to
change the behavior without breaking the
legacy code and you can't really make me
say anything negative with the
decorators it's my favorite pattern
adapters so adapters are a great pattern
to use the
Jesse called and worked the new stuff
with the legacy Cline it's based on
delegation and wrapping so here we have
a very good example for travelers so we
have a you plug and us plug which has
different voltages and different
implementations so we create a voltage
adaptor which implements you plug which
can get a parameter of us plug and
convert it to you plug this is a typical
example of an adapter if we convert this
to coupling again it's not really a lot
of change it's it's simplified but
mostly much or less the same amount of
code and again writing this in native
coupling not really something that's
special to really change a lot so again
another pattern which we just convert
and move forward and the bad part with
adapters is if you use it you will keep
the legacy code forever behavioral
patterns let's start with strategy so
strategy is good for injecting the right
behavior for the right job it's easy to
change an eight new behaviors and works
great with dependency injection so this
is a typical strategy pattern example we
have an interface and two different
implementations which share the same
interface and a class which doesn't even
know which one needs to use will be
injected the right resource and the
behavior will dynamically executed if we
convert this to coupling again it's
a little
there's lines but much or less the same
and again coupling I didn't really find
anything to make it much more native
coupling again strategy is very easy to
implement and very good for adding new
behaviors but once you set the contract
it's over and you can never change it
let's keep comment since it's very
similar to a strategy and observer
observer is used in many frameworks and
it's also inside Java and Java EE as a
out of box solution if we look at the
classic observer observable Java example
we have a radio channel a publisher
interface and the new agency where the
new agency can have new observers and
will notify each observer when a news
item is added so if we convert this to
Kotlin again less lines and what we see
is if you want to write it in native
coupling there is something new called
delegates observable which returns a
property delegate for a real write
property that calls a specified callback
function when things change so again I
don't have much time to dig into this
but if you go to the link you can read
more about it and it's definitely less
lines of code and much more native
coupling looking style code and if you D
compile this you can see actually
Cottman is doing a lot and the bold line
here you can see there is a java class
called treat right property which open
is internally using the execute and make
things work
and you can of course might be using our
Xterra for observe observer and if you
convert a basic observer example to cut
lane it's again much or less the same
what you would expect not much
difference the only main difference is
using the emitter ideas and the
compiling it again nothing surprising
there is a parameter check and I think
that's all I'll skip to this and talk
about pendens injection which is again a
very widely used pattern but presently
not a gang of for pattern so it's also
called inversion of control if you're
not familiar with it go back and you'll
see there's a huge discussion of if it
should be called inversion of control or
dependency injection it's very it helps
you greatly in changing the
implementation or even behavior such as
injecting a mock object during testing
works greatly with strategy basically it
really helps to build real strategy
patterns it's available in many
frameworks CDI if there are any Joey
folks around spring juice play GlassFish
dagger and actually I'll also give a tag
or example so it naive Java example is
much or less like the strategy pattern
and the real thing is could inject this
code to this point so the injection
mechanism is actually the dependency
injection pattern so if we convert the
same code you'll see the same stuff from
the strategy pattern so let's see
something more exciting let's try dagger
with cotton
so Tigger if you're not familiar with it
it's a dependency injection framework
based on jsr three-30 it doesn't use any
reflection so it's considerably fast but
it's a little complicated if you're not
familiar with it so take a 101 digger
has cheese things so you need to know
the first one is module and provides
which make it's the mechanism for
providing the dependencies next inject
which is the mechanism for requesting
dependencies and finally component which
is the bridge between modules and
injections so this is the sample from
Daggers website so if you're interested
in in that you can go to the website and
follow from where I left so we have the
coffee maker which gets injected the
heater and pump and here modules acts as
a factory and component print reads them
if we convert this to dagger it's a
little bit cleaner code but again it's
not a huge change but basically the
interesting thing is everything works
out of box with just a simple conversion
so to wrap it up dependency injection is
super nice but it kinds of at the
magical execution flow if you're new to
it so it might be hard to debug soft to
summarize with coupling mostly it's a
bit easier to implement the method the
patterns and usually it's really less
lines of code and the Java to coupling
tool is really working amazingly and the
other way compiling cut into Java can
teach you really a lot to be honest most
of the coupling I learned was during
switching back and forth from Java to
Cutlass
and with that I can answer some
questions maybe offline and if you like
to talk go what if you don't like that
you don't need to work just forget about
it and there are some nice links one is
a cotton book the second is a talk from
Jake Wharton and third one is my book
beach is jye but covers all patterns in
simple java so thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>