<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Java 9 Module System Beyond The Basics by Nicolai Parlog | Coder Coacher - Coaching Coders</title><meta content="The Java 9 Module System Beyond The Basics by Nicolai Parlog - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Java 9 Module System Beyond The Basics by Nicolai Parlog</b></h2><h5 class="post__date">2018-03-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/pfXsQyToipM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so let's get going
my name is Nikolai I'll talk about
myself later maybe and because I'm here
to talk about the module system but even
with that I don't want to start right
away because they're breaking news that
I just saw this morning I just want to
share them with you they're not even
really connected to the module system
that's it I find that very interesting
and someone to tell you about them
before we come to the really news news
I'm going to tell you some old news you
probably know that Oracle JDK and open
JDK isn't quite the same thing there's
slight differences between the two and
Oracle is working on aligning them so by
the time Java 11 comes out Oracle JDK no
JD K are basically the same thing except
that you can't get Oracle JDK for free
anymore
from Java 11 on will all be limited to
either getting an open JDK ball from
somewhere or paying someone for for
supported version for example Oracle for
the Oracle JDK the interesting part is
that Oracle will ship their own open JDK
builds and you can will be able to
download them on their sites but they
will only do that for the current
version for the current major version so
you get 10 comes out then you get two
updates then 11 comes out then your two
updates then 12 comes out you get two
updates and I think you can see what
this is going the interesting part is
that it doesn't continue after 1104 11
is long-term support release you might
have heard but it's only long-term
support release if you pay Oracle for
that long-term support the open JDK
builds that Oracle ships will not work
he will not merge changes into open JDK
into the 11 branch after 12 was released
so that's not quite that new but you
need that 2 for the next one and next
slide so come if you don't read more on
that I wrote a weekly newsletter
specifically about this topic but now
let's get to the news so this morning
actually I think what happened yesterday
evening I didn't see it or could put out
a new what's called Java client roadmap
update so it outlined claims plans for
applets Web Start Java fix and swing and
if all you're doing is web back ends
then nothing of that interest you for
the next couple of minutes but I'm sure
you'll stick with me if you're deploying
it if you're developing a desktop
application though this should be really
interesting to you so first of all
apples are deprecated in Java 9 and
there will be faced out of java SE by
the time 11 comes
and JDK builds at Oracle ships and I
will soon pretty much anybody else will
ship will not conclude applets
so that's rather boring quite surprising
to me the same is true for web start and
knew it was deprecated in nine but this
is the first time that I heard that
Oracle actually made plans when to
remove it so the same let's just set for
applets is true for web start if you get
open JDK builds then from it from Oracle
then from September on there won't be a
web start in there anymore next we come
to Java FX so Java X was never part of
Java EE and that also meant that it was
usually not included in open JDK builds
is specifically not in orchids open JDK
builds so now that Oracle wants to align
open JDK an Oracle JDK people kind of
hoped that maybe we could standardize or
JavaFX and then we had could have JavaFX
in the open JDK builds but always going
the other way so they're removing a Java
X from their own JDK and there's no move
made by Oracle to include it in open JDK
bills or in the standard so that means
if your project you use Java FX from
September on if your clients use these
current versions you cannot rely any
longer that they actually have Java
effects on their machine there's an open
GFX project and you can download their
bills and some I think will do for
example or our clinics these even have
packages for open GFX so you can install
them into your JDK and so on that
machine but it might make things a
little more complicated have a quote for
you but also constants job of X or code
says it's working with interested third
parties to make it easier to build and
maintain job X as a separate
distributable source module after all
we've seen over the last couple of
months I think it's fair to assume or at
least to guess that this might be the
first steps towards totally removing the
investment into John effects and finally
maybe some like eclipse foundation
somebody else who's going to maintain
that and going to further improve it so
the second part is of course another
quote I made that up but to me that
seems like a fair summary when I found
most shocking actually was the swing AWT
part so again to quote or could we'll
continue developing swing and AWT in
Java SE 8 can of course pay for Java
it's
support and Java SE 11 this means there
will be supported by Oracle through at
least 2026 so in the past I took these
quotes like correctly like a declaration
of intention and interpreted some things
and I thought those would be fine well
the last couple months it it happened
there Oracle later put out a road plan
for example for the open JDK 8 updates
where you thought wait didn't I just say
something else couple months ago and
when you look closely they didn't
actually say something else a couple
months ago they said exactly what they
were going to do they just left out a
couple of bits so what it doesn't say
that this report is free so Oracle
supports it under 2026 can vary can just
mean they're supported on the Oracle JDK
that you have to pay for into 2026 and
also doesn't say that supports goes
beyond Java Java 11 so hypothetically
and this is a very I'm sure this is not
going to happen but hypothetically
Oracle could remove swing and AWT in
Java 12 and would still comply with the
quote that I gave you again I'm not
saying they will do that I'm sure they
won't but we should like the community I
think things should get it should be
more aware that maybe desktop
technologies in Java Java are slowly
going to be phased out and that we
should have to step up and find and
eventually pay someone to support or to
improve the development to improve these
projects okay so hold on now I shock you
into silence if you hear more breaking
news I usually tweet these when I find
out about them or write a weekly
newsletter I invite you all to subscribe
but now I actually want to come to the
module system unless you have questions
about this if you if you can scream loud
enough so I can hear you here you can
just ask No well okay that's fine let's
start then with the module system this
is a talk that's going to focus on
advanced features they're not advanced
because they're more complicated they're
just advanced because they're built on
the basics so I kind of have to assume
that you know the basics so hands up if
you ever want a module in for Java file
that's about half hands up if you ever
read about a module in for Java file
like in some blog post or book more
people that's great okay so I assume you
know the basics I go through them very
quickly
to make sure what I want waste too much
time with them and then of course the
modular system is huge and there's lots
to talk about I'll just pick a couple
things I'm try to give you a somewhat
complete picture but there are other
things that I have to leave out of
course and you can see the slides online
already if you go to slides or corner of
X of work so let's start with the basics
and the very very short version the very
short version is that modules
unlike jars have a unique name can
express dependencies and can define as
can define a meaningful API where in a
jar everything is just everything that's
public is public for everybody in a
module you can have things that are
public inside the module and other
things that public outside the module
all these information are defined in the
module in for Java file that I just
mentioned and the compiler will compile
it into motion for class file you put
that into a jars route and hence you
don't have a plain jar anymore but now
if your modular jar at runtime the JVM
will treat this as a module and there
you go modules there are two important
features and two important concepts
building on that so the first concept is
readability when the module system let's
say it'll JVM launches and see some
module declaration it will go through
these requires clauses and when module a
requires module B it will then let
module a read module B so this term
readability will come up repeatedly so
it's important to like to understand the
term and then at the same time the
module system will check whether
everything is there everything that's
supposed to be required everything
that's required is supposed to be there
and the motor system checks that and you
get reliable configuration then so you
get this feature this promise that it
looks like everything's there then the
second concept is accessibility so if
your module in this case that is
accessibility builds on these exports
clauses in this case the module B
exports a package and if you want to use
a type from the package then the type
has to be public and that's just like it
is before Java 9 but also it has to be
an exported package and you have to read
that other module these two things are
new and so these accessibility rules are
also concept that is new and this will
be that will come up repeatedly and this
is the feature you get from this a
strong capsulation which means as a
library developer for example you can
make sure
or that some parts of your API our
public and other parts will not be
visible outside your module and if
you're working on a work on a big
project a big monolithic desktop
application for example which has more
than a single jar during development
maybe a couple dozen or even couple
hundred jars then you can even use that
in your own project within your own
project to define for yourself for your
future self or for your colleagues like
this part I'm meant to be used outside
of this jar and this other part is not
so I think that's actually to me this is
a nice feature of the module system to
be able to have something visible
everywhere inside the jar but not
outside of it so you're not supposed to
see all the details here although on
this projector you actually can
and it's even outdated there are no
compact modules anymore I'm trying to
show you is the JDK got turned into
modules as well even more than these and
this is a so-called module graph you can
see Java based down here which contains
object and class loader and class or
kind of stuff so everybody needs it on
top of that you can see things like XML
or they should be logging somewhere SQL
is there well so you get all the
features that you're used from the JDK
are no longer in one blob they're
separate split into different modules
and of course you can write your own so
a little demo application that I usually
show and I will demonstrate later
features by referring back to this
application and they're like two three
months a year where it makes sense to
talk about F in kolender and
unfortunately we're not doing those
months so you gotta ignore that maybe if
you made an easter calendar for the
occasion this is a really simple
application we're gonna turn it into
modules just so you get a feeling for it
so the what works and what does a
calendar African learn I usually do you
get a calendar which has 24 sheets each
sheet knows its day of the month its day
of December in this case and contain
some kind of surprise which is interface
because Java we of course in the factory
so we're a surprise factory there and we
have two implementations one creates
chocolate one creates inspiring quotes
in each of these classes extremely
simple and the only somewhat interesting
code lives in the main class so to speak
which launches this which just creates
Chocolate Factory creates a quote
Factory puts them to a list
hence this list over to calendar which
has a static factory method and then
no by the drawer fluxed it builds some
quotes and some Czech chocolate
chocolates puts them into the calendar
and then the calendar can be turned to
text and you can print it to the command
line so it's like very very simple
application this is the most amount of
consecutive code they were finding the
entire thing except maybe in the
randomization so now let's create
modules for this and actually you could
go different ways I just decided to go
this way because you can demonstrate a
couple of things I created one module
for surprise surprise factory because it
looks like kind of like a nice API over
here I created one with both actual
factory implementations which is down
here that's another module and I want to
have one with the actual advent calendar
that's all with the calendar over here
and then Advent contains the main class
so these are the modules I want to build
that means I have to create four jars
actually for this project and these are
the dependencies between the jars
obviously so these two factories
implement this this interface or they
need to know this jar and so forth and I
won't turn this into modules so as I
said you have to create a bill that
creates four jars and then you put in
four module declarations so from
surprise it's very easy you have you
don't have to require Java base earlier
said you always need Java base because
all these very important classes are in
there so the multi system is not forcing
you to always require Java base all the
time so I don't have to do that and you
only export the one package which
contains these two interfaces and the
calendar is quite simple as well
requires this module and exports another
package and factories just the same you
can see where I'm going with this Advent
is a little more complicated because
requires these other three modules
what's interesting here is that doesn't
actually export any package because it's
the it's application itself it's not
nobodies planned to call into the
application from the outside so doesn't
export any packages well there you go
now I know nobody builds things on the
command line I didn't either until I met
the module system to experiment with the
module system I can only recommend you
use the command line directly because
build tools like I usually used to say
that maven one third of the things that
your motor system wants you to do it
just does automatically out of the box
another third is kind of complicated you
have to fight maven a little bit on the
way and the last third you sometimes
just can't do it it just doesn't work
with amazing or greater
so if you want to get to know the module
system it's better better to use it by
hand and then later try to figure out
how to make your build system do this or
do the right thing and what we're doing
here is we're building all these modules
at once because we use a new feature
which is a module source path you just
tell it I want to saw all my sources are
in the source folder and I want to build
the module event and then it goes down
our dependencies other three modules so
I'm going to compile these as well so
then you get all the compiled classes in
the follow classes then you still have
to jar them individually
repetitive an interesting thing is for
the Advent module itself we can actually
define the main class here you would use
that usually do that with a with a
manifest but now you can tell the model
system directly this is my main class
and then if you call it like this you
say look this is the folder with all the
modules in there please start the module
Advent then again we look at the module
Advent we'll see all the requires
crosses we'll check that the modules are
there we'll build this this module graph
and we'll eventually call to the method
so into the main method of the class
that artifact defined here and then the
thing launches okay that were the basics
now I hope I didn't tell well if you do
know the basics I hope you kind of
followed along if you didn't know the
basics I shouldn't have told you
anything new so now when I go into into
a couple of different things that you
can do building on this on these basics
the first one are transitive
dependencies so regarding transitive
dependencies I would say not all
dependencies are equal so most
dependencies that you define you will
use within the same module so for
example need a mutable list so require
guava and use it's immutable list but
you can also use a mod modules class on
the boundary of your own module so for
example you could return an immutable
list from your public API and transitive
dependencies are about to let robot play
about the situation where you expose
your dependency to users so let's have a
look at this example from earlier we
have the surprise module here and the
calendar uses it the thing is that the
calendar has this create method here and
it takes a list of surprise factories
what that means is in order to use the
calendar module I have to read the
module containing surprise factory so I
always have to read surprise so for
everybody else anybody else wants to use
calendar I have to read the surprise
module as well if I don't if I don't
read the surprise module I actually
can't use the calendar module at all so
how would I find out about this the hard
way would be trying error I just try to
use a module and then it fails and they
find out why it fails and then I require
that other module and then so on and so
forth that won't be very nice so you
don't have to go this way instead what
you can do that a module can depend on
another module and can add the keyword
transitive so that doesn't actually
change anything for a and B a reads B as
usual nothing changes here but any
module reading a we'll also be able to
read B so that's why it's called implied
readability it implies the readability a
implies the readability of B so that
means because it for any module to
access the types in B it needs to read
the module now it gets that reads edge
for free so in this specific case would
say calendar requires transitive
surprise and that means if a trend uses
calendar
it reads calendar then also
automatically read surprise and they can
just start using it right away there are
some considerations when exactly to use
this feature and when not to what's
going to go into that here but what I
want to show you a couple of further
applications that you can do with this
because in the beginning of it sounds
like a rather specific and somewhat
benign feature okay I can imply
readability and some other module but a
couple of nice things you can do with it
the first one is you can create what's
what would be called an aggregator
module you can say for example huge
application with dozens hundreds of
modules but anybody who uses this one
sub project so this one part always uses
these three modules like it's like 90%
of the use cases where someone uses this
one module at all is also going to use
the other two modules all the time so
why don't make it easy for them you
could create a module called advent
calendar which requires transitive these
three other modules and
nothing else it doesn't contain any code
it doesn't do anything it's just there
so that I can require at pad calendar
and then I can read all these other
modules for free it would be like kind
of that so it's it a grades the
functionality of these other three
modules earlier I told you on this big
module graph that there were these
compact modules are not there anymore
the compact modules were aggregated
modules there's also a module called
Java SE it's also also an aggregator
module it just requires all the job all
the modules that make up Java is e so if
you want you can require java SE and
then you get the entire jdk more so all
the Java C modules for free so that
wouldn't have to require individual
modules I'm not recommending that I'm
just give an example of where every
Gator modules come up you can do other
things with this as well so with modules
it's a little bit tougher to refactor
code specifically if you ship this code
and other people depend on it that you
have no control over so when you have a
jar and you split up a jar then usually
it's not that much of a problem because
if the giants up on the class path
nobody really cares whether the code is
in that jar in that jar as long as its
present on the class path everything
just works this will not be the same
with the module system if you ship a
module and then later decide to split it
and you remove the module with that name
then everybody depending on that module
with that name will get either compile
time or run time errors because that
modules with their name is not there
anymore because you split it into other
modules what you can do then you can
have the UH the old module and turn it
into a Internet era Gator module so
let's say we used to have a module
called factories and now I decided got
rather huge you want to split it up into
a factory or API and a factory door
chocolate and a factory door quote
module then we can keep the factory's
module and just require transitive these
are three and that means all the code
out there that requires this module now
can also see can still see the
functionality because it's an even
though moved into a different module
that can still read that module so that
might make sense if you're shipping a
library or framework but it might even
make sense if you have to refactor a
module and you've in the own application
it's used like in a hundred different
places and you're not ready to replace
all the requires with a necessary
individual ones
for example maybe the one maybe this
hundred uses of factories some of them
were just used to one and someone just
use the other so you don't want to go
refactoring all these modules at once
could be a lot of work you can create
this aggregator module import
deprecation annotation on there and then
you can remove it over time you could
also go the other way you could merge
modules with this you could say I have a
I find out that calendar factories and
surprise each of them it just contains
one or two classes that's it's stupid
it's just like it just adds too much
overhead why not collect all of them
into one module you could go the other
way around you could create this new
module which contains all the code and
then the old ones they are empty now and
they require transitive the new one so
then everybody who's read who reads
surprised now also reads advent calendar
and hence can still see the code in
surprise important caveat here earlier
when I just dependent on surprise I may
be just dependent on the John with a
single class now that all this went into
advent calendar now might depend on a
module which has like hundreds of
classes so and there could be some other
effects like service registries they
were going to look at later which might
have other impacts so this is a little
more of a dangerous move you have to
look closely into the use case at least
test closely to make sure this doesn't
impact your stability you could even
rename or just this way so all these
things we have to talk about this more
in more intense system than with jars
because again a jar just a container you
can just rename the jar nobody cares but
renaming a module is much like renaming
a package like it like your users will
notice and you can use replied
readability to rename them rename a
module and keep the whole module around
with the old name again it's just the
whole module contains just the module
declaration it just there so if you used
to read this module now you can also
read the new module which contains the
new code sorry which contains the same
code but a new place so in summary if a
requires transitive B then a reads B as
before nothing changes but any module
that reads a now also reads B and you
can use that that's a primary use case
you can use that to make an API
immediately usable even though it
exposes other modules types in its own
API but you can also create aggregator
modules and you can
helps you with your factoring but when
you split merge arena modules and a
lotta blog post about that we're going
to a little bit more detail you have
questions about implied credibility so
Bey you can ask questions now or if you
don't want you can ask questions later
when you meet me and when you see me at
the conference just talk to me yes
so the question is whether there's any
impact of the module system on the
existing code repository so I guess you
think about maven central or something
were there any surprises yes they are so
for example one thing that the molle
system does not allow is to have two
modules that share the same package and
if that happens with jars that's fine
with modules it's not and in those cases
if those jars get turned into modules
you can add and up in problems but the
basic idea is that nobody's supposed to
just turn the jar into modular and do
nothing else and ship it so it's
important when you turn something into
module to seriously think about what
you're doing and you should be aware of
the shortcut on much shortcomings but
the additional hurdles that the multi
system put in and whether you're running
into any of those or whether your users
will run into any of those I have a big
talk and also blog post about
compatibility but that's not this talk
unfortunately so I can't go into details
but you can ask me later I will happily
go tell you little more about it
oh yeah in the back
so questions is there a change in
performance when you use modules so
comparing Java 8 in Java 9 launch times
is really tough because so many changes
went into Java 9 right it's really hard
to track them down my personal feeling
is that Java 9 boots a little bit slower
than Java 8 having we have a large
application which consists of 400
modules normal sorry jars plus like our
jars plus like 150 something
dependencies it boots in like about 15
seconds on Java 8 and it's about 16 on
Java 9 but on Java 10 event picks of 215
so the module system a little bit of
overhead but it also improves a couple
of things for example it now knows where
exactly to lower classes from if you use
modules and not just plain jars so yes
the module system add a little bit of
overhead but it also opened up room for
optimizations and I guess they're slowly
being realized over the next couple of
releases so I wouldn't expect any big
impact in the mean it could of course be
that you have a very specific project
which could you know could be of the
outliers could benefit a lot or lose a
lot in the end you just have to try out
yourself also Java 9 comes with the new
makes the g1 garbage collection the
default so if you do not configure the
garbage collection you're now getting
different garbage collector which could
also very much change the performance
behavior of your application okay let's
talk about optional dependencies when
when you talk about dependencies you
have different kinds one of them you
just need to function right as well
those are like 95% of the dependencies
you just need that class you need those
not feet notes those features if those
features aren't there there's no way for
you to run your application but there
are other kinds as well maybe you want
to use that feature only if it's there
but if it's not there you also fine you
just find another way to do your thing
and the last one is maybe you're
creating a library that integrates with
other libraries or frameworks integrates
with other libraries and the assumption
is let's say mmm I'm a library I sorry
I'm a framework that integrates with
guava then the assumption is if guava is
not there then nobody's going to call
the farmer specific code so I'm not not
depending on guava because I need it
I'm just depending on whether like if
you depend on it I can
you with it but if you don't then I
don't might either so these two cases
are not really well mapped unless you
come to talk about optional dependencies
because what we discussed earlier
yes let's say we have a depth in code so
a library may be absent from some
deployments maybe it's a licensing issue
or whatever so you have some deployments
with that library uncoupled without so
at this example here let's say we have
surprise factory implementation each has
its own module but my idea is that maybe
sometimes I don't want to ship all them
all the modules with all the factory
implementations so that would look like
this right
Atlee needs calendar and at what needs
surprise as before but this two ones I
don't really want them like I don't
really require them if they're there
that's fine if they're not that's also
fine and the other use case is what I
said we're about the about the library
integrates with other libraries and just
wants to provide these functionalities
if the other libraries present if it's
not present the assumption is nobody's
going to call into my library so let's
say we create a library called uber lip
which is not the damn company who took
the damn name but it's like uber you
know so it's the uber lip or the
greatest lip ever and it provides
visibility functions for various
libraries let's say for these ones so
anywhere with Cyclops and waiver and
comments lang and guava and then once
again I don't really require these the
idea is if you use comments Lang then
uber lip can help you but if you don't
then that's fine too the problem is that
what we learned so far about requires
clauses request directives doesn't
really help you with that any at all so
what we learned earlier is I want if I
want to see code in another module I
have to require that other module if I
require that other module the Morrises
will make sure that the module is
present at runtime at compile-time and
run-time and if not it will fail loudly
so that that's not a good situation to
be in
so I cannot really describe like if this
module is there I want to use it but
it's not there I'm fine too that's where
static comes in you can use instead of
requires you can use require static so
if a require static B that means at
compile time the module system will just
treat this as if a requires B B has to
be present and if it doesn't it
complains which makes a lot of sense
because if I want to integrate with
guava
I'm most likely going to compile against
wireless types so then of course I would
require guava to be present at compile
time but at run time things are
different if B makes it into the Mojo
graph then a will read B but if he
doesn't make it into the module graph
for example because it's not present
it's just not on the module path then a
were just long add replication will
still launch and a won't a sorry ace
present won't and force B's presence B
can be absent and we can still launch so
let's give you an example what I said
earlier the advent calendar and the two
factories thing let's say the module
Advent now requires chocolate and quote
factories but it requires them
statically static in the sense of not
dynamic like at runtime but static at
compile time maybe not the best term
think to try to reuse the keyword here I
guess I don't know kind of make sense
but maybe not the best term anyway so
the point is require static factory
chocolate means at compile time
chocolate has to be present at runtime
it may be absent which means that at
runtime I really have to figure out
whether it's there or not and the best
way to do that all the different ways
you could technically just check whether
some specific class that it's in there
whether it's present or not and I think
it's better to write him a function that
checks whether the modules actually
present and that function is the first
tribe that finds was pretty simple you
can ask the module system like look
these are all these modules is their
module with that name and will answer
you and there are some corner cases that
make it more complicated but the by and
large is very simple you just ask the
module system is that module there and
so what I'll do here is when I want to
create a chocolate factory
I will check whether the module is
present and if it's present then I can
do this and if it's absent I return an
empty option so the thing is if I don't
put in this check and I just do this
then of course I will get a class not
found exceptional class not found error
when the module sorry when the shop and
more just not likely actually there you
have to have this check in there to make
sure if it's there then create a factory
if it's not there well then you get back
an empty factory and presumably the code
calling this is fine with factories
being absent that was the basic
assumption
now this is how our bleep would look we
also require static all these
dependencies here the interesting part
is we will likely not check their
presence because once again if someone
doesn't use guava he's not going to call
us giving us some type from guava right
so the assumptions if we get called is
if a guava specific part of our library
gets called then most likely guava is
already present so we want to check
ourselves if one would not be present
the code calling us would already have
failed so there would be no runtime
checks there so to repeat with opto
dependencies you use the keyword static
after requires and if a requires static
B B must be present at runtime but sorry
a compile time but can be absent at
runtime and if you if you want to use B
if it's there then you have to check
whether it's there at runtime if you
just want to use B someone hands your
time from B then it off check it all
you can rely on code before you would
have having failed and again our blog
post which goes into a little bit more
detail so now we have services let's see
just on a little later I still got a
little time great so let's go into
services Oh unless you have questions of
course do have questions about optional
dependencies no this feature was
requested rather late I think in within
the JDK this is there is no use case for
this but the mailing list complained
about requiring requiring this feature
for the ecosystem yes so the question is
maybe in this case can I be like I need
these at least need one of these no you
would then then we would get a runtime
error but the ended what doesn't make a
big difference whether the module system
finds out like you only have you have
none of them even you although you want
one of them or you check that yourself
that's the first time you get called so
let's talk about services and let's talk
about your pendency inversion so
everybody into into architecture and
design patterns like this
for you I showed you this code earlier
there was all these these dependencies
earlier there is a surprise API back
here and these two are implementations
of the API and then I said that applet
needs to require factory quotes so I can
create a quote factory and also needs to
require this module so I can create the
Chocolate Factory I would say that this
is more like a low-level concept and
it's an implementation of an API and
this is a high-level concept and I still
have to depend on it specifically if you
would not think about modules but think
about classes this would mean my class
needs some interface but I still
instantiate that concrete implementation
myself in the constructor for example
and we usually say nowadays don't do
that have someone pass in the the
implementation that you need at runtime
or any implementation in it actually so
don't create yourself have someone else
let someone else do it and this so if
you talk about API then generally means
the consumer of an API and the
implementation should be decoupled both
of them should know the API but the API
and the consumer and the implementation
should not know each other in this case
you saw that the consumer needs to know
the implementation and then there is a
service look locator pattern which is
one way around this the service locator
pattern you have someone in the center
where you can register away can
implement us can register themselves
saying I implement this API and
consumers can go to the same registry
and say look I need the implementations
of this API can you help me out and this
service locator pattern is exactly
what's implemented in the in Java
interestingly enough its implemented
since Java six you could already do this
before but the multi system makes it
more prominent before that you have to
put in files into your jar folder in the
right places with the motor system
becomes a little more prominent and the
idea here is that the models declare
which services they use the other ones
declare which services they provide and
then you have the service log a service
loader in them in the center as the
service locator from the pattern and
then you have to go to the service
loader if you want to note some services
a name suggests suggests so you have a
module a that consumes
servus so use the users directive and
then here you have the fully qualified
class name so this now is not a module
it's not a package it's a class a uses
this some service and then you have also
some service if it comes from another
module you also have to require that
module that module containing the
service definition you would of course
have to require that it could also be
inside a that's not uncommon
and then the provider will say I provide
that service with this concrete
implementation and then that if that
type would implement would implement
that interface so the modular systems
convenient service doesn't have to be an
interface it can be a class I think even
the final caste which makes no sense at
all but usually it should be an
interface so that now in this case both
of them know that service interface both
of them have to know the module where
the service interface comes from but
none of them have to know each other
that means that a never sees these
providers which means for example if you
add a provider you don't have to change
a agency's the API and then the module
system will pick up all providers so in
the beginning one does more than JVM
launches when it looks for all these
requires clauses and whether all the
dependencies are there it will also look
into these users clauses it will see
that module a used the service and they
will check which other modules provide
that service and all the modules
providing that service will also be
pulled into the module graph and then a
can just do this to get this to get the
instance at runtime so in our specific
case we have the applet module which
requires the surprise module because it
contains this API and we say we use this
surprise factor interface and then
chocolate and quote factory modules they
just say we also require the surprise
module because it contains the API but
we provide this interface with these
classes so the module graph looks like
this and as you can see now the errors
have been inverted this arrow no longer
uses these specific implementation
modules instead just depends on the on
the on the API module and then you have
to call the service loader at runtime
this quarter service model looks like
this if you create if you I remember the
code that I showed you earlier where in
the main method would create a Chocolate
Factory and would create a create a
quote Factory would then put them both
into a list and hand over that list
instead we do this now we go to the
service lower until the service door to
load the surprise factory class service
implementations and then you get a
stream and then you have to do a couple
of things but in the end we get a list
of these implementations and then we can
the rest is as before but what's gone
now here is the debase the reference to
the specific classes of chocolate
factory import factory so in summary you
can decouple AP icons you Murs and
providers by having the consumer use the
service and by having the provider
provide that service with an
implementation and then the module
system plays a role service locator in
the center that you can ask for
implementations questions about services
yes
so the question is if you have two
different implementations of that
service then like here is like here you
get both implementations back so now if
you want to figure out is this the right
implementation maybe you're looking for
something specific you would have to
implement that on your own on that
factory so except and actually the thing
while you get a provider here which I
just kind of like went past you can ask
this provider for example for the
annotations on that class yeah hmm
exactly but what might happen is that
you want to say I actually just need one
in this case we want to have all the all
the factories for our surprises that we
can get right but you might be in a
situation and say no no no I just I just
want to find the one provider that does
the thing that I want and they're
different ways to do that one of the
ways is that you put annotations on the
providers which you can check here even
before instance II I think that because
that's a very very lazy process you
could also have the surprise factory
have some method for example you could
think about this the Java SQL module
does this 4x SQL drivers so you could
basically we can say okay alone all the
drivers and each driver AG hand of the
connection string and be like okay this
is a connection string can you handle
this and then maybe the JDBC sorry the
test flight driver will say no I can't
but the Oracle driver would be I can do
this and then you pick the one that says
yes so if you want to have some some
logic in there that that picks the
service you would have to implement it
on your own which i think is good
because it means you can implement it on
your own and you're not relying on the
module system having some predefined
structure but there was a second
question I think yes no you get no
certified you get back whatever yes so
that also means for example if you have
a default you can also maybe you have a
default implementation like I want to
look whether that's a good
implementation out there is that's not I
fall back to a simple default
implementation then it's you should
maybe not do this exact process because
then you would have to literally define
your default implementation what I would
do is I would stream to all the external
services and if I would not find the one
that I'm looking for there then I would
just create the default one myself
more questions yes yes
so what jars what you would do you would
put all the information that's basically
wait a moment
oh yeah so the information that goes in
here you would have to put that into the
jar not the one up there you would not
have to declare that he uses service but
if you provide a service then I think in
meta enough there's a folder services
and then you put in a file which has
this name and then lists each
implementation on a single line and then
you go to the service lawyer and ask him
to load so that features already there
and as I said that's how the SQL module
now it's a module about how the SQL
portion of JDK 8 for example used to
locate driver implementations it used
this exact feature and I think log4j
uses it so this is a it's a thing that
exists but it's not a very common thing
because not very easy to use it's not
very prominent you kind like it's hidden
somewhere you have to create this extra
file and now you already have the module
declaration anyway so now it's very easy
to start using it and I can only
recommend to look into it if there are
no more questions I will go to qualified
exports all we could do instead of going
through more details we could go to jail
Inc which is also a nice feature in
which we are otherwise not going to look
at so you might have heard about this
you can create you can create your own
runtime images put J link and one of the
arguments that Oracle is pulling
regarding the the removing web start and
removing applets is basically the time
where you have a JDK installed like
everybody else JDK installed and then
you just ship the jars that time is over
what usually happens now if you have a
big desktop application ship it with the
JDK included I'm not sure how much I
followed an argument but if if that's
argument that's made and you need
something to make it easy to create an
image that contains not only your code
but also all the things from the JVM
that you need and jailing is that tool
so remember this huge graph oh sorry
there's a little egg here well although
JDK got modularized you can actually use
this you
can the two things you can do let's
start with the weather you just created
JDK installed just for you or just for
your application so if you know which
modules your app uses you can use
jaidev's to find out then you can create
an image with just these modules and to
use that feature your application
doesn't even have to be modules your
application can be just in plain jars as
before you just run on Java you just run
on Java 9 but you can use jaidev's it's
a command line tool to find out about
which modules you need and then you can
use jailing to create that and this is
how you would do that good call jail in
command and would say I want this output
in the folder JDK and then you have to
show it where it will find the modules
that come with a JDK in Java 10 you
don't do this anymore when Java 9 you
still have to and then you say ok and I
want to add these modules these are the
specific modules that I want in my image
and this is the smallest possible image
you just at the Java based module and
then you get get something you get the
JDK folder this is the one here and if I
go into the JDK /bin slash Java list all
the modules you contain then usually get
a huge list of like a 150 or something
modules here we'll just reply just
contain Java base not exactly like this
but and the order in this case actually
works other cases you might see services
here as well but in this case you will
just get Java based in here and if you
need not just Java base but your
analysis of your application found out
that you need like a dozen modules then
you just list a dozen modules here and
then you get a runtime image which
contains just the modules you need and
their dependencies of course so it's not
just those 12 modules it's the 12
modules plus everything that they need
so let's say you have a back-end which
uses all of these features you want we
would then say get it crated up in JDK
folder I create my jeddak male image
which a link this is where you find all
the modules and then these are the more
inside I just put these Comanche twice
to make it easier to read
you can list all the matte one so you
can use app modules for every single one
doesn't matter so let's say we use Jack
style yes and some XML stuff and this
was Jack's B and SQL and of course we
lock something so
these were they like six five modules
and then the module system will
determine which other modules you need I
recreate you an image with just those
modules although in this case it could
be a lot of modules apparently these
ones not oh yeah you get Java desktop in
your Java desktop is huge it contains
all of a wtn swing so it's looks more
like karada huge so you get a still as
large as the usual injury or jdk that
you would run on so that was the first
part where you create an image for your
application to run on now you can create
an image with your application included
but for that your application does
actually have to consist of modules
there are a couple of migration features
which allow you to use the module system
even though not all of your dependencies
are modularized it's called the
automatic modules or called automatic
modules that doesn't work with Jaylin so
you have to have your code and all
dependencies need to be motorized for
this to work this actually makes it
easier because now you just say I want
to create my image in the output in the
JDK folder here are the modules from the
JDK here are my modules and my bestest
modulus Edwin's I want to start there
and because serve is not resolved
automatically at the to services as well
and then in this case my modules are
also all included into this into the
image that I come up with and then I can
just go JDK /bin slash Java launch the
module event and I don't have to give it
another module path because my modules
are already in there so I'm done so if
you use docker images for example this
could make it easier to package
everything you need more than you need
but everything you need and make it
launch with a single with a single
command this how to create a launcher if
you want to you can just say launcher
and this is the name of the launcher and
this is the module and maybe the main
class and then you get even a binary in
Java and JDK /bin which you can launch
okay a couple more options summary we're
gonna jump over because times out I
promise a little bit but my self my name
is Nicola and I'm currently writing a
book about the module system I'm done
with principle writing and finally
finally it's going to go into print you
can have a real copy from June
but you can also already have a digital
copy right now which contains I think 13
out of 15 chapters I read a block I
recently started a YouTube channel not
smart there yet but more will follow
a set you can follow me on Twitter and
yeah if you by the way there's a
discount code if you use that discount
code you get the book cheaper and you
make me a little bit poorer no so yeah
thank you very much so as I said if you
have any questions just fight me on to
conference just whatever I'm doing at
the moment just interrupt me and ask me
something if you want to buy a nice
conference</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>