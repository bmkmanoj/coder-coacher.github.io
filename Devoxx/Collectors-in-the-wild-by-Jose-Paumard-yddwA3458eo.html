<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Collectors in the wild! by José Paumard | Coder Coacher - Coaching Coders</title><meta content="Collectors in the wild! by José Paumard - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Collectors in the wild! by José Paumard</b></h2><h5 class="post__date">2017-11-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/yddwA3458eo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">ah I think it's time to begin now well
hello everyone welcome to this talk
characters in a while thank you for for
coming I just learned this morning that
that we were live on YouTube so hello
also to the million people watching us
live on YouTube so that's 1 million and
roughly 500 hundred not hundred thousand
people watching this code characters in
a while this talk is all about
characters first question we may ask
ourself is why should we be interested
in characters in fact character is not
an API in itself week I'm going to talk
about the character API but if we check
the JDK we more talk about the stream
API and not about the collector API it's
just a sub API from the stream API and
we could say that it's kind of left
aside there are books about streams
articles about stream in fact if you
check YouTube for a strain tutorial or
the kind of thing I did that last week
and I found 7000 tutorials on the stream
API more than we can watch in a lifetime
of course and only less than 500 about
only about characters with the name
character tutorial so yeah it's kind of
left aside what why should we be
interested in characters I think I think
there are many good reasons for of that
and this is this is what I would like to
talk to you about this this afternoon
it's in fact a very powerful API maybe
not as easy to use and to understand as
the stream API but basically everything
we can do with streams we can do it with
collectors in probably a more powerful
way and this is what I would like to
talk to you about today my name is Josie
I I live in the Paris
I work as an associate professor at the
University in Paris and I also have
different open-source development
activities and I work as an independent
contractor also in a Paris area
I'm Java champion great and I've content
on several several things on the
Internet including github SlideShare I
will publish the slides of this talk
probably tonight or in the next
following days and YouTube where I'll
try to to to keep a list of the talks
have given everywhere in the list in the
in the playlist on YouTube I know you I
also have courses on per our site and I
also write articles in Java magazine
among among other things all right if
you have questions or if you want to to
comment or whatever what about using
this Twitter hashtag I know that do all
those rooms are really big and the
people on YouTube they won't be able to
show up in the room to ask questions so
if you have questions if you use the ask
this hashtag
I will do my best to to monitor the this
hashtag even in the next few days or few
weeks and well on that chat with you and
so the answer the question of the
comments right so this is this is a
first collector patent I have a list of
movies basically I stream it flat map to
get the actors correct using a grouping
by as the function identity counting
then taken three set dot stream take the
Max and get a result this is the typical
collector pattern were using when you
are just writing collector stuff it's
not necessarily very readable not
necessarily very maintainable in the
long run it's not that hard to write
once you'll get used to the API and what
wants you you understand how it works
but rereading it to modify it or
whatever might not be that easy and this
is a simple pattern this this code does
just a simple thing very soon you can
write much more complex code like this
one
basically this is one line of code if
you check this an only one semicolon at
the very end of it finished with a get
because in fact it returns an optional
so the gate comes from the optional this
code is is both how to write and very
very hard to read I have only one
comment about it which is a quotation by
Brian Goods that you probably know do
not give bugs a place to hide right and
I think that in this kind of code there
are many many places where bugs can hide
so yes it works
no don't write this kind of code it's a
very powerful API even if it's very easy
to write unreadable completely
unreadable with it and this is picture
time sorry and sorry for the guys to
YouTube thank you thank you very much
have a good day all right so it's very
easy to write unreadable code with it so
it's part of this talk to try to show
you how to make this code readable
alright so let us quickly browse through
the agenda first I will make a quick
overview of the stream API who is very
who knows the stream API very well in
the room please yeah that's a fair
amount of people thirty percent and who
never wrote any kind of stream code in
his life I'll still a few hands write
blessed less than a person your age I
did you all right fair enough so and
then we jump in the collector API
because this is really the main topic of
this talk we are going to use existing
collectors and see how we can extend
them how we can should tweak them and
stuff like that how we can make them
readable this is an interesting topic
and then we are going to create new
characters and new characters by using
the available API and also by creating
API API is basically to compose
characters which is I think one of the
interesting things that we can do with
characters so yeah first of all the few
words on stream so as you may know the
stream
is obvious this is a crash course on
stream this is a deep dive last two it
was called the university session so I
guess we would have beginners in the
java language in it so I kept this idea
of going from from the beginning so so
stream is a basically an object that
connects two souls we can define
operations on the stream there are two
kinds of apparition intermediate and
terminal operation we're going to see
examples of that some of the terminal
operations may be characters not all of
them there are others and a collector as
an object can take more collectors as
parameters we can kind of nest
collectors one in another using the
downstream character mechanism that
we're going to see so a streamer is an
object that connects to a source of data
and watch the dataflow flows through
itself there are no data inside stream
this is very different from a collection
object collection object think of an
array list or a set they are objects
inside the collection it's not the case
in the stream the stream is basically an
empty object the statement I like to
make is that every kind of treatment
that we every kind of processing that we
can write with the stream API can be
written in that way stream that collect
and pass a collector as a parameter and
this is what I'm going to show you today
why is it interesting we may ask because
if we can do that then this character
can be taken as a downstream character
for further processing this this is
what's what's behind that on stream we
have intermediate operation the first
one of course is the mapping operation
take subjects of some kind and returns
object of a different kind
think of a person and the name of this
person the second intermediate basic
operation is the filtering operation we
take a stream of objects and we're going
to remove elements from that stream
because they do not match a given
predicate that we give as a parameter so
here we only keep the blue squares on
this nice little example and the third
operation basic intermediate operation
is the flattening operation
with the flat map method think of
objects that have relationships in the
in a sense of one-to-many relationships
so here we have squares and each square
has a relation to triangles the
flattening of the stream in fact will
create a stream of triangles from all
the relationships with from from all the
objects in relations with the squares of
the of the of the inside stream of the
upstream let's call that so all the
objects in relation will be flattened
into one big stream one after another if
I have for instance a blue square with
no triangle in relations to the list
other the relation is empty then it is
going to create nothing in the
downstream right and this is a mechanism
that we are going to use later in this
in this talk so those three operations
map filter and flat map I told you it
was fast right systems down they do not
need any kind of buffer to work for
mapping I take a person get the name of
that person it's just straightforward
for the filtering is the same and for
that map is the same it's not the case
of all the intermediate operation
defined on the stream API for instance
if we take the sorting of element we
have a sorted method on the stream
interface which just salts the element
of it you see that to sort the elements
properly we first need to see all the
elements to put them all in a buffer and
then we have them all saw them and begin
to produce the result so this stream
object does the sorted stream has to
have some kind of internal buffer to to
to keep all the objects it comes it's
consuming and the same goes for the
distinct operator the distinct operator
with all will only let through the
object that have not been seen yet if an
object is seen twice it's not
transmitted twice it shows only
transmitted once so III need also some
kind of buffer inside that stream to
keep track of the objects that have been
seen
right so both those operation distinct
and sorted need a buffer to store all
the elements from the source so they are
different from the from the map filter
and a flat map and so they fall into two
categories the first one I call the
stateless operation they do not need to
keep track of any kind of state and the
state full operation that need a buffer
to work that need to keep some kind of
internal state of what they are doing
and I've got two other methods also
intermediate on the stream API called
limit and skip that will count the
elements so so this time is not a buffer
it just to counter that also needs to be
to be to be kept during the the
consuming of of all the elements so the
limit keep the end first element this is
very precise not any any n elements it's
only the and first elements of that
stream and the skips skip operation will
skip the end first element just the
contrary as as the limit operation and
that's it for the intermediate operation
now we got terminal operation operations
and the first thing you need to
understand is that only your terminal
operation will trigger the processing of
a stream so the stream will will begin
to consume the data from its source when
there is a terminal operation on it no
Tommy operation no consuming no data
processing mail whatever for instance on
this example I have a stream of movies
first type filter those the only the
movie released in 20 2007 now then I
flat map to get the stream of actors
that played in those movies so I have a
stream of all the actors that played in
a movie in 2007 and I want to get the
title and this will not work because
it's a stream of actors and not a stream
of movie all right
but since it is just a succession of
intermediate operation in fact nothing
is done in a stream the the map will
return immediately and no data will be
processed
if I want to really process data I need
to call the terminal operation on that
stream for instance for each method that
will print out the result here the the
title of the of the movie how can I tell
an intermediate operation from a
terminal operation there is a very good
trick for that even if a method on on
the stream API returns itself a stream
then it's intermediate and if it returns
anything else including void then its
terminal operation right remove the
terminal operation I've got a first
batch for each count max minner reduce
an and to array that will consume all
the data from the source of the stream
to compute a max for instance I need to
consume all the data from all of the
elements of that stream to find the max
of all this data i put the count in
light gray because there is an
optimization in the count method that
sometimes done does not consume any any
data to compute the result I will not go
into those those details and there is a
second batch of terminal operation which
are called by the way short-circuit
operations or match any match non match
find first and fight any that do not
need to consume all the elements of the
stream if I do stream find first give me
the first element that is a positive
integer for instance once I have one I
do not need to consume the rest of the
stream I can I can just stop this
consumption consumption and undo
something else so this is how the
terminal operations work and I also have
special cases on on those two methods
max min and reduce because they can
return instead of a result in the form
of an object or number whatever they can
return an optional and an optional is a
special kind of objects we are going to
see optionals at the one of the last
examples of this talk it is used to
handle the special case of empty stream
what does it mean to take the max of an
empty string well doesn't mean much so
it returns an optional that is going to
be empty you can see an optional as a
wrapper object
in fact and the difference between this
rap object and the integer rock object
is that an optional can be empty where's
the the integer necessary has an element
in it and by the way I put a link here
on a very good talk on YouTube now you
YouTube's guys
do not go and watch that in that link
that talked just now do that later by
use short marks with one hour only an
optional with all the patterns you need
to know one to understand to reduce
these optional objects right so let us
have a look at the first character
because of course one of the last
terminal operation I didn't talk about
is the collect method probably the most
seen pattern of the correct method is
the following get us stream here of
strings I filter I only keep this the
element that are not empty which is the
contrary what is written on the slide
put the result in a list and I'll get a
list of strings that are not empty
I guess that everybody saw this pattern
at least once yeah
alright that's almost half of the room
right and if I change this this code
just a little I can I can just return a
set instead of a list just by passing
the collectors does to not to set cell
to set objects right I also another one
the joining collector that will join all
all the strings of the stream into one
big stream with a separator we are going
to see that in a minute all right
oh yeah demo time fine
I love debug everybody loves live coding
yeah who doesn't like live coding three
people come on guys all right so I got
this this guy is it big enough yes I
think it's big enough right okay I set
up some code already because I don't
want to lose time writing easy code I've
got a list here I need to put my glasses
right oh I got at least a list of
articles taken from the web each article
is known
with his author here's another here's
another author here are two authors and
the title of this article here that'll
be good and I also have the the year
this article was published and I've got
to pull that in a text file and this
text file is like 120,000 long so this
is the total number of articles I have
in this text file and we're going to
play with this text file because the
stream API is about processing data and
well this is this is data this is not
just a toy example okay the first thing
I can do for instance is just so in the
background I got an article class
working with all the methods to decode
this this this text file and among them
I have a read oh that is just going to
read all the lines of this text file and
create a set of article and the article
in itself is just a plain Java Bean with
an inception year the title and an
article type that's one not going to use
in this example and there's also an
equals and hashcode method as any kind
of Java Bean we can examine the first
thing we can do is for instance take
this article create a stream of it okay
easy and count the number of elements we
have in it let us put that in a variable
and print out this variable great run
this code so we indeed have this amount
of articles like your hundred and twenty
thousand something like that we can what
I'm going to do with it yeah we can for
instance select the the first year the
view of the oldest article so since what
I want is a is a stream of of your I can
map this article in its inception here
so now I have a stream of nature and
takes the mean in that stream of integer
getting the comparable and since those
are integer which are comparable get
directly the natural order comparator
okay and since this is a mean it returns
an optional so I need to call the get
method on the optional class see this is
the get method of the absorb pass and
this will return the mini R loops of
that that file print out the result and
I think I've got a bug in this file
because the answer yes is 9020 so I'm
going to filter the article just to
remove the article which have a buggy
inception year so I just want to keep
the article with an exception you're
greater than nineteen run the code and
the right answer is the S naughty 35 I
can do the same for the max let us just
do the same for the max here I just need
to change here for the max and this is
the max here print the result and this
is this is going woops
yeah no great and this is going to give
me the result the fact is all this code
here can also be written using
collectors you see here I just called
terminal operation directly on the
stream API but I can also call collect
characters dot counting which is a
character okay on a minha I can also
call way to comment out this collect
characters that mean by
past the same comparator compat natural
order or is it I don't know comparator
natural order here and do the same here
with the max by I'm going to copy/paste
this comment out this max cope is this
and takes the max body and you see that
it works exactly the same it retailed
the same the same values the same object
etc so I have this kind of duality
between what I can do with these three
methods and the character and I can go
one step further if I have if I take
this article the stream of article I've
got very handy method called summarizing
int but it's only available on the
stream of numbers and in fact if I map
this I'm going to filter where yes I'm
going to do the same filter here so let
me just copy paste this right and this
time I'm going to map to int the result
with the same method by the way article
get inception year so instead of having
a stream of integer here I have an int
string which is not the same object and
all this in stream I have a summary
statistics object it returns an int
summary statistic object which is by the
way implemented with a character and in
this statistic object I have directly I
run this code again I have directly in
one pass over the data this is what is
interesting the count the sum the mean
the Max and the average of the elder of
the int I have in my stream just in one
pass over the data and even for this one
I have a collector for that let me just
write this here again correct and the
difference is that in fact with the
character it's even better you see I've
got those three summarizing int double
on longer method I'm going to take this
summer
since I've got a stream of an instrument
and least summarizing int take the
mapping function I have here as a
parameter and it returns the exact same
summary statistics oops did I do
so my statistics object let us put this
here statistic - and here so whereas
these summary statistics here is not
available
where's my mass here is now is only
available on in stream and not on stream
of T this collector summarizing int here
is a variable through the collect method
so variable on the stream of T so it's a
little wider as a as a use case to have
it so you see that everything I can do
with the with the stream API directly I
can also do it with with the collectors
API which is very nice I told you about
the collectors that joining we can just
do something with it what he calls dot
stream the collectors were joining only
works on streams of T so I need to map
this using a mapping function particle
that get titled for instance I'm going
to use a trick here to filter only the
article articles released in 1960
because I know that the only two this is
the reason and I'm going to correct
those in a characters that join in you
and pass a separator as a parameter this
is going to return a string directly
articles 19 sorry 1960 great
print out the result and if I run this
code you see that in nineteen yes it's
not exactly that in 1960 I have two
articles that have been released the
title of the first is the pernicious
influence of mathematics on science
world and degree of difficulty of
computing barrera
okay so this this joining collector that
works on a stream of string allows for
the joining of strings using using a
separator which is a which is nice okay
those were the example I wanted to show
you just now let us go back to the
slides so we saw our first characters
mean by max by joining we haven't played
with the two lists but don't worry we
are going to do that in a very few
probably one of the most interesting
collector most widely-used collector
beside the two this character is the
grouping by character the grouping by
character is there to create histograms
basically maps as histograms here what
do I do
I just regroup strings of character
using their length so if I take this
stream of strings of characters or apply
this grouping by the grouping by
character in itself creates a map right
this this is its job it takes a function
a mapper as a as a parameter which is
called the classifier this classifier
will be applied to all the elements of
that stream and and the type returned
will be the type of the key of the map
so since this string that length mapper
returns an integer the key of the map
will be while going to be integers well
that's one more picture time hello
Steven are they you should say to the
people on YouTube
okay Stephen chain everybody knows
Stephen I guess so yeah not only
photographer you do that very well but
you have other talents too all right so
the keys of the map are the return type
of this mapping function and when I just
do grouping by and ask this this
classifier as a parameter all the
elements of that stream which have the
same value returned by this classifier
will be put in the list will be gathered
I noticed this is how the grouping by
works so if I have a stream of the
following streams I've got three
different values for the length of every
string of characters so three will be
associated to the list of one to six ten
four four five nine five three seven
eight etc now the nice thing with this
grouping by is that I can pass a second
collector as a parameter to it called a
downstream character and this downstream
character will be used at the following
in fact all the lists of the values
values of the list so all those lists
are going to be streamed themselves
collected and this downstream character
will be passed as a parameter to this
collect call so this downstream
character acts as some kind of
post-processing of all the values of
that map so for instance if I want we
already used several characters
including the collectors that count in
so if I want to use all the if I want to
count all the strings associated of
length three in that map all I can do is
pass these characters that count in
correct sorry
it's corrected counting collector as a
downstream character and all the lists
of strings will be replaced with the
counting which is long it's not the size
and my map of integer non-listed string
will become a map of integers and Long's
and this is exactly this this kind of
thing that that is done I just pass this
string dot length as a as a classifier
and destiny and then these collectors
dot counting as a
processing right Oh
demo time again great I love demos I'm
going to change I'm going to yeah
I've got a got several files and all the
demos will be held in several files
let's get rid of this yeah
so I still have my set of articles and
what I would like to do is count the
numbers of articles per year that I have
number of articles per year this is the
map I want to create so this is a job
this is a histogram so this is a job for
the grouping by character so let us take
my list of article take the stream on
that collect the result correct
collectors dot grouping via the
classifier I want to reboot my article
per year so the classifier is just
article get inception year and if I
don't do anything this is going to be a
map of integer because this is the type
of the year and list of article because
this is what need to fix the import
right because this is what the grouping
by does okay and then if I want to count
the elements of this list I need to pass
the write down string character which is
in fact characters dot counting yeah now
it does not compile anymore because it's
not a list of articles I have here but
it's the result of the application of
the characters that counting on each of
those lists so it is wrong right and
this is the number of articles failure
okay
I can do with it what I could do with
this map this map in itself is with just
my histogram and probably what I want to
do is to get the year with the most
articles in it that so the biggest
biggest number of articles published so
what I need to do is in fact further
process this map I do not have a stream
method on a map interface so the trick
when I want to extract a max and the
stream API is very good at that it's
just to get the entry set this is a set
of map dot entry of the key and the
value of the map get the streamer on
this one and extract a max on that
stream I need to pass a comparator as a
parameter of these maps comparing I need
to understand that the elements of that
streamer didn't let me just do this real
quick but this is no variable you see
that this is a streamer of mapentry of
integer on lanza since this is a an
entry set dot stream data that I've been
calling right so on that streamer are
going to extract the max just get rid of
this one need to extract the max and
then I need to pass the key extractor to
create this comparator and since I want
to compare things with the long here
it's the entry that get value that it
should need to go to - here okay that
should be according now I call the a max
so this returns me an optional so not
optional I'm going to call the gate
let's do some formatting and this is the
best map entry of integer on longer
let's get which is the number of
articles per year this is in fact the
max number of articles per yeah
and if I run this code and print out the
result I won't run this code another
precious one I can see that in 2004 I
had 7600 article that have been
published so this is a very classical
way of processing histograms Oh get the
entry set then the stream then stream
and do something with it since I am in
the world of the of the stream API okay
now the problem with this way of doing
things is that I know that in 2004 I
have 76 hundred articles that have been
published but what I what it's probably
what it may be hiding is the fact that I
might have another year with the same
number of articles in fact what I got is
the first max and not all the maxes from
that if I want all the maxes let us take
this code again I got I got several
several ways of doing it maybe the most
obvious of the way it should be
could be telling I'm going to salt this
using using the long and it will work
and print out Forex for instance the
first ten and if I see the second Max
and I will have all the maxes but
probably the most interesting in fact is
not taking the max now from that stream
is do another collect and in fact invert
the map what I'm going to look for is
the number the list of the years with
with 76 100 articles published so in
fact is once again a job for the
characters that grouping by I need to be
careful because I am only on I am on
that stream right I'm going to copy
paste the type Here I am working on that
stream here so the elements of that
streamer are the entries here so the
grouping by that takes a classifier in
fact the element here is an entry and I
want to group by using the value of that
entry instead of grouping by the key so
here I'm going to do that and treat that
get value I do not wish to further
process the stuff so it means that for
all the number of articles I will have
the list of yours that so this amount of
articles published so this is my map if
I put that three oops
if I put that on a variable the type of
the match is a bit it's a bit ugly to
say the least because I grouped by the
longer and of course all the elements of
the stream that are the map and trees
here I've been gathered in lists so the
value is in fact this guy right but now
that I have this one now I can I'm going
to comment this out I can do the same
here take the entry set dot streamer on
this map ask the comparator and now what
I want to compare get the max by is the
max by key and not by value so get the
key here and now this is not a map I
have at a written type but a map dot
entry which is a the best key value pair
with all the years with this amount of
articles so it used to be max number of
article numbers and now it's all the
maxes can hold it all
Max's number of article per year print
out the result to check if I have other
mirrors okay this time I have only one
year which has this amount of article
but at least I am sure that there is no
other year with this maxes with with
this trick with this map in version I
have all the all the maxes on the
criteria I have I have established right
the problem is that when I kind of write
this kind of code the readability
it's really getting lower and lower
right who think that this code is
readable yeah
0% really and I must agree so we are
going to try to improve this kind of
thing ok let's go back to the slides so
we have the number of article der yeah
so this is how to create a map using
grouping by and then extracting Maxis
using this entry set dot stream and
further processing the stuff and if I
want to have all the maxes this map
inversion which is a nice trick to level
suppose now I want the number of
articles per alpha I have a relationship
between articles and authors so for each
article I know who are the authors of
that article and I want to do the
opposite I want to have the knowing one
author I'll I want to know not the list
of article but the number in the first
step the number of articles this guy
wrote so let us see that on an example I
have two articles here again Tintin
Walsh wrote beyond NP the queue sad face
transition and Gantt whose processor in
Welsh morphing combining something this
is the list of article in my list in my
stream of articles I have the first
article a one and then the second
article a to a one is in relationship
with Gant and Walsh an a to Gant whose
processor and Walsh now remember that
when I have this one one to many
relationship the the flap map operation
is there to help me so I can do is in
fact flat map this streamer using this
flat mapper Coon from the stream of
article to a stream of alter and if I
apply this map flatmap operation what I
get is in fact for the first article
Ganton Walsh and for the second article
in my example can't use processor and
watch right so we see that dent appears
twice in that stream and
Walsh also appears twice in that stream
since they've written each to two
articles so this is once again knowing
how many authors sorry knowing how many
articles each author write is in fact a
job for the grouping by once again
because if I grew by this into an
Instagram what I want to know is that
Janice appears twice wash appears twice
etc and this is a grouping by the key is
in fact the same object as the object I
have in a streamer so my classifier is
just the identity function and I do not
want the list of the people by people
the author by author what I want it just
to count so I just passed the collectors
that count in as a parameter and this
will do the trick
all right let us see that I once again
move to new five okay so let us take my
articles string that flat map the
results using yeah I cannot choose the
method reference here so each article
knows how many authors we have and those
authors are in the list or set I don't
know but I can call the stream on that
so now what I have is a stream of
authors and if and also wrote two
articles it will appear twice in this
stuff so I can just correct the result
using these characters not grouping by
the classifier is just the identity
function and the the post processing the
downstream character is the counting so
if I have this code this is a map of
author and long number of articles T
equals pair
although what you looking for this is a
map right and if I want to further
process this map for instance to try to
guess where try to to analyze which
author wrote the most article I I'm just
going to use the exact same code as the
previous one what did I wrote it here
this entry said dot stream max comparing
by value sorry okay entry said that
stream max comparing by value and this
is going to return me a map entry right
of the type of course of the of the map
and this is a the author with the most
articles let us print out the result
yeah this is the previous code of just
Iran so let us run this one so mr. chen
wrote a thousand and almost 1,400
articles in his life which is quite nice
at least in this file and you see that
that this is this is another pattern
that I can that I can use that in fact
counts the elements I have industry of
course if I call the distinct on a
stream it to it will not work anymore so
I should not call the distinct on that
stream so it we just where it's just
working like that and you see that on
this stuff I have in fact used the exact
same code to post-process that stream
here and this should be a hint somehow
we'll have to put this in a method or in
something or whatever and refactor it to
use it and to give some kind of a
business meaning to it
where am I yeah sort of Acts I couldn't
do the same as the as the previous one
that is invert the map to get all the
maxes of there go I'm not going to to do
this stuff I'm going to to to carry on
with yeah with with the slides okay so
with so examples on the off of streams
are we saw of characters we saw basic
characters the counting McMinn by max by
etc we saw the grouping by with we
didn't see the to list which we are
going to see don't worry
now what I would like to show you is to
understand how in fact a character is
working and in fact it's working on
three basic operation called the
supplied the accumulate and the combined
operation and underst understanding that
will allow us to go one step further to
use finishers and to create our own
characters when I create a list so this
is the most basic list I can create in
fact what is happening this streamer is
going to produce strings of character a
B and C the collector is going to grab
all those elements will first create a
list and will add the element of that
stream one by one to those lists to
produce precisely under released in fact
with the element of the stream in it so
if i so here this characters to basic
operation first create the list and
second take a partially filled list and
a limited of stream and put that element
in the stream if i want to write some
code to do that in fact I need a
constructor to that list which is called
in the collector vocabulary the sudden
the supplier and it indeed it is a
supplier just this time the expression
and the second operation is consistent
adding a given element of that streamer
at least and it's written in the form of
a big consumer that takes a partially
filled list and an element and
accumulate that elements in the list and
when all the stream is consumer then
list this list can be returned it is the
finished list of the collectors to this
collector now it's not quite done
because as you may know the stream API
supports parallelization and what is how
with paralyzation working in this kind
of context well I have two calls on my
CPU or two CPU CPU wants a beauty you
two two partially filled lists will be
created on the two cause of my CPUs
first collection second correction and
at the end of the day I need to merge
those two lists in just one using the
same object a collector so in fact I
need a third operation that is going to
merge two partially filled lists on each
individual CPUs of my of my computer so
in fact the character is created on
three basic operation atomic operation
the supplier the accumulator and another
big consumer that takes two partially
filled lists and that will merge them
together into just one list and this
third element is called the combiner so
to create lists I could also call this
collect method with those three basic
operation released new lists add and
listed at all and it works in fact the
characters dot to list is just a wrapper
on these two lambda expressions as well
going to see it and by the way this if I
want to to further abstract this kind of
code I can also call the collection add
and collection conquer an adult method
method references for that list and if I
want to create a set you see that all I
need to do is in fact to change the
supplier of this of this method the rest
of the method of the method is the same
so this is our collectors work
in a certain way now suppose we also use
the characters that joining character
that joined strings together suppose we
need to we want to implement this
collector in this exact program with the
supplier a combined accumulator and a
combiner how are we how sorry how are we
going to do it well its string dot
streamer filter this is a filter we we
we use the collect I passed the supplier
which is apparently the creation of a
new string the accumulator which takes a
partially filled string and the string I
want to add to it and I have a concat
method so ok let us just call the concat
method and then a combiner in case I
want to go parallel well to partially
filled strings are going to be merged
together and the concat method can also
be used for that the problem is that
this code of course as you may see does
not work at all
why because inherently the stringer in
Java is an immutable object so when I
call final string concat as it does not
add this s passed as a parameter to
define to the final string itself it
just generates a new string
concatenation of those two strings and
might be consumer doesn't work I that
might be consumer suppose that the condo
partially filled container which was a
list has to be mutated by this by this
consumer and since string is not a
mutable container this model does not
fit at all for the collectors to joining
example that we saw in fact the the
model that we just saw works well only
for mutable containers and not for
immutable containers and string indeed
is an immutable container how could I do
that well we all know that we cannot
mutate string so we have another object
for that which is of called the string
builder all the string buffer if you if
you want to reduce the string by first
not exactly the same but it kind of
works the same so I can write my code
like that and this time this code is
going to work
because stringbuilder is indeed a
mutable container the problem is that it
does not return a string anymore okay
this code in fact returns the string
builder and my collectors the joining
returned in the code we wrote the string
and not the string builder and the
string builder is not an extension of
the string so it's just not just myself
casting it it's really a matter of
coding in fact the to string method once
this collect has been done to go from a
string builder to a string object so in
fact of character is three operation
supplier accumulator combiner plus one
operation that is called the finisher
and that will precisely implement this
to string at the end of the collection
this finisher in the case of the to list
or the to set collectors is in fact the
identity function and in many cases this
finisher is indeed the identity function
but not necessarily all the time and the
nice thing is that once I have this
finisher that is done I have a special
character that allows me for the for the
the passing of a custom finisher to a
program to an existing character which
is the collecting and then a character
and we're going to use it in a further
example so let us do that now I'm going
to take this example and in fact I am
going to take the previous example that
we saw not this one but this one
yeah I'm going to copy paste this here
and take it there
I need those inputs thank you can go
away and I'm going to just merge all
this stuff here and this is my map dot
entry now that should compile and
remember I told you this is this is a
pity because this post-processing here
is always the same we throw it three
times in fact and we should try to put
it in a function or something just to
make things more readable now how can i
how can I do this
in fact I'm going to keep this as a map
this was nice as a map sorry call this
number watch copper here just like that
right and I'm going to put this can I
put this in a method yes I think no I
can't
I'm going to put this in a variable and
extract that in a method I think this is
this nice so what is this method doing I
just made a method extraction right
what is this method doing it takes a map
as a parameter okay and return the
mapentry
and just does that this this is by the
way this is this is a map I'm going to
call this map this is a map so this
method takes an object and returns an
object I can model this method in fact
with a function this is what I wanted to
show you the function is in fact a
method that can be passed as a parameter
this is why I lambda others have been
put in Java it takes this type as a
parameter and returns this type
and the parameter okay I'm going to call
this function function for the moment
okay
and what does it do just take him up and
there's this with it all right and they
say this is my function and of course
I'm going to call this function my
finisher this I just use this kind of
method extraction to use that trick and
then this collector here I'm going to
put this in a variable by the way this
is a grouping by your grouping by is
nice this is a grouping by and I'm going
to further to add the finisher to this
grouping by using the character we just
saw in the slide which is called
correcting and then
so this collecting and then we'll take
this grouping by and take this function
as a parameter and if I want this to
work I need to first declare this
function of course plus this finish up
as a parameter
and this is a I'm going to call this
character correcting and then you see it
it started disconnecting and then
character just as that I'm going to add
some kind of indentation here just add a
finisher a special finisher to this
collecting and then here and now if I
pass this collecting and then directly
to the collect here does not compile
anymore because the type has changed I
have directly my mapentry that is that
is computed directly so in fact this
post-processing this entry said dot
stream that max that get Lara has been
integrated in a function here in in a
function here which is which is this one
I could keep this function because this
is a in fact Max entry by I am so let me
sorry by like that so it let me just
call it call it like that I could just
and in fact I could put this function
I'm going to get rid of this because I
do not need it anymore and I'm going to
get rid of this static method here also
and in fact this function I'm going to
put this this is what I'm going to put
in a in a factory method this is in fact
this function compute the max entry by
here by value since I'm just I'm just
calling the comparator a comparing entry
and three by value okay by the way I've
got another competitor here which is
directly defined on the map and three
interface which is this one which is
nicer to use and what I would like to do
now is just try to to make this
dysfunction generic okay so I'm going to
give abstract I'll two things to this
function and I'm going to use a very
dirty trick here okay the integer became
the name of a parameter now the nice
thing is that I can rename it as a tea
and this long as a V maybe it should be
okay in fact because it's a key and it
does not compile because this here this
max is expecting a comparable stuff so
this V should be in fact comparable so
this should extend comparable not
computable future comparable of super V
like that now it will compile fine okay
so you see that it's max entry by value
and by the way I could also put this in
a variable in a comparator and further
call this in a method I expect this
stuff to take a function what did my
function go oh yes it's here right I'm
going to to declare this comparator
outside get the lambda here and return
this lambda but this time permitted so
it's a max by and this time I pass a
compiler as a parameter C and I can
inline this reference yeah that's that's
better so I've got to first factory
method that takes a comparator as a
parameter and then the second factory
method that doesn't take anything and
that in fact creates the comparator
inside to call it and this so it makes
this finisher much easier to read here I
can inline this finisher there Mike's
entry by value by the way is grouping by
I could also put it to put this in there
in a factory method right what about
this is this is just a grouping by
and counting right because I'm counting
that right grouping by and counting yeah
and just pass yes I would like to pass
this as a parameter in fact this is a
function this is this is my classifier
and owada what I would like to do is
just pass this classifier as a parameter
to this method here this is my
classifier I can get rid of this line do
some indentation my grouping by n
counting we'll just take this classifier
here like that and if I want to make
this stuff more generic I can say all
right this is my article
these those are my integers and Long's
oh okay maybe we should be a little more
with this kind of thing okay so you see
that this this group in buying and now
this grouping buyer can also try to
inline that okay so my collector
collecting and then just became this
stuff here which is which kind of so I
can get rid of this code now which kind
of make things I hope a little more
readable I can print out the result and
you see that if I run this code ah thank
you I really was knitting this okay this
is the kind of
the compiler does does see when you
execute the code but when you're in your
IDE the compiler doesn't see there is a
compiler that the compile error so this
is what just happened okay so you need
to just help the compiler by telling him
that yes this is a a mapentry of knv and
you see that the result is the same as
the previous one the difference is that
somehow I have with this kind of
variable extraction and factory method
extraction and stuff I could write some
some more readable code this is the
basic way of making code more readable
trying to trying to extract things in in
methods in variable that that that have
explicit names right let us run with the
slides so what I did in the previous
case is compute compute the max article
published in a year and remember that if
I wanted to have all the maxes I'd say
ok this is the number of article and I'm
going to put the list of the years
associated with this article but since I
used the grouping by with no further
processing I ended up with this kind of
ugly map the long which is the number of
article and instead of having a list of
integers which would have been a list of
the years I had a list of entry of
integers long but really what I'm
interested in it's only your list of
integer which is the list of years so
how could I further process this map to
get this result well in fact what I want
to change is this entry of integer on
long I want to make it just a plain
integer and to put that in the list so
this is clearly a job for a map
operation changing the type of a
variable and the nature of variable is
in fact of opinion in the stream API so
what I need is a function that is a
mapper and that will just dig that entry
and does entry that get key so this
function is not very complex what is
be a little less easy to do is to
integrate that in the in the correct IP
I itself in fact it turns out that I
have a mapping for that
sorry I have a collectors for that could
characters that map Enya the collectors
that map Enya takes a mapper as a
parameter which is the function we just
wrote and has to take a downstream
collector this character that mapping
does not exist without a mapping
character so it will take the elements
of the stream and if it's a downstream
character it the stream remember that
the stream are in fact the values of a
map something it will map those elements
and put the result in a list so it's
basically exactly what we need to do so
we are going to do that on the example
another demo all right where was it
somewhere this is the see example auto
with the most article within this one no
it was not this one mr. bean this one
yes
twist this example the old Max's article
per year which was discs this guy here
so I'm going to take this put the result
here please yes I already have people
here
okay I need this map to work who's there
in fact any all these guys okay okay
I got everything I need here at least I
think so mmm let us just the rest chance
to run this code and make sure it works
it should okay so I have this this this
guy here now what I did here is just
take the entry gate value there and this
gate value is precisely this this map of
entry on long on long here and this is
exactly the value I want to post process
I want to map because this map of entry
and it alone is not what interests me in
fact what interests me is just the key
of this stuff so instead of doing this
I'm going to call this correct Aza that
mapping here ask this entry got get
value so it will open this entry there
to get the integer so it's not get value
it's get key sorry
I'm messing things up this is the
classify I don't want to touch this one
right what I want to do is to post
process the value so instead of getting
the entry which is this stuff get only
the key entry that get key and the good
news is that the type of this stuff has
been lost and put
result interest of course it does not
compile anymore but what I expect is
this blog to compile yeah great so since
I changed the type of this stuff I still
have at least when thanks to this
mapping that opened this entry to get
the key I do not have a map entry here I
only have an integer that is awfully
exactly what I need so now when I run
this code again I got rid of this entry
here two thousand four and the number of
article published during that stuff I
only have the the urinal list which is
exactly what I wanted to have I can do
that using a second the second trick
which is remapping the remapping stuff
I'm going to to copy paste this code
again because the second pattern is also
interesting and this was the the first
code I wrote that returned I'm going to
put this in a variable in the mapentry
with the list of map entries in it okay
so I'm going to I'm going to comment out
this code here get the result and in
fact on this entry set dot stream here
I've got a stream okay of those guys map
entry set okay and what I got here is
just it's just the max of this stuff but
in fact I can collect this this and
instead of using basically what I have
here is a stream of mapentry so it's a
map in the form of the stream and to
remap something to to create another map
the the right pattern to do that is to
use the to map collector the to map
collector here I'm just going to take
the entry and
going to change the key of that entry so
it's just an entry that get key okay and
in the value if I get the value
oops and treat that get value okay
the value is in fact this stuff and I'm
only interested in the key here so I can
just sorry get value this this is my
list I'm going to string that list and
map the element of that stuff is another
entry which is this one okay so I'm
going just to get the key of that that
that entry which is the integer which is
here so now I've got the stream of this
stuff and if I want to put it in the
list again all I need to do is collect
it and put the result in a list great so
now I've got another map which is the
right one now which is this map in fact
this map here but that is here so I need
to further take the entry set dot stream
and get the max and since it the key has
not changed I can just get the result
like that so let us put this result in a
variable and see that I have the same
the same result which isn't in this the
same thing so I have two possibilities
here either use this mapping
post-processing of the values directly
when I create the map with my grouping
by or if I already have the map and want
to remap it use this trick here to
change the type of the map with the to
map character in fact this to map
character this to map character is very
useful especially to
to create to remap up to change the type
of a map you cannot really change the
type of map you can take them up and
create another map with a different type
okay and this is really the job of the
to map character the to map collector
kind of looked like the grouping by
character the first function you provide
you compute the key of that map and the
second function you provide compute the
value of that map now the biggest
difference between the tulip and the
grouping by is that the two map should
not be creating duplicate keys if it is
the case then you will have an exception
because it doesn't work like that the
grouping by expect that you are going to
create duplicate keys and we gathered we
gather the values associated with those
keys in lists the the two map does not
expect that expect that you do not
generate duplicate keys so this is the
main the main trap when using the to map
character now since in this in this
pattern I am sure not to have any
duplicate keys because I take them up
and reset dot stream and in that case I
do not change the key I only change the
value so it's just a kind of a value
mapper on a map so so you have the
guaranteed not to not to generate the
duplicate keys which is great and with
this I think that we are good for a
little coffee break what do you think
yeah coffee break
ok what about we take like 15 minutes
for coffee break is it off yeah ok so
let us carry on that at 3 p.m. okay in a
second part we'll see filtering flat
mapping using characters joins just like
in sequel and composition of characters
thank you and see you in the 15 minutes
oh by the still after 4 yeah by the way
if you have question I will check the
Twitter hashtag for questions and we
begin with questions so welcome back yes
there was a question and a
on twitter about the status of fine
first find any and the min/max reduce in
slide I said that min Max reduce were in
one category and find first finding it
was in another one meaning that two
computer min and Max or a reduction you
need to scan all the elements of the
stream you need to consume all the
elements of the source the stream is
connected to whereas when the find first
or find any once you have found one
elements you're good to go you can cut
the connection to the source this is the
difference between those two categories
of methods now both of this method min
Max reduce fine first finally written
optional to handle the the special case
of empty streams so this is not what is
making the difference between those
those methods right I hope it answers
the question that was asked on Twitter
right so let us carry on we have some
nice things to to to see here again here
I'd like to talk a little more about
types and show you the collector
interface I let a blank line at the
bottom of it because there is one more
method but I'm not going to talk much
about between but which is which is
there so collector is in fact typed with
three parameter type welcome to the
wonderful world of generics yeah a TA
and R and if we want to go further in
this talk we need to understand the
status of those types and fortunately as
I told you if you're in the first part a
character is created on a supplier an
accumulator and the combiner and there
is this finisher that can be the
identity function and that in many cases
is indeed the identity function first
character connects to a stream this
stream is going to produce elements of
type T so the first type of a character
is T the elements of that stream now
remember for the joining character we
began to put
Iza elements of type t which tended to
be a string by the way in a string
buffer and this is the type of a AE is
the mutable container in which I am
going to gather all the elements of that
stream in which are I'm going to
accumulate all the elements of that
string so this is the type of the
supplier the supplier is a supplier of a
creating the mutable container now if
this supplier creates in fact the
mutable container that is returned by
the character which may be the case for
instance for the collectors the dualist
collector then a and r are the same
which in our example will be list but in
the case of the stringbuilder remember
that the finisher is in fact the to
string method of that string builder so
a will be the string builder and r will
be the string returned by the to string
method so those are the type T a and R
and we're going to see example to them
so I hope it will make things a little
more clear for everybody the last
methods I have is a set of
characteristics that returns metadata we
could call it like that metadata on the
collector and among them there there is
a flag which is called identity finish
which test if the finisher is the
identity function or not so a collector
will tell the stream API yes my finisher
is the identity function so you do not
need to call the finish a method to end
up the processing so in a nutshell T is
the type of the elements of the streamer
a is the internal type of the mutable
container and R is the type of the final
container now we could say that a is
some kind of licking the internal of the
character interface to the outside and
indeed it is the case we should not have
access to a from outside characters
since it is really an implementation
detail of the collector itself often we
have a equal R which is the case when
the finisher is the identity function
but it's not because a a equals R that
the finish is the identity function for
instance if you want to collect your
data in using a grouping by bandits
10:03 returning a map you want an
unbelievable map at the end of the
building of the creation of that map
does the grouping by you may want to
call the just collection that
unmodifiable map to the result in that
case a will be equal to 2r but the
finisher is not the identity function so
it's not necessarily the case right now
what is the type what what what impact
does it have on the type of the
downstream character let us take an
example we already took which is the
grouping value of those this stream of
strings by we want to group them by the
length of those strings so the map call
creating is the the map at the bottom of
the slide 3/3 associated to the list of
1 2 6 10 etc if I want to pass so yeah
the grouping by is a collector of type
string because it is a type of the
streamer this character is consuming we
do not know the intermediate the mutable
container in the middle so let us leave
a question mark and it will work like
that and since it is a grouping by
higher the type of the return container
is a map of some key zone and the list
of some values well quite obviously
since the classifier returns an integer
and this is the type of the key the type
of the key of the map will have to be
the return type of this classifying
function so integer is the return type
of the function passed as a parameter to
the grouping by method and the list of
the elements is the list of the elements
of the string so it has to be early
of tea but you see that this grouping by
collector is in fact parameterize by by
more type than the three taa are because
there is a map of K and V in it
and now what happens if I want to pass a
downstream collector to this grouping by
why should what should be the type of
this downstream collector
well this downstream character will have
to consume the elements of the lists of
the values of that maps of that map
which are once again strings themselves
so it's a character of string you just
to be able to consume those values and
the return type of this character is in
fact three it just can be any kind of
value in a case of the character the
return type is a longer since it is
counting the element of that stream and
it will make the type of the overall
collector grouping by string length then
collectors dot counting in fact the
return type will be a map of integer
this is the key of the map imposed by
the classifier and the value of the map
will be imposed by the return type of
the downstream character this is how
things have been made in the in the
collector API and by the way I could
just finish I'm just going to finish an
example I let before the before the
break I think it was there no it was not
was there no it was not it was there I
wanted to remember I wanted to
parameterize this stuff and I used this
trick I just I did that okay and passed
the article here and the type of a map
here trying to parameterize all this
method and it didn't work why because in
fact there long here is imposed by the
collectors that counting collector here
so it's not a parameter of the map of
the of this method the article of the
integer and the integer R because this
collector can take any T here produce a
map of any K this will just be
the type of the function so I can rename
this with the T the integer they here
with a K I'm going to call it K because
it's the key of the map and it will
return a collector that's will return of
map of Kieron long just because it has
this collectors that counting here so
this is just an application of the slice
I just showed you all right let us talk
about intermediate operation it may be a
little well because collectors are
inherently terminal operations but they
can in fact provide intermediate
operation and we already saw an example
of that when we use the string that
correct that mapping function and
downstream remember we use that
character as a post-processing of our
list of map and trees of integers and
long just to make them list of integers
so I indeed have a collectors dot
mapping that does that implements an
intermediate operation of the stream API
which is the map operation now why is it
interesting to have this kind of
collector well because I can use it as a
post-processing in a downstream
character if I did not have those
downstream collectors it would be
completely useless to have those mapping
characters but in fact it's I have them
just just to do that and if a collector
can map then why wouldn't they be able
to filter Auto flat map in Java editor
it's not possible but as you may know
Java 9 has been released a few weeks ago
and in fact we have a collector's doll
dot filtering and dot flat mapping
factory method in the characters factory
class so yes indeed we can do filtering
it takes a predicate of T and the
downstream character this downstream
character is mandatory since it is an
intermediate operation and the same goes
for the flat map
Fatma / also takes a flat mapper as a
parameter which is a function that takes
a team into the streamer and also
downstream character that is and also
takes the downstream character as a
second parameter that will take the
elements of the streamer and collect
them in some kind of other stuff so
those are intermediate operations have
been added to the collector API in niner
and we are going to see how they have
been added because I think it's
interesting to see how those have been
have been implemented yeah
and it's another demo time so let us
jump to the demo first of all I would
like to all those factory methods I've
put here I'm going in try to put them in
a factory class let me do that real
quick I'm going to put them oops yeah
here you teen correctors utils do they
already have that and I'm going to put
all those three methods here to make
sure yes so this is a collectors util
class and it will be I'm just going to
put them some factory method to use them
in other another example sorry here so
it's just there to hopefully make things
a little more readable a little more
readable okay
so let us carry on with our examples we
are going to what is the next yeah I
want to get the article with the most
authors right
so how can I do that well it's very easy
I need to stream my list of articles
this is always the same beginning and I
am going to first of all remember that I
have article that are buggy I do not
want to take into account the article
that I've been released prior to sorry
get inception year prior to 1900 those
those articles are corrupted there are
corrupted data in my fight that this
happens all the time so this is quite
usual to see that and what I want to do
sorry I'm not going to collect right now
I want to take the max with the mod
authors so the article I'm going to
compute the number of all thousand with
the size why isn't it oh yeah so I need
to wrap that in a comparator sorry
comparator comparing article gets size
and then get the result right and if I
so this hopefully is an article article
with the most authors probably not going
to print out this article because I will
have too many authors so what I want to
do is just get the title and print the
number of authors articles get sorry
I'll take article with the most I'm
going to you like that
article get authors and print the number
of authors I have in this article okay
let us dream is to read this coder I
don't have any character in this code
right don't always need character there
okay structural DNA nanotechnology
molecular construction and computation
has been signed by 25 authors right now
what I would like to do is the following
I would like to say all right I want the
article with the most authors but for
each year for each year I've got the
certain number of years in my in my
stream in my stream of articles and I
want for 1960 this is the article that
has been signed by the month or so etc
basically what I saw is that when I have
a processing that is modeled inside the
character I can take this collector
asset as a downstream collector of a
grouping by for instance and it does the
trick so what I would like to do really
here is the following take my stream of
articles group buyer so correct
characters dot grouping by goodbye year
so get inception year and then also
collector as a parameter that infinitely
unfortunately doesn't exist but this
collector should in fact do exactly this
processing here right if I can create a
character that does exactly that filter
max and get then I'm done I can just
pass this collector as a downstream
character and I will have solved my
problem and this is this is all the
point I think of the character API being
able to transform a stream processing in
a character processing to pass this
character as a parameter to a further
processing like in the downstream
character of this grouping by for
instance so how we can we do that filter
we know that we have a filtering
collector in nine we do not have it in
eight so well they say this is java
night code by the way
so this is a my filtering character it
takes a predicate as a parameter which
is this one okay and this filtering
character takes a downstream character
that has to do the same kind of thing as
the code that is here and this is a max
and we saw that the max has a character
characters that max by at the beginning
of this talk so I can continue by
passing these collectors that max by it
takes a comparator as a parameter so let
us pass this comparator as a parameter
and this is it doesn't doesn't compile
because I did not give the type of
anything so it just just code like that
first for the moment that will we'll
have it work and this is the get method
remember this is the get method of the
optional object because this max by
returns an optional object so if I take
this character the return type of this
character will be wrapped in an optional
so what I want to do really is to apply
this get method from the optional object
in a finisher this is this is in fact my
finisher and we saw that if we want to
pass the finisher as a parameter to a
character it is the job of the
collecting and then character so this is
my max by and then just call this
optional dog yet yes this is this
optional like that and post it like that
I think I'm missing closing parentheses
which is here so this is a the
conversion of my stream API processing
into a single collector API now I need
to find the type of this character and
this is not the the pleasant part of
this kind of thing
it's a collector that is going to act on
a stream of articles quite obviously
because this is a grouping by and this
grouping by will create a map the keys
will be the in section here that is the
integers
those are integers and list of the types
of the stream this grouping by this
processing that is a list of articles so
this character will be a collector of
article the mutation the mutable
container inside of it I just lived this
mutable container blank because I do not
really need it and this one is in fact
is in fact this guy is in fact this guy
is it yes it is it's also an article
because what I have to what I have done
here is model this processing with the
collector so it should be an article
also and this is my character and it
doesn't quite oh yes thank you and now I
need to improve this class oh it worked
that's crazy okay I'm going to put this
so this is my map and this is the mapper
I wanted I wanted to create okay so by
transferring this stream processing into
a character processor I just did that
trick put all my data processing in a
parameter which is a character and
passed that processing as a character
and as a parameter to another processing
this filtering a character is available
in nine what I would like to do is just
show you as an example how we can create
such a character I've got character
because we are going to use that later
on I think I've got two collectors the
tutorials are not going to do that
to do it like that I've got a util
package here with the the UTS factory
class creditors you take factory class
I've just created a few minutes ago so
I'm going to create a new class in that
collector filtering character let us
correct filtering director it's nice a
corrector that is going to implement a
victory so we are going to implement
this collector using directly the
implementation of the interface and
which it will be a first example of of
how to do that and we are going to to
make two to do it for other cases so
this filtering character is a character
of T are are G a are oh sorry those are
the three parameters type we just saw in
the slides and it's going to implement
the character interface of T a and oh
yeah
it doesn't compile because uh we need to
implement the methods from this guy okay
so for the month doesn't do much but in
fact doesn't work neither because it
will throw will happily throw in the
pointer exceptions okay this filtering
character will have to take a downstream
collector as a parameter because it's an
intermediate operation and all the
intermediate characters so-called
intermediate characters have to you to
be connected to a downstream character
so let us create this downstream
character here private collector T and
this is my downstream I'm just going to
call it downstream down stream
I'm going to create a constructor to to
get it okay
and now how does this stuff work it's a
filtering character so it's not changing
the type of the the stream I am
processing so I am providing element
today to this downstream character
directly the supplier in fact what what
do I want to do with this character this
character is going to consume the
elements from that from my upstream and
is going to feed some of those elements
to the downstream character provided so
in fact it doesn't too much
I could I could just write it like that
you see just say all right the supplier
is just the supply of the downstream the
combiner is also the combiner of the
downstream ok the finisher is also the
finisher of the downstream the
characteristics gets what guess what
there are also the characteristics of
the downstream ax and if I do the same
for the accumulator okay I've got
basically your no operation a character
doesn't do anything just take the
elements and pass them to the downstream
character of course since it needs to
filter something I need to change this
kind of thing and I need probably to
have some kind of credit to do this so
let us get a predicate I forget to get
this predicate it will be a pretty kind
of tea since we are going to filter the
element of the streams we are connected
to and I'm going to add this construct
this predicate to the to the constructor
now it doesn't change any of those other
methods
apart from the accumulator one why
because the accumulator won't remember
it's the method that the process that
takes an element from the stream and
adds it to the mutable container
provider the mutable container is not
provided by the field
character is provided by the downstream
character if I want to collect in the
list it will be raised found collecting
a set to be a set front collecting a map
it will be put in a map using a logic
that is provided by this downstream
character so here I need well to write
this this B consumer right area so this
is a big consumer of a and T so remember
this big consumer as a method except
that takes two parameter okay so the
first parameter is of tapped a and a is
the mutable container so I'm going to
call it container just to remember that
it's a container and T is the type of
the elements of the stream I am
connected to so I'm going to call this
second element element okay and what do
I need to do or what do I want to do
well if I just do this kind of thing
except container and element what I'm
just doing is just passing this
container on this element to the
downstream character to say hey this is
the container of you've already
partially filled this is an element do
your job so this is another no op no
operation collector and this is
precisely this that I should be trying
to modify if I want to do something
remember this element T I want to
transmit it to the downstream collector
only if it's okay with the predicate I
have so what I need to do is test this
element against that predicate and if it
passes the test then pass it to the
downstream character and if it doesn't
then do nothing basically so this time
if I write it like that I take an
element if it's okay with a predicate I
said at all the downstream character hey
put this element in your container and
this is the way I should be writing that
and if it does not well I do nothing so
the
settlement would just be be thrown away
and this is how to implement a collector
in a collector in a collector framework
it's not it's not very hard as long as
you have a downstream character to help
you because if you don't then in this in
this method here this is where you need
to create the map of key and list of
values etc but this is the job for the
downstream character as long as the
collector you want to create is just a
character created or not downstream
it's very simple very easy to create so
I'm back to this guy sorry not this one
just this one so I could this filtering
collector I'm going to put this one yeah
I could have written in that way I could
have written in that way
collector equals new filtering character
pass and pass basically the content here
like this
first the predicate and then the
downstream character and you see that
yes this downstream character is fairly
complex to collecting and then would so
it has a special finisher and max by
with the comparator etc but this is this
is how it has been done and if I I'm not
going to to write all the map I'm just
going to to take yes
and the size of this map run this code
and you see that oops
yeah of course yeah and you see that
this code is pervy working perfectly
well I have no exception in the console
you didn't see it right I guess you did
okay but this does not come from the
filtering character it comes from from
some other things so the first part of
this of this let me run this code again
the first part of this code worked okay
so the article on the overall with the
most authors with this one with 25
authors I took my collector iced it as a
downstream character well I modeled my
mic data processing as a downstream
character and passed it as a
post-processing of the creation of a
histogram basically and it did not work
now the question is where did it work it
worked in this optional that get method
here in fact I had an empty optional in
my in my er in my stream so what
happened
I created a data processing pipeline and
tested it on a huge database of more
than 100,000 articles remember this is
the amount of data I have and then since
this file is clearly not empty my
optional docket was guaranteed to return
something and not to throw an exception
but now what I've done is that I
distributed all the elements of my of my
find all the articles of my frydar in an
ash map with the key as the years of
this of this of those articles
publishing years of those of those
articles and now since I do not have a
fine enough knowledge of my base I
cannot tell if some of the years will
have any articles or not
so suppose some of the years are just
empty or some of the years are have
articles with no authors which is also
possible
then for some values of my map I might
have some empty of channels this this I
cannot tell in advance because I well I
do not know this base well enough so
what I need to do if I want to further
further process this map extract maxixe
it rhymes guarantee that this map will
work as it is what does the problem
comes from the problem comes from the
fact that this gate is going to be cold
here on an empty optional so I should
not be calling it what is this collector
creating as a map in fact if I France
and I could choose not to create this
correcting and then let let us do that
okay let us get rid of this correcting
and then here I have a different
character there okay to not work sorry
if I if I don't do that instead of
having a map of integers of an article
if I do not call this get I expect to
have an a map of integers and optional
of articles okay this optional that get
is just opening this stuff it's a very
bad idea to create this kind of Maps
why because an optional can be empty so
creating your list of option holes or
map originals or an object with a field
that is an optional is in fact may be in
fact very costly and completely useless
since those optional can be can be empty
so we should not clearly should not
create this kind of map and store it as
such in a field or pass it to another
processing or whatever so this it's not
a good idea to create this map now this
optional object is really in our way and
I think that the right solution to
handle this is not to keep it as is in 9
we have a fey in fact I'm going to
comment this we have a very nice method
here which is a streamer on this
optional curve oh yes
because this collector the type of this
collector is not the right one anymore
so let me get rid of this if I do not
call okay I'm going to take that again
if I do not call this correcting and
then here okay so do not call this
optional and remove this stuff here for
that to compile this is going to be a
character that is going to return an
optional of article this should compile
right okay
does not because I have this panthis it
should not be there okay if I do not
call this optional that get here this
was the previous situation where I could
get here now if I call a stream instead
of a get like this so I'm going to
uncommon this code put this pen that is
back and come on this guy and the comma
here and change this optional for a
stream you put the class then I will be
able to do some things because I have
much more methods on the stream
interface then on the optional objects
basically an optional on a stream can be
seen at the same object the difference
is that in an optional I can have only
use ero or one object and in the stream
I can have a stream a stream can process
more object in that but button option
holders on the stream are kind of the
the same objectory the difference the
other difference is that the stream can
be processed only once and an optional
can be processed more than once so what
I would like to do if I if I uncommon
this code and remove this line I have
something that compiles I am going to
put this in a variable yeah it's not
this one it's the other character that
takes a stream that I want to use
we put that in a variable yes it's
correct that I want to put here this is
my map and this time if I run the code
now
I should not have the problem again okay
I have indeed the sixty values in the
map which is a reasonable amount of
years between 1935 and 2009 now but I
have here streams that are empty and
what I want to do really is convert if I
if I take this entry set sorry that
stream here so here I will have a
streamer excuse me
of mapentry okay so I cannot call this
again here now I have a stream of map
and tree with this stream instead of
inside this one what I really want to do
is transform transform is convert this
map entry with a stream in it that may
be empty in a stream of map entry of
integer and article and I want to do
that with a flat map because remember
that you know if a flat map is
flattening an object that has no
relation this object will silently this
object will silently vanish from the
from the resulting stream so if I'm able
to do that in fact all the streams are
of article that are empty will not
generate any mapentry in the final
streamer and I will be able to create a
map of entry map of integer an article
with the without any exception as I just
saw a few minutes ago
so this is this is really my goal read
create this kind of this kind of
conversion inside master and clearly
they say this is a job for mapping so I
have this entry set dot stream here what
I want to do is the following
take this entry okay so this entry is
this one right from get the value of
that entry and since this is a stream
now you see this is a stream this used
to be an optional but since I use that
now I have a stream here I can map it
alright what do I have here I have the
value I want to get and I want to
recreate from that value I want to
recreate this object here and this
object is just a new simple immutable
where are you here simple immutable
entry with the key being the same key I
asked the entry I have here so entry
that gate key okay I'm going to add
something like that and the second
parameter being the value which is the
value I have here which is this value in
fact the value I have in my string there
so this is my value okay yeah and this
is my mapping doesn't compile because
it's not this type is not the correct
one anymore okay what is this function I
have here can I put it in a can I put it
in a variable yes I can going to call it
function you see that this function take
this map entry of antigen stream of
article which is exactly this type here
this type here right and return the
stream more abstract I'm going to call
this mapentry this is this is going to
be to be R is
and return the stream of mapentry okay
of through stream of Marvin trees so
this is exactly what I need
this is exactly what I need to do and if
the nice thing is that if the stream of
article is empty what is going to happen
this entry that get value returned that
streamer will map that stream but there
is no value in that stream in that
particular value of that stream so this
map will not do anything between it will
not crush because a map on hannity
stream just does not do anything returns
another industry so in fact if this
stream of article is empty the stream of
map entry return will also be empty okay
so now if i'm using instead of a mapping
here if I'm using a flat map okay you
should compile
if I'm using a flat map here this stream
that is empty as we saw in the slides in
the first part will just vanish will not
generate any value in the final stream
so this tree this pattern in fact is not
opening the optional it's keeping just
converting this optional in the stream
if the optional is empty the stream will
be empty and this conversion from an
entry with a stream in it to a stream
with an entry in it which will be empty
if the the first wing was empty will
just vanish
using that flat map so now excuse me so
now what I have is a streamer of map
entry here and I can just correct and
collectors are grouping by entry that
get key and this is going to be a
mapping list of map entries since I
expect to have only one list of map
entry in it or I can could do instead of
doing that
it's just recreate the map we do to map
here and treated get key and entry and
treat that get value and this time I
will have the proper map the types of
the map are kind of lost so let us just
recreate them this was a map of integer
and article are you okay
not okay yes kind of we're here sorry
58 oh yes you're right sorry
thank you is it enough it's not sure
here here
yes you're right
article no integer and article thank you
it's quite easy to get lost with these
generics right okay now it works fine
okay so if I if I pull this man that
size now ah called it correct so I call
this map that size now I only have 59
elements
remember I had 60 in the previous
version but one of those streams was
obviously empty and it has been removed
from from from stuff so we see that
using this kind of trick
the optional element in fact doesn't
does not appear anymore in our pattern I
think that a wrong solution would have
been to try to put some kind of if
optional is empty or filter the result
which is kind of the same on the MT
optional to remove it before calling the
gate there are a map filter and the flat
map methods on the optional but in nine
there is also a stream a method on
optional that would convert this
optional in a stream allowing for for
better patterns basically without this
streamer a method an optional this
function here wouldn't have worked
because it could have written an
optional and since it returned the
stream it can be passed at the flat map
method of the stream API they say this
is the since something we can do in nine
that we cannot do in eight but there are
tricks to convert strings to optional
also in our in eight if you want to do
that right and we done with this example
I think we are kind of done what do we
have to do oh yeah yeah let's go back to
the slides maybe we'll come back to it
okay I didn't talk about the
characteristics of an optional there are
three of them I put in a set identity
finish will tell the stream API that the
the finish of of the character sorry I
was talking said optional character the
identity finish will tell the stream API
not to call the finish I method because
it's the identity function and if we are
not worried about it it might stop
working we're going to see examples of
that and an ordered state that the
collector does not preserve the order of
the elements and concurrent say that the
collector is thread safe and can be used
in parallel right so how did we end all
the NT optional
first we made a we converted an optional
into a streamer and basically we are
slide a very classical pattern when we
have empty elements whereas the where
whether there are empty streams or
interruption all which is to put them in
a stream stream of streams and flapman
floods map them to silently removed all
the all the empty stream this is
basically what we did so we created a
map we in fact our code was creating a
map of K and optional of V the first
step was to convert that map into a map
of K and stream of V with probably some
streams empty and this is going to
happen very quickly if you if you just
set up collectors on non empty streams
and then use them as downstream
characters we converted this map into
stream of mapentry of K and V just by
streaming this map into a stream of
entry of K and stream of V and then flat
map the result and recreated the map
using the two map collector and it
worked quite well which is very nice all
right
what about trying to join streams
together what I would like to compute in
the following example is the the duo of
authors that published the most together
remember that we have like more than
hundred thousand articles we have
probably tens of thousands of authors in
it so this is not something that we can
brute force
I cannot compute all the pairs of
authors from all the authors of this
base and then checked if they have
written an article together what I
should do is really create the pair from
the article together what about putting
that in a character then pass this
character as a parameter to a downstream
character to check for the authors that
published the most together in a year
and we are going to use a nape I have
published on on github for that called
the streams utils that will do the
crossing for us so what are we going to
to proceed we
have I just set an example on on two
articles so Gantt coach beyond published
beyond NP the Q set phase transition and
Gantt whose processor Watson morphing
create a world another article called
combining and stuff so the first thing
we are going to do is for all the
articles get the stream of all tourism
and from that stream of authors create a
stream of pairs of authors that publish
together so the first green stream which
is the stream of the authors of the
first article will generate one pair get
Don Walsh and the second stream of
authors which are the authors of the
second article will generate the
following pair again to whisk in
processor etc and I've got an AP after
that and when we flood map all this
stuff we will have a stream of pair of
authors that published together and
since we already saw how to construct to
create an Instagram from by Counting the
elements of the stream this will be a
job for further for the SIP for patent
we've we've already seen right so let us
do that we are going to where is it this
is this guy this is this one I want to
close you yes thank you
so what I have is always at the
beginning is already the same this is
the easy part cause that stream right
what I want to do is to map those
article we are going to see what it
leaves and here I want to get the
authors and get the stream of those
authors and this is the stream of the
authors and I want to create the stream
of the pair of authors extracted from
that stream and in fact I have so I'm
going to create a function basically
okay that is going to take a streamer of
authors I will sir and return a streamer
of pairs of my pair will be a mapentry
of author and author so this is my
function so I've got my three my also
strain yes let us do that and I cut the
factory method on these streams
YouTube's a factory class which is
called cross-product ordered that takes
that stream okay and that takes a
comparator as a parameter because I do
not want to generate if if I Gen if I
have generated the pair a B I do not
want to generate the pair AAA which is
obviously not to do and not the pair ba
which is basically the same as the pair
a B so this is why this is an ordered
cross product and here I'm gonna need to
provide a comparator of authors and I'm
going to compare them yes just using
oops
just using their last name just like
that so this is this is a some kind of
cheating but this code this code is
available on github yes I should have
downloaded the source sorry this is
available on github so it just just does
the trick and by the way to Java 9 API
okay so this function I'm going to apply
it apply this function to that stream
here and this is going to read to
compute a stream of stream right because
this function in fact is returning the
stream so I can directly use the flatmap
stuff here and this is a just going to
call that stream right and this is
directly the stream of pair of authors
that published together because it's
created directly on the articles on the
article themselves so it's really the
the base
way to generate that string great now
what I want to do is just to collect
didn't I create what did I put in
characters the two tees by the way we
haven't used it grouping by n counting
this is exactly what we need right and
this is the function that identity in
fact yes grouping by and counting
function this is this is the the the
extraction I just did and by the way I
could create another method from this
one grouping myself what about I called
grouping by self and counting that
should return grouping by and counting
with function that identity sorry I
didn't hear sorry this is the classifier
should pass right okay can't in from
chanclas failure okay I don't get it
this should be a tea yes this doesn't
take a transfer as a parameter Oh was it
just that okay okay so naps so now I can
just group by self and Counting
grouping myself let's just fix that okay
grouping by self and Counting so just do
grouping by identity counting this is
nice and what I want to do now is just
pace the correcting and then collectors
dot correcting and then and I want to
get the max by a value in factor which
sorry okay and I think that incorrect
was util I also created something max
entre by value this is this is what I
want to do okay
correct right it's Ted it really
oh yes that's it it's not bad it's more
readable like that no just by using
factory method when it works and when
you have all the time to deal with the
generics and make it works it's it's
better to have that okay so let us call
this entry so in fact this entry is the
duo of author of authors that well this
is the most seen I'm going to call it
like that most seen of authors and I'm
going to print out the result
okay so mr. Kim and mr. Lee publish to a
little more than 200 articles together
which is nice since this is a collector
oh I've got this flat map here so it's
not quite a collector but it turns out
that in 9 I have a flat map in character
in fact available so what I can do is
comment this code and call this
characters that flat my opinion okay the
first argument is precisely the flat map
which is this function great the second
argument is the downstream character and
it's all this character right and if I
run this code it should work the same
and this is indeed the case so the good
news is that this is a collector I'm
going to call it collector okay so if I
want to compute the same kind of thing
in a year all I need to do is call this
articles dot streamer correct in a
grouping by pass my article that gets
inception year as a parameter and my
character as a downstream character of
this stuff right and this is going to
yes and if I want to go one step further
because this is going to create the map
of the most sinner the most seen duo of
authors that publish together in a given
year and if I want to see the max which
should be the same I all have to all I
have to do is construct the right
comparator to to extract the max
from this guy but of course if I run
this code down what is going to happen
ah I'm going to print map that size
right because this might be too big I do
not want to print it what I expect to do
is have the exact same problem as
previous one that is called the gets on
an optional on an interruption all and
this is this is exact same thing why
because if an author has been written
only by one author this article will not
generate any kind of pair so this
function here will return my the first
function I wrote here is going to return
an empty streamer okay
so I'm probably have a bunch of empty
streams in my processing if I take all
the articles there are so many that yes
I am pretty sure that many articles have
been written by more than one author but
if I distribute all these articles
Europe earlier odds are quite high that
at least some of those articles have
been written by only one other that are
not going to generate any pair in my
stream so I should be using the same
kind of thing just to get rid of this we
can do that so where is this collector
this collector is here I'm going to copy
paste it in fact borrows it here okay
call it corrector to corrector to here
and then I should try to find where is
my where is my get and I get in fact
Italy isn't this guy the faulty get is
just here so I should in liner this
method
in line this method one step further
okay one sir years ago I don't think I
need this guy now it's not this one
sorry this one is okay
excuse me I shouldn't mind this one and
this is this is the faulty get high half
here so I can extract this in a function
you know in my finisher here function is
a little a little ugly we all agree on
that
I'm going to rename this as my pawn
because I don't need it and then since I
do not want to get to get this a this is
the get method on the optional that
isn't it okay this is the city optional
so I shoulda called streamer instead of
optional here right so this is now a map
entry of sorry this is a stream
okay so in fact this mapentry here since
returns oh yeah is the stream here I
think it is stream of mapentry and so
here I have a map of stream of mapentry
here so this map is in fact is a map of
Survivor there and now if I run this
code this time since I have kept in fact
the empty stream all the M tips are
optional in it I have the 60 value which
is the same amount of value the number
of data I have same amount of data I
used to have here so now I should do
exactly the same trick as the previous
one which is here I think that this
should do the trick I'm going to
copy-paste to to comment out this code
copy paste all this I also need a
function that I wrote which is this one
by the way this function is completely
generic as you can see it does not
depend on the type of the map oh yeah
let's call it function - we did have the
right type I'm not sure oh no it doesn't
because it's a yes it's a not a stream
of article it's a stream of mapentry of
author and author here all right
okay you know what we are not going to
use that function we are going to to
create that by own by hand I'm going to
paste it and write this function by him
it should be easier than to try to get
this so this is a non-tree set of
streams so this is a my my entry and I'm
going to do the exact same that is take
the value here the stream of those value
get value should be a stream so I expect
that to have a map method on it now I'm
looking at the other I'm looking at this
this this entry that I have here and
this entry I want to create an abstract
simple immutable entry I'm going to just
give me some room here
strike map simply immutable entry here
I'm keeping the key and getting the
value here and treated get value no I
don't want this one precisely I want
this one get value which is wrong
okay so what is this guy ah type is lost
once again yes is it this one yeah it
should be okay so now if I want to
extract the max now I have solved my
problem in in a certain way and if I run
the code again ah I've got a duplicate
key in it great
this this code is faulty okay I'm not
going to fix it now because it's a
little complex and I've got only 20
minute lifts and what we go to go one
step further but I think that you get
the idea this pattern is the same and
and you can all you can just open the
stuff here by the way if I do grouping
by here it will solve the the duplicate
key problem but this duplicate key come
probably comes from from another problem
in that in that code nevermind
I have only 20 minute left it's a little
short I hope I will have the time to do
this so what is interesting what is
interesting in modeling all this stuff
you know in a character it's just that
we can reuse this character as
downstream character and this this is
what we what we just did what about
readability for the for the moment we
just wrote code that was really harder
and harder to both to write and to read
them probably more to read and to write
and to do that we just try to extract
code in variables and in the factory
method which is one way of tackling the
problem but probably not the best of the
way the problem in fact comes from the
fact that if we want to compose two
collectors together the solution we have
is take one character and pass as a pass
it as a parameter to another character
so we ended up creating character max by
character grouping by character etc
nested in each other and we all know
that nesting calls like that just leads
to
very unreadable code and this is what we
saw this is what we saw in this time so
what about trying to get rid of that and
sorry and trying to tour to write
composable character willing to to get
just one last example which is this one
we own to get rid of these articles and
authors and stuff just to just to watch
to watch this to take a look at this
example which is much more simple so
this is the example we took in a slide
here what do I have ever I have a map a
filter and just a collection in the list
which is which is pretty pretty simple
to understand now if I want to write
this with a character I end up writing
this kind of code and we saw that
already
collectors are dot my opinion and I'm
going to pass this mapping as a
parameter string length then collectors
are not filtering and I'll pass this
filter as a parameter this is my
downstream character and then the last
downstream character will be collectors
the tourists which is the last of the
character and this is going to do
exactly the same I'm going to call this
list - this is going this is exactly the
same result if I run this code again I
have of course the same result and now
that all this is in a character let us
call it character right whatever not
going to use it anymore anyway I will be
able to pass this data processing as a
parameter to further downstream stuff as
we as we saw earlier and you see that
this is exactly where the whether the
complexity comes from I've got a mapping
that calls a filtering that called
tourists if I had 15 sites in my in my
data processing pipeline the code would
be really absolutely absolutely ugly
what I would like to do really
is in fact cool it's somehow in that way
you see having a string dot streamer
then collect with the mapping and then
correct with the filtering and then
collect with this tourist to this
collector this this would be and I would
like this to return for instance list
three this would be much more readable
and much more easy easy to read now if I
want to write it in that way what do I
need really
I need a correct method this correct
method is defined on the stream API does
this is a correct method I have that
should return an object able to have
another correct method on it
so this collect method should itself
return a stream which is only possible
if the collector I pass as a parameter
itself written the stream so this
mapping a character okay
how can I'm going to write it should be
in fact passes as a the should should
have a downstream character they able
itself to to create to create a stream
and remember that we have those
collectors to list that can create lists
from collectors passed as the downstream
characters we could try to do the same
kind of thing with a streaming character
so if this mapping is in fact I'm not
going to call that sorry okay my opinion
and I pass this as a parameter with my
mapper it's here and if I pass this
collector sir
I'm going to create it incorrect as you
tear or maybe here like that the new
streaming character
and this streaming character would be a
collector that creates a stream instead
of collecting and streamer this would do
this would do the trick
really so I'm going to create this class
do I have it in YouTube this streaming
character is a streaming character of TA
are and it implements character of T a R
which is nice
okay this is what I want this is what I
want to do and in fact since it is a
streaming character the T will be the
same because this would be a factor
stream of T so I won't be needing this R
here and this a here is going to I'm
going to to user sorry in fact a
stringbuilder
the stringbuilder of t as a as a mutable
container so this string builder will
just be streamer it should be the
streamer with the method or the combiner
here we'll take two builders build the
two since the builder can be made a
streamer now with the build method I can
take all the elements of that stream and
put them in the first builder with this
builder one
dot add my father and return of course
Bellona
the finisher will just be my stream
sorry build the Builder the
characteristics I'm just going to return
a newer set here that is empty and the
accumulator
it's just that stream builder here ad so
this is this is a this is a color stream
your collector that just create a stream
instead of creating a list basically the
same kind of thing and this can be
passed here is a parameter to this
mapping and if I do the same here I'm
going to call this filter a NIA
collector pass my predicate as a
parameter here
oh yes excuse me
kind of roast type of this to McGregor
is because so with the same okay I guess
me the type of this guy right so now I
should be able to okay so this is my
mapping yeah I'll do the same for the
filtering can't believe it
sorry I'm kind of fighting with this
idea okay so this is my mapping now I
want to do the same with the filtering
plus I I greater than three three it's a
character that takes integers as
parameters and this is a filtering right
so this is my filtering and now if I
verify that this code is working by just
passing this list dot three I can see
that I I ever reached the same the same
stuff so this is the first step
I've got a coder I've just transformed a
nesting of calls from method to method
to just chaining of course which leads
to much more readable code but now I'm
not in the model I've written so far
because I've not really composed
collector what I've done is just changed
the calls of character using this
trimming trick what I really would like
to do is the following
strings ax dot streamer
correct and probably do some kind of it
will not be mapping anymore but mapping
yeah then correct filtering and then
collect tourists and it would this could
be really a composition of collector
because this time this subject here if I
if I can do that this subject here would
be a real character would be a real
character that I would be able to pass
as a parameter to a downstream character
what pattern do I have here
mapping is a regular collector and I
want to then collect on this regular
collector so clearly the real type of
this mapping object here which is
defined there is not collector itself
it's something that has to extend a
collector so it extends collector and it
also takes a collector as a parameter
file as a composed object since since it
needs a collector to be to be to be
created so basically this is in fact a
decorator pattern to to do that I need
to use the decorator pattern I'm going
to create a I'm going to create it in an
interface let us call it composable
collector
okay it's an extension of character of T
a its itself something we are going to
have fun with generics here let us
create those suppliers and stuff it
needs a a downstream character to be
created oh sorry
I want this guy to be an interface I
don't want you to be a class so
all this is removed okay I need to then
collect as a parameter that also takes a
character as an interface so this has to
be a default method that is going to
return the composable character here ta
are then correct and that is going to
take a composable character as a
parameter here and I'm going to call it
downstream okay so now the trick is the
collector I mean is a collector here the
mapping character that takes a string
and returns an integer right so this
this in fact is a string and this is an
integer okay if I check the correct I am
taking it takes an integer and returns a
it's a filtering but it could also be
another mapping so this character takes
an integer here okay and could return
for instance wrong there right so this
is a and the collector that is returned
is a character that is able to operate
on on strings and will return the return
type of this filtering here so it takes
a string as a parameter and it's going
to return a long there here
so I said that T was a stranger and I
was an integer okay
this is a longer this is a new type I
need to define this method right so now
I can say that this is a t this is an R
and this is another type let us call it
R so now I can return now a new
composable character of all those guys
and this type B I need to understand how
this thing is working and I've got only
three minutes for that it's going to be
really fast first I want to apply the
mapping character to my objects and then
one this character is fully applied on
them I want to apply the filter in
character on them
okay so basically the supplier is the
downstream downstream supplier doesn't
change anything the big consumer is also
the downstream accumulator the combiner
because it's a big consumer yeah
it's this one the combiner is the
downstream combiner what did I do with
the big consumer oh yeah Ramez stop with
the with the with the stuff this is the
downstream characteristics the only
trick is that and I won't have the time
to finish I'm sorry
and the only trick is is here since I am
going everything is going to be done in
the finisher right so this finisher
will do this kind of thing yeah it's a
function it's a function that takes the
container that has been partially filled
using this stuff so this container sorry
excuse me
this should be a streamer if it's not a
stream it's not going to work so this
finish here this container is a streamer
and it doesn't see that it's a streamer
which is really great okay I've got one
minute left I'm sorry guys I won't have
the time to do that do I have it
somewhere I think I have it somewhere I
just want to show I'll show it to you
really quick is it here yes this is this
is the finished extended character
so this is this is the the Zen then
collect method that takes this extended
character as a parameter the supplier is
the same the combiner is the same and
the the finish of in fact the final
collecting is just down down in the
finisher this is this is the trick to
achieve that the you take the finisher
of the crank character you apply it to
the current container it reads on the
stream because the because the finisher
in fact switch on the stream and you
just collect this using using this
downstream and this allows for the
further for the two to write on this
pattern become becomes possible with
with this extension character which is a
de character over the collector
interface you we can compose characters
and and and just create collectors
without having to nest the call in in
method calls sorry I didn't have the
time to finish this okay so yeah the
main issue was the anti stream and we
saw how to deal with it
we also could create an Instagram etc so
in conclusion very very fast very
quickly because the time is up the
collector API is indeed a very rich API
as you can see the way it has been
designed if you want to create
characters to process all your data you
have to nest things so you need to
decorate things if you want if you want
to keep your code readable nice thing is
that it's quite easy to extend them
thanks to this downstream collecting I
could I say sorry to the downstream
correctly mechanism once it's returned
this can be passed as a downstream to
another processing pipeline and I think
that this is really the key of the the
power of this API and that key it can be
made compatible to improve readability
sorry I couldn't show that to you I was
a little short on time 2 to 4 that the
time is up so thank you for your
attention
I hope you found the talk interesting if
you have any question well just
my sleeve outside of the conference room
you can check the code of the the stock
hopefully fixed and completed on my
github account in the next few days and
the slides on the on my SlideShare
account thank you very much and sorry
for being a little out of time thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>