<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Parallel and Asynchronous Programming with Streams and CompletableFuture by Venkat Subramaniam | Coder Coacher - Coaching Coders</title><meta content="Parallel and Asynchronous Programming with Streams and CompletableFuture by Venkat Subramaniam - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Parallel and Asynchronous Programming with Streams and CompletableFuture by Venkat Subramaniam</b></h2><h5 class="post__date">2017-11-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/IwJ-SCfXoAU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right good morning everyone welcome
to the sessions on parallel and
asynchronous programming with streams
and completable future my name is Venkat
Subramanyam we're going to talk about
two really exciting and very different
concepts available to us in Java and I
want to talk about a little bit just a
little bit for a few minutes about some
of the challenges we normally face with
concurrent programming and then of
course a jump into two different ways of
solving the problem the examples I'm
going to show you here will eventually
be done uploaded to my website if you're
interested you can download them from
their own loads link it doesn't exist
there today but by the time tomorrow
let's say about this time if you go to
the site you should be able to download
all the code examples that I'm gonna
provide you here so let's get started
well one of the things that we normally
do is we want to improve performance and
applications there are times when the
goal is to improve performance the time
also is where we want to make here the
application has a good responsiveness so
typically what we do to make these two
things happen is we turn towards
programming concurrency or
multi-threading well as it turns out the
one of the really nice things about Java
was right from the day one we had
ability to do multi-threading and
concurrent programming well
unfortunately though if you really look
at it we have been looking at solutions
after solutions for this over the past
20 years and almost every time we think
we have a handle on it it slips away
well if you step back in time to think
about what we did in the very first
release of Java we had the ability to
create threads and we eventually
realized that was probably not the best
thing to do creating threads is not the
most optimal thing to do maybe we want
to have really pool of threads so Java 5
introduced the executor services and
then of course we realized that
potentially costs a spool and used
deadlock then of course Java 7
introduced the fork/join API well we can
see that we almost solved every single
problem only to create more problems and
so looking at it how do we really
program concurrency well as it turns out
if we start creating arbitrary threads
and we start managing those threads we
end up with quite a number of
trouble over time when I when he used to
program multi-threading in Java
I had this suspicion that it's almost
impossible to do concurrent programming
in Java and get it correct and I'm gonna
say probably the most scariest book for
any Java program a programmer is Brian
gets this book on Java concurrency in
practice so before I read that book I
used to think programming concurrency
was really hard and after reading that
book I was convinced that programming
concurrency is absolutely hard and and
that is one of the real challenges of
this is it's incredibly difficult to
really get all the things wrapped around
in our head and do it properly well
thankfully Java has some solutions do
tame that beast so we don't have to
struggle so hard with it as we start
programming concurrency so what I'm
going to do here is to talk about really
two parts in this particular
presentation one is about the parallel
streams library and the other is the
completable future so we'll talk about
the parallel streams to begin with and
then we'll take a short break after that
and then we'll continue talking about
the completable future right after that
in this presentation so when it comes to
nature of the problem we have a lot of
times we have computations want to
perform and we want to perform with the
would speed we want to perform with ease
we want to perform may be to improve
responsiveness whatever the nature is
there are two kinds of solutions we can
seek when it comes to programming with
multi-threading one is where we may have
a collection of data and we want to
really process that collection of data
in a lot of different languages we call
these as arrays and parallel arrays
solutions so when you have array of data
or using the word array very loosely
here when you have a collection of data
you want to be able to process that
collection in parallel and that's
exactly where the parallel stream fits
in really nicely on the other hand if
you don't have a collection of data but
you just have a problem and you want to
divide and conquer this problem so maybe
this problem can be split into a smaller
part and then once you split into a
smaller part you can make a decision at
this point do you want to continue
splitting into smaller part or maybe
it's really small enough that you can
actually solve it right now that could
be another way to think about divide and
conquer
if you're looking at a
divide-and-conquer strategy a parallel
stream doesn't quite fit into it because
you may not even have a stream to begin
with well that's where a synchrony can
come and really help us to really set
this off to motion in a synchronous
manner you go off and do your work and
then that particular asynchronous task
you said either can't solve the problem
and get you a result back or can split
further and then eventually get the
result back to you that's where the
ability to do the splitting and then
putting it back together
can come in and those kinds of problems
really fit nicely for completable
futures as we will see a little later on
so with that said let's switch over
focus to talking about parallel streams
itself but before we talk about parallel
streams let's talk about one thing we
have been doing really well moving
forward there's gonna change
fundamentally how we approach problems
and how we solve them well in the past
we wrote code in the imperative style
just as an example let's say for a
minute if I have a list of numbers 1 to
10 and I want to really total let's say
all the even numbers in this collection
double of the even numbers collection
the real boring and you know a more
complex way to do this even though it's
familiar is to really start saying
result equal to zero and then start
doing a for loop you know maybe a four I
equal to zero and I start wondering how
to set the bounds or maybe we can say
given an element in numbers I want to
start saying that if element mod 2 is
equal to zero well then maybe I want to
really compute result is equal s equal
to e times 2 and then of course I can
bring back the results when I'm done
with this and display the result well
this of course as we know is the
imperative style of programming which
we've been doing for a very long time
but this is inherently more complex in
fact I will give you a challenge when
you get back to work do a grep on your
source code for the number of times we
use the for and it's gonna be really
scary and and this is a very traditional
for loop and maybe occasionally while
loop we've been doing but modern Fowler
has a beautiful blog post and his blog
post is called
collection pipeline pipeline pattern and
the collection pipeline pattern blog
post by Marv
Fowler and if you look at this blog post
he makes a good claim that we are going
to be fundamentally shifting the way we
start writing code so what we will do
instead is we'll say numbers dart stream
where that becomes internal iterator and
then we are going to say in this case
filter given an element element Mart do
is equal to zero and then we perform a
map to the you know int in this
particular example and we can double the
value given to us and then finally we
can perform a sum operation on that
particular object so this really becomes
a very nice compelling collection
pipeline pattern as we move forward and
as a result this really removes the
complexity that's in code and makes the
code a lot more easier to understand
easier to maintain but it's not just the
beauty of the code that really matters
I'm gonna say but this is something that
really I'm beginning to realize more and
more and we really want elegance so no
doubt about it right so elegance is nice
to look at the code and say it's
beautiful is nice but elegance in the in
the absence of efficiency is no good so
we cannot say my code is beautiful and
walk away and and elegance and the
absence of efficiency is absolutely no
good and that's one of the beautiful
things about Java is Java did not just
give us elegance when it comes to having
the functional style of programming they
also gave us efficiency and and one of
the beautiful things about this elegance
is it's also a nice pathway to gain
efficiency as well and that's one of the
real benefits we begin to reap at this
point so this function pipeline pattern
becomes very compelling moving forward
now one of the things we know of course
about the collection pipeline pattern in
Java is that it is fundamentally lazy
evaluation it will not go off and do
work unnecessarily and it will only do
enough work to get things away but of
course because the function pipeline
pattern is elegant because the functions
we create don't have any side effects
there are pure functions such functions
are easy to paralyze as well and that's
the
aspect we want to focus on in today's at
least the first part of the presentation
but as we do
I will also swing back to this
efficiency and laziness later on and
we'll address that and see how that's
going to matter as we go through so most
fundamentally this collection pipeline
pattern is one of the most significant
things we're gonna see moving forward in
generally in programming and especially
in Java is we going to start beginning
to use this collection pipeline for a
greater and a fluency of our code
expressiveness of a record elegance of
the code but also for efficiency as well
so we can go from the imperative to the
functional style of programming where
the code becomes a lot more decorative
but some of the benefits of this
pipeline pattern are I mentioned that
it's efficient it's easier to read
easier to understand easier to work with
it is also removing the accidental
complexity in code but one of the
charming features is it is easier to
parallelize so if I want to really
paralyze my code how do I go about
paralyzing such a piece of code if you
write a code which is imperative in
nature and somebody comes to you and
says let's make it faster let's make it
concurrent you're gonna find the nearest
door out and this is one of the things I
love about what Java 8 has done and we
cannot simply take this lightly so let's
talk about the dark days before Java 8
and and how was the past the past was
the following the structure of
concurrent code concurrent code was very
different from the structure of
sequential code and and this was a
nightmare right so your
sequential code was simple your sequence
your code was Pleasant and when you
wrote sequential code when you walk to
work you smiled at everybody and
everybody had a good time at work and
one day they told you you need to
improve performance and you started
putting multi-threading into your
sequential code and that's the last day
anybody smiled at each other and what
did you do you spend time at work
debugging this code throughout the night
and there are days when you probably
left the computer still blinking on the
debugger and the next morning you come
back and you realize
is that the pizza you left on the table
is on the keyboard now and you just move
it our way and start debugging further
and then want you to do after trying
this for a while you realize this is not
gonna win at all because every time you
touch the piece of code more bugs keep
creeping in and one morning you decided
you're done with it
so while you are debugging the code you
applied for the other job
that's called concurrency right and and
you said I'm done I'm not gonna do this
anymore
well that's really hard because the
structure of the code is so wildly
different it's very difficult to debug
it's very difficult to reason the code
and all their fur to put into making the
reasoning in sequential it's just gone
well the beauty is for the very first
time in a long time Java it did
something absolutely phenomenal so this
is the beautiful prescient and what does
the beautiful present look like and the
beautiful beautiful present looks like
the following right thanks to streams we
can claim that now the structure of
concurrent code and and this is
something we cannot just take lightly at
all is the same as the structure of
sequential code and and this is
remarkable because we don't have to go
through an enormous pain in order to do
this so looking at the code we have in
our hands right now if you notice in
this particular example I have the code
running sequentially right here and
produces the result but if this were a
very large collection or if the
computations here were time consuming I
don't have to put too much effort to
make this court concurrent all I have to
do simply is change this to a parallel
stream right there and now that runs in
parallel that's one option
alternatively I can also do something
else I can simply say starts parallel
here and then run it in parallel as well
so notice the structure of sequential
code and the structure of concurrent
code are exactly the same and and to me
this is a very fundamental feature of
streams is that the structure is exactly
the same and that takes away so many
problems from our shoulders so
what I'm gonna say here is that job
eight made parallelism a master switch
at least in this in this very
restrictive context so parallelism is a
master switch well why is it a master
switch and the reason I call it a master
switch is I often have developers ask me
well if it is so easy to do and if it's
so simple to work with why didn't they
make it parallel all the time and the
reason is very simple they gave this
master switch and if you really look at
the documentation there's a fine print
that has the word think in it because
they want us to think about turning on
the switch and before you flip that
switch you want to think several times
it's easy to parallel eyes but doesn't
mean we have to really parallel eyes we
have to ask the question does it make
sense to parallel eyes or not so let's
talk about these things in here let's
start start with the sequential
execution and then we'll go towards the
parallel from there so let's take a
fairly simple example here and work with
it let's take a collection of let's say
these three numbers and play with that
I'm going to create a little silly
little example to illustrate these these
things so we'll say over here is static
let's take transform and in this
transform function all I'm going to do
simply is to take a number and for now
I'll simply return the number itself not
a whole lot of transform in reality but
this gives us an ability for us to
understand how the code works without
having to think through all these
computations so what I'm going to do is
number start stream and then I'm going
to then say of course perform a map
operation where I'll call the sample and
perform the transform operation and I
would say for each and system dot out
and we'll just print it so in this
example as you can see it's a very
little operation that just transforms
the values into the same value and just
prints it out but let's talk about the
transform itself in this example we are
doing a sequential execution but how do
we turn this into parallel well there
are two options are like I mentioned
that are available to turn this into
parallel one is if you are at the source
of the stream you can say parallel and
perform the conversion to a parallel
stream this is very useful if you are
the creator of the stream itself then
this
is clearly a easy way to do this you can
just say parallel stream and then
execute that in parallel and you can see
the output sequence is not the same
that's a little proof that it's running
in parallel but on the other hand if I
had said stream over here you can see
that the sequence is still the same as
in the original so you can see that it's
you know give us a hint that if
something is happening a little
different at least so this is one way to
really achieve it but what if you are
not the source of the stream if you're
not the author of the stream or the
creator of the stream of what do you do
then
so in this case for example you might
have a function that says for example
work with let's say work with stream
where the work would stream may receive
a stream let's say in this case an
integer stream as an argument well in
this case you could say stream dot map
and you can perform some operations on
it but if you are not the creator of the
stream obviously you cannot do parallel
stream at this point that's when you can
say dart parallel and then as a result
as a person receiving a stream you can
decide to run the stream in parallel
because you don't have the luxury of
saying parallel stream at this point so
you can pick and choose what may make
sense if you're the source of a stream
use parallel stream if you're not a
source of a stream but you are receiving
a stream and you want to make it
parallel then use the dart parallel and
you can go back and forth in fact this
is even another benefit you get out of
this as well I'm doing this on my
project at this time we have a stream
but we don't know whether to run it in
parallel or to run it sequentially
because that depends on a lot of
different things so we may even receive
a parameter to our function for example
you may say comma a boolean and then you
could say run parallel and then of
course I can come in here and say
something there are several ways to do
this but here's one example if it is
running parallel I can then say stream
over here is equal to stream dart
parallel or are you can create another
variable rather than changing the input
given to you so this could be a and then
you can start using that stream well it
depends on whether the run panel was
true or false you may decide to run it
parallel or sequential like I said there
are multi
different ways to alter this this is
just one trivial example of how you can
achieve it but I would definitely give a
different name than changing the input
and then use that variable throughout
the code after this so we saw why we
would use maybe a parallel stream versus
a parallel call but there are a few
things we have to be very careful about
when it comes to these things so we can
go from stream to parallel stream but
let's observe the throughout of
execution just a little bit to get a
feel for what thread is going to execute
this particular call
so don't understand this let's go ahead
and put this back into our regular
sequential stream but in the transform
function let's go ahead an output let's
say transform and then we will go ahead
and output let's say thread dart current
thread right here when we do this of
course we want to know what thread is
executing all these calls and then when
we run it we can see that all this is
doing is running it in the main thread
and that's of course no surprise at all
because we're doing this sequential E
but on the other hand if I were to go
ahead and make this a parallel stream
whether I make it a parallel stream
right there or do a parallel right here
then of course we noticed that it's no
longer running in the main thread it
actually runs in a combination of
different threads sometimes it's a main
thread
sometimes it's the thread from the for
join pool we'll understand why that is
just a little bit later but you can see
that it's actually varying the different
threads that's running this which is
definitely a good news as well so we can
see how this is running in parallel so
we can change it and see that the thread
of execution is actually different but
having said that though we need to be a
bit careful about a few different
details when it comes to this now if you
may wonder if there is a call to
parallel maybe then there is a call to
sequential as well and and and it turns
out there actually is so in this case I
made it parallel but then I turned it
sequential and of course now it's
running in sequential E but this begs
the question maybe this gives us a
little idea it says aha look at how
beautiful this is I can run the map in
parallel and then run the for each and
sequentially unfortunately that's not
really true so I'm in this particular
case
the last one actually wins so if your
last call is sequential then the entire
pipeline runs sequentially if the last
call is parallel then the entire
pipeline runs in parallel so notice even
though we said parallel here or you
could have said parallel stream when you
created that even though the parallel
appears before the map and the
sequential happens after the map that
transform is not going to run in a
parallel as a parallel stream it the
entire stream is gonna run sequential II
at this point that is the nature of how
this actually is built so you're not
really making parts of the code run
parallel and parts of the code so if you
have this vision that I will have a
pipeline but segments of the pipeline
will be parallel and segments of the
pipeline will be sequential
that's a nice vision but that's not what
streams do for us so the entire stream
is either parallel or the entire stream
is a sequential depending on what we
configure it as the last one or what we
started out with so something to be a
little bit careful about but that brings
up the question then if we go back to
this code here I want to run this in
parallel or in this in sequential let's
comment out the output for just a minute
run the code you can see the output is
one two and three
well remember the given collection is an
ordered collection if this were a set
and not a list we know a sect is
unordered when asset is unordered
there's no guarantee on the ordering so
streams will not pretend to try to
impose an ordering on what is not
ordered unless you introduce a method
that requires ordering somewhere in
between so what is the streams order
well the streams order is whatever order
it starts with or whatever order it's
influence in the Midway but on the other
hand when it comes to parallel parallel
does not impose any ordering even if the
original collection had ordering in it
so there's a good news and a bad news
here as you can see when I run this code
sequentially the ordering is preserved
because the list had an ordering one two
three and the result was one two three
as you can see in fact let's go ahead
and put this to our original collection
of lists of numbers one to ten
this case when I run as you can see the
ordering is 1 to 10 on the other hand if
we were to change it to a dart parallel
right here and in this case of course
running it parallel what does that do
then well there's no bit on ordering at
this point I'm just gonna run this on
the command prompt so we can actually
see this a little bit easier when I run
this you can see the ordering is
completely different it was 7 6 8 1 but
the next time I run it it is 7 9 8 5 and
who knows what the ordering is going to
be the next time 7 2 5 3 so we cannot
guarantee what the ordering is well
there's a good news and a bad news the
good news is if these computations were
taking kind to perform you're not
waiting for those computations to finish
you can start multiple computations at
the same time so you can get speed but
unfortunately though there's no gal
ordering of the output what if you go to
a customer and say I got a good news and
a bad news I produce a report really
quickly for you but good luck you know
putting the pages back together that's
not gonna invite good customers for us
back to us because what's the point in
producing such a result so fast that the
output is completely jumbled up well the
key here is there are ways to really
control the ordering so how do you
execute execute the operations in a
certain order well the way to really
execute this in a certain order is there
are a few methods that can impose
ordering for you now there are some
methods that will quietly impose order
without you even knowing or telling it
there are other methods that will impose
order only when you specifically use
methods with a certain name clearly in
this particular example we'll see a few
more later on for each is not ordered
and as a result there's no guarantee on
the ordering on the other hand given the
scenario as we just saw when there is
absolutely no ordering being imposed
what if I go back here and say for each
ordered over here when I say for each
ordered notice that it will impose the
ordering so no matter how many times I
run this it is going to have exactly the
same ordering let's not confuse the for
each ordered
sequential execution it is not
sequential execution it is just
serialized in the order in which it is
going to execute just to illustrate this
point let's go back to this example and
look at it slightly differently rather
than calling a print Len let's call it
as sample let's say print it well print
it is going to print out the result for
us so we'll create a printed method
right here so we'll call this as void
print it and then it takes a number and
all it's going to do is simply output
the number well in this case of course
it's gonna output the number well we're
not gonna see anything really different
other than you know just seeing the
number again when we call the print it
and that's the print it is going to
simply return that result for us well
that's great but I want to really print
out one other piece of data when I'm
printing the number itself I'm gonna go
ahead and then say thread dot current
thread so we can actually see the
throughout of execution of the printed
now if I were to run this in sequence
rather than parallel it's no surprise
that you will see that all of these are
printing the number from the main thread
no doubt about it
on the other hand if I were to put a
parallel on this notice that in this
case it is going to print but the
threads are not really the main thread
that is still running in in parallel
threads but notice the sequence is
followed what really gets exciting in
this case is if I go back to this code
now and print the current thread dete a
data right here and we'll along them
along this will also print transform
Plus let's say number plus and then so
we can actually see what number is being
processed right now but then we will go
ahead and say over here sleep sleep and
give it about a second delay if you will
so we can actually see thank you so we
can see that in this case we have a
second delay on this call and so we can
see that it's really going to delay this
a little bit and and execute this call
as you can see if I give a two second
delay maybe it uses a little opportunity
for us to notice that so when I go back
and run this little code you can see
that the transforms already happened but
notice four nine seven five three was
the sequence four was done and nine was
done and seven was done
1 &amp;amp; 2 are coming much later in the game
but when you look at the output though
you can see that they follow the
ordering so even though the code ran in
parallel it simply says I am ready to do
my part in my thread but I'm going to
wait until you finish your part in your
thread and then this can kick in and do
the work so so that's why it is still
concurrent execution but an ordering is
imposed on that particular execution in
the terminal stage at this point so
these kinds of terminal operations can
help us to impose ordering which is very
important in a lot of different cases
for example in this case you can see the
for each ordered made a difference but
another place where the ordering is very
important is when you ask for fine first
if you ask for find first you definitely
want the first element that satisfies
you were you know expectations and
predicates and whatever you provide so
the ordering is still important you
don't have a fine first ordered find
first is always ordered so you don't
have to say it at all so fine first will
always give you the first element that
meets that particular expectation so
there are certain methods that always
impose ordering even when you run them
concurrently whereas other methods may
require ordering by using a special
flavor of those methods to get you that
particular call so that's basically
about how we can control the ordering
but that brings up the question what are
the things I can do in parallel well
clearly we can do filtering in parallel
which is really a nice thing because if
I want to do filtering why would I want
to wait so what is filtering do
filtering says give it a collection of
values I'm gonna cherry pick a certain
values and drop other values well the
good news is if I want to pick a certain
value I don't have to look for its left
or right or other values it is by the
merit of that value either I pick the
value or I drop it well in that case I
can simply do that concurrently given n
number of values I can concurrently
decide if any of the values are
something I should pick or not pick I
don't have to wait for the doing that
sequentially
so clearly filter can run in parallel
let's see if that's actually true in
this case so I'm gonna go back here and
say dark filter and then this case would
say sample check right here again this
check is not gonna do real check at all
but just for us to observe the values
we'll do the check so in this case we'll
go ahead and call the check method this
is going to be boolean and then of
course there's going to be a check and
what am I going to do within the check
well I'm gonna simply return let's just
say a true value but I'm going to go
ahead and call this as a check and I'll
print the number and the thread
information also so we can return it so
I'm doing a filter operation on the
check and then of course once I filter
it I'm going to simply print that a
result in the ordered fashion if we go
back and run this little code now you
can see again the filtering happened
almost you know in here in an arbitrary
order but then of course eventually the
for each is ordered
so the filtering can happen in parallel
to that works really nicely so filter
can be in parallel mat can be in
parallel so we began to think about this
and say is there something that maybe
shouldn't be run in parallel
hey what about reduce let's understand
what reduces before we talk about what
that really means well in terms of
parallelism so let's go back to this
example remove all of this and let's
talk about the reduced function I'm
gonna call the reduce on the stream and
say reduce and I'm gonna provide a value
0 and then I'm gonna provide a total
comma element and I'm gonna call a
function called add and I'll pass the
total and element do it well how does
the reduce method actually work well the
reduce method is by the nature of it is
going to in this particular usage it's
gonna reduce the collection into a
single value so if you had a collection
let's say 1 2 3 4 and such well what
reduce is gonna do is it's gonna first
start with what's called a initial value
well the initial value could be a value
of 0 as we gave on line number 26 and
then we take that and we
to some kind of an operation the
operation could be whatever that you
call in here I'll just put it as up
whatever the OP means to you
well it's gonna take this value and this
value here perform this operation take
the output and then perform the
operation one more time and in this case
of course it's going to send it off to
this and then of course then it's gonna
take this one here and then take the
result of that perform the operation and
then it's gonna take the result of that
and perform the operation and it kind of
goes on with the sequence until it's
done with it and produce the result in
the very end so in a sense what this is
going to do in this example is we're
gonna take the value of zero and the
zero is fed in as a total in the
beginning so remember the initial value
is the input to this operation the
current element in the collection
becomes the second value to the
operation and the result of that is
actually fed back in as a total in the
next call and the second element becomes
the element the result of that becomes
the total and the third element becomes
the element and then so on so this
becomes a operation where we keep
marching through the elements as we
march through the elements we take the
result and then we feed it back and take
the result and feed it back and it just
keeps moving forward like that let's
take a silly example of how we could
potentially use it we got a room full of
people here what we could do is we could
say I want to perform let's say that
total of everyone's age in this room
starting with a person on the and on my
far right he's not smiling anymore
I'm not going to ask for your real age
so I'm gonna send you a zero let's say
initially you take the zero you totally
your own age with it pass it to the
person next to you he takes his own age
adds the total given from his left and
passes it down and we can just sit there
and watch this value go through and one
row at a time and what we eventually get
from that last person up there most
likely is going to be an overflow or
otherwise we're gonna get the result of
it and and and so as a result that's
gonna trickle through it looks like
that's a pretty darn sequential
operation after all because we have to
just popping through every single value
and perform the computation well it kind
of appears that way in the beginning but
we'll come back to this in just a minute
so what I'm gonna do here is I'm gonna
say public static let's say int add
we'll call it as total comma in element
and then in this case I'm gonna simply
return let's say a result of this
totaling but what in the world is result
result is equal to we'll go ahead and
say this is total plus element and as a
result what I'm gonna do here is output
let's output total over here with the
value let's say total and then of course
we'll also output let's say the element
e with the value E and finally we will
output result with the value let's say
plus result so as a result we have those
different things so as a result we gonna
just output those values as we run
through this and you can see how that
propagates through notice the zero which
is initial and one produces a result of
one but one became the input to total
and the result is three that became an
input to total you can see that output
on the right side carry over to the left
side that's the feedback that we talked
about and the result is fifty-five now
we can all agree to one thing when you
do an operation parallel you'll be very
happy if you get the result faster but
you should never get an incorrect result
when you run parallel if you want to run
code really fast and you don't care
about result being really wrong then you
should go back and program in C++ but if
you really because we care about
performance and nothing else in that
world isn't it but on the other hand the
correct result should be obtained and it
should be faster as well so how do we
really do that well in order to do this
we're gonna say what if this is going to
be running in parallel well let's go
back to the example we talked about I
want to total the age of everyone in the
room well I can realize suddenly I don't
have to do this sequential e I don't
have to start the value 0 here under
value trickle through the room and this
is there and just watch them till the
cows go home instead I can say hey folks
we have several rows in the
room and we also have several columns of
you know chairs in this room so for
every segment in the room we're gonna
take every row and let the people in
every row do the totalling on their own
row so for example the first row on my
right side is going to do totalling in
the same exact approach and while the
first row bites totaling the second and
the third and the fourth row is going to
do that similarly in the middle section
here we're gonna have people doing
concurrently in each of the row and so
in that in the corner section as well
now we can see we can have concurrent
execution for every single row in the in
the room in every single column but then
what we can do is at this point the
people on the very right side of each of
the row are going to hold on to the data
for the total of their own rows now we
can turn around and run through this way
because this becomes a row of all the
columns and we can do a totaling and
similarly on this one and this one then
we can take these three values and
combine them together this of course
makes sense when these operations can be
combined in that way so just because we
can run in parallel mean it makes sense
to run in parallel it's got to make
mathematical sense to do this based on
the problem we have on our hand but
assuming we can do this what would what
would it what what would it do then well
let's take a look at this real quick
before we go further if I run this
notice that is the output we guard just
sort of curiosity how many rows of
output did we have right now that was
about 11 rows it doesn't matter how many
times I run it's always going to be 11
rows because in this give an example
with the same input along busy eleven
because we're gonna have ten elements
and remember we are just hopping through
every element that's 11 computations
overall to get the result through it
well with the final resulting the
eleventh one so that's kind of obvious
on the other hand if I do a dart
parallel on this remember what we just
said we're gonna take each of the rows
and do the work at the same time but
what does it mean rows when it comes to
the collection
well the streams internally have the
ability to do things in parallel as well
and so they can start doing these
computations in parallel so as a result
now notice all I did was I turned on
parallel on this now when I go back and
run the code this time you will notice
there is a lot more number of lines in
the output not only that notice there's
a total of 0 + 6 0 + 4 0 + 9 so you can
see all these totalling happen and then
you can see the combination of those
values come together good news it is
still 55 in the very end but how many
lines are we seeing in the output well
that was 20 instead of 11 this time who
knows you know what the value will be
depending on the size of the input but
you can see that it actually did this in
parallel as well so what are they
actually doing well what they're doing
is they are saying we don't have to
really wait for this to be done
sequentially we could start off this one
with a while this totaling is being done
for this we could start off this as well
and this as well and this as well and so
on but here also comes the good news and
the bad news good news says reduce also
runs in parallel but we have to really
understand what this is doing because
otherwise it'll be really a problem so
let's get back to this example one more
time let's just look at it sequential ii
when we run two sequential e one more
time notice given these input the output
is 55 well that is the value no doubt
about it but I get this you know a
desire to not only total these values
but I want to total the values and add
it to may be yet another value like for
example I want to total the age of
everyone in this room but I don't want
to start with the zero I want to start
with my own age so I'm gonna put my age
over here so you don't believe it okay
so I'm gonna start with my age and here
and then start propagating that value
down through the chain so you know I'm
gonna type to somebody said ask me what
is the base of the age and I'm never
mind that okay so the point really is we
can propagate through the chain and then
have the total well here's the good news
when I started with the zero it was a 55
if I start with a 21 it's very clear it
is going to be 76 no
what so that makes sense but be careful
though this is not an initial value this
is a misguided view of the world if we
think its initial value so let's step
back and ask what is that value so the
value that you pass to reduce is
actually it's it's an identity value so
what is an identity value when the case
of a sum the identity values is a zero
no matter what you total with the X zero
no matter what you total with zero you
always get that value back similarly in
the case of a product the identity value
is a 1 no matter what you find a product
with 1 you always get that value so be
very careful this is an identity value
why is that so important notice now I
put a 21 which is not an identity value
when I run this it gives us 76 but
unfortunately if I go back and say dart
parallel right here then the result is
no longer 76 that is all of a sudden
some other value which doesn't make any
sense at all so the model the story is
don't do this so what is the thing we
should do really keep in mind this is a
initial value that we should give in
here so what is the right approach to do
this the right approach to do this is to
say 0 here and then when the result
eventually comes out then you do a plus
21 and it is okay to do this so this is
okay not the other one so notice if we
ran it in parallel but we still got the
consistent value of 76 so we have to be
very careful when you call reduce make
sure what you're sending here is an
identity value not an initial value so
what you really want to do if you want
to really take the result and do some
other totalling with it then of course
you have to do that over here and not
over here and as long as we understand
these things we can leverage parallel in
those areas of code as well very
effectively so that's what we just did
we saw the effect of making the reduce
parallel as well now let's talk a little
bit about using the barrel
the question now is you know how many
threads can I create so let's ask the
question how many threads can I create
now be very careful this is like asking
the question how much can I eat not a
good question when when I asked this
question I end up putting too much on my
tummy this is not healthy so no don't a
not a good question and and so the real
question really is what is the question
I should really ask and the question I
should ask is how much should I eat well
it's the same exact thing how many
threads should I create there is a very
big difference between those two
questions so it's not about how many can
you in fact you can't create as much as
the memory will hold like I can eat as
much as my stomach will hold neither one
of them is actually a good thing so what
what is the answer to how many threads
should I create well it turns out there
are some reasons why certain things are
done in a certain way but before we
answer that question let's you know talk
about two different things that we
should be concerned about if I am doing
a computation intensive operations if my
operations are computation intensive
what does that mean I'm doing number
crunching you throw data at me and I'm
gonna start using the CPU and you can
sometimes you can hear the CPU feed of
the fans running you can see the CPU
really being pegged at the top if you're
running a CPU intensive operation then
be careful number of threads that you
create is less than or equal to and this
has to be less than or equal to number
of course this is something you have to
be very very very careful about if you
are job is computation intensive you
should never have more threads than the
number of course now why is this so
critical to follow well imagine what's
going to happen your tasks or
competition
they have a very high demand on the cpu
so the task is running on the CPU what's
the worst thing you can do now you can
go to this task and say excuse me could
you please get off so I can get back on
do what you're doing which is kind of
pointless isn't it this is like there's
a stupid example I'll talk about let's
assume that there are four monks and you
know how polite monks always are so
there are four monks but unfortunately
they go to a gym and there are only two
thread a treadmills so the treadmill d1
and a treadmill t2 so two monks get on
the treadmill as soon as they get on the
treadmill they look around notice there
are two monks waiting for the treadmill
and being ever so polite that the monks
say oh my gosh you are waiting how rude
of me to use the treadmill when you're
waiting and they get down and the minute
they get down what happens the other two
monks get on the treadmill and they look
around say oh my gosh you are waiting
for the treadmill how rude of you and
they get down and they never work out
this is why it's important it's good to
be rude sometimes in life so the point
really is just killing the point really
is that you don't want that to happen
you want to get on and say you know what
it's my time I'm gonna just finish up
this and when I finished my workout
maybe you can get on or maybe that's an
opportunity for you to go find more
treadmills to you know work out well
it's exactly the same idea when you have
a competition intensive you never want
to give more threads than a number of
course what will happen if you do well
if you kind of imagine this graph in um
in your mind let's say this is going to
be the vertical is the time it's gonna
take so a vertical part is time let's
say the horizontal is going to be the
number of cores on your machine so I
have a number of course let's say you
have a competition intensive job on your
hand with one core on your let's say you
have number of threads is going to be
equal to one let's say sorry this is
number of threads now if when you have
one thread in your job maybe your
performance was was that so it took that
much amount of time maybe now you give
two threads and you notice hey this is
great I got a little bit of a better
performance I got to read threads maybe
it's even doing a little bit better this
is giving you hope now
let's say you have on your machine for
course well if you have four cores
you're gonna hit that spot right there
that's gonna be your performance now you
have five number of threads remember the
number of cores let's say you know cores
equal to four on your system but the
number of threads now is five which is
more than the number of course now you
will start seeing degradation in
performance and the more you go here you
might actually do even worse in fact you
could even do worse than you were
sequential execution I managed to do
this on my client project which was not
fun at all they gave me a piece of code
that took 30 minutes to run and I
realized it and it took 4 hours to run
and they lost all the faith in me when
they looked at this they said thanks man
kid this was a really phenomenal
improvement we forgot to tell you we
want to make it faster not slower oh I
forgot to see the requirements sorry
well the point is we're kind of playing
with the we got greedy and we said what
have we increased the threads and this
is like the Golden Goose problem right
you're trying to get more out of it and
you end up actually totally killing it
so you have to be very careful again
take this graph with a grain of salt but
the point is you're gonna peak at the
number of cores and when you increase
the number of threads to more the number
of course you're gonna lose it and as a
result you don't want to put more on it
we'll look at an example of this a
little bit later well okay so we don't
want to keep increasing this so that's
about computation intensive operations
but what if I my computations are i/o
intensive operations if my operations
are io intensive what does that mean
well I got some work to do on my CPU but
I'm going to do some IO
I may read to a rate of read a file I
may write to a log file I may read from
a database I may write to a database I
may send a request to a remote server
whatever that I do I don't have a use
for the CPU let's say you were 0 less
than blocking factor what in the world
is a blocking factor the amount of
Dreier of time that you're not going to
use the CPU well if I'm not using the
CPU
no amount of time i'm cpu-intensive
that's why I'm saying this is great
greater than zero at zero IM cpu
intensive and it is less than one
because at one I have deadlocked I have
no hope of ever progressing so I don't
want to be zero because I'm computation
intensive I don't want to be one because
I am deadlocked but if my value is
between zero and one
what does that mean if my value is
between zero and one then I have a
little bit more to do here I can now say
the number of threads is less than or
equal to 1 minus the blocking factor now
what this formula tells us is if you are
I are in - if your CPU intensive your
value of blocking factor is 0 1 minus 0
is 1 so number of cores divided by 1 is
number of cores make your number up
threads is never greater than the number
of course on the other hand if you're a
blocking factor is 0.5 that means you're
sleeping half the time when you're
sleeping somebody else could use the CPU
so it's number of cores divided by 1
minus 0.5 which is number of course
divided right with 0.5 which is twice
the number of course so you can give me
2 times the number of course if my
blocking factor is point 5 on the other
hand if my blocking factor is point 9
you can potentially give me 10 times the
number of course so the more i/o
intensive I here I am you can give me
more threads assuming I have enough work
to do that is if I'm CPU intensive you
drastically come down to the number of
cores never give me more than the number
of course I have on my system so this
becomes very critical to do now we can
see why Java is doing things in the way
it's actually doing so we can talk about
these things so the question is how many
threads am I really getting before we
can answer that question let's ask the
question where are these things actually
running so to answer that question we'll
just keep the transform method right
here and get rid of the remainder of the
things and now that I have my transform
is here I'm gonna print on my transform
that thread in which this thread is
going to run
on the other hand we're gonna go ahead
and call the map method over here so
we'll just go ahead and say on the
collection we have numbers we're gonna
say over here let's say numbers start
stream and in this case let's go ahead
and say dot map sample let's say on this
one transform and then of course we'll
go ahead and say that for each will just
swallow that little value that it
provides for us so given an element
don't bother anything to do with it so
this is going to display the thread in
which the execution is running and
obviously in this case the thread in
which it's going to run is going to be
the the main thread that we are really
interested in using at this particular
point well we got a little two-second
delay after that it's going to display
that value well that's great but in this
case of course if I were to relegate
this to a concurrent the parallel
threads what is it going to do well
that's going to run in a parallel stream
rather than running it on a sequential
tree a stream after all so to show that
it's running on a parallel stream we can
turn on the parallel and what we going
to see at that point is if I say dart
parallel right here that's going to run
on on the parallel stream but what
thread is going to run on is the
question if I go back and run this code
this time you can see that it ran on the
fork/join pool but common pool well ok
then let's take a look at that real
quick before we do let's get rid of
these things just for a minute we'll
come back to these let's go ahead and
ask the question output let's say run
time over here and then dart get run
time and then we'll ask for available
processors so we can find out how many
cores are available on my machine by
asking for available processors so this
is going to tell us how many cores are
in my system so let's go ahead and run
this one and it tells us eight which is
a lie by the way but it tells us that
that's how many cores I have it's using
hyper threading and gives me twice the
amount I wish my salary was
hyper-threaded to but anyway that's
basically what it's giving us that it's
just giving us that twice that amount so
right there is my output available
processors well it says we have eight
let's now ask the question for join cool
over here
I'm gonna say pool is equal to four join
pooled art in this case I'm gonna say
common pool and get access to the common
pool so let's go ahead and bring in the
Java dot util dot concurrent right there
so we can ask for the common pool
information once I get the common pool
the next thing I want to do here is
simply output the pool so we can take a
look at what it tells us now remember it
says I have eight cores on my machine
but when I run this code here it tells
me by parallelism right here is seven so
my fork/join pool common pool rather
contains one - or our number of course -
one so it just has one shy of it why is
that the reason for it is becomes really
evident when we go back and take a look
at this this this solution one more time
let's go back to this code one more time
and take a look at this particular
execution so when I go back and run this
little code you will see that it
displays all these details but did you
notice while the transform is running in
the common pool our main function is
main thread is such a wonderful
civilized thread it says gosh I have
nothing to do let me be part of this
little fun you're having here so as a
result the main doesn't sit there and
twiddle its thumbs while the main is
blocked the main course often does some
work this of course we know as
work-stealing so work-stealing is very
essential to make sure we have better
utilization of threads our main is going
through work stealing right there well
the main is being blocked as a result if
you notice it is going to be blocked
here you know let's say a done well the
done is going to be printed by the main
thread obviously so if I say plus a
thread dot current thread that's
obviously going to be the main thread
and of course the four each has to print
the result before it can come out of it
but on the other hand if I go back and
run this little code you can see that it
has not printed done yet and when it is
done with the whole thing it says done
from the main thread but in the main the
meantime the main thread was
participating
in the job right there so now you know
why the common pool has one less thread
than the number of course because main
is actually part of it main is sitting
there and saying hey the common pool
you're seven I'm one we'll work together
in fact you can see how careful they
were in making sure they conform to that
formula it is less than or equal to had
they created eight threads in the common
pool and if the main had still
participated in that that would be a
violation of that formula you don't want
to exceed ever when the computations are
computation intensive but the point is
they don't know what your computations
are so the safe bet is to limit this to
number of course if your competitions
are if your work tasks are not
computation intensive if there are
intensive you can create more threads
but they shouldn't do it for you by
default so they're really being careful
at that point so we saw how many threads
are in there we saw the formula for it
we saw the default number of threads
available for us as well but how do you
then change the number of threads that
you are going to have one way to change
the number of threads is to use this
setting at the JVM level but before we
do this let's take a look at one other
thing notice that I have values in here
around the ten values let's go ahead and
say we're gonna have to warn eval use to
work with so in this case I'm gonna
simply say this is let's say 11 12 just
for the purpose we'll say these values I
want to work with right here so given
these values what am I gonna do at this
point well if I'm gonna run this in
parallel and display this result let's
see what it's going to display I'm gonna
remove this to produce a little bit of a
less noise so let's go ahead and remove
that part for a minute so we'll just
stop it with this and it's going to
print the number when I go back and run
this code you can see it prints the
numbers right there and again and then
again well what are we seeing what
remember it says my machine has eight
cores
after all if I have eight cores well
then what happens is I have 20 values
well because the computers that are most
in the same amount of time it is
by 20 over in this case eight after all
so that is going to be about three
batches soft computation so you gotta
see three batches of computation eight
and then the remaining eight and
whatever is left over there is going to
come in into the third batch so when you
run this no tears here is the first
batch one and then the two and then the
third one right there and then it's done
so that is in three batches it executed
that as you can see so the three batches
mainly because based on the number of
threads we have and and it says I'm
going to do that first back when it's
done I'll do the second one and then
when the third one is over I'm done and
it produced a result oh great on the
other hand what if I increase the number
of threads for this well I can increase
the number of threads by using this
entry called Java dot util dot
concurrent dot for join fool.com and
dart parallelism I just love this flag
because finally something longer than my
name so you can see that you can just
configure this and change it but I don't
want to type this obviously I would get
carpal tunnel syndrome typing that one
so put this into a little script so we
can run it and see so I'm gonna have a
run config and I'm gonna that's all I
did
I'm just running the Java program but I
have provided that flag with a variable
I can send the value to so that's all
run config is doing just taking the
value and sending it to that particular
flag but I'm gonna ask you to run with
50 threads and when I run this you can
see in this case burst one and that's
done so all that ran in bursts one say
put them all into one thread and said
run right now but of course in this case
we are giving it more thread well the
good news and bad news the good news is
you have this flag the bad news is this
is a terrible flag to use because if you
use this flag you are changing your
entire JVM level common pool and this
can be a disaster in the making because
how do we know what kind of computation
is going to perform throughout our
application there could be some things
that are computation intensive some
things that are IO intensive but if
we're going to go back into the common
pool we
go make the performance really worse so
the general model of the story is learn
about this flag and avoid it and it's
better to not use this flag because
unless you're doing something very very
specific and like I know this is exactly
where this makes sense to use kudos use
it but the chances of that happening is
extremely slim so we have to be very
careful adopting to this in general so
don't just do get too excited about it
well you can also configure the flags
programmatically in your application as
well but before we do that let's
understand how these things actually
work now let's go back to this code for
a second notice in this example where is
the terminal operation happening the
terminal operation is the for each and
the terminal operation is happening in
the main thread well that's where I'm
calling this so I'm calling the for each
in the main thread but remember what
main is part of main technically is part
of the four join common-pool so when you
call this in main main says oh you want
to understand parallel I'm gonna run it
in my pool well what is my pool for the
main my fool for the main is the the
common pool and as a result it's done
running in the common pool but if the
terminal operation is being executed in
some other thread which is in some other
pool then it would use that pool so to
understand this let's take a little look
at a little example here so I'm gonna go
back to this code I'm gonna go ahead and
create this all the way up to here but
I'm not going to call the terminal
operation instead what I'll do here is
I'll bring in stream and I'll say this
into a variable right here so stream of
integer we'll call it stream is equal to
and we'll just save this into that
stream variable that's all I did now
that I've saved into a variable let's go
ahead and call a method called process
and pass the stream over to the process
method let's go to the process method
now so public static void let's say
process this takes a stream let's say
off integer and in this case I'm gonna
say stream and all I'm gonna do is
simply say streamed
for each and in this case we'll just
swallow the result that is given to us
and we'll just do it this way so again
no big deal we're just doing still in
the main but it's a parallel stream that
we are using so when I go back and
execute this code now you can see that
it's all going to run in the four client
common pool in fact we'll take a look at
that right here to make sure that it's
actually in the common pool so go back
and execute this little code and and see
where that's that's going to run so when
you go back and run this little code you
can see that it's all in the common pool
that it's running great well now that we
saw that result now let's get back to
this code and say well I'm gonna create
a fork fork join so in this case pool
and this form join pool that I'm gonna
create let me make sure that have
concurrent up here yeah I do so and it's
a pool is equal to new for join pool oh
let's say of about 50 threads and one of
the things I normally like to do is to
immediately say a shutdown and then that
way I don't forget it then I'm gonna say
pool Dart a wait
let's say shutdown and in this case I'm
gonna provide for asking it to wait for
oh how much time should I ask you to
wait let's say give it about 10 let's
say 20 30 seconds so this is gonna be
time unit dot let's say seconds so I'm
gonna ask you to wait for a little a
little while now while it's doing this
this is going to be just waiting on the
pool and giving us the result after all
wait for that time to shut down and this
of course requires us to await shutdown
let's see a wait termination right not
shutdown so away termination that's
going to require us to handle the
exception will simply say throws
exception and not deal with it and then
of course the beauty of this is we get
to enjoy this privilege all the way
through up the chain so now that we have
that we can simply say what do I want to
do within this call well what I want to
do in this call is I'm gonna say pool
over here dart submit and within the
submit I'm gonna take the stream given
to me and say for each and I'm gonna ask
it to take the L
and given and of course simply ignore it
so this is going to run the 4/4 eat the
terminal operation but with them that
pool we just created no longer the
common pool after all now when I go back
and run this little code we can well
let's see what happened here
unchecked oh this is even better so more
exceptions to handle this is awesome so
in this case of course what I'm going to
do is run this within that that
particular pool that where I want to run
this and and this is going to be that
particular stream the lowercase s that's
what was complaining about so I'm gonna
run this within here and as a result you
can see those are from the fork/join
pool rather than the common pool the one
worker so we can see that in this case
it's all that little threads we create
in our code rather than the in the pool
rather than the common pool itself so we
can ask it to run in a completely
different pool by simply creating our
own pool and making sure the terminal
operation runs within that particular
pool and as you saw here it is not where
you created the stream that really
mattered what mattered was where you ran
the terminal operation for that
particular stream that that makes a big
difference so so that's basically what
we saw in this little example well that
brings up the question we can create our
own pool and have that run within that
pool but unfortunately we have to be
again a little bit careful with these
things
we can configure this programmatically
so what that means is you can maybe have
different collections of pools around
and depending on the nature of work you
are doing you can decide which fool to
dedicate that to maybe you have
computation intensive things in one pool
I or intensive in another pool and it
can give it but life is not that kind
often because you are computation
intensive jobs may do some computations
and then what if they branch off to do
IO intensive after that that makes it
really difficult to manage as well so in
general these are really good solutions
when your problem is within a confined
of things you can manage but if your
problem becomes totally convoluted and
and generalized and complex we
be extremely careful dealing with these
things this is just not something that's
going to manage everything for you
that's one of the reasons why it's a
master switch they gave us these little
tools made it very easy to use the tool
but the decision to use these tools he's
a lot more difficult than using the
tools itself that's why we have to be
very careful about it now the next thing
I want to mention here is a parallel
does not mean it is fast all the time so
how does it really matter whether it to
be parallel or not well before we talk
about that let's go back and revisit
this problem we talked about I got a
little code here called a computation
dot txt let's go ahead and use this
little sample code here and see what
this is doing so all I'm doing is the
compute method is going crazy over this
two loops it one outer loop and one
inner loop and performing a little math
it's i/o it's a computation intensive
then of course I have a little in-stream
dart range which is calling the compute
method and performing a sum operation my
question is how long does this code take
to run sequential II darkness so I'm
gonna go ahead and say in this case run
dart SH but I'm gonna ask you to perform
a time operation to see how much time
that code actually takes to run well in
this case it's performing that
calculation
hopefully it produces some result which
we can verify when we make a parallel
also and then when it finishes running
it's going to tell us not only the
output it produces but the time it took
to run as well well but it's a it's a
computation intensive how many threads
can I give for running this as you can
see in this case it the result was 2.2 e
12 and then it took about 17 seconds to
execute okay fair enough
17 seconds I want to make this really
fast so what am I going to do to make
this faster well I'm just going to
comment on parallel right here as a very
first step and say if it runs through in
and makes things really faster so if I
go back and run the code this time
because I said payroll it's going to use
the for join common-pool and notice it
produces the same result again that's a
good news 2.2 e 12 but this time instead
of 17 seconds it took about 4 seconds
hey that's not bad we got a good
you know better performance at least by
simply turning on parallel but then we
can say aha but you're only using the
puny eight little cores of viewers why
can't we just increase the number of
threads even further so to do this what
I'm gonna do here is I'm gonna create a
fork join pool right here so I'm gonna
say fork/join pool and in this case
we'll say pool is equal to new pool for
join pool how about a thousand threads
and then of course I can say pool Dart
submit and in this case we'll just go
ahead and call that little operation and
we will just dump this whole thing
inside of that operation for it to run
and produce the result for us in the
very end and then of course I've started
this on the pool will say pool dart
shutdown and then finally we'll say you
know a pool Dart
let's say await our termination
let's give it about and let's say took
about sequentially 17 seconds let's give
it 30 seconds time unit dart seconds and
and we'll ask you to wait that long and
see what it's going to do so in this
case we are putting it into a for join
pool let's just say 8 threads just for a
minute
so this is really replicating the
default behavior we're gonna get out of
this without much difference at all
so in the neighborhood of about four
seconds it should run so sure enough it
took about four seconds to run but I get
greedy and I say why don't I give you a
thousand threads well it took four
seconds is ended so that should really
run faster than that and something tells
us that well okay so it took all that
thread and gave is really no benefit at
all so it didn't really perform any
faster but what if I were to go back
here and say I'm gonna give you 5,000
threads this is where how much can I
instead of how much should I and and at
times that it doesn't really help us to
run with more threads actually that's as
you can see in this case it's not really
giving us much benefit at all but in a
lot of different cases it could actually
begin to perform really worse if I were
to go in and make some of these payroll
as well we could really hurt ourselves
by doing it so the model the story again
is don't go too far into these it
doesn't give you that kind of
fit when you do these things but how
many threads what can I pay analyze what
can I not payroll eyes so to understand
this let's talk about a couple of
different things one is when you are
paralyzing as two questions how many
tasks do you have what is the collection
size if the collection is really big
maybe it makes sense to paralyse if the
collection is really small maybe it
doesn't you can you can do a little
bench marking and see whether it makes
sense or not for the problem you have at
hand
on the same note if your problem is task
is really small you might actually waste
your performance by having threads it
might be faster to just execute it
rather than create threads and execute
it if your tasks are time consuming you
might benefit from having multiple
threads so a silly example I will use
this let's say you ran out of sugar and
you yell out and say hey kids if you go
to the neighbor and get me some sugar
you got two kids one kid goes on puts on
helmet and he's gonna take a bike to the
neighbor and the other kid jumps the
fence you know who is gonna get you the
sugar really quickly the one who jumps
the fence so if the distance is really
short you want to just go ahead and do
the work you don't want to go through
doing you know all these other
ceremonies which will potentially give
you speed but not in this case on the
other hand if you want to go to a store
which is let's say five kilometers away
and get something the kid that jumps the
fence goes to the jail you don't want
that to happen you really want to focus
on distance and then map to the
efficiency and then say how we can get
that efficiency that's one thing to keep
in mind so measure measure measure all
the time and see if you're actually
getting the performance that you would
really like to get on the other hand
there is something else we have to be
very careful about as well and so I'll
switch gears and show you a slightly
different example to understand this I
have a class called person dot Java the
class person has a name gender and age
and in this example as you can see I
have the age and the gender and the name
and all these little details but what I
want to do is I want to say create a
person and I'm gonna create a bunch of
people on my hand so in this case you
can see I have a serum
is you know female and Bob was male and
Paulo was female different ages and I'm
gonna take this Jill will make Jill
older for now so Jill is 42 but I'm
going to ask the question of this I'm
gonna say in here find the first let's
say female so find the name in upper
case of the first female older then
let's pick a number oh let's say older
than 30 well I'm asking for the first
female who's older than 30 well in this
case what are we going to do it because
it's a first one I'm gonna say create
people and then dark stream then I say
dark filter I'm gonna say given a person
well it's a female order than 30 so it's
a person dark get gender is equal to
gender dot female and then I'm gonna say
dot filter given a person a person dot
get age and we'll say is greater than 30
and then finally we'll say map given a
person get the name of the person I
would say get name and we wanted an
uppercase we'll say a string dot to
uppercase and finally but we really
wanted only the first person
so we'll say find first and what if the
person doesn't exist we'll say our elves
no nobody so no one well I want to print
the result of this eventually so we'll
go ahead and print the result right here
so output and we're gonna ask it to
display all these different values for
us if I run this code you can see from
the output it's Paula why is it Paula
because Paula is the first female who's
older than 30 and it because it's first
it's an ordered collection because let's
just an ordered collection the ordering
is is kept and it's Paula it doesn't
matter how many times I run this no
matter how many times I run it'll always
be Paula but one thing important to keep
in mind is streams not only have elegans
streams also have efficiency based on
laziness so what does that really mean
in this context if I go back to the code
if I display the get name and get aged
and get gender I'm gonna display these
values in these particular you know
output so you can say get gender right
here and as a result we can say get
gender for name and we can display the
gender details or return the general
details but because of laziness in the
computation what's going to happen is it
remember it does not take these
functions this is one clear distinction
in how collection streams work in Java
eight a stream it does not execute a
function on a collection of data it
instead executes a collection of
functions on a piece of data so this is
a very clear distinction of how streams
work in Java
eight so it doesn't take the collection
of data all the people and run a
function that is a function it doesn't
do that it doesn't say oh thank you you
give me a function I'll execute on the
collection oh no it instead takes a
collection of function it takes those
highlighted functions as a collection of
functions and fuses it and then it says
I'm gonna run that collection of
function on the data this is a very
clear distinction as to how streams work
in Java compared to a lot of different
languages that may pretend to provide
functional style of programming but
don't give you this efficiency so this
is one key thing which is the which is
the way laziness is brought baked into
Java lays evaluation is possible because
of that well this is very keen because
when you run this code notice it
evaluated Sarah given this list that you
see here it evaluated Sarah's gender age
and another Sarah's gender age then
Bob's gender but not age
Paula's gender age and name and the
minute it found fine first it said I'm
done and it builds out it never touches
Paul jack-jack
Jill so Paul jack or jack or Jill were
never bothered that is efficiency we are
lazy evaluating we're not doing an extra
word unnecessary this is really good you
can also do insert of a find first you
could do a find any find any means I
don't care about the sequence just give
me the name of any female in the
collection who's older than 30 but
because the execution is sequential and
because that a collection is ordered
Paula gets the fair advantage no matter
how many times we run it'll always be
Paula so going back to this example
let's remove this output for just a few
minutes if I go back and run this now as
run dart SH it's going to be parlor and
it doesn't matter how many times I'm
gonna run this it is going to be always
Paula I know this is not a proof to run
it 20 million times and then monkeyed
around and prove it but at least
empirically we can say it's not giving
us any different result so that tells us
it's Paula all the time no matter how
many times we run it's going to be
exactly that particular call and we can
kind of you know take comfort in that
okay great
on the other hand if I go back to this
code one more time and this time I'm
gonna say find the first one more time
remember the before each ordered for
each ordered gives you ordering for each
doesn't well fine first always imposes
ordering you don't have you don't have a
fine first ordered welder the first
itself is ordering right so you don't
have to say find first order it's fine
first it's ordering in post so in this
example if I go back to this and say
parallel right here now we are saying go
run this in parallel but give me the
first person who is older than 30 and
who is female if I run this code it
doesn't matter how many times I run it
better be Paula all the time because it
is ordered the collection is ordered
fine first will preserve the ordering
that's gonna be Paula all the time
however if I say fine
any all bets are off now because the
collection is ordered sure but it's find
any so because we are running it in
parallel there is no particular
sequencing of execution the one that it
hits first it's going to come back with
the result so in this case look at the
answer that's possible now there are
only two people who are older than 30
and female here that's Paula and Jill so
sometimes it could be Paula sometimes it
could be Joe who knows what it would be
so when we run this we can see that was
Jill okay this is unfair but but okay
thank you I was kind of building to
doubt myself so you can see that it
could be any of them
sometimes Paula sometimes Jill and you
can go back and forth there's no
guarantees to it well this is all
reasonable isn't it that seems like
that's the way it should be
however we have to be very careful about
one thing though what about laziness and
at the same time also a parallel well
let's understand what this really means
notice if I run this sequentially
remember we never touch anybody other
than after Paula we will not touch Paul
Jack Jack and Jill in this example and
that is because we are doing it as
sequential and we are doing it fine
first and as a result when I run this we
never touch Paul jack or Jill on the
other hand the minute we turned parallel
on what does this say it says hey folks
let's get the party started and as a
result it unleashes a thread on the
collection and as a result notice what's
going to happen your result is always
going to be Paula in this example
because you said fine first we prove
that earlier however when I run the code
with the output showing you will notice
we are actually touching Jill we are
touching Paul we are touching Jack's as
well and as you can see this is
unleashing on it so what does this
really mean in this context so to
understand this let's take a slightly
different example
we got a number of people in this room
and let's say I was sitting over there
actually I was and maybe I left my smart
phone next to the third gentleman over
there no there are two ways I can solve
this I'm like I don't remember where I
left my phone so I could go over there
to the first gentleman and say it's my
phone next to you he says no is the
phone next to you he says no is the
phone next to you says yes
oh great things I took three units of
work how many people did I bother three
people so three units of work and three
units of time later I got my phone
alternately what I could do is I could
just yell out in this room and say folks
looks like I left my smartphone
somewhere could you please check to see
if it's there and everyone hopefully
will start looking around for my phone
and what's gonna happen now
good news I'll get the phone in one unit
of time well let's three visit this what
is the difference between these two hey
this isn't that good that I'm getting
the result faster let's try this again
I'm gonna yell out and say get me my
phone please if it's next to you so the
good news I got the result in one unit
of time bad news I bothered everyone in
the room good news I don't care so that
is exactly what this means
parallel says I don't mind wasting more
resources with the hope of getting the
results faster so if I'm going to get
the result faster I will unleash my
threads on it I may even do more work
while some work are still being done if
other work finishes and I get the result
faster I am happy for that
so that is exactly what this a is
parallel is laziness says be efficient
laziness says don't waste your
computations don't do in extra work just
be efficient minimize the work you do
that is what laziness saves parallel
says unleash your threads do as much as
work as you can you need to do with the
hope of getting the result faster so
you're not keen on resource utilization
at this point you're keen on speed of
delivering the result and we need to be
very careful if you have an infinite
stream batters and if you are opening an
infinite stream with parallel think
about it a lot because your streams are
gonna start kicking very quickly and all
those come you will get the result
faster but your performance is gonna go
down because all those threads which are
busy are going to be still kept busy
because they have not they don't have a
clue to die new threads may not be
created after the task is done but all
the threads you unleashed might
potentially be doing some work and that
may not be a really good thing to do so
that's where I'm gonna stop talking
about parallel and we're gonna talk
about completable future it's probably a
good idea to give you a little break how
about a ten minutes break and at the end
of the ten minutes we'll come back and
get started right back here thank you
alright let's get started again thanks
for returning back we will talk a little
bit about completable futures and look
at some of the nice things that we have
available here so we looked at parallel
streams and I mentioned that it's really
useful when we have a collection of data
a parallel or a problem we want to take
this collection of data and do things in
parallel that that shows really well
when it comes to parallel streams on the
other hand what if we have a task and we
want to just divide and conquer that
task we want to take a task and maybe
just delegate that and ask you to run
asynchronously and come back and give us
the result well in this case an
asynchronous execution can be very
useful uh in Java traditionally we have
done almost everything using threads
oops that's thank you thanks for
alerting me on that not sure why that
went that way let's so that's messed up
too isn't it yeah so let me try to see
if this one helps nope
so looks like a resolution is messed up
on the other side can you check on that
please thank you concurrent problem I
think so so while we're looking at it
will just continue to talk and a signal
me if you see that getting fixed so so
one of the things we can do in what we
kind of approach almost everything in
java using multiple threads well when it
comes to multi-threading let's say you
want to send off a task to execute but
you want to get the results back from it
so what do we do in terms of how we can
get the results back so no that's it
doesn't seem to fix let's see if I can
change the resolution here
oh cool all right thank you I didn't do
anything that's the worst thing so all
right thanks
so anyways so let's talk about you know
you want to do some times to ask and get
the result back from this so how do you
really do that in Java well let's think
about this for one second because this
is a bit scary when when you start with
the threading all the way back remember
what the function was the run doubles
run method what was the run method of
runnable void run that just think about
that for a minute it says I will not
take any input and I will not give you
any output how rude
this the scares me right because the
fundamental API behind multi-threading
said I won't take anything I won't give
you anything what does that mean the
only way you can do anything with this
is by doing mutation but didn't we say
mutability is really bad idea when it
comes to concurrency this was dead on
arrival I mean I use this as an example
to scare my children are normally right
you'd say this is how life is when you
get out there in the real world right
you got to face these things so we said
okay we really want to do some work and
we want to get the result back how do
you really do that well this is where we
could use a future well at the beginning
future sounded like really a good idea
but you call a method what does it do it
gives you a future what do you do you
call get on the future and the minute
you call get what happens you get
blocked
that's no future at all it's a very
bleak future well you know it I know I
know this is really a scary thing to say
that we can actually learn something
from JavaScript but it truly is because
the JavaScript programmers have really
filled these pain for a long time
remember JavaScript fundamentally is an
asynchronous programming language or
environment and so they have been
through this in the past they used to do
callbacks well when you do callbacks it
is very very painful but with first
problem is callbacks like consistency
when you use a callback is the first
argument an error or the first argument
data who knows it can be anything you
want
to be and it's very hard to compose it
you have a callback which returns a
method which has a callback which turns
a callback I want to call that callbacks
callback they have a favorite name for
it they call it callback hell and that
doesn't go really well and of course
it's very hard to deal with errors also
so what the Chaves world did is they
came up with what are called promises I
really think that promises opened up
some good possibilities so what it proud
of promises do well a promise maybe in a
three different state it may be a result
rejected are pending well a promise may
or have one data going through it and
how does a promise really work well this
is the nice thing about a promise a
promise has two channels so when you
look at a promise a promise has what is
called a data channel and it also has
what is called an error channel so think
of this as a two tracks a left track and
a right track and when you have a
promise at the head of this so right
about here let's say we have a promise
and from the promise you may have a data
that generated that gets generated and
that may propagate through the data
channel or you may have an error that
gets innovated and that may propagate
through an error channel so in other
words a promise gives you with two
tracks and the data may go through the
data channel from the left to right or
it may go from the error channel from
left to right which is really nice
because you're able to deal with data
and error through this very nicely but
what is really cool about this is this
is beautiful to compose how do you
compose it you can take a function that
returns a promise we'll call it funk and
then on this you can say excuse me then
and you can put a little function you
can put a little catch over here and put
a function now notice that's your data
Channel
that's your adder channel then you can
say dart then and you can put another
function call it f2 and you can put
another catch over here we'll call it e
2 and let's call this one as F 1 and
this is as e1 the way this is actually
structured as this will be your F 1
followed by F 2 and this will be your e
1
over here followed by e2 so this is a
composition of this function they form a
nice chain of functions so when you
generate the data in the function if it
was a real good data it will go to
function f1 if that produces a nice data
it will hop onto function f2 if that
precedes a nice data it'll hop on to f3
and so on and it would just keep going
this way on the other hand if something
were to go wrong in the function you
would then come to e1 which will do
something and generate an error which
will hop on to e2 which will generate an
error and then it'll hop on to e3 and
then so on and it can continue but
what's really cool about this is you may
have a data you're processing and let's
say right here when you're processing f2
something goes wrong so that original
was good f1 had no problem f2 chokes up
and says I don't like this it tastes
really weird well now it can put you on
the left track and say go to the error
now you're starting to process the error
maybe this isse Evan says you know what
I can handle this I can make things
right at this point it could potentially
put you back on the data track again so
you can go from the data track to the
error track error track to the data
track and back and forth so promises
give you a nice way to compose these
functions I know you're wondering that's
all awesome but you're why are you
talking about promises and JavaScript
wouldn't it be so cool if Java has
promises well that is the most
remarkable part Java has promises but in
our field we'll never give the same name
somebody uses because then people don't
understand it so you kind of give a
completely misguided name so nobody has
to clue what you're talking about so
what is it we are really talking about
so in a sense Java as completable
futures are JavaScript promises so this
is exactly what we have with us today
and we can benefit from it really nicely
so JavaScript Java has completed a
futures who really are JavaScript
promises and everything I described to
you just in the past several minutes is
actually for completable future
that's exactly how complete but future
works you can go back and forth in this
chain and you can use it we're gonna see
how that works in just a few minutes so
what are we going to see here we want to
create a completely future and and work
with it well these are the stages I
talked about so you can have stages of
these functions you can go through and
you can work with them
so let's when one stage completes the
next stage can kick in and do the work
and so that becomes a nice way to
compose these chain of operations let's
look at an example of creating a
completable future there are several
options available for this so we'll look
at some of these options concurrent and
then this is going to be concurrent dard
completable future
so we'll say completable future right
here and in this case of course we're
gonna create a example and play with
this little thing so we'll go ahead and
say completable future dot let's start
with that little action to begin with so
I'm gonna say run a sync right here and
what does run a sync I'm gonna just give
it a little runnable for it to work with
I'm gonna say over here let's call this
as you know let's call it as do work so
do work is my async run run async I'm
gonna say in this case in main right
here and and we are running this as a
completable future so the minute I say
run a sync that goes off and does some
work as you can see while the main
thread is doing its work so that's as
simple as how we can create a little
asynchronous operation to run of course
you could have done
you know thread and then runnable and
then you could have said executor
services well this is almost the same as
that except that it's much easier to do
this of course the question is where
does this actually run this code well
we'll figure that out a little later so
we are just asking you to run some tasks
and and do the work so that is doing
that little work but I want to do some
work
after this finishes the work how do I
actually do that well that's the beauty
of this is we can say
then over here and except and in this
case I can simply say next stage if you
will so you can compose these operations
very elegantly and you can keep moving
forward it's complaining that there's an
incompatible type in this case because
the other guy is giving us a void we'll
come back and work through this but look
at the structure for just a minute so
you can start going through this
pipeline of operations and do stages of
operations and we'll take a look at how
we can do this in just a second when we
look at a little bit of a browser
example so but I want to get a result
back from this computation how do I do
this well I can go back to this
completable future rather than doing a
run a sync let's go ahead and say in
this case supply async well as you can
imagine run a sync took runnable supply
async takes a supplier so the supplier
functional interface is what we're gonna
use over here so what I'm gonna do in
this case is just to give you an example
I'm gonna output do work or doing work
let's say and then when I'm done with
the work let's return just an value of
oh let's say a value of 2 so this is
going to return a result of 2 when the
work is done
so when I run this you can see it's is
in main and doing work but I want to get
that result back from the call how do I
get it well if I want to get the result
from the call I can go to this this
completable future and let's just take
this little code right here to make it a
little bit more elegant we'll go ahead
and say this is going to be sample
generate that way it's easier to see
this and we will put this as public
static let's say int generate and this
is going to not take any input but it's
going to do that little work it's going
to say you know doing work right here
and then it's going to return that value
of 2 when the whole thing is done so in
this example as you can see we are able
to get the result back from the caller
well that is going to be the generate
function doing the actual work but then
I can say dart get and then in this case
I can receive the data and I can try to
print this out so what is what is it
going to do well that's the completable
future I set it off to run separately
and I'm asking to get the result of
course when
we do this it wants us to handle the
exception I'm gonna just throw that up
here and say throws exception and be
done with it so in this case you can see
in Maine but we printed the two but the
two got printed when we got the results
back from the call but unfortunately the
problem with this approach is we gonna
block and wait for this to finish so
generally get is not a good idea because
that was the problem with future as well
we call get and we get stuck with it it
could put a timeout on this of course
but that's no fun either well one other
option you have in this case is let's
say this is gonna take a little longer
to run so I'm gonna say sleep over here
dart sleep let's say and in this case if
I'm going to ask it to sleep for a
certain duration of time let's say two
seconds well it's gonna sleep for two
seconds what's gonna happen when I run
this when I go ahead and run this little
example you will notice it's blocked for
that and then when it is done it prints
too and moves on
well that's unnecessarily waiting what
if I don't want to wait for that long
you could say get now with the minus one
for example in this case if I don't have
a sleep well let's go ahead and say I'm
gonna wait a little longer
this may not actually finish it but
we'll find out so when I run this well
it still got a minus 1 that is what get
now does it's pretty impatient I want it
now so if you want to put this into a
variable and come back and call it that
might actually help so in this case
let's grab this one and say completable
future of integer let's say and we'll
call it as future is equal to and save
it away and then in this case I'm gonna
say let's put a little delay in here too
so sleep off let's say sleep one second
or maybe in this case yeah one second so
it gives a little time for it to get up
and finish the job
and in this case of course we will go
ahead and say I want to output here
future dart get now well clearly there's
no sleep here so by the second this one
second it comes here this should be done
it will not be a minus one but a two is
to be the result of this particular
computation and you can see it produced
a two on the other hand if I were to
sleep a little longer than when it asks
for the result there will be a result of
minus one so it can be very impatient to
say get it now for me well well that is
good that is still not very appealing so
we can just quite quietly move away from
those
we'll see how their better ways to
handle this let's talk about the threat
of execution what thread is going to
execute all these different calls well
to understand that let's leave this
generate right here for now
let's remove the asleep let's come back
to this future that we created and we'll
well we have this future save the way in
the generate what I want to do is I want
to come in here and say the future dart
then accept and then accept given a
piece of data given to me I want to
output the data right here so what does
this really do well it's going to go
through a second delay and then come
back and tell us that it's going to
bring back the data and and give us the
result of it oh let's say in this case
our then except not the accept so then
exit well what is then except actually
take as a parameter the DEM except takes
as a parameter a consumer which of
course gets the data and displays it
does whatever it wants to do with it
so that is example of how that is
working but I'm curious worse words this
Aldus running after all this is one of
the cool things we can really enjoy so
to understand this I'll say sample print
it and let's go back and write a sample
printed function so we can play with
these threads and observe this so I'm
gonna say over here void we'll call it
as print it and in this case we will
simply print out two things we'll print
out the value that we get a plus will
also print out the thread dart current
thread so we can see what thread is
executing it
likewise doing work and then we'll say
plus in this case thread dart current
thread so we can display the information
about this thread well when I run this
code what's gonna happen well let's step
back and see this real quick
in this case notice that we are calling
the future well the supply async is
taking generate as an argument and as a
result it is gonna execute this in that
other thread which is good on the other
hand what about this print it what
thread is it going to run in that's the
puzzle will answer the puzzle in just a
minute well remember in this scenario if
I don't have
the sleep function right now in here but
imagine I'm gonna put a little sleep
method over here so I'm gonna say over
here sleep dart asleep and I'm gonna ask
you to sleep for about a second let's
understand the scenario we started a
thread right here we asked it to print
the result of that particular
asynchronous call and now the main is
blocked sleeping in the meantime this
guy kicks in he does his work and says
now that I'm done with this I made as
well join in and finish this job so when
I report the thread of execution in this
example what I notice is notice it's a
common pool thread common pool thread 9
&amp;amp; 9 well that exactly did both the
pieces of work the common pool thread
thread did this work but it also did the
print printed while the main is waiting
on the other hand let's put a little
sleep right here now what's the scenario
this
asynchronous cast started up main is
sleeping main has not told us what to do
with the result of completable future
that's one of the really nice things
these completable futures don't expect
you to be really fast you can be as fast
or as slow as you want to so if you're
not ready to use the result it doesn't
force you to use the result you can take
your time but it's not going to wait
around for you it in terms of execution
so it finished the work put it in the
computable future and sir completable
future and said here it is use it when
you want it you take your sweet time you
come and call this what thread is this
gonna run in
well the main says I don't have anything
to do right now I might as well do the
work so when I run the code this time
though notice that that was executing
the other thread but the two was
executed in the main thread and not in
the other thread and that is because by
the time main calls the print learn that
execution is completed the main might as
well do the work that is fairly
efficient isn't it so when you look at a
complete of a future you are called
particular call may be asynchronous or
it may be synchronous you cannot quite
say that based on what you're looking at
it is going to be a fishy end if it's
going to take a little long
it's gonna run into another thread if
it's not gonna take any time at all it
can run right there so it can go either
way so that is basically the threat of
execution but I want to run this in a
different pool I don't want to run this
in the common pool what do I do well are
a couple of things we have to be very
careful about the first thing is when
you create the the the supply async what
you can do here is you can provide a
pool right here I'm gonna call it as
pool one so I can specify a pool when I
create this so in this case I'm gonna
say a fork/join pool will call it as
pool one is equal to new fork/join pool
and I've created this pool called pool
one and I've scheduled in full number
one so I can give the pool after setting
the task to run then I sleep for a
second and ask it to print the result
well in this case when I go back and run
this little code let's see what it's
going to do notice that's from the not
the common pool anymore but from the
pool that we created that's still
running in the main so that's pretty
awesome same token as before if I don't
have a sleep here
then by the time I get through this the
competition may not have been finished
so where is this print line going to run
now as you can see here both of those
lines are running in the other thread
not in the main so that works really
well so putting into another pool was
extremely easy however you say all right
all right that's all great so far but
let's focus our eyes on this one I know
that this can be running in that other
thread or it could be running in the
callers thread itself but what if I want
to give a completely different thread
for that stage of execution remember
when we did parallel stream we quite
didn't have the power to vary the
parallel as a sequential the entire
pipeline was condemned to run in one
pipeline at one thread well that's not
the case with completable futures you
can take the stages of completable
futures and you can put them in
different threads hmm how do I do that
well that's where async versus non async
comes in
if you
look at this example here where is this
running obviously that's running in this
example in that other thread so notice
it's pool one that it's running in but
instead what I'm gonna do here is I'm
gonna go to this guy and say then accept
async and provide a pool one again we'll
start with that first
so I'm saying run it in pool one place
not in the in the main which is what it
was actually doing isn't it so that's
what it's doing but on the other hand if
I put the sleep over here what did we
notice earlier this one was running in
the main earlier if you remember now
when I go back and run this this time
notice that this is running in the pool
also not in the main because you
specifically told them don't run in your
own thread running the other thread
where this becomes really cool as this
could be pooled to and not pool one so
in this case I could create another pool
and I can say this is let's say pool of
ten threads also are 15 threads 5
threads and this is gonna be pool - and
why would you want to do this well maybe
these tests are computation intensive
maybe these tasks are IO intensive
remember so you can start varying the
threading model that you want to provide
and so you can control that maybe a
little bit better or for whatever other
reasons you want to do so this is pool
one as you can see where as that one is
pool - so you can control so what's the
model of the story almost every function
has an async version which I loves you
better control on the threads of
execution of those functions as well so
it's a quite a complex number of options
available to you in terms of how it gets
handled now that we saw that let's
understand a few beautiful things we can
do with this so in this example just to
keep things really simple let's go back
to the generate function the generate
function generated a value of 2 as you
can see well that's great I have a value
of 2 I'm gonna remove these these these
outputs for a minute I'll just output
the value given to me so we can actually
just look at what's going on in this
example the value being generated is 2
so what am I going to do here I created
a future as you can see right here and
in this case the future I created is
simply getting the generate function
well then I can pick this call to the
generator or the supply async I can
beautifully draw a pipeline so now I can
say dart and I can say then accept and
then I can say given a data I want to
just print the data so I can say print
it and send the data for printing so if
I execute this little code notice it
printed too well the general way
produced to then except printed it
that's a nice pipeline so this is kind
of like you were for each isn't it
so then except is kind of like here for
each so let's put it as then except is
like for each so so leave it at that for
a second okay so we brought a similarity
between this pipeline of completely
future and pipeline off streams at this
point that is then accept but what if I
don't want to accept and print the data
well I could also do it then run then
run will not take any data will just do
it action without any data but I can
also do this is really nice I then apply
well you kind of know what then apply is
kind of right so then apply is like map
so it can perform a map operation for
you so in this case what I'm gonna do is
I'm gonna say dark then apply and in
this case I'll say given a piece of data
give me data x - well remember generate
gave us a - on line number eight this is
going to take the two double the two
that becomes a four when it's returned
and there's gonna print out the value of
four when it's done so right there is
the value of four so this is like a map
operation it performs a transformation
now you could say why didn't they call
it as a map remember you never give the
name others will understand so as a
result they said we'll call it then
apply it's a lot more fun I couldn't be
called as map as maz much isn't it
because we're just transforming it
that's what we are doing but the for
each wouldn't make any sense per se
let's give them give that give that
because for each welcome
it's gonna only have one value not many
values so it's not a four each
it's a terminal operation okay fair
enough so given that what do we do I
mentioned what then run then sorry then
run will do it's a terminal operation
just do an action and you are done with
it so you could use that too so I can
create a nice pipeline but notice that I
created these things at the top of the
origin what if I don't want to create
this at the top what if I want to send
the data at a later time you can do that
very nicely as well let's see how we can
do this here so notice what I'm gonna do
now I'm gonna say completable future and
in this case integer and I'm gonna call
this as future is equal to new
completable future and create a future
object right there now that I created a
completable future I'm gonna replace
this with future dot well notice this
future has not completed yet it doesn't
have any production yet so I can come to
this future and ask the question future
dart is done and it tells me at this
point no I'm not done I'm still pending
so this future is not done yet it's
still pending until it completes you
can't you're gonna wait for it
similarly can ask it or you can celled
you know maybe somebody really cancelled
it
so I can ask it are you cancelled and of
course at this point it will tell you
that it's not cancelled either great now
that it's not completed not canceled
what can I do at this point well now I
can say you know let's say sleep dart
sleep let's say give it about you know a
10-second five-second three two-second
delay and then I'm gonna say over here
future dot and in this case I'm gonna
ask it to complete it so complete let's
give us seven to it well I can push the
data through this pipeline of futures
and again throwing a seven but you could
do other work and get the data this
could be somewhere else you could pass
you a completable future to somebody
else and say you take it and then you
tell me when you are done so this is a
nice way to you buell the pipeline you
give the head of the pipeline to
somebody and say you work on your thing
when you're done with it
send me there are some back this is like
you want somebody to do some work for
you you say you do the work when you're
done takes me the result that's exactly
what we're doing you built a pipeline
give them the future and say you go push
it when you're ready and they can call
complete on you so you don't have to
attach the head the head can come in at
a later time what is this going to do 7
times 2 is 14 and the research should be
printing the 14 after a two-second delay
and right there we see 14 being printed
so this is a nice way for you to build
the pipeline and then come back and
execute the pipeline later on at this
point I want to remind you the main
difference between completable future
and a stream in this case is a stream is
a zero or more stream of operation
completable future there's only one
sequence through which it goes through
and the minute one sequence goes through
a complete one future either completes
or it terminated it was cancelled you
won't get multiple streams of data
through a completable future this is one
of the biggest differences between
promises and observables and streams
promises are zero or one piece of data
or an exception observable is zero are
many pieces of data it's a stream of
data so if all you're doing is just one
stream want one piece that is going to
transform through a completable future
our promise works really well so we saw
how to do that but what about exception
handling well if things can go wrong it
will and we need to be able to handle
that well remember what I mentioned
earlier promises have two channels they
have data channel and they have the
error channel we have to be very careful
how we handle this and so let's
understand this with a little example so
in this example I'm going to go back to
my generate method so in the generator
under turning a - and notice in here
completable future dart let's say supply
async and then I'm going to specify
sample generate and I'm going to just
put this pipeline through it that's
going to generate a result for us
absolutely and and as a result what is
it going to do so when I run this little
code you can see that generate generated
a value of 2
that's going to propagate through right
here and produce the result in the very
end let's just do a sleep here
well actually it's going to out put this
on and see what it produces on the
output so when I run this you can see it
printed a4 well that's printed for
because generate created to transform 2
to 4 and printed it but what if
something were to go wrong here
so I come in here and say in this
example let's say throw new runtime
exception and we'll put a very useful
message oops
something went wrong right so just like
we get mad
error messages right very useful
messages so something went wrong so this
is gonna blow up what's gonna happen
when it blows up just for our purpose
let's go ahead and run this code and see
what it's going to do when I run this
code notice we didn't get anything hmm
that's kind of silly why because we
never really did anything on our error
channel the data channel has been laid
out we only bothered about the data
Channel what did we say the data
produced is to map it to do times 2 and
print it so we took the effort to build
this data channel this game to do and
then times 2 and then Trent that's the
data channel we totally forgot the error
channel now in this case this guy is
blowing up with the runtime error oh my
gosh what do I do with the error maybe I
want to print the error maybe that's art
that's what I want to do I want to print
the error what if I want to print the
error how do I really do that well let's
get back here remove these for just a
minute and we will say that then and we
can say in this case exceptionally I
really really hate this word it is it
doesn't feel good at all right it's not
exceptional it's like gosh we're dealing
with a failure
so exceptionally what are we gonna do
well you're gonna give me a throwable
and when you give me a throwable what do
I want to do with the throwable I am
gonna say output that throwable for me
so I'm just printing the throwable at
this point I'd remove the there channel
now
focusing on the arrow channel will bring
them back together a little bit later so
what is this going to do for us well in
this case it complains incompatible type
and return type in lambda and it wants
us to return an integer value we'll just
make it a little happy for now we'll
come back and fix it a little later on
so in this case I have a throwable and
then I'm going to simply put a little
curly and this one and then end this
here and for now we'll clean this up a
little bit later and all I'm going to do
here is let's say return zero for now
don't worry about that value at this
point when I run this code what does it
really do when I run this notice it
printed you no exception and and the
details of the exception let's make this
a little bit more easier to work with so
I'm gonna say public static we'll say in
this case int and we'll say process ever
and we will say throwable in this case
throwable so throwable is th and all I'm
gonna do is output throwable and what am
I going to do return zero so at this
point a throwable return zero just like
this I just moved it around that's all I
did
so we'll just make it a little bit more
civil so sample process error and when I
go back here and run the code it should
produce the same result as it did before
what almost we'll just do one more thing
we'll just say error : and then just
make it a little bit easier to see
dart get message there we go so I'm
gonna print the message here and one so
when I run this code you see error oops
something went wrong great so that's the
error channel so what did we do just now
we took this error and we printed it
well okay but how is all this coming
together we want to have an error
channel we all want to error data
channel don't we want to live together
and be happy well careful though notice
what I'm gonna do now I go here do this
guy and I take this exceptionally and I
drop it here and then I remove these two
be very careful when you do this this is
our JavaScript promises work this is how
Java completable future work very
careful what you're saying here
I'm gonna take this one if there was the
failure here I will step into
exceptionally if there was no failure
I'll bypass exceptionally and go here
after this point I'm sure you're all
happy right gosh that's the way it
should work when Kent yes but the
question is when this fails it goes into
exceptionally what does that function in
exceptionally do this says I got this
I recovered from the error my new result
is zero so the meaning of this call is I
am going to put you back on the data
track at this point so this is
redirecting you back to the data track
right and as a result and because this
is before the transform you are actually
going to come in here this is the
meaning of the code you are seeing right
now so as a result what is going to be
the behavior of this this fails with an
exception this prints the exception but
generates a new data 0 0 times 2 is 0
and I'm going to print the 0 in the very
end so when I go back and run this
little code you can see in this case Oh
illegal there's a semicolon
ok that's exceptional ok so let's go
ahead and try this again and in this
case of course I'm gonna go back and run
this now and what does that do well
notice runtime exception oops something
went wrong where did that zero come from
that zero came from the transformation
of the data zero from here which was
multiplied if I say plus you will notice
it's a 2 instead of a zero because it
took the zero and did this so the
question you should ask very clearly is
are you dealing with the exception and
recovering from it or are you dealing
with the exception with no hope of
recovery
if there is no hope of recovery don't
return a value what you want to do
instead is throw and just we throw it if
you want to or throw new runtime
exception I hate to tell you this and so
you can just propagate this further and
if something else comes in the chain
later on it can handle it
if there's nothing else in the chain it
just evaporates so let's go ahead and
run this and see what happens now when I
run this this time though notice oops
something went wrong you don't get the
result of zero or two anymore why
because when this failed you are not
going to do this it is instead going to
the next exceptionally and what am I
going to do in this exceptionally I'm
gonna just take my easier out here I'm
gonna call process error again and then
send it back to this so what's gonna
happen then that's going to of course
tell us error I hate to tell you this
and it blows up again so that's what we
are supposed to see right let's see if
that works so go back and run this again
and see what what it tells us Oh bad
return type again well that's because I
put this after this because it's a what
do you say it's a consumer isn't it so
we'll put it right after the accept so
again the point here is you will bypass
this part and it will come in come in
here so let's go ahead and put a
semicolon and see if that goes through
and and again the type does matter and
you have to make it make sure it's the
right type so did you notice now this
blew up so you went in here that printed
the result and in turn blew up so you go
into the next exceptionally so what's
the moral of the story the model of the
story here is you have a data channel
and you have a error channel when a data
is generated in a data channel what are
you going to do you take the data x1 and
you convert it or transform it x2 and x3
and you keep on going this way as much
as you want to or you get an error when
you get an error you can blow it up even
further and you can take this other
error
another error and another error and you
can keep on going or at any given time
you can go from the data channel down to
the error channel this way or at any
time you can go from the error channel
up to the data channel so you can take
these kind of paths back and forth so
you have data data oops something went
wrong come to the left track Error error
I'm gonna recover go back and process
the data and you can build this pipeline
that's your chain you are building so
it's important to understand the
behavior of these exception processing
blocks you need to blow up if you want
to propagate the error if you haven't
really handled it or you want to return
a recovered value are both depending on
your input conditions you may a star
runtime you say oh you know what I was
actually able to recover from this so
I'll give you a healthy data to process
or no this is completely messed up
beyond repair I can't help it I'm gonna
just blow up and be done with it so you
can do that as well so that's all great
so far but there's one problem in Java 8
and that is when you start a completable
future let's go back to this code
example right here I'm gonna return a
value of do well that's all right but
this is generate and I could do other
operations also and what does this do
it's gonna say then accept and then
exceptionally then apply and then accept
and print the result right here that's
all wonderful and if the data returned
is 2 it's going to take the to add 2 to
it and print it that's also really
beautiful but I run this code right now
and what does it do it printed form
however if I go back to this generate
what if this generates says sleep Dart
let's say sleep Oh 10-second delay so
this guy is gonna take a lot of time to
compute now remember one thing this may
not be as 10 second delay what if this
is going to be delayed for ever in this
example of course you like like how
you're calling it you to be done right
well what if you are not doing a general
rate up here what if you took the
completable future gave it to some other
function it is going to call complete on
you what if that complete call never
comes through after a very long time
what's going to happen then well if you
run this little example here you will
notice that it immediately said I'm done
well that was kind of little lucky but
we didn't process the data but
eventually we want to process the data
how long am I going to wait for that
piece of data to finish or you may want
to know that a task you set out to run
was never actually completed and you may
want to do something about it
unfortunately in Java 8 there is no
elegant way to do it you can call get
and we know we don't really like yet so
don't bother about calling get so what
did I do
how do I know this has taken way too
long there is one rule we have to follow
both in life and in programming never do
anything without a timeout I mean as an
example let's say you decide you want to
find the perfect love a smart person
will never wait indefinitely to find a
perfect love because that's the best way
to get old and die alone so you start
finding a perfect love but you always
put a timeout and say you know what I'm
gonna settle down it's not going to work
out that's usually my opinion about life
right you always time out on these
things in life and in programming too
you don't wait forever for something to
happen so that's exactly the point here
you just start out and say I'm gonna
give you some time if you don't finish
in time
I'm moving on how do you do that here
well thankfully they introduced that in
Java 9 so Java 9 now has two functions
which are very useful the first function
that's very useful is a function to bail
out if something doesn't happen in a
certain duration of time so for example
in this in this case what you could do
is you could take this completable
future let's put that into a variable
completable future of integer
we'll call it as future right here so
this future I'm gonna then tie these
operations to this future right here
so this guy is waiting for that to
finish and I'm gonna go ahead and say
let's say sleep dart asleep how much
time am I gonna wait to sleep here let's
say about 20 seconds but in the 20
seconds I want this to really finish but
that's gonna take about 10 seconds to
run that's a total of you know 20
seconds to finish I don't want to wait
that long at all that's too much time
waiting so what am I gonna do well what
I'll do here is we'll go back to this
code and say well I'm gonna give it a
little timer
so future dart and complete on time out
so we can tell him I want you to wait a
little long but at that point I just
want you to complete if you haven't
finished in that duration of time so if
the time expires do me a favor please
complete it for you I mean we do this in
life right
hey I'm waiting for this if they call
you take care of the call if they don't
call you do this work for me and go home
so you want to put a termination on this
at a certain duration of time so in this
example what am I gonna do remember that
guy is returning a - I'm gonna return a
77 comma
let's give it now let's say two seconds
and I'm gonna say two comma
our time unit d'art seconds so I'm
asking it to wait for two seconds and
complete at that time if the task is not
completed by the duration oh well what
would that do in this case so when I run
this two seconds goes by notice I got a
79 and the reason I got a 79 is this guy
said hey you know what you told me to
wait for two seconds nothing happened so
I took the decision and boom here's your
result let's move on so so basically
that's what you're doing right I'm gonna
not wait forever I'm gonna settle in for
this value at the time well that's great
so far this is Java 9 by the way not
Java 8 so this is a welcome change in
the addition in the language that's
really nice however if what if this is
going to finish before that duration so
if I go back here and say this is gonna
take a 1 second delay not a 10 second
delay well remember this is 2 seconds
now when I go back and
this little example the value two
propagates to four and the timeout
doesn't really do anything well the
reason for that is when a completable
future has either completed or canceled
you can never complete it afterwards so
that's pretty safe but I don't want the
data I want to prematurely kill this if
it's taking too long what can I do for
that that's even better you can just go
here and say dart are exceptionally and
you can specify in here a timeout you
can say two comma time unit dart seconds
so this says you know what I'm gonna be
patient for two seconds if in two
seconds you finish up your job either
you complete are you cancel if you don't
finish in two seconds I am gonna blow up
that's what this is so this will begin
to blow up and send a cancel exception
to propagate through let's see if that's
actually working so I go back here
remember that the code is pretty fast at
this point
oh let's see what is it complaining
about in this case of course so are a
part of them I'm having a wrong call in
here so this is telling us cannot find
the symbol this is not our exceptionally
there's going to be our timeout
exceptionally I think I can't remember
the word somebody can maybe tell me what
the method call is that is in Java nine
so a little exercise for you I'll make
an asynchronous call to you and you can
come back with a callable future so so
be gonna make the call to this and say
that when this blows up it's an or
function that's going to give you the
result back to you and tell you what the
result is so so that's what you're
saying come back and blow this up at
that particular time anyone knows the
answer or on timeout our time out thank
you so our timeout
thank you excellent so what is this
going to do now when I run this code it
is going to take the time hey it
finished so that has no consequence on
the other hand if it doesn't finish what
am I going to do let's make that a
10-second delay in this case well that's
of course gonna blow up at the end of
two seconds so if I go back and
run this little code now two seconds
later it's going to propagate timeout
exception and that propagates through
the system using the exception chaining
the IDS we discussed earlier are still
the same
the exception is going to propagate
through and give you the result back and
that's the way it's going to work so you
can also deal with this failure on time
out very nicely also what I want to talk
about next is our two really nice and
charming functions where we can bring
completable futures together this is
very useful when you have multiple
asynchronous tasks that you want to run
but you want to bring them together and
do some operations with it so let's talk
about combined and then we'll talk about
compose the names are kind of so similar
right combine compose or what does it
mean well let's understand what combine
and compose me combine is a really easy
to think about you are you have a
completable future you have another
completable future
you want to take the results of those
two and combine them so one one succeeds
you and the other succeeds you want to
take them and combine them together
let's understand how to do this with the
little example here so to understand
this one let's take a slightly different
example here let's just mock this out so
I'm going to say public static and in
this case we'll say an int will call it
as get stock price I'm not going to
really get the real stock price but in
this case I'll take a ticker and we will
say int well that's good enough let's
say int number of shares so I want to
take the number of shares and I want to
do some computation for the stock price
so in this case I'll return so what do I
want to return well I'm gonna say in
here if well first of all define a price
so we'll say in price is equal to let's
say a thousand if dicker not ticker
ticker if the ticker symbol is going to
be equals to let's say Google we will
say price is is equal to 500 for example
so we have these two prices and I'm
gonna return let's say number of shares
times the price so I'm gonna return a
thousand out of
five hundred putting on what the share
prices that should be fairly easy to
work with now what I will do here is I
want to do this but let's take baby
steps on this I want to compute the
price for Google how do i compute the
price for Google well I want to do this
as synchronously so completable future
integer will call it as goog is equal to
and this is going to become completable
future dart supply async and this is
gonna take the sample well there's gonna
be a our sample supplier isn't it
so this is gonna fire up the call to the
get stock price for Google so there's
the gook and finally let's say in this
case I want to provide now let's just
say one stock so I want to know what
this is going to return to me well
obviously this is running asynchronously
so I can say goog
then accept and what am I going to
accept at this point the value and I'm
going to print the value given to me
right so very simple example here what
is this I would be expected well the
stock number of shares is one Google
price is 500 so this banner print 500
when everything is said and done isn't
it that's what I'm expecting
so no no surprise there let's do one
more thing let's go back here and say I
want to now create let's say AMZN
in this case I'm gonna say AMZN well we
know this is not going to be 500 but
it's gonna be a thousand again I'll keep
things really simple by sending a value
of one we don't have to do much math so
if I replace this with returning the
value for Amazon I can then put this
here and say AMZN then print the value
when I run this code that's five hundred
and thousand so no surprise there also
so we got two asynchronous jobs running
they can take some time to run when they
are done we get the result back we can
celebrate that but I want to know my
total net asset if I own the stocks for
both what what is going to be the value
well you know I can take this value from
here I can take this value from here I
can do the math but life is a little
more complicated this value is coming in
inside this lambda how do we get this
value out of this lambda that's going to
get really messy we create global
variables and you know nobody is going
to be our friend when we go that route
so what can we do to make this a little
more charming enter combined I want to
combine the result of these two
operations together so what am I going
to do
see if this makes sense I'm gonna say
first of all goog dart combined and I'm
gonna provide the Amazon so this is when
Google completes wait for Amazon to
complete when both Google and Amazon
complete then I want you to take those
two results and I want to combine them
and what am I going to combine them with
we could say good price and then Amazon
price and then we could perform a total
of goog Plus Amazon price but the beauty
of this is I don't want to do the output
right here remember one principle of
programming the software should be
cohesive you don't want to put too much
code into one place then the code
becomes unco he civ hard to maintain so
you keep it cohesive so this only
performs a transformation and the beauty
is the result of this transformation is
a new completable future which contains
that data which has been totaled up so
then what we can do here is we can say
dart then accept and I can now say given
the value go ahead and print the value
so in this example you know that you can
also do then apply you can perform a map
and transformation further if you want
to so you can build up a lot of these
things along the way
nicely so what is this going to do it
takes the Google's price on Amazon price
waits for them to complete and when they
finish it takes those two values and
perform the little math you want to do
arithmetic you want to do in this case
I'm just adding those two well the
result is one was 500 the other
thousand so the research should be a
1500 if everything went well
oh let's see what what just happened
here
method combined is says variable Google
type completable future cannot find the
symbol yeah what's the problem here I
want to combine these two guys together
so this is the Google's combined method
apparently the combine doesn't exist on
this that's why completable future are
combined let's see if it's able to take
these two values here so this is goog
otherwise we'll have to look up the doc
to find out my brain doesn't hold that
so what is this going to do it's going
to take these two results and combine
them together to produce the results and
obviously that's wrong also
does anyone see the combined method over
there then combined then combined thank
you so the combined operation thanks for
waking me up so right there with then
combining that together and producing
that result over there so this is going
to just do the math and return the
result for us hey that's awesome we got
the 1500 but of course I intentionally
gave silly names for these methods are
these variables and we often do right
because we don't care about those names
and we don't care about those names
don't give them method variable names
that are ugly instead remove them so
what I would do is I'll say integer sum
right here and use a method reference
and just do the job and that's a lot
better way to write this then to
actually go back and provide you know
silly names you can of course give you
know Google stock and Amazon stock our
our Google value Amazon value that's
perfectly fine or you can just use a
method reference as well so we can see
that you say you took the Google and you
combined what's it what's going to
happen if it takes a little longer to
finish so to understand this let's put a
sleep over here and in this case let's
say I'm gonna give it about you know 20
seconds to finish up well I'll go back
here to this code and in here we'll just
delay this just a little bit well this
is coming from the supplier so we can
take the luxury to do that so let's say
sleep over here and let's go ahead and
say this is going to become a value how
about saying this price itself so I'll
sleep for a second or half a second
maybe are times two over
so so two seconds delay well as you
would expect it's gonna wait for the
results to show up before he can perform
the job so that is perfectly fine so
it's gonna wait for those two to resolve
and and you know that they are resolving
at a different time because of the sleep
and that works just perfectly fine as
well as we can see
but then what in the world is compose
well before we talk about compose let's
step back and talk about something a
little different if you will when you
deal with streams if you will let's talk
about streams in the case of a stream
based programming even though what we're
talking about is not only the stream
this helps a little bit let's say you
have a function f1 where it takes an
object and returns another object well a
function takes an object across an
object for example I could say given a
person I want their first name well
that's a pretty simple function you have
a person which is an object and the name
is an object but I don't want a person's
name I want everyone's name who is in
this room
you know what we can do for that we can
say collection dot map or our stream
which is a collection in this in this
discussion and then I can put f1 what
will this do well this takes a
collection and it returns at this point
a collection so that's the
transformation we have on our hands so
map works really well for this operation
what if I have a function f2 where it
takes an object but it returns a
collection of objects for example given
a person I want all their email
addresses not just one email address but
all their email addresses somebody may
have none somebody may have one somebody
may have seven somebody may have twenty
but I want all of them unfortunately if
I say collection dot map F do we now go
from a collection to a collection of
collection of objects may not be what we
want maybe sometimes that's what we want
but maybe that's not what we
so what is the answer for this in in
functional programming we don't use map
for this we use collection dart flat map
of f2 this will take a collection and
return a collection so model of the
story if you want to use a function that
is a one-to-one function use a map if
you have a one-to-many function but you
want to go from a collection to a
collection not a collection to a
collection of collection then use a flat
map so here is another way to think
about it does your function produce an
object or does your function produce a
collection itself we can apply the same
reasoning now on completable future
let's go back to this code did you know
this word get stock price returns get
stock price is returning an object a
primitive in this case into integer
whatever object it could be returning so
in this example I can take the goog and
what I can do here is I can say given
this goog I can then put a little call
that says dot then accept and then I can
say in this case what am I going to say
here given a value I want to output the
value well that would work really well
because the get stock price is returning
an object as you can see right here and
so when you run this the then accept
will simply take that value and
transform it to you know print it or
then you know apply will do the
transformation so that will work really
well for that particular case however
there are times when you may want to
really implement a method which is truly
asynchronous so in this case let's say
the the method we have here which is the
what is the method we I have here which
is the get stock price what if get stock
price were to go a return to us not a
nice little object are primitive what if
that were to return
a completable future itself so in this
case I'm gonna say completable future of
integer so when I call the get stock
price with a ticker symbol and a net
price it says I'm not going to give you
a immediate response I'll get back to
you so I'm gonna give you back a
completable future and I'll take my time
sweet time to compute and get you the
result back to you
so in this example the way I could do
this is I could say return new
completable future and this is going to
take a supplier and I could do take my
sweet time within the supplier to
actually do the work and return the
response back later so this could be
returning a completable future and this
could be taking its own sweet time in
another thread to do the work
unfortunately though if I create a
supplier well you could argue why can't
you just say get stock price and then
call then accept on it sure but remember
when we do the combine if what you are
getting is another completable future
are in the middle of your transformation
what if your function is yielding
something else so to understand this
let's step back for them for a minute
let's say we have a string on our hand
so the string will call it as as well
actually we would say list of string
will call it symbols is equal to list
off let's say goog and Amazon so I have
a couple of different things right mzn
but what I have is a completable future
dart supply async and this is going to
return to me symbols dart get off some
value 0 let's say well now what just
happened this is giving me a completable
future of a symbol I'm gonna work with
now I can say over here dot then accept
given a symbol well then apply rather
given a symbol I could say get stock
price for the symbol
maybe some number of shares but earlier
remember get stock wise was returning a
price this would work really well but
now get stock phrases not returning a
price it is returning a completable
future itself we're kind of a pickle
here right because when this kind of
turns a completable future what is the
result of then apply the result of then
apply is not completel future of integer
but it is completely future of
completable future of integer trikes
that's not what we quite wanted notice
how we are in the same kind of a
situation as the flat map situation so
the question is is that an equivalent of
flat map available for us in the
completable future scenario well
remember then except is kind of like for
each then apply is kind of like map so
something is like a flat map it's gotta
be something like that right in other
words something should say give me a
function that returns a value then you
can use then apply but give me a
function that returns a completable
future then I will work with it now you
know the rest of the story
that's basically what compose is all
about so compose says if your function
returns another completable future then
quietly remove that outer inner
completable future and then pass the
integer to me so going back here then
apply is not going to be fun then
compose and what am I going to do here
so let's step back for a second I
mentioned this is returning
what is this returning this output is
completel future of completable future
of integer if I say dart then compose a
symbol over here
and arrow get stock price of symbol
comma - then the result of this is
completable future of integer so in
other words this is going to take the
inner completable future wait for it to
complete and then take the result of
that and propagate through your chain at
the point so that is basically so that
is why I see this as the then accept is
like for each in streams then apply is
like map in this and then that then
compose is really like you were flat map
in the case of a stream so this is a
nice way to think about how these three
are related in my mind I always think of
these transformations and when I think
about his transformation it becomes a
lot easier for me to work with in terms
of how these are going to combine
together and function and so this is the
equivalent of how these things work
together and and compose really well and
that can be a very powerful way to put
things together so what we saw here was
the completable future well now we can
take this and do divide and conquer
operations so when you put a little job
on me I can either solve it right now or
I can break it down into other
completable future and the compose gives
me a nice way to return to you a
completable future which will then go
subdivide the problem and work with more
things and then we can put them all to
back together so to summarize what we
talked about we talked about how we can
solve problems using a parallel
collections or we can use a divide and
conquer and we saw how parallel
collections are useful with parallel
streams we talked about the pros and
cons of using it we then talked about
how we can use completable futures keep
in mind they are just promises of the
JavaScript world living within Java and
the one difference between those two is
streams of data in the case of stream
versus one success or failure are not
yet resolved through completable future
if you want to download and play with
the examples I have provided here you
should be able to download them as of
tomorrow from my website
when you click on the Downloads link it
should be fairly at the top tomorrow or
later and then you should be able to
download and play with these examples I
hope you found that useful
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>