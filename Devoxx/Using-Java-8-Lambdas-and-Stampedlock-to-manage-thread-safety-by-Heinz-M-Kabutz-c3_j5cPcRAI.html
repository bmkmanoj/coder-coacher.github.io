<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Using Java 8 Lambdas and Stampedlock to manage thread safety by Heinz M. Kabutz | Coder Coacher - Coaching Coders</title><meta content="Using Java 8 Lambdas and Stampedlock to manage thread safety by Heinz M. Kabutz - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Using Java 8 Lambdas and Stampedlock to manage thread safety by Heinz M. Kabutz</b></h2><h5 class="post__date">2017-03-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/c3_j5cPcRAI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">let's look at Java 8 lambda stamp talk
see how we can use it to manage thread
safety so um what is that blocks and
block was added in Java 8 as a new type
of synchronizer and it's one of those
little strange things that was was
hidden for a while not so many people
speak about it's all right about it it
is a bit finicky to work with as you'll
see in this talk one of the things that
allows you to do is that optimistic
reading now if you look at if you
compared to something like synchronized
synchronizes always pessimistic it's
basically the exclusive reads and writes
in fact it's always writing right lock
they were interviewed right clock has
pessimistic reads not optimistic reading
same clock is not reentrant now this
might look like it's a lot of feature
it's it's a it does make some algorithms
quite difficult to do in fact sometimes
what you will discover that this thing
is not not worth it once it gets to
complications there are easier ways of
doing it in other ways and so at the
time that you would use it as a few
Scott and invariant across several
fields in your class if you only have
one filled with known variants they need
I need this they know much better ways
of doing it and for simple classes your
normal synchronized volatile combination
is normally much easier to write it also
tends to be quite a bit faster this is
what the interface looks like we start
with first of all the writing which is a
pessimistic exclusive rocked exclusive
lock so that's your right pessimistic
means that no one else can get the lock
whilst we are whilst once we've got the
lock so we excluding the videos and with
this mystic which means that we are
excluding any other writers and readers
so that's this is really pretty strong
it's like a synchronized and when we
call right lock it gives back along
which is a stamp which we're going to
use as a signature for locking and
unlocking
knocking there's another mythical try
convert you write lock well this is
something we have gotta read lock or an
optimistic read and I try to convert
that stem to a right look this might not
always succeed but it won't deadlock now
if you compare this to really read write
lock if you try and take a read lock
near try and upgrade that to write lock
you will always deadlock even if it's
not necessary you will always deadlock
even if there's only one thread that has
the read lock it will still deadlock
just to be safe and the idea is that if
two threads at the same time have a read
lock and they're both trying and upgrade
to write lock then one of them could
pass someone could fail but they can't
both succeed because it's the exclusive
lock and so this is a function which you
be smooth which I'll show in a moment is
not very useful because the algorithm is
incredibly complicated to use this and
there are better alternatives and unlock
right is basically like your lock and
unlock and unlock right verifies that
the stamp in fact belongs to a write
lock not to read local optimistic stamp
and they bunch of other methods which
I've not put in here like time locks and
things like that and the read locks way
it looks very similar this redox is a
non-exclusive lock so it's too
pessimistic which means if I have a read
lock no one can write while I'm while a
whole one wasn't holding read look this
is what we mean by pessimistic and and
so read lock returns a stamp again
that's going to be a number that could
be 0 0 means that it couldn't get us
which in this case wouldn't make sense
try convert to read lock means that that
we have got some lock which could be for
hablo right lock and we try to convert
that to redock now that should work but
we also could have an optimistic lock
and we could try and convert that to
read lock again this is one of the
functions you're not going to use that
much I'll show you so much are more
useful and unlock reading and verifies
that we in fact do you have a read lock
that we're not trying to unlock
accidentally the right log in to read
look and there's another one unlocked
for
or for anything which which doesn't do
any checking so that will always unlock
it isn't such a read or write look so
sometimes you don't actually know what
you've got in that case unlock is the
only one to use now there's also
optimistic and i'll show you how to use
all of these in a moment you would say
if i start up a trap domestic greed and
this would this could return 0 if for
example someone already has the right
block if someone is holding a right of a
try and set to optimus agreed it comes
back immediately with a zero now in the
algorithm i'll show you we don't
actually check with a lot of this zero
we assume it's not zero because we are
being optimistic that's right and then
we've got a validate which checks
whether number one stamp was zero which
will be false return false all if
another thread has in the meantime try
to get the right look so the National if
the infinity has been damaged but we do
know that someone has has acquired the
right rock and so it's not safe to
continue and we either have to try again
or we've got to get a read lock a
pessimistic read lock now I live on the
island of Crete and creates a few years
ago about two years ago had a crocodile
a real live crocodile I've even been
decreed it's not really the terrain for
crocodiles and it didn't swim over from
Egypt either probably somebody had it as
a pit you can get all sorts of pits and
Crete and it grew and after a while it
ate up all these chickens and he thought
well you know this guy wants to live in
the you know in the wild so he let it up
into the wild and this crocodile was
walking around for a while he eventually
froze today's because it does get calls
and creature winter so he's died and
they tried to catch him but they
couldn't because he was so well said he
wouldn't go into the traps is like I've
got 70 chickens and and you know babies
and stuff I don't need to go into the
traps so cc's that's what we call them
spots the way but he was on at it now
imagine that you want to move from one
place to another on Crete and you moving
from point
00 2.55 now I want to go to diagonal
line from north to five but I want to go
and go and become crocodile food i want
to go from naught to fire but i want to
do this i don't want to go via CCS and
end up in his belly that's the bad one
right we want to be always has
consistency in our position now there
are some other examples besides
positions as well so I'll tell you some
other ones the moment now M our position
class has two fields it's the double and
the x and the y and X to the y and what
they are is that they are just basically
to pursue your coordinates and there is
an invariant across them as we saw
before we don't want to be crocodile
food we want to survive walking along
the creek and countryside and so and
what we're going to do is we're going to
move them together so what weekend is
going to get an exclusive lock the right
lock pessimistic exclusive lock and we
they need to move the x and the y
together and lastly we unlock the right
now of course if you were to read x and
y optimistically you might get them in
an inconsistent state so that can happen
but you get a different Exodus and why
now so for any questions I'm going to
just put it put a few questions and
slides in here because otherwise run out
of time with questions at the end losing
a case of one I've got sort of the top
pin users of written on this link if you
interested well I'll show this again
later all right now and this is one way
of doing it another way is to use atomic
references or unsafe or four handles so
this is what atomic references would
look like if I put anatomic reference
onto a double array of x and y then what
i could do is in the move function i
could simply do a campaign set and try
and fit it to the new value so i'd get
the current value at work out the next
value and try and set the next values x
and y 0 and 1 and then if I succeed I
would
would I would exit from me otherwise
i'll just try again so it's your typical
campaign sets method and we can do it
something similar with unsafe of course
that's much cooler right because we can
completely destroy our memory and
everything else on our system and anyway
so to do that you'd have to first get
down safe you'd have to get to get the
offset for X&amp;amp;Y you'd have to get the
field XY finest all of those days and
then at the end what I've done is I've
made the XY volatile so don't have an
atomic reference point you to it I'm
just pointing it to directly at the
bottom of the slide here and then this
looks very similar to atomic reference
so I've got my double array current
common x equals in that new double array
so I'm making a new one up front and
then I mean again using campaign swap
object this time to try and and do do
the cavs on this on the subject and the
move is actually going to be in many
cases quite efficient we just have to
create a few extra objects but we might
also sometimes you also have to
construct the extra objects and we use
stamped lock so it's not necessarily
worse than the stem clock might even be
better now wendy is unsafe never unless
your name is Martin Thompson otherwise
keep away from it the it's got this
reputation that it must be much faster
that much much better and they are of
course cases where this is true but it's
not always true and sometimes you can
get yourself into big trouble you might
end up writing some code which is no
longer compatible between different
architectures and hardware so we don't
we want to keep away from that as much
as possible and there was an alternative
before we had unsafe for doing this up
of cares directly on the fields called
an atomic filled up data and we mind for
quite a while that they should make that
as fast as unsafe and that we've always
told they're technically reasons why
they can't but now they've done it so
now it's actually just as fast as as
going directly onto the onto the vaunted
unsafe and a driver nine that's added
another concept calls for handles
now one handles are are an improvement
it takes away the biggest reason my
people use unsafe of course there are
other reasons which aren't dealt with so
well with Phi handles but generally this
is this we're going to look for now I've
done a bit of testing on it and it seems
to be the same speed as on safe so it's
supposed to be the same speed as on set
for supposed to be very very thin layer
and basis that letter to optimize the
way they end up with the same speed and
we've got some cool features say we can
work with sensors directly we've got get
volatile set for the top get acquire set
release and compared set auto campaign
exchange volatile and that's more like a
real campaigns and swap we're actually
getting the value back that was there
like companion exchange volatile when I
first saw that I thought great so this
is going to make the code faster in my
experiments it seems that if you're
highly contended it doesn't really seem
to be that much faster in fact it seems
to slow a rather than faster it's good
under moderate contention and it's again
probabilities that that make it be like
that and now the way that you'd use it
is like this you'd say you'd make vai
handle the XY handle and you'd use
method handles to find that for handle
with the name of the class and the name
of the field and the type that this
should be and hopefully you'll find that
that particular field and then you can
operate on that field directly and for
example with the move function it would
look very similar to the unsafe version
and also the atomic reference m version
as well we would just have the handle
dot campaign set and all the other fancy
stuff sensors and so on on that as well
any questions before you move on my
questions ok
checking with you with me now let's get
back to stamp lock and the whole reason
of using it is not the exclusive
pessimistic locking but rather
optimistic reading that's we're going to
do and you end up with getting better
throughput then something like the
reentrant read write lock now this is
the idiom that we normally use for
optimistic reads obviously you have to
be bit careful here in there because
some things do change but it's good one
ladder time so first of all you would
get an optimistic read stamp this
optimistic read stamp is going to it
might be zero if you're unlucky but
we're assuming it's not zero and we're
going to continue as if it's not zero
now the soft mystic read stamp comes
back and we then assuming that is not
zero read the local values read the
field values into local fields now he's
got to be a little bit careful when you
do that because when you're reading the
state you're reading possibly
inconsistent state so you might end up
with ionic sort of Bounce exceptions not
in this case but in other cases you
might end up with no point exceptions or
infinite loops if that if the state that
you accessing is in such a bad state or
inconsistent state that you that your
your your code actions are being
corrupted so we have to be careful as to
what we read inside that statement in
our with with our point of easy with a
sweet x and y to local doubles as the
easy case but in other cases when you
have a more complicated invariant across
multiple fields it gets more difficult
and we invalidate the stamp and we're
assuming as i said that that it wasn't
02 start with in our experiments we
found that it was pointless testing for
zero because it actually ended up being
slower rather than assuming it's not
zero and just just reading the venture
local values and so hopefully hopefully
hopefully nobody tried to get a write
lock in the meantime and we'll pass the
validate and if we don't pass the better
that then we could then be grade to a
pessimistic read lock
now what we could do is we could retry a
few times and of course this is always
the equations how many times you retry
before you give up on optimistic and
become pessimistic I live in Greece so
we we become pessimistic very quickly so
we've got here the reciprocal read lock
I get to read lock stamp and I update
the stage the local state readers from
the fields and then i unlock the weed so
whilst I'm getting the lead lock no one
else can write but other prophetic loves
to read at the same time what you'll
only find us if you have a with the
optimistic reads you should get the
optimistic read about it at least not
extent of the time so in most cases you
should you should go through quite
nicely and that's sort of a code idiom
if we apply this to the point it looks
like this it's got first of all we we
get the traffickers agreed gives a stamp
we then read the x and the wire fields
into the local variables current ex and
current why I then validate the stamp if
it's not valid then I'm going to degrade
to read lock a pessimistic read lock
non-exclusive look and then this time no
one can write while some busy reading
the fields into the local variables and
as I said before you could retry a few
times three four five times whatever you
want maybe you'd better spit a chance of
success in and then lastly return the
mascot hypotenuse using the local values
rather than the field values okay so
those are sort of the idiom and as I
said when you're reading the fields of
the local variables you sometimes have
to do some some some bounds checking to
make sure that you don't accidentally
and get index out of bounds exceptions
or other exceptions that could occur in
in this piece of code obviously not here
can't but in other cases it could now
Tomic reference is actually not easier
to do this this particular calculation
because all you need to do is you can
say X Y which is pointing to our double
array dot get which gives us a double
array of current and then we can simply
use the current Norton current one in
the calculation so this is very easy to
write the very fast and faster almost in
many cases send this okay its largest
not as complicated as well so the point
of the place we were winning with the
stamp lock is on the is that the is
doing the writing we normally don't have
to construct new double raise all the
time but of course constructing objects
is also not that expensive in Java and
with unsafe our handles it's even easier
because what we're doing with unsafe and
violence were using that we're pointing
to the objects directly and so because
of that we we don't we don't have to
call gate we can just say current equals
the field X Y and then after that we can
say return mascot hypotenuse of current
naught comma current one right okay so
and so far we've seen two little idioms
of how to hard to do this I've hearty
how to apply stamp lock and that is the
third one this one is looks really
really fancy and complicated but it's
not that useful I'll explain one the
idea is the following that withstand
block you can upgrade read lock to right
hook you can try right you might not
succeed but you can try let's study and
with the reentrant read write lock you
can't even try you will you'll deadlock
whenever you you try to do this oh so
with with the stamp lock what you can do
is you can take a read lock you can then
say let's see whether or not we have
some conditions so the idea is that we
only move if we are at eight
particular position so if we are
position 3 comma 3 we want to go to
position 5 comma 5 but if you're not a
position sitting above three we don't
want to go to position 5 i'm going to
stay at position 3 comma 3 that's sort
of the idea that we have with with with
a stamp lock also with with us with the
thermoses method no and first the first
time I come in here if my condition is
true then I want to try to convert my
read lock to a right look if it's false
then I'll jump out of the while
immediately and go and return false and
unlock the read look so if it's false
you unlock the weed lock if it's true we
try and convert the weed lock to right
look this might not succeed it might not
succeed if for example you have if for
example you're somebody else has also
gotten the gobbler right lock at the
same time using the same function but
hopefully it will succeed if it doesn't
succeed then we would go into ELQ
statement so the right log writes that
would not equal to 0 we'd go into the
second second condition again you'd say
we'd unlock the weedman and we'd lock
the right now what could of course
happen is whilst I've got the read lock
no one else can can gets right lock but
in between those two statements when I'm
saying unluckily the name right lock
somebody else could actually get the
lock and get the right lock and change
it and as a result we have to check
again this is why we checking the
condition again at the top and so the
second time around when we when we come
into this try converge right lock we are
guaranteed to have a write lock before
we had a read lock and we might have
gotten a write lock but now because we
had a write lock when we said try
convert we always get a write lock back
and it always works so the second time
around it always works it won't be 0 and
now we can update the values and returns
the sort of the idea we have with us
with with using this
additional change medium in stamped lock
however this is not very useful it's
only real academic interest because it's
it's much easier to just use a write
lock to start with look at this over
here I'm saying long statical desolate
right lock if the condition is false so
if it's true we set the citizenry value
return true otherwise we unlock camuto
and false so this is much simpler to
understand and in all my tests I've
tried it was also faster think that only
the only time it will be slowed we
extremely weird cases so in most cases
you be you'll be faster with us than the
previous idiot medium okay now here's
another way this is now was it was a VAR
handled version what I do is I take the
X Y and I put it into currents of what
the current value now and our first of
all checks the condition of the
condition is false I don't have to do
anything else I can return but if the
condition is our I'm not returning
trainer true or false so I should make
sure you turn faults in this case if
it's not true and if it's true I I work
out the next value and I tried to move
the next value but um if I don't succeed
to look to so if I succeed I turn off
learn succeed I'd have to try again and
make sure that the current naught is the
equal to old eggs and the current y1 is
equal to old wire so does not look at
this for a moment because i think this
code is correct but it might not be so
hard to test these types of things
because you know you run a piece of code
and especially when it comes comes to
trading you run at any run it for four
days and weeks and months and it seems
to work and in 147 you have some
condition which makes it fail let's of
interesting interesting cases recently
with with reading bugs
example is concurrent hashmap because
ganache was supposed to be in a really
great map to use concurrently right and
we've got a nice new function that I saw
being displayed today called computers
absent fantastic computers absent right
so we don't have to have this put as
absent then if it's then contains and
which is riveting on one line problem is
computers absent can cause nasty very
nasty contention on the system now this
is not just a theoretical case you
actually saw this is a real system way
they're going to take out the computer
babson that replace it as put as absent
because there was too much contention on
that it happens if you have relatively
few keys and lots of cases where
computers absolutes being called from
multiple threads so this stuff is not
easy how much time do hers until then
please like a good perfect thank you so
any questions about this sir for the
questions okay so and what I've got is
us to find some some helper methods to
make this easier to use right and to
make it easier to master and those ideas
are following that instead of having you
know the idioms hard-coded hand-coded
every time we we write a facade sort of
a facade likes again a full facade
pattern and we use lambdas to make these
bit more pluggable so this is sort of
the way that the old move function would
look Mesa good look we have got move
taking the you know the Delta X Delta Y
and what I want to get to is where i'm
using a lambda 2 instead do the action
protected with x plus equals delta y
plus equals delta so this is my land
over here it's going to show you the job
that must be done and within a write
lock now this one's very easy to do with
with stamped look so with split lambdas
what you do is is something like this
you'd make the runnable which would be
your right job you pass and run double
in the stamp lock and inside this step
lock idioms we would say long stamp a
salad right lock we would try and and
run the right job and then finally we'd
unlock the right now unfortunately
landers don't play well with exceptions
with checked exceptions and sort of the
guys who's looking after Java admitted
that they that this is a mess up this is
a screw-up because they basically gave
us an unchecked io exception and uncheck
I exception stuff with admittance of
guilt you know we now checked exceptions
are bad we're very sorry about it we're
not going to make an unchecked exception
for you guys but we're going to make an
unchecked io exception because we need
it and internally they use some very
weird rewiring of exceptions with with
generics with the basic costing the
using generics unsafe uncheck what if
unchecked them costing to convert the
the check to the unchecked exception to
runtime exception and then there can
throat so so unfortunately runnable
doesn't support exceptions they want you
could do this with the tribe less
resource as well with the trauma 3
source java 7 to Travis resource and and
that will handle exceptions find and but
it's it's but it's a bit more messy
trying to try to get work okay so here's
destined for origin and and this is what
the code looks like at the moment we are
getting up to mr. greed I read that is
locally valid at the stamp we've seen
this before maybe did a few times and so
on now the way that the code what I want
to get to is something like this we have
got distance from origin a method which
we are first we I want to pass them
first of all the the code that would
read the values onto local values
and then lastly the code that would take
those values and produce something with
those values now this is again there's
going to be a bit more expensive then
then the other than the original code
because we have to be some record we
have to construct a new double array the
new double array might be eliminated by
the scapula so i think i'm not exactly
sure the land of certainly could be
eliminated by escaped analysis so we
shouldn't have too many expensive
creations they will have and so this is
what the curve would look like i pass on
a stamp lock I parson a runnable and a
parson a supplier that would return a
tea and the tea would cause me any type
that you can return again we've got the
problems with exceptions as an exception
occurs that we can't deal with that
properly because lambdas would have to
be declared to explicitly throw them
which of course you can do but it's it's
would mean that you always have to also
catch those exceptions now um so here
what we do is we'd get up to mist agreed
we would then do the reading lock run
and if you go back to previous one this
is the land of here runnable lambda that
reads the x and the y into the current
northern current one and then if that is
a it is false then we say reading dot
run again so we try it again reading
into local variables and of course java
java can't pass and like you can't have
turned two values you can only return
one value from from the message so the
slumping of this way around and then
once you succeed here then we're going
to say return computation or gate which
is going to be to start messed up her
paw Tania's current node comma current
one all right
and hopefully the reading run will be
inlined it should be in line now the
move is at this is another one here
we've got the moves app that i showed
you before where we only moving if we
are at a particular position and I want
to get to something like this way the
first thing is a predicate or actually
it's a supplier of tribe boolean that
returns true or false if we are at a
particular position and the action that
must be done is I want to set to the new
position if I'm at the opposition yeah
off the of the three diem this one's
actually the one we get the biggest win
even though the actual idiom doesn't
help you very much it's not going to
make you faster / make you slower but
this one looks like you'd say while
condition don't get as boolean while
that's true that's the same as we did
before we try convert to right look if
this works then we call action got run
and there's something else I doesn't
point out the last time is that when we
unlock the unlock stamp we don't know
what it's going to be so what we need to
do is to sign the right step all the
weed stamp it's sort of as a redesign
but if we do manage to change it to to
the rights of me to assign the right
sent to the stamp so we unlock the right
step I mentioned at the beginning that
the stamp lock is not reentrant and what
that means is that if you've got a read
block you can't also get a write lock is
where the writer can also get a read
lock in fact if you've gotta read lock
they try and acquire the read lock again
it will deadlock and so this is why you
can only have one block at a time each
week and everyone anyways one lock and
so and so we wouldn't unlock both unlock
one step okay now to do this with the
atomic references lambers you could do
the following there's the accumulate and
get functional in Java 8 it's been added
to the atomic reference
and it's one of the same ideas that we
can use lambdas in order to make our
lives easier with idioms I've tried
using it a few times and most of the
time I find it easier to just write it
by hand rather than try and figure out
how a team works the idiom is goes a
very certain direction specific
direction and if you gotta do something
which is slightly different then to use
it you sort of gets back with it now
let's cover this the the old move method
we would first of all say current from
an x equals e dubble we then read the
values into the current update the
current and update the next and try and
set it to the next value inside the the
accumulating gate what we do is we have
to pass on the initial value which is
going to be a new double array and
that's going to contain the method is
going to be called the actions going to
be called is to sit next note and and
next comes from here right so this gets
passed in and this double gets passed
into the lambda as next the current is
your current value Nexus is the next
study which which is your double array
over here and so we would say next
naught equals the current naught plus
Delta X and next one equals can't 1 plus
Delta Y over here and then we'd return
the next value hopefully that will work
as a the human etiquette is a very
specific mechanism is also I think
getting accumulate and to to show you
how you can work with lambdas and with
these concurrency constructs to try and
make media to to use and unfortunately
in reality very often you have to
customize it a bit and then these
lambdas don't work anymore so I've come
to come to conclusions slightly ahead of
time which is quite unusual for me and
with giant Robert Landis they can help
you to to to get the proceedings more
correct to get them correct there's not
more correct as either correct rule is
not correct and as I say there's an
example in the jdk accumulating gate
shows you how others is done and
unfortunately landers might there might
increase object creation rate another
hand object creation rates is nowadays
not such a big fact anymore the scape
analysis can can get rid of that quite
strongly also looking at java nine
Beauvoir handles its look they look for
the other type of coding as good as as
unsafe better than us certainly safer
than unsafe and then not very many cases
where you would want to use unsafe for
the top of code in the future so we'd
have to wait until all of the
concurrency classes get rewritten now
there are a few classes where they
haven't used on VAR handles yet for
example in concurrent attachment they're
still using unsafe we have an atomic
integer they still using unsafe not for
handles- changes and we most reasonable
and ability at BET and the reason is
simply a bootstrapping reason that they
they need to actually need atomic
integer before they can but before more
handles are available to be used and so
they they're still sticking to unsafe so
beautiful Brigit bootstrapping until
they get that sorted out and got any
other final questions yes
me but it's different too difficult to
set up different looks because this
particular implementation can have
subtly different performance and
behavior if you have a very low low in a
very high concurrently okay I'll repeat
your question for the tape and also for
the recording for the for the audience
Mario's asking how on earth can you even
begin to start looking at benchmarking
with these types of components the
problem that we have is that it's very
much system dependent so it matters
extremely much how much how many
concurrent 3ds got heating it what the
load is what the time is in between and
I've done lots of different tests trying
different loads but I would say that
that none of my loads are none of my
tests are conclusive the only thing that
matters at the end of the day is what
type of performance again what our
fulfillment gain or loss are you going
to see in a production system that's
anything that matters when I can come
with benchmark I for example at an
argument with with with a friend of mine
about what is faster era blocking qlink
blocking queue and you know as a stupid
argument because both are very slow in a
rather take you know lips and workouts
or Martin Thompson's cues they're much
better than those but put that aside for
now did this was heaven I word which
one's faster and and I said that the
Arab rock and Q is slower because it's
using one lock for both put and get and
and my friend said no links link block
and Q is slower because there's a slower
practice because it is right and and so
has this big argument in front of a
class teaching and concurrency course
and and often i went back to the troll
and i wrote a benchmark to prove that I
was right but it took me like three
hours to write the benchmark so that it
prove that I was right because it was
other results of sure I was wrong right
the link blog he was actually fast in a
bug and q no sorry everybody was fast
and I link talking key form is
everything but there was a very specific
case way it was slower and that is where
your where we have one thread writing
and once read reading because then you
for cottage between the two on the
airlock you but not on the link taktik
you but maybe you've got multiple
threads reading and writing there's
contention anyway and of course then the
argument is if you only have one thread
reading and writing do you really want
to take a link blocking q when i wrote
if you know you don't it was taken non
non blocking mechanism for that and it's
it's so it's it very much depends on on
your system so a template that i can
give you is is keep your eye out for
coming for full content in your system
it it appears every now and again and
and it is really is a performance killer
and it's something where when you see
the contention that's where you can't
try and address it it's not contention
or something that you can guess up front
they're just too many variables and play
in the real system so yeah any other
questions yes sir with apple machine I
love these Apple machines i mean at
least i can see people are they
okay what about which which could this
one ok yes yes ok let's cover this again
because this is one of the most
important additions to the language try
to stump look with without this step
looks pretty pointers so what we doing
here is we are first of all getting a
number of optimistically that's we then
run and we've added eight now um if
somebody else is a meantime has so what
vetiver says it just says that in
between when i call trust with sweden
with a code validate nobody acquired a
write lock that's all it says it doesn't
give any more guarantees than that
that's all it says so if after you
validate somebody changes somebody gets
the right look so basically before the
return it doesn't matter because we
really have copied before you wait the
local values into em into local rebels
so if they change it let's find it and
change it
it gets it gets it quite interesting
there was one will quickly show you one
news letter that I wrote on the topic so
one of my friends sent me some broken
code he need was broken and the code
looks like this it was basically an
ArrayList with with two synchronized on
two different locks right then it was
completely broken the first person to
respond was actually Martin and the the
real reason why it felt so consistently
was was the first one of the statement
over here our size plus plus equals e
okay and because we actually are saying
size plus plus that actually and and so
it emits a size in before you before you
do this array equals e now and what i
did was i implemented this using using
stamp lock wisdom klockner and it's
basically over here and the and the the
gate became quite complicated that's
what the gate looks like i did it's
optimistic optimistic Spencer tried a
few times to get success I to optimistic
read now because I've got an array which
where the contents can change I need to
be very careful first of all I read the
size i didn't say i read i read the size
ender and the pointer to the Ray into
local variables and being optimistic all
along I'm as I'm assuming that it won't
be changed at the same time then I'm
saying if index has less than array
links
then I'm going to say get the value up
so at this point I don't actually care
whether or not index is less than sighs
I could do that inside range check
raincheck does that for me but all I
want to know is I'm not going to get an
error in a sort of bounds exception so
assuming I don't get that and then if I
validate this letter that's correctly
then enter the range check and that that
could potentially thrown index out of
bounds exception and then return our if
I don't succeed after several times with
some number three four five times then I
go to the pessimistic read lock now I
can do raincheck immediately because no
one can change while some business doing
that and then I can return this not
array index and the unlock the meat step
yes one why did we sighs oh here this
one the rain check is to check whether
the index that was passed in is within
that is it is listen is within the inter
a yes absolutely
ok so I'm reading ok good you getting me
really worried there Martin it's like I
know yeah ok good well thank you very
much for this thing tom is over</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>