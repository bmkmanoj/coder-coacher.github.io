<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Hibernate you know it… but actually you don’t by Emmanuel Bernard | Coder Coacher - Coaching Coders</title><meta content="Hibernate you know it… but actually you don’t by Emmanuel Bernard - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Hibernate you know it… but actually you don’t by Emmanuel Bernard</b></h2><h5 class="post__date">2017-06-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/6AS6rw56jSE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right let's get going
thank you for your time I think like
many speakers and kind of a noob in
everything Singapore first time here
very impressed so far so nice nice to be
here today we're going to talk about
hibernate probably many of you actually
use the object relational mapper the JPA
mapping but there's actually quite a few
other projects so what we are going to
do today is really have a discussion of
what he knew about hibernate the object
relational mapper but also give you some
of the features that are not necessarily
new but that people tend to not know
about and will you know hopefully you
get concrete takes away to use into your
project and I'll also describe you know
the various other hibernate projects
again to make you be aware that there is
just more than the object relational
mapper and this in this one so my name
is emmanuel Donald I work for Red Hat we
actually made a pretty nice custom
Singapore custom t-shirts go by the
booth and get one just up to register to
the developer program which has a
product for free but also a quite a
bunch of good content you can know
everything about me online the key thing
is I've been part of the hibernate team
for a long time now I've been founding
some of the project we are going to
discuss and also I walked heavily on the
GPA implementation when we you know
studied to work on the specification so
without with no further ado let's go and
start discussing hibernate or and five
so who uses the latest version hibernate
five or more
my boss is here and say hey yes I do so
I guess that's going to be a very
interesting presentation for you who is
using five sorry for okay three a quite
a few and three I don't know guys like
ten years old or some things though get
on it so the first thing we worked on is
rethink how we bootstrap so for the
hibernate three and hibernate for people
you remember that you have your
configuration object that is basically a
melting pot of everything you can do you
can add properties you can add classes
you can start create the initial mapping
information and add classes again and
that was pretty much of a mess for us
because the life cycle of things was not
very well defined wasn't really defined
at all and we always had to do several
phases of we looking at the you know
what we had looked before to make sure
we haven't forgotten things so that was
one part of the the rethinking the other
rethinking is that in a more and more
modular universe so you probably have
heard that Java nine is going to come
with the jigsaw projects or the modular
modular system but even way before that
was OSGi which is coming which is all
mobility rules and observers like
whitefly also used modularity at their
core to simplify the deployment and how
do you put a few interesting things like
the ability to deploy two different
parallel version of the given you know
module or problem or libraries without
you know breaking everything as long as
the same library is not used within the
same active module the other cell module
can work with different version of their
library without breaking things who met
who ever had a problem where two version
of Jackson were conflicting and you had
to pick and choose the two libraries and
there was a bit of a mess that's trying
to fix that kind of problem the other
advantage is security because we only
expose what is needed in the insider
module then there is less stuff exposed
it's been a famous
CDE
Java universe around Java collections
that were allowing the initialization of
pieces of code that could be arbitrarily
executive so that one would have been
kind of hidden by the security as long
as you didn't have you know the comment
collection in your direct application
even though any of your dependency would
have would have used it and finally you
can actually speed things up so while
fly that's one of the good reason why we
did that it can paralyze the load of the
values classes and really be a super
efficient so with all those good stuff
being said it was pretty much a
nightmare for us to actually motorized
make make sure hibernate works in a
materialized environment and OSGi before
then while fly and and those guys were
like I don't let you go really screwing
things up we really need you know a
better way to integrate with you and the
problem is hibernate uses a lot of
different resources there is hibernate
the code base right
that's one thing and then hibernate as
values extensions and we use service
loader you know the meta and slash the
service name does the file inside out to
really detect a new entity and so we
need to pick up and look at other
modules or other jars to see if they are
available we look at your entity because
we need to persist those so we need to
access those we extend your entities
because we created proxies so it is
essentially a subclass of that so we
need special access to that we have your
you know XML file that are here and
there so that created different
resources that in a modular system are
in different area so we really need to
give the hooks for the values system to
really get access to that so it took us
years literally of work we think we
finally got it properly covered and the
way we did that it's a little bit
smaller if I can array these by
separating the bootstrapping two
different well-defined step the first
one is to define the services we have
access to a services like the data
source or the
connection pool or the second level
cache or the class loader that we are
using to load your class and so on and
so on so that's the first step where we
get everything all the tools we need the
second one is let's list all of the
entities or the mappings that the user
is is going to use so it could be the
list of classes because we could be your
HB n dot XML file it could be your
object or I'm that XML file you choose
JPA and we've got the fallacies we've
got the metadata and then we bundle them
together and we bootstrap the session
factor that's why it works nowadays who
is using JPA
as as the primary API instead of
hibernate as the primary API okay so for
you either they say in Java EE the app
server actually bootstrap that for you
so you don't really care about that or
even if you bootstrap JPA directly you
don't really care because you you do
persistence that create an teaching
manager Factory and all of those steps
are actually done inside inside hydronic
another thing we did is look at Java 8
and look at what features med stands for
Java 8 that we didn't cover inside
inside hibernate so the main ones were
the support for the new date and time
type and since we decided to make the
move so I think it's in hibernate 5.1
where Java 8 and more types so starting
with hibernate or and 5.1 you have to
have Charite we also look at other api's
and try to are generic and blocks and
stuff like that here and there to just
make the feature incremental be better
if you use datum time so for hibernate
5.1 and above you don't have to have
these additional maven dependency but if
used 5.0 since it's pre Java 8 we had to
add a separate model for the data and
time support but bottom line is if you
use local date local time offset time no
they are supported and by default we use
you know the most interesting type for
for support slow nice addition
jerax and otto plausible so again if you
use an app server or spraying they will
actually start and stop the session for
you but we met all resources like
session session factories for about
actually auto-close about so you can use
the try the try resource block that java
i get seven brought to the to the table
the other stuff you can see if you
coming out with the native session and
so it's super small don't know why
anyway can ship : there you go
if you look if you're familiar with the
session API you can see that session
that get address you don't have to don't
cast address to the address type so
that's the generic general specification
that I was talking about which is
present in JTA but wasn't present in the
the hibernate API generally speaking we
try to deprecated our all API that were
similar to the JPA APRs just to focus on
the edition okay one big feature that is
not on out of the box but it's quite
interesting is by con instrumentation so
out-of-the-box hibernate to do the lazy
loading boundaries uses proxy so when we
when you load an object which has an
association to another object which is
lazy what we give you is a proxy and
when when you reach that proxy and you
actually try to access one of the
getters that's when we will actually go
to the database load the data put it in
okay that proxy doesn't require a bike
on instrumentation or any magic like
that but if you if you want what you can
enable by con instrumentation and this
part of your interesting benefits so to
take a bit of step back let's see how
hibernate knows that you change your
object so you load an object from the
database hibernate loads the literally
the result side so it's an area of
columns okay
all of this array of columns we create a
new object we populate it and we give
that object to your application okay
that's the managed object in the session
and we but we keep this array of color
somewhere in the session as well you
play with your object you change some
stuff and so on and when you do a
flourish or when you do a comment which
will trigger a flash what what happens
is for all of the managers that in our
sessions we look at them and we compare
the value of the values properties to
the array of columns that we are here
and we say is it different yes
is it different no and if one of them is
different then that's when we trigger an
update otherwise we say oh the object
doesn't change so we don't have to do
anything and it looks like it could be
expensive because for every object in
the manage in the session you really
have to do this check for every property
of this object in practice it's pretty
efficient except in some areas where
people have like massive objects or
loads of different objects in the in the
session but with bicon instrumentation
we can do better because what what's
happening is we actually changing the
code of your entity itself and when you
do a change we will know about it in the
entity class and we put a flag on saying
hey this user has you know touch this
entity and made a change and even more
than that we know about the changes
you've made and we collect them so when
the session does a flush instead of
going to every single object and do a
comparison it will just look at this
flag and say oh flag is on there is the
list of changes my job is much faster
I've got less entity to look and also I
already know the the changes so I can go
straight that's the improvements we've
we've been doing how do I enable that
you if you're in a if you're in Java EE
actually the class instrumentation is
done for you as part of the boot process
just make sure you enable the use class
and answer and then you decide which
feature of Vital enhancements you want
to use so dirty tracking is what I've
been describing about this flag there is
also the lazy initialization of
properties that I will mention in a
minute and then the label Association
management which I will mention in Tunis
so let's go on so that in Java EE that's
how you do it you add the properties in
your persistence but external or
hibernate dot tau dot XML but you can do
it do it at real time too if you
energize the environment for example so
issues maven that's the plugin and how
you set that up and again you can select
which features you want to enable and if
you use greater it's pretty much the
same so you add the dependency and then
you enable the module and you select
which property you want to run it
ok lazy property so you've got lately
associations right which means when I've
got an object and has a link to another
object I can make it lazy so that I will
only load the other object when I
actually access it it can do the same
for the I guess primitive properties
like you know streets or you know like a
string or number or anything it's not on
by default so you need to use the add
basic and such type in course latex and
by using by colonists on what's
happening is that when we load the
customer object we only load the non
lazy properties populate that and we've
got the by card announcement magic doing
things and intercepting your call to the
getter and if the getter of that for
example the Accounts Payable reference
ID is not loaded we will go and load it
and until then what happen is that we
treated the properties in two big bags
the first bag is we load them right away
when we load the object and the second
bag is we load all of the other
properties that are masked as lazy in a
second step but you it was really a
two-step process not a flexible approach
so what we've added in the latest five
releases the notion of lazy group so
here you see that the image is in the
group table for the bad name but it
could have been a name like resources or
assets or something like that and what's
happening is that when you when at the
user I do customer dot image then the
bike enhancer knows about that and will
go load the blob and all of the
properties that are not as lazy good
blobs in this case okay so you can
really add different groups not to big
bag but the in your bag and then
several lazy bags of property so it
gives you more flexibility instead of
having to write a flight wait pattern
pattern or things like that you can use
this discipline the other one is a small
but an interesting one
so in hibernate if you have a
bi-directional relationship what you
have to do is well first of all there is
one side that is the owner of the
association which means hibernate we
look at this side to know if you've
changed the Association and which I need
to print the foreign key column okay but
from an object point of view what you
should do is update both sides when you
add a link from in this case from order
to the link the the line items you also
have to link line item back to order
right and usually people add the order
that add line item method to it to
actually do that kind of work that's a
manual step if you forget or you know I
mean it's always always been a bit
annoying so very tiny small improvement
that we did for the bike on announcement
if you enable it is to do that work for
you so in this case we might look at
that there is four lines in the first
block and here there is only three lines
but it's doing the same job the fourth
line is essentially added as by phone
announcement for you a tiny button
interesting small atom second level
cache with quite a few things around
that the third thing is it's not a new
feature per se that we've been working a
lot around informing improving the
performance of hibernate but not in a
synthetic lab but in in kind of real
life so we took a real-life project we
make it run as fast as we can that means
improving some part of wildfly that
means also improving some part of
hibernate and because in this example
the the the project was a very heavy and
instead database intensive application
we hit hibernate very hard so what we
found at some point is that one of the
critical paths was creating so many
are a object that the VM was essentially
at its cap of number of parallel objects
you could create so we reduce the number
of object created by changing slightly
the API of the similar level cache
access to really speed that up so if you
you know just by a grating hibernate you
actually might go one step further on
your applications just by benefiting
from those performance improvements
another one which does require an
explicit call on your part is what we
call cache by reference remember what I
told you about the flush we load the
data from the database we keep an array
of the column values in the session and
then we create an object populate it and
give it to you when we load data from
the second level cache we do exactly
exactly the same thing we load the data
from the second level cache which is
this array of of columns and then we
create a new object populated and give
it to you okay so the second level cache
and the data rate essentially have the
same kind of information well the
negative part of that is that for every
session you create a new object that
represents this logical entity so a
country is Singapore and France and what
not every session that loads Singapore
and France would have two different
instances for each so in an environment
where those objects are super massively
commonly used and created for each
session that means a lot of object
creations for nothing the reason we do
that is if those object are mutable you
should do a change to the country France
for example by changing say the
president from the old one to the new
one in a given session and the object is
actually shared across all session then
you've got a problem because what is
happening in a given production is
actually leaking into other transactions
so that's not what you want and that's
why we create a new object every single
time but in many key situations the
object that you're caching is actually
immutable that's a country and you don't
put the president's name inside the
country object you put it somewhere else
for example and here you issued if your
object is immutable then we could
actually share the same object instance
cause all of the sessions that you have
in your system so one of the creation
and sharing the object across all of the
session so to do that to enable
hibernate cache use and Rosco reference
underscore entries to true and then you
make sure your entity is marked as
immutable and you make it cacheable and
off you go
be careful it also means that this
object shouldn't have associations to
mutable object otherwise the mutable
object might change and that reference
to the mutable object should be specific
on a per session basis so that
optimization will only work if your
immutable object as no reference to a
mutable object value shoe things we need
a massive amount of work around
documentation so and I was talking with
a gentleman here that said are we moved
to some - - I've at least for a while
but we're coming back to hibernate so
little bit of instability here but the
good thing is that in the meantime we've
reworked the documentation and it's
awesome and very readable nowadays so go
and read the documentation from A to Z
and there would be much more
understandable and and better and also
we have been really focusing on the
community and interacting with you guys
so we do a blog and every week like a
bit of a newsletter that gives you tips
and tricks and what one of the kind of
fallen people are hitting and how to fix
them so you know have a look at the blog
it's called in relation to - as EPO and
just randomly one of the additional
features that we did recently is the way
to set the batch size - on a per session
basis so bad start is very important
because you instead of doing say one
update and you know as going back and
talk to the database we can batch for
the same same table updates like as as
in this case batches of 10 and just way
less interaction with with the database
that up until very recently has been a
session Factory
settings but what happens is that some
new skills in your application is very
much oriented and some other use case
are very just or OLTP oriented for the
OLTP oriented you don't really need
those batch size to be too high because
that's an extra work to do on the
hibernate side but for the batch size
then that's where you want the big batch
size to actually happen because you
don't necessarily want speed on the
latency babies you want speed on the
throughput babies so no with the ability
to override the settings on a per
session basis you you can really
optimize those two areas and by the way
when you load when use the JPA api how
do I access the hibernate API so you
just do entity manager unwrap and then
you've got the session object and from
there you just enjoy yourself forget got
access to all of the all of the settings
and annotations and earth and API them
and so on we come back to hibernate or
I'm in at the end of the talk but let's
do a bit of a discretion and think about
other hibernate projects so we've been
talking about hibernate forum so who
uses hibernate search okay it's just
well we need more people in this room so
let me try and convince you guys to did
you know about it by the way okay not
enough not enough so that's why I'm here
that's good
so hibernate search we're hi manatorian
is an object relational mapper hibernate
search is an object indexed matter and
by index we mean inverted index in the
Apache loose instance okay so what we do
is we take an object or an or literally
an object graph and we convert that
structure into in the case of losing a
document which which feels and do the
right conversions and so on for you and
then we update the Lucene index
okay why do we do that if there are
mismatched the mismatch is that an
object has many types there are strings
there is numbers there is dates there is
nested objects and so
and so on whereas in the Racine universe
there are strings and numbers pretty
much so you really need some kind of
property mapping the other thing is that
an object as an association to another
object in the Racine universe you need
to denominating so if you've got an
address which has a country and you want
to search by the country property you
need to denomination inside the Lucene
index of an adult country so we do that
work for you for you as well the first
thing that we do is really work at the
object level which means you can write
object level queries and not document
level queries so it's a little bit of a
less of a mismatch and we do other
things like clustering and doing the
right matching and essentially all of
the actual indexing is done
transparently for you
you focus on the queries you want to
write oh and the final thing that is
pretty much a biggie is that every time
hibernate or M of the updates and object
we know about it I can answer she knows
about it for events being sent to the
library so which means every time you do
an update via hibernate the object
relational mapper
we can know about it and we can upgrade
the Lucene index for you so the database
and the Lucian index are kept in sync
with one another so you don't have to
maintain your secondary index by
yourself when you do an update it's all
done transparently for you even if you
update it and then you do a flush and
there is the whole object graph that has
change all of that is done for you
transparently so are ya extremely useful
very practical extremely useful way to
to get done so what did we do knew about
this this library recently
well we always upgrade to the latest
version of machine
listen tends to break ap is quite often
so when you use hibernate search or
pretty much isolated from this API
breakage that's another small benefit
the good thing about using it every time
they upgraded faster so you get the
benefit when we upgrade the other thing
is we try to optimize stuff on outsiders
where the recent optimization we've done
for people that are really familiar with
scene you know about NRT which is near
real-time which is a way to keep your
index up to date and be able to query in
real time the small drawback is that it
has to be in memory and and it cannot be
clustered that's a bit of a problem so
we sort of reused a bit of their
strategy and what we do is for every
transaction that that hide any
transaction that happens that requires
an index change we actually pile them in
a queue and we take that whole queue and
ask you seemed to do that upgrade in a
single batch okay and what is float from
a you seen point of view is not the fact
that you do your working memory is to do
an i/o to actually flush that
information to disk and then come back
so if you were doing an i/o for every
single collection and every list of
changes you wanted to apply that would
be slow right if you had too many
transaction that that transition will
have to wait for all of the other
transaction to up what we do is we take
the queue of all the traduction and we
apply them in one batch while we are
doing this one single IO the queue is
probably filling up that's okay when we
once we're back from a losing point of
view we text that queue again and then
we apply it so from a transaction point
of view you go you come you say I want
to index this stuff and the most you
have to wait is essentially one
IO cycle so it's not as fast as energy
because this is one IO cycle but that's
pretty much as much as as you will have
to wait so that's a very reactive and
efficient pattern another biggie is that
we have support not only for Apache
liesl but also for elastic search so the
big advantage remember is that you're
working at the object level and every
time you do a not change from a
hibernate point of view the ORM we
actually apply the change to the index
so here you can keep your elastic search
index in sync with you with your
database France partly thanks to
hibernate search so that's the benefit
you have when working with elastic
search and hibernate search together and
of course you can still use Cabana and
all of that because it's a regular
indexes elastic search indexes that you
can access
you don't forget one yes we try to be
good citizens with the kind of framework
you use of we've got a white flight
fragment that integrates I've an
exception and white flight like a swan
same on the swing would size so you
should be able to get started very
quickly so this is a bit of a synthetic
example where I try to cram as much
features as I could so you see that it's
a regular GP an entity so I've got the
identity annotation at the ID on the
eyelid suffocation and I've got
properties what I have to do is to add
the add index annotation on the address
and no and just by doing that hibernate
cells will be notified by hibernate or
I'm about changes on the address objects
which mean I'll be able to index the
information of address then I need to
decide which team do I want in my full
text index they may probably many things
I'm not interested about from a full
text index point of view but only some
of them well in this case I've been
pretty comprehensive but that's that's
why I use the add field annotation at
Socktober field is interesting it's when
you want to return the result on a order
by city so by default the full text
index the advantage of it is that it
returns the most relevant result
compared to the query you've done just
like Google returns the most interesting
with website compared to the query
you've done that's what it is about but
if you want to not order by relevancy
but by cities then you just enabled the
soccer ball field here taste it we will
mention it in a minute but you have to
mark the field you want to facet by and
spatial so we can do actually geo
location based queries so in this case
I've got an address with a latitude and
a longitude so I mark them as latitude
and longitude and hibernate search will
do a quite index for you
and you'll be able to query by latitude
and longitude at in X embedded is how
you actually do the denomination I was
talking about before so again it's the
classic so the second step once you've
got what once you've done this
annotation
in every time you do an update to an
object the indexes actually are graded
by hibernate search transformatory for
you so that's good
no it's time to write queries to write
queries you can use the native listing
queries or the native elastic search
queries but you can also use our object
level DSL and in this case what we do is
we do a special with special facial
restriction by the radius so say five
kilometers around this latitude and that
longitude and then I want to search for
a very specific street actually not so
specific because maybe my user didn't
type it properly so I want to be
approximately I want to be able to do a
proximity of queries here and those two
are mandatory those two constraints are
mandatory and I'm adding a new one which
is optional which says hey I'm actually
looking for rent and hey will be
interesting for me will be better if the
rent for the condo that I want to look
for is actually add to flow high or
above okay so that's the restriction of
I've done here and it's not a
restriction per se because I've used the
chute property here what's happening is
I'm saying if it's above two then the
relevancy will be higher the score will
be higher so the result will be high
before in my results list let's see our
interesting part about our full-text
search here that's an optional step but
you can add facets so for people coming
out with Amazon or pretty much any
retail website these days you you write
a query you've got the results but you
also on the left of some kind of what
refinement capabilities you can say hey
I'm looking for
I don't know memories and then you've
got okay you can use the Samsung brand
or that other brand or that other brand
so you can select the branch you're
interested in and not the other one or
maybe you want all of the article with
four stars and above and not all of them
so this this is called faceting you can
express faceting here so here I'm doing
a faceting on city and it's discrete in
the sense that all of the cities that
are within my result will be
both on the facet on the left and the
second facet is actually a range facet
which means I don't want the least of
all the floors or for example I don't
want the price every single price point
I want ranges between zero and $20 and
then $20 and $100 and so on so that's
how you describe those ranges so I'm
describing my faceting and then I can
describe my actual query I bundle
everything together and I run my query
and if you look at it it's an actual
hibernate query it returns managed
objects so it's just another way to do a
query in hibernate your written hello
the return managed objects which means
if there is a lazy associations you can
go and navigate to the lazy objects and
so on and so on but this one is a recent
feature that I quite like so if we look
look if we look back to my query here
what I have is three parameters one is
the Rajat rageous the second one is a
street name the third one is the floor
level so I have hacked my user about
those information probably in different
fields okay or maybe have inferred the
rages because I want I know that person
wants it within one kilometers of it but
very often in a search engine that you
expose to a user what you have is just
one boss just Google like one box where
you the user puts everything and then
you have to write the best query for
that just based on the terms they put
you it put into this entry into this
form so here I've got well a piece
provided by the user and what I will
decide is just okay I want to search one
piece on these that's a book in this
case on the title and the summary I
think the title is more important so
we'll bust it to a higher level so if
those names are in the title they will
be higher in my list of results so it's
really a nice way to simplify a bit your
walk when you know that you have a
single form let
the simple whutzaname simple query
string operator okay hibernate OGN is
essentially hibernate or an but for no
SQL databases so we do JP API we use the
JP API you write the object model the
way you describe the object model in
hibernate but we store the information
into MongoDB you can expand and Acuras
I'll mention it later it's interesting
if you have a domain model and you want
to use one of those
you know non-relational database that's
really where the model shines so we do
some of the gql query not all of these
but you can write the native query of
the underlying system so you can write a
memo cue a query and whatnot yeah find
it interesting if you have an own domain
model some free stuff that you want to
put that's not the best job just like
you should all have an object model and
you want to pass this information don't
use either net or I'm for that
but if you use other domain model and
you want to use those that that's the
best the other stuff we try to do very
hard is to make it the most natural
mapping possible so it looks like
somebody really wanted to store that
object structure while doing it in a
mobile DB native way so we don't try to
serialize at the blog now we use the
nested document approach or in the case
of mobility which is the graph database
we use nodes and edges between nodes so
we try to use the most natural mapping
the one you would have written if you
had known about having neo4j very well
and knew about those kind of pattern and
approach so we've got support for those
the last two are really kind of
experimental but the other above are
stable how do I get started with
hibernate OGM well first of all you need
the dependency to hibernate OGM and
specifically which dialect you want so
neo4j in this case and then in your
persistence dot xml you say hey I'm not
using either net or I am I'm using
I bet or GM and then you select the
provider neo4j and then and then that's
it start using the JPA api and you're
good to go
hibernate validator who uses hibernate
validator okay that's the invalid sub
the implementation of the bean
validation spec what you can do with it
is describe constraint on your objects
so here I have a user which has an email
and age and the first name and I want to
express the fact Express the fact that
this email is not just a string it's an
actual email so I'll use annotations to
express that very close to the actual
type and that's declarative and then
from there everybody using the hibernate
validator or API we're validating that
object will actually validate those
property transparently and we put the
list of arrows and the cool stuff that
we work hard with the other equally the
rest of the ecosystem so that the
validation happens at key points when
you until Jack's arrest and jax-rs text
is JSON object creates a Java object you
can actually call bean validation and
have it executed when JSF populates from
a form creates an object it actually
looks at the concurrency and actually
apply them so you describe them once and
they are applied at the web layer or the
entry point layer but also at the output
layer JPA
right before pushing data into your
database we check that the data actually
is correct from a constraint point of it
another stuff you can do for CDI or
spring is to actually validate the
parameters of your methods so here I
want the user to first of all be there
not be null and also be valid which
means please validate those property of
that user object when I'm calling that
method okay so that's been validation or
that hibernate validator what we've done
recently is worked essentially
everything related to Java 8 so which we
have introduced repeatable annotation
which is part of Java 8 so I don't know
if you're familiar with annotations but
you couldn't put the same annotation
twice on a given property or methods you
had to create our container so say
email dot list and then you put the
various emails with the values of operty
know you can put up email up in L that
works what would you want to put swell
at email at email by the way that's
because hibernate valid data of /bin
validations lets you group constraints
into subgroups and you can say I'm only
want to validate that subgroup and not
that other so good so defining the
constraint several times actually is
please II need date on time
remember July eighth date and time you
types we've got support for those and if
you compile with the - parameter
property when we do the method
validation instead of are 0 and 1 and so
on we actually use the parameter name so
the error report is quite a bit nicer
but the big feature of hugger validator
and the bean validation spec which is
about to be final like in a month or two
is support for collections so you could
support constraints on collections have
been able to do that for a while so in
this case put the size on the list of
email so I can have as a maximum of ten
emails but what if I wanted to apply the
constraints not on the collection itself
but what's inside the collection well
Java 8 introduced the ability to put the
constraint here within the brackets and
they call it something I can never
remember but that's within the bracket
so here what I'm saying is that it's a
list on email that should not be known
and invalidation will actually look at
each entry in the list and make sure
it's an inner that doesn't is not not
it's not emitted to collections or
iterable the optional is another type
where it makes sense and we actually
have an extension point so Google guava
has a few collections that are not
actual subtypes of Java util collections
they can implement the same stuff and
inject it into the invalidation so the I
think it's a colored table the table
with like a row column and value
actually can be supported in this
validation
this one is interesting that's a
programmatic way to declare the
constraint that's that's specific to
hibernate validator so you can use the
annotation to declare the constraint or
if your I guess if your static you can
use xml to declare the constraints away
from your formula object the third way
is to use the programmatic API which is
safer from a point of view than than XML
closer to your code so I find it
interesting and it also means that that
you've got several deployments of the
same app but it's slightly different
between customers they don't really have
the same constraints you can actually
customize the constraints between the
values customers so you would ask the
customer to express the constraints that
you gamify also whatever the input and
use that input to call the programmatic
API to express the constraint hibernate
special well back into I ran a tour and
by the way so first of all I've been
talking about geospatial queries with
hibernate search I ran it special what's
the difference so the first one
hibernate search the spatial queries
actually use the Lucene index to do the
actual quad query and the geo local
query hydronic special is really the
integration between hibernate om and the
actual geospatial capabilities of the
underlying relational database so oracle
post geese which is the Postgres
PostgreSQL plus the geospatial support
mysql and so on and so on they all have
one shape or another of special support
how do I do it well first of all I had
the spatial module to my dependencies I
might need to use the specific dialect
for the special support and from there
this is an entity of mine and we are
having an ID and I've got a special type
here which is a point so it's a
literally had latitude and longitude
before in my previous example here
that's a point which are for the X and
y-axis definition and then I can use the
object
state and it will use an actual special
index forms a post keys in this case so
I'm using here the constructor for the
point object the point object is part of
the ggs library which which is kind of a
de facto standard for for that in the
Java universe how do I write a query
that's the jig that's a hibernate query
language query so I'm looking for events
and I'm applying a within restriction
from the location and implying
in this case a polygon so look for all
of those Starbucks coffees within this
polygon right because I'm willing to get
coffee but only if it's as far as this
right so that's how you do the query and
finally and that's the last one I've got
no code to show here but hibernate
unless is about auditing so when you do
a change to the database the change
happens and it's one of the traduction
log that you can only query the latest
state of the database how can it unders
when you do a change to the database
also keep track of what has changed so
it keeps your actual table model at
least but create for the oddity table an
additional table pair audited table
which will track the fact that this
property has changed from A to B by that
user at that time for that transaction
okay and what it means is that I'm able
to to do two kinds of queries one is to
say when was for example the date of
that even change from the first of July
to the fifth of July you can actually do
those kind of crud
when did that happen when did somebody
change that the second type of query you
can do is let's pretend I'm three weeks
in the past let's do a query of the
state of the database three weeks in the
past and look at what's going on and
what was the state of the data so that's
useful for auditing properties trying to
find what what happened and what
exchange and when it has changed of
course that's more expensive those
additional table you need to do sub
selects and complex queries but in
you'll probably use the real-time part
of your application just like as is it
will be a little bit of an overhead on
the right side and you will only do that
those auditing query when you really
need them so it's okay to have them a
bit more expensive so that's what I've
done a ton versus about again it's a
notation base so you mark the young GG
at OD or audited I kind of forgot and
then you describe the values value
switch and I will stop here first of all
tried well total migrate your whole
hibernate application to the new one it
would be better look at the look at the
features that have described especially
from the non organizer and project maybe
you are those needs and maybe you want
to integrate them in your in your
various applications and give us
feedback give us advice hey you really
should have that features that I had
that we'd and so on and so on so
interact with us we really love when
customer or people you know anybody
comes to us and say hey that is great
use case that you're not covering very
well and then we can interact with them
with you that being said we've got
plenty of time for a lot of questions so
try and not be shy and that's that's
when nobody asked questions that's it
typically yes
the question is how musing hibernate but
I'm also using string data which is kind
of abstract it's the spring data GPA
that you're using right so the question
is how do we see it well essentially we
see it as a fact of life
the people will inside the spring
universe they tend to want to use spring
data and frankly it has the view well
I'm not a personal believer on those
automatic method you know method on
interface that create queries I don't
find writing queries that much more
difficult but monkey people do so that's
okay that's okay by me it's like we
don't see any problem with us just
embrace it
the only problem we have is that when we
break API the spring guys they don't
want to break stuff so it might take a
while for them to a grade but as far as
hibernate pretty sure 5.1 and further to
the support is in there so you can do
them so I would love to add you know
Oliver and the string data guys but I
don't think there is an is essentially
delegation so I don't see any
significant performance difference
between using string data versus not
using string data
another question yeah okay so I did it
so what I disagree but that's very
discussion the question is whether
remark is I read search is a nightmare
when you have more than one machine
because I've Annette searched all the
index locally and then if you have two
machines then you know you need to
synchronize everything and that's that's
a mess
so we explicitly had it features in
hibernate search to be part of a cluster
and list that you see never had and
never will
what we have is the master slaves
kind of approach even though you can
select pair index which one is the
master so you could really have in your
architectural several masters to
distribute the load but it's a master
slaves
approach well one master will receive
every single indexing request from the
system apply them for example store the
index in a in a network file directory
and then the slaves will copy on a
regular basis the the copy of the master
with the index of the master and we do a
swap so we've got one feature that does
that and to communicate between the
changes request that the slave received
we use JMS for example or Jacobs as way
to communicate back to the master that's
one approach I've got two more
approaches for you the second one is to
use infinite span as the way to store
the index because here increased one is
a distributed grid that looks like local
to everyone but it's a distributed
system it's like a shared memory across
machines so you can store the index in
there from hibernate search and have it
shared across the machines the third
option is to say well use elastic search
which is going to be your cluster and
hibernate search is just
to be the one asking for the change and
doing the query and delegating that work
to elasticsearch instead of owning the
index we can dive a little bit
afterwards if you want but I think I've
covered the other things maybe one more
question or I don't know how much time
we have left
yeah great question so the question is
if I don't update my data by I'm a
hibernate application but my TVA do some
changes behind my back like you know
those bastards so we've got an API to
manually ask for an index so you might
be able to know about that and then
propagate that request we've got an API
that do a mass indexing of the whole
database so maybe every day you will
decide to windex everything load the
data fast as you can index it as fast as
you can that works usually we put MySQL
down to its knees so it's not gonna be
the indexing part that's going to be
slow and something we're working on is
called the project DB job dot IO it's
called change data capture it listens to
a database changes from a transactional
point of view and create change events
and put them in a queue we hope to have
an integration between hibernate search
and that so we could listen to every
database change event even if they are
not coming from hibernate know about
them and trigger your index that's a
little bit in the future that you see
the value species and we're trying to
connect them something or maybe one last
question because I'm seeing all the
people coming and probably the end of
the session question
three-two-one
well thank you for saying there</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>