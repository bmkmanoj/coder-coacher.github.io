<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Notes on Type Theory for absolute beginners by Hanneli Tavante | Coder Coacher - Coaching Coders</title><meta content="Notes on Type Theory for absolute beginners by Hanneli Tavante - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Notes on Type Theory for absolute beginners by Hanneli Tavante</b></h2><h5 class="post__date">2016-11-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/UXBoiqRJ6DQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so are you ready for type theory no yes
maybe not yes
I'm Hanna Leigh I'm from Brazil and I
came here for devoxx I am a software
engineer and those are my those are the
things that I like to do in my free time
so if you like to play pokemon let's
walk around the city to get some pokemon
a quick disclaimer before we get started
this is going to be a quick session I
have only 30 minutes to talk about you
know lots of stuff so we are going to
see lots of theories so I hope that you
don't get scared because we are going to
see some mathematics on this talk but
don't worry this is not going to be an
advanced to talk about site theory as I
said this is a talk for beginners so if
you have if you have ever heard about
type theory but you have no idea of what
is that about this talk is for you if
you are creating your own language and
you know you already know what you need
to do maybe this talk is not for you we
are going to see some gifts to help you
to keep you know to keep everybody awake
so the goals of the sessions is is
basically understand and they're saying
what type of theory is about and how can
we get a piece of code and make it look
like you know a logical system a
mathematical system this is the goal of
this session so if you understand the
principles and steps behind it I'll be
happy about the results of this talk and
we also plan to understand the benefits
of type theory and why is important to
analyze this like the type system of a
language so this is a quick agenda and
let's start talking about how you choose
a programming language how do you choose
a programming language maybe your
company asks you to use a programming
language maybe because it's a popular
language maybe I don't know because of
the goal of your project maybe because
of the tools that are that are available
to you you don't know why you choose a
certain language has somebody told you
that it should use a certain language I
know there are several reasons that you
might have to choose to choose a
language but how often do you consider
this options like type system immutable
leti avoidance to run some errors and
things like that when you're going to
choose the language so when you have
freedom to choose how often do you
consider these options well the first
bullet here is about type system so what
is a type system can you quickly define
what is a type system
yes no maybe have you ever heard of it
how can you define what's a type system
so we can ask Wikipedia and we have this
beautiful definition from Wikipedia like
in a programming language a type system
is a collection of rules that assign a
property call type to various constructs
of a computer program and now we know
what a type system is wait we don't
because this definition is you know it
doesn't really explain what is that
about
how many times have you have you know
read an article at Wikipedia and you
stopped for a minute and said oh I don't
get what is that about
so this is the case for a type system
and so to understand the idea behind a
type system we have to remember that in
no language some water no matter if it's
assembly java groovy Ruby Python we have
two main components at least data and
operations and not all of the available
per Asians are or are makes sense to all
kinds of data so for example sometimes
it doesn't make any sense just to try to
sum an integer with a string sometimes
it's not even allowed to do this
operation in certain languages so if you
try to use incompatible pieces of data
you're going to end up with a
representation error in your language
and programming languages they use a
type system to determine if your
representation error is going to happen
or not
we have several strategies to handle
this representation errors for example
we can either perform a type check
before we run the code we can I don't
know try an implicit conversion like in
JavaScript we know we can ask for the
compiler tag pieces of code and try to
infer the behavior of what's going on
we can have maybe interpreter that
generates more coal to keep the track of
the data for example those are some
strategies that that people who are
developing languages are using chicken
track of the errors and sometimes the
books or you know the computer science
they had names for these strategies so
it's very common to hear about you know
strong type system or I don't know
dynamic type of system you don't have to
choose a sing alternative you can choose
a mix of alternatives to handle this
representation errors so Java is
aesthetic can you see why whoa
Java is ascetic mostly because it's
going to perform a type check before we
run the code the compiler is going to do
this work for us
and somewhat strong so the problem here
is like how can we actually you know in
terms of code numbers action how can we
perform this type check I cannot say
like oh let's perform a type check how
do you do that I've ever heard somebody
saying like Oh a certain language is
terrible because the type system is a
total mess what does it even mean how
can you prove that you know give me a -
give me a solid resource not only your
opinion but give me you know a solid
research to say if a type system is good
or not so it's kind of easy to say or
it's kind of easy to complain about a
type system without really you know
deeply analyzing it have you ever tried
to analyze the type system of Java how
many articles do you read about Java
type system how many talks do you see
about Java type system we know some
things we know that there are primitive
types we know that there are generic
types but in terms of mathematics what
do you know about Java type system do
you know something about you have a type
system I'm not talking about the general
types that we have primitives you know
classes and so on in terms of
mathematics what do you know about do
you know something about Java type
system well maybe you should know
something about it
because I guess most of you are Java
developers and it's important that you
understand a little bit of the type
system that you're using so I don't know
if is good or bad I'm happy with this
because I like mathematics
but to provide you a concrete proof of
Java type system or Chirino provide a
solid are arguments of what you're
talking about you need mathematics you
need a tool that it's going to be true
or false in case mathematics so that's
where type theory comes in and by the
end of the session I hope we can
understand or be able to read this
formulas into the image this logical
statement don't get scared
please I know this is one of the last
session of the day but this session is
going to be soft and I'm pretty sure
you'll be able to understand all these
logical statements without much pain I
hope so
so let's stop let's see how we get
started on it I'm going to provide you
some steps of what we usually do to
start analyzing a type system of any
language so first of all we usually
collect all the key words that we have
and we analyze the grammar that is
allowed to use within these key words
and we do we create a sort of a map a
draft it's just a sketch so for example
I picked up three main examples in Java
which is like I know extends implements
throws we have a bunch of other keywords
in the language but we kind of create
this a sketch saying like for extend
extents expects to get a class type no
matter and it can be a class type list
it needs to be a single type it's
different for implements for example
implements is expecting one or more
interfaces so you can map this as an
interface type list and so on so on if
you do this for all the keywords you've
got to make this quick analysis of the
keywords in the grammar then now you
make it look like mathematics so once
you did this analysis for your keywords
you can you know switch between extends
to another a variable like a B or C for
some reason people in mathematics they
like choose Greek letters so it's very
likely that instead of a B or C you find
this analysis in two books or papers
with Greek letters but don't don't get
scared by the end of the day they just
mean like a presentation for this
mapping once you map them you have to
remove the double
sometimes the grammar is going to be
pretty much the same for different
keywords and you have to you know make
your final set of analysis smaller so
you have to remove the duplicates and
that's the difficult part because if you
met them in an incorrect way sometimes
you cancel eminates all the duplicates
but we are going to talk about this
later on once you remove the duplicates
from your sketch that you're analyzing
then it's time to using bollock logic
it's usually the first step that we do
and symbolic logic has probably logic
itself is a subject that it's very
common to see at the university and no
matter if you studied computer science
or maybe philosophy it's very likely
that you have studied logic at some
points of you know of your student life
so I don't know how many of you kind of
remember some rules about symbolic logic
but if not I'm going to leave some
reference in the end but the basic rules
like the Morgan or you know implication
rules you have choose these rules here
so I'm going to give an example if we
filter that that big keyword mapping for
Java we pretty much are going to achieve
sad similar to this one that we can map
and again we usually assign a Greek
letter for each of these types so try to
focus for example on class type we use
it the letter on seta the Greek letter
Zetas 4 for the class type or the
interface type so those are some
mappings that you're very likely to
achieve if you get all the key words and
you try to map them to what the grammar
allows you to do you can come up with
something a little bit different but in
the end you need to see that Java is
going to have result types something
that's going to come out of an operation
class type something that's going to
name your it's going to be the type of
the classes that you're declaring
declaring and one thing that is
important from there's 10 inside
theories like your your code has
certain environments so every coat or
every block of code or every program
it's kind of different people can
declare different different structures
for every program in every language so
it's kind of important to you what's the
top level of mapping of any language is
what we call environments what why do
you need to have in order to have your
program up and running environments is
pretty common in type theory and people
usually use this letter the capital a
hole to represent the environment so in
every environment which means let's try
to read is in pure English for the
environments that you have for your java
program for your java code you have a
bunch of classes and you have a bunch of
interfaces right you probably have this
at least one at least one class in your
entire code so you have this mapping but
you have to keep opening you have to
keep expanding this definitions that
you're trying to sketch so what's the
meaning of a class map well a class map
means a class type something that's you
know created a class declaration with
within a certain type the same thing for
the interfaces so the idea here is that
you start opening these definitions that
you are sketching so for example you
create a definition for class map but
then we use another information class
declaration what what's the meaning of a
classic declaration well plus
declaration is something that has
modifiers it has a superclass it has
maybe some interfaces fields methodists
constructors you have to map following
the rules of your grammar what do you
what do you have available to you and
then once you did this mapping with
using symbolic logic it's time to sketch
some predicates base it on what your
grandma grammar allows you to do so it's
time to use one thing that we call
predicate logic if you remember the
logic classes we have pretty much two
big types of logic the symbolic one and
the predicate ones those so the symbolic
one is going to use fixed fair
the predicate logic on the other hand is
not going to use a fixed variable is
going to use what it called predicates
which means it's some somewhat like a
function it can receive some arguments
and then by using the predicate logic we
can start trying to sketch some some
statements that are true in our language
for example in Java let's just start
with something that's true what what do
we can call like an valid type so a
valid type of a primitive it's something
that the language allows we always ought
to do so so this is going to be true and
we can also you know use a mathematical
form for this so valid type of pi and pi
is going to I mean a primitive is going
to be true
can you see do you remember seeing the
predicate logic it's pretty much like
that I'm creating a statement that saw
is to return true so given an
environment with a primitive this is
something that the language allows me to
do so we can create a list of predicates
that are true and we need to start our
analysis based on this predicate for
example I can also analyze a valid class
type so if I create a class according to
the grammar this is going to be a valid
class type let's say class class anymore
and then if I declare the class properly
this is going to be what I call a valid
class and I can express this using you
know valid class tau in a certain
environment I can do this for interfaces
in case of Java for example I can do
that for I don't know exception analysis
and anything like that what is valid so
I have to come up with a logical system
in terms of predicate logic that can
express what's valid for the language
that I'm trying to analyze can you see
on your left side that I have you know
some some thing that is catching English
and on the right side is what I have for
predicate logic itself it's mostly
pretty key logic breathe we are halfway
through can can can you try to picture
the correlation of what we are trying to
do inside theory and what we have in
Java we have we need the starting point
we have to get the structure of the
language in determined what is true what
is valid and what is not valid something
that can really help us here if you're
struggling to build the sketches is the
knowledge of something called lambda
calculus lambda hopeful is somewhat out
of scope of this presentation so I'm
going to leave you of some you know some
further reference if you're interested
but knowing how people in lambda
calculus create some statements might
help you to do your own analysis of any
language because they have some cookbook
and some tricks on what it should look
in a language to extract some logical
predicates and then after you do that
try sketching like some statement that
you can actually prove so another thing
that we can we could try to prove in
Java for example take a look at this a
statement in Java every class type that
you define will be a superclass of a
class is this true or not it is true so
can we try to prove that Johanna try to
prove that with mathematics no I'm
afraid of it okay we can make it it's
not a difficult so let's try to escape
mathematical expression let's just make
a refresher we are we are going to use
some pretty k2 logic here and I'm going
to switch that the concept of class Chu
delay to the Greek letter Zetas I'm
going to switch the concept of
environments which means the place that
my program is actually running she does
kept a letter a ho and then I'm going to
use this symbol to define a class
relation so having this symbols in mind
let's try just catch a mathematical
expression not invert then in an
environment whole so we can start with
coal that's pretty
it's straightforward we can prove and we
use this cute symbol that you see on the
bottom of the screen she actually sang
mathematics that we are going to prove
something we can prove that a class of a
certain type we are going to call that
settle one I don't know which type is
that I'm just calling it set one in the
subclass of another type or what happens
is if the class I'm I am working with
its class object itself so for this is
for this particular case I don't have a
I don't have object doesn't have a
superclass so that that's kind of a
special class but anyway so we can prove
that a class of a certain type is a
superclass of an order another type or
it is the other type itself in case of
object does it make sense to remember
the replacements that I did into the
previous slide
can you see Zetas ho and close relation
I'm going to use one of those two
symbols so that's what I have here was
it that difficult
no that's the first step and we can make
it you can make it we're getting there
so that's the first step so we just were
able to prove something that is true and
using a predicate logic so that's
something we can almost read this now
let's go through this big statement and
don't get intimidated by this big
statement because and in the end you're
going to see that it's another long
longer form to say what we just saw
that's for a given class type that you
declare this class is going is is going
to be a subclass of assert another
certain type so let's start from the
beginning this is the first line of our
statement so I have a valid type of a
certain class remember the the Greek
letter Zetas in an environment I have a
class map and of this the same class and
the same class has a super class called
calls that achoo we are getting there so
how can we rewrite a valid type
well I know that a valid type in Java is
going to be a class in an environment
and this class is going to be is going
to have a subclass sorry it's going to
is going to be a subclass of another
class or it's going to be object itself
does it make sense so getting back see
this first part of the statement means
exactly that the second part of this
statement means the following the
superclass I have a superclass of a type
in case that one but this is the
superclass is also super class of
another type I don't know what those
types are I'm just trying to you know to
make an affirmative so we can replace
that I know that that that number to you
is this superclass of another type which
I'm going to call that the 3 does it
make sense and this is not false so I
can easily replace these two statements
so we're on the way but how how can i
rewrite that at you it's on the screen
is there any way that it can rewrite
that you set it U is a class type what
what do I know about class types again
in Java a class type is going to be a
subclass of another type right we know
that so I can easily replace these two
statements for the original statement
that I have and we're almost there
almost there this is the last part so
the first line is sorry the first line
is a general subclass chain and I can
easily replace that for the original
statement given a class type I know this
class type is going to be a subclass of
another type and again this is true so I
just proved using logic that given a
class type this class type is going to
be a subclass of another type or it's
going to be the the type itself and this
is how you do this like this can sound
obvious to us
but this is how you do that in
mathematics are you scared at all no
that wasn't that difficult so now you
can tote so now you can tell your
friends that it can actually prove this
is a statement in Java using mathematics
and that wasn't too difficult
it wasn't your bad so why is this so
important but that's a good question
because I proved a very simple statement
but see I use it mathematics to prove
something about the language and that's
very good when you're trying to
determine to determine which language
you're using so imagining you're having
an argument with your friends and your
friend must use closure and you won't
choose Java so we can actually use
mathematical tools to try to prove your
point of view and that's very
interesting but besides you know
arguments it's good because the pen you
know types on the type system of a
language you can actually reduce the
room time errors that you have so
imagine like before even running a code
if you have something that can perform
the logical and analysis of your of your
you know pieces of code it's going it
could produce you I could save you lots
of time in law stuff you know it hurts
in production it's also good for IDs
lots of ideas are really interested in
to type theory because of you know this
idea of being able to perform a kind of
check even before running a decoding
production and another thing like
difference like I said different
languages have different type systems so
I'm sorry I'm not a very good CSS
programmer but yeah I wrote this
presentation with CSS and JavaScript and
I broke it but for example let's try to
quickly compare Java and closure and
both run on JVM so close your for
example was not design it you have a
static type system closure it's dynamic
however it can treat that as a tie as a
type it sorry as a static language using
type of closure so let's try to make a
connection between what having closure
how many of you are familiar with
closure well I see some hands so in
closure you have the data type and we
can kind of correlate the data type with
a class type in Java we have protocol
type which is pretty much like our
interfaces but in closure if you see we
have a notable type how can we relate
that with Java we kind of don't have a
new level type in Java so it's a little
bit you know different for those of you
who read Scala codes we have a different
kind of mapping you have different types
in Scala for example we have any you
have nothing we have the parameterize
the types so it's it's a little bit
different and a big challenge and you
can prove in terms of mathematics why
it's so hard to mix up some languages
even even when they run inside the JVM
it's kind of hard to mix them up mostly
because of their type system so if you
try to get scala closure and java you're
going to see that the type systems kind
is not compatible so that makes things
know kind of difficult so again some
challenges that we have a big challenge
I'd say it's besides you know trying to
mix up languages it's about trying to
describe a type system you made you see
that there like maybe seven or eight
famous papers from PhDs trying to
describe Java type system and they're
all different everybody comes up away
from different representation it's a lot
of mathematics so it's kind of
challenging for you know people who are
not very familiar with logic or with
lambda calculus and again like I said a
big boundary here is like try to try to
describe this in an accurate way so I'm
going to leave you some reference for
the for the four papers that I actually
read about Java type system and they're
kind of different in the ends they come
up with pretty much the same types but
the proofs and the way that people prove
their logical statements for every for
each of those those four big four papers
is kind of different so that's a big
challenge I'm going to leave you also
some extra reference of you know how how
could you get started with type theory
so let's say you have a language let's
say I don't know groovy and you want to
make some type analysis on groovy you
can do that so the one of the first
links that I have here it's going to
describe you with more details all those
steps that I that have been describing
to you through this session it's kind of
interesting and I have another version
of this session but it's kind of longer
and it's explaining more about lambda
calculus more about functional
programming so there's an explanation
for monads for you know higher-order
functions and transforming this into
statements that you have to use to
perform reduction and things like that
with lambda calculus and it's a longer
version and there's Pokemon on this talk
you can kind of enjoy some Pokemon so
those are some special thanks I'm sorry
for the short time is you have like
maybe 2 minutes but I'll be around the
conference and hopefully by the end of
the sock he won't beat you afraid of you
know logical statements that represents
a type system of language and hopefully
you'll be able to read something about
the java type system itself and i think
you're going to see that there's some
current controversy between how you
represent some things in java like
generics and that's an interesting
discussion I mean if you're a Java
developer and if you're working with
Java on your daily basis it's kind of
important to understand a little bit of
the mathematics behind the tool that
you're using so thank you very much for
coming to the session I'm sorry for the
bunch of you know the amount of symbols
and the amount of mathematics by the end
of the day but I think that when in this
question by the end of the session
you're able to cheer it softly those
logical statements at least about sub
classing super type in Java thank you
very much
we have one minute to have time for one
minute question does anybody wants to
make a question in one minute come on
you can make it if we made size theory
in 30 minutes
if we were able to read the logical
statements in 30 minutes you can make a
question in one minute no questions one
question the name as the type like
well there is there is no I mean there's
no consensus about naming or structuring
so you kind of can come up with your own
definitions so that's that's part of the
problem</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>