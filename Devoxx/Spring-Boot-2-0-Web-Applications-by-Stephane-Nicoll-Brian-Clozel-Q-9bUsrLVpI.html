<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Spring Boot 2 0 Web Applications by Stéphane Nicoll, Brian Clozel | Coder Coacher - Coaching Coders</title><meta content="Spring Boot 2 0 Web Applications by Stéphane Nicoll, Brian Clozel - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Spring Boot 2 0 Web Applications by Stéphane Nicoll, Brian Clozel</b></h2><h5 class="post__date">2017-11-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Q-9bUsrLVpI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome everyone welcome to this spring
boot to web applications talk before we
start I'd just like to ask one question
or maybe two with using spring boot
already good oh okay so um some of you
have you already tried the spring boot
to - stones by any chance okay that's
five five percent yeah so this session
will be about preamble to and new
features that you can expect so
obviously the new features in Spring
Framework five if you've attended a few
talks about this it's mainly about a JDK
a and and JDK nine story and a pretty
new trend which is reactive programming
support with spring waveflex spring life
plus is a new web framework that is now
within spring framework this is not an
old versus new comparison so you you
don't need to like rewrite or replace
your existing spring MVC applications
with Flex it's actually in a story about
approaching new use cases and
implementing those with Spring Framework
so we'll see why good
so um typical application these days we
want to make sure that those will have a
very good connection they get my
constant feedback and I have to refresh
that the service pushes data to it so we
want really a great user experience for
those at the same time the applications
have more and more mobile clients and
sometimes the network can be a bit crap
so you end up with having a lot of
mobile clients trying to contact your
service and what happens if you don't
get an answer fast enough you hit the
refresh button and you know what happens
on the server side with a traditional
approach where you get a new threat
being responsible to enter that request
at the same time we have more and more
distributed services so to serve very
particular request you may be you may
have to contact multiple services
combine the responses from those
multiple services and sometime a service
can be slow so there's also latency on
the server side
so if you combine all those factors so
the fact that you push is data to a
persistent connection that also takes
quite some resources on the server slow
clients and slow back-end services your
server goes like this
and that's where reactive programming
can can help you know what trucks in
particular yeah so we often get the
question about how does that improve
scalability because that's the one of
the first use cases that you can think
of with reactive and spring you can
actually that there's a different
threading model there in Java were quite
being used to comparing doing a
synchronous stuff with a thread pool and
offloading work to a thread each task to
a thread and within a web application
you often think that one thread equals
one request and that's it so that's a
model that's working pretty well and in
many cases it's performing really well
and but in the case that Stephan
described especially with a lot of
latency and remote services or with slow
clients when you've got the response
already in your application and you're
just trying to push that to to the
network but the client is just low or
the the networks are unreliable that you
can write the bits to the network
properly you just have to wait and
you're just wasting a thread not doing
many interesting things for your
application right so there's a way to
another way to deal with that as well
and that other way is using non-blocking
i/o so you should not block at all when
reading and writing IO to the network
for example so it's doable you can do
that within Java platform using an i/o
selectors or other ways and that's more
or less what we're doing right now with
the runtimes we're using with smart
plots so it's different it's got
different constraints
and you you're relying on the way less
on weightless threads but it's a
different number and a different model
and and it's providing like very very
good things for scalability but that's
not the only thing that's providing as a
use case right right the other thing
that that reactive programming and
spring can provide is using type like
mono and flex so those types they allow
you to that first they're a part of
project reactor there are a reactive
streams part of a reactive streams
implementation of that effect and those
types so they allow you to leverage that
reactive to inspect and at the same time
they give you a nice reactive API you
can come you can compose you've got many
operators and it's super useful to do
very complex things that you somehow can
do with imperative programming but it's
much much harder to get it right with
concurrency atomic whatever so the this
and especially for streaming use cases
where good luck trying doing that with
the our regular API so that's another
very good point about using spring web
plugs if you're in that case and trying
to compose many things that
synchronously and in an unlocking way
then that that shouldn't really help
done right so um what can you expect
from spring boot to so what we've
briefly described and now we will get to
end it interesting bit with the live
coding the demo is new options for you
right so it's not about an old version
versus a new versions it's about new
choices and what you can expect from
spring boot to is to give you the same
developer experience with those new
choices so everything you even you know
from spring would wander Dex developer
tools the actuator the packaging system
the configuration support all that has
improved in spring boot to but also
those new paradigms and those new ways
of developing applications are now also
supported so to illustrate that it is
trade that ya will build on a very
simple application so the use case that
we that we are trying to demonstrate and
we have sir demos about that don't worry
about the code we'll provide a link
after and there is one commits per demo
so if you're lost at some point you can
go back to a particular commit and look
at looked at at home um so we have zones
and those zones basically have smart
sensors which reports power consumption
and for the sake of that demo they do
that every 10 seconds so every 10
seconds you have like a bunch of these
devices pushing to a main aggregator
service their current power consumption
so that's the slow client part that we
were talking about the fact that the
sensor may be on a slow Network and then
like hammering your server and you need
to be able to enter that load and
basically get those those numbers and
provide a service for that on the left
hand side we have an operator and what
your partner would like to do is to have
a vision of the power consumption on the
zone so for that we have a very simple
dashboard application that we are going
to build now yeah then that detrol
application will process that data
persisted and present a nice dashboard
with graphs
to the operator yeah so now we've got
data streaming from that aggregator
application so all the data are coming
from all the sensors every ten or so
seconds so you get device ID the current
power used by that sensor timestamp and
the zone so your been - and we've got
what financial 101 I even wanna so think
about like service when it started
there's a there's a post there that just
because all the devices have reported
that their consumption for the current
period and we need to wait for the next
window to actually get the data and
that's an app which is running locally
on 8080 and we are going to use that
considering that it's a remote service
and we want to get that data on in our
dashboard application and composed
computer data into something with it
right so let's maybe start that nothing
so the aggregator is working already
we've seen the data streaming from it
and now we're starting the dashboard
application where we started a few
things there but it will implement it
together as well right so the first
piece and that's one of the one of the
new thing in spring from ik 5 is the new
web client API so reactive what client
if you've used rest template in the past
in your spring boot application you know
you have the restaurant page builder you
can inject and then you'll get all kinds
of nice things done for you like
converters being registered
automatically the right HTTP connection
factory etc so we have the same you have
the same with the with a new web client
API you can inject a builder spring
which will configure that for you and
what we do here is we basically defining
what the web client should do it's not
doing anything there you're basically
defining a pipeline so connecting to our
service on 8080 the same URI as the one
we were using and basically asking
basically retrieving stream of JSON and
giving back a flux of that object and
unlike rest template in that case we're
dealing with an infinite stream of data
that's the important part right right
and that that is an operator in reactor
you can apply to
in flux right and it's very powerful if
you need to actually process the data in
multiple places or if you have multiple
clients actually requiring that it that
data so share is a is really an easy and
effective way of doing multicast by
applying that operator and returning
that data you can actually subscribe
many times to the same flux of data and
only one remote connection to that
service will occur so let's say now that
I'm using that that let's say we're
using that that pipeline and we exposed
that in our web client web interface and
you have 10,000 client actually eating
the server it's not going to issue
10,000 requests to the back-end service
only one and when a new browser will
come in it will actually jump connect to
the existing existing sources so that's
the first thing
another thing we were discussing about
the the operator that we have in reactor
and maybe Brian you want to explain what
that is yeah so the the service Stephan
showed was the measure collector so
we're getting the that data stream from
the aggregator application and once
we've got it we'd like to do a lot of
operations on those we would like to
collect them sort them and then store
them in a database so you can think of
that as complex operations but if you
look at this we're doing a ton of the
ton of things in a few lines so if you
look at so we're getting the raw flux of
measures here and then right next to it
we'd like to window we'd like to darker
things and then group them by windows so
there are many ways to to group them you
can win the window by time with the
duration a timeout something and here
would like to window and make sure to
buffer many measures until the timestamp
changes so we're grouping them by
timestamp and as well by zone ID once
we've got that we've got small windows
so each window is the collection of
measures for a given zone and a given
timestamp and for each of those windows
then we're computing data
for it so in that case we're computing
we're reducing all those measures in a
single value that's computing the total
number of devices and the total power
consumption for the whole zone
so we're doing that for each window and
by the end of that you get a flux of
those power grid samples to a sample of
measure for a given zone and a given
time stamp and once we've got that again
we stream that into a reactive
repository and this is getting stored
into a MongoDB Arabic database and
stream back terrace so we can return it
in our in our method here so we're doing
quite a lot of stuff and we could do
even advanced stuff like timeouts
handling timeouts handling retries if
something goes wrong etc etc so we'll
show the initial page in a minute so the
the page that you see when you look at a
particular zone and then you can see
that we use that so what we do is on the
MongoDB connection that we have saved
we're basically asking for the last 40
items so that's the last 40 measure for
the zone and then we based on that we
basically return return the model end of
view and we see that in a minute so
right now if I'm if I'm connecting to
the app I can see that there is nothing
right so the usual the usual error
Arabic support that you have in
Springwood so let's let's add a page and
for that I'm going to add an extra
mapping so mapping on slash and then I'm
using the rendering API yeah you can
think of it as the equivalent of modern
view in spring MVC so rendering you can
specify it if you name like you do with
model and you add model attributes and
build it and return it but in that case
the tricky thing is you think we're
getting a flux of zone descriptors here
from the repository and we're giving
that to the model and how would the the
template engine react to that it works
right we're doing some we'll talk about
it I think a bit later but it works
right now even though we provided
a publisher to to the model right so if
I'm if I'm looking at one of those then
I can see these are the measures that
have if I've collected so far and one of
the problem of course is this graph does
not update itself so if I wait long
enough so that the next and second
window appears then I have an ability
graph so we'll update this this is part
of this way to upgrade what we're doing
on that view that other view it what
which was already implemented we're
fetching that data from the database so
in the last 40 or what-not measures
putting that into the model and
rendering the page and that way right
and providing the list of the current
zone the information for the current
zone and the latest samples for that and
we're rendering that into using a
client-side library for for graphs so
that's that's timely it's usually stuff
right so you you put stuff in your
mother with a certain key and then you
can use that in your in your view right
then I can ask for a zone that does not
exist and I get this wonderful error
page again probably you probably know if
you've used that feature that you can
actually create a default error view
with spring boots so all you have to do
is to create an error package in your
templates or static asset directory and
once you have that you create the page
whose the view the name of the view
sorry matches the HTTP status code that
you want you to get and then we will use
that so this is something that you could
use with spring MVC we wander to web
flex and that's basically the story is
everything you've been using so far in
Springwood
on attacks if you decide to go with new
types of applications we've got you
covered right okay so the the part about
the planning engine is report so when we
provided a publisher type to the model
since this is a reactive type there's no
way the current templating engine can
support that day they're not aware of
this so what we do is for any templating
engine the the spring web flex burner
the spring the Flex framework is a
synchronously
getting those in providing the the
actual values to the templating
templating engine once they're resolved
and then render the rendering happens in
again an asynchronous way and what we
haven't touched on until now I think all
the things we we say in show when
there's a flux involved it's always
reactive and it's not only a synchronous
it's always lazy so all the stuff that
happens you know it only happens when
there's someone asking and subscribe
subscribing for it further into the data
so in our case the the whole thing's
subscribing the whole chain is an HTTP
client here a browser asking for data so
on the on the framework side we're kind
of building a pipeline of data fetching
things from remote services and all but
things happen only when there's
something asking for it so it's not just
guessing crews and callbacks it's
reactive right and in a case in the case
of time we free the sign if team did
quite a lot of work right after and
during spring five milestones and before
and they did quite a lot and they saw
that reactive could be an interesting
feature for its and planning engine so
what they did two things first they they
had they added a chunked mode which is
actually configuring some kind of
flushing strategy to your complaining
and complaining engine so it's plugging
with with the final if spring add-on
that they're developing so instead of
rendering the whole page and then
writing to the network of flushing
whatnot they're flushing in a
progressive way so you can configure
like flush every five K bytes or
something so you can make sure that the
the template that you're rendering is
being flushed regularly and sent to to
the HTTP client so that that can be
useful especially if you've got big
pages or if you're looking into
progressive rendering on the client side
that's that's a neat feature there's
also something even more interesting
which is the data driven mode and so
remember when we were giving that
publisher to
model there's a different way to do that
you can give that in a special way to
the templating engine and ask the
templating engine to render that
publisher of here samples or values or
whatnot render them in as fragments as
HTML fragments and render that don't
render the whole thing as a service an
event stream so we'll see that we'll
make that clear in during the demo up
for you
there's also spring data so spring
attack' is the first major release since
its inception in 2009 which gives them a
give the team a chance to review some of
the decisions they've made so you there
is plenty of stuff besides reactive so
there is support of reactive form for
store now readies MongoDB Couchbase and
Cassandra but they've also they've also
improved the programming model quite a
lot so you have for instance a support
for new label new label parameter so if
you have a query and you flag one of the
parameter as new level then the
parameter can can be optional that way
you can also use optional if you want so
there's plenty of new options you can
use when you define your queries on you
on your repository interfaces as we've
mentioned where we didn't reinvention
explicitly but if you build that kind of
app it has to be reactive end to end
right so it has to be reactive from the
moment where the framework is reading
the byte from the request up to the
moment where we actually writing the
response to the client so the the tools
that you're going to choose are going to
have a high decision point of whether or
not this is a good fit for you data
store access is obviously very important
so you you got we got you covered with
Spring Gala
there's also spring security and many
other a part of the portfolio that are
switching to this world so you can
expect that with the tools that that you
are using today one more thing also that
we are going to demo actually now is the
support of infinite streams so with the
terrible terrible cursor support in
MongoDB so basically that the ideas you
wish you a query and you keep the
connection open and when there are new
elements matching you
search criteria they get pushed to you
right so let's start with that one maybe
yeah so in the current view we'd like to
have that graph that have it updated
automatically when we're looking at the
dashboard so for that we need to have
that view but on the client side as well
the browser should connect to some kind
of service and event endpoint which is
trimming that that new data and the
browser should get that data and push it
to to the graph to add the new the new
data points as they as they are coming
so for that we're creating a new method
in our repository so we're looking for
data for a given zone ID and a given
date so basically what we are going to
say is give me the data as from this
minute so did cure in minute so that you
don't get data from the past because you
don't care about that right since we
already draw the graph with the 40 last
measure that we have so the the
application will keep a connection open
to the to the database and the database
will just stream data with a cursor as
it's being persisted to the data store
so we're getting the data as soon as
it's it's it's hitting the data store so
we can we can expose that as service and
even actually very easily so let's see I
need to filter on the zone right so
that's probably a powerful evil there
yeah
okay so let's create a new endpoint get
Mac ping with a given path all right
that's our thing and it's called at
updates and we produce so sentiment yeah
that's the media type text stream text
even stream right so the the return type
has usually responsibility to indicate
that this is not something that we need
to resolve as a view but that's that's
actually the body of the response
um right so let's see so now when
someone is asking for that data we need
to get the current time
so we're resetting the current time to
zero seconds making sure we're in the
right zone offset and then we're asking
the repository give us all the data that
you've got from that instance onwards
and we're just returning that and what
flux will do the rest
right so updates there
it needs we need to wait awhile because
we have this ten-second window a few
seconds what what you will see is
basically 1:9 and every 10 seconds yeah
that's the one and every 10 second while
more or less since we push new data to
the tuner MongoDB correction it will be
pushed as well in the reply as you can
see here so that's very very easy to do
and once you have that actually
upgrading your client sign to 2 to draw
the graph automatically is very easy if
you know Java Script which now have the
ability to demonstrate my JavaScript yes
so watch watch out it's very very
impressive there you go right that's the
one so it's no library involved we're
just using the regular even source and
getting that data and pushing it into
the graph library that we're using so
every 10 seconds or so the data should
be streamed from the database then
application than us and then we push
that data data right into right into the
the the graph and we can see that
actually India in the network tab off
yeah Chrome and see yeah it's got a feed
it right updates 1 and then you can see
the data and what basically you can you
get the idea so for streaming use cases
it's really interesting because you
don't have to deal with concurrency and
reconnecting and all it's it's way way
easier to deal with those types because
flux by itself is a stream and it can be
infinite so you don't have to like I
have a special case for those it's just
the same and we've we've not for the for
the sake of the of the demo H was not
hundred percent correct because what you
would have done probably is
to actually share that flex as well
right so rather than creating that and
returning it on request which would
actually issue a terrible cursor on the
MongoDB database if you simply share
that as a field and you use the share
operator then you just get one
connection to your MongoDB database for
everything right next up is we want to
show the the mode that that Brian was
mentioning the the data data driven mode
of time.if 3 so um what we want to do is
we have this do an event error which is
empty at the moment and we want to get
some information about the system for
the sake of the sake of the demo and
what we are going to do is to get our
data our initial data and find out the
sensor that are actually reporting a
current consumption of 0 so let's say
there's a power cut in the neighborhood
you want to know which sensors are
reporting zero because it should be
normal or something so if there are too
many of those you should be looking into
that particular zone because they may
there might be a problem
so in that case instead of fetching data
as JSON as you know with an SSD stream
we like we wouldn't want in that case
for example we don't want to fetch the
JSON and then do something with a
server-side template with a client-side
template library or so so here we'd like
to just use the server-side templating
engine and render HTML on the
server-side and just push things simply
in the clients so for that we've got a
CAD mapping producing service and events
as well but in that case where it's not
a response body we want to render review
and the tricky thing here would like to
get the measures only the ones with the
power of the current consumption at zero
so we're filtering date data on the fly
so remember this is the same this is the
same flux that we were actually using to
store the aggregated data so it's the
same flux on the same remote connection
to our remote service
to actually share between those two use
cases faulty mirrors right and once we
have that thing we'd like to put it in
the model but in a special way so there
is this this this type that you can use
from time relief to indicate that it
should run in data driven mode and when
you wrap you wrap your publisher into
that variable time leave will actually
subscribe to it and render item in this
case we want to we want to flush every
item the default is 10 so I can actually
ask time image to flush every one item
right that's a semicolon well done and
once we have that and let's have a look
to our page so that that box that's
empty for now is a div with ID events
and their time leaf is expecting an even
stream publisher okay so a collection of
events here so we could render that with
the first render pass on our page but in
that case we'll ask a fine leaf to take
that to partial that that template
fragment and render it using the model
attributes we're giving it so here are
the the stream of data infinite stream
of data and we build that that view with
it and in the end we'll get a stream of
HTML fragments rendered on the server
and on the client side then it'll be way
easier to add the data to our existing
application so if we if we go to that
again if you go directly to the row
endpoint you can see that now time leaf
is ready we don't have any faulty
measure so we can actually use our our
downstream service here if you can see
so there is there is a simple endpoint
where we can change the way power is is
generated so let's say for that area I'm
going to say it's alright zero so all
the sensors are going to report a value
of zero and then you can see that time
leaf is actually subscribing to that and
pushing the data to you so these are
bits of HTML and if I want to if I want
to actually display that in in the page
itself
then I'll be able to demonstrate some of
my JavaScript abilities again watch out
there we go boom so what happens here is
that we consume that that server sent
events stream and for each element we
basically pretend the HTML to to the
current page if we do that it should
work or not this is yeah there we go
yeah and I can see those being rendered
and I can actually click and if I click
then I will I will basically see that
something is seriously wrong and back
cool right so um
in order to build those features there
is plenty of things that Springwood does
that we had to reconsider simply because
they were completely tied to the server
TPI or tied to a spring MVC model one of
one of those is the actuator if you've
used that desire set off so you can use
that with gen-x if you don't have a web
application for one but if you if you
are using a web application then we
automatically expose MVC endpoints that
you can invoke to get some some
information about your configuration the
status of your app on your application
some information about the service
tracing heap dump etcetera etcetera so
we had to basically find a way to
redesign that those features in such in
such a way that it runs with web tracks
and remember it needs to be reactive end
to end so we have to take that into
account so what we've done is we've
build a new model for defining those
endpoints that is not that it's not
related to the sûreté appear anymore
which gives us the the ability to deploy
them with spring MVC and spring ref
drugs but also Jersey and if you if you
are using spring boot with jax-rs
we support Jersey so we have spring buta
actuator running natively on on Jersey
now
if you use a different implementation
the code that's actually required to
support that is very very small it's
really about defining a registering
sorry resources programmatically so if
you have that kind of API and most
dexterous implementation do you can also
support other implementations spring
boot 2 is also a chance for us to
revisit some of the decisions that we've
made if you use the earth endpoint you
know it's it's a bit weird because there
is two use cases one is you want
external monitoring system to know if
the app is up they do not want them to
see details so you can configure it in
such a way that if you don't have the
credentials you only see the status but
you as a privileged user you want to see
the details so and others would like to
see always the details even though there
is security so it was a bit awkward so
we've decided to move that into two
separate endpoints so now we have the
status endpoint that only show the
status and the earth endpoint always
show all the details another thing we've
been working on quite heavily is the new
a security security auto configuration
in Springwood
- so if in Springwood 1 you know that we
have auto configuration for your app so
your endpoints basically auto
configuration for the actuator and stuff
that you can put in the middle and to
know your security the security
configuration of your app it may be a
bit harder because you have to look at
multiple places potentially so we've
decided to go away from that and just
have one basic spring spring security of
the configuration in case you don't do
anything so that your application is
secured by default and as soon as you
express an opinion then we will roll
back off completely which gives you the
impression that you have to implement
everything yourself and hopefully this
this simple prove the opposite so what
we've done as well is providing a set of
feature of helpers that allow you to
define the security for the spring boot
related pieces very easily so in that
case I want to say that status and info
available for everyone
say that all the other end points
regardless of Armenian points you have
whether ya enabled or not it doesn't
matter needs to have the roll actuator
then I want to say that everything which
is aesthetic resources is available for
everyone and then you can start with
basically your security config and if
you want to know what happens you just
have one side to look at you know so
that spring boot has metric support so
in 1 5 when model X you have contouring
contour engage simple API you can inject
in your services to report things and we
have a facility to export those metrics
to some systems and management systems
there is a new project actually that we
start we started to work on called
micrometer and the lead of the project
is basically has this this catch phrase
think about a salad for Jay but for
metrics so this is an API that's
independent from all the monitoring
systems with binding for many of them
taking care of the differences between
them because some monitoring system will
not allow you to define your metric with
a certain structure other will have
other imitations and basically
micrometer will make sure that whatever
you define is mapped properly a major
change as well is the the the way
metrics are defined so right now metrics
are defined erratically
so for instance if you want to if you
want to check how many times a request
has been made on a certain end point
with status 200 you would have something
like HTTP dot server dot required 200
dot path and then the value of the
counter a micrometer and moved to
multi-dimensional matrix so you all you
get is the name of the metrics which
would be HTTP server requests for
instance then you can add as many tags
as you want so you'd have a tag which is
method which would be get you would have
a tag which is status which would be 200
you could add as many tags as you want
and when it's mapped to your monitoring
system then you can use those features
to filter and find the data you're
looking at
so yeah so with all those changes and
all that everything that Stefan
highlighted in the previous slides so we
realize there are a few changes in
behavior with spring boots Adaro a lot
of people have been testing during the
snapshots and in the milestone phase but
we are soon hitting the the RC phase and
milestones milestone six got out quite
recently
so please try things out right now
there's a chance like to to look at
things before we're entering the RC
phase we've written consistent release
notes for every milestone and we're
currently working on a migration guide
so given an overview and not on all the
changes so just so you can try things
just go ahead go and start a swing that
IO and you can select the latest
2000 milestone and that's where you can
raise feedback on our Gator channel or
any issues that will be super useful and
with that that's how to look at actuator
into oh okay so I need to add a new
dependency together in
right okay now that we've got the
starter as you described you don't get
all the actuators exposed out of the box
right so we can look at status for
instance okay of my application is app
info don't have anything right now
then I can go to environment and then
boom it's not there so the reason when
the reason why it's not there is because
we don't have any there's nothing that
with well actually you would expose
potentially sensitive data so there is
many things you can do you can enable
endpoints in individually or you can
decide to actually override the default
with the default for web exposure is
false you can put it true that's shown
on phones and if you do that you know
you're basically expressing an opinion
as you always do and you you get
consistent result so one thing which is
interesting also in tool is if you look
at the if you look at the values of this
of this app you can see that there is a
property sauce for the file I just
edited and for that key there is an
extra parameter now for each key which
is the origin and the origin tells you
exactly where the value is defined so
that's line 40 character 31 and if you
have good eyes you can see right below
that's for 31 so the idea was this is
that we we want to work with ID
developers to give you some kind of of
links within the ID so that you can
directly jump to exactly the place
you're looking at if we are looking at
the narrowed end point so you can also
ask the environment for a specific key
then we have a new format where you can
know which property source actually
contributed to the value what the value
is and all the property sources that are
actually in the system in this case
there's only one value but you if you've
defined that key in two places and you
don't even you know you don't really
understand what what happens and why
your system is behaving behaving that
way you can have a look to this and
realize that maybe you pass a system
properties and you forgot also diamond
it's quite useful can also access the
earth endpoint and then we have the the
regular endpoint noon already
what one thing we should know there is
we have all the usual earth indicator
which may block actually so remember we
told you if you do that that kind of app
it needs to be reactive end-to-end so
what happens for instance for its let's
say that this disk space is blocking
actually yeah it might be for anything
blocking reading because we don't want
to penalize the the whole application
and blocking a thread because we have
some so few of those for that we are
using a reactor operator to schedule
blocking operations on a specific
scheduler so there are many choices but
we are scheduling things on an elastic
scheduler I believe so that we're not
blocking the the nettie threads sir
serving the actual requests and we can
safely do the blocking operations in a
separate place so the obviously the
reactive if you've got for example here
a reactive driver we won't do that in
the blocking way we'll do that natively
in a reactive way if available and let's
actually show that in practice so if you
if you want to build your own earth
educator you know that you can implement
the earth indicator and just basically
write some logic that will actually
check whether or not the subsystem
you're looking at is working properly if
you do that in a reactive based
application the chance is that you are
actually using a publisher yourself is
very high so you need you need a way to
actually express that what we've done is
we've added reactive specific contracts
for those things so let's show a metric
aggregator and we get notice indicator
it has a really long name and that one
is actually a reactive earth indicator
so that's the reactive specific callback
interface I was talking about and there
you can actually return the money of
Earth so you can create a pipeline
whatever pipeline you all you have in
mind to check that the system is working
and we will actually execute that so the
earth endpoint is reactive and we also
use in those cases reactive reactor
features so if you have like 10 or 12
earth indicators we actually ask reactor
to run them concurrently if the current
load allows it so we just say ok just
execute that and combine the results and
give that back to us and we push the
JSON based on the outcome right so I
should have a new metric a greater
aggregator there cool that is up if I
shut down the service but now what the
usual stuff yeah right okay so um we
were talking to you about choices so
maybe we can have a quick look to the
backend services that we we haven't been
showing much of much of a code so it's
again it's something that generates
random data so it's not super
interesting but what we want to show you
is a different way to configure your web
application and one of them is to rather
than using controller based annotation
based or a controller is to define your
route programmatically so what you can
do is you can expose a router function
as a beam a spring boot will detect that
and then you can use a new API in Spring
Framework 5 to define your route and so
that's basically a predicate those are
very simple but you can make make them
as complex as you want and then
basically the function that's going to
service that request if we look at the
fire hose for instance it's taking a
server request returning a response and
there you can use the new the new web
function an API that we call web flex a
fan
to service the request another thing
remember I told you about these end
points that allows us to change the the
minimum value in the maximum value for
the generation it's actually a custom
actuator endpoint so for the sake of the
demo we done that probably would have
probably create a regular controller for
this so this is the this is the
programming model you'll basically
define a new endpoint concerns then you
can create operations and we will use
that and that's API allows us to deploy
that to web flex whatever we see Jersey
janek's yeah totally web framework
agnostic you don't need to write
separate operations for for each I think
that's it yeah so we have four minutes
for questions thank you thanks
so the question is unique test support
for the new reactive support yes
definitely something we didn't have a
chance to show but they several things
one is a utility called step value fire
that allows you to assert your pipeline
so you can run expectations and the step
verifier will subscribe to your
publisher to your pipeline basically and
make sure that everything works as
expected
yeah yes also the web test client so
just like the web client you can use for
like but we've been using during the
demo the web test client is a client
that you can use to test your web
application the nice thing that I really
like about it is that you can test your
application with that client and test it
with the same API in both ways just just
the setup slightly changes so you can
either test your application just like
mock and VC no server is getting started
during the test so it's still
integration test but no server involved
or with a simple switch you can you can
flip the switch and ask the server to be
fully started
test the whole application run in for
real so that's that's really that's a
really nice API in a really nice way
with good assertions to test your your
web app there's also what MVC test if
you are using that so when we see test
that allows you to only test your
controller the slicing into you have
Webb flux test and it does exactly the
same thing for reactive endpoints cool
yeah question here
okay the the the question is during the
demo we used the web client to get data
from the the aggregator service and we
were getting data every seconds that
that was streaming so it's is it polling
or is it getting data as it comes so it
is a persistent connection to the remote
server and we're getting data as it
comes we're not polling we're not
retrying or so it's a persistent
connection and we're getting data
streaming the web browser oh the web
browser is the same thing same thing
that's a server sent events
that's the persistent connection between
the browser and the server in the
browser the server pushes new data as it
comes in and the browser reads that and
any reactor it's a bit like WebSocket
but it's on it's only one way where
WebSocket is a bit more involved you can
choose your own protocol on top of
WebSockets
you could use stump or something else
and it's two-way communication you could
you could stream away stream data up to
the server but in that case is just
streaming server to client
it's a persistent connection so yes
so that's the dreaded question about a
jdbc and reactive since there is no
reactive driver currently with JDBC
there's no clean way of doing that so
you could in theory schedule that on a
secretary jewell or related with the
health indicators but you'd be losing
like most of the scalability and the
back pressure and everything so there is
there is an initiative reactive JDBC
that they've announced at JavaOne
asynchronous I think that's the
synchronous driver for JDBC they don't
call that reactive GBC that's all I I'm
not sure get to be anyways so you need
we need to wait for that to make a move
actually there is nothing we can do the
API underneath is blocking know as soon
as its input stream output stream based
you you can't do anything reactive with
input stream output stream it's blocking
and times up so thank you very much and
you can come if you have more questions
thank you thanks
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>