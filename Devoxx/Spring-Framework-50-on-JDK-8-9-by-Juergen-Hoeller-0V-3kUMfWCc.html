<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Spring Framework 5.0 on JDK 8 &amp; 9  by Juergen Hoeller | Coder Coacher - Coaching Coders</title><meta content="Spring Framework 5.0 on JDK 8 &amp; 9  by Juergen Hoeller - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Spring Framework 5.0 on JDK 8 &amp; 9  by Juergen Hoeller</b></h2><h5 class="post__date">2018-03-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/0V-3kUMfWCc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right I guess I'll I'll get started
feel free to come in if there are any
ones not having a seat gets welcome to
the spring formal talk today I have the
pleasure of returning to Vox tiene so
this is not the first spring time a live
talk I'm giving I had a kind of preview
themes and trends talked last year so I
chose to pick a different focus for for
this year's talk this is somewhat more
specialized talk that actually came out
of our spring one platform conference
which happened in December in San
Francisco last year so it's if I'm not
mistaken literally the second time I'm
giving this talk first time it's spring
one last year with a more specialized
focus on each ad key story in spring
from ik 5 the specific arrangements that
we're making for spring from ik 5 to be
a fully and truly and deeply Java 8
based framework and then measures that
we're taking towards JDK 9 compatibility
and not only 9 I mean it says agent 9
here but whenever I say 9 in the context
of this talk I really mean 9 plus I mean
I will elaborate on this and the
specifics of 9 10 11
a little bit later on but in the end
every time we say 9 here we really mean
9 and it's follow-ups 10 and 11 we'll
get to that
so spring from ik 5 itself let's go to
the to the fact sheet for a moment is
already the fifth major generation that
I I have the pleasure to introduce since
I've been doing this since the very
inception of the Spring Framework open
source project this is always a very
personal milestone as well to bring a
new major generation of the cool
framework to out out into the world and
spirit this is kind of the fact sheet
right we're not going to talk about all
of those things in detail but spring
from
five is many things the GDK eight
baseline upgrade is one of the key
efforts in Spring Framework five another
one is the coupling focus so the kind of
parallel support for parallel
first-class support for Kotlin as an
implementation language in application
projects so it's it's essentially Java 8
the language and it is Kotlin and it
still is groovy
admittedly the primary focus is on Java
8 and cutting these days and we really
mean those things so the first class
support means throughout the framework
Kotlin idiomatic extensions for many
spring Formica API types
just like the Java 8 story I laid a few
notes to that later on there is also a
key kind of thematic background to to
spring for Mach 5 we're trying to
revisit what we're doing from from a
different perspective I'll elaborate on
that a bit and the main the main part of
for our purposes today is about the
baseline upgrade it's not just JDK 8
plus it's also raising the baseline for
example 2 server 3.1 plus and JPA to
that one plus a kind of drawing in line
in terms of how far back we would
support integration api's 4 for external
infrastructure and of course there's the
opportunity not only to kind of raise
the minimum level but to also look
towards the very current level and that
is of course into in the jdk world it's
jeddak in 1911 but in the java ee world
it is the job he ate api level which
after a somewhat well lengthy and
complex process finally was released to
the world last last year and it is the
baseline for what is now to become
Jakarta in the e4j project it's the same
API level in the end no real work
happened happen since Java yet
so this is Soviet photo though it's been
military into the dough or in terms of
providers it is the recently released
Tomcat 9 it is hibernate validator 6 it
is hibernate or m-52 3 which is not
actually GA yet it's the API level
behind those providers
there's also first-class support for
that so in in spring for Mac 5 as usual
kind of we are trying to position it for
the years to come the baseline is kind
of 2013-2014 era api's but what we
really care about is the api's that are
going to be mainstream
in the course of this year in the course
of next year so we are really preparing
the framework for 2018 and higher
a few words before we go into the jdk
topic specifically a few words on the
usage style and the interaction style
with the framework components spring
traditionally has a very strong focus on
on an annotation based component model
this is of course well-established it's
very complete it's in many ways a
totally mainstream programming model in
the meantime this is of course fine I
mean this is this this was a key goal in
particular in the Spring Framework three
and four generation in spring from AK 5
we intentionally put ourselves into a
different perspective take this with a
grain of salt we're not saying that the
usage model has to change the annotation
model is still the first kind of first
choice the common choice the mainstream
choice by far but for the purposes of
challenging ourselves of enforcing a
different perspective on to the
framework making the framework usable
from different perspectives we revisited
a totally different style a functional
programmatically oriented functional API
style so instead of using annotations
and instead of using reflection we're
trying to programmatically express
ourselves
to allow applications even very minimal
micro service arrangements to express
exactly what they need to express in a
purely programmatic fashion with no
annotations no class puff scanning and
to some degree even no reflection if you
are trying to avoid that to begin with
there is a kind of that as many factors
that come into into play here not least
of it all coupling so I'll I'll get back
to Kathleen he here for for once since
the Catalan language provides some very
nice facilities actually not the
language but the Coughlin compiler and
the runtime provide us with certain
introspective introspection mechanisms
that allow for closer interaction with
the language constructs for example we
can reliably infer the return type of a
coupling function something you cannot
do against the Java 8 lambda expression
at runtime this actually does influence
the API design we can come up with more
concise and more expressive Kotlin
variants of some api's because of those
runtime features but back to the notion
of a function of registration and
functional composition this is of course
a somewhat extreme perspective spring is
always about shades of gray right a sort
of a certain middle ground that is
emerging which is what what people
actually do in practice of course these
things mix and match you can register
certain pins programmatically with the
functional registration mechanisms and
send the container onto a class path
scan for certain components that you
detect by annotation in the class path
ending up in the same spring application
context eventually there's nothing wrong
with that at all those things mix and
match you can programmatically reduce
the components that use annotation based
declarative transactions so all of those
things go together but from a framework
design perspective it is really useful
really healthy to force the framework
to be perfectly usable in for example
even a cut line based programmatic
registration scenario that has nothing
to do with a notation and even nothing
to do with travel the language the
outcome the common ground underneath is
what is bring from book 5 now and what
is really kind of these shaping update
we did toward spring from at 5:00 all
right and even if it's not a focus of
today's talk I have to mention it of
course because it is one of the things
we spent a lot of time on that we that
we really proudly present to the world
in Spring Framework 5 is the reactive
programming model and the parallel web
stack next to spring web MVC which runs
on the servlet API we have a parallel
web primer called spring web flux which
is a reactive streams based web
framework all the way through this on
its own is of course a very very key
topic and a very broad topic which it's
not the focus of today's talk but of
course a key reason why Spring filmic 5
really makes quite an impact on - on to
the Chavez scene at the moment just
clarifying one essential piece here eat
and I already hinted at it
those are two web sticks spring from
book 5 comes with two web stacks of
cause aligned with common ground
underneath but two essentially two web
frameworks next to each other
spring web em you see being a servlet
API based framework as you know it
allowing for straightforward upgrades
from from a spring framework four to
five it's basically the same stack it's
still servlet API this does everything
it did before has some fine-tuned
contracts underneath but you probably
won't even notice many extensions still
run the usage model typically annotation
based is still the same so a very
straightforward upgrade path in
particular for existing web applications
but also for newly written applications
where the servlet world is the best
possible match and totally fine right
servlets of course come with certain
limitations from the Soviet abstraction
if
ready request kind of threat bound
processing this is this is a limitation
and the quality at the same time there
are many things that you can easily do
in server based stack here that you
cannot do in a reactive stack so this is
not a black and white choice and it's
not like backwards compatibility and
here's the new thing the shiny new thing
it's really two options with their own
qualities and their own benefits and
drawbacks and it's your choice for a
newly started spring from AK 5 based or
spring boot 2 based web project did Co J
choice of web for Emma great so like a
traditional blocking jph ad BC API
transaction per thread thread bound
transactions you're probably better off
here on Spring Framework 5 no doubt
about it if you've got a reactive
database driver for Couchbase for
Cassandra 4 for MongoDB and you're
really you'd like to expose the reactive
interaction model that the data store is
offering to a web stack into a spring
based web stack then web flux is your
friend your Joe is soft underlying HTTP
engine not servlet based reactive
streams based even if tomcat and Chetty
are used as an engine underneath the
covers they don't serve as a servlet
container here they serve as a reactive
streams in enabled HTTP engine and so
it's really a reactive power that can be
exposed to the web endpoints and to
usage models on top in a notation based
model even for the reactive stack and a
programmatic functionally oriented model
for the reactive stack all right so much
really for we'll we'll get back to
certain parts of this but so much for
the for the kind of general spring
Tomica 5 story line a key and often
unappreciated step that we took in
spring time Mach 5 is the JDK 8 baseline
upgrade this is the first time we
actually do this that the entire
framework is Java 8 based
and it's worth reiterating why why it
comes so late right it's not really late
but for our purposes it's sort of late
that we go that far the main reason is
quite simple in spring for Mach 4 let's
take for the three as the end of that
line and spring framework for the three
there is already a very rich Java eight
development experience for applications
it's internally a Java six based
framework with many Java 8 extensions
that are automatically enabled and live
in the standard jars so from a usage
perspective if you consume spring from a
fall of three in a Java eight based
application setup it essentially feels
like a Java eight based framework to you
at least in any ways right for many
scenarios but there are certain things
we cannot do or certain things that we
have to do in a specific fashion right
if you present code to us annotation
based components with injection points
with handle method parameters then we
can reflectively introspect the use of
Java it constructs we can see that
you're using Java util optional and we
can automatically create an optional
instance for you we can detect your
usage of completable future we can
understand what you mean if you're
trying to bind an HTTP header to a kind
of local data or whatever so we all we
do all of this reflectively in through
Java extensions essentially that are
reflectively enabled it's quite
efficient at runtime there's no
performance drawback but it is something
we can only provide to your code the
framework itself the framework API and
the framework code base the
implementation code base cannot make use
of Java it constructs so just in fall of
3 we even go a little bit further and
it's worth pointing out that this notion
of functional interfaces in Java 8 was
really it really comes with a fine
convention based design we can very
easily interact with lambda expressions
method references without having to
declare any specific Java it constructs
because it's a convention a an interface
with a single callback method can serve
as a functional interface the Java 8
compiler accepts that sort of interface
is the target of a lambda expression or
a method reference without a net
functional interface annotation or any
other Java it's specific construct so
even quite elaborate use of Java 8
constructs in your code against spring
api's is already possible in spring
framework for the three we're even using
repeatable annotations by declaring the
convention for repeatable annotations at
Java 8 feature Java 8 compiler feature
that we already enable for quite a few
annotations in Spring Framework full of
three if you're using the Java compiler
if you're using Java 6 or 7 you have to
do it the old-style way with a container
notation but it's kind of naturally
ignored there's no parallel existence of
distinct Java 8 code and preach away it
could here it's the same code base the
same framework the same chars
automatically adapting to your use of
Spring Framework for the 3 on Java 8
versus Java 7 or 6 this is the main
reason why the Java 8 store is already
in place in action for several years
right it's against Spring Framework for
three but we were waiting for a certain
point of time at that point of time came
in the second half of last year Java 8
becoming dominant in the industry not
just being the stuff that kind of the
latest projects used that newly started
projects use but Java 8 is a baseline
even for existing deployment
environments even for even for existing
data centers this is of course it comes
out of a survey but it's quite quite
indicative and the quite accurate I
believe
indicating a strong dominance of Java 8
late last year this is really the point
that we were waiting for
where it makes sense for the framework
itself not only to support Java 8 in a
broad and deep fashion but also to be
Java 8 based internally and really
embracing even the little things we can
do with char 8 so spring fabric 5 is
Java 8 based now requires char 8 if
you're on 6 or 7 there's always bring
some work for the 3 for you and it's
going to be supported for several years
to come right so it's not going going
away all that quickly but in spring for
Mach 5 we literally revisited the entire
code base I'm not entirely sure that we
touched every source file but certainly
very many of those just by iteratively
using Java 8 constructs internally we of
course have plenty of code that can
benefit in terms of its readability in
terms of its maintainability from the
user Java it constructs internally like
all the collection interactions right we
can choose to use collection streams we
can choose to use the new operations on
on collection and map we can use for
each with a consumer callback we can do
all of those really nice things that you
may already be totally used to in your
application code we can finally do them
internally in the framework and there
were many iterations many many
contributions also from the community in
terms of how to improve the existing
code base along those lines there's also
some some new runtime facilities in Java
8 that allow for doing things somewhat
more efficiently than before in
particular in the reflection API in
parameter reflection so this is nice of
course won't make much difference in
practice but it certainly is a step
forward we're really taking it that far
and we're doing everything we can to
kind of exploit what Java 8 is offering
within our framework opus more
importantly maybe for application
purposes right we can start
exposing Java eight specific API types
new API types that have been introduced
in Java 8
we can finally expose them in our core
framework ApS simply speaking right
framework interfaces like bean factory
like application context and others
previously we're unable to have hard
references to Java 8 API types no
completable future no java time types no
Java util optional no Java util
collection streams in the hard
interfaces right we were only able to
reflectively support them in your code
if you wanted an incoming parameter of
that kind or and you had a return value
of that kind but we couldn't do this in
the core framework api's because they
had to be runtime compatible with six
source six and seven we're finally able
to do this and this is one of the most
significant revision in the EAP is that
there are some overloaded methods now
that instead of a Java util date they
may take a Java time instant they they
accept the Java time duration parameter
where that is semantically applicable we
have hard conversion API is very
immediate convenient conversion ap is
between this little future incompatible
future and we're making use of the Java
util function interfaces this is maybe
the most important common ground in
terms of API design in Java 8 finally we
have a quite rich set of functional
interfaces of simple common callback
interfaces that everybody is using
already but all in their own little
copies now we have kind of a canonical
version in the Java util function
packages of Java 8 blowme we're making
quite some use of this the notion of
instant suppliers the notion of
dependency consumers there are quite a
few spring api's that expose or accept
callbacks of this kind now and on the
way forward we're trying to make as much
use as possible of those common core
Java 8 Kolbe api's Kovach interfaces
instead of inventing our own
right and one of the goals here is not
just do it because we can there's also
some some interoperability behind this
because quite a few libraries and
frameworks out there are already Java 8
based or at least have Java 8 based
versions of their own of themselves and
of course they they would they would use
those Java 8 constructs they they use
Java util function they accept Java util
function parameters they return
completable futures they use the Java 2
time types if you wanted to
programmatically interact with them from
spring containing the background the
spring container context to those Java 8
based API s it of course is really
useful if they kind of talk the same
language and they use the same API types
without any need for for adaptation or
for conversion so not least of it all
for that reason we're trying to
streamline and tag the entire API
surface in spring towards each other the
common API design ground in Java so just
a few examples also got some some names
right on on on those slides I'll
elaborate a bit on on the Y's here
another one is default methods in Java 8
this is a language feature allowing for
a an interface to have a well a method
declaration with a body right so I enjoy
eight an interface doesn't have to have
abstract method declarations it can
choose to have default methods with a
simple fault implementation of course no
state detached but the default
implementation may make all other
methods on the interface or it may throw
unsupported operation exception but at
least it's there it's there for it to be
compiled against as it's primarily a a
language feature that they introduced to
allow smooth migration of interfaces
adding additional methods to existing
interfaces is otherwise always painful
because an existing implementation of
that interface doesn't have those new
methods so it would fail whenever those
new methods are being used
default methods are a way to suggest
default implementations for some of
those new methods in the interface so
that the existing implementations would
implicitly get those new methods as well
in their default information we're
making quite some use of this in in
Spring Framework five and essentially
for two different reasons there are
quite a few cases where we provide
convenience methods along those lines
basically overloads where just there's a
very simple default implementation
calling some other method on the same
interface with some adaptive parameter
was some missing parameter right so
that's that's an easy way to introduce
those is through default methods so
we're not just using it for a backwards
compatibility story we are using it as a
design measure as a design tool in in
our interfaces quite a few existing
methods have been turned into default
methods that maybe need some a little
bit of extra elaboration so there are
existing methods in the Spring Framework
interfaces now declared as default it's
simply for convenience if you implement
for example the pin post processor
interface it has two callback methods
you but in all likelihood you're
probably only interested in one of the
two but you always had to implement two
in traditional Java now in being post
processor both of those have been
declared as default they basically
return the B&amp;amp;S is in their default
implementation so whenever you implement
the pin post processor interface you
choose to just overwrite one of the two
the one where you actually want to
customize so default methods are also a
way to conveniently get rid of kind of
stop implementations for certain
interface methods that you don't care
about this is a quite important use of
default methods in its own right now
having nothing to do with backwards
compatibility but instead having to do
with convenience for implementers of
certain callback api with more than one
one methods usually we exploit this
quite a bit in being host processor
Factory being has default mannan two
implementations for
is singleton we even have some default
implementations in in in SP is like in
the resource SPI this is actually quite
useful as a kind of design tool for us
but in particular it makes it easier
also for the backwards compatibility
aspect for us to introduce new methods
along the same lines the new methods are
also default they do provide for this
feature that existing implementations
inherit that new method but design wise
there then also aligned with existing
methods that are declared as default the
same style right we care about
consistency there shouldn't be an
artificial difference between newly
declared methods newly added methods and
existing methods if they are of the same
kind and both of them benefit from a
default declaration then they have it
now in spring formal five may be the
most common ones are to be found in the
integration at higher levels the
transaction synchronization copic
interface plenty of methods benefits
greatly from default declarations for
those existing methods or in spring and
BCD Handler interceptor with three
callback methods and in all likelihood
you may be interested in one or two of
them but not in all three more
convenient to implement now and no need
for adapter classes anymore with stub
implementations of the other methods so
this is of course also something you may
exploit in your own library or framework
design if you if you have certain parts
of your code base that fall into that
category okay now back to a slightly
higher usage level how how would we use
this for example for the programmatic
registration part this is how you would
be able to write code with Java 8 now in
spring from f5 generic application
context is the same class that existed
ever since spring from 2.5 basically
just say new application context this is
your container instance now and instead
of sending it on to a class path scan or
registering annotation based components
you register beans by class beans by
class is somewhat
easy right also somewhat boring because
in a way you were able to do this before
and we constructed with its default
constructor and don't do anything
special with it ready the new part comes
with what we call instant suppliers here
we register a beam of type bar and we
pass a lambda expression in this is
actually a Java util function supplier
in terms of its signature every time the
container needs a new instance of that
beam
it actually dispatches to this instance
supplier so whenever the container
decides to create a new instance of bar
it won't call the default constructor or
any other constructor it will call this
instance supply in T the job of the
supplier is to create a new instance of
bar it's as simple as that if you need
dependencies onto other pins in its
simplest possible fashion just call back
to the container and obtain them there
are some existing retrieval methods and
some new retrieval variants and there
are some further ones coming in 5.1 for
programmatic retrieval programmatic
filtering of existing beans so that you
can programmatically extract them and
pass them into the bar constructor which
in this case accepts a foo instance as a
dependency so it's its constructor base
dependency injection in a functional
style so know at Auto white here no
class but scanning in this setup
technically there's a there's reflection
here so so this one called the default
constructor it basically does class new
instance it technically doesn't actually
do class new instance but something
along the lines right so it's
effectively reflection but this one
doesn't use any reflection because an
instance supplier is compiled by the
Java 8 compiler as as a lambda
expression basically into a synthetic
method on the same class with a direct
invoke dynamic dispatch so whenever the
container needs to dispatch to this
supply it's literally straight into it
there's no reflection in between if you
wanted to exploit this a little bit
further here's a fine-tuned version just
to in the
hate what's possible this one specifies
an instant supplier probably it's worth
the second look red this is a Java 8
method reference not a lambda expression
but the method reference also binds to
the supplier interface to the same
interface that this one's applies to no
overload here so it's it's some only
very few methods exposed here but there
are very flexibly used with Java 8
language constructs so what does it
actually do it says whenever you need a
new instance of foo call foo colon colon
new right well that's the default
constructor right it's it's the Java 8
method reference pointing to the default
constructor of foo there is a difference
here because foo itself because foo here
up here required a reflection to call
its default construct and here we bind
the method reference to the default
constructor so we have the same
invokedynamic straight dispatch no
reflection involved so this is just
fine-tuning semantically equivalent but
this is slightly more efficient only
really makes a difference if you're
creating many instances of it right so
for a prototype being for a request
scoping this may be worth fine-tuning
and it's also to make a point because
you can set up a spring application
context without use of reflection for
for being creation purposes alright so
this one is also slightly fine-tuned
also exploiting some Java 8 language
constructs here it's actually two
arguments two lambda expressions both of
them in line this one is the instant
supplier this one is what we call a beam
definition customizer there's a it's a
VAR arc so you can have any number of
peen definition customizes so line by
line by line if you want further
customization just comma next lambda
expression and it's always the peen
definition which is the internal it's
kind of the underlying metadata object
in the spring container being passed in
for any remaining customizations for
example setting the lazy knit flag
programmatically adding qualifiers
adding other attributes this attribute
storage that can be used in post
processors there's all the things you
always to programmatically against the
beam definition can also be conveniently
customized here this to me from my
perspective is a fine example of what
we're trying to enable here some very
specific measures in Springs API design
allowing for some quite flexible quite
clever
I would argue usage of Java eight
language constructs for spring
configuration purposes clever in the
sense of making the best possible use of
the Java eight language possibilities
right we're really not trying to invent
anything new here we're trying to take
the features that the Java eight
language compiler comes with and we're
trying to make the best possible use of
it in our context in our world here
there is an equivalent for this in in
coupling by the way the focus for for a
different target so another another
example for Java eight API design
brought into spring practice this is
what we call router functions so if you
remember in the in the reactive web
stack in spring web plugs you could
choose to use an annotation based usage
model you could also choose to go with
what this little slide called router
functions and this is what we're seeing
here a programmatic way of tapping into
the web flux stack the reactive web
stack can spring from a five this may
initially look a little bit scary but
don't let it scare you it's basically
standard Java 8 interactions in in a
fluent style what are we doing here we
are setting up a router there's a static
input here for router functions so
that's a static method are coming from
the input that's also stating input
forget of course
so we're saying we want to express a
route for any incoming request that
matches this predicate please dispatch
to this method in order to arrive at a
reactive streams publisher for the
response to this request and we actually
have two routes we're saying for this
route dispatch to this
handler function it's actually an
interface a functional interface called
handler function you don't see it
because we used a in-line Java 8 lambda
code block to express this handler
function handler function has a server
request coming in and the model of
server response going out but you don't
really see the signature ID you just see
the use of the incoming request and you
see a server response being returned
there's a second route connected to it
in this little almost almost a
domain-specific language of a kind right
a DSL of a kind so for this incoming
predicate pass controller or dispatch to
to this particular handler function here
so maybe let's quickly go into into what
they are doing right so this one is
actually quite straightforward
it uses a repository a target object
that we're using here and this real
function which can for example be a say
a Couchbase bound repository from our
spring data project or it could be a
custom repository in implementation that
you hand coded returning a reactive
strings publisher and this is exactly
what to find all method is doing its
returning what we call a flux flux and
mono are both reactive strings publishes
flux is basically an open-ended stream
of objects a hot string of objects or
reactive stream of objects whereas mono
is a single object or non so it's a
little bit like Java util stream and
Java util optional or if you know rx
Java and this is very close to our
exchange above course that could be an
observable and this could be a single so
this is basically a handle that is
capable of producing the sequence of
user objects when actually need it it's
a recipe right this does not trigger the
actual data store operation it sets it
up and it can be integrated into a
reactive streams pipeline so that
whenever whenever we are ready to
actually process is we we kick it off
and we process the elements as they
arrive one by one or in a batch without
ever blocking
so a key quality of the API design and
the underlying reactive web that carries
that we are never ever blocking so
there's a an event loop with just a few
threads processing all of those
interactions and heal them with it's a
builder API saying HTTP okay this is the
body a publisher for the body and we
have to specify the body element class
if we want runtime conversion for
example to chasten elements so up here
it's just slightly more elaborate maybe
some of you already try to parse it
right we're basically saying the
incoming path has a path variable let's
extract that path urban let's convert it
to a long and pass the outcome of that
conversion which is the long ID to the
repository find by ID method which is of
course a Java 8 method reference here
that we're binding to let's assume
there's a find by ID long ID method
right on that repository and then we're
building this every response again for
the single user object that we just
found by ID
but again actually we didn't find it
right we expressed how to find it it's a
recipe it's a reactive streams publisher
that is capable of loading that object
by ID whenever we are ready to process
the outcome this both of those go back
register to the runtime stack and
whenever a request comes in whenever the
request is fully parsed whenever the
response is ready to be written to then
and only then we start triggering those
operations and there's a back pressure
model involved in the background so
whenever data arrives we're kind of
sending it through the codec step or
entering it out to the response
basically element by element we never
ever block waiting for the next element
to come in
we're being notified when the next daily
band element is ready to be processed
back up to our API design perspective
here this is just really close
interaction between how those api's are
designed how you need to express
yourself here and how the underlying
stack works right
all right so much for a little bit of
Java it usage in in the reactive world
we are not the first and not the only
open source for in fact to have a Java 8
baseline these days there's for example
to unit 5 this our own project reactor
hibernate or M is a 5 to 2 N Furter they
are all coming up basically ready to be
chava 8 baseline now because Java it is
just mainstream alright so let's move on
and talk about JDK 9 a bit so there in
in practice many of the things we do in
spring for mac 508 enable Java 8 based
but we look forward towards JDK 9 in
many ways we release the week after JD
canines GA and we track JDK 10 and 11
very closely in JDK 9 there's not that
many language features I mean there is
this new language for for module info
classes but there's the main reason why
you would move to JDK 9 is not so much
driven by language features it's more
infra infrastructural there are many
improvements at the JVM level you could
argue basically the jdk itself the JDK
setup and the runtime infrastructure the
JVM have been heavily reflected for JDK
9 and we get quite a bit out of this
they they really took the time to to to
do this deeply so at the JVM level for
example we have compact strings with a
more efficient memory representation of
strings at runtime if they can be
encoded in a in a single byte we have
the g1 garbage collector by default now
we can build custom JVM distributions
including certain modules and certain
characteristics of the JVM only there
are many things we can do finally with
the JVM that we are totally not used to
doing in in Java and we finally have an
SSL stack that's ready for HTTP two out
of the box without having to append
something to the boot class
perfora to kind of heck into into the
java hav a middle it's kind of read that
alone is actually a quite quite key
reason why you would want to deploy to
java nine and of course there's chicks
or the module system i intentionally put
it in that order
I see the JVM improvements and the these
tech improvements the security stack
improvements as key reasons why you
upgrade to JDK nine chicks or the module
system explicit use of the module system
in your application code base is kind of
a bonus and I would not put it any
further up because all of the all of the
other features in JDK 9 are so worth
upgrading to so don't let chicks all in
the module system scare you
we also talked we also talked about
reactive streams already it's just a
side note let's skip this quickly but
Java 9 contains a version of the
reactive streams SPI that we are using
in spring filmic 5 in a repackaged Java
util concurrent flow and if you use this
or any library that are based on this
with the spring from a5 reactive web
stack we would naturally understand it
so the reactive streams contract is
actually baked into JDK 9 but just the
contract no providers no implementations
no web server no database drivers this
is to come to follow in further
generations of the JDK so we may see
some use of this some react for example
a reactively enabled data database
driver coming out of the JDBC group
sometime soon it's in the prototype
stage unclear when it's going to be
productized but the core contract really
just a few interfaces are already part
of the change came other things that at
the at the API level may be worth
upgrading to is nice new factory methods
for kind of constant sets and lists and
maps instead of having to manually build
this and and and do an unmodifiable
collection in front of it there's simple
convenience methods for constant
collections now and there are a few nice
things in the Java util stream and Java
util optionally
is that a new in 9 introduced in 8
originally and some new methods in 9
that really make make sense and arguably
should have been there in it already so
there's quite a bit of now a new API
stuff in JDK 9 we're not going to dive
very deeply into this but all of all of
this is all of these forms the reason
why you would want to upgrade to it now
in jig so in the module system there is
a lot of reworking within the JDK the
JDK internally the JVM internally does
not look anything like before not the
directory layout and not a random system
either there is no our teacher anymore
there is a decomposed derangement of J
mod files efficiently compiled modules
that the JVM is loading at runtime on
demand and each of those modules those
JDK modules has its own name like Java
based Java dot sequel traveled
activation those are all separate
modules Java dot basis basically laying
util that sort of stuff right but almost
anything that they could factor out they
did actually factor out and you can
choose to link it in for example in a
custom JVM distribution or you can
choose to not activate it at runtime
when you put strap your JVM and to link
in an external dependency instead
instead of the exp version that comes
with JDK 9 you can choose to use one
that comes from maven central and
there's no overriding problem so
decomposing the jdk itself into smaller
modules that you can choose to use or
not use is a is a totally fine step
it forces libraries and dependencies to
revisit their dependency assumptions to
some degree but that's ok and we've been
forced to do this before because Google
App Engine has also much smaller set of
default api's so it doesn't really do
anything to the spring from a code base
that wasn't it wasn't necessary before
but there are some other libraries in
framix that are affected by this because
they assume that checks B or Java util
logging or even J in the eye are present
by default which they are not
necessarily on
Chiqui nine plus distribution so not
really something that effect spring much
at all but if you're building a JDK nine
based stack of other libraries and
frameworks you may you may hit some of
this interestingly even the Java X
annotation package is now not present in
Java code base anymore so annotations
like resource post construct pre destroy
are not actually active by default they
affected out and you as opposed to to
use a Java X annotation distribution
from maven central instead a version of
your choice a combination of your choice
and in jdk 11 coming up in September
this year in all likelihood these
deprecated modules are not even going to
be there anymore so you have to get
those providers in those api's from
maven central so that's the JDK internal
module graph you see it there's quite a
bit of connections the jdk libraries of
course are heavily intertwined it's they
have been growing as a kind of
monolithic code library for for for well
quite some time right a few decades so
obviously there are strong
interdependencies between those modules
but it's nevertheless very worth having
gone through these this decomposition
step in jdk 9 you may choose to use the
same module system for application
modules but if you're doing this you
have kind of a limited perspective onto
it
you can't use J mod files that's a
tricky internal JVM internal formats all
you can do is take your chance which
might already be modular rest and add a
module descriptor to it enforce certain
characteristics certain separation
characteristics in your Java file and
add extra metadata that expresses the
relationship to other modules so I
basically dependencies on other modules
and which packages you'd like to export
to other modules there are there's a
couple of things you cannot do in the
module system anymore so there has to
can't be any
between dependencies there can't be
split packages like the same package in
several Java files merged at runtime
there has to be a clean assignment of
package to module but ultimately this is
not rocket science it's just a
formalized version of of something you
may have been doing before like
separating your code into modules with
certain dependencies allow that is not
allowed certain expect is to be used by
other modules others to be considered
internal this is just a formal
representation and a way to instruct the
JVM to enforce those characteristics at
runtime whereas on the class path so if
you just drop your Charles on to the
class path which you can keep doing on
Java 9 there's no enforcement it's
basically just a long sequence of sip
files and every time we need a class or
is we search through that long list and
at some point we find it that's all
we're doing there's no separation
whereas on the module path which is kind
of a different mode of operation so
that's kind of you can bootstrap Java 9
in class path mode or in module path
mode and if you in if you deploy your
Java is in module path mode each of them
is going to be concealed by a runtime
shell around it every char kind of has a
module representation at runtime so it's
not just a compiler enforcing something
it's also the runtime enforcing
something and there's even reflection
API is to understand those structures at
runtime so for tools even for frameworks
to some degree we can interact with
these random representations we can ask
a certain package which module it
belongs to we can introspect the
boundaries of a module so there's a
formal representation of the structure
of your deployment layout that the JVM
and frameworks and tools that run on the
JVM can use there's this notion of the
module the script is not actually
strictly necessary
so a HR file deployed to the module path
should have a module descriptor
alternatively it can be an automatic
module which is basically a regular Java
file adhering to D constraints so no
split packages no cycles
but otherwise not having extra metadata
with it and of course a regular Java
file adhering to conventions is great
this is exactly what Springfield is
doing in order to remain Java it
compatible so what we do in Spring
Framework 5 basically falls right into
this perspective if you choose to use
the module system in Java 9 in your
application layout spring is ready to be
consumed in such a scenario you may
choose to for example have a kind of
database layer module of yours and you
may say requires spring JDBC to formally
express a relationship to the spring
JDBC module which is it is essentially
just the spring JDBC char as you get it
from maven central with a little bit of
extra metadata we ship an automatic
module name entry so that the JVM in
module path mode has a well-defined
module name assigned with each of the
Java files this is just a manifest entry
otherwise we export all our packages as
we always did and we we get random
resolution of our inter dependencies
from the JVM so spring JDBC
automatically sees spring TX and spring
cor for example you don't have to
express this anywhere
the usage model is perfectly fine and
that's essentially what we're focused on
you should be able to do this if you
choose to use the module system in your
application projects and layers of
Spring Framework 5 this is reliably
possible in Spring Framework for the 3
it's also possible to you if you don't
renamed a Java file so you can have the
same experience so Spring Framework for
the 3 is technically usable in the
module system but it's not actually
first-class support there quite yet
the dis little syntax that you're seeing
here is the module info file it's
basically like package info module -
info put it into your Java file compile
it with Java C with a Java compiler as
usual it's a little language that allows
you to express this is a module module
named dependencies and exports we don't
actually ship such module descriptors in
the spring frame of jars to reiterate
that point all we do is that we have a
menu
entry for a stable module name because
Java 9 comes with conventions for the
restaurant the module name needs to be
assigned somewhere it can be derived
from the cha file but if you want a
stable named as a manifest entry for it
Rick requires dependencies can be
resolved automatically at runtime if you
want them to and if you want to export
everything then that's the convention by
default write tests and that is the
reason why we don't chip module
descriptors for Java 8 compatibility for
allowing the framework to remain a
buildable on Java 8 this is a great
design that they did in Java 9 and there
were a few cycles involved here so we
have been involved in the late stages of
the jigsaw designed before JDK 9 went
live so we we wanted the conventions to
match what we are doing here
so we had quite some interaction with
the JDK team and kudos to them for being
being lenient with those conventions
that so that we can use them from a Java
8 based framework it's a little bit like
what they did back in Java 8 with lambda
expressions and functionally interfaces
by convention this is kind of the same
line of thinking allowing easier
migration for existing frameworks and
libraries all right is a specific notion
to wrap this up a specific notion that
is worth exploring a little bit because
it's often misunderstood the idea of a
module concealing internals can be
relevant for a framework like spring
right what if you want spring to create
certain implementation beans of yours
that are otherwise not part of of the
surface whatever you want spring to
create for you and took us to configure
for you needs to be visible right so you
have to export at least the entry points
at least the factory methods for your
implementation types if all you want
spring to do is to talk to public art
effects like public classes public
constructors public methods there's
nothing extra you have to do but if you
want add Auto Wyatt on non-public
constructors or non-public fields or a
number
methods you're going to learn quickly
that this isn't possible in jigsaw it's
possible in classpath mode but if you
run in module path mode you have to you
have to open your module accordingly
because modules are concealed by default
everything that's exported and public is
visible to the outside but only that
right no non exported classes in in
particular no non-public art effects of
the exported classes so for spring
purposes an application module does not
have to be open if all you want to do is
talk to public artifacts public
instructors and public classes for
example spring can happily do this for
you
without any extra declarations if you
want spring to see internals non-public
artifacts of your class you have to
export certain packages as open or the
entire module is open all the packages
in the module is open if you're trying
this you'll learn quickly that it's not
spring that you're opening it for it
will be the data binding libraries
hibernate checksum these are the typical
candidates that kind of force you to
open your module but usually not Springs
configuration purposes in any case
there's a solution for this right the
open keyword is a first-class feature in
the jigsaw module system alright so we
already are at the end of this little
tour just a few recommendations and a
little bit of a summary if you want to
upgrade I strongly recommend
familiarizing yourself with Java 9 and
higher I mean at this point take Java 10
release candidate or wait 2 weeks and
take jdk 10g a we are getting a new
chile Carolis every half you know right
so 9 over 10 or 11 whatever the latest
is familiarize yourself with it do the
smoke test run an existing integration
test of yours were just a existing setup
of yours on the latest JDK and see
whether it works you've got a strong
chance of that simply working for spring
based applications on the JVM class path
even when you're using hibernate even
when you use
in Jackson this is a high chance of
working because all of those libraries
have been upgraded to some degree and
run fine on Java 9 and higher at least
in class path mode there's some
enforcement in module in the module path
setup that may break some existing
libraries for example the neti
networking library and or groovy are
still not perfectly usable on the module
path but they are usable on the Java 9
class path so consider staying on the
class path basically take your existing
setup Java 8 paste and just run it on
Java 9 10 or 11 consider even staying at
the Java bytecode level which basically
means keep compiling with target 1 8
this significantly reduces the pain that
you're being exposed to because many
existing frameworks and bytecode
processing libraries and bytecode
processing tools need to understand the
bytecode level and the the JDK 9 or 10
or 11 by code level might be new to them
right and actually 9 has a new packet
level 10 has an even newer one and 11
will get yet another revision so you'll
have that problem every half year if you
just keep compiling with target 1/8 you
can use all of the infrastructure in
Java 9 you can even use some of the new
API is in Java 9 you cannot use any of
the language constructs in Java 9 which
is not usually a huge issue unless you
want to do modules right so keep
compiling with target 1 8 deploy to the
class path and you might be a happy user
of the new JD k9 improved runtime the
random infrastructure with a Java 8
based project just deploy to JDK 1900
right so just the dates here this is a
quite unusual in the area for us in the
Java ecosystem 9 is basically already
end-of-life thing will be end-of-life in
two weeks bye bye JDK 9 hello JDK 10 but
JDK 10 will be end-of-life in September
in half a year
so if you want to give it a try to it
quickly otherwise you're already in
place to give JDK 11 a try
most importantly JDK 11 will be a
long-term support release it's a little
unclear what exactly that means from
Oracle's perspective it it at the very
least means you will be able to buy a
support contract from Oracle for it
providing you with maintenance releases
until 2025 whether in how long some of
those maintenance releases will be
publicly available to the community is
yet to be determined the community is
kind of expected to upgrade to JDK every
half year right in Spring Framework
setup we're currently in a position
where the framework itself is job aid
based it also still builds on Java it
all the tests run on Java 8 if you just
switch Java home to 9 or 10 and rerun
the Spring Framework build as you get it
from github it will still execute build
and/or run all the integration tests so
the build actually works across those
three chilly case and in all likelihood
it will also work on JDK 11 even without
any extra measures we had a few measures
in place within the framework making it
easier to run on new adjudicate
generations most importantly if you are
courageous enough daring enough to give
the new bytecode level a try right so
for example use the Java 10 bytecode
level because you want to give vard of
our keyboard a try that works fine with
spring because we have some measures in
place that leniently accept new bytecode
levels you might have a much harder time
with the hibernates of this world and
other libraries with different bike
regeneration divers in place but from
springs perspective all that we can do
is we want to put ourselves into a
position where existing spring firm
equations like spring from 5 4 4 5 4 5
can be used in jdk 10 and 11 even with
the newest bytecode levels without any
extra measures so we are kind of
anticipating use of existing frame
equations on newer jdk generations
already we are not going to ask you to
upgrade to 5.1 just for that purpose all
right so much for this little or
actually quite extensive story so in
many ways Spring Framework 5 is our Java
8 embracing ver
deep embracing release and a lot of the
goodness and many of the things that you
will find yourself
hopefully appreciating in practice
actually comes out of this JDK 8
baseline as a bonus you can choose to
run it on JDK 9 it and try to embrace
JDK 9 over 10 or 11-hour I would only
recommend doing this here for new
language which is a new API if you have
a clear and strong need to do it
otherwise consider the the arrangement
of compiled against JDK 8 deploy to 9 10
or 11 you might have a quite fine
experience with this and get lots of
runtime benefits out of it right and
there are a couple of things that we
only touched upon in the course of this
presentation there's plenty of content
to be found through Google and YouTube
if you are more deeply interested in to
the reactor reactive story on Spring
Framework 5 or the coupling story there
are dedicated presentations from some of
my colleagues all available on YouTube
if you're interested so there's many
other story lines in spring filmic fact
that we only touched upon that may may
be worth exploring on their own right
alright then thanks for your attention
if there are any questions I'm happy to
take them just come up to the stage or
catch me catch me out there we're also
very easily reachable if anything comes
up after the fact here just get in touch
with us on the blog on github wherever
we are in in a stage with spring filmic
5 where we are very very interested in
how it goes with the practical expose it
go with the practical experience at
right how does it feel like when you're
actually trying to put it into
production if you're trying to use it in
anger for solving particular problems so
by all means let us know and enjoy the
rest of the show there's a closing
keynote following thanks
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>