<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Next Generation Asynchronous Patterns in JavaScript by Jonathan Mills | Coder Coacher - Coaching Coders</title><meta content="Next Generation Asynchronous Patterns in JavaScript by Jonathan Mills - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Next Generation Asynchronous Patterns in JavaScript by Jonathan Mills</b></h2><h5 class="post__date">2017-11-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/p5eEl-e_sFY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so how's DevOps so far we're a
couple days in alright so it's going
okay
apparently I see a lot of people not a
lot of noise though I'm gonna warn you I
ask questions okay so real quick just so
I have a sense of the room I have some
assumptions but I want to make sure so
who in the room would classify
themselves as a Java developer that's
about what I expected
so most dinette developers in the room a
couple we've got three four okay boots
so how many of you are JavaScript
developers alright and I like this so
you're good you're good group because
most people who classify themselves as a
dot another Java developer don't raise
their hand for the JavaScript side cuz
you know Java scripts this other thing
that we do so but we we have to write
code in JavaScript and so okay one more
two more questions one more set of
questions angular developers reacts
developers okay that's not bad view any
view oh I like it that number gets more
and more every time I ask I II do react
right now I've done angular and
angularjs only angular 2 and they're all
the way up to five already
okay so next-gen acing patterns in
JavaScript it's my name is John Mills I
am from here
more specifically like right there smack
dab in the middle of the United States
so thank you for letting me come and
talk to you we went to Bruges a little
bit yesterday afternoon
absolutely yeah nice that was my
response
absolutely gorgeous alright so let's get
started
javascript unlike
Danette or java or some other language
is by design a single-threaded language
we're not web workers yes I know but
we're single threaded and that's that's
ultimately the point so the struggle
that comes with being a single threaded
language is that when you make a call I
assume most of us in the room writes
call API calls
we don't necessarily I think for this
room we don't necessarily do a lot of
file i/o but we at least do a lot of API
calls
so that's long-running right and so we
can't block the thread how many of you
have ever seen a web page where you
click a button and it just sits in spins
right because it's it's making a
long-running call that's is blocking the
single thread that is available to us
and so what what Java Script does to get
around this is they have this thing
called the event loop how many of you
have heard of the event loop before I'm
not gonna talk about it a lot I'm just
going to show you a picture of it that's
it so the event loop ultimately is we've
got the stack that's all of our calls
that we're making and then when we call
out to an API of some sort don't think
API like our back-end server just think
an API like a JavaScript API it drops
things in this queue
the callback queue and when the stack
empties the little event loop pulls the
next thing off the queue and drops it in
the stack and then it executes sit and
so the way this works it's even called
the callback queue right away you can
see where these callbacks right so
callbacks are one of these things that
we just do because we don't even think
about it anymore in JavaScript right you
just write a little anonymous function
you drop it in there and they're kind of
cool they look like this so I make a
request out to a URL of some sort and
then I create a function that gets
called when everything comes back right
so that's my callbacks there I go
however it's not usually this easy in
this guy
so I just created a little callback
function and now I just have request
book your alcohol by but how many of you
write code that looks like this ever
like is it this easy ever even one time
almost never because we have to do
things with the code that comes back so
in this example I created a little react
application that makes two calls so it
makes one call to to get a book so I'm
gonna get a book and all the details are
on that book
it makes a second call that has to go
get all the related books I can't go get
the related books until I've gotten the
books I have to wait and I have to do
things and so what we end up with is
code that looks like this we start to
nest call backs and we call this I call
this anyway Christmas tree code I don't
know if you've heard this phrase before
but you know because it kind of expands
out I guess we ignore the part that
comes back in but some people refer to
it as callback hell right because it's
just one call back after another after
another after another they become gross
name functions I like to do name
functions and we'll talk about name
functions here for just a little bit but
name functions don't really help that
much because I have a whole lot of stuff
that's then embedded in this function so
in this case if I wanted to name a
function get book and related stuff I
like my function names become gross so
oh wait it gets worse
I don't know if you've ever seen this
before this is real I didn't make this
up this is real this is Google search
trends for undefined is not a function
so somebody tell me when angular became
popular
you can tell it's right there where the
spike goes up and I I hate to tell you
this well I don't you know this already
because you probably contributed to this
graph the results aren't helpful at all
because it doesn't know I by virtue of
being undefined it does
know how to help right so we have eros
your your API sometimes returns errors
it just errors happen all over the place
so now we have to deal with errors in a
callback how do you deal with errors in
a callback you pass in a one function to
deal with success or no mmm the response
will pass one parameter with success one
parameter with error right I jumped
ahead of myself so we do this function
callback error looks now I have to check
error for everything right so I go from
this to that same same thing it's
literally the same code I just added if
statements and now it's gross well it's
kind of gross before but and I'm not
even error handling this doesn't work so
what they've tried to do in JavaScript
so es6 how many of you will use es6 code
okay es6 native promises we love
promises before that you could do
promises but we have promises now so
promises get us started they start to
get us to where we want to be they're
not all the way there but they get us
there basically what happens with the
callback is we have incoming and
outgoing things embedded in the same
function call right and we don't like
that we have input in tver and out
variables that it's just all kind of
gross so we don't like that what
promises do is they separate it so we
have a ven now attached so requests book
URL then we're gonna execute this
function it just pulls it apart great
there I am now using promises and it
didn't help that much right I mean so
promises that's obviously not all they
do but I have seen this a lot which is
funny because you go and you look at
somebody's code and they say hey yeah
we've made everything promises and now
there could looks worse
than it did before but they're using the
you know the cool new modern stuff okay
so what is the promise a promise is an
object it's just it's a thing so don't
think about it any other way it's an
object that handles some different
function costs that's all it does
so it's an object that that handles
resolution and rejection of a and API
call or some other thing and that's
literally the only thing it is we create
that just like return new so we new up a
promise whenever we're we're writing a
function and then we return a new
promise and what the promise does is it
takes a function that has resolved and
reject it executes that function you
resolve the promise to execute whatever
the then is because it's an object that
means I can now pass it around so here
I've got my request request and my dot
then and dot that this line right here
what is request return request returns a
promise excellent
so if but a promise is just a thing
right so I can take that thing and I can
move it around I can hand it to other
people I can pass it around so I can
actually return that promise instead of
having my dot then right there I can
return that promise and chain my debts
now it starts to look a little bit nicer
right so I request the book URL then I
execute a function then I execute
another function we're getting there not
quite but we're getting there
I like this with named functions that
right there you don't have to care about
any of the rest of it but because I'm
returning promises now I went from this
big page of horrible ugly code to this
request book URL then I'm going to get
my related stuff then I'm going to
process my list that is very easy to
read
except we're forgetting one thing right
but first let's I told you we'd do
something real so this is calling my
local API with fetch so so fetch is
built-in and reacts now if you do reacts
I'll do some angular stuff here in a
minute but fetch is basically just to
get an API then response so I just do a
get book and that goes and gets that top
section right here's another thing
promises does that's interesting notice
then response equals get related
response dot JSON that's kind of gross
it's not really gross but it's a little
gross I don't want to have to do code
related things what promises let me do
is just return anything I don't have to
return a promise from inside of then I
can return anything so this is a little
arrow function that I snuck in there
that just says I'm gonna pass response
and I'm gonna return response dot JSON
that's all I'm doing
it's all it does so I'm dropping this
little intermediate piece of code in
between my thenns to just clean it up a
little bit and then I'm just pulling the
book back I don't have to worry about
what JSON is or anything like that so it
just nicely wraps whatever I return in a
promise it doesn't even matter so you
start to clean things up even more
errors so yeah I can jumped ahead of
myself a little bit ago now you pass two
functions okay your success function and
your error function that way I don't
have all those nasty gross if statements
right so then success or error that used
to be the way we do it we don't really
do that anymore now we reject with an
error but now we just do a dot catch
Java developers instead of JavaScript
developers you get you get comfortable
when you get to catch things right
that's fuels more familiar to you
instead of having to do if errors
so now we just let you catch your errors
that's much better
so now we end up with this okay anybody
if you just walked in the room you
didn't see any examples you didn't see
anything you look at this code and you
immediately know what we're doing
calling a book URL we're getting related
books I could probably name that better
yes then I'm gonna process the list and
I'm gonna catch errors and I'm gonna
handle them somehow
this is promises promises are awesome
and you should be using them if you're
not too but I'm now done talking about
promises and I have 37 minutes left so
that's like that's not next-gen that's
current that's where we already are and
hopefully if you're not using promises
you should be getting there but I kind
of wanted to get you up to that point
now we're gonna go in two completely
different directions because there's two
different schools of thought on what
asynchronous pattern should look like
there's one school of thought that says
kind of like that last slide with
promises I need my code to look clean I
want it to look nice I want you to be
able to follow it easily I want it to be
very readable and we're gonna go this
way there's another group of people that
think promise that think async calls can
be much more powerful I can add a lot of
functionality I can add a lot of stuff
which makes my code much less readable
but much more powerful and they're gonna
go this way so I'm gonna I'm gonna go
this way for a second we're gonna talk
about some stuff and then I'm going to
come back and we're gonna go a
completely different direction over here
and we'll see how it works out
generators who uses generators in this
room if I get two hands I'll be
surprised I got like six all right I
love it I don't know how many of you put
your hand up after I said I'd be
surprised if I saw two but that's fine
generators are a new feature they they
were
for a period of time my favorite feature
in es6 and the reason they were my
favorite feature in es6 is because they
made things much much easier but since
only like six if you raise your hands
let's talk about generators for just a
second this is a generator function
notice there's a little star there some
of you may be cringing right now if you
use generators because you want the star
to be over next to the function name it
doesn't matter you can put it in either
place I prefer it there so a generator
function does this it yields values back
so so we have a concept of a function
that you make a call to the function the
function returns a value that's it
that's the end of the transaction we
don't do anything more generators break
this thing and now you hand something to
a function and it returns you multiple
things over a period of time completely
differently and so that's weird
but it becomes useful in just a second
so in this case I'm gonna call generator
it's gonna give me two things at two
different times it's gonna give me a
message and it's gonna give me the next
message so let's talk to you that how
that works
I executed by just executing the
generator function and then I go so in
this case I have a generator of our
caller equals gen it's executed nothing
in my generator has happened yet I've
got this big long generator the console
that log hasn't even executed yet I call
gen dot next and it's going to now
return something a whole bunch of stuff
happens one the console dialogue
executes and then it returns the message
but it stops right there at yield what's
what gets returned anybody what is the
console dot log message I actually
cheated because I now I've told you that
it's not quite right but what's what's
displayed in the console at this moment
who says message it's not but okay so
you get an object right so you have a
value of message and then I've done so
you get an object with the value and
whether or not you're done yet I am not
done yet because I have more yields I
haven't exited my function yet so that
it's gonna keep going I call next again
next message still not done even though
I'm at my last yield it's not done and
then I call it a third time and now it's
done but then I undefined
what makes generators become powerful
and this is how it'll tie into ASIC I
can return the message and then I can
pass things back in so notice here I've
got a yield what is your name and what
gets passed into the next becomes the
value of name so you have this two-way
conversation that can start to happen
and this might start to sound very cool
when you think about it from an
asynchronous perspective what if I could
call something and then just sit and
wait I'm not blocking we're not making a
blocking synchronous call everything
else around it will still execute but I
can call something and just sit and wait
for the response and then when that
generator function is ready it's gonna
pass me something I'm gonna keep going
that's what we want to do because it
kind of all lays out now we have
try-catch blocks around all of our ate
all of our generator code and that
becomes very cool as well okay now let's
do this there is a package called code
it's very popular on the node side but
I've seen people use it and use it and
react and angular that takes promises
and makes them into generators so think
about that for a second I now can take
anything that's a promise and create
something that does this whole yield
conversation thing so what that starts
to look like is this var book
equals yield such book URL
when book URL returns it's gonna assign
it to book then I'm gonna take whatever
getting back from book and I'm going to
yield this dot get related and now it's
related this codes easy to read it's
easy to follow I have no nesting 0
nesting at all I don't have all these
additional dot vens I don't have any of
this other stuff that just works exactly
like that this is great but I don't have
a slide on it but that's ok because it's
all synchronous I can wrap this in a
try-catch block that makes it even
better
so I can put a try-catch wrap my whole
asynchrony a P I calls that a try-catch
block if anything blows up I've got one
catch down at the bottom it catches
everything that's very cool but what
that gets us is to the point where we're
ready for async away he uses a single
way in the room I have a few the reason
why I said at the beginning the
generators were one of my favorite es6
they were one of my favorite es6 things
is because now I have a single weight
which basically replaces all of what all
the cool stuff that generators just wear
but some of you can't use async await
yet so you can always use the generator
stuff async await basically does this we
had this return fetch we have then we
have then we have all of this stuff
async away which is available right now
you could be using it does this I create
an async function called get book I
await fetch
I await related I return related now
even if we call it awake and async it's
still non-blocking right so everything
inside get books halts execution but
everything else around it still executes
so this becomes very very simple and
very easy very easy to read at all
does that make sense
this this is the easy stuff right this
gets us almost to code like we would see
on the backend on the on Java not quite
sore net where I just have I write code
and I don't worry about it it just works
and I can read it I don't have the
nesting everything's great
that's the first half this is the easy
side we're gonna go the other way now
and we're going to talk about
observables how many of you've heard
this phrase observables before okay
observables come from the concept of the
observer pattern Gang of Four design
patterns in the room if you're
interested I have a gang of four I
design patterns for JavaScript course
out on Pluralsight I don't know who uses
Pluralsight but um which is fun but the
observer pattern basically looks like
this it allows the collection of objects
or an object to watch in objects and
then have something happen when it
returns that's the whole point of an
observer pattern I'm gonna watch you and
when something happens on you I'm gonna
do something it looks like this right so
I can pull everything apart I don't have
to have like tight coupling I can just
say hey call something when you're ready
right one object is our focal point and
we just watch for changes so let's say I
have a task task is just an object it's
gonna sit there and things are gonna
change on task and then I have a bunch
of stuff that needs to know how many of
you ever have to write logging in your
systems right or you have to write
notification systems or anything else
and you want to know when something
changes in tasks so the logging systems
looking at tasks and just as hey
whenever anything changes I want to I
want to execute well the way this works
is that I have a so my list observers
tasks once you get to implementation
like all the magic goes away task has
just a list of people who are observing
like it sounds really cool but then it's
it's an array and a function call right
that's really all an observer is so I
have a list of people who are observing
this task and when something happens it
executes whatever function that thing
passed in or back to callbacks and I
didn't tell you this earlier
we never get away from callbacks like
those functions even though we talked
about they're always gonna be there so
when it's ready it calls and lets us
know what if we did this in async think
about this for a second I have an object
and I just say hey whenever you're done
just call this thing and then I don't
have to worry about it that sounds
remarkably like what we've all been
doing yeah just what we've been doing
all along right let's walk that's a
callback that's the whole thing so now
I've I've gone from all this cool stuff
and we're now we're back over here
actually I was going the other way we're
back over here - I just have callbacks
again right call this thing when you're
done rxjs is the implementation that we
use most of the time is not always but
most of the time when we do observables
who uses rxjs okay good
and you should are saying s does all
this stuff for us so we don't have the
callback Christmas tree grouse nests and
all that so our chance deals with all of
us and so basically what it does is it
creates an observable just the observer
pattern it creates this thing that gets
watched and then it deals with
everything for us so this that HTTP that
gets is how you would do it in our chef
I'm making my API call now I have this
thing called an observable and argyus is
smart because not
thing happens here because think about
it what if I I want to make an API call
but nobody cares what the result is
should I make the call no that doesn't
even make sense right so rxjs pays
attention and says guess what
nothing's looking so I'm not gonna do
anything yet
the magic starts to happen when we
subscribe so when we say hey pay
attention to this so why when I
subscribe rxjs goes out and starts doing
all the stuff and it goes and it calls
cause the HTTP call when that HTTP call
comes back it calls the function the
callback I'm sorry that's what it is
calls the callback and you can do
whatever you want with it what becomes
very cool is when we're dealing with
errors because we always have errors
right now I just have my dot subscribe
and I pass in two functions this is just
like what we had back with promises
right so I have here's my data function
here's my error function and this is the
way we're gonna work and so when does
air get called either when I get a 500
from an API or I guess whatever or
something back from my API RHS what
becomes cool about it and because I said
there's power right we were giving up
the simplicity that async away had for
the power that we would get over here or
what rxjs does is it handles failures
for us we can do things like retry so if
something fails I can retry it we can go
again let's see what happens a
subscription is just an object right
that's all it is so I when I do my get
with my retry on my subscriber returns
and objects and I can do things I can
manipulate this object in multiple ways
the first one being I can unsubscribe
well have
if I unsubscribe from something if it
hasn't made the call yet is anybody
watching no RGS is one do anything I say
never mind I don't want this anymore
it's been too long just forget it
we'll move on um so we're not done
that's a misleading slide I'm gonna haul
tab and I'm gonna show you some stuff
okay everybody good read this it's a
huge screen so I'm not gonna worry too
much about making everything bigger okay
so here what we have here is this is a
angular 2 because it's a little older
don't hold it against me
application that basically all it does
is it makes the API call it subscribes
and then what you see here when i
refresh is that right here it makes a
call to zero and it gets some stuff let
me introduce you to the other part of
this this is an Express just an Express
server that when I'd ever I do or router
get to an ID I just return that book so
this is what it looks like
this is rxjs very simple very easy no
issues right up until we have an error
right so if I come back over here and
instead of that I create an error I know
after one second I'm gonna send a 500
error that's all that line of code does
right if at any point in this demo
things don't work you have to remind me
it's your job remind me that on the node
side unlike on the angular 2 side I have
to restart my server
so if I tab and it doesn't work just
somebody yell restart your server so now
what happens if i refresh you will see a
500 error right oh now I clicked on it
you will see a 500 error pop-up right
there
aired that's bad and in my console I'm
not doing much with it but in my console
you see right here I have error and then
my response object just so you can see
it and that's coming from this line of
code right here right execute that error
what happens if I do this what's it
gonna do how many times is it gonna call
three times
anybody say three I have to a couple
people who are neglecting to yell as
loud as they could because I'm really
far away I don't know if you guys like
this is a long way um okay so it's going
let's run it and we'll see what happens
I have to save go to Network I'm gonna
run this and you'll see there's my first
one error error error error four times
it called it the first time and there's
a hey I got an error I can retry this
thing three times and eventually it may
work we moved with a 500 error that
doesn't necessarily make a lot of sense
but you could have timing issues or you
know you have race conditions you could
just say hey if this thing fails just
try it again and we'll see an Rx yes
just kind of does it for us what happens
when I unsubscribe though I'm not gonna
I'll take the retry out what's gonna
happen if I unsubscribe just
completely unsubscribe it's gonna cancel
the request that's absolutely right so
let's try this I'm just gonna
unsubscribe right away okay so it's
gonna cancel the request let me ask you
this how many requests is it going to
make well I took the retry out so your
options are really zero or one ah
right because I don't know it should
really make one even though it looks
like I'm keen I'm unsubscribing right
away like I should get in before it
makes the call it actually does go ahead
and make the call but here's what's
interesting so if i refresh you'll see I
get to my zero and I get cancelled I
didn't get my 500 error back
I just got cancelled let's look at this
on the other side because that becomes
weird I'm gonna take my unsubscribe out
and I'm gonna go to my server there
you'll see my call and my 500 if I come
back over here I refresh there's my call
a my 500 error so I am serving back 500s
now you said it's going to cancel the
request so what that means is it
actually will send to the server a
cancel it says nevermind I don't need
this anymore
and so what that looks like is if I come
back in here and I'd put my unsubscribe
back in
look at what happened I didn't send a
500 back just in case you don't believe
me I'm gonna refresh I don't send a 500
back it actually physically cancels the
requests on the server it sends it now
in this case this is Express and I don't
know anybody any node Express developers
okay
Express just handles this for me on its
own doesn't matter and that that becomes
very cool because I don't need to worry
about it the problem is I'm still
executing code like right I'm sending
here I'm sending res dot send status 500
I'm sending the error message back but
Express just says no you're not I don't
care it doesn't matter right so what we
can do is actually just say hey I'm
gonna can't on clothes when if that
connection is closed just never mind I'm
gonna I can clean up I can halt
long-running execution I can do whatever
I want and now if I cancel this and
start over and I make my request again
you'll actually see canceled like it
knows hey you're canceled so I can put
hooks in here on my API that says look
they don't need this anymore
let's just stop execution let me show
you one more thing
with this what if I unsubscribe later so
in this case after two seconds I'm gonna
unsubscribe I've got it for in order for
that to make sense at all I have to put
the retry back in because I don't I
don't know that I'm cancelling right
away right I'm gonna wait a while and
we're gonna see what happens and then
eventually I'm gonna unsubscribe and
just go
so when I do this what you're going to
see here is you'll actually see a zero
and a 500 come back a zero and a
cancelled so it allows that call to go
through but then I'll come back and I'll
cancel later on which is cool because on
the back end you kind of see that same
thing
well we clear that I'll run it again and
then I'll kind of show you here we get
our 500
oh and then the second one was canceled
notice it on close only execute if it's
if it's hard cancel so this is rxjs not
this this is Express this is rxjs and
rxjs is powerful it gives you cancelable
api calls
gives you retry ability it gives you all
of these things the code is not notice I
didn't make it I didn't add another
subscribe for the second call and all
these other things because it becomes
kind of gross and I wanted to be able to
focus right so I'm giving up the beauty
the beauty the cleanliness of
async/await for the power that is rxjs
and you kind of have to pick the piece
that you want and go with the thing that
makes most sense for what you have and
that's kind of how we're gonna close out
we're going to close out this way so
we've come a long way from callbacks
right I mean so rxjs and async await
async await is within the lasts it's
been ready just within the last year
right I mean it's gone through the
process and it's been around for awhile
but but it's been available for us to
use really only within the last year and
promises have only come around really in
the SPAC approved since 2016 right so
those of us who have been writing
JavaScript for way longer than that
remember the jQuery days right and we've
come a long way
in a sink from pure callbacks all the
way to async/await or rxjs however think
about it this way these are just tools
in your toolbox right it's not hey I
always do rxjs or I always do promises
or I always do a sink away you're once
you know what all of the options are and
you kind of see them laid out it's when
you get to a specific problem that
you're trying to solve hey I have all of
this buried stuff and it's gross and I
can't read my code they sink away starts
to make sense or hey I have this API
that fails randomly and I just need to
try it again
or I need to I have long-running stuff
that I need to cancel now rxjs makes
sense all right you have to pick the
tool that makes the most sense for the
thing that you're doing right now
don't pick just one sometimes you go
with all of them or you go with none of
them you know whatever makes sense for
you use the right one for your situation
all right so I have some time left for
questions I'm not gonna hold everybody
hostage for questions so if you have
questions come down and chat with me I
left a little bit of time otherwise
thank you guys very much
have a great rest of the box</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>