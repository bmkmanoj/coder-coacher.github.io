<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Moving Java Forward Faster by Mark Reinhold &amp; Brian Goetz | Coder Coacher - Coaching Coders</title><meta content="Moving Java Forward Faster by Mark Reinhold &amp; Brian Goetz - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Moving Java Forward Faster by Mark Reinhold &amp; Brian Goetz</b></h2><h5 class="post__date">2017-11-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/x7pkWlost64" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">let's talk about moving Java forward
faster first let's talk about where we
are right now as you might have heard
Java 9 is here which means that yes job
9 Julie here which means that jigsaw is
here which means that the modular
platform is here which means that a
whole bunch of other features almost 100
other features besides jigsaw are here
there they're large they're small having
done all this really happy that it's out
there you might be wondering what's next
well hopefully one thing that is next is
adoption by the entire Java ecosystem
question how many folks have tried out
Java 9 excellent if you're in the
overflow room raise your hand even
higher how many are using Java 9 in
production today ok we've got some work
to do now I understand there may be a
little bit of trepidation about adopting
this release about migrating existing
production systems to it you might have
heard in particular that Java 9 breaks
everything that's not true what is true
is it breaks some things sometimes in
order to make progress in order to make
an omelet you need to break a few eggs
but one of Jabez core values is
compatibility we took that very
seriously in the entire Java 9 project
not just jigsaw there's one reason why
it why it took a fair bit of time I
won't go into all the details here but I
just do want to note that many things do
work you don't have to take my word for
it
just after Java 9 was released I asked a
question on Twitter do you maintain a
popular Java library framework or tool
if it works fine on JDK 9 then please
reply with its name and version thank
you to everyone who replied here's a
summary of the replies it's not
exhaustive but it's a it's a highlight
list all of these tools and components
and more work fine on JDK 9 actually
work fine
JDK nine when it was released some of
them worked without change some of them
required modest change by their
maintainer xin in order to adjust to the
to some of the restrictions in nine
there's a lot of important stuff on the
list the major I des ant maven and
Gradle J unit-tests ng popular libraries
byte buddy Jackson log4j hibernate Juke
Neddy the entire spring framework they
all work on Java 9 so if you're running
on 9 if you're trying out 9 if you're
hopefully thinking about putting 9 in
production be sure to upgrade the latest
versions of your tools and dependencies
ok so it's time to adopt 9 but really
there has to be something after that
what's next to understand more about the
future let's take a brief look at the
past for 20 years now
Java SC and the JDK have advanced in
large irregular ends to be honest
somewhat and unpredictable steps each
release has been driven by one or a few
big features and the schedule of each
released has been adjusted as needed
sometimes more than once in order to
accommodate the development and testing
of those features so this is good for
big features but it's not so good for
smaller features because even if they're
done that means they have to wait so
over the last couple of decades we've
had releases that are grand and majestic
but rather slow-moving for Java to
remain competitive in this day and age
it must not just continue to move
forward it must move forward faster and
that's why we're switching to a rapid
cadence of shipping a feature release
every six months like clockwork on a
strict time-based schedule let's try to
visualize this here's a timeline we just
shipped Java 9 late 2017 September to be
precise we're gonna do a new feature
release every six months so the next one
will be in early 2018 we're gonna do it
in March February would actually be
arithmetic ly correct but it's doing
something right after the holidays is
generally a bad idea so it'll be in
March
the release after that will be a year
after nine it'll be in September 2018
and so on all the way down every six
months new feature release these feature
releases can contain any kind to feature
they contain it can contain a big new
feature that containers can contain a
small feature they can remove old
features that were deprecated for
removal in an earlier release the
important thing is that features only go
in when they're nearly finished because
on a six-month cycle we don't have time
to back things out we don't have time to
do major repairs on something that went
poorly and if a feature is almost ready
but it misses the current release well
it's no big deal because the next
release is just six months later in the
context of the open JDK open JDK
community the proposal is to support
each of these feature releases until at
least the next one so if you're a
developer on the bleeding edge you're
using these releases in say a cloud
deployment or packaged up packaged up in
an app you take one you test it you
package your that package it up with
your app and you go and you're always
covered but you do need to advance to
the next one when it's available so that
that's okay for developers on the on the
bleeding edge of course more
conservative organizations enterprise
type companies do want longer term
support so the plan is to offer a long
term support release every three years
the first one of those will be in late
2018 September 2018 that will be
supported for at least three years and
the next one will be three years after
that in September of 2021 an important
observation about this slide is that
nine itself is not a long term support
release if you if this were to go
further back eight would be considered a
long term support release now there is
the question of well what should we call
these in particular what should the
version numbers be when I first made
this this big proposal a couple of
months ago I suggested that we use a
year dot month scheme so the March
release would be 18.3 the September
release next year would be 18.9 and so
on and so forth if you've familiar with
the Ubuntu Linux distribution the
you know this this looks reasonably
familiar there's a lot of feedback on
this some of it was constructed some of
it was inflammatory some of it made
sense some of it didn't but in the end I
kind of agreed yeah that idea we're not
going to do that so instead instead the
current proposal is we're just going to
do the logical thing but the March
release will be 10 September will be 11
and we'll just increment that number
every six months it doesn't matter how
much stuff is in a release it's still
going to be incremented every six months
okay so that's the plan for openjdk
those of us who work at Oracle are also
going to make some changes first change
is we're going to ship gpl-licensed open
JDK builds built only from open JDK
source code we've already done this with
9ga for linux x64 works that we're still
working on the builds for for a couple
of other platforms another thing we're
going to do is we're going to open
source the commercial features that have
been in the Oracle JDK for many years
there's always been this difference
between open JDK builds and Oracle JDK
builds there there are some interesting
features in the in the commercial
versions we're going to open source the
ones that make sense to open source and
eventually work towards having these
builds II interchangeable so this
includes open sourcing features such as
application class data sharing Java
flight recorder Java Mission Control and
the said garbage collector another
change we're going to make is we're
gonna focus mainly on Linux Mac OS and
windows on x64
and look to other contributors an open
JDK to maintain of their ports and
finally we're going to work in the open
JDK community to establish an open build
and test system so that anyone can do
the rigorous kinds of testing that are
needed to ship a quality product now as
with any kind of enormous change there
are lots of worries and there's some
confusion and and we we get that I get
that so I'd like to to take a moment to
discuss the top 5 misconceptions about
the new release model number one non LTS
releases are experimental they're just
they're just a fancy name for a beta
know the only difference between an LTS
feature release and an on LTS feature
release is that the LTS release has a
longer support timeline
number two every feature release will be
as disruptive as past feature releases
nope that's not true the overall rate of
intimated innovation over time doesn't
change what changes is the rate of
innovation delivery and if you end since
innovation is roughly roughly
corresponds to disruption that follows
number three to remove an old feature
requires three years of demands notice
no I don't think that's that's a great
idea to remove a deprecated feature
should require a production ready build
but the issue is a suitable warning
ahead of time so you can test it right a
working build is kind of the ultimate
release note for the future number four
if you maintain an infrequently migrated
system then you can just ignore the non
LTS releases that would not be the best
plan if you test with each feature
release as it comes out then by the time
the next LTS releases available you'll
be almost ready
so follow along even if you're not
deploying that the non LTS releases in
production number five there will never
be more than two updates for any non LTS
release and there will never be more
than three years of support for any LTS
release no well it all depends on who
shows up in the open JDK community you
know for for all I know people could
show up we could we could wind up with
twenty years of support on every feature
release unlikely but theoretically
possible so we've got this new release
model features go in only when they're
ready
that means relatively more development
has to happen outside and to feed all
that we need a pipeline of features in
development all the time fortunately
we've been investing in that for quite a
while now in the open JDK community here
are just a few few of them project
Panama looking at foreign function
interface and better control of data
data layout layout Partrick project
Valhalla looking into specialized
generics and value types which we've
discussed here before project Amber is
about right sizing language ceremony
project loom continuations and fibers
for the java virtual machine at last to
help us learn a bit more about one of
these namely project amber please
welcome Brian gets
hey Mark hey Brian
so what do you mean exactly by by
right-sizing language features well so
you know you may have noticed people
have told us as a few times that Java
tends to be a little bit verbose at very
at various times and so you know people
are complaining for years and we've been
you know ignoring some of those
complaints and listening to others and
you know the more rapid cadence has
really give us an opportunity to roll
out features that are focused more on
addressing the pain points that
developers experience every day mm-hmm
so say so one of the amber sub projects
is local variable type inference can you
tell us more about that yeah yeah so you
know this is probably the most
frequently requested feature that we get
and and you know it's something you've
seen in other languages c-sharp C++
Scala and it's simply extending that
it's simply extending the type inference
that we already do and been doing for
years to a broader contact which is to
say local variables now type inference
is simply the compiler figuring out the
type of a variable based on information
that's already present in the program
right think you have an example here
yeah yeah we have an example so you know
this is some typical Java code I and you
know when we declare a variable you
declare the type and then you say the
name and then you sign something but the
actual most important thing in you know
in this bit of code is not the tie if
you even though that's what come first
but the name because that talks about
what is this per variable mean in this
program so if you let the compiler
figure out these types for you the it
brings this more important information
sort of front and center into you know
into the thing that you see first and I
I think if you've chosen your variable
names correctly like we always do right
mmm it makes the code a little bit more
readable so I'm seeing so you know this
is this is a feature it really doesn't
look like a big deal especially if
you've seen in other languages there's
actually an awful lot of complexity
under the hood that made it a bigger
deal to implement and specify than it
would have been but from the user
perspective it's just letting the
compiler figure out something that is
already present from information in your
program but just to be clear this is not
dynamic typing no no it's not isn't off
job script isn't it's strong static
typing it's the same typing that that
you that you've always done except that
the compiler has figured that for you
and you haven't had to write
okay and when can we have it uh you can
have it now it's already checked in I'm
in the Java ten repositories was checked
in a few months ago and it will be
shipping in Java 10 in March here in
fact it's the commit message nice like
September from Maurizio yeah there it is
so you can play with it yeah you can you
can go you know build out of the
download the EA EA builds now and I
tried out and there's even IntelliJ
support right and and also supported a
show yes excellent okay so what else is
going on an amber so there's actually
quite a lot going on an amber that
that's sort of you know a local variable
type inference is sort of the candy
feature uh but but there's actually a
lot more there's not spinach but but
something a lot a lot deeper so the the
one that I want to talk about today and
I'll just be able to scratch the surface
here today you should come to the talk
on Friday where I'll be able to go into
a little bit more depth is pattern
matching so pattern matching is a
feature that people traditionally
associate with functional languages but
it's actually a very good fit for
object-oriented languages as well and
we've seen other languages languages
experimenting with it before and so sort
of to motivate why we we did this I'll
show a few examples of code that we have
to write today that are uglier than
necessary and then I'll show you what
they look like with that imagine okay
alright so here's an example of typical
code that you write where you have to
you know you have an object you don't
know what the type of it is if it's
gonna if it's a string you're gonna do
one thing if tonight you're going to do
another and so how do we do this well of
course instance of are you an integer if
so cast an integer then do something
integer like are you a bite if so cast
do it by etc so on the one hand you know
we write code like this all the time and
this is probably the best we can do with
the tool we have now but on the other
hand this code really is terrible and
it's terrible in like many ways it's
repetitive which is annoying to write
but more importantly repetitive code is
error prone because repetition gives
bugs a place to hide it's it's harder to
read because all of the repetition
obfuscates the you know obfuscates the
business logic and as a bonus we know
we'd like it's slow right we would like
to you know logically write this code as
a switch but we end up having to write
it as a linear sequence of if-else you
know test so you know verbose error
opponent and slow what more could you
spell yeah what more could you asked for
it's really a trifecta
right so if if we you know if we we
wanted to write a write this as a switch
but we can because the switch statement
is very limited you can only switch on
certain types you can only compare
against constants but there's a nice
generalization of switch that sort of
been lurking under the surface and that
is you you know I using switch as
extending the switch labels to be
patterns so we have an example of this
the the case labels here where I say
case into dry this is a type test
pattern what this means is a pattern
combines and applicability test with a
conditional extraction of state if the
test succeeds so in this example type
these are type test patterns which are a
simple kind of pattern you're saying are
you an integer if so cast to an integer
and then bind the result of that to a
fresh local variable which we'll call I
and so this is the same code as before
but we fused the instance of cast and
binding into one operation and we
already see the code is getting more
readable we've removed a lot of the
boilerplate it starts to become more
clear actually what's going on we've
eliminated the repetition some of the
repetitions so that makes the code less
error-prone but you notice that there's
also still a lot of repetition left in
this in this program we're assigning to
a local in every in every arm of the
switch we could forget to do that that
would you know that would be an error
maybe our test wouldn't catch that
that's unfortunate really we would like
to turn this into an expression so let's
try that so if we if we write it this
way we can easily turn switch into an
expression and this looks a lot like the
you know the previous example except
without the roundabout assigned
something to a local and then use the
local afterwards just the result of the
switch expression is the thing on the
right hand side of exactly one of these
things now it seems like this could be
generalized even more yeah this is a
really simple example any pattern
matching is something we can go really
deep with and obviously it's gonna take
some time to get there
but I'll give you a little taste of
where we're going and then like I said
if you want to see me unpack the example
come to the talk on Friday so I you know
if you have a hierarchy of types like we
have a shape type here and a shape could
be a circle or a square or a rectangle
and a circle has a center the radius and
you you know your hands in a shape you
have to do essentially the thing that we
did before either test it with instance
of or
more likely when you start when things
start to get more sophisticated you end
up with visitor and visitor is awful
right again it's the best we've got but
it's it's awful right so pattern
matching lets us get rid of all of that
and so if we wanted to write a method to
compute the area of a shape and we know
a shape is either gonna be a circle
square or rectangle what we would like
to do is unpack the state of these
things and be able to just use these in
expressions like the area of a circle is
PI R squared so let's take a look at
what this looks like now this doesn't
look like typical Java code so it takes
a little bit of time to get used to but
basically what this is saying is I take
my shape are you a circle if so cast it
to a circle extract these components of
a circle the center and radius bind them
to local variables which I can then use
an expression and the the area of that
circle is PI R squared similarly the
area of the rectangle we extract out the
lower left and the upper right and we
compute Delta X multiplied by Delta Y we
have the we have the area of the
rectangle right so some of these
featured features are going very deep
how are you going to deliver them yeah
if it's only a six month release cycle
yeah so the six monthly cycle actually
helps a lot here because we can deliver
these things in pieces and so we can
start with with the simple things like
what we just showed you with type test
patterns and we can go deeper and deeper
and deeper and so there's a pretty rich
pipeline of things that we can deliver
over the next many releases you know I
said we won't get to this all in in one
go but we will get there over time okay
great thank you Brian yep thank you
barking so as Brian indicated project
amber is just one of many things in the
future pipeline examples of long term
investments that everyone in the open
JDK community is making in the platform
so all of this work means we hope that
Java will not just keep moving forward
but keep moving forward faster don't
believe a word we've said thank you very
much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>