<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Ask the JDK Architects by Brian Goetz/Mark Reinhold | Coder Coacher - Coaching Coders</title><meta content="Ask the JDK Architects by Brian Goetz/Mark Reinhold - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Ask the JDK Architects by Brian Goetz/Mark Reinhold</b></h2><h5 class="post__date">2016-11-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/OKIKEccotUg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good afternoon and welcome to this
year's edition of ask the JDK architects
at devoxx Belgium I'm mark Reinhold
listed on the bottom why don't we
introduce ourselves starting with Alan
who reads that fastly refuses to publish
his Twitter handle but he does have a
module system 4 gdk9 I'm a doctor not an
architect damn it I mean my name's
Stuart Marx also known as dr. deprecated
er I work on the JDK core libraries
group including on collection this
lambda streams and deprecation I'm
already Brian gets Java language
architect okay so this is a question and
answer session and I have here on my
laptop the shortest possible Oracle
slide deck can you guess what the other
important slide is that's right do not
believe a word we say okay so this is QA
if you're in the room and you're not shy
there's a microphone up there please
walk over to the microphone don't shout
because if you shout well we'll ask you
to go to the microphone because if you
don't go to the microphone then we will
have to repeat your question and we will
probably get it wrong we might
intentionally get it wrong even who
knows it's the most fun part that's true
anyway well whatever so the microphone
is there please use it if you're shy you
can tweet to the ask art ask arch
hashtag and I'll be looking for that on
Twitter so if you're shy or if you're
not in the room but you just want to ask
a question and you happen to know this
is going on even though it's not live
stream you could do it that way so we
have 57 minutes left any questions are
we done
really mean okay we'll stay long enough
for the pictures and then move yeah wrap
up I guess we have any primer questions
why aren't there versions of the model
system our first customer please I think
there's a there was a mistake
done in Java I think four or something
now the assertion was introduced it was
disabled by default this led to even the
unit having a sir true method which
would be unnecessary if it would have
been enabled by default sorry you're
talking about the assert keyword yeah
yeah nobody uses it because it's
disabled by default I think in Java EE 8
and a Java SE 8 there was a similar
issue because the parameters names are
not built-in by default so you have to
enable them which leads to that the Java
EE specs have to discuss if they can use
this meta information or not bummer
do you think it would be possible to not
listen to the people working on Java
card or things like that that are really
essentially trying to optimize the last
bit and listen more to the people that
have huge amounts of memory and don't
care if a class is 20 bytes longer so
the people who work on smaller things
and not not necess not just as small as
Java card but anybody who works on
memory constrained systems asks us the
same question of you could you please
stop listening to the enterprise guy
and bloating up the class file with all
sorts of stuff that they might need once
in a blue moon
so I mean given that we're in a position
where we have to make a choice that's a
one-size-fits-all decision we tried to
do the least harm and you know I you so
you're right in a sense that it is
useless in the sense that you can't
count on it but that sort of assumes
that it should always be available and
in fact it's not always available it's
not going to be available on old class
files either the ecosystem hasn't been
purged of old class files so given that
applications need to deal with the fact
that parameter names aren't there it
didn't seem an unreasonable default and
it seemed a reasonable balancing of the
needs of the various constituencies in
the ecosystem and you know this brings
up a very general question for us which
is everybody sort of assumes that their
problem is representative of the whole
ecosystem and becuase Java is actually
successful there is a significant
plurality effete of you know
constituents who are in different little
corners of the ecosystem and they have
radically different needs and and it's a
very difficult balancing act for us to
try to make them all happy so you know
we're sorry we made you unhappy but it
was a choice between making you unhappy
or making somebody equally worthy and
vocal unhappy I'm not saying they are
listening to but I think they already
invest quite a lot of work into
optimizing and they wouldn't bother to
add another flag to optimize even more
still with the answer's no it won't be
would be incompatible actually I have to
that's the women because anyone here
will actually want to comment on trying
to use the assert keyword for testing
whereas so you said no one ever ever
uses a search I actually use the the
assert keyword quite a bit because it's
actually very very useful for actually
defer for debugging but it's something
that is very much a fatal error if this
if this assertion triggers in the JDK
when I'm running with adesh the option
is that means that the system is
actually going to blow up the VM is you
actually want to shut down that's very
very different to an assertion they were
put into a unit test which i think is
what you started off with was trying to
use the certain keyboard and testing and
people end up then writing their own
that certain libraries
butshe unit uses this out yeah well if I
remember correctly oh are you talking
about the the assertion error the
exception class yes I think it's there
assert exception it's an assertion
there's certain errors and but that was
introduced specifically for the
implementation of the insert keyword if
jnah chose to use that that's that might
not have been the best choice for j-unit
to make and they should use something
else
I think they at least handle it
correctly well that's good they're unit
in there yeah okay that's good that's
good yeah so a couple comments on the on
both the assertion facility and the
parameter parameter names so on
assertions yes I heard this is
disappointment that the assert facility
is not used more than it is but it does
find some use in the libraries as Alan
mentioned we do enable assertions in our
test runs and they do occasionally find
things so that's so that's useful but
it's not as useful as one might think it
would be but but also to your point
about the smaller the smaller versions
of Java like micro Edition so forth it's
not just that in fact I I think the fact
is that every implementation even of
Java SE and on the server side is CPU
constrained and memory constrained and
so every production
not every but I'm sure that there are
many production installations out there
of even very very large systems we'll
want to disable assertions because they
do not want to have those gone going on
in production so it's not just don't
listen to the small guys I think there's
there's a wide-ranging set of concerns
about running with assertions enabled or
even having them on by default there are
some really irritating side-effects of
assertions as well which is that they
increase the bytecode size of methods
and then I've been there's there's
resistance to adding assertions to
methods which is oh that blows the the
hot spot in lining limits so don't do
that or put it in a comment in stat
which is right and so that's a you know
that's uh that's one of these leaky
abstraction things right what do we do
about that I don't know right so so yes
it's a problem there are various things
we can do about it but you know it's I
think it's unfortunately lower priority
than some of the other things we're
working on this the same is true with
the parameter names right it's not just
a matter of that the jar file is bigger
it's that it takes longer to parse you
know load the class which is a startup
hazard and it's more memory that gets
kept around in case reflection is asked
to serve that information up and so
that's something that exacts a time and
space tax on everybody
which you know again is charging
everybody for something that benefits a
smaller a smaller group I can understand
everything of what you say but still I
have never seen any anybody it is
evening the debug information for
example everybody leaves them in because
they are the default and of course if I
am in stress I have to optimize then I
would disable these things but I have
never seen it happen in practice in my
perspective maybe other people know
we've certainly yeah people do this yeah
we I hope we see everything I'm by the
way once people start using J link the
the linker that we have in JDK 9 you
would actually see a lot of stripping
and debugging because Bob with people
will be wanting to do is distribute a
small runtime
or get it to as small as possible
they're gonna be using the G link
options which we shall actually am
strictly stripping and compress
everything as small as possible thank
you so one additional comment on
parameter so so I think what it also
potentially does is increases the API
surface area I was gonna make a point
yeah it's good right because it's it's
more things that are specified and
cannot change or we could have like
disclaimer don't depend on those names
but those those disclaimers never work
because if we change the method name
somebody's code would break and they
would file a bug and we would have an
argument about whether that dependency
was proper etc so just more
compatibility issues potentially to deal
with so that that was and compatible
compatibility issues that you might not
even think about today but you'll wind
up facing in two years when a user or a
customer depended on a parameter name
that you thought wasn't important but
was recorded and then you changed now
their code is broken and they're pissed
off this kind of thing you know this is
like the the story of Java for 20 years
so recording parameter names all the
time by default I think you know for
Jabba the language as it stands would
probably be the wrong thing people
aren't used to thinking about it as part
of the api compatibility surface area
sorry
we saw today we saw today some code
samples using a VAR keyword which might
at some point make it into Java and
certain jvm languages have had this for
some time so are there plans for a value
war to encourage moral immutability and
in general what are what features from
those different jvm languages are you
considering to add to plain old Java
also so shameless plug you should come
to the talk on Friday morning called a
Java future sneak peek in which more of
this will be revealed but to answer your
question about Mara without any release
commitments but without anybody's
commitments but to answer your question
about var and Val it's it's subtler than
it looks
because of a syntax decision that was
made 20 years ago before we knew any
better so in Java you say type name and
then variable name to declare a variable
in some other languages you say variable
name : type name and you might think
this is a trivial difference but it
actually makes quite a big difference
and so if you declare your declare your
variables and types the other way then
the choice of whether you use inference
or not and the choice of mutability or
not become orthogonal choices and the if
you had key words for VAR and Val like
they have in Scala or in Kotlin then you
can also use those for declaring not
only local variables but fields we don't
have that unfortunately we arguably it
was a mistake we made 20 years ago it
means that having the Val keyword is
less useful than it would be in a
language where it was used to just to
connote mutability for all variables
having a keyword that only connotes
mutability for local variables is makes
it a weaker thing and therefore makes it
less less useful in the content you know
in the context of Java that made this
decision 20 years ago this is all sort
of unfortunate you know
accidents of history but it's a good
example of how concepts that look like
they should transplant perfectly from
one language to another right
we have local variables they have local
variables they have VAR val we could
have VAR val but there are often subtle
considerations that mean transplanting
the features you don't actually end up
with the same feature that you have in
the other language ah so it's not
something we made a decision on but it's
also something that's not the no-brainer
that it looks like when you think about
it for the first 30 seconds and say oh
well of course you would want to have
Val - so we're still thinking about that
and what about the glasses
what about dated classes for you know
this morning but yeah
does it come to Brian's talk on Friday
yeah so we showed an example of
something like data classes in the Keena
in the keynote this morning and you know
again if you look at languages that have
constructs like data classes including
Scala including Carl and including
c-sharp they all have slightly different
interpretations of what data classes
mean what members you get generated by
default whether they're designed for
extensibility whether they're designed
for mutability etc it these other
languages are actually all over the map
on this particular concept and we
haven't figured out exactly what the
right semantics would be for Java but
it's something that were that we're
working on as we you know discussed this
morning thank you
let's see if we do a question from
Twitter um
many of these look like they're okay
okay are up Brian's alley along similar
lines if what about pattern matching
what is the mystery about underscore
that's two questions
so if your pick answer both of them
I love pattern matching pattern matching
is a very natural fit for languages like
Java and so it's something that we would
like to do and actually we'll be talking
about a little bit on Friday when at one
of the you know the two features that
people ask us for most often for people
who are coming you know from Scala our
local variable type inference and case
classes and case classes or
essentially essentially pattern-matching
you know you define it a case class you
get some of the benefits of a data class
and you get an automatic pattern
extractor out of it and that's something
that unlike a lot of other features
actually translates into Java fairly
cleanly and so it's definitely something
we would like to do the the mystery of
the underscore is is an interesting one
because we see all of these all of these
tweets from people who see that
underscore isn't a valid variable name
kind of wonder what on earth were those
guys thinking and point out to us how
useful it would be to be able to use
underscore word as a variable name we
know that's why we're in the situation
we're in so let's roll back used to be
that underscore was a valid identifier a
lot of other languages use underscore
much more profitably to represent a
placeholder either a variable that is
not going to be used or you know a label
and a pattern match that's not gonna be
bound or a type that should be inferred
etc so having it as a as a identifier is
really kind of a waste of a good of a
good token we didn't like the idea of
allowing underscore as a lambda
parameter because lambda for a name
because it doesn't scale well we didn't
like the Scala wunderbar approach we
definitely didn't want that and then
using it as a parameter name doesn't
scale to more than one more than one
argument and it's a like I said a waste
of a pretty good syntactic token but we
can't make these changes all at once so
what we had to do was first warned about
it and say yeah you've got some old code
that uses this you should change it
because it's not gonna be supported then
in nine we were actually able to make an
error to use underscore as an N to fire
which is what makes people freak out cuz
they think of it because they think they
want to use it as an underscore and it
has an identifier when they really want
to use it as a as a not used indicator
now we are finally free to give it the
meaning we want to but it takes three
versions because we can't just pull the
rug out from people you know so quickly
so yes we know exactly what you want to
do with it that's the plan that's why
you can't do what you want to do with it
now because it enables us to
get to the point where it is a more
sensible language feature in the future
often doing the right thing takes
long-term planning you might notice
Corbett is in its own module the reason
for that next question
hi I'm Mateo first of all just a general
thank you for the Java platform and the
open JDK because as a Java developer
when I'm happy I also think it thanks to
that and here is my question so I found
that first time ever I think in my doing
Java development I found out that one of
the JDK class behaves in a strange way
or at least to me strange way under
setup condition we'd open JDK now I'm
totally sure that I'm not like it drunk
or anything and I can see where the
piece of the code that I think I have
some doubts about it what is not clear
to me yet is where I'm supposed to ask
this kind of doubt question and where I
can you know ask not really raise it as
a bug but say hey why's the behavior
like this no well where where's the code
I find it on one of the son daughter
Nyna class not son miss can say that
everybody knows about that
yeah but either one of the son www I
forgot the food package name failure
connection and I think so so let's see
it's part of the networking yeah library
a net - debit open JDK java.net or you
could try asking it right now and maybe
we know the answer yeah actually I would
need the code the to pinpoint so but
basically the mailing list that I find
basically related to the open JDK are
the correct ways to ask yeah that's part
of it open JDK is for it so it's not
just about people working on the code
but if you're using the code you have a
question that's not quite a bug report
as you seem to do yeah ask it on net dev
and hopefully somebody will answer it
all right yes and sometimes these
questions get bounced around a bit where
you think you might think it's a core
libraries question so you'll ask on core
libs dev and someone will say yeah this
isn't really the right place to ask you
should ask on that list over there and
if that's okay don't be offended
sometimes that happens more than once
even but it's okay and you'll eventually
get threatened wait
when there's a cycle that is a problem
yeah that would never happen no I also
don't be if don't be offended if
sometimes mayor's are ignored particular
development lists people are actually
trying to get worked on and if there's
if there's people showing up or random
questions how do I use this and that did
some but your question sounds
interesting yes so I actually like to
know the answer everyone hopes someone
else will answer the question yeah yeah
so you know if you don't get an answer
we'll ask it again in three weeks so
another question on Twitter I guess I
I'm just cursed with this question third
time today what why is there no version
support in the model system do you
really want to know so here's a little
story I've gotten better better at
telling this little story in early
jigsaw prototypes and this is like what
six years ago it did have versions in a
module declaration you could say you
know requires Jackson dot data bind at
you know greater than two point one and
less than five ten and whatever and it
was there and it was complicated and we
had to add an implementation of it the
initial implementation was pretty as
pretty simple-minded
we were on the verge of checking in a
very sophisticated piece of cold code
called a Sat solver who knows what a Sat
solver is it's a big pile of heuristics
for solving the boolean satisfiability
problem if you have a bunch of modules
and you're trying to do resolution into
a module graph there is no optimal
solution that isn't that is not in the
np-hard category right so since you
don't want to take forever to do that
you need your a six to do it quickly so
we were on the verge of integrating this
and then and unfortunately you're just
before doing this we thought wait a
minute we at that around that same time
we were starting to think about well how
is this module system going to interact
with the build systems that everybody
already uses and will presumably
continue to use and and you know
thinking about this well hmm it would be
bad for adoption if to use the module
system you have to scrap the build
systems you know that's like no that
that's a non-starter so we've got to
work with the existing build systems
hmm okay well everybody knows system has
its own way or in some cases multiple
ways of doing version selection which
way a version selection are we going to
do in the module system huh okay well we
could do this near-optimal thing with a
Sat solver which none of the existing
build systems do maybe one of them ought
to but that's a different conversation
so huh well what if we just don't do
version selection really an insight
let's instead okay we are already
systems around they're not optimal you
know that they have their fans they have
their detractors but it's what everybody
everybody uses maven or grave Gradle or
something that interoperates with that
ecosystem and these build tools provide
ways to inter mediate and deal with
version conflicts and all that other
messy stuff in reality let's put the
module system on a on a somewhat more
abstract plane and say okay modules have
names
they don't have versions you can require
other module modules and you know by
name and that's it and a version
selection is a big issue go talk to your
build tool we're not gonna solve that
problem it was a massive simplification
and it let it let us remove a lot of
hairy code and avoid a lot of hairy
problems so in a way it was kind of a
little judo move it surprised it does
surprised a lot of people but most
people once I told a little story there
they realized oh well maybe that's not
so crazy even if it's counterintuitive
on the surface okay so mark to clarify
something so you mentioned that the Sat
solver is np-hard yeah so I think what
that means is that potentially it
degrades the exponential time and is
that correct and an empty solution
sorry and often the novel an optimal
solution would be a can and that's
awesome in the critical path of startup
yes so think about that you really you
really don't want to yeah yeah yeah and
that's why we're looking at all these
heuristics but even you know even the
heuristics well being if it can take
time and so you know since we don't have
we're not doing version selection
resolution at startup is is a very
simple transitive closure computation
you look at the modules that are
observable on the module path you
you look them up your resolve
dependences it's all extremely simple
extremely fast in you know in in JDK
nine you know with a lot of effort from
Allen and others we've been able to
maintain maintain and I think we've even
slightly improved startup time so even
even though we've added this model
system that's doing resolution of
modules on the module path you know how
the world starts up in a teeny bit less
time than it did in eight so that's
pretty cool
yes hi yes I am one of these programmers
that likes to make my variables final
and just because I didn't think I can
accidentally change them so for some
reason I don't know is neurotic or
something but it feels like my culture
Buster when I check my colleagues I
don't get a lot of support for that
because I think I'm just being for post
and why should I make everything final
so I was like yeah you can arguably it's
the best practice or not but I was just
wondering if you have considered making
variables in Java final by default what
would make what - what would do that -
the JDK mmm I'll tell you what I think
they won't school others think we had a
time machine and we could time many
years you know it'll be a great idea
yeah you know looking back with 20 years
of hindsight and we've we've done a fair
amount of this in the whole module
system design considering well what
should be the defaults for you know
should it never should things be
exported to by default in Ukraine your
gene you should ask to encapsulate them
yeah things like that if you if you look
back at at access modes and finality
maybe some decisions weren't the best 20
years ago having fields and and
variables be final by default in
retrospect probably would have been a
better choice having having having all
kinds of members be private by default
rather than this weird weird netherworld
package private thing might have been a
more sensible
choice having a public construct no args
constructor inserted for you if you
don't write a constructor of your own
yeah I don't think that was that was a
winner but I mean are we gonna changing
any of these things at this point no we
would break all the code in the world if
we did that I know something though that
maybe it's tempting that and and we
could imagine like you know you thought
it took a long time to repurpose
underscore you could imagine a you know
seven version progression where we
introduced a mechanism to make things
explicitly mutable and then in the next
version we warned that you know maybe
you ought to use that and you know over
seven versions we somehow get everyone
to change all their code and they would
hate us for it right because most
developers who care about this less than
they should would look at this I think
quite rightly as why is the compiler to
pestering me to change my code style on
a code base that's been working fine for
twenty years and so it kind of feels
like wall that would have been a great
choice to make 20 years ago the the
compatibility cost to the ecosystem of
trying to change it now it really feels
like we just missed that boat and it's
it's sad you know it's you know I think
we all we all share the the kind of
sympathy you know sympathy for this the
philosophy behind it but it's just it's
it's not a thing that's that's worth
changing at this point you know given
the cost as kind of a best practice than
at least with you know what what I've
come down to doing is declaring every
variable in a method final by default it
just gets to be too too much visual
noise so I don't bother because in
general I I haven't found that that
saves me from doing just stupid stuff
too often but declaring methods final by
default and declaring classes sorry
declaring methods explicitly final and
accurately declaring classes explicitly
final is something I pretty much do out
of happen okay thank you
I should come a couple comments on that
I think I'm just kind of brainstorming
here but one one thing for local
variables that might be useful is to
have a static analyzer that enforces
single assignment or something like that
oh yeah there are lot lots of tools that
will layer on top of grad forms at home
so that's a possibility and another one
is that with a value type stuff and
maybe the data classes stuff the fields
will be final by default so we're sort
of introducing that in new constructs
yeah there have been a number of gentle
pushes towards immutability as new
language features have been added as we
have the opportunity when we don't have
a base of existing code to not be
compatible with but even in that context
you know someone suggested during lambda
that lambda parameters should be you
know should be final by default and we
considered it for a while because we
liked the idea and then we concluded
that you know the cognitive friction of
having to similar constructs that have
different default behaviors that
arguably should be freely refract all
back and forth between each other seemed
like it wasn't worth the benefit so we
thought about it
and we thought about it for quite a
while and then made the right choice
hello I have a question about the Java
mud wallow in Java dance whatever had
those feature will be introduced and the
memory variance is a part of it but the
contribution of a java memory model
cannot describe this behavior and is
there any plans to update Java memory
model and is it possible to see any
draft to understand the evolution way so
Dudley and a number of others undertook
an attempt to read you know to revamp
the Java memory model with the explicit
goal of aligning the Java memory model
with the C++ memory model so that you
know when when you're interoperating
between Java code native code there's a
common set of terminology you can use to
reason about
about visibility of Rights and there's a
mailing list on openjdk JMM dev with
quite a lot of discussion and a somewhat
disappointing conclusion which is that
you know with like 20 of the best
theorists in the world working on the
problem there were still unsolved
unsolved aspects that they were not
comfortable recommending a new set of
semantics
you know at the time so they're
continuing to work on it they were
hoping to deliver it into nine the the
exploration kind of fizzled out but
people are still kind of working on in
the background and it may come back but
you can see all the discussion on JMM
dev thank you I have another question
about stereotypes they are in Java EE
and they are not in Java SE and I miss
them because they only work in one
context and I would like to have every
annotation serotype Obul so to speak I'm
going to plead ignorance here yeah I
know that there's a concept of
stereotypes it's like a macro expansion
where you can say this annotation is a
macro for this bunch of other things so
the problem with annotations is that
they promise way more than they actually
deliver angle brackets rant yeah
and you know we have in the past
you know extended the annotation
facility multiple times at the request
of you know folks who were building
annotation heavy frameworks you know
like you described and each time the
result was more complexity and a fairly
disappointing increase in expressive
power and the fundamental problem is
that there's no type system behind
annotations and yet we want to attach
them to things that have types that
things that have inheritance that things
that may have multiple inheritance and
the the rules surrounding how do you
process these things are incredibly ad
hoc if you read the CDI
vacation you know they make some fairly
untenable ad hoc decisions because they
didn't want to deal with the hard cases
and we don't want to bake something
so half-baked into the language so we
would much rather say here's an
annotation mechanism if the language has
if you would like to layer additional
semantics onto the annotations be our
guest but it's not going to be part of
the language semantics too bad it is
today
Twitter questions pretty good right why
not start with a clean slate and create
a new language in parallel sure who's
gonna pay my salary I used to be an
academia and you know the pay is not
that great
yeah hi there are several concurrency
models and GDK offers one implementation
based on threads do you think that the
GDK will get at some point and now the
concurrency model implementation like we
have with the cert from third-party
libraries in order to help fellow
developers to write more deterministic
code and not reason about our
non-deterministic help of chapter 15 17
and jsr 133 or not and second part to
the question Brian will be there Javed
can Carson practice second edition we're
talking about through so I think the
answer is maybe to both of those
questions
we're not averse to having say maybe
you're thinking about co-routines and
continuations you know co-routines are
very popular and in other languages you
know go has built-in co-routines and
channels and people like that fits
nicely into reactive models it's
possible that might you you might see
that in the future but there are an
awful lot of problems that have to be
solved before we could with a straight
face add add that as a facility to you
know you know to the JRE it's not just a
matter of a little bit of language sugar
that you know if you want things to be
non-blocking they have to be
non-blocking all the way down through
the libraries and that's a major effort
so we would you know we would like to
get there we're thinking about such
things but thinking about them in the
very very far-off kind of timeframe so
maybe and on the book maybe you know
write writing a book is a very time
consuming activity revising a book is an
even more time consuming activity
relative to the amount of new material
that's added and I haven't found the
time I think but I might yeah another
point I'd make about the the concurrency
thing is when we think about what's
appropriate to put into Java SC in the
JDK a lot of that is colored by will
what what are things that we can do in
this foundation of the whole ecosystem
that can only be done here right there
there lot there are lots of interesting
models for for concurrent programming
that can be well supported by a library
that's built on top of Java SE and
doesn't need anything special and
important and that's great you know let
a thousand flowers flowers bloom and if
you find a library out there that does
it for you perfect keep using it but
that's something like co-routines is you
know what would be a deep deep change it
does it does seem worth doing but it is
gonna be a big project so yeah we'd like
to do it and it's something that can
only really effectively be done inside
the platform itself and you've already
mentioned several times today we can't
do this because earlier choices may be
choices we would make differently if we
could make it now and do you think
construct could be introduced to the
language that would allow us to go back
to those choices let's say a source
version statements or anything that
would achieve the same goal
in certain ways we already have that
it's just not in source files it's how
you invoke the compiler yeah but but
that doesn't really apply to you can't
have two files of different sources in
the same project
well not not not yet not in the same
invocation of the compiler that's true
but so so here's the thing the
investment of PEEP of people's you know
time and and money in the overall
ecosystem the reason Java has been so
successful is as a developer or as a
company investing in a project you can
you can invest in in learning the
platform learning how to use it you're
writing a bunch of code having you know
having a mapping products that run well
in production and so forth and there's
an assurance that things are not going
to change radically the key value of the
ecosystem would you know be far
diminished if we I think if we suddenly
said okay well there's there's Java you
know alpha and now we've got Java beta
that's a different language it looks
kind of like Java but there's this other
thing and you have to put a funny token
at the top of your source file and it's
not gonna be totally compatible and why
don't we just call that Scala or
something I mean it's it would be a
different it would be a different
language it would be related to the
platform but be a different language Mia
will Pete do do people want to put you
know the same level of investment that's
gone into you know Java itself for 20
years in that well maybe but maybe not
so it's it feels you know it it's
tempting you know it's certainly
tempting it's it's great sometimes to
sit around when you're really frustrated
frustrated with the design problems like
okay I'm walking into Gosling's office
in 1994 and I'm gonna tell them that
that's just wrong but you know that's
that's just a fantasy for for downtime
the reality is you know Java has been
very successful successful we want to
preserve its success and essentially
forking the language seems like running
away from the real problem
and sort of in addition to the
philosophical perspective that Mark
offers there's also an economic
perspective right so we have certain
limited resources for evolving the
language and you know evolving the tools
to go along with that and all that and
we have to assess the return on
investment and we want to put our
investment where it's going to have the
most impact and fixing the mistakes of
the past is unfortunately more expensive
than adding net new features and so from
a return on investment perspective we're
better off investing the effort you know
adding features like you know lambdas or
pattern matching or what have you then
trying to go back and make Java
you know into what it would have been if
we knew then what we knew now and and so
while it's not out of the question that
we might do some of those things and
like the underscore example is an
example of where we actually did that
and it's kind of small way and people
still complain about about it but it's
it's just not very economically
efficient to put our resources there so
we'd rather put them where they're gonna
make more of a difference for more
programmers ya know in certain areas and
this was I actually had a question on
Twitter in certain areas it is worth
having a long term plan for for
replacing something that was a
particularly painful mistake in the past
serialization is exactly what someone
asked about what's the what's the plan
for corralling the serialization problem
and this is something we have given a
lot of thought thought to over the last
few years deprecated indeed deprecated
for removal equals true please doctor
you know we serialization I'm sorry I
you know I I have the greatest respect
for the people who designed it but it
was just wrong there it is I said it and
I'm glad you know it's just flawed in in
in so many ways so you know we have some
ideas about how to how to evolve in the
long term towards having a much safer
mode of serialization some of a
you know maybe may wind up being
supported by some ideas that Brian and
others have been working on for for you
know supporting language changes you
know and just get away from this
business of poking into random private
fields and assuming that there's gonna
be some compatibility when you stick
that in a byte stream and deserialize it
five years later on a different platform
and never mind security issues so you
know that that is a mistake of the past
that we think is worth fixing we and and
is worth investing in fixing making
local variables final by default not so
much well thanks for the explanation and
for record I'm not saying turn Java into
scala using this please don't not how I
interpreted I was getting that as an
example and but still some mechanisms
like the underscore example to allow you
to do it quicker not deprecated warning
error then introduced a new thing the
stakes for versions which is what ten
years I'm sorry it's a long game it's a
long game yep sorry thank you
hi the jab regarding the foreign vowel
says that the identifier farvel was not
made into a keyword instead it will be a
reserved type name and I was wondering
can you explain what it means and also
what it means for programmers that
currently have a type with set name I
know that a lot of users of Lombok use
vowel already and what we at Lombok do
is we key of the import if it says
import lombok dot fall then we replace
it
couldn't you have a type in the Java
namespace follow for instead of making
it a reserved type name
whoa okay so so let me there's there's
actually three questions in there all
right so the first question is why why
isn't it key word right and that's a
pretty obvious answer how many people
can imagine programs in the world that
have very have identifier names of var
or Val people have this in your own code
yeah everybody so if we made it a key
word we would break those programs
immediately so that will be done we
don't want to do that the but the choice
to make it a reserved type name sort of
illustrates the that we don't view these
compatibility issues as absolute black
and white we assess how much code would
we be would be broken and how deserving
of breaking is that code and so for
example a type named Val as exists in
project Lombok does not conform to the
type of to the identifier naming
conventions it's a type name that starts
with a lowercase letter so are we more
willing to break code that does that yes
absolutely
and so basically you know we're not
we're not willing to do the wrong thing
just because it would break one block so
the thing is you wouldn't break Lombok
because we don't care we would be glad
if you add it right because we made sure
it's already compatible with respect so
we would be happy if you would add it
I was just wondering like couldn't you
use a different way to do this instead
of making it reserved so in in a
particular case of Lombok wouldn't it
mean the same thing yeah exactly you
could just get rid of the import and
everything would work fine so I don't
have that problem but I was wondering
like yeah you know the reserved type
same thing is a clever hack it is it's a
quick it's a clever hack and that's a
good way to describe it because if we
had it as an explicit type it would
still be a magic type and that would
have more I think more linguistic
complexity than have been simply
admitting this is reserved as a type
name and yes if you have types that have
this name well they should have
capitalized the B and sorry
and but but but as Mark says it is a
clever hack yes and you know clever
hacks a good question for dr. deprecate
or maybe from Twitter let's see where'd
it go do-do-do-do-do well I had it it
sucked away Java eight replaced the
standard date API are there plans to
replace any other default library api's
in future versions was it that one let's
see are there plans to replace other
default api's or maybe just remove some
that we already have Oh Brian's mic was
okay
Brian Brian's not answering so so
offhand I'm not aware of any any core
API is that were intending on on
replacing I think we're we're dealing
with we're dealing with getting rid of
the the the the the obsolete core API is
already and that's hard enough so for
instance those of you who have been
looking at the Java for a long time
remember the original pre collections
collections like vector and hash table
or hash table and those aren't even
deprecated yet and I have a you know
there's a plan to deprecated them but
there's a lot of code out there that
still uses them and so deprecating
something imposes a cost we might not we
probably will not actually remove them
but even if you add deprecations then
that introduces warnings and some people
are very sensitive about warnings in
their their code base so they should
yeah
as we are as a matter of fact so one of
the things is that if we were to
deprecate something it actually creates
a lot of warnings in the JDK build
itself and we try to keep our warnings
clean and so so it's sort of creating
work for ourselves to deprecate
something with the Java dot time stuff
okay so you could say conceptually sure
Java time stuff is new there are a lot
of good things about it it's a
conceptual replacement for job you till
date and calendar great get rid of that
old stuff well if you look at the amount
of stuff out there that uses those there
would be like tens of thousands of
warnings generated by by deprecating
those well so and removing them would
just break tons yeah so so they're not
they're not gonna be removed they
probably will be deprecated at some
point but it's like surgery well okay
yeah so so I think the the if my belief
is that the main issue with deprecating
things is generation of warnings and how
what mechanisms are available for it for
people who are concerned about warnings
to deal with them and I think we do need
to work on that more that is something
that we've thought about but we don't
have anything going on in nine and
that's actually I think limiting the
rate at which we can deprecated things
and here's another consideration about
you know the introducing the new
date/time API so we have the old date
API and then we have the new date/time
API and yes the new one is better and
yes it makes sense to consider
deprecating the old one in favor of the
new one the problem is there are
interfaces in which date appears as a
type so you might have an interface like
you know that has a method get last
access date and it returns a date right
so now there may be subclasses of that
interface out there in the wild that we
can't control
so deprecating that deprecating the date
class ripples into interfaces that use
the date class and you know sometimes
these you know these tendrils can go
fairly deep and so
deprecation is not simply a matter of
don't use this because there might be ap
is that already use this and you may not
be able to control all their uses yeah
okay yeah so you made it very clear that
Becker's capability for Yaffa is very
important that you're not just going to
break it
especially not since the cost is not
enough but I'm wondering how you're
feeling or are you waking up at night
like Oh Java 13 we can't do anything
that will put brakes on scopes we have
to make a change that will break the
package compatibility do your fingers
coming or are you just like me we'll
handle it in there on any future well I
think we've you know that this is a it
is a burden one one chooses to take on
when when taking a job you know a job
working on on the jdk whether you're
you're at Oracle or elsewhere I I think
a part of this goes to sort of I guess a
deep philosophical question about tell
about the life cycle of a language on a
platform you know at some point you know
Java may may may reach reach a stage
where you just can't change it much
anymore it's actually had for for a
language and platform a really good run
compared to a lot of others you know
when will draw to reach that point I
don't know I will it won't be next year
I'm guessing it's got at least another
ten years and it may be twenty who knows
but you know at some point it will be
time to move on and and and and that'll
be okay yeah and the other thing about
about compatibility is they're just
there's so many variants of
compatibility one of the things we've
we've really struggled with with the
modularity work is much lower than the
platform and encapsulating internals has
created you know problems in practice
for lots of people where they come they
come running at us with pitchforks
saying you're not compatible
you broke my application
and the reason we broke their
application isn't because we've removed
that you know an obscure deprecated
method that nobody uses you know that
was part of that the Java SE API for
many years the reason we broke their
application was because their
application uses a library that depends
on a jar file that depends on them
another jar file that hasn't been
updated since 2002 and reaches into the
numeric wrapper classes in the java.lang
package and expects a certain private
static field to exist in each one of
them yeah but yes and guess what you
can't do that without JDK 9 so you know
that that that you know the part part of
the the what we think will be the
long-term benefit for the for the
ecosystem of the pain of moving to 9 we
know the pain that 9 is gonna be harder
release to move to because of problems
like that which do come under the guise
of Oh compatibility you broke
compatibility part of long-term benefit
is we are reducing the practical
compatibility surface area you know
after nine you you won't be able to
write code unless you're doing really
nasty things that depends on JDK
internals and that will give us freedom
to change those internals in ways that
for about 15 years we felt very
conservative about changing so some of
the things that we are we're that we do
they've let me see it seem like they
cause pain but they're actually in
service of enabling further evolution in
a in a compatible way going forward it's
similar to the way that we've we've
evolved the platform in the past by the
way just to get a flavor for the type of
things that mark is talking about it as
we did to talk yesterday on jdk 9 where
we went through all of the different
compatibility issues and it's as Mark
said it's not always removing supported
API it's it's all these other
implementation changes that tend to
break things so we went through a bunch
of examples yesterday it's actually all
recorded and from devoxx University
session yesterday if you want to check
it out yeah I will thanks it was kind of
a philosophical answer I hope it was
ruminating yeah I'll just add two quick
points to that one is yes it's really
hard
that's why language evolution takes so
long because you know
having the idea of wouldn't it be great
if I could write this code well that's
you know the first five minutes and the
next three years of work is how do you
work it into the existing model so it
doesn't look like it was nailed on so it
doesn't break existing code etc and
that's where all the work is and so the
flip side you know flip side of that is
yes it can be done we can deal with it
we're professionals but it does mean
things take longer another way that we
keep from reaching that point that Mark
described where we've crammed so many
languages into the language that there's
no place left to cram like ml and the
libraries and the and the libraries is
don't cram so much in write we're fairly
conservative about the features we add
because we know that each feature we add
add some bad weight gets us closer to
that point where we really are going to
regret some some interaction of
decisions so the the antidote for you
know for incompatibility is take your
time and and that's what we do all right
two minutes left does anybody have a
quick question
does anybody have a quick question with
a guaranteed guaranteed quick answer a
quick one we add severity to the
deprecation severity to deprecation yes
so you can have some that you say well
these are not major things like linked
lists we will leave them but you should
preferably not use them a you have other
ones that say well these are really bad
you should never use them and then in
the Flex you can say well crash or fill
the bills whenever a certain severity is
reached in fact we have done that very
thing in nine at least the first step
right so so there's a there's new
attribute for removal which is simply a
boolean which is which is sort of a
severity but in fact actually pinning
down the semantics of even adding one
level of severity
it was difficult how many hours went in
the discussion up for removal what quite
a few started out as an enum with this
whole variety of different reason brides
I think those are the the whole
different reason codes is interesting to
think about it was an interesting
discussion but but specifying that in an
API and using it in practice turned out
to be too difficult so I think I can
imagine somebody saying oh I want an int
or I want a double value as a severity I
you know I think what does it even mean
yeah what would it mean like so so I'm
gonna set my severity level for issuing
errors instead of warnings at 5.37
right there is actually a third level of
deprecation which is to have no warning
whatsoever but a note in the Javadoc
that says you should use that other
thing instead so that's sort of an
informal lowest level and we do do that
in some cases time is up the sign says
thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>