<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>A Pragmatist’s Guide to Functional Geekery by Michał Płachta | Coder Coacher - Coaching Coders</title><meta content="A Pragmatist’s Guide to Functional Geekery by Michał Płachta - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>A Pragmatist’s Guide to Functional Geekery by Michał Płachta</b></h2><h5 class="post__date">2017-05-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/3bkb6U5jJbs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Birgit inflated doing make sense I mean
how I work at the Co technology in
Krakov office and this is a functional
programming talk at functional
programming in Java and Scala and I will
show you mostly Java code but I will
also want to compare Java and Scala side
to side so the same functionalities in
both languages so that you can see the
difference and I will be honest this is
a talk about functional programming but
I don't want to show you any math I
don't want to explain why monad is
modeled in the category of endo factors
and I want I don't want to convince you
that functional programming is cool
either what I want to do is show you
some practical applicable examples of
functional programming in Java so that
you can use it whenever you you see it
fit so imagine that you are part of a
remote team you are doing lots of
contracts for different customers over
the world and one day a new client
approaches you he heard about this thing
called Twitter that people on earth to
use he wants to have something like that
in his galaxy so what what we do of
course we have to be accept and and we
promise to have a working prototype by
the end of the next week right away we
go to our favorite coffee house and
start hacking and the main functionality
the main requirement for this the whole
software is to show who follows whom so
the followers functionality with bound
or our ID and because we are in a coffee
house we want to do pro functional
programming right so what does it mean
to be a functional programmer programmer
in Java the current state is that we
want to have immutable collections we
want to create any table types we also
have few functions avoid reassignment
and of course we want to have functions
that take functions as parameters and
return functions so the higher-order
functions and we can have those in Java
right because we have lambdas and
strings am i right well yes and no
because a lamp art of course held a lot
because they are
functions as data but and then the
streams are also very okay because they
bring the higher-order function
functionality to the language but the
rest of the API hasn't changed after the
Java 8 update so we still have mutable
collections and we need to use something
like guava or other external library in
order to have mutable immutable
collections and in Scala kind of the
same thing can be said about Scala so
everything is built in to the language
and we have Valle keyword which is some
more concise we have first functions as
first-class citizens the real ones and
of course we have immutable collections
so the API for her higher-order
functions is a lot more concise and in
terms of basic functional programming
whenever you see my scholar code the
same thing can be done in code seen a
pretty much in a similar way and but
I'll be showing Scala code but bear in
mind that the coding alternatives will
be very similar there are some
differences at the most more advanced
levels functional programming between
those two languages and I will touch
upon one of those differences at the end
of the talk but I'm not here to talk you
into Scala or coding I'm here to talk
about functional programming and we can
have all those basic things that I just
mentioned in Java today using a library
code called waiver which has just been
renamed last month too from Java sank
because of trademark conflict with Java
so how many of you have used Java really
that that's a real story so how many of
you have used Java Frankl waiver ok cool
all my Java code today we'll be using
waiver and I will explain all the things
that are new hopefully as we go so after
including the waiver we can have a more
Scala coding style in Java so we can
have immutable collections which are
built-in we have functions which are
built-in those are functions that are
compatible with the Java functions a
final keyword stays the same and to
create
imitating types we need to have still
external library or do them by hand and
the higher-order functions look bit
better than with the streaming with the
stream library so small display
disclaimer I'm a scholar developer and I
was trying to do Java first time for a
long time and I picked favor very
quickly but if that's not the case for
you just please interrupt me I will try
to explain as we go so after including
waiver and we have almost everything we
need in order to start the
implementation so let me show you how
those things can be utilized in a real
project and the real project that we've
been tasked with is galactic Twitter and
one week deadline
so let's model our domain first we want
to have citizens we want to have a
citizen that has name so every citizen
in the galaxy needs to have a name so
this is abstract club but we can have a
concrete types we can have a civilian
with also just the name Jedi rebel and
sit also just names and of course a
stormtrooper which is which is a type
with the name and a boolean flag which
means whether the this particular storm
trooper was cloned or not so this is our
domain model for the citizens of the
galaxy and we also know how to fetch
those guys so we know we have two
methods one for getting the citizen by
providing just the name and one for
getting the followers for the particular
citizen and both of them are implemented
by one of our colleagues on the other
side of the globe preferably in a coffee
house so we both of those methods are
returning futures and those are futures
from waiver a future models is something
that may be available in the future
maybe because the computation that is
that will return something in the future
may also fail that's why the future has
two cases so what can we do with such a
type
this is debate that the foundation for
synchronous programming what what can we
do
with such attack what do you think so
let's create a simple console
application we are back-end developer so
we are trying to test our stuff with
console applications and some other
colleague of us ours will be doing the
web application so let's let's write a
simple consult equation to find out we
first provide a name of the citizen that
we want to get the followers for and
then we call our DB client a DB client
get citizen by name it returns a future
of of the citizen and then we of course
got go to our ID press dot on it and see
that there is a nice function called get
which get the citizen out of future
context and we repeat the same procedure
for the followers so we are getting
first citizen and then we get the
followers for the citizen and also get
get the followers out of the future
context and we are able to print the
followers to the console so we have done
well right no so what's the problem
yes that's one of the problems if this
is if it fails then we have a problem
but the first problem probably that will
appear in our happy path is that the
user will just get stuck whenever the
database is very slow right because what
future gets don't get does its wait for
the value to become available so we wait
for the value to become available in the
user thread in the thread that is
getting stuff from the console and into
the console for the user so these are is
waiting for something to happen without
any feedback at all and we should get
users happy right by not blocking at all
can we do that so let's change double
implementation and get rid of blocking
and this technique this this is a common
pattern in functional programming and
that is we don't get the value out of
the context in this kind in this in this
example the context is future we don't
get the value out of the context until
we really need it so this is a common
pattern so all our transformations
should be done inside the context
because we don't know whether the value
for example here is there or not but we
know what we want to do with it whenever
it's there so let's not unwrap the value
from the future let's just map over it
with a new line 111 we let's map it with
the followers get followers called to be
be client and what it does you can see
that on the top of the diagram it will
make the future contain another future
so future of future that's why we need
to flat map that way that's why we need
to use slab Matsuri for this technical
type of flat map and then we'll get the
future of a list of citizens so we're
still in the context of future that's
why we use a sub map and we still are in
the context of future we just are
getting the size of the list in order to
get the count of the followers quantity
of the followers so as you see there are
no blocking calls at all that because
our function also returns the future so
the pattern of mapping and sub mapping
is so popular in functional programming
them in Scala we have a syntax just for
it it's called for comprehension and
both methods on the slides are the same
so the Java and Scala code are totally
equivalent so in order to get flat map
and map we can just use this syntactic
sugar and it's it gets better whenever
we have more of them
so what can we do with the function that
returns future again and we can just
transform it until we need a final value
but if we need the final value we can
just we can just use another fret to
process that value and this is where
what for each function does it's defined
on fall on future in favor for each in
line 22 it takes a lambda so we provide
a function that needs to be called
whenever the value becomes available in
the future we get the result which is
the list of citizens and and then which
is a int that's a count of seed of
lowers and then we put it into the cast
followers map so a user will need to
pull every now and then but the call to
this function won't be blocking so we
always return integer and we're in the
end we in line 25 if there is no value
in the cache we just return zero so
that's about the default value and we
use additional things from vapor here
because we don't didn't use the hash map
from Java we use hash map from vapor and
Hosmer from from very very very of
course immutable so every time we call
it put it returns a new hash map every
time you call it get it returns an
option type whenever option is some that
means that the value is there and
whenever it's none that means the value
isn't isn't it there so this is how it
works for the user
the first is not blocking anymore so
that's cool and the value is cached we
get the real value after our third try
so we we know that that way there has
100 to forward so several threats are
going are happening no logs no spawning
the threads by hand so that's the power
of immutability and futures and this was
just a helpful this is just a helper
application that we can use in order to
test that they can Selvi that we are
implementing but the real web
application is also being implemented by
one of our colleagues as I said before
mmm and what he did is use the API polls
every 200 milliseconds and back end is
non-blocking so the calls are very fast
whenever the value becomes available on
the server it is returned and shown to
the user so everything works fine what
one night the telephone starts ringing
it's our user and he's not happy so he
files the back report and he said that
he has 0 for 0 followers and it's not
possible so what we do we run to our
desk fire up the console application
helper consultation we wrote and run the
query against the production database
this time
and and we see that the problem is
really there so we get zero followers
every time we we ask for for it only
after ten or so seconds it converges to
the real real number so what's happened
this time the problem is that we are
treating zero as two types of data one
of them is zero followers the second is
there is no value at all
so whenever the database gets lower the
user gets frustrated because the value
that he is expecting is not it's not
there how can we solve that whenever
something like that happens in function
programming strongly-typed function
programming we are using data to model
everything so we are using types to
model all our assumptions about the API
we are writing so let's change the
return type to something more more
self-explanatory
we know about this option type already
and it models they think exactly as we
wish it to be models so we can have a
value it means that it is in the cache
or there can be non value that means it
isn't in the cache so we can then feed
back to the user the real state of the
functionality of a quantity of his
followers so let's change that so this
is the new snippet what we need to do it
is just to and turn the return type in
line 33 to option integer instead of
integer and not much changed in the
implementation the only difference is
line 37
in this case we just got rid of get over
else and now it only gets the citizen
name we use the hash map from waiver and
the get returns option and the GUI part
of the web application now can say the
loading whenever there is none returned
from the server now user knows exactly
what is happening so everything works
fine right
one night the telephone stun starts
ringing and it's our client again he is
not happy and he files a bug report
he can't check how many followers
obi-wan Kenobi has okay so we run to our
desk fire object computer the helper
control application we have to check the
things like that and run the query
against the production database because
why not and we can see that really
obi-wan Kenobi has loading followers all
the time even after 10 20 seconds always
loading so what happens now we didn't
cover the failure a failure case for the
future for each as I said before only
executing the lambda we provide when the
future ends up being successfully
completed so whenever there is a failure
in one of those futures we just don't do
anything we don't update the cache
that's why it is always loading so our
database of course is not designed well
because it's throwing just exceptions
every time there isn't there cannot be
an either but you may imagine that we
can have also some technical problems
like timeouts or something like that and
the same thing would apply so obviously
we found because as you probably noticed
obi-wan is spelled with a capital W not
a small letter so what can we do again
whenever there's problem like that in
strongly typed functional programming we
use data to model everything so we use
types to model our assumptions about the
API this case we use try tight from
waiver try type models the computation
that may fail
so whenever the computation sails it is
a failure case and it conveys the
exception but whatever the computation
is successful it returns the type the
instance of type T that we wanted to
compute so as you can see there are some
similarities between try option and
future because the same diagram is being
used
so let's modify the return type line 44
at the top we need to first modify the
cache title that we have
so far it was just linked to integers
now its string to try of integers and we
are changing for each which is only
which only calls our lambda whenever
there is a completed successfully
completed future led to uncomplete which
is called every time future complete no
matter whether it is failure failure or
success so now directly in the in the
return type in line 46 you can see what
the API is expecting of you as a client
so option means that the value is there
or not but if it's there it may be
successfully computed value or some kind
of problem error the best thing about
this new type is that we have two calls
to the database so to potentially
failing cause but only once
do we need to handle that failure so
doing that all the computations inside
the one context of future lets us deal
with the with the problem whenever we
need the final value and in terms of
programming is always at the end so to
cause one side your handling and the end
so we change the API and the GUI
application has also been changed and
now whenever there is a non return from
the server we can say that it's loading
again but whenever there is some some
failure we can just update our
application to handle it gracefully and
it's up to the UX designer to to say
what does it mean but let's assume that
it's something like like that now user
knows exactly what's happening right
okay so everything works fine but one
night again our telephone start doing
this time is our client again and he is
not happy with our return types they are
so complicated he says but suddenly we
realize that is just a nightmare
it wasn't the client it just our mind
it's our second thoughts about what we
have just implemented so maybe it's a
sign right because whenever there are
some problems in the code appearing in
our dreams and maybe design that we
should
at least think about them so maybe we
should be using some other type but what
about all the assumptions that we want
to have in our return types so that the
API client is happy about what what
really is going on under the hood so we
want to have we want to eat the cake and
have it too and there is a solution for
that
there is there is a thing called
algebraic data types and we can just
have some kind of algebraic data type as
our return type which is simple enough
and models everything we need algebraic
data type is product or some so it's
just just just some of types or product
of other types product is just a normal
project for example whenever the the
class is a consists of two types boolean
and int it's a product type because it's
a boolean and int at once right and some
type is one type or another type or
another type but none of them can be in
one instance together and of course
those can be mixed together we have
already seen some of those
for example the citizen is a sum type
because it can be either civilian jedi
revolted or storm trooper and storm
trooper is a normal product type because
it because it consists of the string
name and boolean flag and of course try
an option also are some ADT's because
they consist the option consists of none
and some and try success and failure
so let's model our result the return
type as ADT we'd like to do something
like that so remote followers data is
the ADT is the result return type that
we'd like to include in our application
and it can have four different types so
it's a sum type it can be either not
requested yet it can be loading it can
be set and convey the error message or
it can be fetched and conveyed of
integer of followers now our function
needs to return remote followers data
looks nicer because we exactly know what
the type conveys but when we think about
that how can the user use that function
right so the function this is just a
marker interface this is just a marker
interface remote follower data so how
can anybody use this kind of thing but
before I answer this question let us
think how can we implement this function
in the first place because we have tried
followers in line 80 that are the try of
integer and we want to based on the
whether it's a success of or a failure
we want to create different remote
followers data type right so if it's the
success we want to create fetched if
it's a failure we want to create failure
failed sorry so in functional
programming ADT's I go well together
with pattern matching and in Java using
driver you can also do pattern matching
pattern matching consists of two basic
blocks whenever you have case you are
just decomposing the ADT some type into
branches and whenever you decompose the
some type you can just pattern on the
product type inside so in this case in
lines 81 to 84 you can see that we are
matching over the try followers which
are which are is of type try and
whenever it's a success we just return
we just with the dollar sign extract the
value from success and call new function
on fetch with that so we are creating a
new fetch with the integer followers and
whenever the case is failure we are also
extracting the value with a dollar sign
and pass it to the constructor of failed
so the whole expression the whole
statement is a value of remote followers
data we can return just that so knowing
that we now know how to handle this kind
of return type our own return type which
is which is remote followers data so we
just pattern much on it in our control
application what we want to do is to
have a string that we can print on the
console so we just get the followers in
line 46 and then pattern much on remote
followers on remote forwards data
whenever it's not requested we just put
the string
loading for the string and when fetched
we extract again with the dollar
operator function and call to string on
it and whenever is the error message we
just format a new string out of it and
the whole expression again is of type
string
so both a DTS and pattern matching are
built in into scholar language IDT's can
be created using sealed traits
seals means that all the implementation
classes or the case classes that are
extending this interface or interacting
this interface can need to be needed to
be defined in one file so nobody ever
can add a new some new type into our ADT
and that's why I feel this so nice and
the final place class is just a normal
bar with all the hashcode and equals
implemented for you and pattern matching
looks very nearly the same as in the
Java version but it's a syntax another
additional library to everything works
fine and we have our nice application
that's working fine and one night the
telephone starts ringing again this time
it's not our client it's our user turns
out that our application is getting
popular in the galaxy and is starting to
be used as propaganda tool that's not
good
followers count has been used as
propaganda tool so our new user what he
said is that the clones the stormtrooper
clones are counted as followers for
Darth Vader I didn't they shouldn't be
by the way the user is part of the
rebellion of course
so we fire up our computer of course and
we check in IDE what kind of logic do we
have right now in order to count the
followers and it turns out the logic is
like that and we are we are only
returning the size of the list so user
is right it's a back so let's first
create a function a small function that
only takes a citizen and
turns false or true whether it's this
citizen should be counted as followers
follower or not so how this function
should be implemented so if there is a
civilian it should be counted as as
follower the same for Jedi rebel and see
it but for some troopers only the ones
with the flag is cloned false should be
counted as followers so how can we do
that do that how can we use the
knowledge that we've just learned which
is pattern magic started marching to the
rescue so let's call a count function on
this on the list invader the count would
count does it takes a function as a
predicate and whenever the function for
and runs the function against each
element in the list
whenever the function returns boolean
true then it is counted and whenever
it's false it's not counted so this this
fits well into our definition so we
pattern match on F which is just one of
the elements in the list one of the
citizens and whenever it's a
stormtrooper we just extract the first
name then name value and we also extract
the true so whenever it matches the true
we return false and for any other case
in line 19 we just returned true so
that's the whole implementation of the
thing I just described almost exactly
the same thing can be done in scholar of
course but little less verbose as you
may expect so again everything works
fine but one night our telephone starts
ringing and this is our client again he
is not happy and he files a feature
request this time because the
application is pretty stable and so he
says that the Twitter that we that the
users are posting gotten has got to have
gotten some rather some of them got
another political and we went to our
computers fire up the Twitter galactic
Twitter and we can see that some of them
are really rather political it's our
client and he provided initial list for
the censorship module we need to
implement the censorship module but
those tweets cannot just be deleted
they needed need to be manipulated in a
slight way and the rules are defined by
the client this is just initial list as
he said it may change so the rules are
like that first we get a predicate so if
the treat is pro darkside then we do an
action manipulation action on that wit
and so on and so forth but no more than
two manipulations for one tweet so we
took the naive approach right so we just
each rule is a new if block and yeah we
need to keep an eye on manipulation so
we need to count them in the variable
integer and we go on and on so one big
block of code with mutable variables so
can we do better what do you think
can we so whenever we place a problem
like that in strongly tied functional
programming with data to model
everything
so let's model the censorship of
Gordon's as data let's model censorship
filters of data so we need censorship
censorship filter with which contains
two functions first one it should that
which should that would be mine iterated
second one how to manipulate their tweet
so the first is the function from tweet
to million second is from twit to tweet
so what can we do with with such a type
we can create a list and this is the
Java code we can create a list of all
current filters so those pink ones are
the real functions and we just create
new standard filter out of those
functions that are defined in some other
way
few functions but this is just data this
is just a list of some object which
contain a function object so what we can
do with that is we can get an original
tweet and just run through the whole
list of central filters going through
each of the item we call a function with
the tweet current version of the tweet
and the filter that we are executing
right now and we get a new tweet in
return
we do that for every element in the list
and we get a sense of between tweet as a
final value so this is called folding
and to give you some perspective let's
do it for int we have a list of three
ins 4 6 &amp;amp; 3 and initial value is 0 and
we just run the 0 through the list
folding it with a function that sums the
current version current the result with
the element called X and with what we
get we are folding the whole structure
the whole is into final number 13 we can
do that in waver using false left
function Java Java Frankel collections
list has pulled that function and it
takes two parameter the fair the first
one is an initial value the second one
is by function which is a function that
takes two parameters the first one is
the current current result and second
one is the element of the list that we
are currently processing and in our case
the applied filter function the function
that we provide for fault left needs
needs to look like that it's called
applied filter and it takes quit current
version of the TWiT and current filter
we just called should manipulate on the
tweet and return the manipulated to it
in your turn but whenever it shouldn't
be manipulated we should just return the
original to it so this is how it looks
like okay so what we missed so far is
that manipulations right so we only want
to do two manipulations to one tweet so
what we need to do is we need to create
another type which is called sensor
status it has this tweet that we've had
so far but also has integer of
manipulations and what we need to do is
we just need to modify slightly our
apply filter apply filter function it
now takes in line on line 100 to status
and filter and just get to it although
the status and when whenever there is a
manipulation will return a new sensor
status with manipulations implemented so
folding allows us to have state without
any mutable variables
everything here is final so this is the
whole algorithm when you the meet is
over there ninety six six and
seven we just create initial status with
the original tweet and viral
manipulations and we fold left through
the whole censorship list the cool thing
about that is whether whenever the
rebellion is winning or whenever Empire
is winning we can just feature switch on
the list so we just need to change one
line of code we can use rebellion
filters and biofilters whenever one of
them wants some other censorship modules
so we can use just that whenever we
don't want any censorship we can just
provide an empty list so again
everything works fine but one night
again our telephones start swinging
unfortunately who might that be this
time is Uncle Bob so you don't have a
clean code he says and it is a real
person right so he thinks that remote
data the type that we have is highly
coupled with Jason Uncle Bob okay so we
fire up the ID and see that public
interface remote data which is which is
a generic version of remote followers
data that we using the application is
really is really coupled with the Jason
because all the annotations are there
and they take much more space than the
real I think that will row type that's
there for reason some reason so what we
have here we have to come to concerns in
this piece of code so Uncle Bob might be
right the concern number one is that we
want to represent the state of the
database cache right that's why we
created the remote data type and the
second constant is that we want to
sterilize that type into a JSON so that
the web application can consume that so
those are two separate concepts and we
cannot do deal with that in Java
unfortunately but there is a nice
pattern which is called type class
pattern in functional languages and on
the left you can see our current
implementation so remote data is
annotated with all the Jason annotations
so what it does it knows about it being
a JSON response type
and HTTP server of course because it
uses this Jason type annotated remote
data it knows about a remote data and
Jason and on the right side hand right
hand sent with right hand side you can
see that tied class pattern allows us to
decouple those those things so we remote
data is a pure value it only caught it's
only concern is this being a
representation of the state of database
cache and type class is a group of types
that can be used adjacent and this group
of types the class is not the class from
object-oriented it's a group of types
and the HDD server when needs whenever
it needs something of type Jason the
response and it has something of type
Remo data it is a compiler to fetch
something that can convert those things
so we don't have to deal with that in
our code we need to deal with that using
some compiler magic and whenever there
is a member of types of JSON response it
combines fine but when it's not we get a
compiler error so how does it work in
scala so again this is our remote data
pure data type filtrate and for
implementations for our case classes for
products type and pure values as I said
before and now this is an egg a cache
TTP server so the endpoint is called
followers slash a string with citizen
name and then we the require request is
get and whenever the request is get we
can complete it with the list of
followers followers for this citizen
name and I split the line 15 into two so
there's line 15 in 60 so that you can
see the type the type is remote data
this one nice pure type so we get this
remote data type and we just return it
remember scholar doesn't have return so
this is returning remote followers and
we get a compiler error cannot find
Jason writer Jason format for this
remote data type so when we go back to
this slide you can see that this dashed
arrow is the compiler searching for an
instance of type class or member
stationed racing response for remote
data and couldn't find it so we got a
compiler error what we need to do in
some other separate place in the code so
this is not coupled to coupled together
we just provide an implementation of
remote remote data JSON remote data as
JSON format so there's a function that
we do pattern match on and we just we
just provide a jason for each of this
cases of those product types and we use
in line 15 to 18 we use d dot to Jason
what it does it searches for this
particular loading phase fetch note the
requested cooking classes as members of
JSON format so this compiler recursively
goes through the whole list and the most
important things line 13 the highlighted
one is implicit so we just put this
conversion into an implicit scope and
that means that compiler can just fetch
it whenever it needs it so this way this
is how the server looks like there is no
Jason at all this is the final
implementation and this is there is no
Jason at all we just use the thing that
we wanted to use that means the service
get followers service get tweets for and
return them the compiler will do the
conversions for us so again instead of
subtyping which is coupling and instead
of annotating which is also coupling we
can use just we can just use typecast
pattern and those things can live alone
ok everything works fine nobody calls us
again and we can finally sleep well so
this was the pragmatics guide to
functional geekery starring coffeehouse
programmer Darth Vader and Luke
Skywalker
of course Uncle Bob's was also there as
the star guests and the special effects
by future type which is which models
values that may be available in the
future or fail or failures option types
that valve model values that may not be
there and try type that models
computations that may say both of all
three of them can be treated as Mona
and algebraic data types that help us
model reality because reality is very
complex and pattern matching that helps
on view of a DTS because a DTS may get
complex and tight stress pattern that
helps us decouple the concerns from each
other and the squint a is by this github
galactic Twitter repository I encourage
you to look because the Java and Scala
implementations are there and they have
similar functionalities and they do
exactly the same things so you can just
look around and see the differences
between those two implementations and
there are real web servers in Scala and
Java of Arc ICP console applications
pattern matching details so you can see
how this is really implemented in sites
in Java there's more more code than I
shown and remote data data as a functor
so you can see why do we need functor
and why the remote data can be one and
of course pin might my type pattern in
Scala which is adding methods to
existing types police coder have a look
play around the readme is very nice I
explained all the six problems I shown
you in the presentation there and there
are in the comments so that's pretty
much all I wanted to show you my name is
me how this is my blog I work at about
the technology and this is my Twitter
thanks a lot for your attention and are
there any questions yes
okay so the question is why did I choose
choose to use future and not the future
from Stella Frank not theater from from
Java so yeah those guys work together
very very well
option is also the results also optional
in in Java right but a used option from
waiver so they work together very well
and also the the Java Frank one is a DP
so it's it's really implemented as that
inside there are several other
differences and the same for option for
example option in waiver is realizable
and optional in Java is not so there are
there are differences like that but what
I wanted to use really is waiver all the
way without comparing the Java
equivalent I suppose that you can do
both no problem any more questions okay
thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>