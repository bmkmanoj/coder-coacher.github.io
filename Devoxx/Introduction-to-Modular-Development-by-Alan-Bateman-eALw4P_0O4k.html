<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Introduction to Modular Development by Alan Bateman | Coder Coacher - Coaching Coders</title><meta content="Introduction to Modular Development by Alan Bateman - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Introduction to Modular Development by Alan Bateman</b></h2><h5 class="post__date">2016-11-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/eALw4P_0O4k" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello good afternoon my name is Alan
Bateman I work in Oracle on the JDK this
is introduction to modular development
it's a very introductory gentle
introduction to modules and and it's the
first of three sessions that myself and
Mark Reinhold are doing at devoxx this
year so with the introduction now
tomorrow morning we'll be doing an
advanced session which continues on from
this and then tomorrow afternoon mark is
on his own is going to do the very very
advanced under the hood talk so just a
little bit about some of the modularity
background and because you'll see if you
numbers of GSRs and jep's as we go
through these talks there's a there's a
GSR for the module system and jsr 376
and that's targeting JDK 9 mark is
leading that there's a separate jsr for
the for the overall platform java c 9
and jsr 379 mark is also leading that
one are co-leading that one and that
will own the marginalization of the jdk
so this morning mark showed a module
graph I'll show some more module graphs
in this talk today that is the GSR that
essentially owns the standardization of
the the Java dot star modules that you
saw in that graph for the implementation
that we do everything in open JDK and so
the module system itself is being
developed as part of project jigsaw an
open JDK that would be the reference
implementation for the for the module
system within open JDK then everything
that we actually work on at least all
the significant features they're all
tracked by these documents called jep's
our jdk enhancement proposals these are
really really wonderful resources to
actually see all of the features that
are going on in jdk 9 well in the
keynote this morning when mark showed a
big slide
multi-column slide of all the different
features the majority of those have
jep's in there they all out there all of
numbers just for tracking purposes and
they're really really useful and great
resource to see all of the features
that's going on because they're living
documents maintained by those that are
working on those features for the module
system then we all have a whole bunch of
these these jep's
200 201 222 60 to 61 and 282 what these
are about are the
de Graaff the how we organized the
source code in the JDK which is not
really interesting if you're actually
just using the JDK but it's important
for those that are maintaining the JDK
we have the the layout of the the
runtime image if you're at the
University session yesterday we spend a
good bit of time talking about the
layout of the the runtime images that's
jet 220 the module system implementation
has been done with Jeff 260 I'll be
going through in this presentation a
number of command-line options for
compiling and packaging and running
modules this is the jet that you'll find
all the details for these command-line
options and all the other details that I
won't get to in this presentation and
Jeff 282 is is the link or the jailing
tool I'll show a little bit about that
today so one final thing before I get
into this is is JDK 9 is still in
development nothing is final
so just assumed potentially that some of
the things I show and the command-line
options or some of the other concepts
could change by the time JDK 9
eventually ships so part one modular
development starts with a modular
platform I don't have a lot to say about
this slide it's a graph in quotes of
where we were with JDK 7 back in
Jadakiss and it's a graph of all the
components that made up for JDK 7 and
that's a couple of years ago and this is
the four we put in the effort to break
it up into a set of cohesive modules and
a lot of progress has been made by then
since then one thing just to point out
is is even back in JDK 7 when we were
looking at the the structure of the JDK
it was clear that there had to be some
kind of core to the system we called it
at the time maybe the base component of
the base module and that name has stuck
so rolling forward a few years this is
where the module graph is at now these
this is the graph of the standard
modules standard modules and make up the
Java C API all of the standard modules
start with the name JDK dot something
and we also have a whole bunch of other
JDK modules that start with J decade at
something that's where you'll find
things like these are modules that have
two service providers as a fewer
JDK specific api's so a couple things to
point out on this is right down the
bottom you have Java base you can see
that there's no arrows emanating for
Java base that is the core of the system
that is where java.lang object lives and
we see this in many of the the slides as
we go through this a couple other points
about when you look at this graph is
that for the most part it's one
technology per module and the graph is
also extremely hierarchical and that's
really just a consequence of the work
that we did to separate the head full
and headless parts of the platform the
graph is is is a directive graph there's
no cycles and that's really important
when you when you start thinking beyond
the platform as modules and because
we're about module assists are about
module graphs that do not have cycles so
we start with a modular platform and
have a look at what this actually would
actually means for existing applications
so I'm taking a recent build of JDK 9
and just running Java - version on it
this is Bill 142 which if you're
tracking the early access bills was the
week before that so it's it's a guess
it's two weeks old at this point I can
just use it exactly the way same way
that I used it in JDK 7 and all previous
releases in this example I've taken a
Java editor called MJ edit it's it's an
it's a text editor written in Java
that's been around for a long long time
I have absolutely no idea whether the
maintainer zuv J editors have ever tried
J edit on JDK 9 but I just downloaded I
tried it and it starts up and works as
normal the important thing is the class
path and executable jars and the way
you've run applications
it just works the same way as as it
always did now let's have a look at
what's under the cover so we're running
an application exactly the same way as
it always did but the platform is now a
set a set of modules so what I have on
this on this slide here is the output of
Java - - list
- modules this is a new command line
option - the Java launcher which asks it
to list out all of the the the modules
that are in the runtime
and what you can see here is a list of
module names each one of them
corresponds to the node in the graph
that I showed earlier on I've cut this
down a little bit just because there's
about 70 modules that they all don't fit
on the one slide so you've seen their
java base you'll see a whole bunch of
order names in there that you might
recognize as as part of the the Java
platform now I'm gonna I'm gonna drill
down a little bit and I'm gonna start
looking at one or two modules you get an
idea what's in there so first we look at
the list modules Java base so with the
list modules option I can I can I can
give it a sequence of module names and
it will describe those modules in more
details so here what we see is is
there's a whole bunch of exports and
beside each of the exports is is is a
package name and we can see here that
it's exporting all of the core packages
java.lang jvo java net and so on Java
util these are all the core packages in
that are part of the Java C API so one
other thing just I should say is is this
is the first slide or maybe the last
slide was where I'm showing the new
style options
so in jdk 9 we've moved to using new
style of command-line options and so
they're all double dash and for both
options some of these have shortened
versions as well there's a Jeff if you
look up the open JDK Jeff's page which
is all the guidelines for command-line
options going forward for the platform
all the old options work exactly as they
did before we're going forward is we're
trying to use the the canoe style which
is a bit more modern one final thing
about Java based before I move on to the
next slide is you will not see any non
core packages listed out as being
exported by Java base
there's no XML in here there's no java
sequel in here there's no aww tier swing
none of the core packages none of the
none of the non core packages are
exported by the java base module now as
I mentioned Java desktop I'll also show
you the output of of Java list modules
and Java desktop to give you a flavor
for this module
as as which you have a base there's a
bunch of exports here exports from this
module or all of the packages for AWT so
there java.awt java.awt font and so on
also the swing and packages javax.swing
and so on in addition to exports what
you see at the bottom of the slide is
the dependencies that the Java desktop
has on other modules so all of the
platform modules they know the API is
that they export and they also know the
other modules that they depend on when I
showed Java based on the previous slide
there was no requires because Java based
does not depend on any other module the
Java desktop module on the other hand
depends on a bunch of other modules this
happens to be the same module 'mark
showed in the the keynote this morning
so depending the Java desktop module
depends on preferences data transfer XML
and of course the base module every
module depends on the base module and we
see that as we go forward so what where
we are at this point in the presentation
is you just know that the platform is
made up of of of a of a set of modules
that each of those modules knows what
their dependencies are what api's that
are exported and now that we have a
platform that is composed of a set of
modules we can actually combine those
sets that those modules to create our
own runtime images with the linker tool
so the linker tool mark showed this
morning but essentially takes his input
a set of modules that it finds on
something called module path we'll
expand on what that means as we go
forward on the slides you run this tool
and it will create a runtime image like
what what the JDK is like what the GRE
is like what the compact profiles are
but it only contains the the modules
that you're interested in and and the
modules that they transitively depend on
the structure of a runtime image is is
identical and for all runtime images
created by j-link so you'll find a beam
directory with the launchers that's
where you'll find the java launcher if
your modules if you've got the for
example the java rmi module LinkedIn
that's where you'll find thing tools
like our MRI dr my registry and and
other launchers all those exist in
in the in the bin directory all
configuration or user editable
configuration for the JDK and every
module that has configuration all of
that gets put into a contractor II and
we ROCK gonna go through too much on mod
on the the runtime image layout today
but if you if you google for Jeff 220
you've got all the details as to how
this is laid out and how it differs from
the JDK and JRE out of the past so I'm
going to use the the the jailing tool
now to create a runtime image that only
contains the Java desktop module and
it's transitive dependencies so we saw
from the previous slide that the desktop
module has a dependency on four other
modules they will all get linked in by
the tool to create this runtime image so
this is very simple j-link command and
given a module path where it's going to
find modules I'm giving it the set of
modules that I would like included in
the runtime image and are giving it the
output directory where it's going to
create the this this runtime image I'm
going to do with list modules on the
resulting runtime image I see in here
five modules but you have a desktop
module that I asked her to include and
over all of its dependencies so now that
we've got our custom image I will
actually go back and I will rerun the
Java editor that I had RDJ edits that I
ran earlier on I know from looking at
this with tools like Jade EPS and other
static analysis tools that it really
only depends on the desktop api's and
and and the base module so I know that
it should run on this small runtime that
I've created with j-link and voila it
does it just worked exactly as a would
on a full JDK so having the ability to
create runtime images that are just a
small subset of the platforms is a big
step forward for redistribution so that
is part one at a high level we moved
from a big monolith which was that ugly
graph that I showed earlier on to set up
essentially are mostly cohesive modules
every module has a clear set of exports
every module as a clear set of
dependencies when you're using a modular
runtime it works exactly as it did
previously the class path is not going
away
we have no plans to remove the classpath
so you can stay in the class path until
you retire if you really want to and
because we're a set of modules we can
use the jailing tool to create a small
runtime that only has us as a subset of
the platform modules that's a big step
forward so part two introduction to two
modules this is the real gentle
introduction we start back right at the
beginning on waters a module so for this
example we will offer for the example
I'm going to work through I'm going to
have a module and its name is stat score
this is going to be a statistics package
every module has a name the code in a
module is organized by package for this
example all of the code for our
statistics library is going to be in in
in in packages come acme stat score
something i've got two packages in here
clustering and and regression and I've
just shown two example type names in
there the code is all organized by
package modules can additionally include
native code configuration resources I'm
not going to go into these into that
detail in this presentation
the important thing is module as a name
and the code the Java code in that
module is organized by package the
modules self description is expressed in
a module declaration and that module
declaration in in source form is in a
file a source file called module - info
Java and by convention that is placed in
the top-level directory of the libraries
and source tree in this example we've
got we've got the names of two of the
classes in this module cluster and and
linear they're organized by package and
then we see much of that info at the top
level in the Java info dot sorry the
module info dot Java we have used the
module keyword followed by the module
name open curly braces close curly
braces we start filling in the detail as
we work through the slides in a few
minutes but
so it's how we start off in source form
within the module declaration you have
one or more requires clauses where you
that you use to declare a dependency on
other modules for the stats core module
we will have a dependency on guava we
will assume for this presentation that
guava is already a module named guava so
in the module info dot java we have a
required module name semicolon that's
the syntax to express the dependency on
guava every module has a dependency on
Java base I could have put in here
requires Java base because every every
module ultimately depends on on
java.lang object but the compiler does
this automatically so I'm leaving this
out of this the source declarations as I
said built up my my that the examples in
this slides I'm going to be showing a
little dependency graph on the right so
we can see the source form on the left
and we see our dependency graph building
up on the right I'm now going to bring
introduce a second module this is the
stat CLI CLI as in command line
interface we will assume that this is a
module that makes use of stat score so
we'll assume it's some command line tool
that makes use of our statistics library
our statistics module so it has a
dependency on stat score it's named stat
zeolite requires stat score in addition
it has a dependency on Java SQL Java SQL
is the platform module that exports the
the JDBC API all the sequel ap are so
now let's flesh out our module graph a
little bit further and because every
module depends on Java base I've shown
Java base here with just a dotted line
and just to show how the module graph is
is building up and you have a sequel if
I were to explained and what it depends
on we end up with this module graph so
Java sequel depends on Java XML it also
depends on Java logging every one of
those modules depends on Java base when
when one module depends on another we
say the
reads the other module so Java SQL
depends on and reads java xml with javis
SQL depends on on Java logging so we say
that are actually reads Java logging
this readability relationship that we're
going to build up in these slides is the
basis for reliable configuration in the
module system and this important thing
to understand so as we move forward I'm
going to take a subset of the graph of
the of the graph and start adding in
some some code so we can actually
understand some other some additional
concepts so for this we're going to
we're going to start with stat CLI
requires and reads Java SQL which in
turn requires and reads Java logging I
mean I would put some code on these to
see how this what's going what what are
additional concepts we have to add
within the Java SQL module there is a
type Java SQL driver
if you've used JDBC you're probably
already familiar with this class it's a
public class in the java SQL package it
has a it has a public method called get
parent logger that returns a Java util
logging logger
this is a type from the Java logging
module the Java logging module exports
the the logging API as a consumer of the
Java SQL module and the stat CLI module
might have a driver object it might
invoke the get method logger method and
then with method invocation chaining it
in turn invokes the log method so what
you have in this in this slide here is
you have code in the stat CLI module
making a call to a method on a type
that's in the logging module but stats
eli does not depend on the logging
module so how is this going to work now
what we could do is the Java doc for
Java skier L could say if you were
making use of this method please also
have a requires on the Java logging
method that will work but would be very
knowing for every
consumer of this method to have to go
and remember to put in a requires for
this so the way the module system
supports this kind of use case is by
having a modifier on the requires which
is called transitive
in the current JDK 9 builds it has it
has a different name but the current
proposal is this mod of a rule called
transitive so Java sequel has a requires
transitive and Java logging and what
that means is is that that anyone that
depends on Java sequel will actually
read Java logging and this is called
implied readability the importance of
Pride readability is something that that
mark will go through in the end of the
hood talk tomorrow but what it means is
that Mike the consumers of Java sequel
don't need to remember to do anything to
read Java logging they get it for free
by way of the the requires transitive
now we start adding the the the edges to
this graph that are induced by this
implied readability so the black edge
edges in this graph and are my requires
the orange edges are the are the ones
that are added because of the requires
transitive and what I have in this in
this graph here is a readability graph
with just the with just the black edges
I have a dependency graph when I take
readability into account I've ended up
with a readability graph now we move on
to the next concept which is exports so
in addition to having a requires clauses
in a module declaration we can also have
exports clauses and these are used by a
module to export its API the the value
to the are the the what follows the
export is the name of a package all of
the exports are at the granularity of
package so our stats core module exports
to packages come Acme stats core
clustering and cannot come Acme stats
core regression these are these these
are the two packages that are the make
up the API for the scats core module
there may be additional code in order
packages in the module in the slide I
have a package calm acne stats core
internal that can change some
implementation classes we can think of a
module as as being maybe split into two
parts these are the packages with the
API these are internal packages where
I've got implementation that no one
should be making directly direct use of
and exports as we will see are actually
the basis for an encapsulation now that
we've learned a bit about readability
and we've learned about encapsulation
we'll combine these together to
understand accessibility stat CLI reads
the stats core module when it reads the
stats core module that means that it can
access any of the public types in stat
scores exported packages it cannot acts
any of the types in the packages that's
that score has not exported so this
accessibility is really a two-way street
read you've got to read the module and
the module has to export the the
packages with the types that I want to
be able to access if stat CLI did not
read the stats core module it would have
no access to any of the types in that
module if it reads the module it gets
acts as the public types in the exporter
packages if you get this concept then
everything else with modules becomes
easy
the main implication of what I've just
shown you here is is that the assumption
that public means accessible is no
longer true it's now possible to have
public types non exported packages that
are no longer accessible and they under
who talk tomorrow the mark would put a
lot of this into into context so the
next part of the presentation I want to
start building up and some of the get
some of these some of these examples by
compiling packaging and running these
modules for these examples it this is
going to be using the command line so
some of the command line options may
look a little bit complicated
in time there'd be better support in the
idea in maven so you may not see a lot
of these command-line options so we
start with compiling stats core so this
is this is this is calling Java C on the
command line with two command line
options number one is the command line
option - - module dot path which is
where the java c compiler will find
modules when it's looking for them i'll
explain more about the module path in
the next slide the dash D is the
long-standing option in Java C to be
able to specify the output directory and
in terms of source organization these
modules are organized in SRC slash
module name and then the sources so the
module info is the top-level directory
and everything else is organized as it
always was under stat score when you
compile a module it's exactly like
compiling Java code in the past in that
on the left hand side you have the the
the source files in Java on the right
hand side or the output of the compiler
is the dark class files that the java c
compiler or other compilers will
actually produce so when you compile a
module the module into that gets
compiled into a module info sorry a
module info dot Java gets compiled into
a module invoke class so with the stats
core module we will we will compile this
it has a dependency on John on guava
it'll find guava module on the module
path because we will assume for this
presentation that it has already been
compiled and packaged as a module so the
module path M the module path is not a
class path it does not suffer the
problems of the class path and this is
important to understand when searching
for a module Java C the Java launcher
are or any of the other JDK tools will
search the module path M as a path for
the module once they found it they will
no longer and search for any parts of
that module in subsequent directories
you can't have different parts of the
module in different directories you
can't have two modules with the same
name in
same directory because that's ambiguous
there would be no way to tell which
version of that of the module to use so
it's a lot more robust compared to the
typical two-class path and in terms of
artifacts that can be found on the on
the module path then and like the class
path it's it supports jar files
it supports exploded modules we'll see
some of these as we go through it so
we've stat score compiled I'm now going
to angle going to compile stat CLI
remember stat CLI depends on on stat
score it's exactly the same Java C
command except on get em and as input
I'm giving it the source files for the
stat CLI module I've expanded the list
of directories I'm giving to the module
path so that it finds the stats core
module in the previous slide I compiled
stat score into the mods directory the
convention I'm using in these slides is
exploded modules are in them on the mods
directory and packaged modules which
you'll see in the next couple of slides
are in the EM Lib directory as before we
compile from Java to dash to that class
so now that we have the module compiled
our two modules compiled let us run this
and this is initially this will look
like a verbose command to in order to
run this module but let me explain as we
as we go through it so this is the Java
launcher and I'm giving it the module
path option and a dash M option the
module path is where modules will be
located and the dash M module is is
giving the Java launcher two components
the initial module and the name of the
main class we shorten this as we work
through the slides so it'll look a
little bit for both initially but the
important thing is you're you're giving
the Java launcher the starting point the
initial module and the main class within
that module and when we run this the
stat CLI tool will actually start up so
let's see what happens when at run time
when you run this this this module so
our stats here line module from previous
slides depends on stat score it depends
on static
well it also of course it depends on on
Java base we have to compute the
transitive closure to make sure that
there aren't any modules missing from
our from our module graph and we end up
with the same module graph that we had a
few minutes ago so this this computing
the transitive closure and locating all
of these modules is something that
happens at startup when they execute
this module it get transforms into a
readability graph because we're taking
implied readability into account so that
we now the system knows exactly which
modules read other modules if you want
to see more the detail as to what
happens at startup there's a debugging
option on the launcher and X diagnose
daikon resolver which will print out a
whole spew of trace information to give
you an idea where modules are located
why are they located and then a summary
list of all of the modules that are
resolved at startup so that's quite
interesting if you're actually trying to
understand and what's going on at
startup so that's a quick run through
compiling and running the app the the
the the this example module everything
so far is exploded on the file system
and that's not a convenient way of
course to to to publish modules you want
to be able to package those modules up
into into a jar file or some other
format and to make them available to
others so we'll spend a couple of
minutes talking a bit about packaging so
modules can be packaged up with the jar
tool to create what we call a modular
jar a modular jar is exactly like a jar
file a genome for the last twenty years
except that it has a module in photo
class in the top-level directory of the
jar file the jar tool has been is
significantly enhanced in JDK 9 a whole
bunch of new options to be able to
support modules I'm using some of those
those options here and so what we're
doing is is where we're using the new
options on the jar tool to create a jar
file and the - - creates - - file gives
you the name of the jar file I'm setting
the main class as part of of creating
this jar file
and I'm giving you the Josh C option
which is essentially the root directory
where it's going to look going to find
the classes this is that's how jar the
jar tool is always had this option and
the jar tool will create the jar file
which is this oval box I have here all
my class files in the jar file ended in
the jar file the important thing is the
top-level directory of the jar file has
a module in for that class and that
makes it special that makes it a module
info and that's very that makes it a
much a modular jar there's lots of
interesting properties about a modular
jar but one of the most important thing
particularly for migration from JDK to
JDK 9 is is that if the code in its
package up in the jar file is compiled
or an older version of the JDK then it
can actually be placed on the class path
and used as a library exactly as it
would have been with JDK 7 or 8 so and
when you do that then the module info is
ignored by seven and eight and older
versions if you're compiling two really
really old versions but when it's which
a TK 9 is treated as a module when you
deploy it on them on the module path and
that's all part of the migration story
and which we recovered a bit yesterday
and some of the university talks one
other thing about the jar tool is is is
that because it knows about modules now
there's other there's there's options
where you can get it to describe the
module that's in the in in in in the jar
file so if someone gives me a jar file I
can I can run the jar tool with the
print module descriptor option by the
way there's a shortened version of this
very verbose option if you want it and
at a print house if it's a module it'll
print out its module name it'll print
out its dependencies it'll print out its
exports it'll print out its main class
if the main class is set so this is very
useful for inspecting a jar file that
someone might actually give you so we've
packaged up this jar file now into the
EM Lib directory and we will now run the
CLI application from this package module
and we will see that the command line
has shrunk a little bit it's got a
little bit shorter so as before I'm
giving it the module path and where we
reused to find the the module and this
time I'm giving only the
module named - em because them because
the module knows what its main class is
now we've set the main class of
packaging time it means that the the
Java launcher now knows what the main
point at the entry point is on this
module and just execute it so that's
really nice so what I showed so far is
is everything just running on the module
path one important thing to understand
is that and it's possible for migration
purposes to mix the module path and the
class path together and so what I will
do is I will show an example with a jar
file called stats GUI we'll assume this
is this is just a regular jar file it's
not a modular jar I'm not going to put
it on the module path I know from
inspecting the this jar file let's say
using a static analysis tool like the
Jade EPS tool that it depends on stat
score because it's making use of my
stats core library exactly like stat CLI
did it's also making use of the desktop
module because it's a GUI application
there's nothing in that jar file that
indicates what its dependencies are I'm
actually having to use a static analysis
tool to understand this but let's see
what the command line option is and to
run this on the class path but making
use of stat score and guava as modules
so assuming from the bottom up I've
migrated guava and stats quarter modules
but I'm leaving the GUI tool as a
regular jar file on the class path and
this is what the command will look like
this to the number of parts to this but
it's an executable jar
so it's Java dash jar as normal exactly
as it ran with JDK 7 and 8 and but I'm
giving it a module path where it's going
to find the stat score and its
dependencies and additionally I'm having
to give us this curious option add
modules so what's going on here is is
that there is nothing in the in the
stats GUI jar file to indicate what is
dependencies are you have to help the
system by telling it which modules you
want to resolve
there could be a thousand modules
packaged up in the EM Lib directory the
system has no idea which one of those
modules are going to be used by this
application on the class path so you
have to help us by by giving it the add
modules and with the names of the
modules that you want resolved in this
case it's stat score because I know that
my GUI application needs the stats core
module I don't have to be too concerned
about the modules that are in the
runtime image they will be resolved by
by by default for free if you like so
now let's go further and we bring back
the jailing tool that I showed earlier
on in the presentation what I'm going to
do here is I'm going to use the jailing
tool I'm going back to the stat CLI
module which we compiled and packaged
earlier on and I'm going to create a
runtime image that includes a stat CLI
module so the jail income command I'm
using I'm giving it the module path as
before this is two parts to the module
sorry three parts of the module path and
this one it need only need two but and
the location of the jdk modules which
are in the jdk mods directory mods
directory my package modules that I have
in my EM Lib directory that we've
created I'm giving the add modules an
option to give it the names of the route
modules that I want to linked into the
into the runtime image and then the name
of the output directory so when I create
that at runtime image
I run the list modules and I get the
list of the modules that are included in
the in the runtime image I end up with
four seven modules my stat CLI module
because that's what I wanted put into
this runtime image it's its dependencies
that score it depends on Stan
guava as a module and then there's a
couple of a small number of platform
modules that also gets included into it
so that's really really nice and that is
the end of this presentation and it's a
brief presentation I say we were on
again tomorrow and with
a continuation of this but the main
thing to take from this presentation is
the basic concepts and dependencies
readability and and and exports and
understand how they go together to and
understand how accessibility is being
extended to modules in magician you've
got a flavor for some of the
command-line options so you can see how
modules are compiled packaged run and if
you want to you can link them as well
so more information and as I said at the
beginning this presentation we're
working on the implementation of the
module system in project jigsaw so this
is the project page the mailing list and
where the early access bills are and
they're the Jutes are early access bills
are a little bit ahead of the JDK 9 or
early access bills so if you've been
trying those out then there's a few
additional things that are still in
proposal still not final stage in the
jigsaw early access build system and
it's a lot more bleeding edge and that
is it and I think Marco rhino is going
to join me for questions if there's any
questions so I don't know whether
there's a microphone here and I cannot
see people because I'm blinded by the
light and so if there's people up there
you'll have to shout or find a
microphone
okay so I think the question is is if
there was two versions of guava they're
placed in different directories on the
module path then which one of them will
be used is that correct okay right so
the way the module path works is is the
when it goes and searches for module
guava it'll search in directory one if
it finds it there that's it it will no
longer search for any other versions of
guava so on the command line you can
only have it will only find ever find
one version of guava okay on the command
line you cannot use multiple versions of
the same library it's no different from
the classpath that way well the
classified will allow you to mix them
but that's that we're avoiding those
kind of problems with the module system
right so the question is is in the
module info can you specify the version
that can you declare the version that
you want and the answer is no if there's
it requires gives you the module name
it's up to the build tools to and to do
all the version selection and unarranged
module path accordingly you want to add
to that mark weight if you ever quit can
you please go up to the mic by that
light stand over there it makes it much
easier for us no no no there's a mic you
need to talk into that works great thank
you
please stand by I I'm just I'm near so
many technology fails today it's just
bad karma I think a patch cord okay
yeah okay I think it's working great
thank you
not sure if it's an introduction
question but it kind of relates to the
question just posed with the version
info not being in does it also mean that
it's a development time only feature so
it doesn't do anything like OSGi in app
servers where at runtime modules are
pulled together to create a platform
that's modular and where apps actually
share libraries does that make sense
well and Marx talked tomorrow on under
the hood it would go through a number of
advanced topics including the
possibility of having and you know
different applications running in the
same VM that are actually using
different versions of the same name
module and that's all a very advanced
topic and it's covered tomorrow and I
did not catch the second part of that
question
well one potential misapprehension I'd
like to correct is the model system is
operative apps both compile-time and
run-time we've taken some pains to
ensure fidelity make the two two phases
work almost exactly alike there's minor
differences that are there for migration
and compatibility so the moderate this
is not a build time module system it's
in a certain in a certain sense it's
more active at runtime than OSGi is
because heck the VM knows it knows about
your modules now whereas in OSGi it's
just class loaders so it very much is
active at runtime the fact that it's not
doing version selection is well it
doesn't do with my compile time it
doesn't do them at run time either the
view the view we've taken we made a
simplifying assumption a couple of years
ago that has actually worked out very
well
version selection is the present work is
more properly the domain of built
items and container applications it's
not the domain of a module system in the
Java platform as it exists today if we
were designing this 20 years ago when
Java was new maybe version selection
would be part of the solution but today
it doesn't make sense what what would it
be like you know a Gradle does does
resolution in like five different
configurable ways maven has all its
heuristics
what would the model system do to try to
unify all that it's an impossible
problem to solve so that's why we don't
do version selection ok it makes sense
thanks sure yeah there's a microphone up
there please walk basically we're lazy
we don't repeat your questions and you
don't want us to repeat your questions
because we will probably distort them so
can the same class be they can add in
two different modules now well sure but
they just better not ever meet in the
dark alley okay so it's the model system
will ensure that they don't conflict but
when class casting and serializing all
the module pass goes into it also sorry
I didn't understand that when you're
serializing stuff you get all the class
and class load of stuff into the header
and I would assume that the module
parcels are going there now the module
path is not recorded when you serialized
a serialization continues to work just
like it does today
okay serializes names of classes and
when you deserialize you better be an
environment where all this classes are
still available hence one of the main
factors that make serialization brittle
additionally because the because of the
reliable configuration is at least in
the simple environment you're not going
to have multiple versions of these
classes actually in the runtime anyway
so they're not going to get serialize
are deserialized
when you have a current Java eight
applications what are the main benefits
of migrating it to be a module you take
this one this is the good high-level
questions mark if good somewhere by the
way at the keynote this morning please
go watch the kena video reliable
configuration strong encapsulation
that's it in a nutshell reliable
configuration which you don't get on the
class path so you will never get
components defining classes and packages
that conflict with each other you'll
know if something is missing up front
rather than you know ten minutes or ten
days later in production when your
application went to load some class that
turns out isn't on the class path strong
encapsulation internals of your
components can actually be encapsulated
so that you can change them without
having to worry about somebody else
depending upon them it's also helpful
for the platform too because it means we
can encapsulate the internals of the JDK
so that we can change them and move the
platform forward without without having
to be compatible with all of the bad
mistakes of the past how's that well so
seems to me like when you're having but
you're making your own application
rather than a library you expect to be
used by another module it doesn't really
add much value no it's it still
definitely adds value because you you
can now determine from your application
you know when you write your application
as a module or a set of modules you know
exactly what it is that it's using
rather than it then having to trust your
build system and your deployers to
preserve all the other jar files and
stick them on the class path that may be
even in the right order in order to keep
your application going your application
module now self describes what it me
exactly what it needs so that's that
actually is an improvement it also lets
use tool tools like J link which you
can't use you can't J link a class path
application the linker needs them what
the information around them around the
information that it gets from modules
you also if you want to use the Deo T
technology that's going to nine you
any modules it's it's very hard to do a
decent job of ahead of time compilation
that native code from the classpath
because it is so chaotic by the way if
you just use the examples from this
presentation is I would not have been
able to start up that stat CLI
application if any of the modules were
missing and if I made a mistake and I
had code in the stats Eli that was
trying to make use of some of these
internal packages in the Indus that's
core example it wouldn't have compiled
it wouldn't have run all of those things
would have been caught and there's a
whole bunch of other things that can be
caught as well and with the module
system classes that are not exported and
can they conflict if they're in
different modules
it depends yes it so it's a it's a
compatibility constraint of class
loaders as they exist and have been
specified for 20 years the class letter
can't know about a class about the class
with the same name that in the same
package came to know about more than one
of them so if you load multiple modules
into the same class loader which is what
you get from just the regular module
path on the command line then no you
can't you can't do that but if you play
just even just a slightly more
sophisticated game and create a layer
for your own modules you can when you
make that layer you can request that
every mod will get its own class loader
in which case you can have unexplored
packages with the same name even the
same class names and as long as the mod
those models don't depend upon each
other actually even if they do depend on
each other it'll work but they have to
be in different class loaders for that
to happen so it's possible to arrange
but it's not the default behavior
so when you're declaring boards in a
Java class today you can do this star
like Java dot C code of star would it be
possible in the future to import a
module and not having to repeat several
classes again you're talking about and
if you require module not having to
import specific types you're writing a
Java class let's say on the top there's
the imports right it's instead of
important several classes you will be
able to say this class is gonna use
classes from this module so you wouldn't
have to repeat the classes is that gonna
be something that you cannot do in the
future
not part of the present design not
something we've considered and there's
no repeating of classes anyway because
in the module declaration it sits at the
level of module and the imports any
specific source file or the level of of
type of type or wildcard which is
effectively a package right but know
that we yeah we haven't considered
changing how imports work at the at the
class level in in general it is kind of
a best practice to import specific
classes and have a have an ID help you
maintain that list so yeah it's not
clear that that allowing that would
actually be a good idea I mean if you're
really super lazy maybe but
anybody else you're all just standing up
there waiting to escape 9 minutes left
there please I was just wondering the
IDI the optional transitive keyboard
when defining a requirement why should
it not be the default behavior for the
implied readability oh because suppose
I've got some logging in my own library
I'm not exposing it in the API it's just
an implementation detail I don't want my
consumers to be reading that module just
because I'm using it in my
implementation they say basically when
you export a package you're making a
commitment to modules that rely upon
your module that that will be exported
and if you care about comital
compatibility you'll be exporting it
forever and you won't be changing its
content in an incompatible way when you
do a requires transitive on some other
module you are making a promise to your
modules consumers that oh yeah that
module over there I trust it and you
should know about it and you should feel
free to use it whereas if your module is
is requiring some other module just for
its internal implementation you it's a
good idea just as it's a good idea to it
to encapsulate your internal code so
that you can change it without having to
worry about somebody else depending on
it it's a good idea to in a sense
encapsulate your dependences on other
modules if you're using some other model
just for your implementation it's not
part of your API then nobody outside
should know about it and that gives you
the freedom to change it maybe depend on
some completely different module in
future without breaking the consumer's
of your module but when you're using
very common functionalities that are
packaging packaging modules like logging
etc shouldn't it always be be transitive
well it might be common it
it may be common in some kinds of cases
like a commonly used one commonly used
library that's using another commonly
used library and it's got all with all
those things in it's using a bunch of
types from you know one at one in the
other but making it the making of the
default would risk too much exposure
basically so is that that's why we've
we've chosen to make it not the default
but something that you actually asked
for because it would in a sense be what
occurred love encourage a bunch of bad
practice and lead to trouble down the
road if it were the default
of course it's just implementation
detail how do you avoid name is risk
collisions good governance how do you
avoid namespace collisions name is
choose good just choose good names and
is there any convention you have to
follow you mean you mean that the the
namespace for module names yeah that's a
good question it's been a been a topic
of some discussion in in some early
documents we we were encouraging people
to use reverse DNS it's not clear that's
that that's a great idea it I think it
is a still a good idea for for package
names but because of the way that
automatic modules work you know probably
a lot of a lot of existing jar files
will be used as modules you know 13th of
Jackson core Jackson - cor - 2.66 jar is
the automatic module called Jackson core
now hopefully the Jackson maintainer x'
if and when they migrate those you know
they're their components - modules they
will you know if they have their users
in mind they will call that module
Jackson core rather than you know comm
dot faster on XML dot blah blah blah
which is kind of a mouthful anyway
another aspect of the whole naming issue
is that we expect build systems to be
sort of intermediaries between the names
of modules which can be short and fairly
simple and the name
and group IDs and all the other
complexities that you find in a system
like maven central so I think that the
guidance on module names we're still
trying to figure out the best way to
explain it doing full-on reverse DNS is
probably overkill things that are you
know maybe project name dot component
and maybe dot some sub component if you
need it is probably a good good
convention if your project name happens
to you know it happens to be a name a
DNS name you know with a TLD we'll just
drop the TLD right if Jackie if there
were jackson org which is where you
found jackson they just drop the orgies
jackson them well that's kind of you
know that that's got some promise of
being unique anyway but no it's a tough
problem but i and unlike the case with
package names the build systems can in
inter mediate an add a little of
indirection with the actually have the
names of modules versus the following
group ID artifact ID type thing that you
that you need in maven and help you deal
with conflicts so naming is it maybe you
need having unique unique names for
modules is a little bit less important
make sense
not really but you'll take it ok
three minutes left any more questions
last question I think we're done all
right all right</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>