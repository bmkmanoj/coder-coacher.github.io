<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Keynote Session by Mark Reinhold and Brian Goetz | Coder Coacher - Coaching Coders</title><meta content="Keynote Session by Mark Reinhold and Brian Goetz - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Keynote Session by Mark Reinhold and Brian Goetz</b></h2><h5 class="post__date">2016-11-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/e9eSPtpiGkA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning I'm mark Reinhold Bryan
gets my colleague will be joining me in
a little bit we are going to talk about
Java 9 and maybe some some about what
might be in 10 11 12 we're not sure
we're not making any commitments beyond
what is going to be 9 has a lot of
features in it there are some features
believe it or not that don't involve
jigsaw what do we have we have we have
very bit variable handles of our handles
we have compact strings we've got oh
we're taking away sha-1 certificates
those are those are not a good idea to
use anymore
we have even we even have for those of
you really want it an s3 90 port for
Linux who's been waiting for that well
anyway a lot of people are actually
really psyched
beam into annotations osep stapling we
apparently have both unicode 7 and
unicode 8 yeah we've been working on
this release for a while now haven't we
so lots of good stuff that doesn't
involve jigsaw I want to show you one
particular thing that is sort of the
sleeper feature of the release J shell
the read eval print loop for Java now
let me see if I can switch to this box
yay and actually show a demo so here I
have a freshly minted JDK 9 build it's
actually the jigsaw prototype build I
built it on the serie machines just a
couple of days ago so it's got all the
latest goodness in it J shell I type J
shell and it starts up J shell is an
interactive Java shell you type little
snippets of Java code at it and it
evaluates them in real time and tells
you the result it doesn't need to ask
IBM Watson or some Google tensorflow
thing it's exactly doing all the work on
its own this machine is not connected to
the network right now no neural nets
involved so one plus one that's two okay
that's the second I think can declare a
variable let's say I paint I equals zero
no zero mark I
right a little loop let's increment that
okay there we go
no eyes 10 woohoo okay so this is like
not much more than a calculator at this
point what's really cool about J shell
is I can use it to explore an API so
let's say I got a string I'm gonna make
a string the canonical example string
there's my string if I type X and then
dot and then hit tab it will show me all
the methods I can invoke upon this
string object now that should look
familiar right lots of useful methods I
can say okay suppose I want to take a
sub strings sub string get tab ok the
completes openweight sub sequence now I
want substring get tab now if I if I
shift tab it shows me there are two
overloads of the method called substring
one takes one int and the other takes
two int so and as you can also see if
you're paying attention there's there's
command history and all kinds of other
command line goodness here substring
four seven I get this ring bar let me do
something else with X I'm gonna split it
off let's say well split it on on space
and what do I get back I get back an
array of three strings foo and bar and
as you might have noticed this dollar
sign notation dollar eight there that's
a pseudo variable so I can type dollar
eight and that refers to the value of
that previous snippet so let me convert
that that string array into a list type
list string l equals arrays dot as list
complete that dollar eight now I've got
a list okay what can I do with the list
well yeah I can do all kinds of things
on the list I can ask how big it is and
you know stuff like that
one of the cooler things I can do as of
Java eight of course is I can make a
stream like a stream let's remind
ourselves with them in their food bar
and bass stream and say I want to filter
that suppose I want to find just the
strings that start with the letter B
right simple computation no neural nets
required a filter I'm going to type in a
predicate a little lambda expression and
nothing even the inside this lambda
expression it will do sensible tab
completion so as Todd starts with starts
with is going to
be closed that off and I get I get some
stream some Stream pipeline thingy that
Brian wrote I don't understand that I
just want to collect this back into a
list of lists of strings so I go back in
my history I say collect and I want it I
need a collector so I'm gonna go to the
collectors utility class if I can spell
it
collector oh wait no I don't want a
collection I don't want collections I
want a collector the problem is it's not
in scope so I go over here and I import
java.util stream star and now collectors
dot to say list and boom barn des there
you go so JC shell it's all about
exploratory programming right for for 20
years now it's in the case with Java if
you just want to check something
something a little out and you're too
lazy to go just reason about it from the
Java doc we're gonna rush whatever you
create an X dot Java file or whatever
you call it in your ID and you compile
it then you run them then you change it
and you until you finally understand the
API you're trying to work with with
Rachel you just start it up and type at
it and it shows you the results it's
incredibly useful this is by no means
meant to be a replacement for for IDs or
other tools it's right rather it's it's
a compliment it's not a debugger even
though in some ways it looks a little
bit like okay switching back here now of
course I do have to talk about jigsaw
but don't I
so jigsaw has been this this
long-running project we've been working
on it for for many years to solve an
incredibly hard problem we were trying
to design a model system for the Java
platform which can be applied to the
platform itself to make a modular
configurable platform and which is also
approachable so that you can use it with
your own libraries and applications to
escape from the brittle hell that is the
class path in the proposed design
modules have have have it really comes
down to two fundamental properties
modules have reliable configuration so
module names the other modules upon
which it depends so that a compile time
it runs
we can find all of the other models
needed to compile or run it and avoid
duplicates and conflicts and and all the
messiness that we find on the classpath
the other critical property is strong
encapsulation so a module declares
exactly which of its packages are
exported for use by other modules for
whatever module might happen to depend
upon it at some future time the internal
implementation details are finally
something that we can truly keep
internal and this makes for more
maintainable systems over time so the
module system in in jigsaw 9 is not it's
not a library or framework that just is
sitting on top of the platform it's
actually deeply embedded in the platform
itself modules are a fundamental new
construct in the programming language
they're understood at a very deep level
in the virtual machine so let's take a
look at that and we'll go back to J
shelf to get started so remember we've
got this string X okay we're gonna do a
little little reflection magic here X
what what class is X an instance of well
we all know what this is gonna say right
it's an instance of java.lang string
well in nine with the module system with
the module system every class is loaded
by a class loader into a specific module
so I can now ask of a class what module
is it in so the string class is in a
module called called Java based Java dot
base is the fundamental module in the
system it contains all the core things
java.lang object drop a link string you
know the stuff that you just can't get
on without plus some other stuff besides
that was too hard to separate out
frankly there are a bunch of other
modules let's make a make an object in
some other place Java let's make a job a
sequel timestamp 0 whoops ok
the epoch the beginning of time what
it's unlike we know what its class will
be it'll be it'll be timestamp that's
easy what module is it is it in it's in
the job at a sequel module at some other
module in the system in fact there are a
whole bunch of modules in the system
let's break out of jail there are some
additional options
the Java launcher I can ask it what
modules are observable and I get back oh
I get a whole long list
I get since actually quite a long list
isn't it there are 73 modules in a JDK 9
build let's take a look at some of those
so a bunch of modules start with JAV a
because they define standard exported
api's that that are you know supported
long term compatible all got all of that
good stuff there are a bunch of modules
starting with the letters JDK which are
for the most part implementation
internals or in some cases JDK specific
api's that aren't part of the java c
standard but are actually things that
you can use so we see jumping up bases
up there we've got scripting we've got
you know J shell itself is in is under
JDK specific module management
everybody's favorite logging API and of
course corba because you can't live
without that okay so we've got all these
modules but of course they're more than
a list remember every module names the
other modules upon which it depends
except for the base model because it
doesn't bend on inning and that it of
course induces a graph whoops let me get
into the right directory since I had to
reboot there is the module graph so this
is the graph of just the Java modules
plus one JDK model it snuck in there for
obscure reasons this doesn't look as
pretty as graphs I've shown before
there's a reason for that the reason for
that is this is generated automatically
by the bill the bill generates a dot
file but that is this graph and this is
just the rendering of that graph in into
a PNG so we've got the base module down
at the bottom as I said it doesn't
depend on anything else
logging depends on base and security SAS
all depends on logging and base and all
this other stuff so you can see there's
a very rich structure here and it took a
long time to get to this structure
because of course the JDK grew up is
this model mythic thing over 20 years
where lots of stuff was connected to a
lot of other stuff and it took a lot of
effort to decompose all that and make it
sane alright so we have a module graph
we have a modular platform
what about code that exists today can I
run code that it exists
today or do I have to go change it well
it would sort of kill one of the
fundamental values of the Java platform
if you had to go change your code in
fact if you have old code that uses only
Java SE standard api's it will still
work let me show you an example does
anybody remember swing set swing set
George George remembers swing that he
wrote the tooltips for it so swing set
was was one of the demos in in in Java
1.2 originally to demonstrate such a
swing it was updated swing set 2 in some
release this is a an exact copy of swing
set 2 from JDK 5 shipped in 2004 and I
can run it tada
oh the good old days swing set - the
metal look and feel everybody remembers
this write all this all this great stuff
it's excellent we even have the famous
bouncing babies I think some of these
kids are in college by now so there we
go so old old stuff continues to work in
some cases it won't work and that's
usually when the old stuff is referring
to JDK internal API is that we've been
telling people for 20 years not to use
so sorry there are command-line
workarounds that will let you get back
to those a few of them are so popular
some risk unsafe that they're actually
still there with at least for a little
while but anyway so yes what the model
our platform it's modular it's
compatible and another really cool thing
is it's configurable remember we've got
this module graph right
so given this module graph we can reason
about well what are logical subsets of
the system what if we wanted just a few
modules in the module the modules that
name they need and we want it we wanted
to like try to do without you know Korba
and XML web services and stuff well we
can do that there's a new tool there's a
new tool called jailing Java finally has
a linker something I wondered about when
I started working on Java 20 years ago
where's the linker well there wasn't he
didn't need one mark it's dynamic
linking bozo well we have a linker now
it's an optional build step and you can
use it to make your own custom runtime
image if you look in the JDK build
here's the one I'm using
with what I'm using here if I can type
yes right it looks kind of familiar
there's a bin directory and an include
directory and other stuff and there's
also this j-mods directory right here so
in that directory are a bunch of J mod
files they're basically jar files on
steroids that contain classes and native
code and other stuff that you need to
build a JDK component we can take
subsets of those with with J links so I
tell J link where to find modules by
telling it the module path
JJ mods I'm just start off I'm gonna
make a minimal runtime image it just
contains the base module so add modules
about our base I'll put that into sage
or Jerry base it will go off and do some
computation no nurlan that's involved
and I have Jerry base which is you know
it's it's smaller it only contains a few
things if I ask how big things are well
this whole JDK build is 513 Meg's almost
it's just big Jerry base with just the
base module in it is only 45 and it
still has useful stuff in it so Jerry
base Ben Java list modules it only has
the base module well that's good that's
what I asked for
if we can actually actually ask for the
details what's in Java base and you can
see it actually it exports a fair amount
of stuff it has not just Java dot line
but Java IO and annotate some annotation
stuff and basic networking and new i/o
and security so you can actually write
very useful applications just with Java
code base but of course some things you
won't be able to do for example you
can't run swing set
why can't you run swing set well because
the swing classes aren't their 2d
classes aren't there because it's just
the base module we could of course make
a custom image that contains the desktop
model here which has swing and AWT and
that's actually very easy let me do this
I'm gonna make a desktop
Jerry I'll ask it for Java desktop I
don't need to ask it for bass cuz just
desktop will pull bass in for me J like
that how big are the results well the
desktop image is it's a little bit
bigger than the than just the base image
but it's still way smaller than the
entire JDK and given Jerry desktop let's
see in Java list modules we got the
desktop module plus a few others we
didn't ask for now why are those there
they're there because they're employed
by the monograph because the desktop
module here says that it requires the
prefs module and it requires the data
transfer model the prefs module requires
XML and of course everything requires
Java dot base so that's why we got that
other stuff now there's one other cool
j-link drink trick I'd like to show you
J link has an experimental plug-in API
and a number of built-in plugins with
those plugins you can do cool stuff such
as compress the image that you're
producing so I'll go back to this Jalen
command I'm gonna make a compressed
desktop image so it's gonna have a same
content but I'm going to compress the
class files I'm going to use a smaller
VM that emits some of the serviceability
features to save space and I'll also
strip the debug information now if this
is of course gonna take a little more
time because it's doing a bunch of
depression but still no neural Nets get
your Twitter there we go
whoops no not bad
do you RJ and jerry's star okay the
compressed desktop image is only 31
megabytes that's smaller than the unrest
base image and of course it's still
perfectly capable of running our beloved
swing set by now George is thinking oh
my god you stop okay that's that's a let
the last we'll see if swings goodbye
swing set it's it's been lovely okay so
the modular platform the platform is not
isn't is no modular it's compatible its
configurable and it's also approachable
it's something that you can use we
believe gone to gone to some pains to
make it you know fairly easy to reason
about so that you can build complex
systems out of it and understand what's
going to going on so I'd like to like to
show you a very simple modular
application I'll crank up my favorite
IDE here called Emacs
I've got a data file this is a file of
tweets in in Jason so it's you know it's
Jason it's not particularly readable but
all the data is there this is what you
can get from from the firehose if you if
you ask it nicely I wrote a little
little tiny application to display this
in a more tasteful form
it's called tweets um and it's got just
a couple of classes it's got a main
class here we go I'm using Jackson the
Jackson libraries for for parsing Jason
and doing data binding this is all
pretty straightforward stuff I make an
object mapper I configure it I make my
parcel list of tweets from system in and
then I print them in a somewhat more
tasteful fashion on system out every
tweet is represented by an instance of
this class called tweet logically enough
which has some annotations in it to
identify a private field for timestamp
and another private field whoops that's
not good for the text of each tweet and
any other any other Jason fields are are
just ignored so I could compile but the
main class in the gwee class in the
normal ways to come on the class path
run it and it would work right but
we want to see how to make it into a
little modular application to do that we
need to write what's called a module
declaration remember modules are a
fundamental new construct in the
language understood by the virtual
machine we do a module declaration in a
file called module info table Java at
the root of the package hierarchy of
each module in module info Java I say
I'm making a module I'm gonna call it
tweets um and what do we need to know
about a module well remember it reliable
encapsulation
sorry falafels configuration strong
encapsulation for strong encapsulation
we wouldn't need to say what are we
gonna export well this is just an
application module it's not gonna export
anything that's fine we do need to say
what other modules does it need well to
figure out what other modules it needs
let's reason about that a little like
I'm gonna say requires I could say
requires Java dot base here because we
always need the base module but in fact
since you always need the base module
you don't say that the compiler will
insert it for you to get going on this
let's look at some of our imports that's
often gives you a good clue so here we
need to import we're using the sequel
timestamp class so we're gonna require
that sequel module we saw a little bit
of that earlier we also need let's say
we've got these Jackson annotations
Jackson and Jackson annotations huh what
wait a minute I don't have these in
modules I mean all I've got here in my
my Lib directory are these Jackson jar
files they're not modules they're just
our files I got off maven central
they're actually from a slightly old
release they're probably never gonna be
converted to modules I could go in and
convert them myself but then I'm messing
with somebody else's jar files and and
that's kind of gross and hard to
maintain so the module system has a
concept to help with this right it's
really important to be able to write
modular applications that can depend
upon components that have not yet
themselves been authorized so we do that
with this notion of automatic modules if
you have a set of jar files and they're
reasonably well-formed they don't have
conflicting packages or classes or any
of that ugly sort of stuff you can take
those jar files put them on the module
path and the module system will
synthesize module declarations for them
at runtime for free
so in many cases today's jars are just
tomorrow's modules without any change so
that's actually pretty cool so the names
of the modules are derived from the
names of the jar files we even get the
version information in there so Jackson
- annotations - 26.6 jar becomes a
module called Jackson annotations and so
on for the other so I can now go back
into Emacs and write let's see I need
jackson annotations I'm gonna need
Jackson core that's used in the main
class and I will also need Jackson data
by now I'm almost done I could compile
this and it would compile but at run
time it would fail for a detail that's
that's worth explaining the tweet class
remember has these private fields in it
Jackson data binding library is gonna go
use reflection and thus accessible
method to break into those private
fields to set them to useful values we
want that to happen but by default
everything is strongly encapsulated we
don't do anything else then that will
fail at run time but of course we want
it to work right reflective frameworks
are a fundamental part of life and Java
there has to be a way to make those work
so we have a concept of open modules you
can declare a module that a module is
open that means that its packages are
available for such a deep reflection at
runtime but you cannot compile against
them they're still completely strongly
encapsulated at compile time if you want
to you can open specific packages in
this case I've just opened an entire
module all right so we're finally ready
to compile this Java C just like the
Luke Java launcher takes a module path
we're gonna put in our automatic modules
compiling a module is a little different
than compiling for a class path we're
gonna put the output in a directory
called mods I need to tell it with a
module source path is source and then
finally this is my my complex ID food
here let's just say and that'll go off
and compile there we go
now I've got mods unlike a classes
directory that every every entry in the
mods
rectory represents an entire module so
it's named after the module itself and
if I look inside mods I'll see I've got
I've got the main class compiled in the
twe class compiled and the module info
of course it compiles into a class
called module info class which is
understood by the VM and the runtime
system and now I can finally run this
stuff module path Lib and of course I
need to tell it where the modules are I
tell it what module to run is going to
be the tweets a module within the tweets
on module I need to tell where the main
classes of the main classes or dot tweet
some main and I give it the input file
and boom pretty list of tweets from a
tiny modular application so I can go
further with this I can make I can make
a custom link runtime image if i hack
around a little bit more but time is
short so I will stop there so I've
showed you a bunch of stuff from jigsaw
it's it's real it works it lives it has
some important essential features its
scalable the platform is scalable the
model system is scalable the result is
compatible the system is configurable
and we're looking at the wrong screen
sorry and and it's approachable it's
it's it's a design for mortal more
making over more of the portal
developers to use you can learn a whole
lot more about it we've got a bunch of
jets in OpenJDK that described the
details there's an entire jsr of 376 for
the module system itself we are doing
three sessions here this week my
colleague Alan Bateman and I
introduction to modular development at
310 this afternoon advanced modular
development 9:30 tomorrow morning and
project jigsaw under the hood a deep
dive into the theory of the model system
tomorrow afternoon at 3:10 so that's
some stuff in 9 some stuff other than
jigsaw that's a nine not nine is slated
to ship in the summer
reasonably confident in that date but it
is software let's talk about stuff later
than nine not in any particularly
release necessarily and here's Brian
gets to help us without right so what
have you been hacking on so for the for
the last couple Barrett versions we've
been focusing mostly on big big things
like lambda in jigsaw um and we you know
we we realized that we also need to
focus a little bit on some sanding off
the rough edges yeah sending off the
rough edges that just you know improve
every day develop productivity and so
looking at typical developer pain points
you know one of the biggest pain points
that developers complain about all the
time is Oh job as verbose so much
boilerplate is there anything you can do
about that
no but kinda have a point yeah they do
have a point they do have a point and
we've been ignoring it for a long time
and then we should do something about it
so we've got a couple small features
coming up in the pipeline that hopefully
should sand off some these rough edges
and I'll you know show you two of them
today okay what's the first one so the
the first one is about odd that what I
think is the the you know biggest source
of boilerplate in Java which is simple
domain classes pojos pojos dumb data
carriers that look like I had in the
tweets thingy private this yet this
exactly you know so these have you know
to use my favorite phrase an undesirable
beef to bun ratio and so if you have you
know your typical typical main class
like this XY point really you'd like for
this to be the whole thing because
that's really all the beef there is yes
but when you go to write this class you
also have to write a constructor and n
equals and a hash code and a to spray
and your ID could read that for you but
then you'd still to read it because yeah
reading code is more important than
writing code and so even though the IDE
makes short work of writing it you know
that's still a lot of code to look at
and and and say oh that's just an XY
point so it would be nice to be able to
communicate to the compiler that I'm
just a dumb data class all I've gotten
is X&amp;amp;Y fields and and and you would just
automatically acquire all of these all
of these code artifacts okay like like
this and so this is a possible syntax
where you're saying you move to move the
principal fields up into the into the
class header and you automatically get
constructor equals ten so what does he
wanted some non default
you just put them right in okay right so
then the only thing that you see is
actual beef so that's something that the
that the author has decided as an
important part of the class
now the Devils in the details right
because like you know if you want to
tweak the behavior of equals or
something like that you don't want to
have to rewrite the whole equals method
right so we've also got some other sort
of smaller features that go below this
to try to I you know to address that
we're still working on that but it's
showing it should be a big help okay
what's the second one all right so the
other one is expanding the scope of type
inference so we're big fans of type
inference you know lots of people still
say job it doesn't have type er I'm
sorry you're just wrong it drives me
crazy we've had type inference since
Java five but the you know so type
inference is we really like it because
it allows you to eliminate redundancy
from your code while maintaining the
benefits of strong static typing and so
you know we started with type inference
in Java five inferring the types of
generic method type parameters so
instead of having to explicitly say you
know string here when making an empty
list of strings the compiler just just
infers and in fact a lot of people don't
even know about the first syntax because
the inference works you know pretty much
all the time here yo and in Java 7 we
decided to expand the scope of type
inference to all constructors with the
so called diamond feature so here you
know I'll used to have to explicitly say
list of string new ArrayList of string
but we realized that there's no reason
to have to say that twice the compiler
can figure that out and so and so you
know we kept going and Java eight when
we added land expressions you could have
the types of a lambda for lambda formals
be explicit or you could have the
compiler figure them out for you from
context then most of the time it can I
don't think I've ever typed a land that
Landon had to declare the you do it once
in a while sometimes you need to but
most of the time you don't and that's
perfectly readable and so we think that
a sort of next obvious place to apply
type inference is local variable
declarations right and so you know if
I've got a you know a bunch of you know
local variables here that uh you know
what where I've a little bit here I
declare a local variable reader I say
it's a bufferedreader but the compiler
can well figure out that it's a
bufferedreader and so you know we've
adopted the conventions
languages have done which is to say var
which means figure out the type for me
this isn't dynamic typing it's still
strong to JavaScript it's not JavaScript
ago but the compilers just synthesizing
a type from what's on the right-hand
side and saying that's the type of
reader okay and you know with a longer
example you know it actually reads
pretty nicely and some people you know
ask like doesn't this make the codes
less readable because you're well it
will look I don't have any taste if you
don't have you pick lousy variable names
like XY and Z it will make your code
less readable but in fact I claim that
this is more readable because the most
important thing here is the variable
name not the type and by moving the
variable names front and center it's a
little bit more obvious what's going on
in this code yeah excellent so these are
two fairly small things I have to ask
Stefan can we go a couple more minutes
you don't stop okay we're gonna we're
gonna keep going okay we have permission
from the master thank you okay so those
are some cool small things let's look at
at some bigger stuff okay yeah
absolutely so for the last couple of
years we've been working on two big
projects projects valhalla and Panama
I'm gonna be talking a lot more about
these at the Java sneak-peek talk on
Friday morning so come to that if you're
interested project Valhalla is about two
major features value types and enhanced
generics which is both a performance
feature and an expressiveness feature
and Panama is about rebooting the JVM
interaction with native code and native
data to make it easier for Java code to
call native code and access data in the
native heap okay so I don't think you
have a pen I'm on demo I've got a demo
yes okay it's actually explaining what
the demo is sort of a machine learning
devil
okay so stubner alaikum you network
notice oh good so we we took the we want
we wanted to have an example of a native
library that we wanted to just be able
to use from java and show how easy it
was so we took the opencv library now
this is a c++ library for image
processing so it has all kinds of useful
image manipulation stuff including image
classifiers so we configured it to
detect cats in images cats yes because
the internet is full of cats
what's with the Internet sport that's
the innovators for okay and and so you
know we wrote you know pretty simple C
program
to call OpenCV and I actually got the
code up here I you know less than a page
code the details are important but the
basic idea is you read an image in from
a file and and then you pass it to the
image classifier and it hands you back a
bunch of rectangles you draw the
rectangles on the image and then you
redraw the image looks reasonably
straightforward right and so we want to
make writing this code to call this
native library as easy to do in Java as
it isn't C okay but people already do
this with J and I today so why do we
need well the very brave ones do it in
j'ni you know I guess there's that J and
I as miserable to use but in return for
that misery it's also unsafe and slow
whoa three benefits one tiny effect
exactly so you know the goal of Panama
is to make calling native code as easy
safe and fast as calling any other Java
library right so and to give you an idea
of how painful Jan is I wrote out the
j'ni code yeah this means not big enough
but this is the handwritten javis
you know for basically calling the API
points in that in there that used by the
previous program and and actually
there's more then and there's the
handwritten the handwritten C
implementations so this is what you
would have to do to to write that little
program in j'ni and this is what you do
to write it in Panama and it looks like
the C code it looks almost exactly like
the C code cool and you know when you
access things like you know when it
hands you back pointers to you know
rectangles and things like that and you
call getters to access the its accessing
it right out of the native heat but it's
not marshalling the data into the java
heat it's just going through these doing
all this safely and it's all doing this
all this safely it's really cool and it
actually works you want shows yeah yeah
it's a seven well switch to this machine
all right
type the magic command a magic command
okay so there we go
do we than that Mouse here mm-hmm do we
have a mouse you know it's good it's
that guy yeah sorry all right
okay so we have a you know a bunch of
cats to demonstrate that yes in fact it
does detect the cats more cats you've
just used the downer okay even better
even better yeah
exactly a cat's don't care large stone
feline yes it didn't fool the defender
that's good yes that's a real cat huh
that's a real cat hey that's my cat yeah
you should be careful when you post on
Twitter she's your cup that's my cat and
that's oracle CEO Safra Catz we're not
not a cat not a cat and the cast of cats
they're not cats I've also not cats and
the detector was wasn't fooled by this
Oh calm and so this is just a simple
Java program wrapped around that little
bit of code I showed you before
okay back slice so so the way this all
works is really cool
it replaces the whole j'ni workflow with
you know which is full of handwritten
error-prone stuff like if you're writing
a J&amp;amp;I program you have to do all of
these things and they're each of these
steps is manual each of these steps is
error-prone and some of the result is on
soap managers and the result is unsafe
and dangerous so if you get it all right
yeah so it's you know total win instead
what we do is we replace this with a
tool based workflow where you point this
tool at your C header file it extracts
metadata that describes the calling
format and the layout obstructs
generates Java interfaces that you can
call just like a Java library and then
at runtime it generates Java code to
bind to it and so that way all the code
you know the VM is able to see through
this whole stack of stuff your calls to
the interface that generated code the
Patamon runtime and so it's able to
optimize all the way through it
excellent ok very cool thank you very
much Brian yeah great stuff looking
forward to it
but not gonna tell you what release it's
in some day because we don't know ok
last thing we need you the the Java does
not move forward without lots of
feedback both early and late you can get
JDK 9 builds you've been able to get
them for a couple of years now you can
still get them JDK 9 java.net if you
really want to want to live on the
bleeding edge you can get the even
earlier access jigsaw specific builds
you can find those off of the project
jigsaw page Brian and I work for Oracle
so you should not believe a word that we
say thank you very much
to mark thanks great
thank you Mark so wrapping up our last
keynote speaker it's been a speaker that
I've been really looking forward to
actually get into the Deaf walk circuits
I'm really excited for the next speaker
he's actually he was willing to do</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>