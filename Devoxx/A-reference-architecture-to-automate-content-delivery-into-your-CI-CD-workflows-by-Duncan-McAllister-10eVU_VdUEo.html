<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>A reference architecture to automate content delivery into your CI CD workflows by Duncan McAllister | Coder Coacher - Coaching Coders</title><meta content="A reference architecture to automate content delivery into your CI CD workflows by Duncan McAllister - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>A reference architecture to automate content delivery into your CI CD workflows by Duncan McAllister</b></h2><h5 class="post__date">2017-11-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/10eVU_VdUEo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hey good morning everyone thanks for
coming to my talk I hope you're having a
good last day at devoxx today today just
a heads up this is a sponsored talk
we're gonna be talking about a little
bit about CD ins in general what they do
their role how they can support
developers more importantly how they can
how they should be automated and
included in traditional CI CD processes
but we will be getting into a few
Akamai's specific tools I work for
Akamai but we're gonna try to keep this
as high level as possible so that can be
applicable to other CDN technologies or
vendors so real quick a little bit about
myself my name is Duncan McCallister I'm
a consultant working for Akamai and the
global consulting services so what I do
is basically help customers you know
optimize the performance of their
websites I do analysis on their various
web properties and api's
more importantly act as a developer
advocate for Akamai automation products
and help customers engage in projects to
automate their usage of Akamai so real
quick let's just quickly cover like what
is a CDN right so if you have a web
application anything that's like hosted
on the Internet any type of content or
API you need to have typically some type
of acceleration or security around that
right and CD ends provide that
traditionally these are done in the
following ways so the biggest one is
obviously caching right CD ins are large
distributed global networks with you
know hundreds of thousands often of
nodes that sit between your end-users in
your application and they can cache
various content locally as close as they
can to the user right in the case of
Akamai we try to be at least one network
hop away from the end user right so that
every tune the customer and in your site
is as short of a geographic distance as
possible so caching not only helps in
in accelerating web experiences but also
helps in things like scalability right
because the more you're offloading
traffic to a CDN the less origen
infrastructure and less bandwidth you're
paying for at your data center
additionally it helps with things like
stability right if you if you suffer any
type of outage or you know momentary
disruption of service objects which are
cash from the CDN will persist there and
we'll be able to at least support some
type of web experience you know while
the origin site is offline for things
that are dynamic or transactional that
cannot be cached the we make use of
various Network acceleration technical
technical exam police is using like we
do mapping of various points around the
internet to understand various places
where congestion exists between various
data networks and then we use that
information to potentially a crowd
around that route around outages
dynamically do things like tuning
various TCP parameters to make sure that
the transmission between our network and
the origin is as fast as possible
additionally we do things like content
targeting right so we can use various
pieces of information about the client
things like the device the geolocation
to serve variants of content based on
those characteristics so a good example
of that would be like serving videos
that are only a lot of specific geo
right because there's various digital
rights management around that or
potentially serving images scaled
specifically for a mobile device
viewport the last is obviously security
so sitting in front of the origin we are
able to inspect the requests of various
from various clients and look for things
that are malicious right we're looking
for sequel injection threats we're
looking for things like credential abuse
and we're trying to stop that before it
gets to your data center another thing
is a big one is a denial of service
right so there's distributed attacks and
distributed attacks that against your
origin require
a very large distributed defense and the
way we do this is just with extreme huge
number of computing nodes that can
essentially absorb or hopefully are
larger than whatever threat is trying to
you know do harm to your business so
these are all traditional I guess you
use cases or features of a CDN and in
pretty much every CDN out there offers
these but these are more focused on like
non-functional kind of things right
these are the scalability performance
security right aspects and traditionally
these are all kind of concerns of the
operations teams but you know as that's
kind of time progress we have all this
compute power out distributed across the
globe the question kind of became you
know what else can we do with that right
there has to be more use cases and kind
of features that we should be able to be
thinking about and the goal is when
you're tight when you're thinking about
you know creating performant
applications creating fast web
experiences for your customers how do i
leverage that compute capacity to do you
know deploy features as close as I can
to the customer right so there's
actually a lot of very interesting use
cases that developers like specifically
front-end developers may be interested
in that CD ins can provide so these
range I'm just going to talk about a few
of them but these range from things like
application load balancing so we can
understand like the type of content that
that a customer is requesting and route
based on various characteristics of that
content we route based on their
geolocation route based on their device
characteristics we can even implement
things like multivariate testing
solutions right so we can do things like
instrument algorithms within the edge
network to assign the type of experience
that a customer may may want to view at
the origin additionally we can implement
things like feature toggles so we can
have dark releases or canary releases
and instrument those types of things
using the edge network and then even
more importantly is we can actually
dynamically assemble UI content at the
edge right so we can take some of these
these information about the client and
then actually dynamically construct some
type of UI element based off those
characteristics so with all these things
and all these capabilities what we've
seen is that there's like a wide array
of actors that interface with the CDN so
there's also in addition to like the
development use cases we have the
obvious ones right like the network
engineers they need to know you know
what are the IP addresses of the edge
network so that they can configure
firewalls and other security policies
around that we have QA engineers testing
various features that are implemented
within the edge of making sure they're
working properly security people who
need to you know curate various digital
signatures of bots and malicious actors
and to find those using tools that we
provide in the edge and then maybe even
sales and marketing people right so that
like a good use case here would be a
sales team that's creating like vanity
URLs or specific sales sites that are
activated at a specific time so with all
these various actors traditionally CD
ins have become like a choke point it's
a big monolithic network it acts as a
service you have many people trying to
introduce change so it's it's very hard
traditionally to to introduce change
into that quickly right so you know what
do people what do customers kind of keep
asking for when it comes to solving this
problem right well just like anything
else the velocity of the changes that we
introduce need to keep pace with our
origin applications that are internal
applications there there could be
various functional dependencies between
what we have deployed in the CDN and the
things that we're deploying at our
origin right so the the rate of change
of those things needs to keep up with
what we can do internally CDN
environments also need to be very easily
obtainable for developers because
there's so many various you know rich
features that can be used from it
through a CDN
we need we need to have some kind of
mechanism for developers to play around
with those features right it can't be
just the you know try and production or
or a limited number of environments to
do that we need to we need to think
about things like self-service to help
familiarize developer with the CDN and
those features and and make sure that
that's reliable and in performance
additionally we need feedback on what
our changes are doing like how those
changes interact with our bottom line
how they motivate customers how do they
change the various kpi's that we care
about how do we know if things are
breaking or even working in the CDN
these are all very important attributes
and then lastly if things do break we
need to kind of quick rollback
mechanisms right we need the ability to
quickly be able to reproduce issues by
maybe like reverting to previous
versions of our CD and configuration
state in various environments and also
potentially deploy new features into
production quickly so how do we do this
right well with everything it's
automation right so the the guess the
approaches we need to treat CDN
configurations we need to treat all this
logic and behavior as virginal artifacts
right they need to be included in some
type of automated testing process just
like our everything else they should
adhere to the same kind of standards and
scrutiny that our origin applications
and our configuration do right
internally just because it's a service
doesn't mean we have to treat it any
differently and it also the change to
these artifacts should be commits driven
right so as we make a change or
introduce some type of new behavior we
want to make sure that by just by virtue
of doing that automated processes happen
to test and deploy those those features
and then lastly we need to eliminate as
many manual steps as we can and in the
deployment process and provisioning
processes so these are like traditional
just CI CD tenants of any system and CD
ins need to
here those so what are the things when
we you know embark on a journey to
automate our usage of these CD ins what
do we need to consider the the main ones
are things like security right so we're
deploying certificates to the CD and
we're provisioning new certificates
especially for doing things like
creating provisioning new environments
we also have to manage our various API
credentials and tokens and secrets
operationally we use CD ins to do
various like traffic shaping activities
if you have multi data center kind of
deployments you might need to kind of
hook in the city and api's to manage
that especially this is very important
for things like canary releases or
you're using you know maybe DNS based
solutions to shift percentage of
percentages of traffic between you know
data center a a B and C and then we also
need to understand like cache management
so things like invalidation if I have
content that exists in the edge I need
some kind of mechanism to you know
invalidate or remove that and lastly we
need some way of provisioning
environments right we need the ability
to create as we said you know
self-service kind of capabilities for
developers to be able to provision and
and we also need some kind of testing
framework to understand how the
behaviors are actually interacting so
what we've been doing at Akamai for the
last you know year and a half two years
is we've really been trying to focus on
you know supporting these various types
of use cases we we have we've we've come
up with a various number of you know
tools api's libraries that help assist
in these types of endeavors one of the
big ones is we're really trying to work
on an API driven platform everything
that we release all new products have
some type of ability to be managed via
API and for everything else were
actually you know kind of retrofitting
API support around those products if
anyone's ever worked with Akamai you
know that we have a lot of different
products so that we we obviously have
you know a huge plethora of various API
capabilities that we can we can provide
to basically manage pretty much
everything
in addition to that our api's are you
know they kind of adhere to a very
strict authentication and identity kind
of scheme right so in order to make that
easier we've provided a lot of pre-built
signing libraries and in various
languages like Java Ruby Python Perl a
lot but essentially what this does is it
really eases the process of
authenticating with these api's so a lot
of the work that I do is in Python the
way that we what we've done is we've
like extended the requests library for
Python to be able to use this
comprehensive authentication scheme so
it's really easy all I have to do is
just you know provision some credentials
provision the secret and then just kind
of past that into my code leverage that
authentication class and just start
using api's additionally though and this
is going to be a main focus of the talk
later is our property manager API so
property manager is essentially a tool
that we use to manage behaviors we
create conditions like you know if
content type is text HTML then do
something
so all CD ins essentially have some type
of control interface ours is called
property manager and and today we're
going to be talking a little bit about
the property manager API and how we can
use that instrument behaviors the big
thing that property manager API is
really good for is actually curating and
modifying these types of caching
behaviors another type of you know
content assembly behaviors but we also
have a new product that we're working on
is the CLI so the CLI is really great
because it really extends the ability to
automate various CDN use cases outside
of the developer spectrum right you
don't have to be a developer or
understand Python or you know do
complicated request handling to interact
with api's it's essentially a wrapper
that we can you know use to interact
with our various products that we're
using it supports right now is force the
big ones which is you know things like
provisioning cloning
activation and and also content and
validation and management of other
various cloudlet policies that we
provide in the one of the really cool
aspects of the CLI is it has a package
management built in so as the API is
underneath change the CLI will
automatically update and make advantage
of those new kind of operations right so
you don't have to from a management
perspective I guess the the benefit of
using a CLI over our management api's is
that as the the API is evolved you don't
have to have any like development
overhead to actually take advantage of
those new features and we're going to be
talking about the CLI shortly so when we
work with customers to automate CD ins
we've we've seen essentially the kind of
like three approaches to doing this
right and they kind of start with the
very easy and in with a very complicated
the first one is essentially you're
using CDN kind of tools and capabilities
to manage your configuration you're
using the UI to introduce those
behaviors and you're basically using
things like the CLI to deploy them then
the next thing that you could do is
actually and what we've seen in a
limited amount is that customers will
actually edit the raw configuration data
and manage it internally and then purely
just interact with the city in a
deployment perspective right so this is
a lot more complicated because the
mark-up that CD ins use like fastly and
even Akamai it is pretty proprietary
right so you really have to understand
you know the the structure and in the
way of defining those behaviors it also
puts a huge emphasis on static code
analysis right because your since you're
not using the internal tools to make
modifications to these artifacts you
could be introducing you know really
malformed behaviors or structures right
it also reduces the portability across
various CDN providers so if you need to
like change CD ins this could be very
difficult and lastly what we've seen
which is
kind of interesting is maintained C C D
and behaviors via abstraction right this
is essentially creating transpilers
right where you can we've seen some
customers create their own markup
language for the various caching and
content assembly behaviors that they
want to implement and adapt those to
basically compile a custom version of
those configurations for the CDN
provider that they wish right and now
this is really I guess common for
customers who like to do things like CD
and load balancing if they want to have
multiple CD ins and be able to shift
traffic between one or the other they
can use this mechanism to automate that
the problem with this approach though is
you're kind of limited to the lowest
common denominator of feature sets
between each CDN right if Akamai
supports some kind of really cool
behavior like adaptive acceleration or
server push but cloud front doesn't then
this transpiling method will only be
able to leverage the the common features
between them and that kind of restricts
you as a developer and what you can do
so when we're talking about automating
these things what are the API is out of
out of all of them that were really
interested in well they really span you
know the configuration security and
operations domains so we need something
to we new think about provisioning we
need to think about cloning
configurations from one to another
deploying configuration that we're
managing to a specific environment we
also need some way to introduce our
behaviors which we talked about the
operationally we're going to need to
know like how to invalidate content how
those api's are structured or need we're
going to need to pull you know have
hooks into the the logging and
diagnostic tools that are available as
well so we can understand how those
things are working and in production and
then from a security perspective we're
going to need to know you know as the
the CDN network changes you know what
are the IP cyber blocks that we need to
you know ACL on our on our back-end
right how do we construct our firewall
policy so that we can safely interact
with the CDN and then additionally we're
going to need some way of provisioning
things like certificates
and other API credentials so all these
things are typically what we would see
in a common c ICD pipeline for a
customer who's trying to automate their
usage of a CDN so next I wanted to kind
of transition into some kind of
real-world scenarios that we've seen in
the wild here right so we've worked with
a lot of customers who are doing this
kind of stuff wanted to kind of show you
how the I guess the typical things that
people do at a very high level when
they're trying to highly automate these
processes right and what are these
pipelines really look like so this is a
very kind of high level depiction of
what we might see in an in a customer
ecosystem and I think the the biggest
thing to notice here is kind of the
delineation of the internal pipeline
infrastructure and the things that the
pipeline relies on that exists outside
of that right that are that are kind of
vendor managed and and it creates this
like tight integration between our
internal tools and and these services
that we rely on but the main components
that we typically see are you know we
have a some developers trying to
introduce some type of behavior feature
they're going to do that either via the
UI directly the CD and UI or they're
going to be doing that through some type
of interface that DevOps engineers or
release engineers are providing to the
developer right there is since there is
you know a learning curve it is common
to see things like service catalogs
exists where release engineers have
given you know some kind of like conduit
to developers to be able to provision
these resources without having to know
too much about how they work right
essentially like simplify that there's
also some type of you know task
orchestration we need to define a series
of steps that's required to do things
like provisioning deploy and activate
and we need to kind of codify that in
some task orchestration engine a big one
we see is actually Jenkins using
pipeline plug-ins but we've also seen
other implementations of other kind of
like off-the-shelf BPM engines like jbpm
or activity we also need to maintain our
configuration or
data in our configuration variables in
some type of version control system this
is really key because we pretty much all
CD ins provide some type of built-in
versioning scheme so when you're using
like the you know a CDN manage property
manager they're going to be they're
going to be maintaining various you know
states and time of those configuration
artifacts we're kind of trying to get
past that and actually you know manage
those things internally right and that's
very important for a number of reasons
we're going to talk about later and then
lastly we need some type of testing
framework right we need to we need to
build some type of mechanism to actually
test these features and this is very
difficult because CD ins are essentially
huge reverse proxies right like how do
you test a proxy so what does the
sequence look like and this is just you
know mimicking and mirroring the
traditional kind of like early stage
development testing process so once a
developer introduces a feature it needs
to trigger our pipeline right and then
we either if the if the features
introduced via manually just by editing
the raw markup or using api's we need to
perform some type of like static code
analysis before we deploy that typically
for Akamai this comes in two forms right
so we describe our configuration
artifacts in JSON format so we typically
want to like lint that artifact and make
sure it's structurally complete and
sound but additionally we want to make
sure that we're understanding various
the structure of behaviors that are
within this configuration there there
are various technical dependencies
between these behaviors a good example
of that would be I'm trying to
instrument HTTP to protocol support on
my configuration but I'm doing that on a
configuration that doesn't have any kind
of TLS configuration these are
dependencies that if not met it's going
to break the configuration right so we
need to rely on various validation
services from the CDN feeding or
document or configuration artifact to it
to identify those and capture that
information right usually these will
come in the form of warnings or errors
right oops
so next we need to deploy that can fit
that artifact and test it right we can
do that by either deploying to a you
know kind of long-living
pooled non production environment or we
can actually what we've been trying to
work with customers to do is actually
provision ephemeral environment so an
environment which purely exists for a
short duration just to test a specific
feature at a point in time then we need
to do some very basic sanity checks so
we need to test is the CDN actually you
know responding to host names have the
various cname operations that I need to
do in DNS to actually integrate my non
production environment with the CD and
have that been done is it responsive to
requests and then after that once we
understand that the environment is in a
functional state we perform various
integration tests right so we want to
make sure on the backend that we're able
to access our application that the our
core business features are working in
tandem with the features that we've
implemented from there what we do is we
take that feedback from both the static
and integration testing we package it up
in our various commit messages and merge
request messages and from there we use
those that event of reviewing the actual
merge request to trigger some type of
subsequent process right like maybe
additional testing or even deployment to
production so how do we test these
features right so because seedings are
reverse proxies they're kind of
transparent however because of these
advanced features we can actually have
entire request and response actually
exists within the CDN and never actually
even make it to origin so how do we know
what's going on um this is actually done
using response headers right so most
Citians will actually inject various
debug information if you request it into
the response headers of your various
HTTP requests so this is this can be a
little bit difficult with some of the
off the shelf testing frameworks right
like selenium doesn't really support
HTTP header inspection so usually you're
going to have to like write something
custom to do this but the things that
you're looking to validate are things
like what are the response codes that
I'm getting back from my requests what
are the TTLs of the various objects that
I've assigned in in cache and then what
behaviors are actually toggled or
enabled and where the state of those
behaviors right in the bottom example
here we have kind of highlighted that
the prefetching behavior is on so we
need to map for a specific object that
exists within our UI application it is
that conforming to the behaviors that we
expect it to write and we do that via
these debug headers additional things
you might want to look at are kind of
just meta attributes of the requests
that are just kind of native to HTTP
things like what is a protocol version
the content encoding you know various
other headers like cache control very
things like that and content security
policies so when we're talking about
versioning right we mentioned that the
source of truth needs to kind of migrate
from the CDN managed kind of version
into some type of internal version
control system things get a little weird
here right especially if we're relying
on the services or console to make
changes to our artifact right and the
way we do that is with some type of
staging environment right so typically
what we've done is we have a dedicated I
guess environment that it's not even
really activated it just exists purely
for us to submit changes to our
configuration right
and when we use that as a basis to pull
from to actually integrate into our CI
process right from there we want to make
sure that we're capturing those changes
on a short-lived feature branch and then
doing all of our testing on that branch
before integrating it back into some
kind of mainline branch and we do this
for the same reason we do this for other
development projects we just want to
make sure that if we break something
we're breaking it in this short
of branch and we're doing it without
impacting master and we know master is
always safe additionally we want to make
sure that this cycle is as fast as
possible because we don't want to have
we want to have all of our changes very
micro and short and atomic right we
don't want to have batch DUP changes we
want to commit frequently and often so
that means that our validation cycle
needs to be extremely fast so
additionally we want to externalize our
configuration and we do this via
variables within the CDN so this can get
very difficult because the objective is
we need to take a single artifact and
have it be adaptable across multiple
environment types where this can be
really tricky is that your non
production and production environments
can be very different from a topology
perspective you could have you know
multi origin you know two data center
production environments but single data
center QA or dev environments so you
need to understand and the origin
environment to kind of work well
together right and we do that via
environment variables the big ones to
kind of consider are things like the
origin so what is the actual end point
of you know where I should send specific
requests the status of various feature
flags and other kind of access control
policies that you might want to apply
differently in your configuration so a
good example of this is that you might
want to really lock down from a network
perspective all of your dev environments
differently than your production
environment which you want you know
widely accessible to the public Internet
so I'll just kind of leave on some best
practices here so the big one is let's
try to avoid these monolithic
configurations you want to have a kind
of one-to-one mapping between a
configuration in an environment you
don't want to have a configuration that
has you know huge numbers of
environments that coexist within it
this can be inherently non scalable and
it makes it extremely difficult to
manage if you and this is something we
actually seed on all the
right is we have because it's so
difficult to manage these things we
typically define huge numbers of dev
environments in a single config and that
means when I introduce a behavior I have
to reconcile that across each instance
of that environment right additionally
it makes it very hard for me to maintain
versions of my development environments
and different configuration States and
lastly this is kind of going back to you
know environment topologies we need to
avoid snowflake environments we need to
make sure that not only our CDN
environments but our origin environments
are as consistent as possible
right and this is a huge challenge
especially when it comes to topology
right we need to also make sure that
there's mechanisms in place to allow for
differences in topology differences and
potentially even you know security
policies and stuff but keeps our
artifacts common right next we need to
make sure that we're testing CDN as
early as we can the lifecycle so a a bug
is always cheaper to be fixed in
development than production this it's
the same with CDs right so we want to
make sure that we're testing these
things in development and and doing that
often and that we're also including that
information in our various commit
messages when we're in production we
want to monitor traffic offload we want
to understand the effects of these
behaviors and we want to you know kind
of measure that stuff and use that to
inform future releases right so it's
always good to you know use various
tools like real user monitoring and
offload measurements to understand the
effects that the changes that we're
making have on our performance and
lastly is another thing we see often is
we want to integrate our you know
deployment process for our origin
applications with CDN and validation
right so as we do things like deploy
creative releases write banner images
stuff like that we want to make sure
that we're using API is and
and various tools to surgically
invalidate that we don't want to do kind
of broad invalidation for changing just
a single object so I guess I'm a little
bit early but I'll just end off with um
you know check out our developer portal
where we have a lot more information on
some of these api's and we have links to
various open source projects we're
working on we also have new capabilities
we're working on and various examples of
API usage and you can always tweet us at
Akamai dev to learn more get feedback so
thank you very much and hope you guys
have a good day Bob</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>