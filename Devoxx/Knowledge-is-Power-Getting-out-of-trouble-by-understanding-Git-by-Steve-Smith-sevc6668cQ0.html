<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Knowledge is Power: Getting out of trouble by understanding Git by Steve Smith | Coder Coacher - Coaching Coders</title><meta content="Knowledge is Power: Getting out of trouble by understanding Git by Steve Smith - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Knowledge is Power: Getting out of trouble by understanding Git by Steve Smith</b></h2><h5 class="post__date">2015-11-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/sevc6668cQ0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everyone I'm Steve Smith from
Atlassian and welcome to knowledge to
power and understanding get so the
backgrounds this talk is to give you a
better insight into what gt's doing
underneath the hood it's going to walk
you through some of the base principles
of get to understand its internal model
and they'll show you how you can use
that internal model to fix problems for
you in the real world you know this is a
this is more of an intermediate to
advanced level talk if you're in brand
new tickets
it might be a bit rushing for a hit but
then it doesn't hurt either so how do
people here at devoxx last year how many
people try to attend a talk called prime
practical continuous deployment I was a
few sorry about that
I got a me in a bowl of stew fleece
disagreed and I had severe food
poisoning this year I have been
exceedingly smart I've done the right
thing IV nothing but but frites and the
finest Belgian beer since yesterday so I
should be fine this time around and
Mythili my tongue is now burn I've got a
hangover but we'll try and get through
this shall we
so you'll hear the following a lot this
is from the day get book get is
fundamentally a continent decibel file
system on the VCS layer on top this is
true you also hear a lot of stuff about
acyclic graphs don't worry it's acyclic
graph it's really really simple
what if you're learning it naturally
trying to get work done not a case of
I'm trying to learn get fundamentals I'm
trying to learn just I want to get my
job done day to day basis this isn't a
hell of a lot of use to you Sarah Jane
Hodgman Westby who took SPO could get
merge this year a really great
conference I recommended it's all up on
the on the web you'll know and check it
out a great talk about how to learn get
to the high level how to teach get at a
high level she drives her nuts because
you're telling people are just easy it's
just an acyclic graph that she's giving
her you know massive headache because
people just getting confused they not to
do task based learning I want to go okay
I'm starting a new branch why am i
starting up
what's the point okay I see how do we do
a push-up all the rest what's them the
high level model how do I get work done
however that will work up to a certain
point
unfortunately it tends to break down
once you start getting into some serious
work once you start trying out things or
even just your team gets bigger or you
try out more complex workflows so the so
sarah-jane gives these tutorials and
talks about how to learn get to the high
level this is not that talk this is the
other talk this is a talk you have
behind closed doors when all you know
all the cheats hit the fan and isn't and
you've got to realize this is how it
actually gets done and that's where you
get somebody else who actually has
learned the low level model try and
teach it to you ideally we'd like to
learn that beforehand which is hopefully
what this talk will be giving you the
power to do so assume everybody saw this
xkcd a few weeks ago this is actually
really good
it's explained yet this is a kind of
everyone has experience with get its you
know what you do is you find some magic
commands and they work for you for a
while and then you screw up and you
realize how I can actually just pull it
all again so I'll do that you don't go
you can drive try fixing it however you
sometimes get to a situation where you
do need to fix it if you follow the
secret text the alt text for that you'll
have seen this text as well d it's
talked about a friend
the magic phone number that person who
knows how he actually works and can tell
you what the magic commands are to get
you out of trouble
this talk will hopefully get you a step
closer to being that person because
here's a secret that person doesn't
actually know those commands he doesn't
know half the command set of get the gum
answer to get is not really important
it's the internal model once you realize
the internal model you realize what's
what commands must exist in that
universe you can work from first
principles and work out what needs to be
done if you don't do the commands in
question you can go well I would
to do this it now so there's almost
certainly a command to do that so we'll
take you through a few of these commands
today but we will also be showing you
how to think and how to think like those
commands how you could even implement
those commands yourself
so with that I'll let's get dive right
in
let's go to get internals this is a
broken down or a blown out model of the
Carlsberg brewery in Amsterdam no it's
not in Copenhagen I love talking about
anyway it's a brewery which I do do like
them so the first level of the get model
and the fundamental level on which all
other abstract concepts are built is the
blob now this is a bit of a slightly
scary video but that work so much the
blob is actually exceedingly simple so
the blobs actually can encapsulate a
bunch of things and this is by the way
if you look at this now this is gif
that's a lot that's it when we're
talking through that as we go so there
are only really three types of objects
inside get there is the content blobs
there are trees which point of content
blobs these are very conceptually
similar to file systems and then there
are commits which point to trees which
point to objects commits give you a
changing model over time but this is
basically it we actually show you this
at a very very simple low level so this
was look at in action this is down at
the file system level so it would get in
it that creates a new empty git
repository and then we're going to do a
tree tree uses a UNIX command that does
a recursive LS of Commerce's you know
directories show through the whole thing
through the whole directory as you can
see here there are simply two
directories inside get objects there are
other stuff in that git repository file
system on your local file system but
it's basically I'm going to show you the
objects for now so it's info and
pack and nothing else so that's because
there's nothing in the in repository
it's an empty repository let's put
something in there we're going to put an
empty file so touch is a UNIX command
that will either update the file stamp
of a file or timestamp of answering or
it will create an empty file if none
exists so this is an empty file and then
we do a git add that's merely telling it
track this doesn't actually create a
committee doesn't put it into the
history yet but it says I want you to
track this now I want you to keep your
eyes on this so we've added it into the
git repository in a very shallow way so
as we're looking at these objects again
we can see it now no there's a single
get object in there now it's broken down
into sub trees so what it does it takes
the first two numbers of the hash and
there and uses that and then it puts
into different directories that spreads
the load out over the whole directory
rather than having one directory with
potentially millions of files in it you
spread them out a bit more evenly but
you stopped every second what is in that
file
well fiercely nothing because an empty
farm is actually data in there so what a
blob is isn't at the the get level is a
a header is added to the file to the
contents the whole lot is said lib
compressed and that's and then a hash is
taken a sha-1 hash that's a lot you
could implement this stuff in half a day
the low-level stuff of get very very
easily indeed all you need to do is a
couple of libraries that do Charlaine
hashes zed libs and that's pretty much
it so we've added the file and it's got
a a hash so we've added the header and
we've taken a hash of that file and
we've used that to identify the file now
of course if this header is always the
same which it must be because git is
essentially a standard and the content
is always the same that hash is always
going to be the same this is what we
talked about by a content addressable
filesystem anywhere in a known universe
where the same laws of physics and maths
I an empty file will always produce that
hash anywhere if I had 1520 a thousand
files in to get they're all empty
they will always return a single file
that's it
that's what content-addressable file
system is so that's that common concept
but of course just adding files with
hashes without names without any other
information is not a huge amount of use
so we're going to do a commit I've added
a file we seek megaton to to keep a
track at if you wanted to track it over
time the commute commit gives us that
step it creates the first in a chain of
changing information changing contents
over time so let's do that please do
gets commit with a message and that's it
so let's have a look at that object tree
again so your tree again now there are
free objects I talked about there are
free fundamental object types in get
these are free object types one is the
blob that is we added it sailor has the
same hash always will do because it has
the same content we also now have a tree
the tree points to the blob it says it
gives it the additional metadata
obviously talking about hashes isn't an
awful lot of use to us we want to talk
about them higher level run sort of file
names you want to talk about permissions
on files and track those as well that's
where the tree comes in the tree points
the objects you can also point other
trees so you've got a hierarchical file
structure it contains metadata around
the authors around the files so around
the time stamps it contains data around
the permissions so it will track all
this for you so that gives you the
faster that gives you a name can be
associated with a a blob so for instance
I talked about adding a whole load of
empty files to this and you always end
up with the same blob so you can add a
thousand empty files but git will only
ever store one blob but you want to give
those thousand files a thousand names is
going to be a thousand entries in your
tree misser data so your metadata build
on top of
later now we want metadata over time of
course we want to store commits and
changing trees and changing objects over
time so this is where the commit comes
in so there's free update signatory
because there if there are free blobs
there are three types of metadata one is
the content the other is the tree that
points to it and says it has the name
its identifies that by the hash and
associate a name with it and a bunch of
other metadata that looks a hell of a
lot like a normal UNIX type file system
which not surprising because it was
basically written by a file systems and
UNIX person and on top of that we have a
commit that says this at this time this
author created this tree and it points
the tree by its hash and has a bunch of
other method data and it's fairly
freeform you can add other metadata in
there and we will do in a bit I'll show
some stuff that gets added later on of
course a single snapshot in time is not
a lot of use it's it's a version control
system let's say it's a change system
change control system therefore we want
things to change over time and that is
where the idea of change of commits come
in and is that we build our high-level
abstractions in get there is a
fundamental chain we start with our
first one that has no parent but the
next one has a parent and points the one
behind it so always point backwards
never forwards so it's kind of like area
of a linked list so link you start the
beginning and you can find the next one
each step along the way but you're
coming from the start from the far end
so you're going backwards in time so the
this is basically how you change in time
if you modify a you add a new file and
create a new tree to point to that new
file you have a new tree that tree has a
commit associated with it and the commit
may have have a parent a social Victor
Tillett where it came from
how it got to that state so from this we
build the fundamental building blocks of
get so let's look at something else
we're going to actually modify this file
that we created before same fun we're
add some content to it and what happens
well we have an entirely new blob this
is back to this idea of content
addressable filesystem any change a
single byte a single bit inside a file
results in a completely different object
because it's a different current content
conceptually as a different hash this is
what again we'll talk about content
addressable filesystem now this may seem
a bit inefficient if you've got a
gigabyte file you change one bit in it
you can have a complete abite file this
one reason why git is often not that
great at large file systems with one
things Atlassian and github or working
on together but it's also on the
fundamental insights of git and I'll
talk a bit about how we deal with some
of those inefficiencies but let's go one
step up the con the conceptual tree and
talk about how we address this as human
so far I've talked almost entirely about
hashes we have file names inside trees
but we can't really get into those trees
because the trees have hashes and we
actually to us talk about hashes
ashley's are not great thing for humans
so we need something that operates a
slightly higher level something that is
talked to in a human way about the
objects and points in time and commits
that we are talking about and it's aware
refs come in so refs are the next level
up and they are exceedingly simple a ref
is just a pointer to an object in the
story in fact its simplest level it is
just a file with a string in it that is
a that contains the hash of the object
is pointing to that's the simplest form
of ref but we don't even regenerative
refs very much directly you can do but
you're talking about you're operating a
lower level then it's kind of fun to do
it's good to know but you don't actually
want to operate them generally speaking
is operating at a slightly higher level
of abstraction so we're talking about
the levels of abstraction even if you
don't know anyone I'm talking about here
you will probably have come across the
first one being is a branch right or the
fundamental concepts of git and very
important and a large part of its power
1/2 of its you know its most powerful
concept of branching and merging and
doing someone consistently and
cheap way so a branch is just a commit
that hey that has a appearance but it's
not for the mainstream or to put another
way a branch can be seen as an object
which actually has two children so
because we talk about parents to commit
only points back to the previous commit
there's no reason why you can have a
bunch of commits to all point back to
the same one and these are branches at
its simplest level this is where
branching is so fast all it is is we're
talking about creating new commits that
have a difference or shared parents in
in them
the reason they become very simple ways
we can use them is because we associate
a ref with them we call it a branch so a
branch is just a point of divergence and
a tag associated with that orbs or if
associated with that that says okay this
we're going to talk about this branches
tree with development as my feature or
whatever the other one you've probably
come across is a tag a tag at its
simplest level is exactly the same thing
it's just color by convention doesn't
change over time that's it it's just a
reference that we has a name associated
with it and it just points at the commit
and unlike branches and unlike the you
know the mainstream development that
reference is not updated because all
about branches on obviously the all the
branches have rested with them including
your default one which is usually master
and any tags will appear will can point
to any objects in this in the history of
the tree now of course because this is
these are just files that have how she's
in them then this year it's actually
very easy to modify these which is often
a bad thing so there's an additional
type of tag that is a hesitate has a
message and then also can be signed
cryptographically and this means that
the tank can't be modified because the
hash it points to is encoded in this
signed data but its simplest level a tag
is literally just at a pointer so these
are all really the same thing used in
different ways a reference just points
to an object a branch can point is used
as a reference
to point to a separate stream of
development and a tag is just a ref that
doesn't change over time so again that
is have another lo look at this at the
file system level you can do this on
your own repositories create empty one
do on your productions on fraction
system doesn't matter it's all that it's
all there so we're gonna treat to the
two types here we're going to create a
tag called a tag and we're going to
create a branch called a branch and we
can look under get riffs so the objects
are stored under get slash objects we're
going to look under get refs which is
where to stay stores all this metadata
data these these pointers to the system
and if we actually cat one cat it's just
a way of blasting out just showing what
the contents of a file are you can see
that the branch is literally just that a
hash it as a string stored in a file
with the name of the branch that is how
simple get is this is why it's so fast
for these low-level operations you're
literally is talking about chucking a
bunch of bytes into a file very very
quickly so this is the core fundamentals
of get from this you can pretty much
work up all to all higher levels you can
start thinking about other ways of using
it you can actually use it to you can
actually abused it in a lot of ways so
that's all a little bit about operations
on this including what a famous one
which caused a lot of truck trouble
truck took a lot of trouble and I'll
show you how to get out of this trouble
later but we'll have a look at reset it
would probably use resets at some point
this is very useful you also get you
into a world of hurt so but what is a
reset reset essentially all it does is
manipulate a tag for you or a ref for
you so in the case here we'll go back
all that's the reset does is just move
that pointer back down the tree now
there's a little bit more to it than
that
reset there's a bunch of stuff to the
working directory in staging directory
there a bunch of flags you can say
I want to keep the current state of the
working directory I want to keep the
staging area there's there a few there
but these are either implementation
details at its fundamental idea of reset
is it manipulates those references for
for you of course now that we know how
this works we don't have to use reset at
all we want to do a reset we can do
ourselves we're going to look up the
hash we want to open up in my Emacs
whatever that reference file that branch
and we can modify directly ourselves all
the git is doing here is doing that for
us and it does a bunch of extra work by
saying what we want to destroy data the
hard all it says is just completely
destroyed us and check it out again but
we can get now we can manipulate these
things directly now
what's obviously when you'll do a reset
here you're moving that tag you've over
that there reference you've overwritten
that reference how do you get back to
that previous state say you've made a
mistake here you've done a reset you've
moved backwards through your tree you
wanted oh oops I want to go back
forwards will despite the the this I'm
using a normal convention here in these
diagrams but actually the arrows should
go the other way they all point
backwards down the tree to the parent we
only have it's a singly linked list you
could it's very hard to go back up a
singly linked list you didn't have to go
only back through the chain how do we
find out where we were before we did
that reset well luckily gets anticipates
this and keep something called a RIF log
ref log is simply a log of the changes
you have made to particular references
over time so you add something to a
branch and commit it the branch
reference moves that's entered in a RIF
log we do a reset that's entered into
the ref log and we can see that ref log
and we can go back and work out what we
did and what it was previously pointing
to and clean up and I'll show you how to
use that later one gotcha here one thing
to be aware of by default get only keeps
the ref log for 90 days
so if you're going to screw up
up and find out about it within 90 days
but within that this is obviously all
configurable as well but that's just a
number ninety days knowing plenty of
time to realize now as I pointed out get
creates a lot of objects as it as it
goes through the system and a lot of
these are often redundant if I actually
add a file and make a change and add a
file and make a change in air to file
and only then commit all intermediate
versions of that file will have been
stored as objects potentially quite
large ones so how do we keep things
clean how do we stop wasting all this
disk space well one of the fundamental
insights that Elena's had when he was
thinking about gates and creating it was
the disk space is cheap nowadays but
programs time is expensive so it
actually originally it was actually very
very inefficient it just they just
stored all these objects and that was
pretty much it however that's not very
good doesn't work very well as and scale
up over time for a large project of
reactive ones and also it's not very
efficient over the network as well so
something else needed to be done to make
it a little bit more efficient so a good
talk about GC GC has two concepts behind
it one of which is actually should be
very familiar if you're a Java program
or really anyone else working in a
high-level language is that GC is there
just a garbage collection it finds any
objects which are unreferenced and
cleans them up this is very much how
like G's garbage collection works in the
JVM or any other high-level garbage
collected language goes around finding
objects which no longer references to
them there's no path to to them and then
will just destroy them so to show that
again what we do here is we're going to
do a get a reset and then we're going to
get GC and that destroys the object now
the reason I do prune all there is
because I'm forcing a situation
git will actually keep these objects
around for two weeks it gives them a
time it gives them a grace period so
I'll just destroy objects every time you
do a GC it will only store them after
two weeks so you've still have the
opportunity to go back to the ref log
even though you've done I get GC but
this very simple concept very much the
same as a JVM if you're any familiarity
with a huge garbage collectors in
general the other thing that git does
during a GC is he does a pack so pecs
are not something you're generally going
to want to worry about in fact I almost
skipped this part because it's not
actually fundamental to get packs are an
implementation detail and there's
something to potentially change over
over time and probably will so a pack
file is really the realization that yes
you you can keep all these objects lying
around but it's much better they're
probably going to stay in the same state
the same order the same chain of events
is going to pretty much be immutable
over time you can go back and change
history but you're probably not going to
so what can do is Delta encode this we
can basically say we're going to find
that blog these files work out all the
differences change and then change only
store the changes and not the
intermediate states the redundant
information now that is actually how
subversion works at its fundamental
level but it's also one of the
weaknesses of subversion anyone here
ever tried to remove a file from a
subversion history yeah a few people
it's a nightmare isn't it bordering on
impossible I end up writing my own tools
to try and do it it's black art stuff
because it stores differences if you
remove something from the chain that
chain of difference is now broken you
have to know every single chain back
through the history git is different git
stores conceptually every one of those
intermediate objects you can actually
take these pack files and blow them back
up again out of the full object trees
then recompress them this is why I say
pack files may well change over time
they don't generally generally but if
you can file them find a new more
efficient pack format it saves 20% or
something great just go through your
repositories blow them away out to the
full object files apply the new pack in
your say plus of 20 20 percent so the
this doesn't really affect the
conceptual ideas of gate but it is quite
useful
- - no so this is to show you if we'd
run a GC and we can go back to our
object files you notice the objects of
all disappeared now and they've been
replaced by two files free actually one
is a an index of indexes a list of the
actual pack files and each pack file
consists in this case of two files one
is an AK the pack the raw data and the
other one is the index file which gives
you the metadata about how to find the
necessary points for certain files
within that pack file if you don't need
a low-level work of any of the file
system based databases like Berkeley d
DB this will probably be quite familiar
to you as well generally this is a de
database content you have a data file
and you have an index file Stahl's how
to get to that de data in a random
access way the actual internals of the
pack file are actually quite interesting
if you're interested in sort of
low-level stuff I recommend going have a
look at it it's in the under the docs
directory inside the git source a file
has lots of information about it on the
web
it's very esoteric it's written by a
very smart guy who knows an awful lot
about storing information on distil
ainlina sort Torvalds the only
documentation on it consists of an email
that he wrote up at some point
explaining roughly why he was trying to
do it is hyper optimized for hitting the
disk in the most efficient way possible
to make it as fast as possible so it's
very esoteric but if you like a bit a
low-level operating systems little
hackery or database style stuff
recommend going and having a look so
that it's fun dealt with the fundamental
low-level concepts of git now and talk
about some of the higher-level concepts
on top of that they're necessary to
actually turn it into a real version
control system because we talked about
branches the branches aren't actually an
awful lot of use by themselves and you
can go off and work on your wonderful
new feature for as long as you like when
you're going to get that back into the
main tree then it's what's the use of it
so this where mergers come in merges are
fundamental to the model of get that I'm
talking about here but they are very
very important in the ideas of on how it
actually works in practice
slight higher level of
turning into a version control system
being able to collaborate so what is a
merge at a simple level a merge is just
a the point where you you converge two
branches back together
very simple you what you have to do is
though is consolidate change changes you
have to work out has there any
conflicting changes if a same file and
the same place as we modify by two
different people you have a conflict if
not you can go ahead and merge but you
want to do so in a coherent way so get
us a number of different algorithms for
doing so but at its conceptual level
it's also quite simple it's a merging
point so unlike the point where of a
branch where diverges and you have a
parent that has more than one child a
merge and a particular merge commit is a
point where you have a child with two
parents so this says I am the point of
the convergence of these two points in
time now the fact that this is stored in
scientic merge commits themselves is
quite powerful as well inside gates
because it means you can actually
destroy your branches you say I don't
have tracked these branches any
Morgana's from way but this history is
still contained all you've done is throw
away the references and you can actually
go back and through your chain find the
merge commits and find out whether where
the branching points were and work out
where the changes were made over time
even if the references the branches have
been destroyed there is one exception to
this though and git does do this by
default you probably have heard of the
fast-forward merge this is the simplest
form of merge all this means is you
create a branching point but the main
parent has not actually been modified so
why do we have a merge commit at all we
don't have to do a merge because now
there's nothing to merge the two are
basically equivalent to each other so
all we do is just shift the tank forward
and as if nothing happened now this is
actually good because it's very very
fast and keeps a clean tree
unless
cause you don't want a clean tree well
if you want to keep that history you
don't have those two pounds now you
don't actually know that branch occurred
at that point in time it tells a very
clean code story but it isn't a very
clean development story it doesn't tell
you who made the branch who did the
merge etc so often and it's often a
question of policy we will say no FF
there is a flag during the commit - - no
FF no fast-forward and it will force a
merge commit to be created with the two
parents regardless of whether it's
actually required or not that stores the
additional metadata and it tells a
high-level story
some people want fast-forward commit
some people go as far as doing elaborate
re bases to always keep their tree clean
so that your fast-forward is yours will
be fast-forwarding some other
development shops will prefer to keep
the true history and will go and go no
FF no fast-forward and always make sure
that you're storing where a change came
from including it's branching history so
I mentioned no different merge
strategies associated with this so there
are a number of different merge
strategies built in to get the resolve
is what you're probably used to if your
normal normal patches recursive is what
isn't used in buy in get by default this
is a new fairly new form of merging
strategy and it relies heavily on gets
extensive history so the idea is that
you can go back and because you can walk
back down a tree you have two points
where you want to merge the branch and
the the branch it came from you can then
walk back down both trees and find out
where the shared point was where the
common ancestor is at that point you
creates a bunch of disks and break it up
with the chunks analyze those chunks and
therefore you can find out or make an
optimal merge and you can also do this
over complex merges where you've
actually had branches and you've merged
cross merge branches carried on working
cross
etc it will actually go back and create
dummy intermediate merges along the way
and sort of replay a dumb a false
history for you as well very very
powerful worth looking into in of itself
if you're interested but the great
remote recursive is generally just
worked because it's been extensively
tested on the Linux kernel this is one
they use in the Lynx kernel by default
and then get by default
obviously Linux one of most largest
software projects in history of mankind
one the most active right now if it's
working for them it's probably working
for you you're going to octopus that's a
sort of a special one we'll take actual
more than two branches and actually
create any number of branches take them
and merge them into one very tricky to
do generally only use we have multiple
streams of developments that are not
overlapping and you want just pull them
together sub-module star systems
so on we use it for our blog engine
because each of our blogs is generally
worked on in isolation so we can just go
all right pull them all together in one
go and then push them out the door we
use it for our staging servers there's a
special merged system called ours this
generally froze away another branch what
it says is I'm working on feature Bron
blah blah blah blah I go to merge what I
say actually forget all our history this
is now the sort of truth it completely
overwrite one branch with another this
is nothing to do very often but happens
sometimes in long-running projects or
long-running branches where that the new
branch that essentially supersedes the
previous branch you're working on
version 2.0 version one keeps on being
created your cross pulling any security
fixes hot fixes and patches and so on
when you get to the end the release date
for your 2.0 that's really you don't
care about one anymore so user hours to
completely overwrite that history while
not actually destroying the history
merely saying we're going to start again
from here subtree is a powerful one it's
vit the closest comparison for
subversion is the subversion externals
that doesn't really quite work like that
it's very useful pulling in other
projects or if you want to spray your
project into some
modules smaller git repositories and
then pull them together through a parent
one that's it's a good solution for that
as well quite powerful quite complex as
well my colleague Nick apology has
written about this if you go in Google's
get subtree or probably hit his article
in the top five or so go read that it's
got great examples on how to users in
pratt in practice the other one though
is it do we have custom ones we can
actually add custom merge strategies if
we decide that we these aren't working
for us we can add our own and put in and
plug them in in particular is useful for
if you have a proprietary binary format
that is actually merge abut obviously
get can't merge binary files there's no
idea what the semantic meaning of them
are but if you have a some buying
proprietary binary format and you have
to know that you can merge these two
files by pulling apart looking the
structure and then merging them back
into a new file then you can add your
own merge system in there so a good
example would be if wants to merge XML
if people been over writing XML and
massive changes to it all you've put
your XML into an XML editor who's
completely restructured it although it's
semantically the same you could actually
then have an XML merger that basically
breaks it up looks walk the tree finds
out they're the same then spits out a
brand new XML file is semantically
equivalent to the changes of the both
but is looks completely different so
it's a XML a good example for that so
merge strategies are plugable so it's
not actually part of the gate core model
itself but it is important to realize
what emerges the only part of it is
called the git score is that the fact it
has two parents how it gets those two
parents and the ways of resolving change
between them is a pluggable system that
you can use and you can change at
runtime so I'll be talking about merges
and so on we also have to talk about the
big elephant the room or friend riri
base everyone free her to rebase Emma
told don't do it or you absolutely have
to do it etc etc I will leave that up to
your developer manager fights over the
stripe
a philosophy on this changes quite a lot
but rebase is actually itself it's a
very very simple concept indeed what we
do is we just replay a history at some
point at a different point in time now
this isn't the same as a fast-forward
merge it looks a bit like it at the
diagram level but it's not because each
time we move these files but is these
commits over time and the objects inside
them we're going to be changing the
parent the parent means a hash changes
on that which means it's a down
different object so we actually have to
a full replay we can't just move riffs
around we actually have to take each
commit and replay it as we go along
that's actually a very very powerful
idea in itself because if you're
replaying history you have a chance to
change history you get a second chance
and we can use that in a lot of quite
powerful ways and I'll show you in a bit
because we can use some of these ideas
or talked about so far as a way of
getting out of trouble
they don't recognize this is almost
curious does it has anyone seen this
this video this is a the advertisement
for the prince of persia sands of time
that was played I think in Australia
this is not actually me rewinding this
is the video so no one's seen this
alright there's much been Australia only
thing or I'm just too old so we're going
to try and use some of the concepts I've
introduced now to get out of Trump
trouble this is more than just an
academic exercise in early this is get
internals this is a way of solving your
problems by understanding them and
realizing that you don't have to know
all the commands you'll need to know
what commands could exist and you'll
generally find them so we can go back to
our first one get reset hard this is a
pretty much a rite of passage so how
many people here have done a get reset
hard at some point how many people
 it up
and you have to clean the mess up right
quite a few it's a rite of passage
everyone does this
it's one of yo ya know reset oh yeah
i'll get rid of change boom I've no idea
I'm doing so how can we learn no use
what we know now our new knowledge to
get us out of this problem we've done
reset hard we've now back in the past we
realize we don't know what our changes
are anymore I can't help with the actual
unstaged working changes that is a
anyone was unstaged or drill off the
reset or reset hard we'll be blown away
but everything was in inside get will
still be there so how do we get it back
well we know how to do that now because
we know that git doesn't destroy that
information it's tucked it away
somewhere very handy for us inside the
ref log so this gets us out of trouble
we know we did a reset we can see it in
the log we will we actually done one
that reset we want to get rid of that
reset so we now know that the
corresponding previous state was 6 CC 6
6 3 7 which is why we're talking refs
and not in numbers because not very
useful but we can use that number now
and get ourselves out of trouble
so get reset hard and we just do give it
the hash that we want to get back to and
it moves us back to our previous state
so that's very simple idea and it will
this is the sort of thing that we think
about if we know that reset moves tags
and branches and refs around then we
know that we can manipulate them
ourselves and we can fix this next one
is a favorite of mine my my last jobs my
previous team was a massive massive
refactor I was constantly rebasing and I
was constantly breaking the build and I
found something out only afterwards
which is really really useful I'm going
to show you now so these are re rebates
and you've broken the build is you've
got a long-running branch you want to
rebase it and to keep it clean to keep
it up to date with the mainstream of
development and we so we've done a
rebase to get it up to date
unfortunately something along the way
has broken and you don't know what one
of those commits in that chain that
you've replayed how
broken the bills welcome what's happened
and what can we do about it so there's a
couple ways we can do this one is we can
actually replay we now know that our we
can do use riff log to get back to the
previous state and then we'll do a new
command rebase exec rebase exec is a
very very powerful concept what rebase
the rebus exec does is at each point
where it replays the history it'll
execute a command for you if that
command returns an error it will stop
this is really really useful if you want
to do your rebase is broken then all you
do is do a run your test suite as part
of the the rebase after each step on the
RiRi base and it will stop when you
found the issue so if when it finds the
test bro broken so that will rapidly
find the first step along the way that
broke the build there is also another
way of doing this stone again if what
may have heard of git bisect git bisect
is very popular with the kernel
community it's not so much to use
outsides after the normal development
projects because ideally you should be
running continuous integration and you
should find problems out as they happen
however it is quite useful when you've
done something like a rebase or a long
stream of development and some errors
crept in you want to find out what it is
particularly if you could automate the
test or the bisect will also work
without automation you can do this
manually or you can do it through
automation what it does we jump back we
set a starting point where we know that
it is good when the previous good spot
then we can run bisect and we can do
that make test again and well bisect
will do will jump to intermediate points
and see if the test pass will fail if it
passes it will nodes of break
must be further up the tree so it jumps
back to another easy intermediate point
and tries again and basically narrows
down now the good thing that this is I'm
using make test here just as a
placeholder for testing but you can do
this manually as well if this is at some
point the PDFs produced by your order
system suddenly call squiffy then this
is a good way to you use it run it run
by bisect at the intermediate point it
will stop and say please mark this as
good or bad you didn't go off you run
your your PDF run or whatever and look
at them nope this one's good
mark is good and then get will mark that
as good find the intermediate point and
then will run will stop again and allow
you to check again so it's very very far
quickly narrowing down almost got almost
like sort algorithm to find the
intermedia the intermediate point now
against all the ends here we actually
provide a little time of the answers for
questions but a lot of this little quick
recap this is the get data model this is
the entirety of it all the concepts you
need are here blobs have can't a content
trees pointer blobs and give them
additional metadata Kemetic commits to
track these changes over time and
commits chain do that by having parents
possibly with multiple children possibly
with multiple parents so this is the
core of git and you can do do this so
now we know all this about git I
recommend going after production servers
start mucking around with refs directly
and screwing things it's great fun it's
and don't worry your bosses won't mind
at all but also you can use this
knowledge to help you solve the actual
problems you're having a red state basis
and you can be that guy in that text
file who knows the commands not because
he knows the commands but he knows the
commands must exist because he
understands a conceptual model so
hopefully this has been used to you
we've got a little bit of time so I'm
actually happy to answer questions or
I'll be downstairs on the atlantean
booth for the rest of the day if I
didn't want to come and catch
as well thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>