<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Plain Functional Programming by Martin Odersky | Coder Coacher - Coaching Coders</title><meta content="Plain Functional Programming by Martin Odersky - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Plain Functional Programming by Martin Odersky</b></h2><h5 class="post__date">2017-11-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/YXDm3WHZT5g" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay since we're on welcome to my talk
about plain functional programming this
talk was originally labeled as a
beginner stock and I think it will start
off easy for everyone to understand but
it will end off with some new things
that should also be interesting for the
experts here so playing functional
programming what let me start off with a
question what do you think is the
biggest difficulty in software
engineering what are we all fighting
with naming variables usability
off-by-one errors yes only two to two
greatest difficulties until you name
them I would say no its complexity the
complexity is a mega difficulty we're
all fighting against it's after all
Software Systems get replaced not when
they wear out bits don't draw like Gilad
bracha says and it says it's a shame
they don't but they get replaced
hopefully when they crumble under their
own weight
because I have become too complex that's
the fate that lifecycle of a software
system it gets too complex nobody wants
to deal with it anymore
and finally you people find the courage
and energy to replace the software
system with a new shiny one which
doesn't repeat of course any of the
mistakes in the previous ones and then
the cycle repeats so where does all that
complexity come from why do we fall into
the same trap again and again and again
well I think there are lots of possible
culprits one definitely is changing
requirements the software system is sort
of a life thing it's not a bridge that
you built once and then it stands it has
to be adapted all the time
the other thing is of course changing
developers developers change all the
time developers who come new into a
software system might not really
understand its subtleties and might
therefore increase the complexity and
maybe it's also just attitude sometimes
that we are
really keeping in our mind to do the
simplest possible things for fear of
being labeled simple tons so we need to
do smart things because otherwise other
programmers maybe think we are stupid
but overall I think we don't really know
what causes the complexity we only know
that it software generally becomes more
complex the older it gets so it is
essentially a constant fight it's an
uphill battle but we still need to fight
it so what does that have to do with
functional programming
well functional programming is important
in that context because it removes one
really important dimension of complexity
what is that I mentioned that it removes
well it removes the need to understand
the history of the program in order to
understand a single part a function
functions don't depend on the history
what happened before and they don't
influence the history what happens after
functions in the mathematical sense just
take parameters and give you a result
that's all you need to know about them
there are no hidden side effects and
that's a huge relief because it means
that to understand a piece of program I
know what I have to look at and it can
be fairly small I don't really
potentially have to trace back all the
possible interactions that can be very
very far indeed so I think that's the
the key of functional programming why
function programming is important in the
in this complexity debate okay so I said
well yeah but what does this guy tell us
doesn't Scala and Haskell have a
reputation for being rather complex
languages and they aren't exactly the
simplest languages are they
and it isn't Scala in particular a huge
language containing everything class the
kitchen sink so I've heard these
arguments and therefore I did a little
bit of research so I tried well can we
maybe measure some of these things and
one measure I found I found several but
I just show you one and today all
correlate it's just the grammar size in
lines so if the grammar gives you all
the constructs in your language and you
I just took them all and yeah show that
formatted differently I made sure that
it wasn't glaring the differences so
this could be off more or less by 20%
for each of these languages but he is
roughly what you get so interestingly
enough that was for me a big surprise
C++ is not on top I thought it was on
top C sharp is on top C sharp grandma is
1500 lines C++ grammar is a little bit
less than 1000 lines and then you have
Java 8 Swift and Cortland or more or
less the same and then you have Scala
which is a lot smaller it's actually
less than 400 lines and you have Hasker
which is a little bit smaller than that
and you have Python which is the
smallest of them all well that confirms
our understanding the Python is a really
simple language and of course I could
say well Python is small also because it
doesn't have to talk about types talking
about types ads of course considerable
footprint to the syntactic constructs of
a language so if you don't need to do
that then you save a lot of lines so I
would if I haven't looked at other
dynamically typed languages but I would
also assume that there four more to the
left of this chart so it's not the size
of the language I hope that I have now
proven this myth wrong but still I mean
people perceive Scala to be complex
where does that come from sorry Scala
what I didn't get I didn't get that I
was gonna Z Scala said yeah I'm gonna
talk not about Scala set but about some
of that yeah it's kind of that well
maybe so I think it's scholars that
could be part of that culture shock so
there's a huge culture shock for several
reasons so let's look at the shock part
first functional programming is still
foreign to many and it's not just
learning another language if you learned
let's say Python then of course with
with Java you have to learn the the
static types and if you go from Java to
c-sharp and you learn a little bit more
features and it's all very much the same
idea the same approach to write programs
with types or without types but it's
functional programming is completely
different and you sort of learn that
gradually as you get into functional
programming that it really demands a
completely different way
to think about programs and I would
argue if you do it right a much simpler
way to think about programs but simple
as we chicky says is not familiar so the
simple way to think about programs might
be rather foreign to the people who are
new to function programming so it's not
just learning a new language and it
takes time to attack and then there's
the culture so I think that some parts
of functional programming have developed
patterns and terminology that require a
lot of learning to get into and that
sometimes contributes more to the
complexity than it solves
and I'm gonna try to essentially give
you some examples of what essentially
what the trade-offs are it's not as
simple to say well some people just want
to throw super complicated abstractions
at you and they obviously good for
nothing so that's not definitely what
what I want to say here so let's look at
functional language families because of
course there's more than one so roughly
speaking we have the dynamically typed
languages which most of them all come
from Lisp so examples are silos and
racket and closure closure is the one
which is most widely used in industry
and then there's the ml family of
languages with currently used languages
such as SML or camel very popular in
France Haskell all over the Internet and
then of course Scala
Scala sometimes people object to it
being in the ml family because it
doesn't look at all like ml it looks
more like Kotlin or swift or maybe
that's the other way around so the
functional way is very simple you just
parameterize all the things that's the
only thing you have you if you need
something may you make it a parameter
and if you return something you make it
a reset and that's great because it
means that there no side effects
everything is referentially transparent
the fact that you parameterize all the
things in a statically typed language
means everything passes the type checker
every part of your contract is
essentially checked by as type checker
and the type checker finds a lot of your
errors so for instance if you write a
programs with
collection libraries then you will have
this aha a moment that you say well you
write a program several hundred lines
500 lines whatever complicated
operations and it runs on first try you
were never as good a programmer before
so why are you as good in this new new
paradigm well it's because the compiler
actually was able to check you century
all the critical pieces for you because
you made them all blatantly obvious as
parameters and results of your programs
so and the other thing of course is it
gives you very fine-grained control what
you pass where so all this is great but
sometimes it's actually too much of a
good thing if you take that principle to
its end and I think most programs end up
with a sea of parameters because
unfortunately this piece that you are
looking at has dependencies on 20 other
things so well yes that would mean to
any other parameters most of those
parameters furthermore hardly ever
change so it's very very boring and
repetitive to pass them everywhere and
it's also prone to mistake because
you're well you might overlook one in a
statically typed system the compiler
will probably find out but well there
are always exceptions where essentially
it would pass the type checker so one
strategy to cope with this thing to say
well the direct approach is just too
many parameters too many details to
mention is to raise your abstractions
and that means typically that you take
inspiration from category theory and
monads everybody here knows monads so
that was the construct that came from
category theory and by now I think there
many many more so there's a trend really
towards category theory I was looking at
the program of this year's lambda world
which was just running two weeks ago and
I think the conference is about twice as
large as last year so very popular and
category theory has all but taken over
the conference so it's very very popular
so let me just show one example of what
a program style that's inspired by
category theory and I made an attempt to
find an example that I actually like
it's easy to just show you examples
where I said everybody laughs at that
and says
it's clearly too complex but I wanted to
show you something to say well let's
understand why people do that so what
the what the example does is it looks at
the configuration problem so it means
you have a very simple code you have
code that depends on some configuration
data that are in a configuration object
and some of that data might be wrong so
you have to check it and you have to
react on essentially do the appropriate
thing if the data is not in the format
that you expect so there's a quite nice
article called reading configuration
with closely arrows and that as an intro
of that and I will switch directly to
that article so basically what it does
is it uses a thing called slice Lee and
that's a functor or rather monad and
those are two other parameters okay
good so so what do what does it try to
do so here yeah that's so here are four
case classes one is a name consisting of
a first name and the last name the other
is an an age which just wraps an integer
then we have a person that consists of a
name and an age and finally we have a
config object that defines a name and
the age and the task is super simple
given the config construct the person
that is described in the config so
here's how you could do that and it's
it's it's in in that system so there's a
part called read name and I'm not really
sure why they wrote it as a closure
value rather than a method but whatever
so read name takes a config and it gives
you back an option of name option
because while it could be wrong and I
have to return something when when the
thing is wrong so then I choose to
return none which is sort of the typed
version of null so what it does it's it
splits the string into words using the
split operator if it finds more than one
because we need a first name at the last
name then it gives gives us a name
consisting of the first name and the
last name
there could be last name could consist
of several words like Simon Peyton Jones
right Peyton Jones two words for the
last name so it reassembles them with
spaces and we th is a very similar thing
it just pulls out the age of the convict
it checks the age for validity we say
well we need to be between one and
hundred fifty and in that case we return
the option the sum of this age and
otherwise we return none okay and then
there's the thing to say well now we
have these options and we need to
compose them somehow better so this is
mysterious thing that we say we have to
sweet name K and it's a closely of
written name and we have a read HK and
it's a closely of reach H okay and what
we then can we do with that so there the
payback is here we can write a person K
as it's again a closely thing which
doesn't mention config parameters and
it's a closely of option conflict person
and that just essentially uses this
monadic composition it uses a for
expression reads the name reads the age
and gives us back a person and that's
somehow does two things somehow we put
in we put put in the configuration we
don't mention it anymore here but
somehow it ends up in this closely thing
and furthermore we output the option
also again except that we mentioned that
this is the first parameter we we don't
do we don't we don't mention it anymore
so then we could say the result for
instance here of a conflict with Bojack
horseman and 42 is a result one and that
would be the output of that and here we
would have an illegal configuration and
then the result would be nothing so
that's what we want to achieve here of
course you could you will say that for
this example here it's complete overkill
and everybody will agree with you but
people would say well in reality I would
have maybe configuration objects
consisting of hundreds of fields and
methods that access them there could be
thousands and maybe it's worthwhile to
actually hide all this plumbing in some
plumbing which is higher level which is
this twice leasing but of course if
you're new to
code based like that then probably your
reaction would be closely what slice Lee
what
so actually closely here's Kleiss Lee
it's actually not Kleiss Lee what is
Kleiss Lee who closely was a swiss
mathematician from 1930 to 2011 he lived
he was teaching in freiburg which is
actually quite close to where I am about
40 kilometres away and he's the inventor
of the classic category and wisely
triples and what you saw here was an
example of Kleist it triples so now I'm
sure you're all enlightened but let me
let me maybe just redo the problem and
try to come come up to the problem in in
baby steps so let me do that and I'll do
that with with live coding so let's look
at this configuration problem again and
let's say we don't don't do functional
programming we just have a box standard
imperative language and we do it
imperative Lee so that's what we would
do I guess
so they would so the the imperative
thing to do is have a global variable
config okay that gets laid in
initialized later on and then we have a
rename method which does the split part
and then instead of doing this option
thing it just says require parts dot
length greater or equal to require in
SCADA is the same as assert only it
doesn't throw an assertion error when
it's wrong it raises an illegal argument
exception so requires sort of saying
well something's wrong and you were to
blame you the caller is to blame not me
that my code went wrong okay or in this
case the config is too plain okay and
then we essentially do the same thing
that we do the past the first name and
last name read H is the same thing it
gives you the age it takes the H does
the requirement returns the age and read
person so here we say okay in the person
thing let's say the contract would be
give me a person or not depending on
whether this thing is valid so here we
do return an option
and we do that with a try-catch so I
said requirement would throw an illegal
argument exception so here we catch it
return none and if there's no exception
then we really turned some and the
person that we got from read name and
read age okay cool so problem solved
but of course you say yes sure in this
simple part maybe I would even do it
that way but in a large system I have
this dependency on the config object and
let's say we do this thing somebody
changes it later on but let's say that
we have we're living in a reactive
system there's some outstanding
computations that we'll come back and do
we have to do when essentially some
something triggers but in the meantime
we have already changed the config
object and then of course all hell
breaks loose because this thing would
essentially start its computation with
one config object and then suddenly we
change it under it and give it a new one
so we know all the insecurities with
with mutable state there that way okay
let's do so what can we do well
parameterize all the things right so
let's do that it's just right config
here three times and then of course
rename takes a config so we have to pass
the config and we have to pass the
config to read - okay and we're done
so that actually for me is probably
sorry and we can so we can do this we
can delete this and we can pass these
things directly right
okay so that's actually the shortest
version and probably at least in this in
this context in this setting where
everythings are still small the simplest
one it's plain functional programming
well you could say no not really because
you have an exception here and here you
you catch it and I'll get to that so for
the moment I want to just essentially
take this as a as an aside and say okay
good
admit it we have an exception and we
have to deal with that one other
objection would be the following let me
just go back to the preview that if we
have to pass all these conflict
parameters everywhere and in this
example it was very simple essentially
read person passed the config to read
name and read eh but in an actual system
this might get out of hands you might
have literally thousands or tens of
thousands but parts where you have to
pass some of these config things
somewhere else so you have to declare
all these parameters and you have to put
them in every call that's this problem
with the sea of parameters so SCADA has
a very simple answer to that I'm a very
direct answer and that is if passing a
lot of parameters gets tedious then you
can leave some of them implicit so let's
do that so what we would write is just
we write implicit config and here and
here as well and then we don't need to
pass the parameters anymore alright
don't know what I did here
okay oops yeah there we go so we don't
need to pass the parameters anymore and
that's that's fine so now we have
essentially rid ourselves of the tedium
two extreme pass all these config
parameters everywhere down the call
stack into all the leaves of our program
okay great so in what sense was Kleiss
Lee better than this about it handled
exceptions with options all the way down
but let's ignore that for a moment in
what way it was it better than this
otherwise I didn't need those convict
parameters right that was the other
thing all these conflict parameters so
that's another thing where the
essentially the high level abstraction
you don't need to repeat yourself over
and over again with these parameters so
let's see what to do about that so in
the configuration example we have three
repetitions of implicit config :
conflict so it's an implicit parameter
called config in a large system it can
get tedious to declare all these
implicit config parameters so having to
write it a couple of times doesn't look
so bad but in our new compiler dot C
which is our new scholar compiler we
actually currently have two over 2,600
occurrences of the text implicit CTX
context so the context as you might
guess is the thing that essentially gets
passed into all the parts of our
compiler that need to know what the
current environment is what the current
context is and that yes that does get
tedious and the ANSI question is
wouldn't it not be nice to get rid of
them so here's I'm now explaining
something that will come up in the next
version of SCADA SCADA 3 and that is
already working on the system that I'm
showing you which is essentially dotty
which is the predecessor of SCADA 3 so
what I'm sure I showed you in the IDE
was essentially ddotty presentation
compiler that was type checking the
programs in real time so towards the
solution so how can we make avoid this
repetition of all these implicit
parameters
let's massage the definition of read
name a little bit you saw in the closely
that one can alternatively write things
as a method with parameters and parents
here or you can write them as
essentially a thing with our lambda as a
right-hand side so this this thing here
is a lambda it takes a convict and
essentially does then precisely the same
body as you saw before and the only
difference here is it's an implicit
lambda so we can write that already in
current scala and implicit lambda just
means that the config parameter is
itself available as an implicit in the
lambda okay cool so what's the type of
that lambda so previously so far in
current SCADA it's a function from
config to name so that's how the
function types are written and from now
on it will be a new type called implicit
config to name so we have not only
implicit parameters and implicit lambdas
but also implicit types implicit
function types what does it buy us well
first what are the rules I mean you can
invent a new type but what what should
how should the compiler type check
programs with that and the rules are
actually unfortunately really really
simple the only two the first rule is
that an implicit function gets an
implicit argument just like an implicit
method so if you have F and it's an
implicit function from A to B and you
have an implicit value which we assume
is unambiguous so there's only one that
matches best then the the F expands to F
applied to a you improve you apply the
parameter implicitly and you do that
exactly the same way for implicit
parameters of methods so now you do the
same thing for function types the second
rule is that implicit functions the
lambdas get created on demand if the
expected type of an expression B is an
implicit function type implicit I to be
then B will automatically be rewritten
to a lambda which takes a parameter
whose name doesn't matter in fact so
it's not accessible to the user program
and it returns a B so that's the only
two rules that we have here
okay so let's see go back to our thing
and see how we could change that so what
I do here is I have some boilerplate
code that I put to the side well it's
actually not but now it's boilerplate
dream over code its boilerplate
avoidance code so I define a type alias
configured of T and that's an implicit
convict 2t so I say well if something
gives me a TIA but it needs a convict to
do so then let's call that a configured
T a configured name a configured age and
so on and then I set these con implicit
function types they I can't really get
at the at the parameter so sometimes I
need to so the config parameter which we
well okay let me do it first and then we
will get back to that so instead of
writing implicit so I write configured
of name o to do that I need to import
what was this called configs okay so
that's a configured name and that's a
configured age oops
I'm not very good at editing standing up
and that's a configured option person
okay
and everything still works so the
absence of red twiddle twiddle means its
type checks and I assure you it also
runs and that's that's the right thing
so so what that means is that now I have
so let's see what I got I got I avoided
the implicit parameters and I put them
all in the type why is it good well
let's let's say you have not one
implicit parameter but five we have to
write five of them each time with a type
do you have to write five nested types
yes but with a type you can alias it you
can invent an abbreviation we do that
all the time in software construction
once something is first-class we can
name it and use the name instead and
because the implicit functions on our
first class first class types we can
name them and use the name instead we
have essentially here instead of the
implicit function types we have used the
configured great so let's see what how
we will go on oh yeah sorry
no now we go further and said well let's
come back to the exceptions
I still use exceptions so what should we
do here well what would scarra stata
people say well one thing to do it will
well just use a try a try type with
options and things like that and I'm
going to use something very similar but
a little bit different I use a type I
made up myself just for the purposes of
demonstrations so it's called possibly
instead of try so I say okay if
something is a possibly so sorry
now I have to import exceptions as bit
as well and I say okay read name is
possibly configured name
okay good so sweet name is fine
read H we seem to have a problem here it
says no implicit argument of type
exceptions can throw was found for
parameter C T of method require so this
require method let's have a look at it I
just imported that now from this
exceptions object previously it was
imported from pre-death so it says well
okay I get a boolean and if the boolean
is wrong throw an exception but I need
an implicit capability that I'm allowed
to throw an exception I wilt not false
from now on I will not just throw
exceptions like this because that's a
side-effect
I need to be allowed to throw exceptions
let's call this thing can throw so it's
a class in exceptions and it has a
private constructor so nobody can create
an instance of can throw instead of in
except this object itself so where is an
instance of control created in the
function on error which is essentially
the second part of attempt so that's
essentially try catch instead of try
catch which is primitive in the language
I have attempt and on error which is now
also in a library
what does on error do well it says okay
let's run this operation with a fresh
can throw I tell this operation well you
can throw an exception or more precisely
this only exception that we're dealing
with because I'm gonna catch it anyway
so we're safe yeah there won't be any
any any escaping exceptions so I give
that capability to opie and then I say
okay if I have get an exception if
somebody throws that exception then I
give you fall back so I've used
exceptions which are a great invention
in the JVM because essentially they
allow this non-local control flow and
they are very very efficient so we
definitely should use exceptions but in
Scala program the programmers don't
really want to use exceptions why well
because they don't show up in the types
something might show up I throw an
exception and then you don't know what
it does so it's an undocumented
side-effect so you say well that's
actually is that something that Java
actually did better doubtful in Java you
have to pull it in the types but the
type system in Java is super super rigid
so for instance you can't just define a
closure and thread exceptions through
and things like that so it is
essentially you you have lots and lots
of problems with the type discipline so
let's see what we can do here
so I've shown you what this possibly
does and here it says okay no you can't
do that so I have to what do I have to
do to fix this I just put it in another
possibly and what do I have to do to fix
this well here I say instead of the try
which I shouldn't use because it's it's
an it's an exception I can't get it
anyway I do attempt dot on error and
then the nun so that's that's what I do
I stops and we damage we're done again
so what I've what have I shown you so
we've we've done one thing which was
injection arguments we can express that
as an implicit function type and put an
alias on it we've seen another thing
which was effects in this case raising
exceptions we've seen we can do exactly
the same trick only another name which
is possibly and configured and we just
leave the code exactly the same as it
was in the imperative version there's
nothing we I haven't touched the code at
all and all I really did is I changed
the result type from where we started it
was named and now it's possibly
configured name so I would argue that's
actually a great thing because name
doesn't really tell me enough name
doesn't tell me actually this thing
needs to read the config object or you
have to pass it and it doesn't tell me
all and and by the way this name might
be is essentially non valid and in that
case essentially somebody has to handle
the case so it doesn't tell you any of
the two things whereas now we have it
all in great detail cool
so you could say good so how does that
compare to closely and the mona semana
turns
formas and things like that so I think
the answer is once you do closely the
where did we hear the person we person
thing they didn't look any more like a
normal straight line code it was a for
expression and for expressions are
actually rather pleasant to write in
scala so essentially they I could give
you the simple surface syntax for for
monadic composition but the problem is
essentially you only have one free beam
so as long as you live in one monad if
everything is very very nice with four
expressions if you start to compose
monads it gets very very hairy and
that's essentially where all the
plumbing comes from whereas here we have
there still no morals at all it's
straight line code all we did was
essentially passed these implicit
parameters okay
does this thing have a name actually it
does there's a essentially a a movement
a very set of very interesting ideas
called algebraic effects which is
essentially a fairly new and hot thing
in function programming what I claim
here is that Scala's implicit in
particular implicit function types they
are a great way to represent algebraic
effects if you do if you see how people
do it currently using monads and and and
the other obstructions in Pescara and
haskell then you see that they have
great quite troubles so typically people
go to a freeman art and then with a
frame or not you can do algebraic
effects and by the time my head is
already up in smoke whereas here it's as
simple as essentially having these
hidden implicit function types another
thing I just can out of spite let's just
turn these things around let's try this
he works still so I can I can't have
these things in any order and there
would be no type error whatsoever so
what's the other very interesting thing
is these things these effects or great
effects right effects they behave really
like sets order doesn't matter you can
write them in anything the compiler will
essentially find the ways to make it
work cool so what we have
here I'm sorry I was skipping two slides
but I go back to so what we have here is
really a great comparison between
explicit versus implicit here on the
left you see explicit plumbing that's
close to triples Mona's Mona
transformers the whole thing categorical
thing and what we have instead is
completely implicit so that means you
notice the end points that means the
types you have and the types you want to
pass and the connections are done
completely automatically so it's really
like having a bunch of Wi-Fi endpoints
and not very how something is routed the
system will take care of that all you
need to worry is that you are very
specific what you have so in the in the
Wi-Fi point the being explicit means I
have an IP address a unique IP address
in the implicit parameter thing it means
that you should use implicit parameters
only for very specific types types that
you can't essentially misuse for
anything else so one of the first
mistakes everybody's doing with implicit
they do an implicit that gives us a
string or that converts to completely
unrelated types because it's cool once
you do that you will regret it greatly
later on because that ruins your
addressing scheme in this Wi-Fi thing
essentially that that will more implicit
so you have the more these over overly
large types will essentially conflict
with everything else so it requires a
certain disappointment but once you do
that it's great so I think in this case
here I would say normally you say
explicit is better than implicit but if
you look at this and that in the real
world and I think most of us would
prefer Wi-Fi connections over a let's
say a cable salad where you have lots of
cables going from one to the other or
this plumbing thing here so everything
is relative here okay
to wrap up the comparison let's talk
about efficiency
so these implicit function result types
I said these closures that get
essentially created by the compiler
closure creation that's an object so
that's not free but
actually because implicit function types
are so simple the compiler can fairly
easily optimize them and in fact it will
replace them by just correct methods and
then the cost of an implicit function is
just the cost of passing a single
parameter which generally can be can can
be is negligible so if you compare what
we have seen now with closely triples
the goal of both was to essentially
avoid mentioning detail over and over
one detail is what am i reading the
other detail is am i giving back a
partial result an option or a try or
something like that and the they have
the same advantages that the reading and
the returning is abstracted in a type
and I can make my types very short and a
type can express a lot of things because
I have alyas for them so I have
essentially lifted this whole thing to a
different level but in the examples of
closely in monads I would say it's much
much harder to get the plumbing correct
and the observes the observation here is
that monads are all about sequencing so
essentially a monad gives you the for
power to change control flow a very
useful example of a monad is future so a
future says well I will come back later
with that and that means of course that
I will not do this in line with the code
that I'm running I'm running this on a
separate thread and when I'm ready then
I will come back so that's essentially
very substantial changes of my control
flow and Mona is a great for essentially
putting some structure into them they
get us out of callback hell but bonnets
themselves once you have a lot of them
and you need to stack them with mono
transformers or whatnot they're also
very hard to deal with so again you
should have the approach to say use the
right tool for the job a monad is an
extremely powerful thing if I don't need
it for this thing then I shouldn't use
it and in particular for the things we
have seen which was reading and effects
we have a very important thing which
I've shown you in the code there
community if it doesn't matter what what
order I I need an A and a B either
Karin what order you pass me the a and
the B right that's in such that's not
significant and the same the same thing
if I can throw an exception or write a
file and I tell you that I'm not saying
it doesn't matter what I say by the way
I can raise an exception and write a
file or whether I say by the way I can
write a file or raise an exception it
doesn't matter it means the same thing
it's commutative and monads because
they're so powerful are also not
commutative so that means with Mona's I
cannot in general just swap them around
and that means the monads are much
harder to compose so the message I think
is use the right tool for the job okay
we have a little bit of time so I talked
a lot about functional programming and
monads and category theory and stuff
like that so I want to do something
completely different and show you what
implicit function types also are good
for so when we started with implicit
function types Li Hao Yi he challenged
me and says I've seen this cool thing I
saw in Courtland and it's essentially
this these tears elves where you can
create tables and I think Ravi has it as
well in Kotlin it's called receiver
functions which is sort of a funky way
to reinterpret this in a function type
so he says can you do this with implicit
function types
why do you think I could can do this
with implicit function types and then
it's all a little bit and the answer is
yes we can
so here's so if you have a look at it
and decompose it so what that means is
you write a table and it has two rows
and each row has two cells and that way
you build up this table and if you know
a little bit of Scala you know that
these things and the prices are
parameters and inside the parameters
it's a block with two statements so this
thing must underneath be mutable so sell
here and sell here it must do something
right and at the same time row must do
something
so let's that should give us a clue
already what should they do well somehow
the row should add itself to the
enclosing table and the cell should add
itself to the enclosing row right so we
need to know what
in closing table and in closing roles
and here in this diagram it doesn't look
like we pass it as a parameter except of
course if the parameter is implicit then
we can do that without actually showing
it in the in the code and that's
precisely the implementation here so
let's maybe look at at a table so to run
a table that's the outermost one we run
the parameter of the table that's the
initialization code that's this init and
what's the initialization code the
initialization code must know what the
incurring encoding in closing sorry
table is so we make it an implicit
function type it's an implicit table to
unit we don't care about the result so
what would what the body of table then
it would create a new table empty
initially run the initialization code
and return the table so what does row do
well row takes an in again an
initializer which now takes the row the
current row and gives us back in unit
and it gets the enclosing table so it
runs the row it so it creates a new row
it runs its initializer and then finally
it adds itself to the enclosing table
and finally cell takes a string and an
implicit row and adds itself to the
enclosing row so that's how I get this
thing here so very generally why did
this work I think very generally what
implicit function types give you is the
general ability to abstract over context
in a type so that mean means previously
you had a computation and it said well
but it needs this and this and this and
I need to be very explicit about what
that is I have to write this as
parameters or whatnot and with implicit
function types the answer is no you can
actually put this in the type of the
thing you're constructing or that you're
demanding and that way we can is
essentially establish an implicit
context candy-themed is used of course
so as obviously the question is use
these things wisely wisely so to
conclude simplicity is the ultimate goal
and I believe functional programming
helps because it has the right genes it
gets rid of this problem of mutable
but it's not a silver bullet and
abstraction helps but it also has an
intrinsic complexity coat cost so you
always need to balance the benefits with
the costs and sometimes and most of the
times I would say it's actually better
to be plain so I want to really make
some publicity for that
don't don't dare to be plain so further
reading for this there's a paper which
is block which I found extremely
well-written and extremely important
that everybody here should read that
whether you program Scala or another
language it's called the principle of
least power in short the things as if
there are several ways to go about a
program a problem a software
construction problem always pick the
simplest possible solution that does the
trick if you if you're if you can
express your library it's just a bunch
of static methods use static methods
don't use a class don't use a factory if
you can do that with a simple class
don't use a class hierarchy if you can
do that without monads and closely then
do that use just plain parameters until
it becomes unbearable that you have too
many of them and if everybody here would
just do a little bit of more of this of
this attitude then I think we would
overall spare us a lot of complexities
down the road so I should finish with
credits of all the people who have
worked on the current scholar project
and and also people in the Skylar center
that support Scala and thank you all for
being here and I will I think we have
about four minutes for questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>