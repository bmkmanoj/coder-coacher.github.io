<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Tomcat to Apache TomEE in 1-n Steps by Andy Gumbrecht | Coder Coacher - Coaching Coders</title><meta content="Tomcat to Apache TomEE in 1-n Steps by Andy Gumbrecht - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Tomcat to Apache TomEE in 1-n Steps by Andy Gumbrecht</b></h2><h5 class="post__date">2015-11-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/FBwZbzceQQ8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">haider everyone welcome to DevOps
belgium hope you had a good day who's
tired who's just spent 24 hours getting
back from San Diego who's tired I'm here
basically to showcase a little bit of
Apache Tommy I'm sure you're all
familiar with Apache Tomcat it's been
around for a very long time I'm Andy gun
Brecht oh and we're going to stand by
basically I'm a member of the Apache
community of being a committer on Apache
Tommy for about six years now is Apache
Tommy for you well that's kind of like
asking you what's your favorite Star
Trek episode and whether Kathryn Janeway
was actually a captain in the Star Trek
episode the choice is yours obviously
there's lots of application servers out
there and I'm not going to point you in
any particular direction Evelyn to say
that Tommy is the best just a quick look
at Apache Tomcat what does a plaque see
Tom can't give us no I'm sure you know
it just gives us jsps it gives us
servlets and it gives us a Pesci tomcat
that's about it I'm sure all of you have
played in the past with Tomcat and added
your own little architectures and your
own appease and your own frameworks and
it could end up looking something like
this what I call pick and play obviously
over the years you've had a big choice
and that's probably because your
application server has been lacking in
those features so what's Apache Tommy in
comparison to Apache Tomcat a whole lot
more so we're adding basically the
Oracle web profile to the Apache Tomcat
platform and we've got that certified
around about 2009 we started the
implementation 2011 we had our first
release we were originally Apache open
EJB
so we took this open EJB 3.1 container
and we stuck it on top of apache tomcat
and start to play around with her added
a few more appease and then we realized
you know this is like adding EE to
Tomcat so we were Tommy and we've added
all these jars to Tomcat so it's been a
long road it's not been an easy road you
can add one or two of these api's to a
tomcat with a relative ease but if you
want to add all of these together then
it's a whole lot of sewing up to do it's
not as easy you would think it would be
and I'm sure a lot of you know it's
actually a very complicated and tedious
process and so we've done this and
actually got it certified by Oracle so
we're passing in the order of 20,000
unit tests to be certified every time we
do a release so you know you're gonna
get a stable platform with Tommy we're
also in the process of cleaning up the
EE specification so David Blevins is our
CEO at Tommy thrive and he's the lead on
the Apache Tommy project also Geronimo
and we're basically cutting out the
stuff that nobody needs you know in
order to make that platform a bit of
light lighter so it is not so heavy
we're already at EE 7 we're about to do
our milestone release at IE e7 version
of tommy so if you're looking for an e7
version that's going to be Tommy 7 and
that is not going to be initially
certified because we're waiting for the
t ck from Apache and Oracle and that's
nothing to do with the Apache Tommy
project or or Tommy tribe that's an
issue with Oracle basically Tomcats been
around a long while that's not a bad
thing we're really happy that tomcat has
been around a long while what that means
is it's a really really stable platform
everybody knows Tonka everyone knows how
stable the Tomcat platform is so what we
basically do is often you're a path to
EE without replacing that stability that
you've come to know and love
you can download Apache simple website
lots of documentation to get you started
so if you're familiar with Tomcat it's
not going to be too hard to get started
on the Tommy Road but I don't want to
stand here and do it like a PowerPoint
thing I'm just going to show you a
really simple example which is actually
pretty complicated under the hood it's
made to look easy yeah just before I go
onto the code we did win the geek award
and we did win the Oracle award for our
application so things are progressing
for sure so what others are looking for
I was looking for something that runs on
Tomcat that's really complicated and has
thrown in all those extraordinary api's
that people have developed over the
years there's nothing really standard
about the the mybatis project that's not
to say it's a bad project it's just a
lot of different technologies thrown in
together and so you know I wanted to
find an application that was running
stable on Tomcat and see how that would
run on Tommy I mean if I just run this
up on Tomcat itself so I'm just running
on my 7:06 patchy Tomcat this is just a
an open-source free application used
basically is a framework to do whatever
you want on the the website and it's a
very simple and familiar jpetstore
implementation of this of this project
just takes a few moments to start
so I'm not going to go into any great
detail of the project basically you can
just see it's a pet store kind of
application
it's got persistence and there's spring
and various other elements that so this
program together but I want to take that
and basically show you how easy it is to
get this up and running in Tommy so this
this would be for me step one part of
this demo I'll put the link up at the
end again but there's this project which
contains pretty much all the elements of
the EE specification that have been sewn
in to this mybatis jpetstore example so
you could download that and play with it
you will basically all I'm doing is
searching for a specific text and that's
described in the project so here I'm
just going to search for Tommy step one
and I've created basically some
documentation for you to read
I've also bookmark these I don't want to
do searching all the time so if you
download the project you can actually
use the bookmarks to go to some of these
but Tommy step one
what is Tommy step one well that is
basically taking the mybatis application
dropping it into the application
directory of Tommy and firing it up a
little game of spot the difference can
anyone spot the difference where is
Tommy
where is Tomcat can anyone see basically
if you eagle-eyed you're going to see
two more configuration files on one
extra directory and endorsed directory
so if you're familiar with Apache Tomcat
you're going to be familiar with Apache
Tommy because there's pretty much no
difference what we've done is added all
the libraries for the e specification
and obviously the configuration files to
configure those things so there's going
to be no surprises you just download
unpacked install and run Tommy in
exactly the same way the
you would run Tomcat
okay
it's not showing my Tommy configuration
nurse
that's why when updating the background
so what I've done is basically set up in
exactly the same way to set up a tomcat
container itami container in I feel like
them in IntelliJ sorry and I'm just
running this and it runs in exactly the
same way I don't need to do any extra
configuration steps everything I'm
familiar with with Tomcat is exactly the
same for Tommy and yeah you've noticed
I'm using a PC so it's a bit slow
apparently
I didn't fire these up in the background
I basically wanted to show you that this
is actually starting the application
from running Tommy there's no magic here
this is just basically the same
application dropped into a Tommy
container and started so now running
side by side just a different pour and
oh dear that wasn't supposed to happen
oh no it was it just runs I haven't done
anything I haven't changed anything it
just runs so that is basically one of
the messages that I have for you today
and that is to drop your application
into Tommy and just see if it runs
so what's it's going to give you you
just saw the difference between Tomcat
and Tommy it's going to open up all
these doors for you no one is saying
when you go on to Tommy that you must go
through those doors
they are basically there for you to then
walk through at your leisure so if you
want to start playing with stuff then
you can start playing with stuff I'm
just going to show you what we need to
do to open those doors
so step one we've already done we
dropped application into Tommy and we've
started up our application and it works
when we want to start playing with the
EE technologies and we need to tell our
application that these libraries are now
available so step two is to introduce
the Java EE API this is from Apache it's
it's a collection of all the api's in
the e specifications all bundled into
one jar file so you don't need to go and
search for them we do have a Tommy maven
plugin it's not required for your
application specifically to run under
Tommy but it's nice to be able to test
your application and the Tommy may even
plugin allows you to do that so from the
command line you could run tommy run and
your application would be deployed to a
Tommy container and run up for you there
are also different build goals like exec
where we'll build a complete standalone
application so basically what people are
calling micro services today it's a phat
jar with everything in that you need to
run your application and that's the
Tommy maven plugin
we have various flavors of Tommy so I
would always recommend Tommy plush so
Tommy the web profile it's missing
things like jax-rs obviously jax-rs
restful web services are really
important today everyone's there they're
restful api and so we have an extra
distribution called Tommy Plus and this
is just a classifier we add on our
application plugin so that when you run
it will actually pull down an entire
Tommy distribution with everything in
that you need to deploy restful web
services we're also supporting our
Cillian testing I'm not going to go into
that today because there's not there's
not gonna be enough time to do that but
our kuleana is a framework for testing
your application on the actual
application server that you're going to
be deploying on absolutely today unit
tests have been very unique on
application servers in there usually
deploy to some lightweight container
that mimics your actual production
environment while here without plugin
and our Kilian support you're going to
be actually testing and running your
application on your deployment platform
and finally you don't have to do this
step but obviously you're now in an EE
application so just update your your
web.xml for the three zero where that
profile that's obviously just adding a
few more bells and whistles to your
application and that's all the
specification added there for you so now
we're going to have a look at some
actual code and how easy it is to start
opening those doors so as you can see
I've got Tommy step one
Tommy step two Tommy step three Tommy
step 4 I've basically gone through this
project and provided a step by step
introduction to all the EE API used in
the e6 specification and you can just go
through and search for those particular
steps you can see just slightly lower
here I've got to see the eye step again
we're not going to go into that today
we're just going to stick with a restful
so this project and this demonstration
is basically for you to take away and
download yourself and start playing and
seeing how easy it is to use these
technologies so what do I need to do to
make my first restful api
well you'll actually be surprised how
simple it is all we're doing here is
annotating POJO so simple plain old Java
object and we're giving it a path um
we're going to be scanning for these
annotations so Tommy tries to be late
lazy loading and is in as much sense
that if you are not using specific API
is we're not going to fire those
containers unless we have to
so we'll scan your application and the
second you start using something like
path we know that you want to start
running the restful container we will
fire it up for you there are other
technologies again in this which I'm
going to skip over because we're just
going to follow straight for the rest
scenario
so I need to separate my application so
when I'm providing a restful api we
define a rest application and all that
does is give us a namespace that
separates our restful api for our
application api obviously our pet store
is running under a particular route and
we need to if that's running under the
root directory then we need to separate
that from a restful api and so all this
is doing is defining a restful
application within our War file
my restful endpoint is going to be a
complex type obviously you've got your
native types that would be a far too
easy example to demonstrate here when
you're going to be developing a restful
api you want the ability to actually
send transmit and receive complex types
this is an XML complex type but it could
be json annotated as well as JSON and
XML parsers for your app for your
complex objects and they basically
consist of your familiar properties and
so now I'm going to expose this this
complex type and again I could have made
this much much easier and just use a
native type like string or int or any of
the others but this just gives you a
flavor of pretty much how complex it
gets it doesn't get much more
complicated than this so I'm producing
application JSON application XML so my
caller knows what I'm capable of
delivering so it could request delivery
of a JSON object or it could request
delivery an XML object the get method is
obviously an HTTP GET and the path
that's just an additional path to my
POJO so if I wanted to access this
application I would need to call my
application namespace then my path
namespace and finally my endpoint
namespace space and you can see I'm just
constructing a really simple POJO object
and I'm returning it so there's nothing
really complicated about this method
it's very easy to implement
this is just an example of a client so
with the ee6 they kind of missed the
beat it's been done in EE 7 but 86 there
was no client API for accessing your
restful endpoints you were kind of left
to your own devices and various
implementations were developed we're
using here apache cxf because that's
what we're using on the server side so
it's easier to serialize and deserialize
but with the e 7 we now have a full api
for extracting information from restful
endpoints in a standard format but it
looks very very similar to what we're
seeing here so i'm accessing my client
you can see app was my application path
api was my restful path which i've added
to the application and then my rest was
the poggio object and complex is my
endpoint I could have multiple endpoints
in my my arrest path which is why you
saw on the pojo object we had a path
annotating the object itself and then a
path annotating the method so I can have
many methods within one particular POJO
object
this is nothing particularly to do with
rest itself but just a nice example of
when you're actually extracting
asynchronous information from your
server in a swing client that you're
using and checking your dispatch for
your safe object so you can see I've
received an object and that's my complex
type that's been deserialized from the
server and I can now use it anywhere in
either a light client or a heavy client
I'm getting the right key eventually so
now I'm actually in my client
application I can render this complex
type so there's nothing complicated
about this I'm providing a restful
endpoint with a complex type and I'm
calling it through a web client and
exposing that in a very simple endpoint
application
so because this objects been defined and
I've added this to the mybatis project
it's obviously not gonna work if I keep
typing in the code
and this is basically a very simple
swing application that's going to
communicate with this end point so
you've seen how easy it was to define
the end point and literally just
clicking this button will access that
object and print it out and I can click
that button and receive that complex
type as often as I want so what seems
very simple is actually very complicated
in the background but done in a very
simple manner there's nothing
complicated about the code we've taken
all that complex sewing together of all
these api's and all you need to do is
start using them so the day you take
your Tampere application that can be as
complex as a mybatis jpetstore and drop
it into tommy you can start defining
your own restful api
once you've got all that set up then I
am gonna have time to show you a little
bit of arquillian that moved quite
smoothly so I'll kill um what is that
Killian our cleaners is basically a
framework that wraps itself into things
like J unit and unit and provides you
with familiar unit tests of your entire
application server our Killian provides
you with bombs that have all the import
so they have all the dependencies you
don't need to go and hunt those down you
just need to import the Killian bombs
and actually there's a more recent
version of this that's going to be in my
talk on Thursday on our Killian cube
where these bombs have actually been
unified and pulling even more of the
dependencies that you need to test
so you can see it's just j-unit we don't
need anything more than J unit and the
Killian plugin that's provided by Tommy
so this our Killian plugin basically
takes all your information that's in
your application wraps it up nicely
packages it together and sends it to the
server for deployment and then tests
against it so this is just the our
Killian J unit container so that's
basically to complete the are Killian
bomb and the our Killian j-unit
container so we just add the Tommy
plugin and we're ready to go
when I'm testing I like to test my
application as if I'm a remote client so
one of the things here there's just
added convenience is HTTP client there's
no magic behind this it's just the
Apache component for making HTTP
requests against your server
so surefire is that's just the maven
plug-in for testing everyone should be
familiar with that and then we have the
IP lien configuration file and again
this is too much information to go into
detail but all this is basically saying
we need our application server to run
and how we want to run it you can see
we're using - one that's basically
taught me specific other implementations
or application servers to do their own
thing all that's saying for us is we're
going to use a random port that means we
can run multiple tests in parallel
against application servers and they
won't have port crashes and then to
create your arquillian test all we're
doing is run with the arquillian class
that basically tells j-unit this test is
going to be run with the arquillian
framework and please give me all those
dependencies when you when you make this
test
I don't care about
so the tests basically consists of a
deployment so my application obviously
needs to be built and this is done by a
shrink-wrap API here we're defining web
archive and we're adding some of our
classes so you don't need to add all
your classes if they're dependent on
each other but here you're basically
building a lightweight version of your
application you can mock out any complex
types that you have and this creates a
real war file and sends it to the
application server for deployment and
then we test against it we can inject
elements from our application so these
will be proxied from the server so we're
actually talking to our server we're not
talking to some mops implementation and
then we can run these tests and that's
basically a very simple are Killian test
so I just have three tests and these are
talking to our application server it
takes a lot of understanding to realize
what's being done here a typical unit
test you're going to be testing small
elements of your application in
isolation here we're taking all the
elements of your applications sewing
together in a shrink wrap archive
they're being physically deployed to the
application server that's fired up by
the arquillian container we're then
testing against objects that deployed in
that container so this is real-time
testing of your application it's a
really powerful testing mechanism and
you should be using it if you're running
any kind of application server not not
just Tommy and then just to finish up my
test octillion holy moly which is a bit
holy moly
obviously applications become
increasingly complex as we develop them
and we're just adding here jax-rs so
we're going to have a rest endpoint
again we build our archive in the
deployment and you can see this looks a
bit scary until you actually start to
read it
what we're doing is building our
descriptor dynamically so our web
descriptor might be pages and pages of
XML and we're only testing a small
element application so we don't want to
build that XML every time we're just
building a small snippet of XML we're
putting together a slightly more complex
shrink-wrap archive with all the
elements that we're going to be testing
we're switching on with our beans XML
things like CDI which tell Java EE that
CD is never used and EJB TR just tells
ask a nurse for a JB's and other
annotations so it looks slightly more
complex than it actually is
and our tests also look slightly more
complex than it actually is all we're
doing here is building a very simple
soap request and we're testing a web
service that's deployed on the server
and so you can see with our Kilian your
tests become as complex as you need them
to be for your application and again you
can mock things out
and that pretty much sums up Tommy so my
message today is really if you're using
a Tom Pat legacy application I'll stand
here I'll promise you it will work in
Tommy and if it doesn't work in Tommy
you get back to us on the Apache website
and we'll fix it for you because it
basically means we don't think something
wrong that's it thank you very much for
your time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>