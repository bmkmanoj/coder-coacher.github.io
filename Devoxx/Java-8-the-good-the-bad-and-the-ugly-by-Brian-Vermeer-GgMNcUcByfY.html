<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Java 8: the good, the bad and the ugly by Brian Vermeer | Coder Coacher - Coaching Coders</title><meta content="Java 8: the good, the bad and the ugly by Brian Vermeer - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Java 8: the good, the bad and the ugly by Brian Vermeer</b></h2><h5 class="post__date">2017-11-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/GgMNcUcByfY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">yes we're all awesome good morning
everyone
welcome so early over here I can't
understand that you will probably fall
asleep that's no problem but please vote
first thank you for that we're going to
talk about Java and I would say Java is
awesome Java is beautiful I mean look at
it it's a very nice Island part of the
Republic of Indonesia of course I'm not
going to talk about the island but
there's a little thing about it because
my mother was born here so I can
actually say that Java is in my blood
which sounds kind of cool right but
we're going to talk about this Java
I mean Java is well known well used
well opinion eyes and we know a lot
about it I mean it's quite evolved
nowadays but if we can say something
about Java
over the past decade I think we can say
it's a bit conservative if we look at
the schedule of releases over the last
decade we can say that some of these
major releases were more important than
others let's take a look at it say Java
5 was quite important things like
generics enhance for loops out to an
unboxing typesafe enums are still part
of the code I write today so it had
quite an impact on us as developers and
the way we code I guess just two years
after that Java 6 came out which came
which became well so kind of a standard
I guess and but do you know what main
features were in Java 6 JDBC 4.0 jax-ws
2.0 and some security enhancements but
if we compare it to Java 5 it was not
the big life-changing code
thinks we had in 5 right between 6 &amp;amp; 7
there's a huge gap and we all know why
that is
so you could say that we could if you
look at Java 7 some awesome new code
constructs would come in but do you
actually know what was in Java 7 diamond
operator tried with resources but my
favorite new feature of Java 7 was this
one we could use underscores in literal
numbers but we're not here to talk about
history we're talking about Java 8
because Java 8 promised us new things
new ways of coding new ways of thinking
and new ways of solving problems
Jeff a9 just came out there are enough
talks about Java 9 but who is using Java
9 nowadays in production good you're
using Java 8 in production right who
does who is still on Java 7 please my
great thank you okay so Java 8 it came
out in March 2014 which was
approximately three to four years after
Java 7 it promised us new features that
changed our way of coding things like
higher order functions we used we are we
now a we are now able to program in a
more functional way life changing they
said but we're now three years ahead of
that and I guess it's a good time to
look at what we have seen in Java eight
how to use it what kind of code
constructions people are using so
eventually what is good what is bad what
is utterly ugly first let me introduce
myself I'm Brian I'm just a software
engineer working for a small Dutch
company called blue for IT we work for
the top 100 companies in the Netherlands
project based currently I work for a
large bank in the Netherlands Rabobank
I don't know if you know it doesn't
matter because what matters is this you
all have that app right the my deaf Fox
app and please if you don't know what to
fill in I gave you an example over here
just five stars just fill in these
things and we're completely settled you
can fall asleep after that no problem
but if you have another opinion please
vote and gave up give us our feedback
because there are a lot of people over
here and the feedback is very valuable
to us as speakers this is considered a
best practice talk and the problem with
the best practice is that is just an
opinion I mean a best practice is a
commercial or professional procedure
that is accepted or subscribed as being
correct or most effective again it's
just an opinion
these opinions are well staffed are well
researched of course but there could be
an edge case in your situation that some
things that I would say do not use this
will be good to apply in your case so
the foremost thing that you have to do
is please keep thinking and make your
own judgment so for the people that were
a few guys or few people over here that
we're still on Java 7
so why Java 8 they promised us the few
things first of all paralyzation was the
main selling point we could run things
more parallel
all right let's boilerplate code through
things like lambdas and that kind of
stuff and fewer lines of code if you
apply the laws of software engineering
could end up in less errors or less bugs
and it gave us some new solutions to
problems we already known and we already
used to solve but we could now solve
them in another way say optionals or
something
well let's mark that down because the
one thing as developers as we as
developers do is we are actually a bit
like little children I mean if a child
gets a new
it doesn't matter how much awesome toys
he has he wants to use that brand-new
toy and it has to come everywhere he
wants do everything with that a bit of
that is the same with developers we have
new things like dreams lambdas and we
want to fly them everywhere but is that
good even do we know where why they are
invented how they should be used so
let's start with lambdas first of all to
use something and to use something
properly you have to know why you should
use it right I mean I can have a screw
and a hammer and I still can get to
screw into the wall but it's not the
proper way to do it
so lambdas lambda in in functional way
are anonymous inner functions please
remind these three words please please
keep that keep you look at those in mind
so actually there are nameless functions
without boilerplate all right so no
signatures and we can use them in ER so
like in line but the problem is first of
all is with function do we know what a
function is before Java aid because we
live in an object-oriented world and
actually we do not have functions we
have methods and methods live inside a
class so actually methods are
subroutines of a class so what's the
difference between a method and a
function if we talk about it we probably
think it's the same thing but it's not
because in Java in Java 8 a function is
simply something that satisfies the
functional interface and the functional
interface is nothing more than an
interface with one abstract method again
anonymous inner function I will come
back to that first of all please
pronounce it as lambda and not lock da
because the lamp is something on a
circuit lada which was an old car brand
and I heard so many pronunciations is
lambda well personal I know
how do you write a lambda well on the
lower lower side you see an example on
the left hand side you have some
parameters you have an arrow and a
function body which seems quite easy but
we are talking about this functional
interfaces let's quickly run through
them because in Java eight we have four
of them four main functional interfaces
the predicate the function the consumer
and the supplier well it's quite obvious
the predicate gives you back a boolean
something is true or something is false
a function takes something does
something gives you something back the
consumer is like my wife it takes
something it doesn't give you anything
back and the supplier well that's not
that's mean with my credit card right
can I buy this no I'm kidding she's
actually watching your live stream so
sorry dear I will not I will not make
that joke again
I swear so first of all this is wrong
why it were anonymous inner functions
and now I make it I declared it to a
variable but just for the sake of
argument you see four examples of those
four interface I just gave you the
predicate which make sure if something
is even or odd the consumer who takes
your input and does nothing but a
side-effect the supplier who gives you
something like math but random and a
function in this case takes an integer
and gives you back a string there are in
more and more of these function
interphase of course and you can write
them yourself
one of these one of the things that can
be used is something like by function
that takes two inputs and squeeze them
together which can be handy if you have
to integrate a few things but these
functional interfaces are not new
actually these things we already knew in
Java 7
because in Java 7 we had DS the
comparator the collar ball and the
runnable and the funny thing is we can
now write them as lambdas which is quite
cool
because normally in Java 7 if we do
comparisons we need to Burnie to write a
comparator compared to like this we have
our list of beers yes there was a big
over there there was a big Dutch party
at be essential yesterday I know so this
I was inspired by that I have three
beers over here and normally I want to
compare them in one way or another so I
had to implement compare the comparator
like this but if you actually look at it
there is just one small part that is
important for the comparison right this
part so why not scratch everything away
and only supply the part we need well
that's possible now by using the
collections that sort with the list I
supply and a lambda I can now get rid of
all this boilerplate and you see we use
it as an inner function because we can
now use functions in our they call it
again in Anglian English well now we can
also use the sort function on beer
itself because of the fact that we can
use we can we can we have static methods
on interface that was worth looking for
so what we do now is instead of
implementing the complete comparator we
only give the important part we can give
behavior to a function so actually we
create it or we are now using a
higher-order function we can give
functions as a parameter by seeing this
we can do this ourselves we can lay we
can make ourselves a new layer of
abstraction just a small silly example I
have two lagers one that has to log
uppercase and one has to lock lowercase
and yeah I know my methods has to be
small but I have a huge pile of code
before my statement and a use pile of
code after my statement and what we saw
previous to Java eight was that people
would take the piece of code duplicated
and just reroute rewrote the the part
that was different like we do here but
because it's just a small part and it's
actually it that for for 99% is that's
the same thing we can now use these
lambdas as a format of abstraction in
our own code like this we do not have to
copy/paste the things again but we make
a function that does these things and
takes a function as a parameter and now
by creating the two functions above the
log over and the log lower and we supply
it with the behavior it needs we can
have smaller functions and we do not
have to do the copy-paste things anymore
higher-order functions quite important I
will come back to that when I talk about
streams but writing a lambda how do we
write a lambda with roughly we have two
kinds of way to write a lambda a lambda
we can write it as a single I lambda as
you see on the upper side or we can use
it as a multi-line lambda which we see
on the lower side there is something
called method references we can use it
as well and method reference are simply
the thing is if we take one parameter
and we actually directly supply it to
another method we can simply shorten it
to the second line we have here the only
problem with that is if we want to do
more than just pass it through we have
to rewrite it back to it usually to an
old-school lambda people who are not
into lambdas yet I think it's wise to
avoid these at first first write the
lambdas with the arrow and get used to
them and after that you can refactor it
if you wanted to to these method
references so talking about lambdas and
I know you guys all use lambdas or the
bagasse who are are now using Java 8
I've got a I've got a little puzzle for
you I've got these lists of beers again
I only drink three of them because I had
to do this presentation right and I have
two sorts of functions look at it how
what will happen does line one compiles
and line two doesn't line two compiles a
line one doesn't both lines compile or
what the hell just give me one of these
beers D of course is the right answer
but which of these other three is right
just take a couple of seconds we are all
brilliant software engineers so who says
live answer eight who thinks Ansar Bayt
who thinks answer C who think answer D
I'm with you after data three right we
just roll back into the city and get
some beer also the guys who thought that
answer a was correct it's true answer a
compiles an answer B doesn't now why is
that it's a little silly of course but
the first one is a single line lambda
the second one because of the brackets
is actually a multi-line block lambda
which I secretly wrote two rewrote it to
a single Islander
but what does that mean the single line
lambda has an implicit return we do not
have to use the return statement and
this is actually the way lambdas are
supposed to be written and I will
requite venket if you use a block lambda
the people who wrote lambdas like punish
you by you you have that that you have
to use the return statement by using a
return
return statement in the second one you
will get it running so that's about
block lambdas and block lambdas normally
you write them like this if we need to
do one thing more than one line we need
to provide the brackets and we actually
write down a complete function body and
we have to supply it with a return value
I would say don't do block lambdas
because it's ugly and you can imagine
that if you give these lambdas as a
parameter to another function so to a
higher-order function and your function
or your lambda is like 15 60 lines of
code if not it doesn't get any better it
doesn't get it raises the complexity
instead of getting it down but if you
need to do more you first need to ask
yourself well do I have to do more in
one function perhaps I have to split it
up in two functions and if I have to do
more in that function
perhaps we should abstract it into a
method and actually give the method a
better name than my method of course and
it still is declarative so in this way
we can still use our lambda as a single
line and it actually says what it does
it actually says what it needs to do
because I will give you example of some
sort of block lambda I saw in code I was
working on things like this putting
complete if-else statement try caches
into a block lambda does it make things
more readable and the thing we want to
do with lambdas is to comprehend just a
tiny little bit of functionality and
pass that to a function well if you pass
this to another function good luck for
your colleagues
good luck maintaining it and I don't
think that anybody will love you anymore
so short thing about block lambdas
please don't use them please redo
to a one single line if you do more
abstract it into a separate method oh
guys he was while you were sitting there
on the stairs there are a lot of C's
here in front so come up I won't bite I
will kick you I promise next thing about
Landis type inferencing lambdas have
automatic type inferencing it's static
there's nothing special about it but
please make use of these automatic type
inferencing you do not have to supply
the type of your parameter in this case
you can just use it and perhaps b1 and
b2 are not the correct ways to do that
you have to give it proper names of
course because names are more important
than the types but please we want to get
rid of all the boilerplate code so why
give types if you don't need to think
about it
next thing parentheses again we are
using this as abstract inner function by
using parentheses on our input parameter
and this time and this time here do we
only have one parameter it's useless I
mean if you have a mathematical function
like the thing above the parentheses are
useless as well and if we supply it to a
function or a chain of function the more
parentheses you use the harder it get to
read get 30 minutes left all right let's
jump into exceptions exception handling
at first this is the main question I
guess how can I throw checked exceptions
from inside Java 8 streams or lambdas
who's got the correct answer for me just
cream
no answer yeah it's true because because
the simple answer is you can't you have
a slang awesome
yeah you can't use other libraries but
I'm not talking about Java eight like
Java 8 just gel eight with other level a
libraries like gel like Java slang they
build things around it and I can give a
complete other talk about it but you're
30 minutes left I do not have the time
for that sorry but you're correct you
can use libraries for that but if you
just use plain Java 8 as it was designed
you are not able to throw checked
exceptions and the inside of use checked
exceptions inside Java 8 the streams or
lambdas at least not directly so if I
have a function that throws an checked
exception and I want to do this it's not
possible the compiler will say nope
sorry
so what do we have to do well I saw some
some things like this just make a block
lambda out of it make it a try catch and
after that we can use it right well
again we just sat to each other dad
please do not use block lambdas to use
this as an inner function it doesn't get
any more readable than it was right ok
so what should we do perhaps we can wrap
it up so we wrap it up into a method and
after that we can use it as a single why
lambda which is quite I think quite a
good thing first thing I want to do say
is checked exceptions well I don't like
checks exceptions I mean how many
languages do you have checks and have to
have checked exceptions nowadays I think
Java is probably the only one and
normally if we have an exception it
would be the end of the world because
normally if a file isn't found or
something isn't there well my whole
system blows up and it's no problem that
something is going horribly wrong or
actually it's supposed to go horribly
wrong
so this is an option to do checked
exceptions if you want to check them
yourself if you don't want to check them
yourself and just tell me how many of
you guys if you haven't exceptions just
wrap it into a runtime exception and
throw it up I do that I do it multiple
times so if we do that now you want to
use that into say the stream API or in
an Inlander why not write your own
utility we have the functional interface
so we can now write our own check
function or I check for functional
interface with rows actually throwable
and okay I use the block lender sorry my
mistake but we can use at once we can
put it into one of my utility libraries
and I can use it everywhere I want with
the trap thing around it and what we
wanted to receive with java 8 is to make
certainly things more readable more
declarative well I would say that even
though it's called wrapped it's still
quite declarative quite short and quite
readable so perhaps that's something to
think about
let's jump to something completely
different or well completely different
optionals well there's I can make a
whole talk about optionals but somebody
else did it already
stupid marks doctor deprecated last year
how to talk about optional the mother of
all bike sheds if you want to learn more
about optional police go into that doc
it's quite funny and quite it resembles
the problems we all face it with but
let's just go into optionals now
optionals it's just something new and
you have eight it's actually nothing
more than a wrapper around a value that
might be absent or might be nil so what
we do if something is no we can wrap it
into an optional and we
and the person who uses this needs to
check the optional first before he can't
he or she can use his what's in it
so it's designed to tackle the null
reference problem well of course there
are different opinions about it some
phase it's it's the lifesaver some say
it's well the purpose is quite good but
the way we implemented it is quite ugly
for example if we have it is quite
simple concept if we have an R if we
have an optional string it can be empty
or we can have a little string in it and
you see over here that normally you
would or return see the first two lines
you first you will you return or a
string or a no and now we just return an
optional and the one who's using it is
forced to check the optional so you
would say optional has two choices right
and there you're wrong
because we live in an object-oriented
world so optional can be nil you should
never use this but it can be so are we
get are we now rid of the null pointer
exceptions no we are not that depends on
the people who are using it so if you
are using it if your people are using it
if your team is using it don't ever ever
ever ever ever do what I did in a red
line never do this but on the other hand
if you use a library from somewhere else
say we pull something out of github and
I don't know who wrote it we are still
not sure if they used optional in a
correct way we have to investigate so we
have to be careful these optionals can
be no please always avoid this in your
own code because there are still people
who are first describing all the
variables they are using appoint them to
know and after that you are using them
and if you forget to have that optional
rewritten to something that is useful
you end up with a No
using optionals well optionals are quite
strong if you use them in the correct
way but don't use them unnecessarily if
you see the first line it's quite silly
right we have a string which can be nil
I wrap it into an optional and I ask the
optional if it's present it's like
sending my girlfriend to the mailbox no
no I get to in a mil box I get a letter
give it to my girlfriend
I say well there if there a letter in
that envelope well I could easily check
it myself this first line doesn't give
me any more readability the second line
well we can discuss about that but if
you see the first line well probably you
should do the easy mil check as we
already did if you want to use it the
first line please don't now you are the
child I described we have optionals
let's wrap everything in optionals no
please don't use optionals wisely use
optionals in a more functional way like
this say we have a fine function and
it's fine function can give me something
because the bear is found or can give me
nothing well in this case if I want the
beer I can say fine beer or else I give
it a default value which is quiet first
a readable statement and it's quite
functional on the other hand if
something is not found
perhaps I control an exception these
things are all provided and police use
optional in that way optionals are
actually used as return values or
designed to use as return values they
can have three options be aware of that
well never assign it to no and you have
to choose within your team or within
your company how to use it you can use
it everywhere but perhaps that's not
quite the way to go
but we can discuss about that we can use
it only in the things were the
publicly are available so as a return
value or don't use it at all make your
decision and stay with that optional as
I said are designed as a return type not
as an input type it just says to the
user of your public API while this can
be nil you have to check for it and I
force you to if you want to know more
about optionals go to that talk I
describe - I will give you a link later
on and he will do what March will go
into deep about optionals and all that
kind of stuff but let's continue to
streams because these are the awesome
things right because streams what are
streams
streams are actually a new design why
because most loops we are use are
actually this is actually the same they
have some sort of repetitive design
pattern the stream API gives us some
sort of abstraction in that and we can
pass lambdas into that to use the stream
APR even more awesome than it already is
we can utilize all the higher-order
functions in the stream API but what is
a stream first of all it's not a data
structure please do not use it as
storage and I will tell you why in a
short time but remember no data
structure because a stream is actually
something that is derived from a data
structure like a collection the
collection is the static thing and we
derive a stream from that it's something
intermediate which is quite difficult to
comprehend it's an intermediate result
which by nature is lazy
well lazy that sounds good normally I am
lazy it can transform data but cannot
mutate data so we have to be immutable
or stateless as if you may want to tell
that way and the fun thing about streams
we carry it you make we can create
pipelines
well give me an example a simple stream
I make I derive a stream from the list I
use the map function with a single line
lambda of course and I collected back
into a list we have two types of
functions on the street an intermediate
function which give me back a stream
which is lazy so it doesn't do anything
until I tell them to tell it so it's
like children or like me actually if my
wife tells me like police throw the
garbage out yesterday please throw the
garbage out do you want to have food or
not throw the garbage out and then I
will do it same holds with the
intermediate function it doesn't do
anything until we use a terminal
function and a terminal function kicks
off the stream and does something with
it and actually gives you back the
results you wanted to so normally we
should do something like this you want
to look into a list of beers and I want
to have the beers that are good because
I like my good beers normally we would
would have done it like this right but
with a stream API we do not use the we
do not have to use these invitations we
do not have to supply how anymore we can
just describe what we want we can
declare what we want like this so if I
want to have a good beer simply filter
them and I want to only have the name so
I map that function over it and I put it
back into a collection so we're
utilizing these higher-order functions
explaining how instead of explaining
what instead of how but you do not have
to apply these to all loops I had
colleagues that were like okay now we
have streams let's well it's Saturday I
have a few hours left let's rewrite
every single loop into a stream you have
to consider if first of all it gains you
anything if it doesn't gain channel
thing like readability Lex complexity
you shouldn't rewrite it just take
careful notice at your own code and if
it's probably if it's worst end of but
then the example above like multiple if
statements perhaps you could rewrite it
into a stream but you do not have to use
it as a purpose on itself
somebody told me yeah but we have to for
each now right well the for each is cool
or if the for each is kind of syntactic
sugar for the same thing as we wrote
above in the for each is in for each
statement we can do side effects and we
know that side effects from a functional
perspective are quite evil don't do them
unless you have to but it doesn't Jenny
anything because you can we can argue if
it's read more readable or not but in
this case I just do everything in it for
each group so I have to rewrite it into
a multi-line lambda which is not pretty
and again we do not utilize the lazy
nature of the stream API instead of that
perhaps I need to do a side effect well
do you say I have this example I have a
beer and I want to enrich that statement
which say the ratings and the reviews it
gets on the internet or something
normally you change the state of a beer
but what you could do is make a function
on beer which supplies you with a new
instance of the beer with the ratings
and in that case you can still utilize
the stream API so to use the stream API
in a more constructive way you perhaps
have to make sure that you do not change
state or well perhaps you do not you
cannot change state into the streams
so by using these kind of functions like
here new beer with rating or new beer
with review I supplied with a new beer
and I now can easily easily use the
stream API to write it down in a more
declarative way and in a more easy way
to read are you still awake good because
I have a new puzzle really for you say I
am had to applaud a mission and my
normal teams were team alpha Bravo
Charlie and Delta okay I wanted to use
that that the list but then team leader
Bravo called me and he said well sorry
two of my men are sick so my my team is
not complete and I say ok no problem
we've got I've got a spare team team
echo and I just put it in so for every
team in that mission I want to put in it
out because I need to get my rap sheet
back to my superior what would be on
that rap sheet let's take a minim a will
that be alpha Bravo Charlie and Delta
what about the alpha Bravo Charlie Delta
it will give me a concurrent
modification exception alpha Charlie
Delta echo as I wanted to be or just did
it just gave me a co-current
modification exception just take two
seconds three seconds for perhaps
play a little show of hands who thinks
answer is correct a few thank you three
things answer B is correct nobody see
deep well some of you paid attention
because it's a Jersey and why I didn't
do anything with the stream that's a
correct answer
I just declared the stream team dot
stream and I assigned it to a variable
but I didn't do anything with it streams
are lazy remember so I do something and
streams are derived from a collection so
I removed something from the collection
I added a new team to the collection and
after that I say to the stream do
something and then it does the work and
because it's lazy and it is derived from
it's direct from the original collection
alpha Charlie Delta and echo will be two
correct answers and what's what does it
say first of all should we give a stream
as a return value I don't think so
because a stream can be utilized once
and once only so that means I will come
back to that later because I haven't
have an example of that but more
important it is derived from a original
collection so you have to make sure by
when we utilize the stream or when we
kick off that stream with a terminal
function we have to make sure that the
original list is not modified at the
same time as we as we are actually using
our stream now we didn't because we
didn't do anything until the last line
but if we work with concurrency perhaps
that can happen you have to make sure
that that doesn't happen
streams are derived remember that I said
something about only user stream once if
you use this example
the first timeline works the second line
doesn't because although it's the same
line you can use a stream only once
after that it's done and we have to
declare a new stream or the arrive a new
stream from that collection that's the
reason why you should never return a
stream from a function if we return a
string format from a function say in an
API I use and I see they gave me a
stream back what conclusion can I get
from that I don't know if the stream is
already used is not used so I have to
assume that it's already used so what
value does it add to me if I have that
stream as a return value the only thing
I can imagine is perhaps I can use the
another collector on it so I don't have
to collect it into a list but probably
in a set please do not give a stream
back as a result it's intermediate and
keep it in the same function or in the
same method as you derive the stream
phone you have to consume the stream we
saw an example of that but if you see
this example we have a stream we limited
by 10 and we map over it and we use
piqué and piqué is a nasty method
unique is a nasty thing because it can
do a side effect but gives you back the
stream and if you read this say quite
fastly you would say okay it draws a
runtime exception but it doesn't do
anything because peak is intermediate
it's lazy it doesn't do anything until I
say do something and I kick it so don't
forget to consume your stream if you do
code reviews or something you see like
this thing alright well looks good next
you have a problem in your system on the
other hand it's no problem to use mode
to use a function multiple times what we
want to achieve with streams is getting
things more readable and less complex so
we attempt to squeeze everything
one lambda or one function but it's
quite a good thing to filter first on in
this case the alkyl percentage and after
that filter again on the ratings you do
not have to squeeze this together and
people attempt to do that don't just
make the tiny little baby steps I mean
if you ever build an IKEA closet tiny
little baby steps everybody understands
it and if I see it over here I see two
times the filter statement well it does
I are I understand it and that's the
most important thing you have to
understand in and have to be
maintainable next think infinite streams
well we know this will run forever right
we have an iterator and we say for each
imitable runs forever and ever and ever
and ever
normally you limit this and there's no
problem with a limiter we would say well
okay limit it to ten but this thing will
run forever as well I mean okay and the
iterator does something it distinct
something it limits right and now I do
it for each just try it it runs forever
it's a silly mistake because this thing
doesn't know that the iterator only
produces two elements so it keeps
running forever or it keeps running
until we have ten elements if I would
rewrite it to limited - it will
terminate what we have to do is to make
sure that limit and distinct are the
other way around and then it will work
fine but can you imagine if we say this
will run forever what it does to this
parallelization is good paralyzation is
awesome but if we do this in parallel
and you didn't see it you have quiet and
awesome well while you've quite a
problem in production I would say it
would just not blow up one core it will
blow up all your course and it will get
quite hot in your data center or if you
run it in your cloud you will see it at
the end of demand on your credit card
so we have to watch out with parallel
parallel is nice but it's not the magic
Harry Potter wand parallel uses the
common fork/join thread pool and this
thread pole is not something that is
indefinitely or as big as it can be no
it's just as big as it is so if you use
parallel everywhere this thread pool
will get exhausted so if you use
parallel everywhere everything can be
slower actually so you have to take care
of do we use parallel everywhere no just
use parallel in the things you do not or
you need these this computing power and
normally I think in 9 out of 10 times
don't use it if you use it everywhere
you will see that your system will get
slower your individual functions will
get faster but I'll combine together it
will get slower so streams don't replace
every loop with the stream just look if
it's adding something be careful with
infinite streams only uses 3 months be
careful with the parallel I just
explained that a stream is not a data
structure and I'll repeat again that it
is not a data structure and stream
pipelines do not anything until you
consume it to summarize everything up
the other aid is great music is a great
addition to the to the other the things
that it are in Java 8 are a great
addition to the other language but Java
8 is object-oriented it's quite
different from Java 7 but we still live
in object object-oriented way it's not a
functional language so don't use it as a
functional language there are some nice
functional features we can use and we
have to use it in the correct mindset
use them with care and was I said don't
be a cowboy and don't be that little
children they did a little child that
wants to use it everywhere if you want
to know more the puzzlers are actually
well inspired as I would
say by this talk Java 8 puzzlers too
strange too bizarre and wonderful by
Baruch and and Victor which was a VG
accession you can look it up I will
publish this slides of course and if you
want to know more in depth about
optional please go to the DevOps talk
from last year I have that youtube link
as well over here optional the mother of
all bikes yet buy a bag
bye bye stupid marks I hope you liked it
again I hope you already voted if you do
not I have somebody at the door who will
stop you until you vote now please vote
just please just give me feedback and my
name is Brian I work for a company
called blue for IT I hope you enjoyed it
and if you have questions I have 1
minute and 30 seconds left so I would
say come up to me find me around or
tweet me thank you so much for being
here and have a great day box</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>