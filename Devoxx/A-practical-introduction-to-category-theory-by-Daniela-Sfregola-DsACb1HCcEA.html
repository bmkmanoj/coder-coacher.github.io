<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>A practical introduction to category theory by Daniela Sfregola | Coder Coacher - Coaching Coders</title><meta content="A practical introduction to category theory by Daniela Sfregola - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>A practical introduction to category theory by Daniela Sfregola</b></h2><h5 class="post__date">2017-03-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/DsACb1HCcEA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so what is this talk about these talk
about is going to be a practical
introduction to category theory but it's
something that I discovered fairly
recently that I didn't know before so I
believe I have a background that is
common to most of you guys so I've done
basically Java the whole of my career
right and then one day I decided about
four years ago to move towards another
language this language was Scala and
obviously it was using a pattern that I
wasn't used to so I found myself not
being a mathematician having in a way a
lot of people that will tell me that I
was doing things in the wrong way
because I was using object-oriented
programming but the cool kids are using
functional programming and I wasn't cool
and I struggle a lot through this
transition again I'm not a mathematician
so it's something that never learned at
school it was something that initially
wasn't natural to me at all
it was just what the hell are they
talking about what they're so passionate
about it but it is a process that is
faithful but that actually was amazing
and that I would suggest everyone to at
least think about it so how do we reason
right how our brain works so since
school what we learned is to take a
problem decompose it in small problems
so those smaller problems and then
combine them together so for example if
we have the problem let's find this room
we could they compose this problem by
saying okay I'm gonna find where the
building is and once I know where the
building is I'm gonna find the which
floor the room is and then I'm gonna
find which door is the one that I have
to go through obviously when we reason
like this we don't care about the
details so we don't care
about the fact that we need to walk that
we need to contract our muscles to
actually make the movement it's
something that we don't care at that
point is not relevant to our problem and
this is how most of the people reason
about things and everything is about
composing things together and not
distracting out the details and this is
something that we do every day when we
code things right object-oriented
programming has the idea of composing
objects and extracting out the behaviors
so you have an object that you know
that's something but you don't know the
details of how it does that specific
thing with functional programming is
that you don't have objects you have
functions and the abstraction is given
by much magical laws okay
it's cool we understood that in a way
composition abstraction is at the bottom
of everything but what do we care so
category theory is at the base of
functional programming and is the theory
they study how to abstract they compose
things together
I don't like technical terms this is a
practical presentation so I'm gonna
rename all the things that I don't like
so I'm gonna call category theory has a
rotary because this basically what it's
about
so let a promise this gonna be the first
and the last definition and then we are
gonna go to practical stuff because
again we are not mathematicians we like
code we like reality so what is a
category a category is well it's just
arrows really you have some things you
can call them points you can call them
notes that are ABC and then you have
some arrows that allow you to move from
point A to point B using F
from point B to Point C we using G and
you have some rules about around these
kind of movements so for example you
know that if you go from A to B using F
and you go from B to C using G then you
know there is gonna be a way to go from
hey to C and that's G after F the second
rule that is at the base of everything
and the rule that IG mention was the
rule about composition again composition
is about abstracting out all the details
so that everything is gonna be the same
so the identity rule that is you always
have a way of returning where you are
right and this is pretty much
mathematics right we are back to school
but we don't like those times there were
bullies at those times so this doesn't
really make much sense for us right we
are programmers but maybe these does so
the graph that we just seen could be
translating this in the following way
instead of having notes or points you
could have types right so you could have
a function that is called size that
given a string is gonna give you an int
and you will have another function that
is less or equal than to that given an
int is gonna give you a bullet
it's what if you combine the two you you
will go from a string to a boolean
that's the composition log same for the
identity lo you have a string you can
concatenate it with an empty string you
will get the same string obviously there
are a lot of ways of doing this like for
example we could get a string and revert
it twice and we will get the same string
again so this is cool this is what if it
agrees and I promise this is was the
last tariqa bit but what do we care the
reason why we care
because on top of this category theory
some mathematicians that are a lot
smarter than me
have former some rules on things that
concatenate well together so the first
rule that we will see is now gonna be
terrible I promise it's gonna be Monat
but we don't like more at one of these
award very scary you so we're gonna call
ad to do least button okay so um like
speck some pizza I'm Italian so what's
better than Pizza
so we have our to the list um get the
door get the sauce get the cheese and
then there should be four point cook in
the oven until golden right this is
natural right that's how people reason
about things so how would you translate
these in code so myself four or five
years ago I would probably have done
this in the object-oriented way um so I
would had a function get though that
returns an ingredient another function
get source their returns source saying
for the cheese then I would just make
sure that everything is there and I
would have called the function cook the
returns a pizza right um obviously what
happens if for any reason the dough is
not there or any ingredient is missing
we explode a 9-point exception right
we're familiar with that I've seen it so
many times in my career you guys have no
idea and this is worse but obviously
it's not as pressive enough because we
don't know if something is actually
possible that something is there or is
not there it's gonna be our maturity has
developer to say okay I don't trust this
let me make sure there is not now right
what happens with the monadic approach
so with the melodic approach um is gonna
be the type itself that is gonna tell us
by the way this may or might not be
there so you will have an option that
means before we have a function get
though that this time is not returning
an ingredient it's returning an option
of an ingredient and saying for the
sauce and the cheese the function cook
is exactly the same but basically this
is just to the list where we say cut the
dough if step one went well go to step
two that is get the sauce if step two
went well go to step three get the
cheese and so on and so forth so this is
just syntactic sugar the guarantee is
that the the ingredient is gonna be
there it's gonna be extracted what
happens if something is not there the
whole expression is gonna be none
meaning it's not gonna be there right so
the whole idea is that this expression
is gonna be none sorry yes it's gonna be
an option over pizza instead of just
being a pizza so the type itself is
telling us two things
what to be aware of meaning that it
might not be possible to make a pizza
and the second thing is telling us how
to compose them together meaning that if
any of these options are not there the
whole thing is gonna collapse and it's
gonna be none so it's really informative
so everyone so far so good with me yes
cool
obviously option is just one of the
things that you can do with this pattern
you can do basically whatever you want
so for example in this community we have
options that represent the fact that
something might be there might not be
there we have try that it's something
that could throw an exception and we
have future they represent something
that is a synchronous so that
potentially could fail but nothing stops
you from implementing your own so if you
have a domain where you have to
concatenate things together and one step
depend on the previous one implement
your own you're not gonna worry about
checking failures and edge case
scenarios but obviously this is just one
way one type of composition the category
theory offers us right not everything
works with this type of composition so
we are going to see another example
there is data validation and we will see
how we are going to soon realize that we
want to think impose things in a
different way not in a concatenation way
in particular we're going to talk about
data validation why did the validation
because everyone has to validate data
right if as soon as someone's gives you
some data there's a really good chance
that you will have to do something to
make sure they didn't send you something
that doesn't make sense in your context
and also in particular for the business
validation it does change quite quickly
so it's good to organize it in a way
that it's easy to remove and add bits
accordingly um so what we are going to
do is that we're going to have some fun
we are going to try to implement the
function that that validates this form
so we will have an email a phone number
and we will have a function that will
return yes this is good or no this is
not good because of its reason this
reason this reason right so the first
thing that we really tented to do
actually I'm sorry I'm running a little
bit here this example we are going to
use the scholar how many people in the
audience are familiar with scholar have
done something okay cool I would say
half but this is not it's nothing to do
with scholar potentially any language I
could have these patterns implemented
and the way we are going to do this in
scholar is by analyzing how we have
implemented Monat
the first piece of the puzzle is map
right map is simply a function that
allows you to access the value inside of
your wrapper so if you think of an
option like a wrapper that gives you
information about the thing inside
map will access that thing inside
without unwrapping it so if you have a
sum of a string and you map over it you
will still have some what happens if you
try to map a container that doesn't
contain a thing well you will get
nothing in return
right everyone with me so far
cool ok the second piece of the puzzle
is phat map what is that map is map plus
flatten not going crazy it's just that
sometimes you want to concatenate two
containers together right but you don't
want to put one container inside the
other so what you do is that you say you
know what just get rid of one container
in practical terms it means that if I
have a option of a string and they use
flap map and I slap another option of a
string if I have a sum I will get a
combination of the two elements inside
if I have none I will get none in return
so this is basically concatenating
containers together I think that the
sugar nothing crazy again if you have a
map and if you have a sub map is
actually more complex than this but for
this talk
let's assume is this is the case you can
write some syntax like this they will
basically allow you to concatenate
things together so if you have a sum of
one a sum of five and you say extract
the values keep them together
and then some them you will get her some
over six if you do the same and one of
the two values is none you will get the
whole expression that is not okay cool
now back to our problem so this is color
code nothing too scary about is really
similar to the Java options you have an
option there is a type that is either
sum of something or it's none and we do
have a map and we do have a flat map it
means that we can write expression like
a to-do list so our case study again is
to validate an email and a phone number
and concatenate them together in a class
you see if they make sense so we have a
case class that is data that contains an
email and the phone then we have a
function that validates an email that
gets a string or interns an option of a
string and then we have the same for the
phone note the we return an option
because if the string that we passed is
not valid then we have decided to
represent this in this way if we do that
then we can just say validate the email
validate the phone number and then if
they both exist combine them together
and put them in the data case clause
anyone can see any problem with that
okay the problem with that is that a
kind of work but it's not exactly what
we want to do um so if we analyze what
the function would return so if we pass
a knock you need an email that it's
valid and then affirmed in is valid
obviously the the function is gonna be
fine we are gonna see both the values
but what happens if we find if we passed
something that is not valid but just
look at the output of the function we
don't have any information on what
what's wrong
so was it the email that was wrong
what's the phone number that was wrong
was it both we have no clue right this
is basically the equivalent of saying is
it valid yes no right so it is exactly
the same of using a boolean and this is
not what we want to do we want to do
something a little bit more expressive
so just don't please this is not
expressive enough if if this is all you
need you might just use a boolean I get
over with it so okay we we want to try
to be a little bit smarter okay so
option is not expressive enough so what
about either either is another type that
exists in Scala but again it could exist
in any language either is a type that as
either a left sorry
good selection of words so you will get
a left or a right if you get a left you
cannot get a right if you got a right
you cannot get a left so it's basically
one of the two again we are lucky we
have a map and we have a flap up so we
can write our to-do list cool
so back again had our problem so you
have a case class that has there is
called data that has an email and
phone number then you have a function
that validates Timo they take a string
and this time returns and either of a
list of errors and the string saying for
the phone number and we try to
concatenate them together to write our
validation function so we start and we
say okay validate Timo okay and then if
everything goes well validate the phone
number we take the values if they are
both valid and we put them in our case
class so what's wrong with this one
the problem with this one is that it
will be more informative than an option
but it will not list all the things that
went wrong so the first one works right
okay email okay phone and we see data
but in the second example bad email bad
found you will only see the first one
and this is because we are concatenate
things together so if the first one
fails we will not do the second one so
can you imagine a website with let's say
ten forms and you compile you fill all
of them and you send a and you say now
the first one is wrong you fix it you
send it again
now it's the second one that is wrong
you feel it again okay now is the third
one that is from I would never use a
website like this right so what we want
to do is not concatenating things
together but we want to compute all the
validations in parallel and then if
there are any problems we want to
accumulate them together yeah okay
so either doesn't work well in this case
and the reason why it doesn't work
yes because it doesn't accumulate
results it concatenates them so if you
don't have to accumulate errors that's
fine but this is not the case we want to
show everything that went wrong in our
data so how this point we just try to
battle match or if you're not familiar
with pattern match i for a java audience
I will probably say we try to do a
switch case right and we say okay if
they're both valid put them in a case
class if they're both wrong combine the
things that went wrong together and then
if only I got this boring can you
imagine what to do if you have to
validate more than two things together
so if we have to evaluate three things
we will have eight case scenarios right
if we have to believe it four is gonna
grow even more exponentially right so
this is the right way of doing it it's
not something that you actually want to
do because it's gonna just gonna be
painful it's gonna work but it's just
the code is not gonna be maintainable as
soon as you have more things to validate
it's not gonna be so easy to add new
ones and also yeah the problem is that
it's not clear what's wrong and what's
right I live in the UK I have been
trying to tell people that they drive on
the wrong side of the road but they
still doing it so he's not obvious that
left is the wrong thing and right is the
right thing so you need to make sure
that everyone is aware of that
convention so
category theory is gonna save us all so
basically what we want to do is to
compose things together but we don't
want to just concatenate them we just
want to run them in parallel and then
combine them all together and that is
exactly what applicative functor does
the name is a little bit scary but you
will see it's simpler than you think so
turns out that in the sky community we
have libraries that implement a lot of
these Combinator's cuts is one of them
and cats we have this time that is
Kavala dated that has a similar to
either but it has either something is
valid or something is invalid and it has
a map right so you can access things
easily inside but it doesn't have a flat
map and in fact it doesn't have a flat
map means that you cannot go get a knife
things together instead of a flat map
what it does is knows how to combine
things together on the left side so this
annotation is a little bit scary for
people that are not used to functional
programming but basically what it does
this is exactly what we did the last
example so we'll take all the validated
it will extract all the ones that are
invalid it's gonna combine them together
and if he couldn't do any of this it's
gonna continue and it's gonna consider
just the valid elements that he could
find what does it mean in practice same
example as before we have a case class
data that has an email and a phone
number we have a function that is called
validate email that this time takes a
validated of a list of strings saying
for the phone and how we have to do to
combine them together is to use this
crazy simple
that's it done and we will make sure
that it will abstract all the bits that
are invalid and the final result is
going to be properly formed and again
this is just gonna work just fine so if
we pass these strings that are valid we
are gonna see our case class otherwise
we are gonna see the errors so what we
have learned is that we are used to
think about objects but sometimes
objects are not that important right
sometimes in particular when dealing
with problems that require combining
smaller problems together what we care
about is how these pieces come composed
together and this is exactly what
category theory does we have seen two
examples with some an example of Amanat
that it's something that concatenate
things together and we have seen example
of applicative functor there is a way of
processing things in parallel and at the
same time and then combine them together
so hopefully I at least give you some
idea of things that you can do it a
category theory
I'll get you a little bit excited but if
you don't fell asleep it's fine this is
the thing to remember so sometimes the
details really don't matter sometimes
the only thing that matters is how we
are planning to compose things together
and there is a really good chance that
is someone out there there has already
implemented a great way of how we could
compose things together so this wasn't a
Oracle introduction to category theory
it was practical but obviously you do
need some theory as well I'm not a
mathematician so I don't feel
comfortable enough to show you guys and
board you too
laughs with some mathematical theory but
if you want I listed you my two favorite
sources to learn about category theory
is gonna be amazing I'm telling you so
they are on YouTube the first one it's
from Philip water it's it's a really fun
guy that 30 years ago came out with all
of this stuff and it was his
presentation alum of the world it was a
quite a fun one
and the second link is from a collection
of videos that go quite into details of
every single mathematical theory behind
it so if you guys want to start
implementing this kind of composition in
your language that doesn't ready have
them it's possible so that was
everything from me how I got you at
least interested into this new amazing
world he's gonna be painful at least at
the beginning at least it was for me but
it's definitely worth it so if you guys
want to see some code in action you can
find some at my that's my repo if you
guys have any comment or you just want
to contact me that's my twitter handle
so thank you very much for listening and
are there any questions
hi thank you it's really interesting now
western about the same symbol you showed
to concatenate very yeah you passed yes
this one it's from cat's library yes
it's a specific for that well so in the
in the scholar in in the scholar
community there are two main libraries
that do this one it's cats is not
because the creator of the library is
into cats a is actually a dog person is
just cat sees from category theory and
there is another library that is called
Scala Z they are basically the same but
the simile is different but they are
basically the same so in my experience
for me personally was easier to find to
understand cats because cats has a
better documentation but it's just my
personal preference they are both
equivalent so if you feel more
comfortable using the other one the code
is basically the same thank you okay
cool thank you very much guys</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>