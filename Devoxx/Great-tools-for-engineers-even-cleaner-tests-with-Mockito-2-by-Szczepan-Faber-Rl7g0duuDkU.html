<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Great tools for engineers: even cleaner tests with Mockito 2 by Szczepan Faber | Coder Coacher - Coaching Coders</title><meta content="Great tools for engineers: even cleaner tests with Mockito 2 by Szczepan Faber - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Great tools for engineers: even cleaner tests with Mockito 2 by Szczepan Faber</b></h2><h5 class="post__date">2017-04-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Rl7g0duuDkU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright let's get started thank you very
much for coming for past ten years
roughly because in 2007 I started doing
first experiments with mocking something
bothered me the thing that bothered me
was that
Mahiro like being a really good
framework with really clean api and
really driving nice clean tests for
certain specific use cases the old
mocking frameworks that Makita used to
compete with with those other mocking
frameworks you could have slightly
better experience when it comes to
debugging all right and that bothered me
for like nearly ten years and now
finally with mojito version 2 that was
released in October last year finally I
was able to address that and with the
team we started to making progress on
those use cases and this presentation is
focused around that
so although mojito has like a couple of
very nice features I want to focus
exclusively on the debug ability
experience and also like clarity of
tests like how clean your tests can be
with new hero so I'm Stefan Faber I
originally come from Poland but now I
live in US and you might know me from my
work with mojito or Gradle and right now
I'm a tech lead at linking development
tools team and my team is pretty awesome
and is hiring so think about it in 2008
there was no way to run clean tests so
mojito one point all was created I
published 1.0 in January I believe this
is where I used to work in mojito this
is the tube station somewhere in London
I used to work during on Makita on my
commute some random tech people would
sit by my side and we would do some
spontaneous pair programming that was
that was how it was done and in 2017 our
days mojito has roughly 2 million users
and it could be that top one of the top
three Java libraries and I have real
data for you to prove it so with their 2
million users that's the rough estimate
according to some official statistics
there are like 10 million Java engineers
so assuming that half of them writes
unit tests it's kind of sad but probably
true and let's say that that half
actually right uses mojito for doing
mocks this gives me this cautious
estimate that let's say we have two
million users it's pretty good also it
feels that Makita is a pretty good when
it comes to Java popularity every now
and then there is research done and most
popular repositories on github are
indexed and inspected for their
dependencies this is the research from
2016 about 4,000 most popular github
repositories were parsed and identified
what dependencies they use and mojito L
and mojito core were frequently
appearing mojito corn mojito all is the
same thing I hope you no longer use mock
it all that was the legacy artifact that
contains all the dependencies and you
know in 2008 back in the old times
such artifact was useful because at the
time people not necessarily used
dependency management as we use it today
like many times team checked in their
binary dependencies in the source code
and like the parentheses that contains
other dependencies like mojito always
useful but given mojito core in mojito
all the same thing I was able like when
I collect and add together the results
for those two we are on number three
better than guava yeah what was awesome
so in 2016 this guy helped me out this
is David Allen actually I should use my
clicker so David Allen he wrote this
book getting things done it helped me
with my life and we've worked like
getting things done and really engaging
with the open source community and
engaging with the work that needed to be
done with mojito community and some of
the other guys on the on my team on the
core team they did tremendous work so so
thanks to David Allen as well mojito to
my the way I like to think about mojito
- is that it really makes this it
addresses this gap that I saw with my
hero and like adds more debug ability
and more clarity to your test and I'll
show you all the most reading
second before that happens I want to
leave you with one thought that writing
clean tests and writing like you know
poor tests it's it takes exactly the
same effort right it's just different
level of discipline
so these add that discipline think about
the quality of your tests and you really
are not going to spend more time on it
and in the long run it will actually be
faster so I'm all for the routine tests
and now it's time for live coding let's
let's get started I'm gonna go to
IntelliJ and I hope the font is okay so
let me know if it isn't actually before
I do that the sample project that I
created for testing smart dictionary
test I actually recorded like a short
video which I'm gonna run now so that
you can see that I'm gonna turn that off
I thought that I can like test drive the
entire project for you here but then
when I recorded it when I pre-recorded
that it was like eight minutes just like
too long it would be like almost one
third of the time I have for this
session so I just show you the
beginnings so I was able to like test
drive some basic functionality like a
class and then we will be building some
use cases on top of that what I want to
highlight here is that the way I've been
doing that is my favorite style of
development which is test-driven
development and what is interesting and
sort of counterintuitive in this style
of developing is that I'm actually
typing code that does not exist yet like
if you see there like the smart
dictionary class does not exist yet and
various methods don't exist yet
I will generate those methods from the
code so I used that method to actually
design my code before I actually code it
and it's very counterintuitive because
as engineers we are more used to like
using classes that already exists right
and here it's like it's kind of
backwards the cool benefit of that of
you of developing code like that is that
I can not only like design my interfaces
and my code before I actually write that
code I can also save time on
generating those classes and those
method stubs right there from the IDE so
try it out at home you know try to write
those this is more test-driven
development use the classes that don't
exist yet and generate them from the
code I will now shift to real coding so
thank you step up for this demo here ok
so I have this class here I want to show
you let's hide actually like that there
you go I'm gonna collapse all the
methods to explain you the behavior
we're testing so I have a smart
dictionary object this is the test for
that and I have a three methods that
cover three basic functionalities that
smart dictionary provides so it needs to
look upwards it needs to keep the
history of the lookups and it will
ignore if there are any history failures
it will ignore those failures instead of
showing you the tests I'll show you the
code because I think it's simpler and
it's pretty basic I want to use that
sort of a hello world example to
demonstrate you some of the things that
I'm super excited about in mojito v2 so
we are asking wiki for the description
we are storing the lookup attempt in the
history we ignore the failure and return
the description let's get back to the
tests I will run those tests now they
all pass the problem I want to
demonstrate is the debug ability
experience when you mess something up
either you make a mistake in the test
code or the production code that you're
testing is not behaving correctly and
you are in the middle of like developing
your tests and you have this problem
that you don't understand why your tests
are failing so I will sort of emulate
that scenario that scenario I can
emulate but by making a typo in the
parameter that we use for doing things
so for example with in my test that
verifies that we are keeping the history
the lookup attempts in history I make a
typo in the argument and I will run this
test now so this will actually provide
us very nice or
Makita tells us precisely what happened
that you wanted to you are verifying the
method with the argument material what
we are getting in the argument that is I
don't know if I hope you can see that
it's a different argument if you know
how certain tricks how to be very
productive with mojito you should also
know that for all the exception messages
all the exceptions coming from akhira
that deal with comparing things we try
to use the exception types that IntelliJ
understands that's why you can do things
like that you can click to see the
difference and actually see the
difference in the arguments here in that
nice IntelliJ window so this is pretty
good for verification
mojito story when you are messing up
something with the arguments and stuff
it's it's going to give you very nice a
very nice debug ability experience you
you should be able to figure out the
problem fast however I want to show you
that for stabbing it's not the case for
stabbing the experience is not nice I
will run that test now what happens here
is that the framework fails on the
assertion so here if I click on the
stack trace it fails here and it fails
sort of late in the game like I made it
either missed I made a mistake with
stubbing so I would expect that the
smart framework hotel hey you have some
problem of stabbing because you're
stabbing with this argument but you know
in the real code when you're executing
test a different argument is used mojito
is not smart I guess and this was the
use case that traditional mocking
frameworks although of the old times
easy mock or J mock we're actually a
little bit better because those
frameworks by default were strict which
means that if certain interactions
happened with the mock objects and you
haven't accounted for those interactions
you forgot to specify those those
interactions the code will fail early
and will give you a nicer the big
ability experience you would see
oh I'm messing up with the argument and
mojito does not offer that now there is
a good reason mojito doesn't
offer that so in the next step I want to
emulate strict mocks with mochi ro
mojito mocks are not strict they are
very lenient mojito does not care if the
methyls your stabbed were used or were
not used and but what if you want to
have strict mocks in mojito by the way
any one of you who is familiar with
strict mugs would like to have strict
mocking support in mojito anyone so okay
cool I see some hands nice so I'll show
you what happens if we have strict mocks
in mojito in mojito there is no API for
strict mocks there's no like hi there's
no such feature but I can create that
feature relatively cheap please let me
do that so here instead of mock I'm
going to have a method strict mock and
same for the for that let me create that
method it's going to return it's going
to be parameterize in a return type and
here it's going to be like that type to
mock and here I will return mock type to
mock and i will configure the default
I'll change the answer there you go I
can pass a default answer that the mock
gives when any method is invoked on the
mock by default the answer with mojito
is you know return some dummy values or
just ignore it I will change that the
default value and instead of returning
something I will do throw new material
exception annex unexpected interaction
or invocation
let's say we have something like that
now I will run this test and I'm
actually one more thing thank you I'm
gonna use lambda it's gonna be nicer oh
thank you very much I wanted to do
Makita exception right the reason I'm
doing mockito exception because Makita
exception will give me some nice
stacktrace filtering but runtime
exception would do - thank you
nice capture I will run that test again
previously it failed with assertion
which is kind of late does not give me
good debug ability now when I run it
actually there's one more thing I need
to do to make it working properly and I
will not completely explain it so you
have to trust me there are two ways of
like stopping in mojito
what is this traditional way where you
say given that interaction I will return
some value there's also a way of doing
that when we start with will return
walking framework given wiki fine
description those two lines are
synonymous it's the same thing will
return is used or will throw rather this
style of syntax is used for studying
void methods the reason is there are
certain like syntax limitation I can't
have a void method here in the bracket
so sometimes like you as you use mojito
you'll have to use this slightly
different syntax of stubbing where you
inverse the order like first you specify
what you return or what you throw and
then you specify which method and
actually I think this is this should be
like that so it's the same thing I can
if I have time I can explain why in this
particular particular context I needed
to do it suffice to say for now that I
need to do it in order to have the
strict mock this damn implementation of
strict mock working okay I'm gonna run
this test now and what's happening it's
telling me now that there's unexpected
invocation which
better because previously it was failing
with assertion and now it's failing with
unexpected invocation
so it's failing closer to the problem
that we have which is nice and if I grow
that solution and add some more
capability to the strict mock I could
have made that exception even nicer that
would tell me hey this is how you have
this is how the method is invoked but it
was stabbed with a different argument so
I could make it better
that's this is the strict mock inaction
and if you can see it gives me a little
bit better failure closer to the real
problem however when I come back to the
test and let's say I fix my typo where's
my typo right I place here I'm going to
run this test it still fails because now
it says that there is a lookup attempt
unexpected because I'm using strict
mocks I have to specify all the things
that are happening with my mocks so I'm
gonna have to do something like that
will do nothing given history lookup
attempted maketo I will run it now and
it passes I'm gonna run other tests note
that the only difference I did I started
to use strict mocks I'm gonna run all
the tests now what's happening is only
the first method passes the other two
methods are failing even though when I
look at the code like the code is
correct there's nobody there in the code
so why the tests are failing so the
tests are failing because I'm using
strict mocks and strict mocks require me
to somewhat accommodate all the
invocations all the interactions I have
to specify them and this is against the
philosophy of Maki Rho mu Kira drives
clarity of tests by making it possible
and actually advocating that to separate
the behavior you're testing two separate
methods right I do not want to specify
all the things that are happening with
my marks in every test methods because
that defeats the purpose of nicely
isolated small test methods that focus
on individual behavior and even in
first test I have that problem like in
this test I want to focus on one single
behavior of interacting with the wiki
but now because I'm using strict Mach 4
history I have to accommodate that there
is a history lookup attempt so I hope
that with this example I can show you
that there is a downside of using strict
mocks and that was one of the reasons I
created mojito I really didn't like the
old style of doing like strict marks
with like easy mock and J mark for the
record there are ways to change the easy
mocks and J mocks and all those to be
also lenient but that what was the
default behavior the default behavior of
of the of easy mark or Gemma curve many
other mocking frameworks is strict and
what I have observed in large code bases
where engineers were using those
frameworks is that the typical way of
solving problems when the code base
grows is to basically add more
interactions to tests and each test
metals has so many interactions with so
many marks I did not want Makino to go
down that path
I wanted mojito to drive like more
focused specific test methods that's why
I mojito is lenient and will stay
lenient but I want to solve that puzzle
I want to make book hero easy to to
debug I want to I want to make that use
case better and finally with the mockito
v2 we got it so I will stop using this
trick mock so I'm gonna change that to
basically to be mark killed of methods
oops
when you smoke here as well
so let me let me finish off and I'll I
am happy to take questions
is that okay all right thank you so let
me run the test again this should pass
no hang on this one doesn't pass why not
do I still have typos oh I removed the
right thing okay thank you
we'll return mocking framework given
given given wiki fine description okay
I'm going to run my all my tests again
the typos that I used before could
happen or the problem with stabbing
could be here but also if you have some
complicated logic that you're testing
you might have problems with arguments
inside of the codes I will use a
different variant of this problem here
so word plus equals question mark let's
say let's say we have something this is
like an example of argument problem I'm
gonna I'm gonna come back I'm gonna run
this test so far it's not using mojito
v2 features we have an assertion failure
and that failure is a far away from the
problem and I can't easily be back home
quickly debug so in order to show you
the mojito v2 features I will start
using the J unit rule first giant rule
is something that was available in prior
version of mojito so there's nothing new
but we have added some nice new
different behavior - Jenny Drew and I'm
I'm running out of time unfortunately
faster okay so this is going to be a
mock this is going to be a mock I don't
need because I will use the journeyed
rule in a second I can use some nice
mojito notations
like that and I want to use oops
public rule mockito rule rule rule
equals Paquito j8 rule okay we've got
this let's clean that up a little bit so
I have rule I'm gonna run all the tests
again there will be failures because I
have this artificial sort of bug here
and coming back to my original test this
is the test that I'm focusing on so when
you are using J and you drill the first
thing that we've added in mojito v2 is a
warning on the console showing you that
there is something wrong with your
arguments and if you can if you read it
and if you can't quite person understand
it you can go to mojito hint class view
the Javadoc and it has a comprehensive
documentation what it really means
suffice to say that this warning is
intended to help you figure out and kind
of debug when you have those like slight
argument issues but that's like warning
is not good enough right like we don't
look at the console that often it's kind
of hard to figure out so how can it be
even better so we are at it we added a
new optional strict stub feature so I
can make my rule to operate in this
strict stubs mode this is not strict
mocking this is strict stabbing which is
the best of both world it will give you
the debug ability you need and the
cleaner tests without order all the
weight of three mocks what's happening
now when I run this test I have a
failure that is different I don't have a
certian failure it tells me that there
is a potential stabbing problem strict
stabbing argument mismatch and you have
a nice clickable exception message where
you can click here and you can find out
that
the expected invocation of that mattered
uses a different argument this is where
you have stopped out so this is like a
nice thing that is added by opt-in
feature with strict stops you can also
get that behavior using mockito Jade
runner there's also an API to get that
behavior without yuning using J you need
support so you can you can do it even
without J you need rule I won't have
time to show it but it's all very well
documented I want to show you more
features of strict stop because the fact
that it conveniently tells you what's
wrong with your test when you have
problems with stabbing it has also two
other important features one is that
your tests will be more dry don't repeat
yourself
there are occasionally use cases where
where you want to verify that there are
no other interactions with your mock for
the API for that in mojito is the verify
no more interactions method and I
personally use it rarely but there are
cases where you really need to be
specific you really don't want to have
any other interactions and in this
artificial use case when I run it
actually I'm going to go back to the
implementation I'm going to fix my bug
I'm going to run my test actually no
let's and I remove the strict stop so
this is the default behavior you get if
you don't opt in for Street stops what's
happening is that I've declared the
stabbing for the V key object I verify
that there are no more interactions with
the wiki object but it that mojito fails
but hey you know like what do you mean
no more interactions there is an
interaction there is a there is an
interaction here fine description so
Makita forces me to do this
verify wiki find description mu hero and
this is not great this is not smart
because I'm repeating myself I'm
repeating exactly the same interaction I
mean repeating this
here in two places so it was also
bothering me that for certain rare use
cases where you really need to be
specific and you want to verify that
nothing else happened
using verify no more interactions you
have to duplicate your stabbings so
basically duplicate code and like that's
not the clean code is not duplicated
code now if you're using strict stubs
you don't have that problem because
strict stubs validate that this stub was
actually used which means you we
guarantee you like you don't need to use
verify no more interactions with strict
stabbing because we guarantee that stubs
are used and I don't need to use that so
I'm more dry don't repeat yourself see
this is this is working final final
feature of of strict stabs is the
validation of unnecessary stops which
are essentially dead code I will do
let's say I have something else here bar
let's say I have some copy pasted code
or something some legacy or whatnot and
in the normal behavior of machi row so
I'm going to remove the strict stubs I'm
gonna run this test it's failing because
of the verify I'm gonna remove the
verify no more interaction so I have the
code that I had before with only
difference is that I've added this extra
additional stabbing that is not used by
anything but let's say I forgot to
remove it oh don't go I'm gonna run it
and no ketosis all good there is
actually with mojito to default behavior
or rule is the warning so you get a
warning on the console but again you
know warnings it's not something that
gives very good signal it's very easy to
overlook so it's not great if you use
strict stubbing strict stubs and run
this test it'll actually fail saying
that sorry there's an unnecessary
stabbing please remove it so you can get
rid of that code like some of the
stabbings that you don't know and you'd
be surprised if you run this mojito if
strictness if strict stabbing on your
bass how many in how many places of your
code you have unnecessary stabbings you
like you wouldn't know but there exists
and that's the feature number three of
strict stabs which is avoidance of
unnecessary stops the stuff that you
also get with Jane is runner but since
I'm running out of time I'm going to
jump to presentation quickly to finish
off and those key to three key features
and with that presentation I wanted to
give you a little bit understanding
about straight mods is that Street mocks
they add value but you know there are
certain things that they will also they
are not nice in certain respects by the
way this is this is how I looked when I
was younger but I started writing so
many tests I'm no longer that pretty so
with mojito v2 for cleaner test what you
have is like easier debugging with those
stabbing issues dry so you don't repeat
yourself when you you don't have to
verify stops and you have that test code
detection unnecessary stops are detected
other features of v2 that I didn't focus
today we have a built-in Android support
there is we replaced easily with
fantastic by the body write library we
have support for mocking finals and
hopefully at some point like getting it
even better or maybe even mock statics
who knows we'll see we have various
rather smaller API tweaks that makes
mojito more intuitive we have new API
for like extending mojito and like
getting into the details of mojito which
was nice
Java 8 is supported much better like
lambdas and things like that there is
also a really cool project on github
mojito release tools to nudge and you
know shift the Java community more
closer to the model where every pull
request ships a new version to maven
central and with that I maybe have time
for like one question and finish at 4:01
you had a question
Oh
so why I wanted to demonstrate that
strict marks in general like like
produce low quality test code base with
over specified tests that specify too
many interactions often interactions I
don't care in my in my testicle so
that's that's my belief of course you
know we can argue you can have your own
presentation about Street mocks and how
cool they are it will be thank you so
strict stop good be food yeah it is a
good default one thing I forgot to
mention is that you can easily opt out
from that default per test so that you
know for edge cases you might want to
opt out you wait for mojito 3 in mojito
3 we plan to like turning on by default
so you want to yeah let's do a mojito v
3 let's upgrade our code base and then
oh god like so many tests are failing
what's going on now let's stick to
mojito too so I think I gotta finish but
thank you very much for coming and like
catch me at the corridor somewhere and
we can chat about maketo or other things
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>