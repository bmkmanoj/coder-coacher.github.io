<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Transactional actors with Eclipse Vert.x by Mark Little &amp; Michael Musgrove | Coder Coacher - Coaching Coders</title><meta content="Transactional actors with Eclipse Vert.x by Mark Little &amp; Michael Musgrove - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Transactional actors with Eclipse Vert.x by Mark Little &amp; Michael Musgrove</b></h2><h5 class="post__date">2017-05-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Ikwj7gxemLQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">we're again inflated do it make sure
welcome to the presentation on
transactional actors using a software
transactional memory and Eclipse vertex
my name is Mark littell
I'm JBoss CTO VP Red Hat and I'm going
to be presenting the first half and my
colleague Mike Musgrove who's sat in the
front here he going to be doing is
really interesting bit he's actually
going to be showing you how this stuff
works and taking you through some some
live coding or at least some live some
live demos
this is his laptop not mine so bear with
me if I go in the wrong direction
okay so we're going to be covering
briefly the actor model and again
briefly on transactions and software
transactional memory because I want to
try and get to the the meat of the
presentation which is really the the
code walkthrough will touch on vertex
will touch on the software transactional
memory implementation that we're using
which is based on the the JBoss narayana
project and then like say we've got Code
walkthrough and Mike's got he's got four
demos if we get through all four four
that's great but I'd like to at least
get through one of them and leave some
time for anybody who has any questions
and if you have any questions while
we're going through it you know just
shout out and we'll try and accommodate
them so before we actually dive into
what this talk is I thought is important
to tell you what the talk is not there
is there's not time to do everything we
like to do in terms of showing you how
you can actually develop transactional
actors of vertex and give you a survey
of the actor model we're not going to
give you a survey of transactions or
distributed transactions both of those
are you know at least hour-long
presentations and themselves it's not
going to be a tutorial on vertex we've
had a number of the RedHat vertex team
here over the last couple of days giving
various presentations hopefully some of
you may have been in those
and it's not going to be tutorial on
Narayana because that again is a large
project it's been around in one form or
another since 1987 and we could fill
three or four days just talking about
some of some aspects of it but hopefully
it still is going to be useful if you
want to hear any of these here details
about anything that it's not you know
you can grab us and those you know if
you do a Google search you'll find lots
of presentations that we and others have
given over the years on on these
different bullets okay so the active
model has actually been around for a
long time since the 1980s actually no
since the 1970s there's another model
called communicating sequential
processes CSP which was defined by a
whore and that was in the 1980s there
are a number of different
implementations of the active model even
on the JVM is you know akka which is
based on written and scala it's over the
years it's a very very popular way of
thinking about and designing concurrent
distributed applications the little
diagram at the the edges to try and give
you an idea that you have actors which
are single threaded and they can they
receive messages they have they have
mail boxes where a message comes in they
do the work to find on the that is
defined in the message and then you know
they they send another message maybe as
a response and then if there's nothing
else in the mail queue then they'll go
to sleep and wait for another message to
come in and actors only communicate
through message passing
there is no shared state direct shared
stay in the actor model if you want to
share state you'll send and send an
email or send a message and say this is
what my state is and then the you know
the other actor that received it can
look at it and then know that at least
run the message was sent that is what
your state is one of the reasons that
things like actor and CSP have been very
very popular like I said is they are
really good way of thinking about
distributed systems at scale as well
many universities
in teaching CSP for four decades and you
know maybe some of you guys in the room
have actually learned about it at
university if not at work so that was
act the actor model in a nutshell now
we'll move on to software transactional
memory so Before we jump into that we'll
give a quick overview of of transactions
or distributed transactions as some
people like to call them if you've used
databases you will have come across
transactions typically they're called
local transactions in a database
transactions tend to have what are known
as acid properties which is an acronym
for at for atomicity consistency
isolation and durability I'm not going
to cover each of these in detail but
it's important to at least cover a
little bit of context so in order to get
atomicity there is a requirement between
multiple participants in a transaction
to have a consensus protocol they a
transaction essentially everything
happens in the transaction if the
transaction completes successfully or
nothing happens you never get partial
completion in a transaction and to do
that you need all the participates in
that transaction to agree that they are
going to move forward and commit the
state and if one of them decides it
can't then everybody has to undo and one
way of thinking about that and there are
multiple ways but the marriage ceremony
those of you who are married or even
thinking about being married you know
whether you're Homer Simpson or Marge
the marriage ceremony is essentially
two-phase commit protocol you have the
the vicar who is the coordinator and he
asks the you know the bride and the
groom sequentially do you want to marry
this person and they'll say yes and at
that point they are neither single nor
married they're in this indeterminate
state because the vicar the coordinator
has not told them whether they are
married or whether they're just going to
everything's over and done with and
we're all going to go back then they go
on to the bride and say you know do you
want to marry this person and the bride
says yes then the vicar will hopefully
write down something in case there's a
catastrophic failure and you can
remember where he was
when the church gets rebuilt and then he
goes around and says Tilbury right
you're married and that's it so that's a
two-phase commit protocol the thing
about writing down is very very
important because happens failures
happen and you know okay
taking the analogy to an extreme as I
said you know there could be a
catastrophic earthquake the vicar could
die or be struck with you know
short-term memory loss and not remember
where things were and the two
participants could have different views
of where where the thing was you know
whether they're married or not married
and that's what writing this this
information down does it that is what is
commonly known in the transaction world
as the transaction log so if anybody
asks you if you know about two-phase
commit now you can say you do and it's
just the marriage ceremony durability
touched on this the log aspect is really
really important because we have to have
this ability to be able to undo or move
forward evenly even in the event of
failures so there's a transaction log
and the participants have to remember as
well so technically what I should also
said is that Homer and Marge are
supposed to write down a little bit of
paper in case they have short-term
memory loss as well and that would be
their versions of the logs and then we
have isolation I'm not going to cover
all the acid properties but isolation is
can be imposed in a number of different
ways the typical way is locking so you
know if you've got multiple resources
being accessed in the scope of the same
transaction you might get a read lock on
something to prevent somebody else
trying to write it while you are reading
it and obviously the typical rule is you
can have multiple readers on a resource
or state within the scope of transaction
but only a single writer so software
transactional memory is a relatively new
thing Hardware transactional memory has
been around for you know almost 40 years
now and it's actually been very
successful and there's a number of
different implementations of Hardware
transactional memory that are in
widespread used today software
transactional memory was first proposed
I can never remember them in a PhD and
then subsequently in a number of papers
in around about 1995 and despite the
fact that that's only like
years ago and you might think well
thirty years and software is a long time
everything should be done and dusted
it's still a very very active area of
research it's used it was software
transactional memory if you if you do a
Google search and find the original
paper you'll find that one of the
reasons that it was posited was to make
it easy to develop distribute to develop
transactional applications transactions
are really good but sometimes it can
actually be hard to develop with them
and to use them software transactional
memory tries to make it so damn easy to
use transactions that you don't even
think about the fact that you're using
transactions there's you know the notion
of accessing shared State again you know
I mentioned earlier that's traditional
transactions as well you know you share
your state in the database you might
have distributed objects and share
distribute objects stayed so software
transactional memory doesn't actually
didn't actually add that that was there
for before that but it makes accessing
shared state and using shared state in a
software transactional memory
environment a lot simpler than it can be
in in traditional transactional
frameworks all code inside software
transactional atomic blocks is you know
serial and no other threads can access
the state that is being accessed by some
other threads within that within those
blocks if they conflict and some
implementations are software
transactional memory in lots of
different languages so this isn't Java
specific will support locks they Nestor
don't necessarily support locks to do
concurrency control they might also do
time stamp based concurrency and they'll
they can also support optimistic and
pessimistic modes of development so
hopefully you know some of this is
similar to what if any of you have used
transactional systems over the last few
decades ignoring software transactional
memory some of this should actually be
very very familiar T hopefully so
transactions and actors have actually
gone together quite quite well for a
number of years almost as soon as a
software transactional memory at came
out people were thinking about how can I
add this to act
and even before software transactional
memory back in the early 90s or late 80s
and early 90s when distributed objects
were kind of like the norm and people
were doing work with corba and even DC
before it people were looking at how you
can combine the transactional
programming model with the actor
programming model because you know
despite the fact that actors are
single-threaded an actor may go through
multiple state changes upon receipt of a
message in it in its mailbox and you
know failures can happen so one of the
nice things about transactions as I said
earlier is that the work you do within
the scope of a transaction the
transaction system will ensure that if
there is a failure halfway through you
get back to a known good state that will
be undone and you can start again so
even if that is a failure you've never
even thought could possibly happen like
somebody comes along and pull the power
ever the the wall you don't have to
program against that as long as you're
using transactions the system will take
care of it and when the recovery happens
and your application starts running
again you can start again and try try
the same thing again maybe you're tried
an alternative so there's there's been a
need for combining transaction model
with actors for quite a while because
consistency of state changes it doesn't
matter whether using an actor model or
or non actor model it's very very
important it's very very important that
you know that when you're making state
changes either in a single-threaded
environment or an environment where you
can have multiple threads accessing the
same state at the same time even if
they're in the same process that there
is a level of consistency with or
without failures just throwing failures
into that makes makes it even more
important so I said the combination of
transactions and actors is very natural
and a number of people ourselves
included believe that the combination of
software transactional memory and actors
is is very natural is even more natural
I suppose because actors simple
programming models software
transactional memory a simple
programming model so quickly I'm going
to rush through the vertex stuff because
I want to give Mike enough time to do
some of the demos so vertex if any of
you have
Ben JavaScript or no developers over the
years the easiest way of thinking about
vertex is it's it's like node the node
model on the JVM with polyglot you can
actually develop with JavaScript on the
JVM with vertex if you really want to
but you can develop with Java with Scala
with groovy with not all of them but I
think eight eight of the popular JVM
based languages are currently supported
in vertex with a reactive programming
model so there's a reactive manifesto
which has been around for a few years
vertex and the founder of vertex a Tim
Fox are actually instrumental in helping
to define the reactive manifest
manifesto originally and a reactive
system needs to be responsive elastic
resilient and asynchronous and I think
I've said most of this but a vertex is
because it helped you know it's been
influenced by and helped to influence
the reactive manifesto obviously but we
believe vertex is reactive it's
extremely popular it is non blocking
asynchronous it it has a notion of an
event bus that vertex entities called
verticals can you be communicating with
there are different implementations of
that event bus as I said it's already
polyglot and over the years a number of
other projects have been integrated with
vertex so things like ActiveMQ that was
added into vertex to allow you to
actually have an event bus that is based
on ActiveMQ there's something up
streaming apache called cupid dispatch
shrewder or if you're American dispatch
router that's also been integrated into
vertex hazel caste is one of the cluster
managers for vertex obviously given that
JBoss and Red Hat having to have in
Finnish band we've had in Finnish band
to that and there's integration with
Spring boot it has an extremely large
user base and contributor base so it's
not just people who take the stuff and
use it which is very important but also
people who
contribute things to it and it's been in
eclipse for about three years now so if
you go to the vertex website which is
vertex dot io you can see a list of all
the well all the customers who have
allowed us to put their name on which is
actually a subset of all customers we
know are using it but as you can see
there's a there's an awful lot of on
there that's just a one-page thing but
there's actually an awful lot of people
who are using vertex and using it in
deployment today which i think is the
important thing
so vertex provides a number of different
ways in which your your your entities or
your verticals can communicate with each
other
TCP UDP variants of HTTP G RPC I believe
after I was talking with Clement earlier
today mentioned there is this event bus
which is the backbone for sending and
receiving messages does distributed data
structure as I mentioned hazel Caston
and infini span it has automatic load
balancing built-in resiliency so you can
actually fire up as Mike will show you
in a minute
you can fire up seven or eight different
versions of your applications who do low
balancing and vertex will keep them will
manage them and if one of them goes down
it will fire another one up just so you
can have the same level of resiliency so
now we'll quickly go on to the software
transactional memory so as I said the
narayana project that software our
software transactional memory
implementation is based upon has been
around for a long time it actually
started life in c++ back in 1985 it was
known as the arjuna project back then it
became the first pure java
implementation of a transaction manager
back in 1996 and it's kind of morphed
since then it defines a number of
different models but one of the ones
that we added a few years back as I said
is software transactional memory with
with our software transactional memory
model the state is obviously within
objects we're talking about Java here so
we like to think about objects so your
state that's going to be manipulated you
have that within an object
your state can be your transactional
state can be volatile which mean or
recoverable which means that it's the
transaction you can do the normal things
I just mentioned in transactions like
assume that things can will roll back if
you force a roll back but if there's a
crash you lose the state any state
changes you made have gone completely
but then there's also possibility of
having persistent or durable state
changes so that means that if you're
doing things in a single-threaded
vertical and you're making state change
in the transaction commit and then
there's a crash when you recover the
states that you committed is on disk and
you can recover and you can get back
that state and you can combine these
things in fact you can go from a vote
from a volatile state to a durable state
and then back again if you saw which
it's not something you're going to see
demonstrated here but you know you can
do that there are optimistic and
pessimistic models for concurrency
control in the software transactional
memory implementation you can have
different types of transactions so you
can have top-level transactions you
could have nested transactions so
unfortunately I do not have time to of a
nested transactions but they're a really
cool thing and you can have nested
top-level transactions I wish I could
talk about that because you know without
knowing what nested transactions are to
know that nested top-level transactions
are really cool but again
you know if you look at some of the
things that you know we've blogged about
or spoken about you'll find that and
maybe you know maybe it'll be time
afterwards and it's also modular so the
transaction context that we have are
associated with a thread and if you
start a transaction and that transaction
flows across to other objects that
decide they need to they need to be
transactional they can quite happily
create transactions without checking to
see there is already a transaction on
the thread because what they'll then do
is create a nested transaction which
will be automatically nested there's no
special construct for a nested
transaction you just create a
transaction if there was one already
running on that thread the one you just
created is automatically nested within
that transaction so it does it makes me
actually make things very modular you as
a developer can just think I know I need
this object to be manipulated a
transaction it gets called in a
transaction fantastic if it doesn't
that's still ok I'm responsible for
ensuring I start and end the transaction
and everything that we do in the
software transactional memory world is
done with annotations quickly some
context some examples that will
hopefully set some context for Mike's
about to say in the in the STM world
what you essentially do is you create
some what we call transactional memory
containers and you define these on a per
tight basis so Mike will will
demonstrate this later on but you can
have like you might create a
transactional container for a for a
stack or for a theater booking system
and then you get transactional memory
instances from that container when you
create the container this is a very
simplified version to contain a method
by the way I basically had to cut a lot
to get on this one slide but when you
create the container you can say I want
instances from this container to be
recoverable which as I said is the
volatile aspect of the of state changes
or to be persistent I want them to be
shared which means that you can actually
access and through multiple verticals
running potentially on different
machines in a system or exclusive which
means that nobody can can share them
even if they're on the same machine and
even if they're in the same address
space and then once you've created that
then you create instances and you get
back a reference to the instance to then
manipulate and do all your operations on
as I said early we have a load of
annotation so you mark the interfaces as
transactional and then that's the thing
that the container gives you gives you
back transactions can be nested nested
top level the top top-level ones you
don't even need to mention that
transactions are just top level
optimistic and pessimistic annotations
if you want to set locks you can
actually set a read lock and a write
lock that's probably we probably change
the name there I was thinking about this
the other there because sometimes we
don't actually use locks it's a
historical reason that they call read
locks and write locks at this point you
can define the state that you want
saving so the system will add earlier
it's important that you know for
transaction rolls back it can undo any
state changes and give you back exactly
the state
before the transaction started if you
don't use any of these annotations in
general there's a sensible default the
default if you don't specify what the
state is everything in the objects that
you touch in the scope of transaction is
stay is safe whatever you think that's
not final and not volatile everything
will be State will be saved and then
everything will be restored but you
might actually want to have finer
control over that so you can say with an
annotation don't ever save this state I
don't care what you do about the rest
you can save it all but don't ever touch
this don't ever change it and then you
can define objects which are transaction
free which means if a thread goes into
them the transaction and the transaction
is on that thread context and the
transaction will be suspended and work
will be done but you want every wheel to
undo it if the transaction rolls back
okay so that was a whirlwind tour of
hopefully some context of where we've
got to with software transactional
memory in in practice well in theory and
now Mike's
hopefully going to give you some
practice some examples good luck that's
work hi guys my name is Mike was Grove
I'm a developer at red heart to work on
the transactions team so in the second
part of this demonstration that I'm
going to be like taking masks on most
concepts of the actors and software
transaction memory talked about two
implementations of those two concepts
and I'm going to be showing you how to
like pipe to put those and commit those
work in your programs so I'm going to do
in two parts the first part is going to
be by slide so it's going to be occurred
walkthrough of how to create a software
transactional memory object and then in
the second part I'm going to be running
some demos and those demos I'll be
showing you how to use transfer
transactional memory and how to combine
them with vertex and last and light
programs running running without so to
create a software transactional memory
object you start off with a box standard
vaak standard java Rob javanese face so
this is how you just so you've got a
stock level interface you've got get as
you know gets getter setters and you've
got like a mutator value a decoration
and decrement it's not stock value and
then you would have your implementation
of that object
still off to do software to a national
memory so it implements that that stock
level interface it's got some state now
in the bottom and then it's the softer
States going to be the one that's going
to be managed by a software
transactional memory so first thing you
have to do is in fact it's the only
thing year that you have that year
that's mandatory is you have to mark the
interface is being transactional what
that does is it tells the SDM runtime
which which objects it needs to bite
maybe monitoring which at which it needs
to be managing as transactional objects
so if you find that on and then the exam
you can go back to the implementation of
that interface now you could just do
nothing on this at this level now that
mark says that all of these like
annotations have like very sensible
defaults and so the default is any state
that you've got in your order any
members any fields does not ultimately
state and the contain that will monitor
any accesses to those states and also by
default all methods or public methods in
the interface will be will be monitored
by this to come another container well
clearly that's prime probably you won't
want to do that to you likely with some
some methods that you will want to be
been managed by the software
transactional memory system some will be
like you it's only reading so will your
writing and for like so with right locks
of it to write locks requires a lot more
like an isolation of state between
different threads so you want to make
sure that your that your markup which
ones are really read-only methods which
ones are right methods so for example to
get we're third up there at the top it's
never going to mutate any state inside
the object so therefore you just need to
take read locks whenever you go through
that method and then at the bottom is
line and said the state so you mark up
which bits of your object is actually
state that you want to have managed by
the software tool national memory
runtime so you define your software
transactional memory object and now you
have to make it you have to go and use
it you have to make it available have to
make it known to the
to the runtime to the Tophet SDM runtime
so the way you do that is you
instantiate a container mr. nas SDM
container and that's instantiate the
default container that's going to give
you like volatile like the volatile
objects you instantiate your service
simply the implementation of your stock
level service and there you are you
going to pass that implementation to the
Container and you're going to say to the
Container create me a proxy for this
implementation object and what you get
back is something that is actually
monitored by the start of the SDM system
so whenever you make into it whenever
you interact with that stock level
object now it's the software
transactional memory system will know
when you've been touching various bits
of State and at the bottom there so you
know you have to bracket all of your
operations within a transaction block so
software transactional memory recall
from earlier parts presentation is it's
like an atomic operation and you go
delete Demark a what your atomic burn
sections of code are and you do mark it
out with begin and end like a standard
transaction and then you do all your
mutaters or your reading of objects
inside that bracket so I've got a coin
there is like we do have something
called top so nested top-level
annotations or what that means is that
the STM runtime will actually start a
transaction for you if we're not on one
already running so even at this point
here you still don't need to start and
stop transactions so you have a really
really low barrier for entry in terms of
how you can like you know take advantage
of these things so if you like you know
if you're getting if you're
experimenting with it you can just write
a very simple interface market act
transactional marketing esta top level
and then just reuse it like you had any
normal Java object and then you could
play around with it and you could find
out you know that you know that you can
get your concurrency support etc and
your safety
so that's showing you how to use SDM and
how to press DM object so the second
part of it is I'm going to be going over
if how you integrate up with vertex and
Damned and as a result of combine the
two you can get very scalable scalable
shared memory systems so so I've got
four demos I'm not sure if I'm going to
get through them all but the first demo
is really probably the most important
one so I'll spend most time on the first
demo and if I find I've got time then I
can go through the rest of them so so
the format is of all do and have a
couple of slides on each demo just
describe what the demo is then I'll go
into the Africa I go and run it or go
into a light command line run the up run
the demonstration
talk a bit about about what it's doing
and then after done that then step back
into the cord and show you the code that
implements that demo so it's three parts
so the first one is it's showing you how
you might want to scale your application
so your application running and you want
to like you know it's be able to cite
service litem or workload so you do that
by you scale it by them by adding more
threads to the system so for example you
might buy yourself a bigger box and you
can fire have more threads running your
workload so that's an example of
vertical scaling and this combination of
software transactional memory and vertex
is a perfect is a perfect solution for
scaling in that way without having to
light write complex complex locking code
or eye or synchronization code between
third threads so what the example does
is it's a volatile one so volatile is it
only runs in single address space or all
the threads in the address space and
share can share the memory but you can't
share them between different genomes or
in other video games it creates one
service that service the service is
going to be a theater service but it's
going to instant it's going to create
out in the context of vertex and then
you're going to stanch eight multiple
vertex instances and each of these
vertical instances is like a single
thing single thread that's mirrored us
interacting with us using that theater
object and it's fielding requests to it
and the isolation between the different
threads is managed by the STM system
yes so it's site so I've got a single
SDM object it's theater object and it
manages booking so it maintains the
bookings it's made me lecture query the
blocking so it's got a write method it's
got a read method so it's it's going to
start a number of different vertical
instances each vertical instance is
going to be listening on to the same
HTTP endpoints and the first X runtime
will manage the requests coming in and
it will go to Plex those requests on to
the various verticals that are listening
on that that one in pinpoint okay so
fixed
okay so I've got canned script here
okay so
so demo on so first off so I'll scripted
it so I'll put them in maven profiles to
take a copy of that okay so I'll start
that so I'll be have a nice look at the
example the demo obviously so what
that's going to do so it's going to
start it it's going to deploy a vertex
vertical and then it's got out versus
vertical is then going to be running in
I've done it with ten instances so
there's 10 does 10 threads running here
and that's you're showing that it's just
demonstrating like there's actually 10
threads in the system and then so and
that that service is now listening on an
end point so it's listening for theater
blocking requests so if we fire up a
couple of HTTP messages request of it
okay so this year five message at the
endpoint 8080 and it's a post method
message so it's going to ask you to
create a resource and it's going to
create a theater booking and I'll do
that twice so if you look at the output
there to see the JSON output it's
showing you that there's which threaded
service to that request so it's thread
five a service to run it again it's a
different thread servicing it so and
also in there you've got booking counts
and see the booking count is
incrementing so even though it's handled
by different threads they are actually
seeing the same state and same objects
and then you can also show get requests
in a similar fashion and you can so yeah
so you can see that I get requests as
you turn the looking calendar to keep
data again with another one and it's
different trades being handling it so
it's like demonstrating that each thread
it's doesn't matter which thread is
servicing the requests it's still seeing
consistent state so that's the end of
the first demonstration
so the next I was going to go through
the code yes that's that's kinda handy
there okay so so this is the code that
does its apps I've separated out the
code into like three into a class
hierarchy so I got three class in the
hierarchy at the top level of the
hierarchy I've got this thing called a
volatile theater vertical and that's the
thing that does the initialization so
that's going to initialize the it's
going to it's going to deploy the your
vertex vertical to the dip-dip line and
it's going to initialize your software
transactional memory objects so if you
see there the first thing it does is
it's creating a container for software
for the STM objects and it's creating an
STM object and on an earlier on the
slide deck I showed you surely like you
call create method on the container you
pass it an implementation of a Java
object and it returns you back a proxy
so that line there where it's not
service equals container so that service
is now going to be a proxy and us and
this yes the SDM runtime is going to
monitor what you're going to be doing
with that object this next one here is
kind of a workaround for an issue we've
got outstanding where you have to like
make sure it's like it's in there me
it's been initialized properly so once
we fix that you won't have to do that
line so that's the Stasi STM
configuration complete and then you're
going to deploy your vertical at vertex
incidents you can deploy your vertex
vertical and there that's this on here
is showing you I'm going to come on 10
instances of it obviously you can have
as many as you want depending on how on
how be for your boxes and then just
passing a little bit configuration
through to the root of the instances
it's going to create so vertex will then
on this line and then go away deploy
that vertical sees you want tendencies
it'll spin up ten threads it will call
the star methods on each of the on these
of the verticals and then it will feed
events through to it so the next one is
the
Theater vertical so the theater vertical
this is like an instance of the of the
vertical like you've just deployed out
shown you on the previous screen so a
vertex will deploy the verticals and it
will call the constructor of your
vertical limit of implementation call
the others do you need an empty
constructor and then it will call the
star method so the start method is the
trigger for the for the for the vertical
instance to actually start doing this
work and providing service whatever
service it provides in this case it's
just the services just listening on HTTP
endpoints for theater request service
request for the for theater bookings and
etc so what I've shown here is the SDM
object that was created on the previous
screen in the main method that object
has to be shared between all the
different instances and the way you get
such a shared object is you use a clone
method
so it's accel y : method on the so if
you look at which one was it so it's
that one yeah this one's got a clone
method so I've had to put the clone
method in the in the previous class
because you know the excel in different
ways depending on whether you want
volatile objects or persistent objects
or again what Mike and Molly want so in
this example it's just like calling the
clone method on the container
okay so so that's done the
initialization of the instance and then
the start server method that's just
starting an HTTP server so that's like a
vertex things not an STM the get routes
is just defining the nd the the paths
that this service going to be listening
on so it's going to be listening on at
path voice the API service name is
theater so it's going to be listening so
it's done listen for read requests on a
slushee API slash theater and it's going
to really listen for theater bookings
post requests on such API slash theater
and then however many seats the customer
wants to Bach and that's pretty much
there so the actual the actual business
logic for doing the blockings
is is in this method here get bookings
so that's that's where the business
logic will reside and then there's just
like the packaging up with response to
send back to the to the HTTP corner so
now if you go back into this level so
I'll put that into the next in turn into
a superclass of this one just I've done
that to separate all the different
possible functionality so the deployment
the first text initialization STM
initialization and now the business the
business logic so the business logic is
where the domain objects reside so is
the get booking service so I didn't tell
you which object is being passed through
yes so it's passing in the cloned STM
object so this is light of its cloned
because it's shared between all the
different verticals so we're going to
get booking so the gate blocking objects
so we call earlier we said like when you
do a software transactional memory of
interactions on objects you need to be
able to like bracket those changes
inside an atomic block so here I'm
showing you like you so you're going to
start it's an atomic transaction and
then and then you've got to begin it and
this is where
Tomic Broncos I self between begin
through to commit and that's the block
where you're going to do where the SCM
container is going to be monitoring all
accesses to your STM objects in this
case the only interaction with it is to
like ask it to out you know it's called
a reed method asking it how many
bookings it's got and similarly the mate
booking that's going to be a write
method so same as the previous one more
or less except it's going to do a book
show call so I'll butcher I haven't
shown you actually the SDM object
implementation itself so if I step
through into that so this is a this is
an SDM object so recall when I says you
CD flight with an interface and then you
just annotate it with that transactional
and that's the trigger for the SDM
contains and all that it needs to be
monitoring monitoring all the cause to
to that interface or the implementations
that interface an in this case is only
one this is the right through this
there's the right method book show and
then as a cos year and there's a get
there's a reed method in there so if we
go back here so yeah so that's yeah and
yep so that's that covers the
implementation of like of that first
demonstration so if anyone got any
questions as I'm running through if I'm
skimmed over anything just just shut up
and I'll do my best to answer your
questions
so the second demo is very similar to
the first demo the only difference is
really is going to be is that it's
instead of having volatile software SDM
objects it's going to have persistent
ones and what persistent what means you
can do is you can share that memory
across different address spaces so you
can spin it multiple JVMs and then all
of it all be seeing the same object so
this an example here of why you might
want to do that is if you go on a scale
out your history service you want to
look to push it across multiple nodes
and your verts odd multiple GM's then
you better run multiple JVMs and all the
sharing the same the same the same data
and they'll have consistent changes to
that data
so back to the demo so I kill the first
demo off so dead load two so I'll start
that one really
and then in another germ another window
I'm going to start the second JVM
so I'll start it in this window with
this one I've got to tell it which which
objects is going to be shared so objects
have like a data ident unique identifies
to the software time data memory system
and those you IDs is how it knows that
the arm that the objects are being sure
which objects need to be shared with
each other so on here I need to take a
copy of the your ID and I can tell this
one
okay so so that's now - JB I'm running
both of them hosting the theater booking
service each one is deployed a vertical
and the vertex is deployed ten instances
that vertical in each JVM now what we
can do is if you request curl requested
it so these are service requests just
like we were before
so the different JVM so they need to be
listening on different HTTP endpoint so
this window this one's this one 8086
this one's listing on at 80 82 80 82 so
now if I if you request at it so now I'm
creating a booking to the 80 80 service
in the top left-hand window and then
I'll do the same on the second JVM give
it 80 82
mr. slash with it yeah 1882 that's all
right okay
that's why I've got it scripted in the
shell script okay so so what I've done
there is I've issued two request to
create bookings and then you know if I
go back and ask for it how many bookings
you've got it doesn't matter which JVM I
go to they should report the same value
about because this is a shared out
shared object is shared across petrest
spaces so if I step on here so if I go
to the what the service listening on the
8080 end point so that's reporting a
booking count of three so I've got three
blocking there and then if I go to the
other JVM that's listing on 88 - then
yes so that's giving me the same value
as well so that's showing you how to
share the memory and share state across
two different JVM and the JVM your - the
concurrency between them so I'm running
quite short as I now am so I do have two
demos like left so yeah so wanted it -
what I haven't shown these are haven't
shown concurrent accesses to life just
like being typing the command line doing
one type of one command service your
question at a time so that's not
concurrency so there is one part of the
demo which slightly spin up a number of
vertical instances it's probably best I
just show you actually well yeah we have
four minutes for just just to show it
running okay yeah okay so so I'm showing
the code for persistent one but if you
are interested then it's all available
it's open source so you can go and grab
it
so again more three right okay so what
this one is this is a stress test so
first what we're going to do is start
one of the earlier demos so we're just
going to start a service demo one to
start running demo on and that's doing
theater bookings and then I've got a
second example here so it's a stress
test and that's going to start up a it's
going to start up a vertical it's going
to have like ten inches again so it's
going to have ten into this vertical and
each vertical is anybody firing loads of
light rest at rest requests at this
theater service asking it to do a
blocking etc so this should like really
normally slight if you haven't got your
concurrency right this should cause a
lot of like corruption so run that one
so it's doing 100 requests and it's
fired there so it has been successful so
it's got a couple minutes left so so the
stress test is yeah it's firing so it's
firing 100 requests so it's running up
ten in ten vertex vertex verticals
parallelisms ten and it's each part each
vertical is then issuing 100 requests at
that service I've started and then the
actual cord is in there to do that so
the the demo that I didn't do that what
that would have to show you is it was
showing you how to compose objects on
how the taxi so I've got a thirty
service and I've got a taxi service
running and then I've got an alternate
AXI service running so you do your
theater all in the same symp single
transaction transactional block do your
30 theater blocking try year's taxi
booking you might get an exception on
your taxi booking and add it marked as
like nested so that would fail and then
you've got the oxygen of then going
trying an alternative taxi service I had
three services running going to go and
do the alternate taxi service and then
you would commit the changes and it
would know and then it would commit
those changes from only making them
visible to any other threads and that
was showing the composition of like STM
operations
okay so so skip over those so if you
want more information you can go to our
website so though we are notice
it's hosted by the narayana project so
if you've got to like narrow your honor
that i are and you'll find some web
pages that you've got four hundred blogs
you can get as on IRC as well the source
of this demo is available as well that's
on our QuickStart repo and the actual
source of the SDM system that Mark wrote
is is in our master tree under SDM so
that wraps it up for the devil for the
talks or QA anybody any questions right
so s so SDM isn't clustering SEM is just
managing shared memory state so it's got
one copy of the share memory state
through all these objects that have been
cloned so you see if you've got you one
object you saves the container clone it
for me you get back a clone but the
underlying memory of the original object
and the cloned object is managed by by
the SDM container the clustering is the
vertex is a vertex concepts or vertex
has zero on do you mean something like
the hazel class hazel caste clustering
or the InfiniBand clustering yeah so
there isn't as yet but the advantage we
have is that the transaction manager and
finish plan users is Narayana so that is
definitely something that we want to do
but we haven't got the integration with
third with infinite span yeah at this
stage but it's an open source project
okay old
yes
there's no ex-air here for a start
there's no XA there's no database so you
don't have to have oracle or db2 or
anything like that state to save your
steak yeah although there's no you know
everything's done to through annotations
and the system is actually tracking as
you access the the objects and making
sure that you know if you if you move
through an object that doesn't make any
state changes and it doesn't say save
any state if you move to an object that
does modify state then it'll it will
save the state for you but those there's
no transactional access to a database
involved there's no XA access so that's
one of the big differences oh sorry
so the the STM implementation is pure
Java today one of things we could look
at is how we could do this in other
languages so the verb one vertex move
from 2 to 3 so in the in vertex 1 &amp;amp; 2 if
you wanted to do a make a nice utility
in Java on vertex 2 and you also want to
be able available Scarlett you had to
reimplemented
one of the things they did in vertex 3
was they actually did some automatic
translation so you only have to
implement there in one language and then
it can be made available in the other
languages so we might do something
similar oh no no no there's no Jay and I
or anything
yeah depends on the implementation so we
have different implementations for
sharing state one of them could be it
could be two in Finnish BAM
it's not so infinite in Finnish span at
the moment it could be a shared file it
could be memory mapped file that the
actual way in which you do the sharing
of state between instances is itself
pluggable we just haven't got around to
do in the the infamous Mountain one yeah
yes oh yeah yeah yeah yeah yeah yeah
yeah
it depends on whether you set the object
to be persistent or volatile if it was
volatile like I said before you'd lose
everything you'd lose the state it was
persistent and it happened after the
transaction had committed then if the
transaction committed that's it's there
you will have that same state when you
recover again yes yeah it's what
transactions are all that really yeah
okay
oh I think I think we're done but if you
anybody wants to come and ask us a
question afterwards feel free</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>