<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Wait, what? Our microservices have actual human users? by Stefan Tilkov | Coder Coacher - Coaching Coders</title><meta content="Wait, what? Our microservices have actual human users? by Stefan Tilkov - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Wait, what? Our microservices have actual human users? by Stefan Tilkov</b></h2><h5 class="post__date">2016-11-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/jJxmi8nrHwg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everyone my name is Stefan tasarov I
am delivering yet another talk on micro
services and unless you've been living
under a rock this is a topic that you
kind of can't have possibly ignored so
you know all about it right everybody
here is familiar with micro service and
all that so I'm going to skip the
introduction and I want to talk about an
aspect that I feel is being neglected
way too often so when people talk about
this micro services thing it all seems
very easy right we started out we're the
monolithic application and this
monolithic thing has various different
things inside of it it may have layers
for example every architectural diagram
you ever saw has some sort of layering
inside so it's persistence in logic and
UI and it has some sort of the main
context so maybe there's billing and
accounting and provisioning and some
sort of product inside there's lots of
different kinds of domain related
concepts all bundled in there monoliths
it may even have some internal
components of some kind maybe it just
has a nice package structure or it has
actual components of some variant or
maybe it has OSGi service whatever it is
you have as multi-dimensional complexity
and all of those things so we start out
with this big monolithic thing which is
obviously bad because any kind of
monolith is bad right that's what we've
been taught so far at least and we cut
it apart and there's micro services
that's it right that's that's all we do
right so the core idea here being that
we take explicit care to make sure that
the deployment boundaries the thing that
actually we cut apart the lines we cut
along our play an important role
right so with these micro services they
have this deployment boundary and
everything seems perfectly fine oh wait
did I just give a micro service
introduction maybe I did but it was just
a minute right so please forgive me so
that is this micro service idea but
there is an an aspect of it which I feel
we talked about not nearly often enough
which is this UI thing I have a certain
theory why we don't talk about this so
much and the theory is that most
architects our back-end people right if
you look at the typical
personally who does architectural work
who has an architect's role whether it's
their only role or whether they assume
in an addition to something else they're
typically server-side people right
database experts or distributed systems
experts and they think that this UI
stuff can't be that hard right it's not
something that you can actually sue that
you should waste too much time with and
I think that's a that's a huge mistake I
think this is something we should spend
a lot of time with so that's what I want
to talk about if you look at those
typical diagrams if you look at your
typical architecture drawing or the
micro-services architecture you'll have
lots of collaborating services and then
there is some sort of front-end on top
of it right but I think these diagrams
even if they're prettier than mine leave
a lot of questions to be answered for
one what is this thing right this this
front-end part what is it is it an
application is it multiple applications
is the server in a client part so where
does it run is this the server side web
application that we're talking about or
is it some sort of client application is
it maybe a native or a single page
JavaScript application what actually is
it what is this line and is it the same
line as this one down here
and does it matter does it does it play
any role your should it play any role in
your decision-making what kind of
connections you have between the
individual parts so I think all of those
things that we tend to ignore have have
lots of important consequences and we
should be dealing with them and I'm
going to address most of them by
challenging some Shump assumptions I'm
going to issue some claims and then I'm
going to try to debunk them and I think
by that we can try to find out some of
the some of the things where you learn
things might actually not be as simple
as they appear at first sight so the
first one is orchestration is cheap and
that's not true at all
it has never been true anybody who has
ever built a distributed system knows
this right anybody who's ever naively
cut apart a larger system and into
individual remote components RPC styles
Sun RPC dce/rpc RMI whatever it is
remote ejbs CORBA web services every
time you try to every time you find out
you find yourself making way too many
calls over a network
you find out that your performance is
going to be hurt dramatically so
obviously there is an impact here if you
consider your climbed as being remote
inclined if your back-end services right
so some things are really remote and
some are almost local there is a huge
difference between something that is a
call issued over the internet and
something that happens in your back-end
system so this might be something with a
latency of milliseconds it'll take you
20 milliseconds if you're if the line is
good if everything's fine take you 20
milliseconds to get back an answer if
you're on the internet and may take you
from Michael's few microseconds if there
are two services talking to each other
sitting on two machines next to each
other in some sort of rack in your
datacenter with a fiber connection
between them so this matters a lot if
you find yourself with a client-side
application a client-side application
running on some mobile device or running
on some laptop computer trying to invoke
multiple services to orchestrate them
and to build up some sort of result for
the end-user you're going to have a very
very unhappy end-user that's not
something you want to do so you have to
address that somehow and one pattern
that I see coming up more and more often
is this idea of having a back-end for
front-end a BFF could also be a best
friend forever right you have this yeah
this thing on the server side that does
the orchestration it actually assembles
the calls the results of the calls to
multiple back-end services it forms the
same logic and then processes them
formats them nicely and returns there
maybe in the form of JSON to some sort
of client so you have something on the
server side that is explicitly built for
a particular client side direction and
everything is perfectly fine right I
don't really think so
I think those those those things are
sometimes an awesome solution but as
seems to be the case with more and more
things these days people tend to pick a
solution and apply it everywhere as if
as if a solution in itself had any value
but a solution doesn't have any value if
you don't consider the problem that it's
supposed to solve right if it has to
match that somehow and at some times I
think we believe that we're all Netflix
this drives me crazy to no end because I
love those folks there they do awesome
work it
absolutely great if you have a chance to
listen to somebody who is involved with
Netflix our Netflix is architecture
present about them this is this is like
like watching somebody who came out of
the future to tell you about how IT is
going to look like in a decade or so
it's fantastic but most of us don't work
in the business of streaming video at
least it's my assumption if some of you
work as at a Netflix competitor you're
excused but the rest of us including me
typically work on boring applications
that's because boring applications tend
to pay the rent right we would all love
to do those you know fancy new algorithm
stuff and you know all those really cool
things but mostly we do boring stuff be
honest we have something sitting in some
kind of database we have to do some
processing on it we have to present it
to the client and for those things I
believe that this is typically not a
good solution because there's a hidden
assumption here which is the channels
matter very much we we have this
assumption that we're building the
perfect client for each channel and that
is not the case most of the time most of
the time channels don't matter as much
as you think because if you have an
unlimited amount of money and an
unlimited amount of resources in terms
of fantastic engineers and and and you
know awesome funding and a great not a
great use case that doesn't change too
much all the time then you can maybe
afford to build a different back-end for
front-end for every sort of client that
you have but most of the time that is
not something you have the luxury of
being able to do actually imagine some
Oh arrows that was lazy so you've got
all those things connecting all that
stuff typically that's not what happens
the most most applications that I know
are different they have users that
assume that they'll be able to do
whatever it is they use the application
for on various channels so for example
they might start browsing for a product
while they sit on their couch in the
living room using their iPad and then
because they're there they don't
actually want to work next day at the
office they actually use that time to
use their laptop or desktop computer to
actually check out by and check out that
product and then maybe years they use
their mobile phone to check on the
status of the whole thing and then maybe
I don't know I had to use the voice icon
somewhere so they leave a comment using
using censored of audio device umm so
users actually expect a single seamless
experience across multiple devices it's
actually the situation they're in that
matters it's not the device they're
using I can use my iPad and word I can
use it at home I can use it while I'm on
the road it's wrong to assume that just
because I'm using an iPad I am in a
particular context I am in that context
but I may be using any device so I
expect to be able to do everything
everywhere obviously I want flexible
user interfaces I want something that
actually matches the device I'm on that
uses it to its to its utmost potential
and I understand that if you're aiming
for perfection if your goal is to build
the best possible application for any
particular device your only chance is to
build a particular application for this
particular device but very few people
have that kind of resources very few
people have that kind of money you
typically can't do it so that is my
first my first assumption I think those
things very often have that kind of
problem they're not needed but they're
applied because everybody does it that
way and because some very smart people
including some Neumann who might be here
in the room I don't know actually a
wrote about this pattern it's a very
useful pattern it's just not useful
everywhere and it's related to something
else this mean for orchestration arises
because our services in themselves are
too low-level so if you look at a
potential set of things that your
service might be able to do some certain
some different kind of layering then you
might have a service that essentially is
just a JDBC driver in disguise right
it's just something that gives you that
directly returns some data from a table
you could just as well give people
direct access to your database some
reason maybe you don't and I admit that
not many people do this kind of thing
but very many people do this there is
something that is pretty low-level that
center around some sort of entity right
this is said this is a service that
gives you a customer this is a service
that gives you an order and it may allow
you allow for you to update something
and has some validation logic it
maintains a little a little of a set of
reference referential constraints on
that's all well and good but it's still
for my tastes way too low level and
that's related to the fact that it is
highly reusable because if something is
highly reusable it's very likely going
to be pretty useless those things are
related right if you know them the more
useful it is the more specific for a
particular purpose it is so if you have
something that's for a particular
purpose
you won't be able to use it in any
situation it'll just be usable for this
particular thing if your service were
say something that concatenates two
strings that's very very reusable you'd
almost pretty much every program has a
need to concatenate strings but it's
probably not a very good service to
externalize right so you have this
relationship there I think you should
strive for building services that are
useful and they can be specific your
goal should be to build something that
can be used meaningfully forget about
reuse reuse is just a side effect if
it's being reused that's nice typically
you're having it used is the most
important thing I think that is also
related to another aspect which is this
idea that it's the services that make up
the important parts of our applications
I call this SOAs original sin there were
many SOE initiatives started with
incredible budgets and huge companies
where where people said if we only build
the right services everything else will
be easy right the value is in the
backend services guess what typically
it's not typically the only value your
users care about is the one they can
actually access which is the stuff that
is exposed to them by a user interface
that's why it's called a user interface
so that is the actually important part
so your illusion might be that you're
building something like this these
highly valuable services and then you
have a very thin front and that just
orchestrates the stuff but in many cases
the actual reality looks more like this
you have those low little things but the
actually interesting stuff happens in
the orchestration above so it's the it's
the assemblage ISTE it's the
choreography of different services that
actually produces a value so your your
monolithic your UI actually looks a
little bit like this you have
you have a big monolith on top of all
the little services that you built in
fact this is I think what most
micro-services architecture projects
these days resemble which in my view
means that they're going to fail in the
long run they may offer some benefits
now but in the long run you're just
you've just fooled yourself right you
have relativity down there and as long
as your monolith up there is pretty
small everything's fine but if it's good
if it grows and it will grow you're
going to run through the same problems
you had with your big monolithic
application up front so I don't think
that's a good solution it actually gets
worse if you have multiple back-end for
front-end parts for different platforms
because you're not going you're going to
replicate the same logic multiple times
so if you're if you're a domain expert
if a stakeholder asks you to I know
introduce a new step of approval now
every order above a certain threshold
has to be approved by a supervisor if
the product is something sold on this
from from this category then you're
going to have to make that change in
multiple places because the process of
actually doing that approval is in the
orchestration and not in the back-end
service that's not what you should aim
for what you actually want in my opinion
is something that looks a little bit
more like this you want to have vertical
slices that actually encapsulate a
cohesive piece of business logic
including the data parts and including
the user interface parts I want to have
something that offers me the opportunity
to address a single team if I want to
make a change if my user registration
process changes I want to go to the team
responsible for the user registration
and ask them to offer a new way of
authenticating or I don't know some
two-factor approach or whatever it is
that I need changed I don't want to go
to multiple teams do that thing that's
not that's not the idea I believe of
using micro services in practice so
typically you'll have something like
this such a vertical slice sometimes
you'll have micro services they don't
need a user interface that's fine as
well not everything can be the same
thing but typically what you aim for is
this vertical responsibility this idea
of having something where a team or an
organizational unit is
for everything from the front end to the
back end part actually it's arguable
whether this is a micro service I think
it is I think it is a micro service
because it follows all of those
constraints like having a deployment
unit allowing for parallel development
allowing for choice of technology on the
inside and standardization on the
outside you could argue it's a variant
it's a specific subset of micro services
I'm a few colleagues of mine have
actually set up a website called SCS
architecture that org SCS stands for
self-contained systems and that's this
variant this particular thing I'm
talking about that the web application
that actually has everything inside of
it from the front end to the back end
part but you don't have to believe in
that is that a product you can buy or
anything like this just trying to give a
name to a common thing to a common
occurence that we see of many of our
clients and many companies outside of us
so if you look at this then the key idea
here is that you have those vertical
things and you have to integrate it in
some home we're going to get to that in
a second because if you have our slices
they still make up a part of a larger
granular system right what you're what
you're doing is you're decomposing your
the system that fulfills your business
goals into individual units any of those
either
each of those units may now be a little
bigger then than the 200 line micro
service but it's still only a part of a
system and you want to have those
integrated user experience because your
users couldn't care less how you
modularized your your back-end or your
application right that's not what they
what they care about so now we're
talking about modularizing the front end
right we now we're not talking about
finding ways to componentize or maybe
cut into micro services what we
traditionally or what windows in that
and the negative example had has a big
monolithic system and here something
another assumption that drives me
completely crazy is this one right this
is you know this is just an
implementation detail anytime somebody
says this is just an implementation
detail it typically means they don't
know what they're talking about it's
like your old school professor who said
this is left as an exercise for the
reader or something well maybe they knew
what they were talking about but they
didn't want to talk about it anyway and
this is similar here I'm
is not true front of technology matters
a lot
front-end technology matters because it
restricts the architectural options you
have you cannot you cannot use all of
the options with all of different
front-end technologies they shine at
different things and you have to be very
aware of this and this should factor
into all of your decisions this is a
crucially important part of your
applications overall design you cannot
ignore this don't postpone this turn
this into a very very important decision
to be made upfront because in the end
when you follow his model you have more
than one platform we all talk about the
backhand platforms right we talk about
the environments are micro services run
in I used to be able to say at least
there are no micro services service now
I know that there are some by now sadly
enough but whatever you're talking about
some environment in which your back-end
services run up to the point where they
may be return JSON over HTTP or protocol
buffers whatever it is right this is the
backend part but what's the front-end
part what is the platform that are you
eyes run on that's I think is a very
interesting question
if you look at the the way we approach
this on the backend side then we have
certain goals that our platform needs to
fulfill for us to be happy right we want
to have as few assumptions as possible
about the internals of each service we
want this to be a decision to be made by
the team developing that particular
thing we don't have any implementation
dependencies at least I think that's a
common goal we will have a very small
interface surface we don't want to have
tight coupling between the original
service services because they will rely
on complex structures should be easy
should be simple to use ideally it
should be based on standards so that
anybody who follows that standard can
use their technology of choice to build
things we can develop in parallel
separate teams can release independently
right we can deploy independently we can
actually operate independently we can we
can shut down parts of the system and
put them back up without hurting the
other parts that will be an ideal
back-end scenario for for a micro
services environment so this is where
all your kubernetes stuck awry
whatever buzzword of the week it is you
wanna do whatever I'm not talking about
that at least not now but what's the
front and enology
right what is the what is the front in
part my claim is he cannot meaningfully
talk about this unless you differentiate
between the different kinds of from it
so let me try to do that what kinds of
front-end technology do we have first of
all we have this web stuff versus the
rest right so that is a pretty big
difference and that within the web world
we have different kinds of building web
applications we have a more traditional
style where a web application consists
of HTML being rendered on the server and
then enriched with CSS and JavaScript on
the client side and we have the client
rendered things where you have a single
page app and of course I'm
oversimplifying drastically here because
there's a lot of grey in between those
two - those those two extremes
well the native app side we obviously
have lots of different platforms it
could be mobile desktop some sort of set
up some sort of in embedded device I
know some sensor is something running on
your bicycle or in your car or whatever
it is to possibly build and make it with
a native fashion so how how how does it
matter why is this important so let's
take a look at those those different
things oh yeah I forgot one which is the
one in between right so we could mix
some of them we could have for example a
native wrapper that includes a web
application that we sort of them mixture
between those so let's dive into one of
them let's talk about the web
application first actually let's talk
about the classical web application
first if we want to integrate different
services or applications or systems
built using web technology we have
magical powers at our hand the most
magical of all the powers we have is
called a link that's a fantastic thing
because it allows you to it in a
completely standards-based way connect
to things built by different people
using different technologies deployed
independently that's pretty cool that's
actually just the web right that's the
way the web works and this seems
amazingly obvious this seems completely
boring but it's amazing how something
such something that is so obviously
useful is not being used by so many
applications because this requires that
I can actually lay
to something within an application so
that I can you know link to it from
another place and that's not at all
obvious it doesn't seem to be at least
because you still have applications that
don't provide this capability if your
application exposes what's important as
individually addressable things
resources if you're into that rest
terminology then you can link to it
which is pretty cool
it's also pretty limited because this is
just a one-way kind of thing of course
there might be a link back but this is
just you know somebody has to actually
click on that thing and follow that and
it's unidirectional it doesn't doesn't
carry too much context although for
example you can using various various
techniques transport a user login
context which is a pretty important
thing here but you can you can connect
some things a little further along the
along the axis of being actually useful
for more complicated use cases is a
redirection approach so this is what
happens when you use your facebook login
or your twitter or google account to log
in to some third party website but
you're being redirected your browser is
being redirected by the side you're
trying to access to the login page of
your service provider and they ask you
whether you really want to grant access
to whatever or share your identity with
that particular thing and then you agree
and then you're redirected back using
some callback URI and then they do some
magical thing in the background and
worry about that whatever you have an
integration between set to separately
build web applications that is actually
a sort of a little business process that
happens here right and you could use
that to integrate things so you could
actually use that if you have split your
huge monolithic application into
multiple parts to integrate them again
again I know that both this and this are
have limited usability because sometimes
you just want to have a composable
composite UI right you want to have a
page that assembles things from multiple
places it's actually a very useful
technique called transclusion that
allows you to build on the same
foundation so you have a link from one
place to the other and then you use
javascript to replace the link by what
the link points to or a preview of what
the link points to so you're actually
embed something from the other side into
Europe
this is all pretty abstract right so I'm
going to show you something actually we
were very lucky that one of our clients
allowed us to open-source a prototype
application that we built for them we
typically not able to do something like
this and I apologize for it being German
I think we're going to be late at some
point in time but for the point I'm
trying to make this doesn't really
matter right so let's just do something
I can search for a person this customer
selection I can I can select one of
those people here and then I look at
this is actually an insurance company
not that it matters right and I have
something that I can look at here I can
select the individual contracts let's do
that here and now I could register a
claim for something and now I can say
well something broke that's what
happened I don't know how much you can
read with me a little bit bigger so I
can now register it that claim and you
can actually see if I if I look here I
have a little list of notifications so
those are things that I've put on my
calendar to address at some later time
and I can select one of them and then
what you're looking at is another
contract so it's actually pretty as I
said pretty boring stuff right just to
ensure internal insurance application
now the interesting thing is what you
what you what we actually looked at
right now with three different
applications and pretty sure you didn't
notice until you unless you paid very
very specific attention to the almost
unreadable URI bar over here so let's
try that again
and Phyllis traded purposes I'm going to
switch off JavaScript that's my little
icon out here so you actually have if
you could see a little small change here
now I have a button here that wasn't
there before that's actually not true it
was there before but it was hidden and
when I started typing the incremental
search worked in work so that it act in
and then it actually submitted the form
that I'm looking at so this is actually
the other way around and what you to
what you'd probably expect this is not a
fancy JavaScript application that has
some fallback strategies actually a
basic HTML application that's being
extended using JavaScript but I'm
getting into roll call and I didn't want
to do that too much so I've now clicked
search and you can actually see that
this next screen is in fact the same
thing that was embedded in the
incremental search that I did at the
beginning right so
again one of those things again that's
not what I want to talk what I wanted to
talk about what I really wanted to talk
about is this little envelope icon over
here so what you can see is that there
is no longer a number indicating how
many unread notifications I have and if
I actually click on that thing you can
see that this is a different application
it's actually my inbox it's a different
it's actually built using different
different technology to of I think three
or four applications here have been
built using spring built one has been no
one has the ability using spring but the
other three have been built using no J's
not that it matters because for the
Indic for the integration that's
completely irrelevant because what's
actually happening here is that they
that you include part of one application
into the other so if I select something
here you can see that this is a boring
web application that just happens to
work and if I turn on the JavaScript you
can see that there's the indicator here
and I get the same UI will almost the
same UI embedded here in fact it is a it
is a subset of the actual UI because my
colleagues who built this to make the
point actually use the exact unchanged
HTML and just cut out the parts that
they want it you can make them do that
in a more efficient way but they wanted
to show show off so that's how they did
it did that make sense
so you have this integration of multiple
applications using basic web strategy
this is nothing fancy at all this is
actually all technology that we had
available a decade ago with maybe the
exception that a decade ago this whole
whole ecosystem ecosystem was a bit of a
mess and we have a lot more
standardization these days a lot more
browser browser capabilities a lot more
browser compatibility
so we can build this in a way that works
in different browsers without investing
too much time in the whole thing so
let's switch back to my to my
presentation what I just showed you is
what I like what I like to call
transclusion so the idea here being we
embed something and that is something as
I said that's been doodle for a long
time and actually think that we're going
to get more of this kind I'm using
something called web components which
you might have heard of pretty new
standard currently being very slowly
adopted by different browsers but there
is a polyfill that is a JavaScript based
implementation for older browsers that
allows you to use it in
the browsers as well and that might add
a little bit to that because this is
essentially a contract between different
parts within a webpage that is
independent of any particular framework
which I like a lot it's also if you want
to compatible with the progressive
enhancement approach with the idea of
using plain old server-side HTML and
then extending it on the client side you
can do that very nicely with web
components and I think it's an important
thing so if you look at the browser as a
platform if you actually build multiple
web applications as opposed to a single
one the browser's
integration features are a great start
to connect things right you have
independent applications they're
obviously loosely coupled that's what
the web shows us by the simple fact that
you have come applications built by
different companies operating nicely
separately deployable based on a
standard and so on and so on right they
run on a device so if you ask me for a
recommendation if I am myself or my
colleagues are consulting or building
something for your company then we
typically advocate for doing this just
this just build a web app build it in a
decent fashion and of course that is not
easy to do in today's world because
today people expect something out so I
have a little cheat slide here which is
how to get away with just the web
sometimes it works it works if you start
with a mobile first approach that's
absolutely critical because users will
want mobile access especially
stakeholders specially non-technical
people will use their mobile devices to
access what you have to offer so it has
to be a mobile first strategy that means
you get at a responsive design if you
want to have a great mobile experience
using a web app then I think the best
approach is to use progressive
enhancement because this reduces clutter
and bloat and makes it a very nice
experience now of course if you have
multiple applications an obvious
question is how do you make sure they
all look the same
how do you make sure they all behave in
the same way right because you don't
want to have different applications if
it's if you're one company delivering
something to your clients so the next P
part is to set up some simpler share
lessons that's like your own little
internal bootstrap repository right
hopefully not based on bootstrap if
you're a big company because that's
embarrassing but you have built
something internally and you use that
and
everybody can pull in the newest version
if they like to that's also a critical
part you don't push that to other people
you don't update that for them without
their knowledge because that is not the
micro-services way right everybody
decides on their own so you might be a
little out of sync but that's probably
fine in most of the cases you sacrifice
some efficiency for this increased
autonomy which is what micro services
and all the rate related things are
essentially all about right sacrificing
something to gain benefits in terms of
autonomy and independence and then you
end up with small front ends loosely
coupled my favorite way of doing things
again this doesn't work all the time but
very often it does also it gives me
another chance to include a quote by one
of my favorite people match it's a glove
ski awesome person check out his talks
and his Twitter and basically everything
he's ever written anywhere it's all
fantastic he has this great talk about
website obesity about websites having
become way too fat for their own good
which is very true if you're actually if
you're actually using the modern web you
know this very well probably and he has
this great advice which is make sure the
most important stuff loads first you
know the thing that you really care
about that should be first not the not
the wrapper not the chrome not the
application frame or anything like that
the actual content is what your users
care about whether it's an article or an
order or an account they want to see
that and then stop because that's the
best way to do things I like this
approach a lot watch that talk it's way
funnier than any I could so that
addresses parts of this tree right so we
now have talked about this rendered on
server kind of thing which i think is
something that is used not nearly awful
enough we could use this way more often
but what about this stuff on the right
how do we how do we address those native
application teams what what if you have
to build a native application and Bekah
that could be excellent reasons for that
right for example you might have a
requirement that your client works
offline completely or you might have a
requirement that means you can't only
access the the devices capabilities
using a native application because the
web application simply can't because
there is no standard and no repper to do
that or you might have extremely high
usability or
well native looking field requirements
for some for some reason right then then
those are also a good reasons so let me
challenge another assumption from
analysts are okay well actually I don't
want to challenge that so much because
sometimes they are in fact sometimes
fundamentalists are just as okay as Beck
and monoliths because a monolith
contrary to what I said at the beginning
is not at all always bad
in fact personally I think monoliths are
awesome so I want to build a lot of them
you know a monolith is perfect until it
hits a certain size until it till it has
grown to exceed that size it's perfectly
nice so a monolith itself has good
cohesion and it's nice it's easy to
navigate it's easy to refactor
internally you can easily deploy it it's
won all the benefits of being one thing
turn into negative things once that
thing becomes too big but they're really
nice if things are small and sometimes
that is perfectly fine for native
applications as well so you say you're
building an application that consists of
a few services that you've nicely
modularized and then there is some UI
stuff left and that is really something
that two people can build in three
months then I would not advocate you
separate that and to individually
deployable components because that's
probably not really useful but if you're
from an application is the result of a
collaboration of two dozen people
sitting in five different teams then you
do need some sort of strategy
unfortunately if it's a native
application by its very definition it
restricts that idea it's a native
application because it is a single
deployment monolith right it might be a
single iOS app that you have to deploy
through the worst deployment pipeline of
all the Apple AppStore right you have to
pull it's not deaths nothing continuous
about that so you have to push it there
then you wait two weeks or maybe a week
you're lucky and then that update gets
pushed out so you really have to
coordinate and synchronize to achieve
those goals the work of multiple
different team members and you only have
internal modularization to achieve that
this is not my fault this is because
it's a native application right I don't
have a magical strategy here because the
platform doesn't offer one so sort of as
Lucian is to address this using
organizational structures so if you have
a 50 person team you can have 5 people
responsible for the UI and they could
form one team that's nice because they
can work together on that monolith but
it's bad because now everybody hits that
poor team for any meaningful change that
is relevant for an end user not nice or
you could distribute those five people
to five different teams which means they
now have to meet once in a while to
synchronize the releases which is also
not great but what can you do
sometimes your platform supports this
with some sort of internal interface I'm
not an iOS developer so I can tell you
exactly what strategy to use but I'm
being told that both in iOS and Android
and other figments there are in fact
other modular modularization strategies
than micro-services who would have
thought but they all require more
integration they require more of a
single platform it's more a little bit
more like like EJB components or Java EE
components that sit in the same app
server as opposed to different
microservices right they have a stronger
connection to each other but you can do
it with a lot of discipline with
planning release trains you can get to
that but if you can avoid it you should
because it's definitely not ideal if you
have a larger UI if if multiple
contributing parties that is not really
nice one nice strategy that we've
applied multiple time stone that I like
a lot is to use sort of the best of both
worlds and build a hybrid a hybrid
essentially gives you a single
deployment thing for the native
application but you only have to deploy
that if you change the outer frame right
if you change the most important thing
because in a hybrid most of the logic
hopefully at least most of the logic
comes from a web application and you can
even reuse the same web application
because face it most of the time that's
my experience personal experience most
of the time when somebody says we want a
native application it's because the
marketing apart marketing department
said we want to have that available on
the App Store logo somewhere not because
of any technical reason I apologize if
your use case is different but most of
the time that is the reason and you can
easily fulfill that requirement by
having a small wrapper that just
includes the web native the web
application in the native parts so that
covers that sort of stuff
right we've talked about this class
Wepa we've talked about native
applications and we've talked about the
hybrid model that combines the two which
leaves just one thing and that is the
rendered on the client kind of thing
right so we have something that is
rendered on the client and if you look
at that then there is a lot of a lot of
mainstream momentum right now behind all
of those nice ideas that say you can
actually build a JavaScript centric web
application that is just as good as a
native application which is kind of
Awesome except my goal would be for that
application to be not as bad as a native
application so I've just talked about
all the bad things of native
applications they have this monolithic
structure you don't have a you don't
have a standardized way of integrating
things why would you copy that why would
you build something that is not great
using a technology that can actually be
used for great stuff I don't get it
in fact this reminds me of something I'm
one of those rest people in fact I
believe the very very first rest talk I
gave was at some DevOps was about 10
years ago even work I guess and I talked
about this thing and I talked about how
rest differs from so whistle based web
service so if anybody here in the room
is old enough to remember that right
those were those Engelbrecht T horrible
kinds of things and if you look at what
a web service does it does everything
but the web right it it tries to avoid
everything that makes the web great
just because port 80 was open in the
firewall I mean that's a very good
reason but maybe not sufficient maybe
maybe it's not a good idea to pay for
all to pay all the costs for your using
HTTP if the only reason you're doing
this is because the port in the firewall
has been opened it actually misuses HTTP
just as a transport protocol it ignores
the goodness of different verbs that
have different meanings so that you can
for example apply caching to some of
them it doesn't have this link ability
approach right exposes the single end
point used to be my favorite pun this is
where the web ends right the endpoint
fails to embrace the web in every regard
and that is actually true well I have to
say this this is what I mean by web
service is the soap whistle XML kind of
service right because these days people
start using web service to talk about
restful or sorta restful web service
which I find fantastic but if you look
at Web Apps they tend to repeat the same
mistakes if something uses the browser
as a runtime it is not necessarily a web
app it may just happen to be a desktop
application that runs on the runtime
provided by the browser and if that is
exactly what you're looking for that's
fine if your use case would be just as
great with a desktop application use
this model this is perfectly fine if
they're being badly built they don't
have to be but if they're being
carelessly built then they then they
ignore explicitly ignore all the things
that make the browser cool I can't hit
the back and forward buttons I can't hit
refresh or go back to the starting page
I can't I can't switch off JavaScript
because if I try that I get a white
screen if the JavaScript is still
loading also get a white screen I
typically get frames and decoration
before I get the actual content doesn't
support linking and exposes this
monolithic beast that is not something
that I want to copy right actually if
you look at this if you look at this web
thin if you look at this rest thing it
has this idea of hypermedia enough
actually encapsulating process flows I
reused my diagram from a few slides
earlier actually if you look at the
web's architecture embodied in the rest
architectural style then there is this
idea of having an unknown client you
don't know what kind of client it is it
could be a browser but it could also be
an automated user agent something like
curl or a crawler or something else the
idea that you have kind of different
clients is a very important one because
it means the interface to that client
has to be largely a declarative you
don't assume that everything that
happens in the client will happen as the
result of the execution of some program
that you deliver to it so logic and the
actual and the actual state machine is
kept on the server right rest is a
client-server style it's derived from
the client service tone which means the
logic sits on the server where god
intended to put it because every time
you make a change now it's immediately
available to everyone and you make it
just at this one particular place and of
course you can extend the client even
the rest dissertation the recipe a cheap
thesis has this concept of code on
demand
to extend the user-agent to make it do
something that it couldn't do on its own
which is perfectly fine in the role of
JavaScript so let me try to address this
from the rest perspective if you're into
this rest thing right then you have
heard of this hypermedia thing some
people talk about hypermedia api's where
I would talk about rest api is because
there is no rest api that is not a
hypermedia api and you could have what
multiple ways of doing that one way to
get a fantastic hypermedia application
is to just use HTML because surprisingly
it is the original hypermedia format it
has hyper media controls forums and
links and all of that stuff and you
might say I don't believe in hyper media
which is fine because the rest of the
world does as evidenced by all of the
existing web systems that we have and
you can tell me that you have these
individual applications but they're just
being linked to as a whole and not
through the individual parts inside so
if you want us if you want to strive for
this you can just use HTML or you can
invent your own JSON based incomplete
clone like hell or a siren or JSON API
or what have you because they all try to
to replicate what's already inside HTML
and the same is true for the client
perspective you want to have a restful
client which i think is a pretty cool
idea you can actually just use the
browser because it's already there and
if you build a hybrid application that
is actually what you're doing right
you're building a hybrid application for
some specific stuff maybe 10 to 20
percent of what your application does
and you're using an existing fancy
hypermedia tool called the browser or
the embedded browser review to extend
your application to follow hypermedia
instructions from the server which is
actually pretty neat or you can invent
your own JavaScript based buggy clone of
the whole thing by using a Hydra media
API on the server and then parsing the
JSON to render a form
wellit's or another form a UI because
you can't use the word forum because
then your boss would notice that you've
actually started building a browser I
actually think the browser is
drastically under under under value
people don't know what they what this
thing actually is and they don't know
that the value of the browser exceeds
its JavaScript runtime that's a
fantastic thing to have but it's just
one part of the many cool things in fact
the browser is a fantastic way to
declaratively
that's the power of your of the
underlying computing device this awesome
3d graphics accelerator things and lots
of fancy things that you can that you
can use and you don't even have to
program them you just provide a little
bit of HTML and then it'll work you also
have a great architectural style
support in that architectural style for
mixing those things so this is an
example that I often use this is a
simple select control in HTML with a few
options and if you look at what this
renders it'll it'll show you something
like this and normal people so none of
us in this room but normal people don't
know how to select more than one element
here and this looks completely ugly but
from the underlying information model
this makes a lot of sense so what you
can do is you can start with this you
have the basic HTML and then you add a
little bit of whatever JavaScript
library you like this happens to be
jQuery UI but really doesn't matter and
you would declaratively access the parts
in the in the page that have a certain
class or element name whatever it is and
then you render some fancy control this
actually gives you a very nice
programming model for your whole
applications so this is a style that
actually matches this idea very nicely
in fact I think if you don't have to
choose a model if maybe you shouldn't
write you should at least think of it so
if you if you pardon my stealing here if
you really build a complicated
JavaScript kind of thing you start to
reinvent things that are already in the
browser and that's as I've learned over
the past few decades not a necessarily
good idea in fact we have another side
of those is a little older than the SES
architecture kind of thing called Roca
again that's not a products on the
framework it's not a tool you can
download it's just a set of best
practices Roca style and that actually
talks a bit about what constraints you
would have to follow to claim that your
system is is following that style and
that's not something you get a seal of
approval for or you know some bonus
points is just something that makes it
easier to talk about those things and I
think more people should be aware of the
of the underlying ideas it's not
necessarily the name I don't care much
about that one
interesting the enough of a colleague of
mine a new colleague started her job
with us said I like this Roca approach
but maybe that's just because I'm lazy
just makes things easier and I kind of
like that but maybe I'm just too dumb
for the complicated stuff then I felt
like saying no you're completely right
this is exactly what you should be doing
so the last ten minutes but only the
last 10 minutes were a rant against
single page applications at least a
naively built way of single page
applications and I'm aware that many of
you are angular fans or react fans and
not if some ember people in the room
which is all fine go ahead do that if
you're a fan of single page apps don't
don't come to me bragging because I
don't like them but it's fine for me if
you do that it's nice and we actually my
company we have a lot of single page
apps for different different kinds of
different kinds of scenarios but if you
build them at least don't build a single
monolithic one that's not a good idea at
least build more than one and allow
yourself and enable yourself to make a
decision in each scenario whether in
this particular case a single page
application might be a good choice or
not and if it's a good choice which
framework is the right one because you
know what you're going to run through
this exact same problems you had on the
server side with your client-side
versioning maybe some of you have I
don't know how many of you have build an
angular 1 application and are now faced
with migrating it to angular 2 and if
it's a large monolithic client-side
application you have the exact same
problems here on the server side exactly
the reason why micro services were
introduced because updating things that
are too big is a major pain and or
whatever so don't reinvent browser
integration features rely on what this
thing has and of course that means
accepting some if inefficiency for
example if you want to use those browser
features or being able to link into
something sitting inside an application
then you have to actually jump to that
application and load it and if that
application has a megabyte of JavaScript
to serve to you because you before you
actually see what you're interested in
you're going to pay for that which is a
consequence of using a single page app
so maybe use a little less than a
megabyte maybe use 100 kilobytes or
whatever it is that you find you need so
except some inefficiency because the
benefit that you get for it is more
framework independence right you can
actually change your mind and maybe if
even if it's only a newer version of
your favorite JavaScript framework even
that may be reason enough to follow this
avoid modularity a lot Java EE was GI
whatever because it's going to have the
exact same results on the client site
that it had in the server side and
repeating the same mistakes that we did
in Java on the server with JavaScript on
the client isn't really an improvement
that's not what we want to do so let me
summarize what I wanted to get across
and then we can have a little bit of
discussion afterwards I think that very
few organizations are in the business of
delivering delivering API is that
happens to be what you do and only then
you can ignore the idea that you eyes
are important but most of us should care
way more about the UI part than we do
and that actually means finding out what
architectural style is the right one
don't just accept the most popular
framework that is not a good way to
build an architecture think first of
what kind of thing it is you want to
build and then pick the most convenient
two of them best tool for that
particular purpose from an monoliths may
be okay or they may be not it really
depends on your scenario so they're just
as good or just as bad as Beck and
Melissa until is unto a certain size
it's perfectly fine and I wouldn't
bother with separating those things
because it's easier to for example when
there is a version update or when your
favorite JavaScript framework is no
longer supported to just throw the whole
thing away and build from scratch if
that takes you a few months or a few
weeks don't worry about it don't
overthink things but if it's something
you're building for the long run then
you should care about this thing and
maybe modularize the whole thing and I'm
absolutely firmly convinced that nothing
beats the browser in in this regard but
no other technology has this has this
kind of support for integrating various
parts from different from different
origins built using different technology
it has a fantastic standardized platform
available and the vast majority of
devices so that is something you should
you should strive for and with that I am
actually done Thanks
so any questions you have to wave
frantically because I cannot see over
there you shout really now they might
hear you
so the question let me let me repeat the
question the question was there's a lot
of tooling for single page apps there is
a lot of great tooling for sba for a mix
of various kinds what is the analogy in
the press of Enhancement world what
would you use there how can you get
similar developer productivity so in my
view the major major benefit that single
page apps single page app frameworks
have is they provide you with an
out-of-the-box architecture they provide
you with a set of decisions made by
other people which is nice because you
can reuse that knowledge from one
project to the other you can talk to
somebody who knows the framework and
they know the particular architecture I
think this is something that we have in
the progressive enhancement world just
as well we just need to understand it
because there's a fantastic model of of
actually delivering pages there's a ton
of server-side frameworks that you can
use to do that including those who
support for for partials and modularity
and reuse the templating you just build
that on the server side to build a
standard old-fashioned java the HTML
server-side application which i think is
absolutely comparable and then the
question is how do you get this
client-side functionality in the past we
used to fiddle around with a little bit
jQuery here a little bit of our own
library code over there it was all a
complete mess I think in the corrosive
enhancement world and particularly with
the move towards web components the the
upcoming move towards them we have
different kinds of things so for example
we have a solve problem almost solve
problem of modularity in terms of es6 we
have much better ways to isolate things
against against each other and you can
actually build up a set of client-side
components that you can compose so that
the contract between the server and the
client sub components is ax
the HTML of you generate on the server
side and I find that a very nice model
it may take a little more getting used
to in the beginning and it doesn't give
you a desktop style programming model
but I find it very maintainable I find
it absolutely usable and I find it just
as productive in fact I find it much
more productive at least in the mid to
long run then then the the convoluted
codebase that I see in many single page
app frameworks and of course this is
again an oversimplification that's
that's what people do when they just
have an hour to talk about things
because there's a lot of gray area in
between for example you might have lots
of parts in your application that are
essentially just boring forums with a
little bit of interactivity where the
approach I suggest is absolutely
perfectly sufficient and then you might
have a fancy thing where you have a
WYSIWYG rich text editor that that you
have to build yourself because there is
none that you could reuse so maybe you
would use a fancy framework for that the
key point I'm trying to make is don't
don't surrender control to the framework
use library since other frameworks
reuse things you reuse components and
other people have built assemble them
but don't don't give control to a
framework that might not be there a year
from now built for the long run as in a
similar way that you would do it on the
service any other questions or comments
I'm fine with comments too so don't
worry yes please
so it was it was a comment I think that
there is an older paper by Spotify that
seems to suggest a very similar approach
to the vertical slices that was talking
about and I can absolutely imagine that
I don't know that particular paper but
it's very important to me this is not
something that I or my colleagues
invented in any way this is just
something that I see emerging in many
many different applications for example
there is a there's a large German
retailer called Auto they they have they
write a lot on their dev block about
this whole thing we actually did a
little consulting for them they have
their built their own a shop completely
from scratch using a hundred people in
10 different teams and they've used this
approach of having separate vertical
slices exactly this when they talk a lot
about it there are things like like
Groupon for example Groupon does a very
similar is slowly moving to a very
similar approach from the monolith back
to these slicing slicing kind of thing
you could argue that Amazon has a very
similar thing although they do have some
page composition but they also have this
idea that a team is reponse responsible
for everything from the UI to the
backend part and there are older papers
from like a decade ago there's an
interview with vana for goods thing that
was about ten years ago there were he
talks about the two pizza teams that
you're probably familiar with it's all
the same idea right it's nothing fancy
it's essentially using the idea of
having smaller teams that are aligned
along multiple boundaries there are they
are aligned along along a boundary of of
domain contexts or they're responsible
for a certain part of the business
functionality and they're also aligned
in terms of operations and deployment
and development and making decisions
about versions and they essentially
don't have to have meetings with
everybody all the time to get stuff done
they can actually do it on their own
which i think is the overall goal of
this of this model anything else yes
right so that's another excellent
question how do you actually synchronize
the handling of shared assets right how
you how do you get those multiple teams
to collaborate let's say for example a
shared asset is the main menu the main
navigation bar at the top of the page
obviously you want that to be exactly
the same in all of the applications all
the time and I would concede that is
definitely the case for this particular
thing or you might have something like
I'm the way calendars are styled across
the application or you might have a
standardized footer across the bottom or
you might have recommendations that are
supposed to appear at different parts
with the system and that actually opens
up a whole discussion about the number
of things that you need to have in your
tool box for some of those things it's
critically important that you're
independent and autonomous but it's not
as important that you're absolutely
up-to-date and dynamic so for example
you for those use cases you might use a
module a git module that you just link
in to your interior system so everybody
only gets an update when they when they
rebuild but maybe that's fine for
certain things maybe for example for the
JavaScript assets that render certain
controls maybe it's fine if it's a
little of a sync because you don't you
don't want to have somebody you don't
force somebody to have to test this
until it's in their own fits into their
own development schedule some things you
might want to do with a remoting call so
for example you might check for a login
of a certain level before you show a
credit card number and maybe that's a
different system so you'd call out to
that system and come back it's a very
tight coupling
but it's absolutely necessary from a
business perspective sometimes you might
just replicate data don't mean this
don't mean using actual database
replication a feature that we've used a
variant up of use the number of times is
feed based replication so one system
service subscribes to an atom feed or
RSS feed of another system and makes
local copies of certain parts of the
data maintained in the other system so
that it can act autonomously that would
be out of sync but fine because you have
your value and
/ consistency and sometimes you want to
include things on the server side so you
use something like ESI that will be
etched site includes a feature by my
implemented by many caching servers like
varnish or squid where you actually at
the very end before you deliver the page
to the client you can merge outputs from
multiple systems and they could merge
that would be the one the approach I
would use for your question
you could merge a frame with the actual
content so that it gets delivered as a
single HTML but it's just one system
that maintains the navigation bar and if
you update it it's automatically updated
everywhere and for some places you might
just do it in the client-side like I
showed you using the transclusion
approach so if the other system isn't
available does that stuff doesn't get
trans cluded which is pretty cool
resilience built into the browser
because he just rendered the complete
page in the browser and if that other
system isn't there
well you can't embed something but
that's fine because obviously it's
secondary content and so you can just
show the main content so in essence
there is a whole set of tools that you
could use and I'm not advocating that
one is the right solution all the time
what I'm saying is that the front-end
student-centric solutions that I talked
about are very often forgotten about
people think the only way they can build
things is by using the desktop modeling
the desktop programming approach and
just building the same thing you would
have built using Eclipse RCP or swing or
windows presentation foundation whatever
just use that and rebuild the same with
the same approach using a current
JavaScript framework and I think that
falls way short of the opportunities and
possibilities the web actually has to
offer
ok with that my time's up again thanks
for the often awesome questions I'll be
here a little bit for discussions and
have a nice conference</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>