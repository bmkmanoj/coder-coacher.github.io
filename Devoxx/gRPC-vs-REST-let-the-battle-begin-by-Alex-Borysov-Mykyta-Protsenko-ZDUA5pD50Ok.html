<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>gRPC vs REST: let the battle begin! by Alex Borysov &amp; Mykyta Protsenko | Coder Coacher - Coaching Coders</title><meta content="gRPC vs REST: let the battle begin! by Alex Borysov &amp; Mykyta Protsenko - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>gRPC vs REST: let the battle begin! by Alex Borysov &amp; Mykyta Protsenko</b></h2><h5 class="post__date">2017-11-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ZDUA5pD50Ok" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everyone thanks for coming today
we're going to discuss different ways of
making remote calls in distributed
systems well let's talk first what makes
us qualified to you and discuss this
topic I'm Nikita % I'm a practicing
developer I work at Rocco
I work in billing and payments team and
in the past I walked in a bunch of
different projects using both micro
services and monolith approach and
learning some stuff there hard way in
the process and today I'm going to talk
how to avoid the common pitfalls in rest
world it's pretty easy don't use rest
and avoid those pitfalls I'll tell you
how you how what you can use instead of
rest and why my name is Alex and
hands-on software engineer I've been
working on distributed systems for over
a decade
I built system using rest so up on
different RPC solutions currently I work
for Google where I started to use G RPC
and today I'm gonna tell you why your PC
is one of the best options you have when
it comes to remote calls so let's start
from the beginning when people talk
about rest they use a lot of big words
like hyper media sell descriptive
resources service-oriented architecture
but let's start with what rest is not
rest is not Jason over HTTP very often
people get confused and they mix up HTTP
api eyes and rest api eyes and even
royal filled in the author of the very
concept of rest is pissed off about this
confusion so let's I'm confuse things
let's learn how to tell HTTP api is
apart from rest api s-- if i try to
describe rest in towards these two words
would be outdated approach no
architectural pattern set of concepts
and practices to make your system more
scalable and your life easier and the
most important of these concepts is
state transfer it means that client has
all the data about the current session
and if there is a need to change the
state of the session the client sends
the set of
the changes back to the server and the
server is 100% stateless why is that
important
let's take a look at a couple of
examples on the left from you we see an
example of a good restful api we have a
resource with a unique identifier client
can call it it can get all the
information about the resource it could
change the state of the resource and
send the changes back to the server this
is easy to write this is easy to
maintain and easy to scale and on the
right side we see an example of a non
restful api where the server has to
remember the information about the
current session what has been what was
found on page one what is going to be
found on page three how to reconcile the
changes if something pops up in the
process it smells of sticky connections
it smell of scalability issues and it
smells of weird bugs there is no rest
for the weekend ok so we understood what
rest is not and believe me therapy C is
not rest either so let's see what it is
Google started to adopt micro services
long time ago probably even before this
Wars was invented and as you know in
micro service world every client call
results in hundred remote network calls
to make all this process communication
inter-process communication efficient
Google developed its own framework for
remote procedure calls or our pcs and it
was called not not your PC it was called
stabby stabby was used inside Google for
many many years there were multiple
generations of study and finally in 2015
Google released open-source version of
stabbing which is called G RPC so G RPC
it's an RPC framework originally
developed by Google today it's a part of
cloud native computing foundation it
uses HTTP 2 is a Transfer Protocol and
it's built with all the modern
requirements to distributed systems in
wild and today your PC is used in Google
and number of other companies
wha-wha-wha you said RPC remote
procedure calls what does it mean back
to the age of CORBA and RMI
nice try but no cigar
sieze neither CORBA nor are my please
remember that and never ever compare
them because your piece is built is also
lessons learned from years of using
stabby lessons in scalability in
performance and building a tool which is
easy to use and easy to maintain for a
long time I can even say that your PC is
not just to library first of all there
is a set of best practices on how to
build how to design you distributed
systems and your PC is built on top of
these principles it provides you default
out-of-the-box implementations for loose
abstractions and gives you extension
points using this extension points you
can easily customize any part of its
implementation you can plug it plug your
customization you can add new features
and your PC consistent today is not only
Google there are other companies and
individual developers who contribute
integer peace ecosystem so what makes it
even more popular that your PC is not
only Java your PC is available for at
least ten programming languages what it
gives you it gives you freedom and
flexibility so your client and your
server they don't need to be written in
the same language anymore it's not RMI
and what else you can do you can write a
prototype of your service in Python and
then rewrite it for production in Java
and your clients clients of your service
they will not even notice this change
well but you're talking about
implementations now and let's take a
step back and ask ourselves can we even
compare these two guys because rest is
an architectural pattern and your PC is
a library with a bunch of
implementations a good point about the
games or receives more than the library
it also imposes a set of principles
since built on and it creates an
ecosystem based on best practices so
both gr PC and rest are diffracted tools
to build distributed systems based on
some principles and the boss is widely
used in scalable systems including
microservices architecture let's recall
how we're usually taught to build our
microservices
pretty similar to draw in an owl they
tell us take our framework XYZ now
it's 5.0 and then you know just nto
microservices yeah
but as Oscar Wilde said truth is rarely
true and never simple exactly because is
micro-services he sold 12 problems and
acquired new ones because nothing is
free let's name some some of the new
challenges we are facing right now we
have services that call other services
and the services come more and more and
more and as a result it has this complex
all IRR key in huge amount of remote
calls first off it's gonna affect our
performance because all this network
calls are expensive but I got one more
problem even before we make this call we
need to find out whom to call where to
call where to find the service or in
other words how to discover it so
Sarah's discovery is another question we
have to answer now and the real life
usually have multiple instances of the
same service right so at any given
moment in time we have to find what
instance to call depending on a lot or
something else so what balancing is
another problem we have to solve and
after we finally solved all this and we
made our calls it get complex all our
our key and we need to trace and and
monitor it and when some of the services
are slow we need to be able to a find
them and be tolerate them it's even
worse than that because services won't
just be slow they will break they will
crash and burn back in 1987 Leslie
Lamport said that a distributed system
is the system where your computer can
break because of the computer you didn't
even know about or something like that
1987 was doing before people started to
register but what kind of before that so
now we are going to have services that
are going to break and we need to live
with it we need to teach ourselves how
to build a system that can keep going on
when some of these services are failing
alright so you got a bunch of new
challenges Hill if you of them we just
mentioned but we are lucky because your
PC is built with all this
in mind and it helps us toes approach
them well not just your PC because read
rest got introduced back in 2000 and
since then people learned how to deal
with the challenges in the rest world as
well did they they did indeed so let's
take a look at example and basically
let's go ahead and write the services we
can call
what do your services do when people
call them they usually execute some
logic and they call other services so
let's build an aggregate in service to
collect documents for example or big
data oh well you cannot do anything
without big data nowadays so let's
collect pokemons and big data buzzwords
and aggregate them and to make things
even funnier let's don't forget that
external sources may return us data or
pokemons or big data buzzwords using
different formats some may reply with
JSON some with binary data and some may
even return XML sure XML because XML and
the rest are like two peas in a pod
right no not really on the contrary rest
doesn't care about format representation
doesn't matter you can use homing
pigeons to transfer your data if you
want to and to illustrate your point
let's build our service to actually
accept the data different data formats
from different sources and aggregate it
and reply to a client with some kind of
unified format so let's start with a
with some code snippets from a sample
Springwood application to show how to
build a restful architecture as with a
classical web application we are going
to have a controller that is going to
get requests provides replies we're
going to have the service to do all the
heavy lifting and we are going to have
data sources to call external services
to get the data and let's not forget
that the rest is all about resources
these external services will reply us
with they provide us resources first and
foremost they will give us some unique
identifiers of those resources they will
give us some structured data and the
representation of this data JSON or XML
is irrelevant
we don't care why is that because when
we actually do the call we use rest
template to get the data and the
serialization is going to happen under
the hood because all modern frameworks
can handle JSON XML binary serialization
it's not a problem it's just as simple
as to draw a circle instead of an owl
the fun part is going to happen in the
service the interface of the service is
simple we're just going to call it to
fetch a new resource by ID and under the
hood is going to call external services
but it's also going to add value and by
this I mean we need to provide a type
back to the client because we need to be
able to tell apart pokemons from Big
Data buzzwords and also we need to
provide a client and exit a next ID so
the client will know how to find the
next resource and final step is
controller and it's pretty simple just
call the service and define a UA
you're right so we can find this er this
resource and if I last step with that we
need to do is to define a representation
jason in our case so we got a system
that we can start integrating with it's
easy to integrate because all modern
languages have production ready HTTP
clients you can start integrating right
away and if you want to test it you can
use any tool starting with curl right
okay controllers the projects are cool
and easy but let's look at the bigger
picture how your client will know where
to find your service is your controller
good question let's find out how to
bring rest and service discovery
together today we have a bunch of
service discovery solutions out there
starting with world-famous Apache
zookeeper and the most popular solutions
they usually implement some kind of DNS
based service discovery providing your
DNS record to resolve and point in you
at the right direction so let's take a
look how it's done in kubernetes for
example we have two services one service
is defining its own name and another
service is using this name as a host
name in the URL it's pretty simple Norco
changes are needed it just works yeah
but this is an external solution
somebody has to install it somebody has
to support it it is true but if you are
deploying your services to cloud today
the chances are that your cloud provider
already has some kind kind of solution
ready for you
for example Amazon has around 53 and
load balancers elastic load balancers
and Google has kubernetes okay so you
showed your controllers annotations and
pauses and they easy to write indeed and
the engineers real-life coding we do so
you jump to writing our controllers
right away so what do we end up with
oftentimes we have a bunch of services
and nobody really knows they rip ice
make it up what doesn't if you have a
service sure not problem let me check my
laptop let me check my controller wait
I believe while with the invocation
peter has changed some something here I
have to look it up does it look familiar
and it worked when I had two or three
tries but in micro service wars we have
like gazillion of api's and it will be
good to formally describe them well what
stops us from using swagger we can use
swagger to formally describe an ideal or
we can go the opposite direction we can
parse our controllers and annotations
and generate swagger definitions based
on them well some parts of your team can
use it some other cannot it requires an
additional discipline in your project it
requires an extra process it requires an
external tool after all with G RPC we
change the game
we start with an API when we need to
write a service that aggregates data
from multiple sources the very first
thing we have to write is its formal
definition its API there is no other way
to start writing your PC service
out-of-the-box your PC uses Prada buff
as a language to describe your API you
can change this implementation you can
use other ideal but the fault language
is proud about this product we can
easily define our aggregation service
there is no boilerplate code we get a
single method get it takes a request it
returns a response in the request we
have an ID in a response we have ID
content response type and ID of the next
item
now we formerly described our service
and remember I brought up a point that
your PC is built on top of best practice
of having formal API specification
before coding is one of them and we
always have api of our service no matter
how many services we have we have it
described in language neutral way and
all the clients will use it as a source
of truth now we should use your PC run
time to generate classes from it in Java
we can use your PC Java Runtime you can
do it from command line or you can use
your build systems that are plugin
availables for cradle for basil for
maven
let's call our wizard your PC Java
Runtime hoosh and we generate abstract
service class hoosh only generate
requests and responses builders Rogers
we don't need no stinking paw juice but
the client has to generate the builders
now somehow of course but it's easier
than writing them manually that will be
just an extra step in your build process
and we of course can generate
strongly-typed client libraries or stops
now it's time to implement your PC
server so have tops to extend generate
abstract class and it already has an RPC
mustn't get in the same method as we
described to now ideal it takes requests
but it doesn't return anything
as you can see why because your PCP is a
synchronous by default here is the same
when you receive a request they don't
always have a response right away
oftentimes we have to calculate it we
have to worry from some external service
or we have to build it from multiple
sources what we can do here I can just
block our current thread until we have
all the data available and then return
it to a client this way we could have
response isn't as they return type of
animated but what happens from the block
the current straight the request let's
take a look at an example we have a
service with a straight pool of size X
and it blocks current thread the request
first request takes the first thread
second take another and so on and
request X take the last thread and when
X plus 1 requester
and we have no threads left we just
reject this phone so number of requests
we can handle at any given moment in
time is limited by the number of threads
we have in our strap pull this approach
kind of work but it doesn't really scale
that's why we use dream observer and
stream observer is one of the key
interfaces in your PC
it has method all next and when we want
to send the response to our client we
can call this method all next is a
response when our RPC method is called
we don't block a thread and we don't
return anything to our client now we can
handle more requests than we have
threads in a thread pool and when we
have a result we just call on next
method passing our result to a client
this approach is always called Hollywood
principle don't call us it will call you
when the result for client is ready we
will call this client using this
provided method on next we call first we
call surgery called act depending on
what response is ready
that's why API is looking like that now
our server can handle large number of
requests but if we have result right
away they can immediately give it back
to our client just don't block the
thread we can use aggregation response
builder to build a response and send it
back to our client using method on next
wait a second I remember you defining a
field called next ID in your protocol
file but I don't see using it here sure
yeah I don't use it here because the
reason there isn't a simple I don't have
it I'm talking about the stream of
pokemons and as a father of two I can
tell you that there are much more
important ones that you can imagine when
I get a Pokemon I have no idea what will
be the next when I have no idea to
provide but how your client will know
how and where to find the next item
let's see I need next ID so my client
can pass it back to me in the next
request right so if I don't have it in
my request I don't need it to my
response so I just want my client to
subscribe to subscribe to my stream of
pokemons and when I have something to
give them I will return them a new item
that's typical streaming scenario
streaming there is no resource IDs there
is a stream of responses and Sarah knows
better when to send them back in your PC
we can just add stream modifier to the
response and voila we have streaming API
now we can set multiple pokemons back as
needed let's name a message subscribe
now and remove IDs from request and
response and now we have clean servers
three mini try that was an aggregation
service definition but it takes this
data from other services it gets it from
content service let's describe this
content service content service is even
simpler it has nothing on the request
and it his ID and content in the
response we are going to have a separate
service for pokÃ©mons a separate service
for big data but both of them are
described using the same API definition
and using this API definition we call
our wizard cat means your PC runtime and
it will generate service definitions and
clients for us and aggregation service
will just call our content service using
these clients or stops let's implement
aggregation service to see how we a
implements 3mins or PC service and B how
we use client libraries of client stops
here comes the example we take generated
content stops we inject them and when
client calls a subscribed method we get
the request here what we are doing here
a donut find out Union we call all the
content services by the way they using
the same Hollywood principle we don't
block the current thread when we call
our services so this way we can
subscribe to multiple sources from a
single thread when we call a client stop
it's like it's like a voicemail we can
do fast car service please send us back
a Pokemon when you have it and here's my
number I mean in my stream observer is
my own next message on it and when
service has a new Pokemon it calls me
back using my message on next giving me
back my new item few things for
emphasize to emphasize here this first
of all these Hollywood principle we
could subscribe to several services from
single thread
other than that we streaming we can get
multiple responses back because there
are a lot of pokemons out there so all
next month's that we've got many many
times and finally please note this after
we added streaming to our API our method
hasn't changed at all
me because gr PCP is I designed to be
non-blocking and reactive being a
synchronous is important for scalability
soldier pcs forces you to write in the
style and forces you not to block the
current thread and all the work we will
do any one message arrives in our next
method let's look at it here when we get
a new pokemon or a big data buzzword we
convert it with a deck response type and
we build our aggregation response
builder using our aggregation response
or using a builder and that's it no
resources no next IDs so what we did
here is an aggregation service when
client subscribes to it it subscribes to
all the sources when any of the sources
return the result we convert and return
back to a client when other service
responded they return other Pokemon to a
client and so on so to launch every
single rod you need to start out your PC
server now any ideas how we do that with
annotations maybe almost but now these
builders we have Lady Sarah builder we
set up a port and we add a service if a
your PC server implements multiple API
switch is usually the case we can call
add service multiple times and the same
reason we need to start our service but
you see that we injected
Pokemon and Big Data client to
aggregation service now let's see how we
created this client we have 90 builders
to instantiate them this time it's not a
channel builder it's an additional
builder for others host port we created
the channel and Channel and your PC is a
logical abstraction logical connection
between your client and your service
using channel we can create clients or
stops we don't need to write this
top celebrities may not anymore using my
set new staff we created a synchronous
stuff the other edge is so how to use
this stuff it takes requests and stream
observer of the responses but if you
need to block your current set until you
get a response you can use a block and
client and finally if you have hate
callbacks and you'll have functional
style you can use future based clients
you're going to call new future stub
method and it will give you back your
future if our future back sorry just
trying to wake you up guys okay and and
now you can map your future you can
subscribe to it and so on
choose whatever stub you need one
doesn't simply choose at your PC client
actually one does and most easily will
only in one of them wow that's a lot to
digest but still that beginning let's
talk about something more interesting
that stubs and builders you asked me
about serve discovery and rest and now I
want to ask you about sir discovery in
your PC world sure first of all messin
stops us from using DNS based solution
like you did and here we did exactly
that but your PC provides the extension
points and in case you have your own
solution for service discovery a lot
balancing maybe you have some custom
metrics that like let you choose which
instance to call so in this case you
don't have host and port but you
implement two interfaces instead named
resolver is the first one it's an
implementation of your service discovery
and load balancer is your load balancing
strategy your PC provides you some
simple implementations out of the box
but you can write it around if you need
and your implementation can integrate
with your own homegrown I don't know
load balancing solution or with
client-side load balancing or anything
else so your PC doesn't limit you by
using external DNS based service
discovery solutions another notable
thing here is native standards ensure
peace implementation is built on native
and many provides us as an asynchronous
and unblocking IO and HTTP to used by
native with prod above
by your PC give us high performance
framework and performance performance is
a first-class citizen and jarppi CTR PC
team continuously running performance
benchmarks if you follow a link on a
slide you can find real-time performance
the best boards for the latest available
release and for the latest development
version and master these benchmarks are
run for every single pull request it
helps your PC team to find any
performance regressions as soon as
possible and via our PC users always
know what throughput and latency we can
achieve using your PC as you can see for
the scenario under test use your PC Java
we can achieve more than 600,000 QPS on
eight core machines or even more than 2
million QPS if you searched two core
machines okay that's even faster than
the last time we talked about it and
that's cool you totally got me convinced
non-blocking i/o is the way to go
but rest can do non what can I add to a
synchronous servers have been around for
a while and B you are talking about
performance of streaming solutions
between servers but what about clients
because real system is going to have a
client and a server and what if we have
performance issues between a client and
a server what if we have a client in
Australia combining about 900
millisecond latency in rest world that
can be easy to fix you can just drop in
a cache between your client and your
server modern city and providers let you
do it for mere sense for a gigabyte of
traffic and you need no conscientious
and no infrastructure changes on the
server side ok in this case we can use
your PC for services server performance
and provide client restful advise it can
be cached well I agree that's a totally
valid approach but you can use rest in
the backend world as well for example
rest is an ideal candidate for service
solutions like how do you do a classical
deployment in cloud usually have a
couple of the aims you have a load
balancer if you need to scale you just
add more VMs when you don't need them
anymore
you shut them down you stop paying for
that but what if you're not Google what
even what if these two VMs are not used
100% 24 by 7 it means you paying for
something you not using to solve this
issue serverless was invented in the
surrealist approach your code is
represented as a function that takes an
input and it does something and you pay
only while your code is being executed
and your function can be shut down
immediately after it's done and rest
being stateless is an ideal feat for so
for a stateless function ok so yes it so
that use case is a kind of different
let's take a breath and see what we've
got here the difference between your PC
and the rest is visible with a naked eye
yes but it didn't stop us from
implementing our aggregators using both
rest and your PC and I'm not talking
about a few code snippets on slides we
actually wrote the code we commit it and
pushed it to github and we compiled it
and deployed it to cloud and Alex
started with asynchronous streaming and
here's your PC services I use client
polling for rest Alex rolls started with
writing ideal for his your PC stuff I
wrote some controllers and annotations
as it doesn't even work let's give it a
try then okay so other services even
have a UI and they will show you I'll
try to show it to you yeah we got all
the pokemons we got all the big data
buzzwords not all of them yeah it's hard
to track some of them so is it well
total tech sounds like a Pokemon ok if I
click on it I get new one
overall that's definitely big data stuff
storm sure beaker not sure my son would
know yeah your son would definitely know
it seems like we have we have some
confusion here we cannot really tell
them apart for sure I believe it would
be nice to be able to guess to vote and
see if you have guessed right but to do
this we we will need to change our
architecture we'll have to add a couple
of components
starting with with voting service so we
can accept a vote and we can compare if
you guess correctly if it's a Pokemon or
big data buzz board and to do this we
need to go to aggregator and compare the
actual type with the type provided in a
vote and it's also going to validate the
item to make sure that it actually
exists because we don't need Norfolk
news here we don't need election med
link either so what answer is we'll pass
the word to the new service called
leader board which will keep track of
top-5 guessers and it will give them
back to a client of our gateway and
Gateway service will randomly choose
between your PC and race implemented and
provide public API tour clients that's
how new architecture look like but with
the new architecture we got all the
problems we talked about earlier leader
board seems to be an obvious bottleneck
if leader board starts failing when
leader board starts failing when leader
board starts failing vote him and
Gateway and clients are going to fail
too we have a classical typical
cascading failure scenario in rest world
people usually handle this kind of
issues using circuit breakers like
history
if the server starts failing we just
stop calling it but we do a health check
every now and then and while it's down
we produce an error or fallback response
right away we don't call the service we
give it a chance to recover
and when our check passes we just resume
the normal traffic ok circuit breaker is
a great fighter I agree and you can use
it in your PC it will require you to
write some more code to integrated
logistics for example but we have
another problem here the world doesn't
end up with dead services it's even
worsse to have slow services slow
services are harder to investigate they
kind of work with Samson control circuit
breakers are triggered by exceptions
including timeout exceptions and our
client are different as well
clients are latency-sensitive some
others can wait for example what if a
mobile client has 200 milliseconds time'
but left off can wait for two seconds if
you say at large time out between our
services latency tolerate Lenten season
sitive client sorry will fail if client
came out is 200 milliseconds and first
call took 50 milliseconds second to 400
millisecond client got an error but
services they are not aware of that
they keep chatting alone they waste our
resources this doesn't work too well
does it let's see what happened well
these short service to service team are
let's say 100 milliseconds tell what
happens with latency tolerant clients if
our client has two second timeout and
first hope 250 milliseconds second 400
millisecond and this moment we reached
our 100 millisecond time out between our
services service produced an error and
now we have to return error tor client
probably to the timeout error even
though our client was willing to wait
for more than a second so it doesn't
work too well either
to fight such issues JIRA PC introduces
a concept of deadline propagation what
is that when client timeout is 200
milliseconds and first call took same 50
milliseconds what should be timeout for
the next call 200 minus 50 your PC does
the mass and it will automatically apply
time out of 150 milliseconds to the next
call if watching service is ready to
call our leaderboard service in another
400 milliseconds what should be a
timeout for this new call again your PC
calculates it for us 200 - 50 - 400 I
have no time left at this point your PC
will cancel all the calls for this
request is deadline exceeded status code
and it will not even try to make a call
to a leaderboard service if we have
latency tolerant client everything will
work for them even when services are
slow with your PC you get deadlines
propagation out-of-the-box it
automatically adjusts time out for every
next request based on time already spent
and it will save our resources okay we
solve this problem but we got a new one
here a client got an error but how do we
know which service is responsible for
this error because the call went through
a bunch of services client called
gateway it called voting it called
aggregator it called leaderboard how do
we find the culprit how do we get the
logs how do we investigate the problem
and how do we fix the issue after all
and we can use distributed tracing
solution for example projects under open
tracing or world-famous Zipkin Zipkin
sprinkles a pinch of fairy dust over our
projects and voila
is all the all all the calls all the
calls for our request and we can see
latency for each stage and we can see
what services was were called so what is
the trick under the hood the hood we
have added a label to each request of
each service report to Zipkin each time
you send the receive requests we tell it
who made the call who received it how
long did it take and so on does it sound
complicated don't worry your piece
already did the hard work for you all
you need is just to add interceptors
when you create a server and client
those interceptors are already written
for you you can find them in open Zipkin
project you create a tracer you tell it
where you find to find your Zipkin
instance and this tracer you can create
this interceptors so this interceptors
are an example of your piece ecosystem
in rest world it's even easier you don't
have to instrument every call either but
all you need to do is to add a couple of
dependencies here to your project and
provide a property point in your
application to a zip concern okay it
listens on this port on this host and
that's it you got all your latencies of
all your calls for both of the
implementations ok so we have a micro
service mash which collects pokemon can
tell pokemons apart from big data and
send result a client we can
but we can calculate top five aggressors
we have some fault tolerance built in
and even have a tracing and monitoring
who wants to try it out and test your
pokemon knowledge get your smartphone's
ready we cannot tell you what to do next
okay
alex is going to open up an application
okay so we have our well probably
pokemon here but now you have buttons
right you can try say is it a bug is it
a Pokemon or is it a big data by
pressing the corresponding button oh
come on big data and also please note
that on top of the screen you have your
username we are going to have a contest
competition so we need to know who's the
top guesser who's the Pokemon expertise
so don't close your application leave it
or take a screenshot so we can know that
you is really you so let me try to
actually vote and let's check our linear
board okay and we have a little word
here if you need to do what yes I did
okay okay we got some some requests
coming in so I'm trying okay so the top
guessers will get prizes it has the
layest harder from Google and Roku so
try a smart get your smart phones get
your laptop's alex is going to give you
a link which you can load sure because
we don't want to compete between
ourselves right we already have the
stuff and the link is guess it of course
your PC versus res comm you see it on
the screen go there let's give a
conference Wi-Fi a stress test and those
services as well and a services as well
let's see how well they can helmet
so when while people are voting let's
check our leaderboard
there's our board okay yeah we have a
pretty intense competition cool guys
keep it on keep it on okay now we can
take a look under the moon right so wait
oh okay a lot nice yes so what you can
see here is we deployed our services to
one of the public cloud providers and
you see this is a tracing well you can
see on the screen is a distribution of
all the traces leaked if we click on the
trace we see all the requests economy in
what services they yeah so that's a
content let's check the vault what is
more interesting but okay they can
filter it right wait anyway what you
just click on it I can see it here yes
oh nice yeah all right all the steps
great way gateway rest vote and rest was
investigator res Big Data content and
finally leaderboard they say also
service as a request and we see a bunch
of requests common and the latency
distributions here on the top all right
so to make it even more interesting what
about breaking our system what about
break in an old leaderboard yeah because
we have photo voice and how do we test
photons without break in our system
makeva has a magic command that
introduces the latency to our system
yeah it adds like 750 millisecond
latency to the door board so three two
one
I just broke leader board all right so
what let's check if our application
system works first of all yeah well is
it working on a big data uh it's a big
data of course mahute Abacha mahute sure
Impala it's big data as well okay so our
applications to works we still can what
but let's take a look oh nice the
distribution looks better now you see
that our request to they take longer now
much longer but if we cling to some okay
leave it because it's a rest
implementation and you can see that we
have gateway here : rest voting service
calling the rest aggregator but we don't
call leaderboard because we have our
circuit breaker open because it was
triggered by exception
nice so your circuit breaker works
alright so yes it does forces
recommendation I filter the resident
limitations so to see in your PC works
works we can click right here and what
you see here actually said the deadline
500 milliseconds to every ward so and we
can see here that no matter how long did
it actually take every individual
request took the entire call was
cancelled after around why 500
milliseconds plus some Network latency
and we can see on the bottom right of
the screen that it was cancelled his
deadline exceeded status code so let's
see Allah lovely creamy and kick-ass PAP
are leading the the competition and I
guess since our leaderboard is kinda
broken it's time to call it a day and
announce of our winners so lovely kami
and kick ass beep please raise your
hands raise your hands ok my hand please
come after the table okay please come
after the talk to claim your price and
please don't close your applications so
we can realize that it's really you and
thanks for participating it was really
fun to see our system working ok the
code of our dama and that's about a
dozen of different services can be found
on github here using this link and when
slides are published we are going to
make all the links available you can
just download them and learn more about
your PC and rest using those links as
well and we would also like to thank
this guy without whom the demo wouldn't
be even possible because he wrote the UI
for all our services thanks again
thank you again and on slides and them
so that your PC is the best feet if you
need streaming and performance but rest
is very good when it comes to resource
management and it's really simple to use
both solution can handle most common
issues of micro service architecture and
you can even use them together like we
did in this demo and what are we trying
to say here actually one simple thing
there is Mike there is much more
pokemons than big data it is true it is
definitely true and you may have gotten
an impression
the architecture you choose the tule
chose your PC arrest actually defines
your application architecture but that's
not true both tools rest and your PC can
solve the common problems the difference
is the amount on effort and resources
you have to spend to solve a specific
use case so start with your use case
start with your problem sure because
after all you can use it sledgehammer to
crack a nut but a nutcracker might do a
better job and we hope after this talk
you have some idea which not my require
as sledgehammer if you have any
questions we still have females to
answer them and after the talk you can
find us and I'll answer yes and ask more
questions or claim your prizes don't
forget that</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>