<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Writing Groovy AST Transformations: Getting Practical in an hour! by Baruch Sadogursky | Coder Coacher - Coaching Coders</title><meta content="Writing Groovy AST Transformations: Getting Practical in an hour! by Baruch Sadogursky - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Writing Groovy AST Transformations: Getting Practical in an hour! by Baruch Sadogursky</b></h2><h5 class="post__date">2015-11-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/GVfrNwTBpUM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everybody and welcome to the
targeting practical with HD
transformation the title says in an hour
so the best setup for this talk is
actually 90 minutes hour and a half I
did it in 60 minutes it was a little bit
stressful I did it in 45 minutes it was
really fast and we have 30 minutes so
buckle up it will be really fast I'm a
Jeff here a did the talked previously
about metaprogramming groovy he
mentioned compile-time metaprogramming
those are the st transformations let's
talk about that for a second but first
let me introduce myself my name is
Barack I'm a developer advocate with Jay
frog it start up in California Israel in
France him we have two products both of
them I heavily invested in groovy a bin
tray a most of it written in groovy so
that's why I'm talking with you but
groovy today we have quite experienced
with it will I will love it and I am
that's why I'm sharing it with you today
so before we start let's understand why
we need these two terms transformations
and and how it actually started and for
that I will write very simple a groovy a
very simple groovy a class it will be
class person i have this cheat sheet an
agenda all it one so in let's write a
groovy class person it will have it will
have string first name and string
lastname and i will compile it and then
we will see what we actually got in
there in the bytecode mmm it's done
let's open it let's open to class so
here i will open the st talk
and it will be in it's not the correct
one that 1a build classes main org
devoxx person and I will open it in tell
EJ here did happen yes okay so here we
have the compiled code and of course
except of the two fields first name and
last name we will see here that getters
and setters were generated for us and
that that's very nice feature of groovy
and it's actually wore on boilerplate
especially Java boilerplate so it will
generate a lot of code that you would
write yourself otherwise and and and the
question is we have a lot of boilerplate
and it's all it's it's sometime common
like we always need to write Gator and
settles we always need to implement
equals and hashcode and constructors
from parent and to string and this kind
of stuff but sometimes it's very very
limited to something that we try to do
okay not all boilerplate is M is the
same and grew we have this flexible
ability to add more and more boilerplate
fighters in the way of st
transformations and there are a lot
which are building into the language
itself for example to string which
you're probably familiar with so if i'm
going to compile a compile it now and
let's see if it's got refreshed no i
need to do the thing again okay and yeah
and now we can see that two string
method was generated for us all this is
not new of course you probably ain't
know about it and if not you really
should and this is the compile time
metaprogramming that comes with the
language those are the st
transformations and the end
the purpose of this talk is to show you
how you can write your own is the
transformations 25 boilerplate a to
provide additional means of extending
the language extending your aim your
usage of the leg of the language and of
course reducing the amount of code they
need a repeatable code that you need you
need to write so these two string what
it is and how it is written that's
exactly what we are going to talk about
so in st tasty stands for abstract
syntax tree abstract abstract syntax
tree is the representation of the source
code or the bytecode in there has which
is a tree so I am for you to understand
how it works I will start with a very
nice picture in the explanation about
Oxford comma and it's too small all
right so here is the sentence we invited
the strippers coma JFK comma and
stunning and you can understand that we
have three a three entities on the same
level this is the party that we have and
we have all three of them here and now
we remove one comma out of it this one
and our sentence will be without this
coma we invited the strippers JFK and
stunning what happened the tree changed
now we have completely different
structure that looks like that now we
have strippers which are Jeff Kingston
ok so except of waking you up a bit with
a nice picture the idea is to actually
show you how expression a simple
expression a sentence can be transferred
to a tree and it's the same with the
source code and I will show an example
from source code from groovy source code
one of the nice ways to observe these
three is using a groovy console that's a
tool that is built in that is built into
a
the groovy SDK and you can just run it
and you can run your scripts groovy
scripts and then try to execute them or
try to observe the st tree so i'm going
to write here very very simple simple
expression one plus two equals three
let's run it right run it and the result
is a true not surprisingly and now I
want to see the last so we have here
inspect st in the menu and this is the
st three that we can observe so it our
script generated the main method and
here we have the expression statement
and here we go with the run block
statement ok so here we go this is our
expression groovy edit return we don't
care about that and here we have binary
expression 1 plus 2 equals equals 3 it's
binary expression which means that it
has two parts left and right and under
on the right side we have constant which
three on the right side of this tree we
have another binary expression which is
one plus two and it has two leaves as
well constant one and constant too so we
have a tree here right and this is
exactly how it looks in with them you
know with the constraints of swing which
makes it extremely ugly but anyhow this
is a tree you can still see that this is
a three so this is the abstract syntax
tree and what ice-t transformations do
they manipulate these three and this is
exactly what we are going to learn to do
just now so let's go back to my cheat
sheet and see ok so we spoke about
Oxford comma and the st browser ok now
let's actually write an annotation a
transformation and what I want to write
is a transformation that will add a
field to any class inside
our code em and when I mentioned any
here is the time to explain about two
different kinds of SD transformations we
have global transformations and local
transformations global are global so
when I'm talking about changing all the
code i will use global transformations
local transformations are executed on
some part of code which is usually
marked with the classic metadata for
marking code and this is of course
annotations so in the two string
annotation that I showed you is a local
transformation because it only adds to
string on a class which is annotated
with to string a notation so we will
start with a global one and in spirit of
a test driven development we will start
with the test so I'm cure we will write
a groovy class which will be our SD
transformation test em there is a small
challenge in testing against the
transformations because for example in
IntelliJ they are part of your code so
for writing code that for testing called
them manipulates some code you cannot do
it in the same code base for example in
with Bill tools with Gradle of course
but everything is maven you have two
different phases you compile the main
code and then you compile the tests so
by the time you compile the test that
tests your st transformations the
transformations code itself is already
been compiled there it was the case in
ideas in IntelliJ IDEA I have the
sources and the tests which are compiled
together so I will do something else
instead I will evaluate a test code in
runtime that means after the code being
compiled and esta transformations are
already so okay so i have this test
class and i'm going to write a test void
m ever every class should have
alpha field that's my test and what it
will do is it's going to run a script
and a cert whether it was successful or
failure and the script will be groovy
script it will be very easy we have a
class and then we expect author to be
there and I would say that well why
cannot run it because i have now
probably confine can write
run where's my run tests kill all right
so I ran the test and it fails it fails
because missing property exception there
is no property author in this class so
now we will will actually make it work
and for that we will write a class is
the transformation is a class and it
will be author error st transformation
will write the st transformations in
java for a number of reasons first of
all if you don't write groovy every day
it will be easier for you to see java
code now and also in of course for the
sake of the performance think about it
especially global is the transformations
they run for every class that you have
they should be really really fast we can
make groove with a run fast as fast as
Java we're going to talk about it but
for now we are going to write s
transformations in Java so I will create
a Java class also address the
transformation ok so I have all the
imports and after either is the
transformation extends abstract st
transformation and also have a notation
that actually tells the world that it is
and groovy st transformation it contains
the reference in which phase it should
run and you can see here there are seven
phases during the compilation of groovy
code and i definitely not going to get
into a witch which they are the
important part is that there are three
phases which are particularly suitable
for running distant transformations the
conversion semantic analysis and
canonicalization they are not too early
for the construct that you need to
operate our already created but they are
not too late in order to change to be in
time to change your transformations so
those three are actually good choice and
here we will run it in the conversion
state m visit method suggests that we
are talking about visitor design pattern
and compiler the SD compare groovy
compiler it implements visitor it just
goes traverse through this st3 and
that's fine and we have two elements
that are passed into our transformation
nodes and source nodes are talking about
particular nodes which were annotated
with annotations for local
transformations and source is the whole
source code and that's exactly what we
need for the global transformation so we
will use we will use the source and we
are going to iterate through all the
classes in our source and for every
class in it we are going to add field so
we're going to add field which is named
author and each public static final and
of type string and it's actually a
constant with string in it that's
actually all now let's try to run the
test again and it still fails with the
same exception why because we have this
class which is very very nice but we
didn't register it in any way with the
compiler itself so groovy actually have
no idea that this class exists so
registering groovy st transformation is
down through resource for services
locators and groovy expects st
transformation classes to be present in
side-netting services we are going to
put it there and inside this class we
need to put the fully qualified name of
our transformation so that's what we are
going to do and that's actually all now
let's try to run it and voila we have a
new field inside a class which are never
there which is quite impressive I would
say so now we have like we need to go to
the Q&amp;amp;A right now something but we have
ninety percent of the talk ahead of us
okay and now we will run another one
which will be a local transformation and
the log
transformation are different because we
need to create in a an annotation for it
so we will start with a notation again
plain old java annotation so here we
have main java and we are going to
create a messenger annotation m ok so
what i will try to do now is having a
notation on a class for every class that
is annotated with the messenger a
notation it will be a method edit
automatically method message and this
annotation will have a parameter which
will which will just write in second so
first let's start with the retention as
you might imagine we only need this
annotation in the source because while
by the time the compiler done with it
it's already done what it should done
and we don't need anymore so M source is
good and the target will be a type
because as I mentioned we will mark
classes with this messenger and here I
want to have a property which will be a
boolean shout and shout will of course
issue the message in cups and without
the shout will have the message just
printed normally ok so that's our debts
are a annotation now we can run tests we
can write test that uses this annotation
so we have another test and it will be
every class with messenger should have
messaged method ok and
test message here we go okay so here we
have a part when I still the standard
system out to be able to assert on it
that's not interesting and here we have
we have a class quite full shout false
and then I can use the method message to
issue a hello world and expect it to
print hello or lowercase and then I have
loud fool which also have messenger and
have child set to 2 and here I expect
the same hello world message to be
printed in cups so let's run the test
and verify that it actually fails it is
no signature of method quite full
message is applicable and suggest me to
run this case for some reason and now we
are going to add the annotation that
will do it so here we have here we have
message a drastic transformation that's
the one again we will stick with Java it
will be the Java class okay so that's
the same class now I use another compile
phase it will be semantic analysis for
this matter and here I'm going to use
the nodes this time because now I only
care about classes which we are
annotated with this annotation so I take
the node of the tree which presents the
annotation itself because I will need
this property out of it and then I i
take the member of this annotation which
is the shout the property and i will
then evaluate whether it's true or false
and of course I need the class that this
annotation was put on because I need to
add the memorator
okay and now i need the call to
uppercase so that that will be the
message will be the variable that i'm
going to extract from the mm from the
arguments of the method and to uppercase
call it's actually a method call
expression it calls a method the method
will be on the message the message is
string it has to uppercase a method and
it doesn't take any arguments so this is
actually message dot to uppercase and
whether i use it or not we will know by
evaluating the shout so now this is the
code that's going to be injected in the
method so here i have expression
statement that's in one liner method and
it will be a method call expression we
will call print land on this object and
that's a groovy way to do
system.out.println right we have print
line added to any object so these dot
println and then what we are going to
print we're going to use the ternary
expression there with the with the
question mark and the semicolon and we
will ask boolean expression whether
shout is true or false the shout is the
variable from the annotation and if it
is true then we need to call to
uppercase call otherwise and print the
results of course otherwise we will just
print message so this is our code and
now we need to add this code to a method
so here we go message admitted annotated
class that's the class that we used add
method now we add method named message
it's public void it has the parameter of
string that is called message that will
be the same parameter that later I will
print and it doesn't draw any exceptions
and the
content of this method is the code that
we just generated here so that that will
be the that will be the transformation
now let's run the test and it's still
faith it still fails for the same reason
we didn't register it so now let's go
and register it local transformations
are registered in the level of their
notation that we that they used so all
we need to do is going back to our
messenger annotation and add another
metal notation here which is groovy st
transformation class we refer here to
the class that we just wrote message
either st transformation dot class and
that should be enough now i can run it
again and hopefully it will be
successful right so now we actually
added this method to the class that we
used here ok and now this is a hell of a
ste this is not trivial transformation
it's still I would say ten percent of
the production code of your production
transformation but it starts became a
complicated and interesting and here is
another local transformation that i want
to show you and it will be adding main
method so what i want to do is have
another annotation or dev access the
main to be java class and it will be
annotation and this time it will be
still for sources but only on methods a
target target on method what i want to
do now is mark a method in class with
main and generate and make this
transformation generate a main method
for a public static void main so now I
have this main and I can run my
a and i can write my test so i will it
will be test void method class with
method with main should have public
static void main and of course it should
run it ok so here i have this class fool
it has a method greet it has main and
then I run food at main with args way
and expect it to work and of course it
won't work the whoop now we can run the
metal adder st transformation yet the
main we're in the right back in the
wrong package oh well i put it in two
packages okay so it should go here ok
and now let's write another one we are
now it fails no method no signature
method which is a good trailer that's
exactly what we want ok still same code
exactly we will use canonicalization
just for me to be able to pronounce it
well and here we have the annotated
method in the declared class we don't
need the annotation itself because it's
only marker there is nothing a
interested in it and here we have an
empty array we will need it for the m4
for our a string array of main and the
constructor call because we will need to
create an object now right the main will
be static and we need to generate an
object in order to write the method in
now we can actually a see the code that
we are going to add again one-liner
method our main will be one liner we
will create a new object and then run
the annotated method on it with no
arguments okay so what we are actually
going to do is adding call to greet like
new fool dot grid and then it will of
course run that's what we are trying to
do and now let's add the method itself
here we go add method the name main its
public its static its void it accepts
array of strings and doesn't roll in
exceptions and that's the code that we
are going to add to it and now we
already know that we need to register it
so we add here groove is the
transformation class classes may neither
st transformation dot class right now
let's see if that works oh mein ido
there someone in the wrong place again
main address the transformation plus
that's the good one okay that's cool now
that's even simpler the one before so
why bother to a to show you my question
is how do you feel about it is it is it
good enough the main other is it
something that we can actually work with
do you see any problems in it there are
actually tons of problems in it yes just
shout we don't have time exactly we can
annotate to mesogens Clint same plus we
can actually have already have a metal
main method we can annotate a method
which health parameters and I just run a
method without parameters this
annotation is shitty this transformation
right because there are so many things
can go wrong here and we didn't prevent
any of those so I don't have any time
now so instead of writing the test that
will fail if you if we try to generate
second main method I will just show you
how to prevent it and all we need to do
actually here is start running the
protective code so here we go a little
check if the class already has main
method with em array of strings as
parameter then add error right and
that's one of the most extraordinary
things about writing is the
transformations you can throw compile
errors with your messages that's like
super cool right so now I'll write a
test for it because it's cool it will be
a test two means
and here we go I just have main method
and I had another one boom that's not
the one no that's not want exception
that not one okay I don't have time
time's up okay so as you see as you so
it's doable but it's hard because you
need to really understand all those
mechanics of how the three works and
before I leave I just want to show you
very neat tool created by these guys
Sergey Egorov you can find him on
twitter and github and find this tool on
his give account that can actually not
only show you the three browser that i
showed you earlier in the groovy console
but also generate the st code that you
can just take and use so all those guys
are actually something that you can
throw inside your transformation and
then you will not have to figure out all
you know all this stuff which you'll
probably won't be able to figure out
without copy pasting from other examples
or learning about it so that's a very
nice tool to do that as well um well
that will be all for a for half an hour
thank you very much i hope that sparked
your interest and just you know try to
do it it's fun thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>