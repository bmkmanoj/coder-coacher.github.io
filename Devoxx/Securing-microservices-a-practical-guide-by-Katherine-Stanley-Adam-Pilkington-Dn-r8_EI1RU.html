<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Securing microservices: a practical guide by Katherine Stanley &amp; Adam Pilkington | Coder Coacher - Coaching Coders</title><meta content="Securing microservices: a practical guide by Katherine Stanley &amp; Adam Pilkington - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Securing microservices: a practical guide by Katherine Stanley &amp; Adam Pilkington</b></h2><h5 class="post__date">2017-05-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Dn-r8_EI1RU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">very good make it do it make sure
so I'll start talking while people kind
of still funnel in so welcome to our
talk on securing microservices a
practical guide thank you so much for
coming it's great to see so many people
here especially because I know that
there's a lot of other really good talks
on as well at this time so thanks so
much for coming I'm Kate Stanley and
this is Adam Pilkington and our topic
today is securing microservices yeah hi
everybody
adam Pilkington myself and Kate both
work down at the IBM labs early just
like Winchester and we've been lucky
enough to both work on Webster Liberty
and something called game on which is an
open-source project that's going to form
the sort of core part of our experiences
that we want to share with you today
about the practical aspects of securing
Micra services I mean one of the things
we found when we started doing sort of
our first forays into microcircuit a
couple of years ago was that there was a
fair amount of sort of theoretical
talking and articles about the security
side of the bug services possibly a
simple hello world micro service at the
end but there wasn't any real practical
actually this is what the code looks
like me as a developer this is what
you're going to have to deal with this
what you have to do I'm not security
person case not security person but we
now have to do security the idea here is
we can actually share with you what
we've done in terms of this very
practical or intensive develop developer
aspect of security so first off I'm just
going to do a little level set on what
are micro services I mean a quick shower
hands in the room who knows what mic
services are yeah well good good shower
hands okay right who's using micro
services lots people talk about micro
services it's like the joke is
everyone's talking about talking about
micro services but yeah cell phone
number in there but some happened so
what we're going to do is do it just in
a level set on what we mean by micro
service and particularly how it's
changed the security landscape somewhat
for a developer so having a nice little
picture so what we've got it with like
services
you know we typically the word micro
implies a small
seeing so what will you mean by
micro-services something that's small in
scope it's going to do one function it's
going to do one function whether it's a
shopping cart or ratings app it's my
list management service it's something
that's that small scoped but nonetheless
this moment anyone who's actually tried
to you know deploy a e applicational
into the cloud for example we know is
awful a lot of scaffolding that goes
around one class would say three or four
rest endpoints in there so it's small in
scope but none less in terms of a
footprint on disk and but they are
independently deployed okay I mean one
of the things about people what we want
to go to Microsoft is is because they're
having problems with either the time it
takes it or the monolithic apps they
want to use technologies that aren't
available in their chosen language so
they want to be added deploy these
microcircuit separately and
independently and you know in the data
the model s if you're trying to pull it
up and it takes three or four days to
the employer or even months or weeks to
go through a cycle you go to Mike
receivers you can spin up these things
and redeploy them with continuous
integration and builds as well they are
replaceable as well so they tend to be
scalable they are they are stateless in
some ways and another so normally they
need some data to work but what happens
is is they are written to be stateless
and they have config injectable they're
going to get their states on back-end
service but they're replaceable you
scale them up in numbers if one gets
sick you get rid of it they are sort of
interchangeable units of work and
finally they are deployed enormous
processes so they've built around a
process boundary so you typically the
model and the model we've gone for in
game on is we have one app server that's
running one service that's a
independently deployable service the
other thing is that they're now you know
these web services are communicating
across language agnostic api's so we
have typically you know a favorite
combination of breasticles using JSON
parsing over HTTP it's one of things
it's enable microcircuits take office
now you don't have to have a specific
library specific language go do
something
language agnostic api's let your create
Microsystems really easy and get them
all communicating with each other those
synchronous calls with rest we have a
version of synchronous course with
WebSockets so long
running conversations and you can have
pub/sub events as well as asynchronous
communication and we use all of those
inside game on as well I will show you
how where they fit in later on okay I
mean another thing that's changing so
much services have come up and they've
changed the landscape but so another
quick question for the audience who
remembers j2ee the old Java oh I'm in
great company I thought I was going to
be seeing you guys Katie left to Google
that later on what Joe - he is okay so
yes 15 years ago I wasn't working IBM I
was in the financial services company I
was a Java architect on my son certified
I'll take them to another one that a
real person actually marked rather than
just cramming for the test just a a B
and you know multiple-choice hundred
pounds like to thank you very much so as
part of that there was very much this
sort of you know this model was in
fashion then you know you have
middleware you know a middleware bundle
and you have you developed your
application and even in the framework at
that point one of the things I remember
them sort of saying was okay you've got
this you you're a developer you just
look at your development things you read
well when you finished you hand out to
the Ops guys and they deploy it for you
and the Ops guys are normally some sort
of strange people over the side
networking stuff and other things and I
wrote my servlet and I just checked the
you know I said you know check this
users in this role or whatever and it
was more job done and literally it was
throw it over the wall to the ops guy it
pick it up go what and you try and make
some sense of it wires of databases
whatever but you know it's almost sort
of baked in at that point that there was
this sort of split microservices bring
devops back together no you have a
DevOps development and operations side
anymore
you are DevOps you own the service it's
your service so you you are doing the
whole cycle at which point is also now
is that you're having to handle the
security aspects you know you no longer
was it I could just throw it over the
wall let someone else wire it into my
back-end LDAP server or something else
you know have to deal with the security
aspects of it which is a bit different
so this breakdown from traditional and
sort of monolithic Moodle applications
into like service one there's now forced
to
to become more exposed to security they
have done in the past the other thing is
that as we move over there we also bring
in the cloud as well so in that diagram
but as we move some of these marks
services and we move them off Prem
suddenly you know we don't have the
luxury of a central authentication
system anymore you know other people
want to communicate it with us in other
ways so the cloud has changed the way we
also think about security okay so I'm
not going to give a bit of an
introduction to game on we mentioned at
the beginning that we've been building
this microsomes application cool game on
and that that was the thing we were
looking to secure so we're going to use
that throughout the presentation to kind
of give you kind of real examples so
first I'll introduce you to what it is
so it's a text-based adventure game
looks a little bit like this
I myself growing up didn't play
text-based adventure games there a
little bit before my time but hopefully
a lot of you in the audience will be
kind of familiar with them the reason we
built it is because microservices were
starting to kind of become more widely
use people were trying to learn about
them and start making not just sample
Micra services that do them in
production as well and what we found was
that there were plenty of sort of
articles and blog posts and things where
you could go and follow some steps to
build up your first micro service and
stand it up but actually that one micro
service was pretty simple maybe it
doesn't even really count quite as a
microcytic one application running and
when you want to make the leap to then
starting doing more services in
production it's quite a big leap and
there's always other things you suddenly
need to care about rant how do i do
communication how do I do security all
these things that you you know haven't
really thought about before and so what
we wanted was to provide people with a
way to kind of not have to make that
giant leap but to build that everything
they know a bit more gradually so that
was kind of the aim behind creating game
on so as I said it's a text-based
adventure game so we've already stood up
the main sort of infrastructure for the
game and you guys as developers will
come along and write one room to the
gate
and that is your first micro service and
you plug it into our our existing
architecture and build it as part of our
existing microcircuit but then once you
have one room you can start expanding it
in different ways so you could start by
just scaling up to the one room and
looking at what does that mean does that
mean eed to add some sort of persistence
you could look at extending your room by
adding extra micro services that you own
so when someone enters the first room
they then have access to all your other
rooms that you sort of manage there's
various different ways you can go but
the aim was basically that you can come
and write a room and then gradually
expand your micro service knowledge so
that's why we built game on the open
source will put up some links at the end
if you want to come and build rooms and
but for now my you know guinea salami we
turn the mic off and so I'm going to
give a bit of a demo game on and the
reason for doing this is because we want
to show you kind of what waving at the
back what's with him walk do you want to
go over there maybe I'll take mr.
speaker so I'm going to do a demo of
game on the reason for this is because
we want to talk about security so we're
going to show you kind of an example
flow to then be able to talk about how
we secure it so this is game on itself
running and I can just click enter here
and I've got some sort of sign in so
it's already starting to see some
security here I'm going to choose github
and that's taking me through saying I
want to log in with github so not used
to this keyboard so I'm going to log in
you
hopefully those the right password yes
and we're into game on
so I've already logged in before I'm it
would normally ask me for my name and
things like that but it already knows
who I am and this is game on itself
I'm it arrived in the rec room I can say
help and it gives me some information
and I can also move so I can say go
north and currently the information here
on the screen is coming from one of our
and internal services that we stand up
for you have a first room to go into but
if I go north I change into a different
room and this different room then the
content is being served somewhere else I
also have some options at the top I can
go and I can change my player
information so I can update my name I
can update my favorite color because we
decided that when you play game on you
should have your favorite color as part
of your user and then also you can
update any rooms that you've created so
if I go back south to the rec room and
then I say list my rooms Oh apparently
doesn't have to do that well
theoretically I should build a list
whatever rooms I have and and I can then
go and update them as well so it's just
a little show of how it works if I
switch back to the slides so what does
that look like in the game on
architecture so this is our architecture
currently so I'm going to kind of talk
through the flow I just didn't how it
relates to this diagram here so the
static service is serving up all of our
static content for the front end so when
I'm logging in that's the information I
see when I actually do the login we're
talking to the auth service we'll talk
more about that later and then when I do
different actions I'm then communicating
and working with the other services so
the mediator on the end mediates between
myself the user and the rooms that other
people have provided so when I moved
rooms
it was the mediator that was
facilitating that move and the original
room that I landed up in is served by
mediator as well then when I wanted to
update my
players name I interact with the player
service because that deals with all the
player information and then finally if I
want to update the name of a room that
I've registered or change something
about that room then I can interact with
the map service and that you'll notice
is a couple of other boxes there at the
bottom so that some other sort of
services outside of our core
infrastructure that we use as passive
game on okay so when we were you know so
we've shown you how we were building
game on and we're letting you come in
and register rooms and we want players
to come in and we want to we have some
fundamental questions that you want to
know particularly you're sending up a
public service like game on where we've
let other people from outside our
organization join into our
infrastructure we want to know sort of
who are you so you know we saw the
social silent would cover that in a
minute we're gonna know do I trust you
okay so it's okay I know who you are but
don't trust the information you're
giving me you know your trusted party
and have you changed anything along the
route so like three fundamental
questions that sort of you know you sat
there you have a rest endpoint and you
have a set of questions as you know who
are you okay I know who you are now but
I trust you you in my circle trust and
happened you know importantly have you
changed anything I mean some of these
Microsoft's interactions you know go
through three or four Mike services down
the way you know you don't have a user
in front anymore
you have services talking to each other
and it's important to know whether for
example was coming down forget game on
but I mean if you think of a banking
system for example and you have a debit
amount or a credit amount going through
series monk services you don't want
someone changing that from 10 pounds or
100 pounds halfway through and then just
passing that along going yeah that's
fine and you end up with 100 pounds
coming out of your accounts for the 10
pounds so there are various issues about
not just who you are now but there's the
service interactions and say data
integrity questions let's look at who
are you first so we've you know we've
done this with our social sign-on I mean
traditionally in the enterprise man
backed up monolith you had a central
enterprise server and you know that
would manage your usernames your role
with what groups you
in but when you come to game on and when
you come to letting out people in we're
the choice we could sit there and manage
our own usernames and passwords and the
revocation of that but you guys people
coming into our system don't want to
have to create yet another username yes
another password so we were implemented
the social sign-on factors now lots of
these have libraries they're a lot
better now than they were when we
started doing this several years ago and
the code in there actually go through
and lets you authenticate through one of
the social Cylons
now what they do is they all work in
approximately the same way and one
things we found is we had to go through
and work out a few nuances in this flows
we're going through so now you can get a
library or you can have a service or
whatever does a lot of this for you but
as developers we've also wanted to know
what went on under the covers you know
it's great you know using a library but
actually what happens under the cover so
prior to any of this happening prior to
even offering you some form of login and
what we need to do is we have to go and
register with Google or Facebook or
Twitter or github and they and they give
you as part of that registration process
a some pieces of information typically
one is a public bit that you can share
with other people and another piece of
private piece that you keep to yourself
I think public private key
although not necessarily an actual
public private key depends on the
organization okay so that's happened
some time in the past you come along and
you authentication so what happens is if
the client comes in and makes that
request to access the page Muse into the
login so you redirect them for
authorization and what you do is part of
that is you give them that public part
that you've got from will stick with
Google for a minute or so so gleam or
them the Google gave us when we register
for our camp we pass that back look to
the client and a redirection off to the
Google server that says please go and
login over there and take this piece of
information that identifies game on
which is why it's a game on is asking
for your information because the book
client browser redirects to the third
party site it looks up the public thing
that was passed in knows it's game on
text puts it up there and says okay
here's the roles that game one is asking
for sign-in you know grant the roles he
login
redirects you back router back and then
that redirects you back into game on
okay so far so good
and as part of that we have we have an
opaque blob come back so it transfers
back from the third party by the browser
and back up to game on again so it's all
bouncing around over systems and we'll
come over to where some of these you go
watches of course it is going by the
public and anything go to the client
should not be trusted okay you know the
general rule anything that goes to the
client and you receive back come trust
itself but in this case we have a blob
come back we take that blob we then give
it back to Google along with our private
part of the information they gave us
with the registration they decode it and
they give that information back to us
and say yes this is this person and this
user and these are the roles that
they've allowed you to have access to so
that's how this flow works and it's a V
and then what we do is we don't create a
JSON web token which we'll come on to
more details about how we use the JSON
web tokens with their information and
then we manipulate that and we pass that
around the system so they say one of the
key things we get asked about is isn't
that is that secure and say it is secure
because we are allowed to give out that
public part that doesn't matter that
just identified us to Google the
information that comes back the client
can't read because we need to provide
the private part of it back up to Google
on the back end so you see how the whole
system hangs together so that we can
actually offer a skill sign on with game
on people we never see your username
your password but we know who you are
and use people can log in with your
favorite account and you don't have to
remember 600 different usernames and
passwords to get into different systems
so just to reminder this is our back-end
system that's going on that Kate
explained a minute ago system and this
is all happening in your service here so
originally was all bound up in in one
and I think we had one provider and then
we realized quickly we need to provide
more logins more ways so we split that
out into its own Micra service yeah it
became big enough yet scoped well enough
that we so this was north service now as
I said we did this because one you know
this is an opportunity what you go to
Twitter you get their client library or
you go to Google you get the car ivory
and I can show the github
a repository where those are but you
still have to do some work at that point
and that's if you do it manually now
there are services I mean we work for
IBM so inside a bluemix there's a PI D
service and that will handle the
authentication for you and basically
give your service assigned JWT but I
mean that's that's by the way they are
just doing the same here it's just that
it saves everyone else having to do the
same authentication so it's almost like
the next level of abstraction up which
is okay I've taken out and I now have an
all replaceable
remember we said these services are
replaceable I can now replace one or
service the one we wrote with one
provided by our favorite cloud platform
provider so the next thing we're going
to talk about is JSON web tokens and
just going to kind of introduce you to
insert and then sort of explain why we
need to use them so they used to carry a
representation of some information as
you might guess from the name the
information is in a sort of JSON format
and they contain certain claims about
the request so things like an issuer
subject and expiration time that sort of
thing and the reason we use them is
because now that we've gone and got our
also token and we understand something
about the user you know we've got a
token the represents what we think
they're allowed to do in our system we
need some way to pass that around and we
use JSON web tokens to do that so
adjacent web token will help us to make
sure that the request was in issue it
initiated from a specific user request
and then also know the identity of that
user and what they're actually allowed
to do there are three time related
fields that you can then include in your
JSON web token and these are things that
you should be verifying as you pass your
JSON web token around the first one is
IAT so time that it was created they're
not processed before time so when you
should not process it for and then the
expiration time and you should be
validating each of these depending on
what they are so time jason web token
was created make sure that before the
time you receive
request expiration time should be after
not processed before should be in the
past so those are the kind of three time
related fields that you should be
verifying because then when you pass
your token around then there's some
understanding of yeah we think this
looks like a valid request the other
thing to notice about the expiration
time is that could be useful for
checking if you've seen this request
before if you have your expiration going
to be reasonably short then there's a
reduced chance of replays happening so
we've now got a way to pass our
information around and we can say okay
next service here's the user and this is
what they can do but there's still a
risk there because we're passing
information over a request
it could be tampered with as it goes
through and that's where Jason Webb
signature comes in so you take your JSON
web token that you created from your off
token that you got from orphan Minister
go and you sign it and there are two
ways that you can do this you can use a
shared secret so that's symmetric
signing or you can use a public/private
key pair so asymmetric with a shared
secret the idea is that you share the
secret that you're signing so you need
to be careful who you're going to give
that secret to if you give it to just
anyone then that means just anyone can
create new requests that your system
will view to be valid requests so
there's a risk factor there of who you
give that shared secret to with a
public/private key pair you give the
public pass away and you keep the
private part to yourself if you give
away the private part then again people
can create requests that you would then
validate as being absolutely fine and
there's a risk factor there
so with public private key you can give
away the public key but you want to keep
the private key to yourself and you'll
then be using the private key to
validate your request when it comes back
in so that's a bit of information about
what they are more generally but how are
we using them for game on so as we said
in our flow earlier we've logged the
user in and now the user wants to make
some sort of
request so that's where the JSON web
token comes in because it carries a
representation of that person and we
need that to be able to work out if they
can make the request that they want to
make so for example if I'm a player in
game on I can't make a request to update
atom user information I can only update
my only user information so we're using
the OAuth access token that we got from
your social sign-on to create the sign
JWT and then we're signing it with the
game on txt org certificate the reason
we chose to use our ssl certificate is
because makes it easier from our point
of view we already have a well known
public key and we don't have to setup a
new public/private key pair and manage
in that way we can just use the one that
we have so we sign it with the key and
then we pass that around so that's what
we're using whenever we've got
interactions between different services
within game on because they can validate
with their private key that each of the
services gets injected and to make sure
that they trust that the JWT has come
over hasn't been tampered with and has
come from someone that we kind of trust
so we've got some code here example as I
mentioned earlier game on is open source
you can find it on github this is a
slightly shrink down version of the code
just so that it would all fit on one
slide
but if you want to go and look at it in
more depth then feel free we'll put up
the links all at the end so the things I
just want to call out here is you can
see we're setting some claims here at
the top so things like the subject the
audience when it was issued the
expiration and then also we're then
signing it and we're signing it with the
private key so then when you validate
the JWT you then validate against the
public key now the other thing to note
here is actually we're using a library
here using the Java jwp library if you
want to link to that sense against you
can come up the end of our I'll give you
a link but it's useful to use libraries
wherever possible because if you use a
well-known library then there's a better
chance that more
people will have used it and it's kind
of easier to just rather than trying to
kind of roll your own especially if
you're fairly new to security so that's
how we're using gwt's in game ah at the
moment it's the service to service calls
so that we know if a particular user can
make the request that they can make and
that the information about that user
hasn't changed in transit okay so before
I go into has anything changed I mean
just to carry on with the GWT do I get
back to my flow here I mean one of the
things about passing this sign JWT and
now that we know that this means that we
we know who that user is and because we
sign with their data in the JWT we know
hasn't been changed we can give that to
the client which allows long you know
interactive sessions for someone to come
in to game on in one room and then go
away come back two hours later they can
represent the same JWT to us and we know
because we can validate the signature so
they haven't changed anything so we let
those things live for about a day before
we expire them but it means that in sort
of long-running process or particular
where you're going to have users come go
you don't have to get them to real
syndicator every time you can give them
an authentic ation period at that point
and you can be confident that they
haven't changed anything because you can
validate that none of the jacent has
changed now interestingly we found as a
little tip that when we also
particularly we're interacting with
github as far that as part of the actual
logging on and requesting permissions a
lolis libraries allow you pass a bucket
of stuff so we call it it's not only a
tag field or something else on the end
which is sort of stuff and you can pass
that up to github and github as part of
its authentication will basically pass
that information back to you when we do
that decoding on the backend now the
thing is you have still have the same
trust issues at that point is that okay
I know it's github but I really
shouldn't trust that perhaps you know
whatever comes back round again is what
actually sent out to the client in the
first place so technique we found was to
actually put a sign JWT as in that
bucket you can then send that up and
because in the async world it comes back
on completely different thread that's
absolutely fine because we know we
signed that data
github didn't change it
we can action it so though we can't put
anything in there that shouldn't be
shown out to the client it does mean
that we can interact asynchronously
across multiple threads and multiple
services being sure that what we got
back is what we sent and this allows us
to say things like them so for another
thing we do which is a code accelerator
could app accelerator you can
automatically have the code pushed into
github for you those permissions and
that has to be handled in that a scene
because the callback we get is on a
completely different thread somewhere
else I had no idea what data and what
what user was logged in but because we
received back the sign JWT we can we can
trust that we trust ourselves and we can
carry on doing it so there are some
interesting things you can do with JW
tees beyond sort of you know you just
using that it's an easily possible data
format but you could you know as long as
you don't my sharing the data so really
useful be able to say has that changed
in getting back a later point in time
so again the app the app accelerates
stuff is another microfarad spacing so
you had this this same issue doesn't
matter what innocence processes you can
validate it so I mean these jadibooti so
they are they allow us to establish you
know who you are and you know want to
know who you are we have covered an
aspect of that has anything changed with
the signature but there is another way
of doing it which is this a message
authentication code or hash message in H
Mac and this is more we're remembering
the the architects diagram we have
services communicating with other
services that's not it that's not who
you are anymore that's this service
that's the mediator service talking to
the room service the who part isn't
isn't a person anymore it's a service
and you want to be sure that you know
that they haven't that you trust that
person so you have to you want to make
sure with this H Mac that you
authenticate the service and again that
the contents haven't changed the flows
come through so how's that how to do it
so in game on the service operations is
a shared secret and that enables to
establish trust because we share a
secret it's a bit sort of sometimes it's
a bit hard to understand but yeah I
trust you because you know peace
information that I share with you that's
how I trust you as a
servus so when you apply it to the hvac
and you and you encode with it then an
ID code it we share the secret then of
course you have the problem of the
secret anyone else we find out that
secret can become a trusted service but
it does allow you to establish a service
to service identity now the other thing
about when you do H Maxo HVAC is
normally a sort of quite a convoluted
process you can make it complicated you
want but if you look in the game on
documentation what we do is we do things
like we take the creation date field of
the HTTP header we do things like cache
the body and so we end up with a hash we
hash the query string parameters we hash
your game on ID and we put all those
together into the H Mac and that base it
and put together with the shared secret
and you end up with basically and then
basics for encode that you end up with a
string okay and you can and then we put
that in an HTTP header we send out to
the thing we're connecting to basically
the thing about and this casing with
shared libraries are you know well the
reason you want to use them is that you
don't have to reverse that process to
unpack it all and to establish that
nothing has changed because basically
you don't trust what you're given you
repeat the process at the other end to
make sure you get the same answers as
you've been given that's what you've
been given remember that as a rule we
never trust what we were given we go
through and replay so I have to sit
there and rehash the body the other
thing else and the problem is if you
have two people doing that then the
problem is is that it's very easy to
make a mistake in that hashing and then
you start rejecting things falsely false
rejections
so what we did in game on and we've
created so we've extracted our own
library because I you know we wanted to
make sure that people could successfully
register rooms we expected their own
library and it's now a shared library
that we then inject into other
microcircuits and we follow a good 12
factor application coding it is its own
code base and we use a something called
jetpack then one heard of jetpack when
using git pack no sorry okay and cute
pack is really good so get packed io io
lets you point it lets you point
a github repository and you can declare
a dependency in your maven or Gradle
file and it will resolve that dependency
through jetpack with whatever the
releases they wants to pull from github
so it makes anything so even if no one
has released a jar into maven central
you can use jetpack to point that their
github repository at a release in there
and then write it a dependency in your
build file so we can just put all of our
shared signing code into this one
repository we then put a dependency in
the build file that says result from the
jetpack repository our name and version
and both click run to get package it
back post to the code and injects it in
with all the dependencies we need as
well and manages all that for you
there's a really good way of actually
sharing those sorts of cross-cutting
concerned libraries like where security
is one of them the other thing about H
max is compared to JW T's they're
they're very small
okay giggle T is Jason H max comes out
with you know whatever is 128-bit string
that's bits that's converted into a
representable string what that means is
them because it's passed in HTTP headers
you can actually action it before you
even get to processing the body so the
Jason one you'd have to go through your
doctor piloted jason do the scene to the
h map we can validate it in the header
now that lets you do some clever things
with WebSocket handshakes for example so
far the WebSocket handshake between our
mediator in the room we H Mac that and
when we call the room so what the room
can do is it can pair the shared secret
and do the HMA processing and then if at
any point it fails it can reject the
WebSocket handshake level so you don't
even get a connection mate
so allows you to action and route based
on header information rather than
actually taking a body and parsing JWT
now of course yet you could cram a JWT
into a header it becomes much simpler to
do it with just H macking by the header
so there are sort of different things
it's a slightly more complicated but has
better uses in terms of faster fitting
at a faster processing
okay so sort of would talk about a bit
about development versus production
because I mean that's always something
that's tricky with security is that we
want parity between your development and
production environment but that's hard
the hard to achieve because it's
security you know a lot of things should
only be known to the production
environment and so how do we actually
let you develop locally I mean one of
the really good things about game on and
we took great pains to be able to
achieve and we'd like to share some of
that pain with you right now
is how actually you can stand the whole
thing up locally all that infrastructure
you saw including even the Casca and the
couch DB if you clone out a target
reporter free and run some shell tips
you will end up with whatever it is ten
eleven docker containers or running the
services and the whole thing runs
completely locally so in order to do
that we had to address a couple of
issues and one of things we saw was that
a bit about accessing third-party
services so okay we ended up with having
you know we went to Google we got our
development key but now how do we
actually get that you know into the
system so in production system that's
actually injected as part of the build
pipeline and we use a service called
Etsy D which is a name value key store
service and that lets us get together
and sort of basically if any of you seen
in the build pipeline you go through and
you define your environment variables
and we actually instead of filling out
each one we just have them filled in
from a CD but basically the thing is we
inject the real stuff in the bill
pipeline okay the things we can't show
us are things we don't check into the
github repository but it does mean
locally when you run it locally you do
get an anonymous login box turn up into
like game on
so that's how we've done it we hit so
when you're running locally there a
couple it works out it's running locally
and it presents you with anonymous users
who don't actually get the social
sign-on but you still get a JWT signed I
come and I think we dummy up the
back-end provider so we you'll trust it
so everything else flows the JWT is
still signed we don't do anything
differently it's just that you don't
have to go through the social sign-on so
we've gone through and providing it but
it's one thing about when you're looking
at these systems is how you are going to
work out your own
development versus production parity
okay so we're kind of there and so I
think we've kind of hopefully taking you
on a journey of how we created game on
and specifically then secured it so we
talked a little bit about how we do our
social sign-on how we propagate who the
user is but more specifically what the
you can do through the system to make
sure the each micro-service when it
receives request knows if that
particular user can perform the function
that they want and then finally we've
talked about how we understand and trust
that when requests come in to a service
it's a request that's been made by
another service that we trust and that
the information whether that be the
information about the user and the
claims in the JSON web token or more
generally the actual content as a
request the body of the request we make
sure that that hasn't been changed so
these are some points that we kind of
want you to to go away with when you're
moving to Mike receives that means
you're going to have more interactions
and this is the place where security is
something that perhaps you haven't had
to think about quite as much before and
it's definitely a good place to start
when you're looking at how do I secure
my Mike refurbish and it's important
that you understand the interactions
between the different services and look
at what is the risk here for example
when we're doing things with a room and
our services talk to a room they use a H
Mac and we have a shared secret and we
just share that secret between game on
itself and that particular user who has
the room and that way we know only those
two people have the shared secret and if
they want to create more requests
they'll just be doing something with
their room that they already owned so
it's kind of understanding what are the
risks in that particular interaction and
then what can I do to address it so that
comes into the second point which is
understanding the concerns that each
interaction who are you do I trust you
and has anything changed as things to
can passed between the services which is
particularly important when you have a
chain of interactions they might have
gone through several services to get
there
the third one is to centralize using
common services or libraries so we've
talked about two examples here one of
them is our author service so we put
that there to make sure that if we
wanted to change the way we were doing
social sign-on then we just change one
service and it means that all of the
other services are actually they have no
clue how we do our authentication and
they don't need to the other interesting
point which I don't know if we mentioned
but if we wanted to add more front-end
as well they can interact with the or
service we don't have to have different
authentication in the different
front-end they're all bluest to how we
do authentication as well and then of
course the second one with the shared
library which add me talked about the
very last thing is do it early this is
something that I think with security and
I guess with Microsoft is in general
there's so much to learn there's so many
things that you could do first but I
really think that when you're doing
security with micro services you should
be thinking about it right from when you
write that first service because as you
build up your micro service you'll be
talking about what are the interactions
what does this mean here and you may as
well add into that conversation what
does this mean for security should we be
doing something here for security with
game on we did think about it from the
beginning but there's definitely more we
could have done from the beginning and
as Adam said we had to refactor and take
out your service which was actually fine
because we built it in a modular fashion
we didn't have all of the auth code sort
of trickled in to everywhere it was
quite contained then when we decided to
split it it made it easier so even if
you don't start off with a separate
service or a separate library if you
build security in from the beginning and
build in thinking about how your micro
service is going to evolve it will make
your life easier how do you go forward
just before we finish off we show you
where where you can find this stuff on
github so first off with there is a git
book which has all the information
we've gone through on there or certainly
a sort of guides and how to's and how
things on there and if we look down here
there is the section on application
security and it talks about as you know
how we're doing the request to fail in
the open ID authentication the signed
requests so for example you know here
here are the headers we're doing after
documents of people we want people to
come along and they good/bad implement
this you know use our shared library
rules by all means but we do document
fully how we construct it particularly
when it comes to the H Mac so if you
look down here to run through we sort of
initialize it we put in the method the
request your I your game on ID the date
the headers all the other HTTP headers
all the other parameters on the body we
make a hash out of that and then encrypt
up your shared secret the other end you
decrypt it if the decryption works the
shared secrets are good therefore I
trust you and then I can go back and
make sure all the hashes so this stops
you actually changing anything you can
see how easy that is to get it wrong
when you're going through or do it
slightly out of order in a slight
different way or you've got a slightly
different date format or something else
so that's why we quickly standardize on
library but you know how we did it all
is all in here with example so you can
test yourself about what you should get
out in there and how to pass it all the
way back again and particularly also had
the WebSocket handshakes I mean those so
it's interesting you've never got into
the actual depths of the WebSocket
handshake how you can actually influence
it and reject it before even gets
upgraded to a WebSocket connection
itself from an HTTP request so this is
the actual game on github repository so
down there as you can see there's you
know it's actively developing you know
we're still working on this new code is
going in so something we've finished
with yet I mean what services and
everything else is still continue to
involve will continue to work on it we
have the swagger in there we have also
rooms in different languages so for non
Java developers we've got Swift room a
JavaScript node room these people trying
out microservices and you know you'll
find the HMH implementations and the
sign JW stuff in those languages as well
because remember these across language
cross-cutting concerns
just quickly I don't think so here's our
oath one and as you can see here so you
can look in here and see how to do
Facebook github Google Twitter
authentication codes all in there have a
look this is the actual shared library
so you can see how we actually do the
sign requests how we intercept how we do
things like that and one of the cool
things about our shared library is the
annotation based so you can take a
simple jax-rs class add one thing go
that's a signed request well suddenly it
aged Mac certainly now it has to be
secured coming through then changing you
don't want it take the annotation off
you know so there are lots of things in
there about how you know we evolved from
having it you know in a class to then
into a shared library to then annotation
and CDI injection all sorts of other
things on top so we bolt it as we found
that once it actually were to add a do
it we needed to keep doing it in
different places and make it consistent
and finally in the mediator it just I
just pulled out an example of an API key
in here Henry took that API keys they
just more of a sort of a bear a token if
you have a key and you present it we'll
just check it against the list of keys
that we've got so you know it's very
straightforward but we've just let that
out of sort of more complicated things
that you get asked to do rather than did
you give me you notice value in this
field
so think about five minutes left sir are
there any questions
oh we're and they're rolling up Mike
I just finished a guy called Mike who's
gonna Rove and yeah if you can sort of
come up here and try and repeat it in
here and I think we've got a mic coming
down
so if you don't store user names you
can't sign in with multiple services on
the same accounts like I couldn't merge
my Facebook and github couldn't could I
do that so when you think so link them
so I could decide to login from either
one or is each okay so we store just the
one that you log in with to give you the
ID and I suspect at the moment we treat
you except with people when you're
logging in but we are for what we've
done here we just want to validate the
you are who you say you are because
github or Facebook said that's who you
are and you know primarily to I think in
game on to get your email address for
example and like that so you know I'm
not sure whether you how you'd merge up
an identity we just need to know from
from one of our trusted identity
providers and social age one of those
people that you are who you say you are
yeah the key aim was to be able to say
this user can do these actions and so we
haven't linked them so I know I have
rooms are deployed under my github and
under my Google because I forgot which
one I signed in there so I mean we could
go in and we could say okay so if you
sign in and you know bounce you back
through the other one to check that you
are you know who you say on the other
one with at the backend storage then we
could put the two together so you know
whichever one you log in when you do one
go and work on your room and change the
description of register a new room you
could use either one I mean it's that's
almost implementation detail at point
but there's the fun part shall we say is
getting the Twitter thing to work in the
first place
whichever way they've done it because
they're all course slightly different
but the main concept is the same just
are you using any of the stuff inside
IBM for any community was the launch for
for paradigm that you know best
practices paradigm to use in actual
products so all of the core services are
running on Liberty which is our cool
Liberty t-shirts if you want to get one
I think they have some of the IBM stunts
so they're running on Liberty and on
bluemix mostly because as a team that's
what we were doing at the time we were
working on Liberty in
King at how do you do Micra services of
Liberty habitat work so quite a few of
the services like we're using amalgamate
which is that's actually open-source but
was kind of created by people from IBM
so there are quite a few IBM related
things and you'll see in our templates a
lot of them deploy straight to bluemix
IBM bluemix but the aim was really to
help educate people about micro services
we saw need for our customers they
wanted to know how do I get started with
microcircuits and we wanted to give them
a way to learn fast so we're really
encouraging people to come and deploy
them in different ways
when I was at devoxx yes earlier this
year we deployed a wild fly room for
example so we came for people to do them
in all different languages and have
rosetta stone - Destin different clouds
as well but the core services are
running on bluemix currently there any
more questions I think there's one right
the back there so so when you didn't
read the JSON web token what is the
inaudible expiry time so how long is
valid fall and what if the dopant is
compromised and you want to share with
all the services okay so the expectation
time in some respects is up to you there
is a trade-off between you know forcing
someone to real authenticate and
regenerate a new token based on how long
you want to trust that token plus their
answers and don't forget we're now in
the distributed computing environment so
it's not like a just a process call on
the same box anymore it's got to go
across the wet piece of string somewhere
between two servers that may slow it
down so what we did when we did the one
there was we did a five minute we pick
five minutes as a almost arbitrary you
know we weren't getting any one rejected
but if something turned up far too late
then we know we would we wouldn't honor
it so we also had to pick sort of five
minutes because simply because we
distributed computing for example when
we're when we're calling out to a room
that's hosted somewhere that's probably
been hibernated somewhere and has to
come
into life and everything else we need to
you need to balance that sort of you
know now that you're in distribution
environment plus how long it's in
detective to continue ask to regenerate
tokens as a choice and the other thing
to also do in there we sort of briefly
touched on replayer taxes is actually to
store you know the ones you've received
for a certain amount of time that's
linked to that that effective time so if
we pick a five minute window then we're
store all the met all the requests we
receive in that five minutes because
then if we see a duplicate one come
through we won't honor it because some
of these some of these other systems or
other marks services they may have two
instances that are sending things to us
which is the same request so we keep
track of everything we receive and also
means we had a bad experience at one
point one of our things where we managed
to register about a million rooms in the
couch because something to study
replaying room registration requests to
us so we put anything that said okay if
we've seen this request before we won't
do it any time and you tie it to your
you know your time out for your JSON web
token because if you don't on earth
anything after five minutes you don't
need to keep it so they link together in
terms of other things that you do as
part of the security you know I think on
their ticket that I showed the code
snippet it was in comments but you
should always make sure that once you
validated the request if it's not valid
then do something about that and what
that something is is up to you and it's
about looking at what are the risks in
this situation what is going to be the
impact to the user if I have to throw an
exception or something like that we've
got one minute does anybody want to ask
another question
cool well the little screen down here is
just said time's up so that's good
timing so thank you very much for coming
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>