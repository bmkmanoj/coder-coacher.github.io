<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Rust as a support language by Geoffroy Couprie | Coder Coacher - Coaching Coders</title><meta content="Rust as a support language by Geoffroy Couprie - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Rust as a support language by Geoffroy Couprie</b></h2><h5 class="post__date">2016-11-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/e92Yrp3W_2I" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi how are you yeah I'm tired too let me
just lie down this way it's nice
okay so computers being computers so I
will talk about rust for a bit
me I'm Rafa Kuechly I'm Frankie III I
work at clever cloud we are platform
services team company like the thing
where you do get bush and he goes to
production and it runs it does not crash
or if it crash we will start and it
taught of scales and everything and it's
quit come talk to me about it afterwards
all right so first I have small question
for the audience did anyone do see
development at some point in your life
yeah do you still do yeah yeah I guess
so that's the same for me like I was a C
developer at heart and I realized see
because you can a lot of low level stuff
but at some point I was just so
frightened that I will put something in
production it will be exploited and it's
or it will just plane crash or eat the
memory and it was very distressing for
me but there's still good reason to
write C code like speed it's still easy
to write fast code in C you can read
micromanage the memory and it's portable
you can write code for most any platform
available and under CERN but why should
we avoid C like we all we have all seen
that kind of thing in values operating
systems even your phone your watch
everything it crushes the
vulnerabilities like people will just
take over your whole program like it's
it's a pain it's a pain to compile it's
a pain to to write correctly and if you
tried to
- link C code - any other language
you've seen that like FF is a complete
mess
so hi let's do some rest
what's rust rust is the language that
came from Mozilla well they had an issue
they were writing a browser that's
called Firefox I don't know if you heard
about it it's like this huge chunk of
C++ like so huge that they had to build
complete web web app just to browse the
code because if you grab the codes from
Firefox it will take so much time that
you won't get any work done so yet this
web interface when you can click some
part of the code and get to definition
and everything otherwise it's impossible
and that lot of lots of issues and when
Graydon Hall one of the developers said
hey I've been building toying with this
language called rust in my free time
it's memory safe kind of nice nice
features Mozilla started to do spawns
all the stuff and this is a slide it's a
slide that comes up at every Russ talk
in the Rose conferences like we want to
have a chronic way that's fast that's
really about them that's productive it's
not a job that we will have get all free
is we want them if it's not available we
will make sure we get that so how does
it work the idea is you will have like
high level tools but for low level
programming and a compiler that will
like do that we do a lot of work for you
so in the design it's an object language
without classes let's not get into the
debate again there are traits if you
seen that I will show afterwards
everything is immutable by default
because it's a lot easier for the
compiler to just reason about the code
and if you think about it like most of
the time the data you will use will be
immutable no garbage collection it's a
pretty funny part of the language like
at some point
you develop on the language they add the
idea that there would be garbage
correction and once they said okay so
the compiler is not smart enough to
manage the memory so we don't mean
garbage collection we just remove that
from the language and it's gie of the
zero cost abstraction a lot of check
checks are done by a compiler at compile
time but we not result in code at run
time that will do the checks like you
make sure that the allocation and
de-allocation of memory and then he and
they're like you would do in C in C you
do a malloc and you do free in C++ via
new or delete or Auto pointer shared
stuff whatever in rust you let the
compiler take care of that it's smart
enough to know when to allocate all the
aerocut memory but you don't you don't
see a cost of checking everywhere if
pointer is null of everything so in the
way it's written it's quite
straightforward here's a function on
yeah
we have structs I say we have kind of
object like think everything like
strokes unions and everything this is
the basic storage of data we have
announced so this the option type or the
either if you seen that in other
languages like recent Java or Scylla and
we des pattern matching which is like a
central way to write coding rust
basically I almost forgot to put that in
the slides because it got just so basic
for me that I just wait yeah it's it
there I talked about the traits so
instead of having in returns between
classes and objects and stuff you define
some of this kind of interfaces and you
implement them for this product or this
anon and whatever it's here we have just
trade to get the area that returns a
float on 64 bits and like okay we
implement that for a second it's it's
quite straightforward to do that
the syntax can take a bit of time to you
get used to but
basically it's as inspirations from see
from Java from ml from form a lot of
languages nor feeling there are closures
a good thing with closure is like the
most of the time now they are not even
allocated on the hip
those are closure that are generated
statically at compile time so it's just
like calling another function is not
something that will have a runtime cost
and a big feature of the compiler of the
borrow checker this is the thing that
will tell you okay in this part of the
code you do something with the data of
the memory that you should not do and
it's really hard to get in front of that
part of the compiler that we just say
okay this code that you've written in a
lot of other languages that you put in
production
I'm telling you now you made a mistake I
like a lot of time there are people
coming to the roast IRC channel and
saying okay so the compilers say that
this is wrong and I know it's right I
have been running that code and I know
it works in other languages and then
someone just raise their hand say hey
yeah but this is one in a million a case
where when we on time case where it will
just completely burn your computer so
there's been a lot a lot of work a lot
of check are done at compile time to
come with you to help you so it's a
simple one like you have a function
called foo which will take a reference
to a Veck as argument the reference is
the ampersand stuff and push you try to
add something to the back but a it's not
mapped mutable otherwise would have been
anta some note so it's not mutable so
you cannot modify it and a lot of things
like that are there like another one
when you get you get to you try to
modify something while somebody else as
a reference to it like when you have a
mutable reference to some code nobody
else can read it because
you don't know what will happen if
someone reads the code value matter if
modifying it so like millions of check
to to make sure that your code runs
right but at first it's a bit hard to
write code because you not use to think
about this so it's getting there like a
lot of the the checks now the compiler
is getting smarter and is we're able to
infer what you want and will not annoy
you with the references and stuff if it
knows you can make it safer
so it's Rick young yet if you take a lot
of time to get something that's usable
for everybody but it's getting there
so we use roast a clever cloud a lot
like I've been evangelizing using roast
for like two years something then ok
this is a good language I have to
rebuild the compiler once every two
weeks the language is turning all the
time but I have no crush it's fun to use
it's easy to maintain it's easy to
refactor and like we have lots of tools
that are now being rewritten in rust
like I'm not even the first one to build
some rust active a cloud some some
things have been there like for moms now
even the CEO is shipping this this week
project for that and we can put web apps
of platform like five commands you
understand with the tools you create
your application you push it at will
compile and run and it will be there
forever so this is a great language and
we like it maybe you've not seen how I
like that language but whatever why
would you use rust so we've seen that
see is interesting it's low level but it
crushes rust will do the memory work for
you so it will prevent the
vulnerabilities you will have to think
about when you in select in C you have
to think all the time where is the thing
da located I am really calling a pointer
that's
valid is there something behind that
pointer I don't know
you don't know what what Calvin and
there's a nice perk of roses like the
build system it was really cool you
don't have to mess with the auto tools
and stuff we will switch I don't know if
you've tried to do anything we've made
500 tools and a lot to confront whatever
um it's a specific kind of fun ya can
see the pain from if some people are
there so what the thing is it can pass
itself as see like you can take dynamic
library in C or C++ and you can write
one in rust that will appear just the
same like the same function are exported
you can do the same column whatever and
it will be loaded in another program
without any issues one of my big example
is that I made a pass for FLV files so
the flash video and I made a plugin to
pass flash video files for VLC and there
is no C code in that plugin is just you
put there in VLC V&amp;amp;C loads it it passes
the file gets the video it works it's
it's do a morning in Reverse to just
replace some C code it's not necessarily
easy but it's doable you can do some
native extensions for languages like
Python Ruby no that's Karen everything
you can make some webassembly stuff I
still don't know if it's if there's a
good use case but I want to see it use
because it's really fun to like compile
to JavaScript and as we will see in Java
it's the same as for C do you can access
it with genie and GNA so why would we
use a language like rust to write those
native extension because sometimes like
you in Ruby you want to have like fast
code you will write C and you don't want
to spend three months to get used to
rest while you can just do a big big big
mess in C well the difference is in one
thing
it's hard to get right but once it
builds basically it works and if you
will not make as many rows as you see
like if tried to put some C code in
production you will have lots of issues
so so service calendar to replace some
see why would we replace some Java
because like a lot of us are doing some
Java here so it's very portable like you
can build for almost any platform all of
the ones that are supported by LVM
basically it's very low from footprint
does not use much CPU or RAM or whatever
there's no runtime its lexical it's very
easy to write clever low-level code like
in embed a zombie stuff you can write an
operating system in rust a lot of people
have done it and like as I said no
cabbage correction so maybe it's not
enough to convince you but like I have a
Verizon's to don't to not do some travel
and prefer to do some C so we have good
lambdas the adoption types where right
from the start
two powers in arms inside integers like
yeah and whatever you so no I don't want
to start flame war but like different
languages different needs
I like roast so now let's do something
what I want to show you now is something
that I extracted from a client project
we had an iOS app and an Android app
that should communicate with some kind
of crypto protocol and maybe communicate
with the server side as well basically
the IDE built two different
implementations in Objective C and Java
and maybe one in Python and all of them
have different bugs and whenever you
have liked the small smallest mistake in
crypto code then it will be complete
garbage everywhere you cannot see what
happens so the idea was okay let's make
one library for everything that will be
current with itself and we will use that
and make bindings for all the platform
and I said wait we won't
that is see like it's 2016 like we can
now do something in rows it's it's good
so is it doable to do that to write code
for all of those platforms where I don't
know if you remember that model from
Java a few years back where rows you
will build once you build for all of the
platform it will take some time like I
spent hours building for all of the CPUs
for iOS it's it's complete mess but yeah
we can do that so I cannot show you the
code for the code protocol stuff but I
have another example like I got so we'll
build an inverted index and inverted
index is a small data structure that's
used in search engines basically it's
very naive algorithm the idea is that
you will take a whole bunch of text and
see which word appears in which text and
you wouldn't you when you get four you
can get forward okay it's in this takes
this one this one this one on this one
inverted index yep the algorithm is very
simple you take the ID of the text and
you get a shmup of world what set of IDs
and then you just have to get the set
for one word so yeah with this small
phrase it's really easy to do and the
just small thing you have to make sure
that you normalize the words like if
there's some punctuation if there are
some uppercase letters or whatever it's
where a lot of the issues are like I
don't know there's what that's floral
but you want to only store the singular
one it's where you have to do a lot of
intelligent walk but let's do something
very naive for now because like I don't
have much time
yeah a small thing like if you want to
search for a few words you search for
one word and then the other and you get
the intersection of both it's very very
naive come as algorithm but whatever it
it's a
test scale so how do we model that in
Java the index is a hash map of world a
world in string and a hash set of
indexes and the integers are just the
IDS of my my data mouth my text we have
three functions want to insert something
with the ID and the string and it will
just explode the text and create add
then add the words to the index one to
get the set for one word and one to get
a set for the string and if the made
hash set for two substring but whatever
so the insertion in Java we split the
text remove all of the all of the white
space and for each word we will try to
normalize so we put the word to
lowercase and we remove punctuation it's
a very naive normalization but whatever
we create we try to get a set if it
already exists exists we put that in
that set or we create a new one and
after what it's done it's already there
to get the index for one word it's quite
easy just call the ash map with the word
and you get the set to search a string
there's a bit more walk where you get
unit you must get the first set in the
list and then you do the intersection of
the all of this all of the set
afterwards
we retain all so it's like I don't know
of 20 20 lines of code to do that to do
a very very very stupid search engine in
in a small Java Android application so
yeah we need some data I thought about
it I wanted to import some Wikipedia
stir but see I have two paths eaten
annoying so there's a really nice API
that's been done by Nicola which is
right there to get all of the data for
devoxx all of the devices and yeah you
get the data for each day each talk and
everything so from there I extract the
the speaker's the list of speakers for
one talk and the titles and the summary
and I will just put the title and
summary in the index so there's an
Android application I will give you the
code afterwards it's easy to see but
like the interface is just this this
search box you put the word you get the
list of talks it's something that's
pretty straightforward to do I like as
we've seen it's easy to write that code
in Java but now let's imagine okay maybe
we want to have that search engine
portable like we want to use the same
one on iOS we want to integrate that in
a Ruby application we want to run that
on a microcontroller I don't I don't
care I need a good excuse to do some
rest so let's do some rest yeah so the
ID stop you can't achieve the ID is will
write rest library we've seen that face
and we load that with janie I'm sorry
gene a talk about that afterwards once
we get something that can be loaded in
the unreal application we can start to
write the index code and start to
rewrite stuff from Java to rust so first
we need some test code so when you want
to do a native extension for your
language the thing that will be the
biggest issue or even when you want to
do rust with anything else is the build
system
basically you you want to make sure that
it will compile fine so you don't start
reading the whole code right away you
you first start with a simple example so
we have function that can add two
integers not unsigned integers
because hey and we will try to access
that from Java we have two solutions
basically gni which is something that's
very variable the idea is that you will
load the library in Java and the C code
must expose functions that match the
package class method way to do Java and
GA is a bit more easy to use but there
is a kind of overhead but Jenna is
basically you declare your C function in
in the Java and you can't call it that
right away so in Jane I this is how I
write my Ross function so it's it's a
bit painful to do like I've done it for
the client project because I really
didn't like GNA for that I want it to
like micromanage my type in the FFI I
want you to make sure that I got
everything I wanted but basically you
emulate the method calls on everything
from Java like you will talk you will
take the GRE reference and you can ask
it to get a reference to a class to a
class then you ask the class to get a
reference to one of the methods and you
call the method with one of the
arguments is the object and it's it's
extremely verbose to use and you have to
declare your function like Java cons for
whatever until you get to the mid to the
class and the method in DNA it's a bit
easier can declare that like any C
function it and we walk correctly on the
Java side if you write gni yeah I am I'm
in the package I declared the same in
rust so Java come in restrict rust
the rest glass and add and now I have
this function add that's there and
declared as a native function gen a you
just declare an ad function there and it
will find where it is in the library
basically the idea is that GNA needs two
jars only one of them I don't remember
exactly what was the difference one gni
wrapper and we'll do the calls for you
there was more overhead on the recall
but it it's not that big and so for our
build system we do something easy with
just real easy no but here are the steps
we build with cargo cargo which is the
package manager forest cargo build we
set the target which is on linux android
api to say okay we will build something
for an arm android roast now supports
reading for a lot of platform and like
all of di us CPUs are are supported as
well and we get the lib index file which
is a dynamic library and in our hundred
code we put the drawers in leaves and
then the gni libs folder we put the
genui dispatch on our library okay from
there we get something that built that
will launch that will be maybe able to
load the library we can do something
more that adding some integers now so
let right let's write the index so if
you remember if you remember in Java
where was that
and they're free functions insert search
word substring and we have a hash map of
string and a set of integers so in rust
it's there so we have a hashmap of
string to a set of integers to the same
data structure we have the insert
function taking an ID and the search
word taking the world and returning an
option of ash set because maybe we don't
find the the word we're looking for and
the search for string search function
I made that as a method on the index
structure so as you can see for the
search and search world the first
argument is an opossum self it's a
reference an immutable reference to self
but the inset takes an ampersand mute
and that's saying basically I want to be
able to mutate the the index this is
this is pretty powerful because you can
have a lot of methods on one on one
structure on one object depending on who
is using the code they may have a
mutable reference or they may not have
one so you can pass the the index to
someone after having critique that
created it and you pass a new table
reference and you can be sure that they
won't they won't be able to mutate
anything because it's guaranteed by the
functions it's pretty great to add that
to the mutability that's explicit if you
written C you may have seen like
everything is mutable by default and
when you want to move to make something
immutable you have to put a Const so you
have to explicitly make it safer in rust
you have to explicitly put the node so
it's easy to grab for that and the same
way there are a lot of thing like
checking for error codes on everything
we have a return an option as written
for such rod in C if you have like
something that we written over a point
out something or no value it will return
null or
no value and maybe you won't check the
pointer and it's it's implicit in you
implicitly decide to not check the
pointer and not you cannot see the error
checking code in rust when you want to
ignore the the error code and get the
value inside the option and not caring
whether it's null or not you will you
will add unwrapped and you grab for that
because your app will create a panic
will crush your program if the value is
not there and you can see explicitly
that there you decided to make something
that's unsafe so it's a pretty powerful
way to write code because basically all
of the unsafe patterns are very very
easy to see in the code and like right
now whenever I see my rust code crashing
is oh yeah I unwrap some something there
and I made a bet and I lost basically
you cannot you still cannot prevent the
developer from shooting themselves in
the foot if they really really want that
but you can make it a bit harder
so let's write the insert function
there's a bit more code note now that
what we have what we had before
so the first three lines it's basically
just the regular expressions library in
rust it can pre compile the reg ex and
lazy static is something that will
create value the first time you access
it and then in snot then you cannot
mutate it since Marik X to remove
punctuation is used only once is is
generated once and used everywhere
afterwards I can just generate it at
that point and yeah there's an unwrap
and let the bed there but it seems it
does not work so if I want to insert
code I call speed whitespace on data
data is my string speed whitespace
generates an iterator and I can do for
each stuff so forward in the list of odd
split by whitespace
I will
normalize it so I replace with the red X
on the punctuation by noting and I put
two lowercase and I get my word I check
if my intake even if my index contains
the key contains the water and then it
gets a little bit more complex than the
Java code so the ID we have the index
which is in self in the instructor so
self dot index dot get Matt I want to
get a mutable reference to the ash to
the hash set that's that I can get from
that word so I know the gosh that exists
I check that it's contained there and
then when I get the offset I do a map
get nut returns an option
I do not own that so I get the offset
and then I insert my ID so this is
something that I wrote like just okay I
will do I want to do that now the
compiler will tell me
so you need to have a nut there
something and then you need to have a
non-person basically I don't think much
about the way I write code I just read
the compiler tell me you made a mistake
there so Indian it makes something
that's quite small but then can be a bit
harder to read if it's not there we
create a new hash set a mutable one we
do let root in so itself just let we
insert the ID and then we insert in the
other in the index this are set at the
the key word but it's basically the same
algorithm as the Java side so now we
won't do the rest of the algorithm right
now we try to call that from chora so
this is where there's the most work when
you try to link some rows to some other
language or rewrite some code at the
interface between both of them basically
we have an index that's the rest object
it's not managed by the Java garbage
collector it will be managed by
but once you get once you give something
to the language that's cutting rust
basically the compiler says okay yeah
but it's it's not mine anymore and
that's the idea of box if I don't put my
index in a box in index in index right
if I don't put it in the Box Russ will
say okay I still own that thing so I
will just delete it after at the end of
the the call but you put it in the in
the box we tell the compiler okay I'll
give the ownership of that thing to the
code that calls me and I return the box
of index the second function well you
get the box
but you don't get a reference to the box
to the index or whatever you get the box
itself so you own it
and the compiler you say okay yeah well
you do no fee in your function but I own
that box and it's not used afterwards so
I will just remove it at the end of free
it's a pretty fun way to just delete
data in the insert so we get a reference
a mutable reference to the index we need
to have it inaudible we need the ID and
we get the text as a see a see string
because that's how DNA works so
basically it's a list of bytes
terminated by a null Chau so first we
have to do an unsafe manipulation
basically unsafe it's a way to tell the
compiler okay I will do something with
the memory that you don't like but if I
can guarantee you that inside that part
of the code I did not make any big
mistake guarantee that the rest of the
code will be safe because sometimes when
you do interface with external code
there are pointer manipulation and
things like that that you have to do
like I could have added some code check
that the index is not now because I
don't know I could have obtained another
reference from the Java code so we
create a CSTR which
you see string in rust from the pointer
we get a slice a slice in rust is a
structure that contains basically a
pointer to something
and Al and then we call the STR from you
utf-8 function which will check that the
data is made of valid utf-8 char
characters and if it's alright it will
return an okey-okey
of something and then I know it's a
valid string and I can insert that in my
index and I had another method to just
see like how many words I have and test
that with Java I get the same data
it's for my index I get a count the
number of keys and return that as an int
so as we've seen GNA makes it easy to
call the code and just declare the
functions like they would be done in C
so there's something you can do with GNA
is exposing the struct itself it can it
can understand see stripes so I could
have accessed like the internal things
like you if you remember the point the
point structure with X&amp;amp;Y and coordinates
and everything I could have used that
from the Java but the the rest hash maps
and everything are pretty opaque for
Java so I would just say ok I'll give
you a pointer and you call my functions
with that pointer don't try to do
something else and now I can test the
code see if both of them work the same
way so for the Java side I create a new
index and for all the talks I insert the
title and summary for rust you need to
have the instance so if you see the
instance is a reference to the library
and that's mapping to the class we have
there so I call that instance which is a
rust and I call the method it has the
static methods with rust index that I
got before and is
it's a bit verbose but you can very
easily made make a big wrapper around
the Ross library and then there's an
asset so you have to take my word for it
but we get like the exact same number of
wads of keys so it's great but we need
more tests like I'm trying to write some
code from Java to rust I want to make
sure that I have the same feature that I
work the same way that I don't introduce
bugs because what I want is like
portability compatibility
interoperability I want something that
works exactly like the way I need so I
need one to add the other features if
you know that there's a a key word you
can check you can search for that's
called golden master testing it's a very
very great way to plant the rewrite of
something basically you will test the
old code and new code on the same data
and check the result and do that like
four months to make sure that the
results are consistent we won't do that
today because no time so let's implement
the search it's like the Java side you
have wash nut you give the world - - map
you get the data okay it's easy enough
and I said you return an option the
really annoying part is this one because
it's I have to make it safe and rust can
fight me a bit on that but let's see so
first we do a spit whitespace get an
iterator now it's the same as Java we
want to get the first hash set we cannot
do like this big
for all our set in the the stuff for the
words because I need to do the
intersection of the the hash sets I
could do I could walk through the whole
iterator if I'd made a union of
everything but now I have to get the
first way - who's reg Electress that
kind of use case where
so I get the first word I know more
normalized the world I replace the
punctuation with the regex we had before
I make it lowercase and then I search
the world and I get an option of hash
set so in first we had we got the first
element we got next
but next gives us an option as well
because maybe there's nothing in the
string so what we get in first is an
option of option of a set because we
it's it's annoying to have like multiple
calls that can fail so you have to
handle the case correctly but in this
case it's interesting we can just care
for one case which is like it's
something of something containing a hash
set and that's where I get the E flat
stuff basically in rust everything is an
expression so you can do something
equals if stuff else something and this
is valid so I want a hash set I get res
which is the hash set of I 52 and if
first is the sum of sum of high hash set
I clone it because the hash set I got
from the index is a reference to the one
you see how it's still a bit harder than
something like Java like in Java you
just return the heart set on everything
because it's garbage collected so you
know the reference will disappear at
some point and it will be de-allocated
when needed but in rest know if if I if
I return a reference I have to use a
reference but the case I want I want to
have my my set containing something so
if there was no first word on the in the
industry or if the world was not there
in the in the map I return an empty set
and whatever happens afterwards
section will be Humpty then this is a
fault
you give it a first parameter and an
operation that takes one parameter of
that type and then the node the next one
in the in the list and so I ETA rate on
the list and get the world for each flow
that normalize it and I get the the I
call the index with that world so index
that get that would give me an option of
ash set I'm up on that option so if
there's something in the option I get an
aged in a hash set and I do H dot
intersection with my first with my first
parameter my accumulator set and then I
clone this and I return that and if
there was nothing I do an unwrapped or
and a return a new hash set so you will
have to take my word for it that it's
actually pretty easy to write and kind
of easy to read if you use to rest
basically when I when I wrote that I do
not know where like who was returning
which type or whatever I just say okay
like you see the hash set of I 42 stuff
I put that to say okay this is the type
I want to have there and I read the code
on the other side of the equal sign and
then I let the compiler tell me
yeah but there you did that and it's not
the same type like you got a reference
to a hash set and you want to hash that
and it's the same thing in the end in
the in the lower part so it's a bit
harder to write but in that case like we
have some code that still manageable now
there's an issue I have there is that
the hash set of I 52 it's a rust type
and it's not one of the ones that's that
are easily mapped by DNA so I have to
have a way to return a set of integers
to
so are we doing with that I make a new
type that's basically of an array of I
42 stuff and I make the methods for that
so one to get the number of element one
to get one element somewhere and one two
three the result you can see that I made
an unwrap there it's it was to punish
myself if I made the mistake to make a
knot of bond access on my result
basically is hard to iterate on things
that came from a native code but I could
have made like some safer wrapper so now
if I want to use that I'll make my
external function the one give to Java
and say okay so you want to search that
text so the first line the function R
return I get a slice from there from the
text then I convert that to a text that
can be empty I use from utf-8 but
instead of matching on that I say I take
the result or I replace that with an
empty string I search the result and
then I create a Veck from the edge set
by iterating on it and it's cloned so I
will own the data and then I rub that in
a search result but I wrap in a box and
I give that to the Java code it's it's
pretty verbose to do that but basically
most of the time you don't iterate on
much stuff coming from native code you
try to just push as much stuff on the
native style side as you as possible so
on the Java side you have the search
function you have the search result
can't free get on whatever so it's still
pretty easy to declare and the code to
search everything is kind of the same so
we get the set of
for the Java code with such string we
get a pointer to a search result from
the rest code and then I convert that do
to to Java hashset
and I try to compare them like how many
entries can we get like if I search for
Java so let's see ok it's alright they
get no they don't get the same result so
what's happened it turns out like I had
a bug in the Java implementation that
did not happen in the rest code
basically for some of the talks
there was Java extension mark or some
filler that in at the end of the line
and then line returned and whatever and
then over what and the Java code I
written was not taking that so I still
circuit Java reg ex but I'm pretty good
at rest now I think both so it was a bit
hard to do it's always a bit hard to
write native code but now we have a
working implementation and I could use
the same C interface to call that from
Objective C because it's some code
that's easy to to call from object he
objects is just basically C with the bad
parts of small talk I really love small
talk but like I don't I don't conduct
can bear Objective C whatever but still
I have another example I will be able to
for you afterwards where basically you
can call from Objective C and you can
even package a roast rat code in a in a
pod pod file stuff which is a kind of
packaging and they have like a new one
every two years in the iOS community and
it's doable universe so there may be a
question that I have avoided for the
whole talk because I did not want to get
in there it's like yeah but Java is fast
enough and we don't need to do some C or
code so and I agree like Java is fast
enough but let's see yeah so don't take
that too
tappy it's just native code on both ends
and like turns out like writing code
faster naive was easier for us if you
really don't like what I did come and
get me I still like to see people do
micro benchmarks so in the end there's
still a bit of a learning curve in rust
it still takes some time but the
compiler team is really committed to
make it easier and easier to use like a
lot of cases where the compiler is
telling you that to make you did
something wrong they will be able to
understand what you mean and generate
the correct code instead of just telling
you you did something wrong you have to
make sure that the compiler look is
helping you like if you go into the
language just say okay yeah it's
annoying but it tells me that I write I
write the wrong code no the compiler is
like
is there to make sure that you will not
make too many mistakes
it's like pair programming with a robot
the robot tries to be as polite as it
can but like if you do the smallest
mistake to see it and it will tell you
it's very explicit so it's portable like
I think I could use my implementation of
a bad search engine on almost every
platform I think I oppose that to some
PHP or Ruby conferences it should be
good to have the same implementation and
FFI is kind of easy it's hard on the
rough side even more if you do gni but
basically most of the code on the Java
side will be easy to write which is good
because most of the time you want to
make sure that the user of the library
will have the best time ever so Indian
if you want to take a look at the code
it's there on github the slides also
available there's also a link on the
github one to the iOS and Android
version of the code we have lots of
stickers for clever cloud if you want
there's the hosting powers one on a lot
of very nice one and if you have any
questions or anything I'll agree about
them voice thanks we have like something
like nine minutes if you ask questions
you can just look at gifs for long time
yeah yeah so the question is in terms of
API what do we get out of the box for
like for the standard library connection
one collections collections in interest
Russ is not a battery included language
like a lot of things are still left to
the community because they did not want
to fix everybody on one implementation
on everything but the collection like we
have the the vague - map - set we have
the trees where lots and lots of ways to
iterate on data and basically the
community had a lot of fun writing their
own collection like there's a kind of
array that's stuck allocated but if get
if it gets larger that's some size it's
now a heap allocated array like there
are a lot of things you can do with the
collection interest but most of the
standard library is very very small
because it's left to the community
any other questions
I can show you the iOS side still have
seven minutes
yes that one
maybe I can okay I know I know what I'll
do
so this is another example where I have
the iOS code with a small library so no
it's not that one it's let me check it
was in the example yeah okay yeah so in
my class I think it was somewhere there
no why did they put that code whatever
the I can show you Eugenia genocide
I made one library and then I met
another library which is calling the
first one and making the GI wrappers and
this is the one I use on Android maybe
it's a bit small okay so yeah it's
pretty verbose I really don't like the
way it's done but yeah it was easy
enough to do it manually and like for
the the rest the rest side basically
it's it's C code it returned some C code
it was no example to prefix strings and
stuff and this is something that can be
called directly from Python or from
Objective C or whatever there are people
that are doing like some libraries to
make ruby gems and Python extensions
that are very well connected to the
language like you could get an object
from Ruby and rust would understand the
garbage collection from Ruby this is
pretty awesome stuff that people have
been doing any other questions all right
thanks
don't forget to take some stickers</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>