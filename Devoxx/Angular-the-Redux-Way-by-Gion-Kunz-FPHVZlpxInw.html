<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Angular the Redux Way by Gion Kunz | Coder Coacher - Coaching Coders</title><meta content="Angular the Redux Way by Gion Kunz - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Angular the Redux Way by Gion Kunz</b></h2><h5 class="post__date">2018-03-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/FPHVZlpxInw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright thanks for joining my talk in
this talk I will talk about the title is
angular the redox way and we're looking
at some general state management topics
but then in the end we are more looking
at ngrick store
which is a one implementation for
implementing a redox kind of pattern
within angular first of all this is kind
of a bold statement but state is really
sometimes your biggest enemy when you're
developing an application you can just
have so many issues with state in your
application and these are just a few of
them so synchronization is the issue for
example in client-server architectures
if you're having stayed on your server
and on your client and you kind of need
to synchronize this state you can get
into a state of where you're not seeing
synchronized anymore right or if you
have a distributed state and you need to
synchronize the state between these
different distributions right so this
can also lead to a lot of issues
dependencies are usually a problem in
States or one state is depending on the
other state what do you do when this
state updates you need to update also
the other state so it can just lead to a
lot of messy code state transitions
right so if you have something like a
process where you're going through or
your user are going through in a user
interface and then you need to
transition between different states so
that can also be a big issue in your in
your code mutability is also a big issue
so of course if you're using object
references in our state and I'm we're
just updating the state somewhere maybe
we have another reference from somewhere
else and then we're just updating
something that we actually don't want
and generally a lot of times in our
state architecture it leads to
kind of a non-determinism so over time
you cannot really predict what your
application state is and how it came
there right and that's a huge problem
because when you're looking at your
application you should always be able to
tell exactly what's going on right it
should be completely deterministic and
that's really not the case with most
application architectures so first of
all let's look at the anatomy of off
state and we can actually talk about
this a little bit so as an example I
would like to bring up the question why
do we even need client state right so in
a client-server architecture why do we
need client state is there any reason
for using client state couldn't we just
store all the states on the server right
like something like JSF or something in
that area right so if we do a little
experiment and we're developing a small
to-do app it could look something like
this right so we're clicking a to-do to
mark it as done but then it takes a
second in order to get marked and also
the second to do if you want to take it
off it just takes time until the server
responses with the update right so if we
don't use any client State we're gonna
have some kind of an issue here right
because if we're performing a change
this change first needs to go to the
server and then maybe even if some you
know if a lot of stuff has been updated
and we don't include in the payload of
the response the updated state we even
need to do another call to the server to
get the updated list of todos let's say
and that just takes a lot of time right
and if you're building your application
like this the user will actually have a
very bad experience and that's basically
because the perceived performance of
your application is very bad right so if
you
if I as a user click somewhere I want to
see an immediate feedback right so I
want to see that this what I've done is
actually done also I have a lot of
glitches in such an application because
if I start to click around and do a lot
of tasks and this needs synchronization
with the server before I see it I may
end up in a dead-end right because I'm
clicking all around and everything gets
delayed it can really lead to problems
another issue is with a server state
only if I add to do in this example and
I don't see it so I need to switch to
project tool and I'm switching to
project one again because that is
triggering ali-a reload of of my to-do
list and here the issue is if we have I
mean if we are really building our
application from components what we
should do we have maybe two components
like a project component and a to-do
component
now the to-do component is fetching the
initial list of data and it's
visualizing that is showing that to the
user and then suddenly you're updating
the list by adding a new to do on the
server but this is done from the project
component right and then suddenly your
to-do component is out of sync because
you're only relying on a server state
you don't store anything in the client
so the client doesn't really know if you
are updating from one component
something to the server
maybe that component can be updated but
the rest of your components in the
application they have no clue what's
what's happening so this is more of a
distribution and synchronization issue
so if we're having a distributed state
or if you have a lot of components and
they rely on the same server state we
kind of need additional synchronization
so in order to solve this we could use
something called client persistent state
and client persistent state can be
implemented in many ways of course but
in this example we are making use of
rxjs because that is already coming with
angle
so we're actually we can make use of
that in an angular application and we're
using a behavior subject which is an
observer and an observer at the same
time and we're using that behavior
subject in order to build up kind of a
cache in the client that is just caching
whatever is on the server so if we have
that behavior subject when we're doing
an update to the server and the server
responds we can actually publish this
update in this behavior subject and all
the SUBSCRIBE components they will be
updated by this change right what we can
also do is kind of an optimistic update
using that behavior subject so instead
of just relying on the server to answer
we can already update our local
persistent state and rely on the server
to correct our optimistic update let's
say so this could look something like
this we have to do list here which is a
behavior subject of type two Deuce array
and in our constructor of this service
we're calling to load two deuce method
and inside of the load to those method
all we do is we do an HTTP call to the
server to get the to-do list and then
we're subscribing to that observable and
we are calling this to-do snek stand
with the next method we can actually
publish something on that behavior
subject so like this we can we can all
the SUBSCRIBE components they actually
obtained as an event they updated list
of to deuce which is really great
because then we can have hundreds of
components subscribing to this list and
they all will be in sync if something is
getting updated from the server and then
we can do something like an optimistic
update right so instead of directly this
is the add to do method right instead of
directly calling the server to post a
new to do what we're doing is we're
doing kind of an optimistic
update so we're pushing kind of a dummy
to do into our to-do list or in the
observable stream of our our list or in
the behavior subject and rich is
concatenating
what's existing already we can do that
by getting the current value of the
behavior scepter subject by calling gate
value which is not so much used and and
loft in the functional word world
because it kind of causes side effects
or it's a side effect but with this
method we can optimistically update our
client state and then we can just rely
on the server to update the correct
values once the request is it's done or
once the response comes in and this is
really great in some situations as in
this user phase because now we can take
off the two Do's these updates go in as
optimistic updates and one once we add
two deuce it's also added immediately
and we see the change and when the
server responds with the correct answer
or with the correct update
we're just overwriting what we did
optimistically in our clients persistent
state so actually we can think of state
in kind of two fashions there is a
persistent state and there is a
transient state and in the client we
also have a persistent state in the
client right there is a lot of state or
ways how we can persist state in the
client and there is this persistent
persistent state that we just saw which
helps us to synchronize state to the
server where we can also leverage
concepts like optimistic updates and I
think we shouldn't think of persistency
as either persistent or transient it's
it's more like a gradient right so we
have things that are highly transit
transient and we have things that are
highly persistence but there are also
things in between right so we shouldn't
only think about only persistent or
transient but it's somewhere in between
for example the state of a mobile menu
right if we expand the mobile menu in
the UI in the user interface in the
browser this is maybe a very transient
state right we don't need to store it in
in any way but
the password of a user for example or a
document the user uploaded it's actually
very persistent right it's stored in a
very very persistent way and I always
like to think about when I think about
state of the life span requirement of a
state right so what's the lifespan
requirement of an accordion if it's
collapsed or expanded right there is
just not so much requirement for a long
life span you don't want to save this in
a in a database if the user has expanded
the mobile menu or something like this
right however other things like
documents that are uploaded or the
password of a user has actually a very
long life span right and what we need to
be aware is that usually everything that
has a very long life span is also very
hard to obtain right and to manage
because you need to do a server call the
server needs to consult a data store or
a file or whatever so it takes a lot of
time and there we need to kind of build
build a bridge for the user experience
because we cannot we cannot show the
user that this needs so much time so the
next topic is centralized reactive State
and we were going to look at some
approaches and maybe the most popular
design right now is called the flux
application architecture which was
designed by Facebook and the flux data
architecture is really really nice
because it's so simple but it solves
really so many problems and we're going
to look into a lot of examples now the
basics are very easy from the view I can
dispatch so called
actions and these actions are dispatched
using to a dispatcher and the dispatcher
is actually then updating some state I
have stored in stores and so this is I'm
not directly modifying States within
this architect
I'm dispatching actions structured
actions that tell the dispatcher this is
the action for example adding a to do
and then I have some payload with this
action and then inside of the dispatcher
the modification of the state will be
done based on this information right so
it's a very controlled way how to manage
your state how to manage your data and
after that change is done the store will
actually reflect these updated the
updated state into the view of your
application again so that's one of the
things of this architecture it's really
unidirectional right so the view is
causing an action or triggering an actor
and an action and then this action is
going through the dispatcher and the
store is updated so flux is actually
implemented in many implementations the
most popular one is probably redux and
you know that probably from from react
but Redux can be used not only in rekt
of course it can be used anywhere and
you can see all these other libraries
here or implementations there are many
more the but there is reflux flux or
flow mocks and I mean from these names
maybe they're very creative libraries
but in the naming maybe they were not so
much creative but if we look at the
history a little bit to come to the main
topic that we're looking at which is
ngrick store you can see this is maybe
like the influence influence map how
ngrick store was created and redox was
highly influenced by Elm which is from
about 2012 I think and flux the flux
data architecture so these were the two
main influences for for the redux
library and then ngrick store they took
this to a next level I think because
they took the concept of redox and
combine it with the reactive way how you
do things with oryx chairs with streams
right jobs were observable streams and
that's really really a great combination
because then we have the we have the
concept of a centralized state
but it's combined with the reactiveness
of Oryx chairs we give thought it gives
us a great flexibility by using
operators but also it's really efficient
because we can always react on on
changes so the ngrick store architecture
is actually also pretty simple if we are
looking at from from a higher level and
from the view so this is similar to the
flocks concept we're dispatching actions
but in in ngrick soar in redox we're
dispatching the actions to the store and
then the store is actually forwarding or
delegating this action into so-called
reducers and reduces their chest pure
functions that take two arguments one is
the current application state and the
other argument is the action itself and
then the reducer function is producing a
new output State for your application so
you give it the current state an action
and it gives you the resulting State
right that's a that's a reducer function
and then this output state is going back
into your store where it's effectively
then distributed to your view because
you can subscribe to the store changes
it's an observable right so you can
subscribe to these changes with angular
even in the view using the async pipe so
that's how actions would look like if we
are implementing them in ngrick store
they're actually pretty simple the only
contract that you have from the action
interface is that you implement this
type field which should be a string and
it helps you to distinguish between the
different actions right so in the
reducer you will then check for this
type property in order to see what
should be performed what action should
be performed so every action has also a
payload and I mean you don't need
necessarily a payload some actions they
don't have a payload right for example
the action of clearing all too
in a list you don't need additional data
or information to execute this action
right if you need to clear the whole
list
you don't need additional data so you
don't need payload for that but other
actions like updating it to do you might
need payload like the actor to do ID and
the data that you want to use to update
this specific to-do item this is how you
dispatch an action using ngrick store so
you just call store dot dispatch and
you're passing your action that you want
a dispatch and then this is the
interface for the reducer function and
as I said before it's really simple you
have just two parameters the first one
is the current application state so the
store when it delegates to the reducer
when it is pechenegs an action it will
pass the current application state and
and also the action that you use when
you dispatch and based on that the
reducer will be able to produce a new
output state so if the action is adding
it to do and your current state is an
empty list then the reducer knows okay I
take this empty list of the current
state adding you to do with the data
from the action and then I return the
whole state as a new outcome State and
that's the beautiful thing about
reducers they're pure right so when you
call them with the same state and the
same action the output the output state
will always be the same right so they're
absolutely deterministic and this is how
you would implement a reducer so in this
example we have a very simple counter
state and on that counter say we have a
count field we also create a constant or
an object that is kind of the initial
counter state where we set count to zero
and in the reducer we can use a pattern
we can use a default value for our state
so if by any chance the reducer is
called with undefined as the first
argument so no state is passed which is
using the initial state and the second
argument is that action
and it needs to return a new counter
state so we're passing in a state and
we're getting out of state inside of the
reducer and that's a pattern that is
coming from from redox so we're using
switch case to switch on the action
types and then we're just performing the
action that is required so the reducer
is actually the element in this whole
thing which is producing or which is you
know modifying your state and this is
how you get data out of this store or
out of your state
so since angie arexx uses observables
what we can do is we can call store dot
select which is effectively just a map
function an observable map it's
equivalent to observable map so we're
passing a mapping function where we
always receive the global state and then
we can just substitute or select the sub
state and then we get a new observable
that is pointing to that subset and when
there are changes I will always get the
latest values like this okay and really
the most beautiful thing about this
whole thing flux but also ng rx is that
it is so simple but it is so powerful at
the same time because it will fix most
of your state issues that we looked in
the first slide we looked at in the
first slide and because it's so simple I
want to show you that we can implement
our own ng rx with only 25 lines of code
so in order to implement our own ng oryx
we are starting with the action
interface so we're building a few
interfaces now in order to have
everything type safe and document it at
the same time so we're having an action
with a field type which is of type
string and the next interface is
actually the reducer function so we call
it a we're creating a interface for the
reducer function we're using two
generics one is for the state type
and the other one is for the action type
and the reducer function itself as we
saw before has two parameters first one
is the state and the second one is an
action and the result the return value
is also a new state right and then we're
trading another interface in order to
help us with selecting sub states right
so we're creating a selector interface
which has also a generic that represents
the state and another one that
represents the return value when we sub
select the states of the devel or the
type from the sub state so here we can
pass a selector function or a mapping
function which will receive the state
and produce or return a value from the
state and it produces an observable of
that value type so that's our selector
function so now finally the last
interface we're creating an interface
for our store objects so whenever we
create a new store and the store object
has two generics one is stay type and
the other one is action type on the
store we're adding two methods the first
one is the Select method which is just
off type selector function that we just
created before and the second method is
the dispatch method right in order to
dispatch actions from the store we're
adding this method which is really
simple a method or function where we can
pass an action and it doesn't return
anything so now we're implementing our
store and we do that by using a factory
function so we're creating a factory
function called create store and create
store is using the two generics that
we're using here crud frequently for the
stay type and the action type and we
have two parameters in this function
the first one is actually the reducer
that the user wants to use with this
specific store which is of type reducer
reduce a function and the second
argument is an optional argument for the
initial state that we want to have in
our store so we can pass an initial
state so that our application has a
state initially the return value of
create store obviously because it's a
factory function is a store so now
inside of our factory function we're
kind of building up the heart of our
store which is a behavior subject so
we're using a behavior subject inside of
our store to emit changes of the state
of our application so you can see the
behavior subject is of generic type s
which is our state type and we're in
initializing our behavior subject with
the initial the optional initial state
initial State and we're calling that
changes because it emits all the changes
of our state and finally we just need to
return our state object which is
conforming to the sorry our store object
which is conforming to the store
interface and implement these two
methods or functions so the Select
function is really simply a map right so
where we can actually just do a map here
so we get the selector which is a
mapping function selector parameter of
this arrow function we're converting the
changes to an observable and then we are
piping that observable using the map
operator and just pass the selector
because the selector is a mapping
function and a second method we are
implementing is the dispatch method and
here we are getting the action that we
want to dispatch then we are accessing
changes and now the tricky part starts
well it's not so tricky with next we can
meet a value on the behavior subject but
we're not calling next directly instead
we're calling the reducer that was
passed to the factory function in order
to create a new store and we're calling
the reducer with the current state of
our application which we get by calling
changes get value and the action that
was dispatched so the reducer will then
create the new State and this new state
we will emit through the behavior
subject and that's already all we need
to create an grx I mean in its simplest
form of course but this is already
working and with the example from before
with the counter state example and our
reducer we could now create a new store
and use this already in an application
by creating a store using our factory
function create store we pass the
reducer we pass our initial state and
this is already working inside of a
component if we then want to use this
state and modify this state using our
own own implementation of ng rx we could
just get something from the state by
calling sword select and here we're
getting the sub state which is this
count the counter state which is of then
of type observable number right because
the count is just a number and if we use
the awesome async pipe in angular in the
view we can directly subscribe to this
observable within the view of our
component so the subscription is
happening there and then if we click the
button to increment the counter
recalling the increment method on our
component which is dangerous calling
store dot dispatch and passing the
action increment action increment
counter action which is handling the
reducer right as we saw before in the
example
so flux is really like balm for the soul
of your application if you're using a
flux architecture and you scale it up
you're gonna recognize that it's really
really doing a lot of good for your
application
it's a centralized state right so you
don't need to search for distributed
State in your application you'll always
know where your state is it's highly or
it's unidirectional so all your data is
flowing in a unidirectional way the view
is sending actions to the store and the
store is then updating the data using
the reducers that you have configured
reducers are pure functions and that is
for me I believe maybe the best thing
about this whole concept of redox and ng
Rx is that these functions they're so
predictable
if you're writing tests for your
application you can just you can just
call the reducer with states that you
put together and the action and you
should be able to see all the behavior
that is really really in an in a pure
way right so when you call it at the
same state and same action the outcome
should always be the same and it's
really simple to reason about if you're
building your application like this
because of this high predictability and
determinism you can always really say
what your application does and because
it's so simple and nice we would like to
now also implement this awesome redox
replay feature that you I'm sure you
have seen a lot of times but we're gonna
implement it in our own implementation
that which has produced before with only
seven lines of code so this is the
implementation from before the only
thing that we're gonna change is we're
gonna add a new replay history function
to our store interface and then we can
just pass an interval which is a time
interval that is getting that is used to
replay the state with some delay right
so every state changes
played with a little delay inside of our
factory function we're just adding a
history which is simply a list of states
right and then we subscribe to the
changes so whenever there is a state
change we we subscribe directly in the
factory in order to see or to get all
the change states and just push them
into this history and now we're going to
use some Oryx chase magic to create a
replay history function so here we are
getting the interval as per the
interface right and we're using the from
helper the observable from helper to
create a stream of items from our
history array so every item in the in
the array will be turned into a stream
item and then we pipe that stream
through a zip helper where we use a
timer to offset each individual item by
a given amount of milliseconds and then
we're just subscribing to that new
stream that we produce here and we're
using our changes again to emit these
individual states that then get you know
delayed on a time axis a little bit and
replayed so this is maybe not the best
idea because now if you would replay
again the replayed replay would replay
again right but I mean for this
demonstration it doesn't really matter
so if you look at the application like
this we can update some to do this now
in our list adding new to do so this is
all happening through actions of course
now with our own implementation we can
even switch projects and add up to do
there and you already see maybe we have
a new button there on the bottom replay
history so this is just calling the
store replace history function that we
just created and if we do that you can
see that the whole state changes we have
applied now in the UI or just replay it
to
user interface and of course this is not
a feature that you could use in
production but what it really shows is
that your whole application is really
really simple to reason about if you can
replay States and your user interface
shows States from your history then the
architecture that's it's kind of a proof
for the architecture right because then
it's so highly deterministic that
something like this can actually happen
or can be done easily with seven lines
of code right so with a total of 32
lines of code we have rebuilt and grx
with a replay function even right which
is awesome because that proofs it's
really really a good concept so what
about asynchronous actions so far we
have only seen a synchronous stuff of
course the two duels were synchronized
to the server but our actions we're all
synchronous so you could really go very
simply about this whenever you complete
an asynchronous operation no matter
where you're performing the operation
you can just call store dot dispatch
right so we're loading a to-do list from
the server and when we are done we're
dispatching an action and the action is
updating the data in the store State in
the store however then you will start
trading a lot of services and they do
all sorts of crazy things and then
dispatch actions and you're also losing
a little bit control and there is a
solution for this with an grx is the
little helper library called ng oryx
effects and it helps you to kind of
manage these asynchronous effects in a
very controlled manner so this is the
architecture of ngrick effects it's
really simple effects act like a stream
there you're going to receive actions
and if they think they need to do
something with one of these actions
they're going to pipe these actions
through and they're going to produce
a new output action so they're more like
a pipe something gets in into the effect
and action gets into the effect then
something happens maybe something
asynchronous not necessarily but maybe
and then after a while the effect spits
out a new action and this action is
automatically dispatched to the store so
you don't need to dispatch it manually
and that's the whole idea of effects in
in ng rx so the implementation would
look like this the effect is actually
put into a service so you you're
creating an injectable class and inside
of that you are creating effects by
using the effect decorator that comes
from ng rx effects and we're also using
something called actions here the
actions is actually coming from ng or
its effects and it's just an observable
that emits all the actions within your
application that were emitted right so
whenever you dispatch an action this
actions observable will actually emit or
you can you can observe this this action
coming through these actions observable
when we have that or when we when now we
could really react on all sorts of
actions right every action that get
dispatched in our store we can handle
here and then we can use a helper that
comes from ng rx effects which is called
off type and that just had it's kind of
a filter so we could also write filter
and then action action dot type equals
low to do action that's actually
actually the same write off type is just
a little helper so we're only taking
care of load to do this action and then
what we're doing is we're using merge
map in order to so that's all or its
chairs we're using merge map in order to
start an order observable stream and
kind of merge it back into the original
stream so like this we can extend our
asynchronous operation by involving an
the stream and we do that because we
want to do an HTTP call and the result
of that HTTP call we take that and we
map that into a new action and that's
the set to do this action right so
effectively you could say about this
effect it takes a load to do this action
does something and then it's mapping to
a set to do this action and then this
action is actually dispatched to the
store so in your view that would now
look like this so you just use now
dispatch in order to load some data so
you're not involving a service anymore
you're just calling store dot dispatch
load to do section and that will trigger
the side effect and the side effect will
load the data call an order action and
your state will be updated and reflected
into the view using observables and
subscriptions directly in your view all
right so now I want to look at a few
patterns and I think it's really
interesting with redox and an TRX so how
you dealing with this state their date
there have emerged some patterns of how
do you treat certain problems in
in-state architectures like this right
so you could even write a pattern book
about how to create state for immutable
not immutable infinite scrolling or a
load more button or any kind of task you
have any user interface sometimes you
can see some common patterns that you
can really describe as a pattern to be
used with ngrick store or redox and I've
just put out four of these patterns now
here I think but there are many mores
and it would be really interesting to
actually create maybe a website even to
collect all these patterns and if you
are working with redox or ngrick store
already I would be really interested
after the talk if we could talk about
your experiences and maybe
patterns that you are using so the first
pattern I want to talk about is
asynchronous operations with error
handling right so usually when we load
something from a server something could
go wrong right and then we have an error
in a traditional application sometimes
it's really hard to handle these errors
not because of the error handling but
because you're using distributed state
and once one part of the state is
corrupted you never know how to fix your
whole application with all the state
where is the state corrupted right if
you distribute your state it's gonna be
really hard to recover so you could just
restart like air long right or you could
use a centralized safe management where
errors happen in a very controlled
manner right so when we have an
asynchronous operation with error
handling pattern what we're doing is
we're calling or we're dispatching an
action called load item section in this
example the reducer will handle this
action immediately but at the same time
the effect will also handle their action
so the effect will do something with the
action as well and after a while when
the action the asynchronous action or
the asynchronous effect is done it will
either map to a load success action or a
load failed action based on the outcome
right if there is an error we'll have a
load failed action with some payload
maybe the error and if everything went
fine we have a load success action so if
you look at the state for this example
or for this pattern it could look
something like this we have a loading
flag we have a errors list which is just
a list of strings now in this example
and that the items list the effective
items list the side effect would look
something like this so we have we're
filtering for load items actions and
we're again using merge map to merge in
an order stream but here this time we're
calling HTTP GET but we're not only
handling the success case we're also
using catch error in order to handle the
failure case right when we have
an error coming from the server so in
our success case we're then mapping to a
load success action action and passing
the items which is coming from the
payload from the get request and in the
failure action we're just dispatching or
mapping to a new load failed action
which is really controlled now we can
implant a reducer that just handles
these different actions right in the
load item section that is actually to
cause the side effect to load the data
the only thing we're doing is we're
setting loading to true and this is
happening instantly right once once this
action is dispatch we're setting loading
to true and then once we receive the
load success action coming from the side
effect we're setting loading to false
and the items to the right means that we
receive by the action which effectively
come from the server if something is
failing we could do something like just
setting loading to false again of course
because if it there is an error we also
stop loading hopefully and this is the
moment where in some traditional state
distribution you see spinners going all
all along when when the application had
the error you see the spinner still
spinning for forever actually so within
an architecture like this this could
never happen actually and we are pushing
the error into the errors list here in
this in our state another pattern is the
optimistic update so in that case we're
also the action is also handled by the
reducer and by the side effect and then
the side effect in this case is not
handling the error you could handle
there as well but we're just dispatching
or mapping to a server update action
once the the optimistic update went
through our state is pretty simple here
again we have updating flag and the item
that we want to update and in our effect
what we're doing is we're just doing the
asynchronous operation to update our
item on the server so we're filtering
for optimistic update action and we're
calling API items with with the post
pass today
from the action the server gave us the
answer and when we got the response that
everything went fine we're mapping to a
new server update action passing the
payload from the server in our state
however what we're doing for the
optimistic update action which is also
handled by the effect we're also setting
updating to true but then we are
updating our item in the clear climb
persistent state so this is now this
plot client persistent state right so
we're optimistically updating our our
local state item and when the server
then returns with the real update we set
updating to false and update the item
that comes from the server there is also
more patterns like a load more button we
can quickly look at so we have a load
more action than we in this time the
load more action is not directly handled
by the reducer the mapped action from
the effect is then handled by the
reducer in this example we just have
empty items array in the beginning and
when we're loading data from the server
all we need all we do here is we're
doing something that we didn't saw
before so we're combining the action
that comes in with something from the
state which is also an observable right
and then we're basically combining that
so we can get the current list size from
our state and use that in our get
request in order to specify how many
items or where we want to start loading
additional items and then we just pass
that and the answer we're gonna use the
answer to append more items to our items
list right so here in the reducer we're
just passing more items and there is
another example with a process step it's
kind of a finish date machine like a
pattern where you're using kind of step
type interface using a Union type and
then you can just jump from step to step
in your state so that's the idea and
maybe
collect some data on the way and in
order to do that we don't even need an
effect you can directly do that in the
reducer we can do create a sub switch
inside of the action type switch where
we switch for the action step kind and
there we can decide do I need to go to
the next step or to the previous step
and all these kind of things that you
have in a finit state machine so the
conclusion is really that or what shines
most about flocks and redox is that it's
really simple you saw it right we we
built it together with 32 lines of code
but the impact is has on the on the
determinism of your application and the
cleanness is really really fantastic and
it's always hard to tell about this
because I think you can only really know
about it if you experience the effect on
your own so if you're using it in your
own application mid-sized to large size
you really gonna experience the benefits
of it so this is my company I just found
that my company a month ago and I'm
doing some consulting and also workshops
or implementation in these kind of areas
so I'm only doing stuff in the front end
I'm a pure front-end developer and if
you I'm always looking for people who
are like-minded and need some help maybe
with some topics on angular or ng rx so
if you have some stuff to discuss please
come to me after the talk thank you
I think we don't have time for questions
but if you have questions you can of
course come to me and I'm really happy
to talk about this stuff</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>