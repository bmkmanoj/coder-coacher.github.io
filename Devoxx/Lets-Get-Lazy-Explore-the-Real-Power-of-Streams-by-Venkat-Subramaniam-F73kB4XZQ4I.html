<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Let’s Get Lazy: Explore the Real Power of Streams by Venkat Subramaniam | Coder Coacher - Coaching Coders</title><meta content="Let’s Get Lazy: Explore the Real Power of Streams by Venkat Subramaniam - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Let’s Get Lazy: Explore the Real Power of Streams by Venkat Subramaniam</b></h2><h5 class="post__date">2017-04-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/F73kB4XZQ4I" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">samanya I'm going to talk about laziness
and Titus back into how we can actually
benefit from the true value behind
functional programming so let's talk
about laziness to begin with so what
does it really mean by being lazy
well being lazy simply means that well
in a case of an eager valuation we
execute a particular computation or a
function or an expression as soon as we
get hold of that particular expression
but rather than doing that we're going
to postpone it until a we can do it
later or until the point when we don't
no longer need the execution and we can
just avoid it so one of the benefits of
being lazy is we can be more efficient
by false warning computations so one of
the things I've learned over the years
is both in life and in programming it
really is valuable to be lazy so we want
to postpone things until the point where
we can no longer postpone it well let's
talk about this a little bit when it
comes to programming languages there are
two ways in which we can execute code
and one of them is applicative order and
the other is the so called normal order
well it turns out the normal order is
actually abnormal we don't use it too
often most of the languages actually use
what's called applicative order let's
understand what that means with a little
example to see how this actually works
so I'm going to start with the example
in Java but I'll show you a little bit
of example in Haskell just a little bit
in Scala and then we'll switch back to
Java after that and look at few more
details so let's talk about this
applicative versus normal order well it
turns out most languages that we use in
the mainstream use the applicative order
and so here is a quick little example to
think about let's say for a minute we
have a function to start with and this
function is going to be let's call it
compute this is not going to do a whole
lot right now all this is going to do is
simply return the given number let's say
but I'm going to go ahead and print out
in this case compute called
and so we can display the the fact that
this particular function was actually
called
in this case but what I'm going to do
here is I'm going to define a variable X
equal to 4
and I'm going to say if X is greater
than 5 and let's say compute of X is
greater than let's say 5 also then I'm
going to go ahead and say something
called result a little silly example
otherwise I'm going to output in this
case let's simply say a no result well
here is a little example so X is 4 if X
is greater than 5 and if compute X is
greater than 5 then I say result
otherwise I say no result well a trivial
question of course I'm going to run this
code but the question to you is will the
compute function be called or not no of
course not
why is that two words note that's more
than two words towards short shots are
curing absolutely we all know shots of
curing right so we have come to agree
that well compute one we call because of
shots of curing all right so absolutely
that's exactly correct so when I run the
code you can see that compute was not
actually called it said no result well
I'm going to do this a little
differently I'm going to go here and say
if the temp equals compute in this case
and then of course pass the X to it I'm
going to put this as temp let me ask you
this question do you want the compute to
be called right now no do you think
compute will be called right now how sad
isn't it well don't you think that
compute should not be called yes you
said you don't want it to be called
but it's kind of unfair isn't it why in
the world does compute get actually
called in this case
well that's because by default a
languages like Java do Iger evaluations
so in other words the language says look
you call compute I'm going to go ahead
and call it well wait wait a minute why
did it then call it previously why was
it okay to remove that in the short
circuiting it all comes down to one
single thing that's language
specification languages have some
specifications they write down and say
that's what we do don't ask a question
about it in fact it's kind of funny
because when you read the C++
language spec it's very glaring the
simplices language spec really clearly
says even if the constructor were to
produce a side-effect the constructor
may not be called period so languages
make these classes available whereas
mostly languages like Java C++ C sharp
these are all imperative and
object-oriented languages so we do allow
suitability of code in other words
functions often have side effects so
unless specifically documented the
language is fear there will be side
effect and they eagerly evaluate these
things let's step back and come back to
this a little bit later let's go over
here to yet another example so here I am
in Haskell so I'm going to say in
Haskell ad and I'm going to say a B
equals a plus B and I'm going to go
ahead and say evaluate in this case and
the evaluator takes a value and returns
a value then I say main equals in this
case of course and what do I want to do
in this particular example well in here
I'm going to say print and I'm going to
call evaluate and then I'm going to call
add one and two well a very small little
example as you can see and it of course
produced the value of three which is of
course one plus two but the question is
did ad get called in this case well we
can kind of say of course it did because
we got a total of one and two so there
is no doubt about it but how do you
prove it well in the case of Java I put
a little print statement to prove it
sorry I can do that in Haskell because
in Haskell it is a complete opposite of
language like Java in language Java
the default is mutability and you have
to plead with the language and say
please just this one's make this
immutable language like Haskell has what
are called save default language like a
Haskell say everything is pure by it by
default if you want to make something in
P or you have to make a special request
so I can just throw in print statements
anywhere I want to and walk away I won't
be able to do that well so how do we
prove this I never thought I will prove
it by using a debugger so
going to say GHC I which is the
interactive shell I'm going to go ahead
and load in this case sample dot HS and
I'm going to put a breakpoint right now
on line number one and I'm going to put
the breakpoint in character number oh
let's say about sixteen over here so I'm
going to say one and sixteen then I'm
going to call main and clearly you
notice it is waiting for us in the add
function and I'm going to say continue
right now and it says three but to prove
that the code did execute the add
function we'll come back to that in just
a minute but I'm going to go back to
this code and I'm going to go ahead and
change this to evaluate value I'm going
to return off 42 now of course when I
run this code you can see the result is
42 but the question is is ad being
evaluated or not well here's how
half-scale works you go to haskell and
say hey Haskell call ad it says why
because I want to test it to evaluate me
but why because I want to pass a result
to print but why because I want the user
to see the result
oh then just called print well you call
print and it goes in there and says gosh
I need the result of evaluate okay then
go call evaluate and evaluate says
return of 42 well I'm done hey what
about ad well what about it is of no
consequence no use it is absolutely lazy
how do you prove once again let's go
back to the GFCI let's go ahead and load
up this particular code let's put a
breakpoint right there in 1 and 16 let's
go ahead and call the main function and
notice it produces a result 42 it never
hit the breakpoint so that shows us that
this actually never called well this is
called normal order so normal order is a
different from applicative order well
change the word applicative to
invocation or call meaning the order in
which a function is evaluated is the
order in which it is applied called
invoked that is the default behavior and
lot of languages normal order is it
wouldn't call the method when you apply
but instantly will wait until that
method actually becomes relevant and if
that method is not relevant at all it
would completely bypass calling that
method and so this is basically how
Haskell works now how is it that Haskell
is able to do that well the reason
Haskell is able to do that is methods by
default are pure functions functions by
default are pure functions functions
don't have side effect in Haskell unless
of course you specifically mark them
with what is called i/o what i/o is not
input-output I say IO stands for impure
operation so you are saying I'm marking
this I'm coloring this function to say
something funny something smelly happens
here don't optimize this code and
evaluate it in the sequence in which it
is being presented whereas a lot of
other functions are pure so they can be
executed at will are not executed at all
if it's not relevant well that's awesome
that some languages can do this so
normal is actually quite uncommon like I
talked about but some languages are born
lazy I mean when they were born they
were at the beach sitting and having
some nice drink and they were absolutely
lazy from the birth whereas other
languages have to work really hard to be
lazy those languages are kind of like me
I'm always like looking for something to
do and my wife will say when you just
sit down and relax I'm like how do you
do that right so the point is we always
active not very lazy some languages are
like that so we saw the difference
between eager and lazy evaluation but I
want to go a little step further with
this how could we really make use of
laziness a little bit further so I want
to entertain to start a little bit
further in Scala for a minute
so in the case of Scala I'm going to
define a function called compute where
I'm going to say you know value let's
say our number and then I say a number
is a hint and I'm going to go ahead and
say in this case equals and I will
simply say compute like we did a few
minutes ago over there on the other side
so I'm going to I'm going to call the
compute method and I'm going to simply
return the number right in this case of
course I'm going to say X is equal to 4
and I'll say if X is greater than 4 and
compute of let's say X is greater than 5
then I want to of course print out let's
say result otherwise I'll say elves no
result much like what I did that's silly
code in the Java site when I run this
code of course what you notice in this
case is that it is not going to go ahead
oh did I say consult sorry do too much
JavaScript going on so let's go ahead
and say print line of course so in this
case you can notice that I'm going to go
ahead and call this method well
obviously in this case it will not
execute the compute function well it
because of short-circuiting as we know
earlier in our examples we talked about
but on the other hand though well it
does say no result right here ignore the
cat release I'm messing with something
else in this case but you can see if
there's no result it never called
compute on the other hand I'm going to
go ahead and take this code right here
and I'm going to call it as Kemp as you
would see and I'm going to go back here
and say eval and then of course temp is
equal to and I'm going to provide that
now the code is almost exactly like what
we saw in the case of Java with only
minor syntactical differences if you
will well obviously in the case of Java
the code was eagerly evaluated as you
saw a few minutes ago the question is
what about kala
well in this case of course we said temp
is equal to compute and said Scala go
ahead and run this well X is of course
not greater than 4 so when I run this
what do you expect well sadly Scala does
execute the compute method as you can
see now why is that well the reason is
again Scala says I don't have a way to
guarantee that functions are pure so I
can't just keep running functions after
all so I'm going to go ahead and eagerly
evaluate it so what it really comes down
to is the purity of functions yes either
you can guarantee the purity of a
function or if the language requires
purity of functions then there can be
lazy about evaluating it if the language
cannot require purity of function and
you don't guarantee putative
and then it's got to be eagerly
evaluating it unfortunately but there's
always that thing called language spec
so this code as you can see in Scala
simply ran compute and printed no result
exit you can mark this particular
variable with this beautiful keyword
called lazy now you are playing a part
the language spec says if you mark a
variable as lazy you are giving a
bonafide certificate to the language to
say skip evaluating this until you can
no longer skip evaluating it until it's
required or just forget it don't even
execute it so now notice when I run this
code you can see that compute was never
called because we mark this variable as
lazy and because you said it's lazy the
language says I don't have to run
compute I will wait until you actually
use it on the other hand if you notice
if I make the variable X 14 you can see
that compute was actually called even
though we had marked it lazy that's
because of course now that X is greater
than 14 temp is required and Tempe is
actually called just to make the point
clearer I'm going to say here but notice
that compute is being called actually
after the line that hits the here in
this case so again print line and you
can see the computer is being called
after the code hits the print line and
not before so you can see that was very
lazy in evaluating the temp as you can
see so in other words languages can
decide to be postponing evaluations
until a later time how does this really
relate back to what we're going to do in
language like Java
well obviously the question is does Java
have a lazy keyword well it doesn't so
language like C sharp give you a class
called lazy but Java quite doesn't can
create one yourself you're interested
but I'm going to move forward and do
something else I really want to postpone
evaluations but how can they do it well
this is where lambda expressions come in
really nicely
well how does lambda expressions
actually make a
well remember a lambda expression is an
anonymous function so you are getting on
your hand a function and you're holding
on to a reference to a function when you
create an anonymous function now imagine
this anonymous function is like an apple
well I could take an apple and let's say
we have a good friend here or less and I
give him an apple so here you go and
what are you doing with the apple now
okay there you go he just added the
Apple thank you very much he could
certainly do it or he could have other
options too for a minute you notice he
deferred was no nerd no juggling apples
but I could have given him the applicant
three things he could eat it right away
or he could just keep it right there or
he Anthony could eat it little later on
or he could also give it to somebody
else hoping he is not taking a bite out
of it already so those are the four
different options he has he can use it
right away he can use it later he can
give it to somebody else or he could
trash it so essentially the point really
is those are the different options you
get so if you think think of what we can
do with objects we can do the same thing
with functions as well and lambdas are
these function objects if you will so
let's take a look at how that's going to
help in what we want to do so I want to
talk about laziness but before we talk
about laziness let's entertain the start
about how this could potentially be lazy
well in the case of Java they have
what's called a supplier so if you
notice this particular example you can
see the temp was evaluated eagerly which
kind of sucks but what I'm going to do
instead is I'm going to turn the
temporal into supplier of integer temp
and then of course I'm going to go ahead
and do something a little different
watch this one very carefully right now
I am going to just copy and paste this
so you can actually see the way this
code is evolving so here is the temp
right now but I'm going to change it to
supplier of integer and of course in
this case I'm going to take this part
right here and I'm going to do one
little operation to it but before I do
that operation I want to say probably
the most profound statement ever that I
have become a
for us in our field is profound a
statement is the following words by
David wheeler there's not a single day
that goes by when I don't think of those
words and I don't appreciate his words
because I think this is the most
fundamental thing we all benefit every
single day and that is in computer
science well that's what he says in
computer science almost any problem can
be solved by introducing right by
introducing if I don't know how to type
introducing there we go so introducing
one more level of indirection so almost
not all but almost every problem in
computer science can be solved by
introducing one more level of
indirection this was the words of David
wheeler and I think that is absolutely
phenomenal because this is what we do
every single day when we program we
throw in another level of indirection
notice what I'm going to do in this
example here is the call to compute
let's introduce a level of indirection
and there we go we just did so we
introduced a level of indirection or
rather than calling compute right away
call a lambda which in turn will call
the compute so that is the level of
indirection we introduced then I can say
temp dot get over here and then of
course when I run the code this time you
can see that it did not call the compute
method anymore because we passed the
lambda but the lambda was never actually
evaluated until the lambda is actually
needed and in this example it was
actually never needed at all on the
other hand if I were to go back here and
put 14 here well clearly we would need
to evaluate it at this time and you can
see the compute being called right now
so it postpones evaluation until the
point when you can eliminate calling it
completely or call it later on when it's
needed so we brought the Java code back
to what Scala was able to do not by
using lazy like we did in Scala but by
using the supplier here
Java and then moving that into a level
of indirection and using of course the
lambda expressions so what I'm getting
to is why a lot of languages do not
support laziness question yes please
right you bet you so you would have to
do a little bit more work you would have
to do a little bit more work in that
case so in this example it would revile
you ate the get the lazy wouldn't write
that's why Java doesn't support lazy but
you can use this as a building block to
build even further there are several
people have written about it I've also
have a blog about it how you can use a
supplier to build your own lazy you got
to do a little bit extra work to create
laziness in Java but it's not too
difficult to create one so what you
could do is you could create a class
called lazy kind of like what c-sharp
has done and then you could say when you
call me I will cache it the first time
you call it and I'll return the value
after that you can definitely build it
suppliers don't do that by default so
really good question absolutely you
don't get that for free in the case of
Java I wish we did but not so but we can
easily build one to your point so so in
this case of course one of the beautiful
things about this is you are getting
laziness in languages for free but in
languages that don't give you laziness
but do support lambdas you can go
towards laziness by building using
lambda expressions so in other words
what I'm getting to is lambdas are
pathway to laziness and and that is one
of the really beautiful things as with
lambdas you can achieve laziness that
you won't be able to get a lot of
different tools and frameworks and
libraries rely on this idea very very
you know important because lambdas give
you the pathway to laziness but please
don't assume just because we're using
lambda that we are actually lazy the
language of the library should actually
make use of it not all languages in
libraries do but thankfully Java does so
Java says I'm going to take advantage of
laziness when you give me lambdas and
we'll see how that that is so in just a
few minutes so let's take a look at one
example of this I'm going to take a
problem and solve it using the
traditional approach and then I'm going
to show you how we can solve that using
the lambdas and functional style of
programming then I'll bring out a
concern with the program and see how
laziness saves our day so let's take a
look at an example to begin with I'm
going to start with a list of numbers 1
to 10 and my problem says find the
double of the first even number a
greater than let's say 3 so I want to
find the double of the first even number
that's greater than 3 now in this case
I'll say result is equal to 0 and I
output the result at this point then
I'll say for int I equal to 0 are let's
say element in numbers and then I'll
simply say if element is greater than
let's say element is greater than 3 and
element mark 2 is equal to 0 then of
course the result is equal to element
times 2 and I have to break out of this
particular loop right here well it tells
us the result is ade but unfortunately
though that's not entirely true because
if you notice this code there are times
when the collection may be empty the
collection may not have any even numbers
at all the collection may not have any
number greater than 3 in all those cases
the research should have been
non-existent but unfortunately the
result is a 0 which is incorrect
so the problem first of all is this code
is verbose this code is noisy this court
requires imperative style it uses
mutability you have to sit there and
tell every single detail in this code so
a lot of negative with all that negative
it's even worse this code is actually
wrong but the beauty of this code is it
is very familiar you can pretty much
grab anybody off the street who knows
Java show them the code and they are not
going to freak out when they look at it
right it's common it's very familiar
however be
before we go further we want to get rid
of this ceremony what are the things we
want to remove you want to remove the
mutability we want to remove the
imperative nature we want to write the
code in a functional style so how do I
make this chord into functional style
well I'm going to go back here and write
this again but this time I'm going to
say numbers dart stream well stream is
an internal iterator an internal
iterator rather than using an external
iterator as we saw here then I'm going
to say dart filter and give it an
element element is greater than 3 now
I'm saying given all the elements give
me the elements that are greater than 3
and then of course I'm going to say dart
and in this case I'll do a map given an
element element in this case times 2 and
then of course I'll say find first I
just want the first element and then our
else just give me a 0 intentionally in
this case I want a 0 if I don't put it
it'll give me an optional rather than
giving the 0 giving the value itself so
in this case we got the same result as
the other one however I'm going to make
a small change to this code and then
argue about some of the differences 1 2
3 5 4 6 7 so keep in mind the sequence
of numbers I have 1 2 3 and then 5 and
then 4 and then 6 7 8 9 and 10
when I run the code again both of them
produce well should produce the same
result in this case as ended so in this
case of course I'm filtering I forgot
the even numbers didn't I so filter
given ie Emaar 2 is equal to 0 so both
are giving us exactly the same result as
you can see in this case ok great so we
have the code doing the same stuff but
wait a minute are we really having
issues at our hand let's talk about the
advantages before we talk about more
specifics look at the code in the top
for a minute that's an imperative style
cobia looping through and going through
the values and telling everything every
single step of the way while the code in
the bottom on the other hand
and he's a single pass through given all
the numbers yet the only numbers greater
than three then get me only the even
numbers then get me the double of the
values but pick the first one and then
return to me zero if it doesn't have a
value but wait a minute how much is the
cost of executing the code in the top in
terms of computations well before we
answer that question let's go back and
do this a little differently let's go
ahead and say public static and I'll say
boolean he is greater than three in this
case let's say number and then I'm going
to say return number right now and then
similarly I'm going to go ahead and put
two more calls in here well this one is
going to be again a boolean but I'll
call this one as YZ even and then of
course in this case I'll say mod 2 is
equal to zero whereas here of course
it's going to be greater than three and
then finally of course I'll change this
one to say a dub of course I'll call it
as double it and this is going to return
number times two well I'm going to use
this code in just a minute so go up here
and say instead of e greater than three
I'll say e greater than three the method
call similarly instead of checking this
right here I'll call is even and pass
back and finally I'll go ahead and say
double it and pass this as well so I'm
just changing the code to use those
methods well this gives a little bit of
a clarity on the computation itself but
remember the code we have with us is
going through a int one two three five
so let's see how many computations this
is going to perform when we give that
series well in this case is one greater
than three well the answer is no well
he's still greater than three no is 3
greater than 3 no is 5 greater than 3
well it is is 5 even know if 4 greater
than 3 is 4 even and then double it well
that was eight computations to do the
work so we can say that given this
particular example this code took 8 con
mutations to do the work well that's
great but what about the one in the
bottom well let's be very naive about it
without thinking much this is a
collection of ten values we're asking
each of the value is greater than three
oh my gosh that's ten computations
dead-on-arrival isn't it because eight
computations there was ten over here but
to add insult to injury this is going to
be asking if the numbers are even that's
seven more values being compared ten
plus seven is 17 plus of course we're
going to double the values left that's
four more values because there are four
values which are even in greater than
three and that becomes seventeen plus
four which is 21 so that's 21
computations compared to eight
computations so eight versus 21 well
you're going to say wow that's about
three times more work you're going to do
but notice how beautiful this code
really is are you going to say get out
of here we're not going to give you
three times more price because it looks
beautiful because we want performance of
this code well that's a fair statement
so oftentimes when you look at languages
like Ruby languages like JavaScript by
default or even groovy that's exactly
what those languages do is they do all
that extra work so for doing functional
style you are compromising on
performance it may not be a big deal if
the collection is a small one but let's
go to this and see what's going to
happen now you go back to this code and
you add more values to the end over here
in this example well the imperative gold
is still sitting there at eight
computations while the functional code
may have to do a lot more work now and
then you kind of wonder is this really
true that we want to really explore it
but thankfully in a lot of different
functional programming languages and
even though Java is not truly a
functional programming language even in
Java
what I said so far is not actually true
in this example well why is that and the
reason is the streams in Java are quite
capable and different well what is water
streams do in Java that we don't see in
lot other languages what a stream do in
Java that we see generally in functional
programming languages well there's one
character of stream that I've only seen
among my own children they both are lazy
to the bone so they don't actually do
the work when they are told to do I'll
share with you an experience that I also
noticed at my home or I know about so my
wonderful wife and I have teenagers well
if you have teenagers you know what I'm
talking about
if you don't have teenagers if you wear
teenager at one point you know what I'm
talking about teenagers are lazy to the
bone so my wonderful wife will tell my
son she would say turn off the TV it's
as if no words were spoken because
nothing really happened then she would
tell him you know take the trash out
nothing happens then she says do your
homework nothing happens then she says
I'm calling daddy and everything happens
so the point really is these are lazy
evaluations so when you go to the stream
and say hey stream go ahead and filter
it says and never mind filter again as
some other day Matt maybe and then you
say fine first and bam it's done I mean
they could have renamed the fine first
just called daddy
that would just work fine or called
mommy depending on the family but the
point really is the evaluation is
postponed so there are two kinds of
methods available in these languages
these methods are called intermediate
operations and the intermediate
operations are fused together on the
other hand the one in the next world
line is called a terminal operation and
it's a terminal operation that triggers
the evaluation of the intermediate
operations and not otherwise so to prove
this point let's go ahead and comment
out the functional style code for a few
minutes let's only keep the imperative
code
I'm going to go back in this case and
say he is greater than three plus number
but before I go I want to emphasize
these kinds of operations are pretty
much really bad idea you want the
functions called within lambdas or in
other words you want the land us to be
pure in other words lambda should not
have any side effects so don't do what
I'm showing you here I'm just doing it
here to illustrate for you know
illustration purpose but in production
code we should never make these
functions impure the functions that you
call within lambdas and the lambdas
themselves have to be pure that's very
important well now that we talked about
that let's go back and drop these things
here and I'm going to say is even right
there I'm going to say double it and now
I'm going to go ahead and run the code
and notice the number of operations we
performed it is eight operations this is
the imperative code again one two three
four five six seven eight operations
later we got the result so that is the
imperative code but I will comment out
the imperative code and uncomment the
functional style code but before I run
let's understand how this actually works
what it doesn't do is it doesn't take
one through ten in that sequence and
then pick all the numbers greater than
three and say here you go a list of all
the numbers greater than three it
doesn't do that in other words the lines
that are highlighted do not work on the
entire collection instead what it does
is it takes the first element one and
says go ahead and run this one through
and the one says okay a thank you for
calling and it says one is a greater
than three no 1 is not greater than
three so one will fall out right there
it takes two again and says try it two
is not greater than three it runs out
takes three next three is not written
entry it takes five next five is greater
than three five is however not even so
five builds out to the second or then it
takes four well four is greater than
three four
even it performs a double of the four
and the four arrives at fine first and
find first days oh thanks and as sort of
fine first days thanks the rest of the
code says gosh looks like we are done
there is no reason to touch any of the
other variable values so in this example
it will never evaluate six and later
because it has obtained the value up to
up through four there is absolutely no
reason for it evaluate four and laker
and it's going to be very lazy about it
to prove that of course let's go back
and run this code right now and when you
run it you notice in this case I'm going
to call these methods now so we can do a
comparison so sample in this case is
greater than three and then of course
I'm going to say sample and then is even
and finally I'm going to say sample are
double it but notice now when I run this
code it performs exactly the same number
of operations as the other piece of code
dead exactly eight computations but more
important note is it never touched the
value six or later so you could go off
and add more data to the end of that
sequence but you will be guaranteed it
gets off as soon as it finds the answer
it is absolutely lazy in fact to really
understand this laziness a little bit
further let's go explore something a
little different here I'm going to go
ahead and remove all of these for a
minute and then I'm going to simply say
output right here done and then of
course when in this case when I say done
right here and whenever execute the code
you can see it performed all those
operations and then finally it said done
however notice in this code we performed
all the intermediate functions and then
the terminal function but what if I am
going to stop this code but one shy of
the very last line so I've moved the
find first from the sequence of call I
did the filter the filter of the map but
I did not do the fine first what is the
code do that
or now behaves like some employees you
know at work they come to work in the
morning they look around and say hey
where's the boss and you say oh the boss
is out sick today yes I don't have to do
any work then well after all if there's
no terminal method why waste the time
and if we're doing the work so in this
case notice when I run the code even
though I have the filter and the map
available here all it did was do done it
did not actually do the actual work
because the map and the filter were all
just lazy methods it didn't have a
reason to actually evaluate that method
so I just completely ignores that and
says never mind I don't have to do all
that extra work because nobody actually
cares in a way if you really think about
it it's like you and me right your boss
calls you on January 15th and says I
want you to work on this project and
your report is due on April the 15th so
on January 15th you got this new project
the report is you want April 15 so you
get out of the office and you start on
it immediately right of course not you
are going to start on it promptly on
April the 14th if you're like me in fact
if you know secretly
that you're going to quit on April the
1st why in the world would you work on
this project anyways right but on the
other hand you know how some bosses are
really boring the boss says this is a
new project for you on January the 15th
and says you our final report is do you
want April 15 that word final knows
what's going to come Nate later is going
to suck because the boss says your final
report is due on the 15th of April but
an interim report is due every Friday
that life sucks you got to work
something every week then because
there's a report due every Friday the
mouth of the story there is if a
function has a side effect you cannot be
lazy if a function does not have a side
effect the only way people will know
what your function did is by looking at
the final result because it never
changes the world around it during its
execution so in other words when you
think about functional program
when people say immutability is very
important to me
immutability is like vegetables' you
don't convince children this is
important by telling them eat your
vegetables because who wants to
immutability is like vegetables so when
we go to programmers and say you need to
do immutability they're like get out of
here we got other better things to do
but why do we care about immutability
because if your code if your function is
immutable if your lambdas are pure then
your execution can be postponed to a
later time you can obtain referential
transparency in your code you can have
memorization in your code without
immutability you cannot have any of
those so lazy evaluation cannot exist in
the presence of mutability in other
words this evaluation is going to exist
only if you can guarantee immutability
in your code that's one of the reasons
why immutability becomes so important
there are other reasons of course but
these things cannot exist without having
the possibility of immutability that's
one of the reasons why it's critical so
in other words what we talked about
right now is that we got some really
good benefits out of our hand so what is
it we start with immutability and what
are the mewberty gives us it gives us a
referential transparency now what is
that preferential transparency really
mean referential transparency means that
the value of a function can be replaced
for that particular function or
expression languages like Haskell do
this phenomenally well I was blown away
by Haskell one day I was working with
Haskell I made a call to a function that
function involves a lot of work and it
took a good 15 seconds to run and at the
end of the 15 seconds plot that also
showed up and I said ok that's great but
for whatever reason I said run it again
and when I ran it again Haskell came
back with answer like what I'm like whoa
how in the world can you give me the
result instantaneously when you just
took 15 seconds to run that's when I
discovered what Haskell was up to
skill automatically can store things
into a tongue and then we evaluate that
value and give it to you rather than
executing the entire function but
language is able to do that because
there is a guaranteed purity well when
it comes to Java Java does not guarantee
purity when it comes to regular
functions
hey what about lambda expressions does
Java guarantee purity of lambdas Java
does not guarantee purity of lambdas but
I believe Java does something even
better than guaranteed Java assumes that
lambdas are pure
I love languages that assume like that
because if you and language are in
disagreement you know who wins right the
language always wins so the language
says you're on your own if you're
messing with stuff written within
lambdas I will not warn you I will not
give you a error and things will sail in
unpredictable ways so you and I have to
guarantee that lambdas that we write and
the functions we call from lambdas are
actually pure that's our responsibility
in languages like this but as you can
see Amir already gives you a referential
transparency immutability gives you
ability to do memorization where you can
store the value and then reuse the value
eighty number of times you know by just
returning the computed pre computed
value for the same input that's because
your functions have the ability to give
you the same output as long as the input
is the thing but we also have the
ability to perform laziness and of
course there's another benefit of this
which is easy and the safe of
parallelization so in other words we
cannot we cannot have laziness without
immutability but the minute you bring
immutability you got all those benefits
but what about laziness what's the
benefit of doing that well if you're
lazy you can be very efficient so in the
when you say the word la zy in Java you
pronounce it as efficient because you
get efficiency from it more than
anything else but there's one other
benefit of late
not that you get also that is a very
charming feature and that is infinite
streams and so you can see how one good
thing leads to another good thing and
you are moving towards something little
bigger and better and for a greater good
so infinite streams become available as
well when you are able to move towards
laziness how so let's look at an example
of how infinite streams can help so what
I can do in this case is let's say I
have a collection of values and in this
case I'm going to go ahead and say let's
say a write a function and the function
I want to write is the following
I'm going to say a call a function let's
say output and I'll call compute with N
and K we'll come back to that in a
minute to see what it means so n is
equal to L 51 and let's say K is equal
to let's say 142 all right some random
numbers but what is compute going to do
well I'm going to say public let's say
static double compute which takes the
end and takes a K well in this case I'm
going to say something along the lines
of return be a total of square root of
all even numbers let's say starting us
all not all K even numbers let's say
starting from n well I want to return
the total of square root of K even
numbers starting from n how would you
write this code in the imperative style
it's going to become a total mess very
quickly isn't it because you're going to
say int index is equal to n in the count
is equal to 0 and then you say in this
case a double a result so you're going
to say double result is equal to 0 and
of course you want to return the result
when you are done with this whole
computation but then you're going to say
while in this case count is less than K
then you're going to say in this case
you're going to increment the value but
you're going to say if the index mark 2
is equal to 0 well then you're going to
say well result is plus
equal to math dot square root of that
index but then that's not we're not done
we ought to increment the index so
you're going to say count plus plus to
increment account index plus plus to
increment the index but look at this
code how complex it becomes very quickly
you got to increment the count in the
inside the F you got to increment the
index outside if you get it wrong it's
going to be wrong and most likely I got
it wrong already right any problems
yeah you could use the for loop but then
how do you know how many to go you got
to keep skipping also right but the
whole point is whether you're using a
four or a while it is complex and you're
going to stop and think about it and say
is this correct is this what I should do
is the boundaries correct but the
question is why bother we can do a lot
better than any of those now that we
know how we can use functional style so
we're going to use a lazy evaluation
because we're going to create an
infinite stream so how do we go about
creating an infinite stream to do this
job so 19 22 it says well we don't know
whether it's right or wrong but
nevertheless let's try this return
stream where stream comes from the
java.util stream a package so I say
stream dot eat correct starting with the
end given an element element plus one
well that gives you an infinite stream
right out the back so we are starting
with n n plus 1 n plus 2 n plus 3 n plus
4 but the beauty is this is lazy
evaluation it will not evaluate this
lambda expression until you demand for
its value then I can say well things but
I'm going to filter and I'm going to say
given an element element mark two is
equal to zero well that becomes only the
even numbers I'm interested in then I
perform a map to double and I'm asking
format square root and I'm asking for
the square root computation then I say
limit to K and then perform a sum
operation on the result and return the
result from it well notice how we're not
dealing with for loops or while loops at
all the loops
and the boundary conditions and all that
stuff life becomes very easy thanks to
lazy valuation which leads to the
ability to write infinite streams well
we are not explored infinite streams as
much in our programming with language
like Java because mainly we never had
those capabilities until this point or
at least not so easily expressive and
fluent until this point but just use a
phenomenal benefit of making the code
very highly expressive even as a user
for loop even if I used a while loop I'm
going to look at the code and stare at
it and say how does this work going back
and forth this becomes a single pass
through the code given all the values
starting with n only get me the even
numbers get me the square root of the
even numbers but only get me K of them
and total ed and that becomes highly
expressive as you can see you don't have
to work that really very hard to get the
code to produce a result you are
interested in and of course we can't do
this if you did not have laziness
so laziness leads to the greater good
again you can efficiency in code but you
also have infinite streams available to
you also those are the benefits you get
if you are interested in downloading the
code examples I showed you you can
download them from the website I hope it
was useful and I hope you'll be eager
about being lazy thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>