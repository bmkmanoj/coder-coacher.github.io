<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Prepare for JDK 9! by Mark Reinhold/Alan Bateman | Coder Coacher - Coaching Coders</title><meta content="Prepare for JDK 9! by Mark Reinhold/Alan Bateman - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Prepare for JDK 9! by Mark Reinhold/Alan Bateman</b></h2><h5 class="post__date">2015-11-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/KZfbRuvv5qc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right welcome this talk is called
prepare for JDK 9 it's one of four
sessions that we're doing at devoxx this
year
prepare for JDK 9 is all about going
through some of it some of the big
changes that are happening in JDK 9 and
what the implications of those changes
are we have another talk in this room
later on today on introducing the module
system itself and tomorrow we have an
advanced talk and a under-the-hood talk
plug those at the end and give you the
rooms for those so my name is Alan
Bateman and Mark Reinhold is here as
well he's going to sit this one out
maybe and take take the questions at the
end before I start is in case anyone may
have misread the abstract this is not
going through all the features other
features in JDK 9 this is this is really
mostly about the implications of modules
strong encapsulation what it means for
existing code and so just just just to
get that clear right so before we begin
I just want to have a slide here who's
afraid of the big bad wolf which is
mostly to get a feel for whether people
are a little bit nervous about some of
the changes in JDK 9 so JDK 9 is still a
is still a bit out and but I just like
to get a feel for how close people are
TJ TK 9 so if I could pull the audience
for a few minutes just to find out how
many people are currently on JDK 8 this
is good this I see most most hands up
and JDK 7 a few good few hands - should
I go back any further six very forever
again okay I won't bother with this and
so for those that'sthat's that are
keeping up with the JDK releases I'm
curious to know whether folks have been
tracking the features and changes going
into JDK 9 so a quick show of hands as
to who has been downloading the the
weekly JDK 9 early access bills to try
out the changes ok small number of hands
who has been braver again and has
right the chicks are early access bills
which are JDK 9 plus the module system
has anyone tried them out a really small
number of hands okay
actually I'll ask one last question who
put up your hands if you're nervous
about some of the changes of coming in
JDK 9 that it might potentially break
some existing applications all right
maybe 10% of the audience okay
this is this is the this is really what
this topic prepare for JDK 9 is about
and hopefully we'll be able to address
some of those concerns so just at a high
level some background about what what's
proposed for JDK 9 and particularly
what's happening in in project chicks on
what its goals are it's mostly about
trying to make the Java C platform and
the JDK a lot more flexible and scalable
it's about being able to produce
reliable compact and deployments that
they're suited to run on small devices
or in the cloud it's all about improving
security it's all about improving
maintainability it's all about
encapsulating security sensitive api's
it's all about encapsulating internal
api's which is immediately leads into
reducing maintenance for the JDK and
also reducing maintenance for those
working on on libraries it's all about
as Mark talked earlier on and the key
knows about moving away from from
undressing at least some of the problems
related to to jar hell in the classpath
it's also about enabling a whole bunch
of other potential optimizations and in
the platform in the in the future so
they're just high-level goals for both
JDK 9 and and what we're doing with
modules the modularity landscape I just
want to get that on the table first so
that it's clear what's going on because
there's all these numbers and what GSR
numbers in the JCP and there's also all
these these these Java enhancement
process are jets that are going on in
open JDK so within within the Java
community process there is GSR 376 which
is the Java platform module system that
is the GSR that is going to define the
module system for Java C 9 and beyond
mark is leading that
jsr which mostly got going earlier this
year there will be another GSR for Java
c9 for the platform itself that has not
been submitted that yet is typically
submitted a little bit later in the
release because it's the it essentially
becomes the umbrella GSR far for the
release so there's no JCP number for
that yet because it's not submitted so
Jr's JCP that's all all the standard
stuff implementation we do all of our
implementation in the JDK now in the
open and improv in open JDK project and
we have a project within open JDK called
project jigsaw and that is where we're
working on the implementation of the
module system that's where the reference
implementation for jsr 376 will be
defined there's a whole bunch of these
Jets these Java enhancer proposals and
the listed some of the I've listed all
of the numbers for the for the jyp's
that we have here
Jeff 200 is the is the JEP that is about
the JDK marginalisation Marcus showed
spaghetti diagrams at this morning in
the keynote
I'm sure if folks of F I've seen some of
the spaghetti diagrams from other
conferences and previous dev oxes so
we've been working on for a long long
time in the background on the module
ization of the jdk and Jeff - Jeff - 20
s where you get a lot more information
about about that Jeff - one is is about
reorganizing the source code and the jdk
build around modules so we've got a
module graph now we're able to translate
that into a source code layout and also
completely change the JDK build so that
it builds everything as modules so it's
very much an inward-looking
Jeff and something that we got in over a
year ago in into gdk9 builds everything
is organized by modules built my modules
and that's really really good Jeff - 20
is about the modular runtime image I
have a couple of slides later on this
because this is somewhat of a disruptive
change which is about changing how the
the JRE and the JDK look the layout of
them because modules completely blurs
the historical distinction that we've
had between a runtime and an SDK so a
few slides on that later on Jeff - 60
I'll be talking about it in this deck
here is
encapsulating the the non-critical
internal api's and Jeff 261 is the
implementation of the the module system
that supplements the what the work
that's going on in in the GSR with all
the implementation JDK specific things
so I will cover those last three jets
are the jet 220 and 260 and further on
in in the in the deck so just some high
level and background and on the
categories of the API is in the JDK and
I've talked a bit about GSRs and
standard api's these are the api's that
typically are in the java ourjob x
namespace these are the standard api's
these are the ones that typically will
have have some historical connection
with the JCP maybe they've been subsumed
over time but they are standard ap is
all Java C implementations will will
have those api's there's a bunch then of
jdk specific api's and these
artistically being in the comps on
namespace some of the newer jdk specific
api's that have been defined in recent
years have been in the jdk dot star
namespace now when I when I say jdk
specific API I'm talking about
documented supported api's but they're
only they're only supported within
something that's derived from the open
JDK source space they're not standard
JCP ap is the common son namespace has
historically been this confusing bag of
internal api's supported api's and it's
been a historically very confusing as to
know what what can I make use of what do
I know
what will it be removed in the next
release I have no idea now we put in a
tactical solution for this in in in JDK
8 with an annotation so it's clear which
of these M Khamsin and JDK specific
api's are exported and supported but
this this will be superseded by the
module system in 9 of course there's
then all the unsupported API some of
those are in the comps on namespace
you'll typically see something like
Khamsin and XM xml internal blah blah
blah
if you see internally in the name is
typically jdk internal API then there's
all the Sun dot star and the Sun that
stars being historically and very very
troublesome because people have been
making use of those api's though those
internal API is change over time because
they're not never intended to be used
and that's something I want to talk
about in this presentation so we've dug
out actually mark dug out this this is a
this is this is a page from the
documentation from the we think JDK 1.0
1.1 it's dated at the bottom 1996 and
I'm just going to read out what it
taught what it says about Sun dot star
AP is the Sun that star packages are not
part of the support of public Java
interface a Java program that directly
calls any API since under star is not
guaranteed to work blah blah blah we all
know this and one thing actually to say
is is that documentation is all good
enough but the compiler was changed in
GDK 6-2 to at least emit warnings when
you start making use of these sun api is
on that star api's our other internal
API s-- some folks may have seen those
warnings
some people may do what just ignore
those warnings
I will not poll the audience as to who
ignores JIT compiler warnings so just
some high level just compatible
compatibility policies and this is this
has always been the case in the JDK in
Java C is if an application is only
using supported api's in released in
then it should work on n +1 without any
changes it should not be necessary to
recompile it and I think for the most
part we just this is this is work quite
well there's of course incompatible
changes that the creepy and accidentally
but for the most part this has worked
quite well it's always being possible to
remove supported api's it's not
something that happens very often but it
has always been it has always been
possible it's even being possible to
remove meet major features that was a
policy that was established I think in
in in the GSR for Java C 6
so how do we do with managing
incompatibilities so this is this is at
a high level what happens is it's it's
all about judging risk and judging based
on real data what the possible impact
will be one of the wonderful things
about when the JDK moved to open JDK is
there's lot more eyes on the code
there's a lot more a lot more people
able to spot things that maybe the
original author of the code may not
they're proposing a patch may not
actually have recognized so this is
actually really really good so many
people actually looking at a change
before it actually happens to understand
what the impact is and a lot of people
have are forced to go through a lot of
work income and create and collect a lot
of data and before pushing through a
change because there is the concern
around and compatibility impact
typically what we do at least the
engineers working in Oracle is will
often will often make use of big core
corpuses of code to be able to analyze
and what api's are using and how they're
using and so this is this is just one
resource we also of course look at a
whole bunch of existing products and
libraries to make and to get a better
feel for how things are used before
making changes whenever there is
incompatible changes we do attempt to
communicate them and communicate them as
early as possible so if you go back
through release notes and JCP
submissions for all the releases you
will see that there is communication
about possible removal of of or of of
api's in the future we've not really
removed api's but m8 is an example and
I'll get into this in it is an example
where we've communicated possible future
removal and I'll get into that later in
here and one other thing is this is when
when when we are refactoring our remove
or removing some unsupported api's there
is always consideration given to what
possibly might be using it even if it is
unsupported and and where possible
replacements are provided as well and
then of course there's workarounds and I
don't know how many people ever look at
the extensive release notes that
actually go out with every single JDK
release but there's an
inevitably there is a list of
workarounds for particular changes and
so there may be some change it's it's
it's making the code or the release do
the right thing but there's a
possibility that someone is behaving is
depending on broken behavior and this is
the workaround possibly to restore that
broken behavior this happens on a
regular basis and if you if you ever
studied the release notes and they can
be quite detailed at times then this is
this is often there okay now we get to
the what I want to talk about in this
presentation there's six items on this
slide I'm mostly talking about the first
four the other two are just more FYI and
I'll cover them very briefly at the end
so I want to spend a bit of time talking
about in encapsulation of of internal
api's what that means what the
workarounds are we've had to in in in
our effort to marginalize the platform
which has been in a multi-year effort
there are some a small number of things
that have to be removed features and
methods I want to talk briefly about
those I want to spend a little bit of
time on the binary structure of the JDK
and talk about some other things that
are being being removed before briefly
just mentioning the the version the
version string change and the underscore
so I'll start by showing a graph of this
is this is a graph of the usage of
internal AP is the the x-axis is is the
number of usages of a particular
particular internal eternal class and
the and it's the data set used for this
is is there's a bunch of Oracle products
and there is a bunch a whole bunch of
open source projects that we downloaded
and analyzed so this is there's just
over 100 libraries or use on this
specific data set so what we see here is
that there's a hundred and 25 usages of
some internal class and I'm curious
whether there's any guesses as to what
that class might be
some people are saying on safe at the
Sun misc on safe and that would be a
really really good guess on this
particular dataset that's actually not
quite right and this particular dataset
it's actually son miss base64 encode err
okay we stack the deck maybe here but
these are examples of what originally
meant to be into were in JDK internal
classes and this in this is a data set
sun misc base64 happens to be the one
that's that's used more than some misc
on safe I know if I use a different data
set it probably this would get reversed
if anyone wants to guess what the number
three will be anyone want to guess what
the third one would be it's don't hear
any guesses so and well the in this
particular data set the third one is
happens to be base64 decoder okay what I
want to get into here is is well there's
a couple things to say about this graph
is that and there's there's a small
subset of the internal classes that are
clearly used a lot and there is a big
long tail of internal api's that that
are used by only a small number of
libraries once once I go right down to
the end of the graph here I'm seeing
only one or two usages of specific
internal api's now what has been
proposed is is to try to at least
categorize the usages of these internal
api's and there's essentially two
buckets the non critical and the
critical the non critical are the
internal classes that did not appear on
that last graph there's little or no
evidence to show that they're used
outside of the JDK also in the
non-critical buckets are classes that
are clearly used for convenience I would
put some miss base64 encode or and
decoder in there so one there is since
at least since Java CH there is Java
util Bay 64 and there's an encoder and
decoder there is no reason for any code
outside of the JT
kay to be using the Sun miss base64
encode or decode her classes they were
just being used for convenience there's
there's dozens of base64 encode or
decode her classes out there just on
that one we should have put in a basics
for AP ie 10 15 years ago and it would
have avoided the the dependency on this
so that's the non-critical ap is the
critical ap eyes are things like Sun
Muskaan safe which is functionality that
is completely impossible or at least
really really difficult to implement
outside of the JDK something like one's
large parts of some Muskaan safe you
could they could not exist outside of
the JDK because they're so tight to to
the VM so this is the high level split
between what we wore has been proposed
as the non-critical and the critical and
the jib 260 proposal is is as summarized
on this slide it's it's encapsulating
all the non-critical api's so the
non-critical are the no evidence of
usage are they're probably only used for
convenience encapsulate any critical ap
is for which there is already a
replacement in innate I see there's a
courage return has ended up our in the
in this slide here ignore that so if
there's if there's already a replacement
in age there is no need for that to be
that that can be in cat can be
encapsulated in nine and the important
thing and this is this is this is really
important for those that are dependent
on the Sun Miskin and some other
critical API is is is that we're not
proposing to to encapsulate these
internal api's in nine what we are
talking about doing are proposing to do
is deprecated them and then have a plan
to remove them in intend in addition for
any of the there will of course be some
bit about the world walk round and I'll
get get to that in a couple of slides
time to be at least be able to get at
these encapsulated api's via some
command-line option
so that is what the high-level proposal
in this inject 260 is about the current
proposal lists the following classes as
critical internal api's Sun Miskin safe
is there of course there's there's the
support for signals and that is
something I think we can look to define
standard API for what there is code that
uses it some is cleaner there is code
out there that that makes use of that
particularly around trying to forcefully
free buffers and on unmapped
map files this Sun reflect reflection
get caller class there is a stack
walking API that is being proposed for
nine and but there is a lot of code
logging libraries for example making use
of reflection cat call or class so
that's proposed as a critical API and
then the summer reflect reflection flag
tree which is something that
particularly serialization or D
serialization libraries are going to be
making use of because they're doing
things like trying to allocate objects
for running constructors and and other
things like that that are just not
possible in the java language so that's
what the current proposal is inject 260
and when this Jeff was published one of
the things that were said is is is that
if anyone wants to proposes additions to
that list then come forth but bring data
with you to be able to justify why it
should be not and not encapsulated in
JDK 9 so so far there hasn't been too
much feedback on this I think people
people have been mostly pleased at least
some misko on safe and some reflect
are not proposed to be encapsulated and
that covers very much the some of the
core and critical libraries that people
depend on or transitively depend on but
if there's order things that should be
added to this list get the data come to
the jigsaw dev list with them with that
data to back up the proposal now I'm
going to go back to the to the slide on
the I'm going to go back to the data
that backs the the the internal API
usage that we had a few minutes ago now
hopefully this is a little is isn't too
small
this is from the data set that we used
to create that graph this is the api's
that are used so we see the basic c4 and
basic c4 encoder and and some Muskaan
safe at the top and then we see this
long tail these are all color-coded my
apologies for if the color is hard to
read but and orange is the critical API
so there's a C against any any of these
internal classes that that are critical
so the Sun Muskaan safe the Sun reflect
reflection factory the API is that
illicit on the last light appear in
orange on this slide the non-critical
api's are the ones that are that are in
that are in purple and against them is a
release number for which release there
is an API available so I mentioned about
some miss basic Steve I mentioned about
Java util base 64 being a new API in
Java C 8 then that is the reason why
some mystic 60 64 base 64 encode or and
decoder have our age against and there
is a release age that has that supported
API so there's no reason for the some
miss KPIs to be to be encapsulated
there's a bunch of bunch of API that are
listed down here that are that are non
critical so the ones that are in red are
the non critical where there's no
replacement plans because probably we'll
just used for for convenience there's a
whole bunch of of internal XML classes
within the the Jax PM repackaged
implementation that are being used by
some libraries there's no plan to
provide and these no plan to make
to designate these as as critical api's
so that's just that the the the classes
for this hundred hundred and ten
products that were actually and
libraries that were use for for this for
this analysis now I want to move on and
just talk about how do you find the the
JDK internal usages so we have a tool
it's it's that does static analysis and
Jade EPS tool we're going to use that in
a number of the presentations on modules
tomorrow and I'm curious whether people
have used our familiar have let me just
quickly just poll have people are people
aware of g-dubs okay I see a small
number of hands okay J tips is a tool
that does static analysis of jar files
is a simple way of putting it
the tool is there in jdk age we put it
we develop this as part of JEP 162 to
provide a simple way that you can run
this tool on on your on your on up on
essentially a class path of jar files
and find out what API is they're using
it can tell you what internal api's are
using it can find out what the
dependencies are between different jar
files there's a whole bunch of very
useful options so if you haven't tried
out Jade EPS and you are and you have
JDK 9 at least try it out are such a
decay age then then try it out because
it's really really useful we've improved
a lot Jade EPS in in JDK 9 and we have
improved yet again in the jigsaw bills
where we have a whole bunch of other
options that will actually aid people
and creating a module just and
declarations so Jade EPS is a
command-line tool there's also a the
maven folks have a Jade EPS plugin that
is useful if you're using if using maven
so you can have it run in your build to
look at the the your artifact to see
does that have any dependencies on any
internal api's you can also have it have
it run on your transitive dependencies
to find out whether there's any library
that you're using that that that might
have a dependency so the option that I
want to show on the next slide is the
option JDK is is called JDK internals
the example I'm going to run this on is
I've just taken one of the jar files
from the GlassFish for that one
distribution and the option I'm I'm
passing is Jade EPS and then jdk
internals which is a special option to
report internal jdk internal API usage
and then I'm just giving it the name of
the jar file there's a whole bunch of
ways that you can actually run and j-dub
see it's been it's become a little bit
of a Swiss Army knife of
static analysis tools I'm just picking
one usage for for this slide now we go
and look at the output and we're going
to switch to a smaller font to be able
to see the CC the output of this jar
file so what we have is the output is
showing me what the code in this jar
file depends on and it's listing me out
that there's code in there depends on
Java based Java basis is is the core
module of the system it's where
java.lang an object lives we beginning
into that in the other presentations
today and tomorrow and then it lists me
a whole bunch of other classes in this
jar file they're all in the package
comes on Enterprise something and they
have dependencies on internal api's in
this case these this the code in here is
clearly making use of a lot of sun
security x.509 and x and and sun
security util so this these classes are
part of the internal security framework
for in the security libraries part of
the jdk and they're being used by code
in this in this jar file it's for you
can see there over on the right where
it's flagging them as jdk internal API
and what what module there in so there's
a lot of code and here that's making use
of internal API s-- one other thing that
the tool does is it has a small little
database that goes with it that gives a
mapping to supported or newer api's in
this case someone that's using the X 500
X 500 name type which is in some
security x.509 well maybe there's a way
be that code should really be using
there's an X 500 principal that has been
in the platform since Java C 1.4 so it's
providing a mapping there when it
recognizes that there's a possible rip
in standard or JDK specific replacement
for that then it will actually print
that out as well so this is a useful
tool to at least give hints this it may
not be easy to refactor the code here
too to make use of of x500 principle but
at least this it's making folks aware of
it so that is a static analysis of one
jar
file to show and with jaidev's to show
how you can find out what internal api's
are being used I want to actually show
what happens I've run time if you start
making use for starting up GlassFish in
this example and it starts to run some
of the code in this jar file what will
happen so assuming we have not compiled
in a glassfish for for running with
modules in jdk 9 suppose we've just
we've kept whatever it's compiled with
seven or eight and we try to run us what
will actually happen and this is what
happens in this specific case we get an
allele access error it's it looks a
little bit scary when you see at first
but illegal access error is it would be
if you had typically illegal access
error means that you've got some kind of
a mismatch between your compile time and
your run time it may be that you're
actually have a reference just something
something that's private but was
actually public when you compile it for
example and and modules has that that
effect will be talking in the other
presentations about what the what what
it means to be public and whether
whether a public type is accessible or
not but with with encapsulation of
internal api's you may have public types
in these jdk internal packages that are
public but they're not accessible so
this code in this jar file is attempting
to access in this case sun security
provider policy file will actually get a
legal access error when it attempts to
access that type there's other
information in this exception to
indicate what module what modules are
involved ignore some of the details for
this to be going through in the other
presentations on modules how to how to
read these exceptions a bit better so
that's just one example from from from
GlassFish to show what would happen if
you ran this code with strong
encapsulation I'm going to pick a second
example and I'm sticking with the jeez
I'm going to just pick Gradle this time
and I've got a compiled Java task that
I've got I'm going to run and actually
fails when I try to run us with my what
my
so bills why is this I've I've
highlighted the error in red here it
says could not create an instance of
type comps on tools Java C API Java C
tool when I look at this first it looks
to me like Gradle is unable to launch
Java C for some reason what's going on
here what Gradle is useful in that you
can get a lot more information by run
rerunning it with the - - stacktrace
option and it should give me a lot more
detail as to what exceptions are being
thrown so I'm going to rerun Gradle
again this time with the the stack trace
option to try to get some of the
exception I've removed most of the
exception here and I've gone straight
down to the bottom of the stack trace
which is where I actually see the cause
of the exception in this case it's a
legal access exception the previous
slide I had an illegal access error
which is I'm attempting to resolve and a
static reference to some type in an
eternal package in this case there's
clearly some code in Gradle that are
that is using core reflection to get at
some internal type in this case it's
it's some internal type in in Java C the
Java compiler so the again the exception
is explaining what is going on here it
says this is an internal type in the jdk
compiler module someone outside of that
in this case it's the unnamed module is
is attempting to access that we explain
in the under the hood talked all about
on unnamed modules so this may all look
a little bit scary this is this is what
this is what this is the implications of
strong encapsulation it means existing
code does it that it's making use of
internal api's now suddenly stops
working but don't panic I want to I
wanted to out the command line option
that to at least be able to get code
that is existing code to work at least
by just adding to the command line so
the option we have in our current jigsaw
bills is called X add exports you
essentially give it the
of these internal packages that need
that you want to be exported to have
some existing code continue to work it
might look a little bit the option here
might look a little bit for both what's
going on here is is there's the the
source module the package and and who
it's being exported to it's all it's all
in capsule is is is all encoded in this
command line option in this case in
order to run GlassFish and we can bring
up classes just fine with with with our
jigsaw bills but we have to give it the
X exports so that these internal
security classes that the the class
which is using our exported are at least
in an exported package so the GlassFish
continue to continue to work exactly as
it did previously
now the GlassFish folks are our friends
i know i didn't didn't want to pick pick
on them for just for this particular
presentation they have been testing for
quite some time with the jigsaw bills
and they have an issue in their juror
that actually tracks addressing this
issue and there's I think about 10
different different issues that they
have in their JIRA some of them are easy
to solve some of them are not easy to
solve but this but the good thing is is
is is that by like least working working
with the early access bill finding these
issues finding solutions of these and
particularly some of these old code then
it's it's it's it helps get them in a
much better place so they can actually
run online win-win 9 eventually ships so
X add exports is the option essentially
what it does is breaks encapsulation
this is this is the this is the syntax
of it source module package equal to the
target module and you can you can list
this many many the option can only be
listed once but the value can encode
multiple multiple source modules
packages and targets so that is what
encapsulating most of the internal api's
means it means that existing code that
uses uses those internal api's and may
not run but put it but there is at least
a workaround to keep existing code going
if necessary
so that's the biggest change that's
happening are the biggest thing that
modules will mean for existing code that
continues to run on the class path so I
want to move on now and just go through
some of the other changes that are going
on and so I talked about just about the
removal of methods so the JDK is
absolutely huge and there are tens of
thousands of methods as thousands and
thousands of classes in the in the
public API as part of preparing the
platform for modules we recognize a long
long time ago that six methods have to
go and these are the six methods that
are we were posing to remove in nine
they have been removed from JDK nine
since the first build so right at the
end of 2013 before even JDK 9 build or
one shipped these methods were removed
so that we would give it maximum time to
anyone that might have a dependency on
those methods to to be able to make use
of replacements in the case of Java util
logging loud manager there there is
there is new methods that replace those
in the case of the four methods and in
the pack 200 Packer on unpacker
we have not found any usage whatsoever
of these outside of the JDK codebase so
there is no there's no replacement plan
for those because we haven't seen any
usage of them whatsoever so this is this
this is these are the only six methods
that were planning to remove from the
standard api which i think is actually
quite good given that given the size of
of the platform in these in this
particular case as I said we have known
about these six for a long long time and
it's been documented they've been
deprecated when when Java C ace which
was submitted to the JCP then it was
these were these were actually flagged
for for as being deprecated and to be
removed in a possible future release so
they're the only six so I think that's
actually that's actually not too bad
this other change though which is the
changing the binary structure of the
jury in the JDK is something that is a
lot more
disruptive so the whole bunch of of of
motivations for for doing this and some
of this will be clear once I show the
show the next copy number of slides what
and a big part of it is moving to
modules will completely blur the
historical distinction that we have
between the JRE in the JDK and some of
the other presentations on modules
you'll see that we're actually taking
libraries we're linking them with with
modules and we're reducing new runtime
images the structure that we have in the
JDK and JRE don't lend themselves for
that and also using jar files is a
really really inefficient and probably
one of the worst ways that we can
actually store classes and resources and
for the platform particularly for for
for startup and some of the
optimizations that we want to want to do
and so this structure is changing the
structure of the GRE is is is a
disruptive change it's something we
wanted to get into JDK nine really early
so it's in it's in Jady Jady canine
builds for about a year now and mostly
to give time for the tools to catch up
because if you're a compiler you're an
IDE your tools that are making use of
RTV are and so on you're depending on
the structure of the JDK
and so changing that structure has
impact on the tools and it's going to
take a while for those tools to catch up
the good news is this is the first time
that we will ever have a supported
interface for accessing classes and
resources in the JDK or that are the
earth the JRE we've never had a
supportive way of doing this before and
now we do and it allows tools running an
eight or nine to be able to access a JDK
nine image which is which is really nice
so just a quick summary on the on the
layout of the legacy JDK image like I
would hope anyone using the JDK will
recognize this there are two there are
two bin directories there's a bin
directory at the top level there's a bin
directory in the Jerry directory you
will actually find the same tools
something mostly in in both directories
that's a little bit strange there's a
little bit of an accident that goes back
to 1.2 there are two Lib directories the
runtime classes are our down in GRE Lib
classes for tools were in tools that gr
at the top level of directory there's
also a bunch of other Java files in
there that make up the rest of the mess
of the runtime and they all have they're
all there all of their history and story
associated with them as to how they
ended up in separate jar files the Lib
directory and other parts of the on
other directories are a little bit of a
have started Lee being a little bit of a
mix of files that are intended to be
changed because their configuration
files security policy files and so on
and a whole bunch of other files that
were never intended to change you can
edit some of the some of the
configuration files in the JDK and it
won't start up you can change it so that
things actually break some of these
files were just never intended to be
documented never intended to be edit it
so we've used the opportunity with
reorganizing the layout of the JDK to be
able address those kind of issues and
what we've moved to which up to 220 is
the new modular runtime image and it's
very very simple layout there's a bin
directory where you'll find all of the
launchers so that's where the Java
launcher is that's where you'll find
Java C and so on there's a comp
directory which is where any of the
configuration files that are intended to
be edited or to customize the JDK or the
runtime that's where those files are all
of the other files that that really are
not intended to be edited they have been
moved elsewhere they're not in the
contract only the files are intended to
be edited or in the conf directory there
is no Jerry directory there's no two bin
directories and and most importantly is
there are no jar files
there's no RTR there's no tools they are
the classes and and and resources that
the JDK is is using it's that are part
of the the runtime part of the runtime
image they are now in this internal
format that's that's that that will
change over time it's in it's it's it's
intended to be optimized very much for
the JDK usage intended to enable us to
do a whole bunch of other optimizations
over the next while mark mentioned about
IOT and linkage to that and we can
optimize things for for for startup we
can do various compression we can do a
whole bunch of order
in between classes and other things that
you need in order to get the footprint
down to run on embedded systems so it
opens up a whole new world to do these
kind of optimizations or over the coming
years so that is what the layout is and
as I said this is in JDK 9 for over a
year now it's taking some of the tools
cut off quickly it's going to take time
for many of the other tools to take to
catch up on this so this is a disruptive
change and and I would hope by the time
JDK 9 ships that the almost all of the
tools will be able to work cleanly with
the the newly the new image layout there
are two features that have been removed
and our miss features is how some people
have described them the extension
mechanism which was a way to drop
arbitrary libraries into the into into
the into the JDK or the JRE and have
them be automatically their types be
visible and very problematic mechanism
that has been removed that has also
flagged in Java C 8 for removal the
other thing that has been removed
Willacy is the endorsed standards
override mechanism most people probably
have not heard of this mechanism it's
more it's it's typically the way that
app servers used to provide newer
versions of standalone technologies and
indoor standards same mechanism for both
so historically app servers would needed
to run with a newer version of Jax B or
jax-ws or the common annotations or some
other standalone technology or endorsed
standards maybe the w3c API are the core
baby is this was the mechanism for the
allow them to to override what's in the
jdk linked to modules opens up opens up
the possibility of doing this in much
cleaner way and in reject our bills we
have an upgrade module mechanism which
which changes the unit of replacement to
be module so if an app server wants to
run with a the e version of the common
annotations the the JDK only has the the
subset of that which is the
version of the common annotations then
that can be packaged as module put on
what we call the upgrade module path and
that will cleanly override and unhide
the module that's that the JDK ships
with so this is a lot better mechanism
so indoor standards may override
mechanism goes away and we have the the
new way to replace the upgrade modules
with with with alternative versions a
couple of other little changes that are
that that are going on and the and these
all these all stem from changes to the
implementations of modules fundamentally
changes a lot of things and our class
loaders are no longer our keys our
application and extension class loaders
are no longer instances of Java net URL
class loader any code that depended on
that and that's very much of a highly
implementation specific that the
assumption that that there would be
instances of this type and they would
break what we know as the book class
path is gone everything is everything is
modules now and so there isn't there is
no way to replace or to to use to
pre-paint classes to put them on the
boot class path those ways of patching
modules a way that we can get into in in
questions on modules but what we know as
the boot class path has been has been
changed very significantly associated
properties with the boot class path are
also they will also go away they're not
quite where it's not not quite there
with the with with the jigsaw builds
what we're 95% there Jeff 261 has all of
the other implication or all the other
possible implications so we've put a lot
of effort into attempting to identify
all these other implementation specific
assumptions that code might met might
make and they're all documented in the
final part are they the end section of
Jeff 261 if you want to google for that
it's it's quite extensive so just to
give an example about for one of these
I'll go back to Gradle and my apologies
if there's any work in Gradle here it's
just just randomly picked this one
because it just happens to be one that
has an assumption in its code somewhere
that the the the application classloader
are thinking actually assumes the system
class loader is a URL class loader which
it isn't when you run with chicks or
bills because are because the code the
application class loader complete are
are completely different from what they
were in previous releases so there is
code somewhere in Gradle that happens to
get a reference to system class loader
and then blindly cast it to a Java net
URL class loader and it gets a class
cast exception this by the way is one
that we're that that apparently is
straightforward to fix in Gradle it's
it's all about some hack that that was
put in a long time ago to work around
command line lengths and limits on on
Windows a lot better way to do that with
JDK 9 because there's arc file supports
you can if you've got command lines
would really really really really large
number of arguments and they won't fit
on the command line then at least you
can put in into a file and do use the
the a dart file syntax so this is just
an example this is one is not really
tied to modules this is really just an
implication of some implementation
change so every single JDK release there
will always be some internal changes and
some refactoring that will go on
something that makes a dependency on
what an implementation type might be is
is is always a risk of breaking so
that's just just just one example so two
final things that I want to cover these
are not core to jigsaw they're not core
to modules there are only things I just
wanted to highlight so that folks are
aware that moving to JDK 9 means dealing
with the version string change so
there's a Jeff on this Jeff 2:23 that um
has a lot more details about this so the
the versioning string format image in
the JDK has always been really confusing
average I've just gonna read out a
little section here from from from the
Jeff which actually helps to explain
some of the motivation for this which
release contains all the most recent
security fixes is a JDK 7 update 55 or
JDK 7 update 60 it looks like JDK 760 is
5 releases later
Update 55 therefore it must include more
security fixes but that assumption is
incorrect these two releases contain
exactly the same security fixes so over
time the release the the way the version
string has worked and under and the JDK
has got quite confusing what update of
security releases have been bumping by
five update releases by twenty how do
you know which one is more secure it's
really really confusing so this issue is
finally being being being looked at and
and that's what this Jeff is all about
the important change is that the leading
one goes away so this is a table I've
pasted this in from from the jep to show
what the version if we continued with
the current scheme would be versus what
it will be when the the version string
scheme goes into JDK 9 it's not in the
JDK 9 build so if you try it out and you
start looking at the at the Java dash
version or the system properties you're
not going to see a change just yet what
I would hope that we're getting in soon
so the important thing is that the bills
are being reported as version 9 not as
1.90 and you'll see as you as you work
through the examples in the Jeff how
it's actually going to change where this
where this may possibly be an impact for
existing code is where there's a
dependency on the value of these
properties there is code out there that
parses the value of Java dot version so
today if you take the JDK 9 bills
Java dot version is going to be 1 dot
9.0 when when nine ships then we
expected we'll just have the value 9 so
there may be some code out there that
might get tripped up by this it may
assume that the does there's a leading
one dot in the beginning of the string
so this is just something to make folks
aware of to my knowledge from anything
that's been tested so far it's only been
a small number of cases where if we're
code has been found to be really really
dependent
the on the version string so but it's
just something to be aware of if you
have code and you maintain a library
that maybe is doing some JDK version
tricks to work around something or do
something different on particular JDK
versions check it out just in case that
it may be impacted by this and the final
thing I just wanted to point out in this
presentation is the underscore this is
an odd one because this is solely a
sourcing compatibility if this code
that's already compiled with some
previous version that's using the
underscore it will continue to work but
code that's if you attempt to recompile
the code and it has it has a an
underscore as a single character
identifier it will no longer compile so
I just wanted to make people aware of
this this is nothing to do with modules
this is this is being flagged for quite
some time there was a Jeff on this I
just wanted to point it out as something
to think about in case in case you have
code that might might do this the the
Jeff to look to find out more about this
is Jeff to 1/3 which is the milling
project coin chip which has a couple of
little updates to the language by the
way if you have code that is using the
underscore you will be getting a warning
in a in jth already's if you compile it
what you have a C then you will be
getting a warning already so what can
you do to compare to to prepare for JDK
9 well the most important thing to come
away with is is the J tips tool it's
it's really really useful it's a Swiss
Army knife of static analyzers it's
really really useful to be able to look
at your libraries or your own code and
any libraries that you are actually
making use of to see whether you having
any internal API usage I want to bring
up about the the version string and the
underscore just to be able to make folks
aware of that and then for anyone that
is working on tools and the changes to
the runtime structure and everything
related to jet 220 removing RTT are
removing tools that you are that is that
is a big impact on on on tools and so if
you're maintaining any tools and then
that I was and finally thing the to say
is that we have both JDK 9 early access
bills and we have jigsaw early access
bills available for anyone to try out I
know sometimes people get confused
between the two of those the JDK 9 early
access bills grows like clockwork every
week on the Java not net download site
the jigsaw bills go out on a slightly
irregular basis they are there whatever
version of whatever point of JDK 9 that
we're seeing 2 in jigsaw at that
particular point there that version of
JDK 9 plus the the the module system and
so we push those that we've pushed out
three or four of those now in the last
two months and for people to try out and
it's a jigsaw builds is what has the
strong capsulation that has the module
system if you try out the JDK 9 bills
then you can continue to use a lot of
the internal classes because there's no
module system in 9 yet that's all I want
to talk about today in this session so
we have we're doing the intro talk in
this room later on today that is that is
very much a gentle start on on modules
it's covering them covering the basic
concepts that you'll find in the state
of the module system document tomorrow
then we have the advanced modular
development and which deals with
real-world cases and migration to
modules and then we have the advanced
our third a really really advanced under
the hood talk tomorrow and in room 5 so
that's the other talks that we have here
for more information
project excel page on open JDK GSXR
Davis is the mailing list that we use
there's the links to the to the early
access bills for the JDK 9 and the
jigsaw bills
Jade EPS tool is really useful and that
also has as has links to the wiki page
where there's more information about
internal api's and I've also put a link
there to the JEP 223 so I think we're
done if anyone has questions then it
would be great if you could find a
microphone do you not bring you one mark
hasn't
microphone hello I don't know maybe I
didn't get it but what kind of
identifier or keyword is underscore
what's it used for in gdk9 the error
said it was the keyword do you want to
talk mark about how much possibly be
reused so so they did without mentioning
Scala mentioning what the underscore and
JDK nine has no special meaning other
than that it is no longer a legal
identifier prior to JDK nine you could
use it as an identifier there are a
couple of libraries that have api's that
do use underscore alone as a single
identifier it's basically a underscore
you can think of it as a bet on the
future there are some ideas the the
we've we've thought about it a bit
especially in exploring some of some of
the work around Val how have your your
you're familiar with the ballot value
types for Java and and and there there
may be some point in the future where we
want underscore to have a special
meaning not necessarily the special
meaning it has in Scala or for other
languages we can't promise that we will
want to do that
but if we're going to do that then we
should take action now to prevent
underscore from being more widely used
and that's why we why we cut why we
deprecated it in a to make it generate
warnings and we're taking it away in
nine we might lose this bet and we will
have lined up annoying people for no
good reason but sometimes predicting the
future is hard another question
can can we try the jigsaw is there a
build that we can we can use we can show
when a Java user will person yep
download site there okay follow the
resources all on the jigsaw page there's
links to all the Jets that I mentioned
and an whole bunch of other material and
the binaries are available there as well
to try it out mark is getting easier in
his exercise today will there also be
changes to the web stats class path no
changes to web starter are planned right
now yeah question I know
EEE and se two different worlds but do
you think in ie9 we will have a bit more
modular app service because you
mentioned app servers and modules yes
thanks all part of the if there's a
grand vision here you know we hope that
a future version of Java EE perhaps
numbered nine will have modules
incorporated so you can have a modular
war file or whatever and you know we've
already spent lots of quality time with
various EE spec leads to make sure we
understand what they think they're gonna
need so that they can do what they need
to do is there any plan for async/await
like acing a wait like in the c-sharp
and increments asynchronous programming
async/await
know how i come to ask the architects
and we could riff on that
I mean what's about delivery timeframe
you have a still a plan I think you're
asking about the JDK 9 schedule you know
software schedules there with a arc you
do your best
sometimes you change the schedule but
the schedule is what it is for now yeah
do you have any more time is the clock
blinking you got one and a half minutes
okay you can get in another couple
hundred meters of running no no no
forgive you get too much so currently
the Java compiler ast is probably not
public API are any plans to make it
public API the Java C so the example
idea okay so the example I use there I
think was mostly launching the compiler
which doesn't I think require access to
the ast I think in that particular case
it would be possible for that code to
just use Java X tool API to launch the
compiler and but it's their view on the
ast that is supported I can never give
this first I head yeah I'm not sure
which a twitch of the Java Sea is
earliest II certainly certainly isn't
but there there were there is a non SE
standard but supported AST that that you
know from the jdk perspective we support
you just not might not find it
everywhere
Kirk you don't have much time IDE
support yep ID support is good do we do
we have it yet what who's supporting
jigsaw features in IDs right now nobody
nobody but we're but we are we actively
talk to them yeah but do you each just
to say is each of the eight each of the
IDS have already put in work to support
the changes are in Jeb 220 so they're
working with the JDK 9 bills and which
is really good with the module bills
jigsaw bills there any just brand new
the IDs it's going to take some time for
them to support modules all right times
up
thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>