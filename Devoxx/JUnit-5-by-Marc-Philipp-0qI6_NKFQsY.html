<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JUnit 5 by Marc Philipp | Coder Coacher - Coaching Coders</title><meta content="JUnit 5 by Marc Philipp - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>JUnit 5 by Marc Philipp</b></h2><h5 class="post__date">2017-04-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/0qI6_NKFQsY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you all for coming
know that I've set up my IDE which just
quit on me we can start just a few words
about me my name is Mark Philip I'm
Wallace senior software engineer and I
work for logging in and based in Germany
I've been a giant maintainer for some
time now so 2012 I just kind of stumbled
into being that but I guess that's a
story for a different talk if you want
to ping me on Twitter I'm contact me
feel free to do so also you can go to my
website and get my email from there if
you want to drop me a line okay
with that being said I want to get
straight into the programming model of
Jane at five so how do we actually write
a test with it and I want to show you
demo how to do that okay so this is a
project that's based on Gradle but you
can of course use maven or whatever
right I just wanted to show you how to
migrate existing tests that have been
written with Jane and for to the new API
that we use in Jane at 5:00 in order to
do so we just need to in this case add
this dependency the new API to write
tests is called the Jupiter API just
keep that in mind for now I will talk
about why that name and maybe whatever
other modules are there later so just
keep that in mind for now and already is
there and that's the simple test okay
this is a test that is written using
Jane at 4:00 right so it has the orc
Jaime imports here for tests and for the
ignore annotation and it's just a
regular class so I'm assuming most of
you have seen a Jaime for tests
maybe quick show of hands who's written
a jana for tests before okay most mostly
all the people so this should not be
news to you right if you have a test
method it's just a regular method that
has to be public and void and you have a
test annotation on it and you can also
ignore tests that don't work at the
moment and you should then specify
reason for that so I will now microwave
this test to the new to Jane at Jupiter
API and for the purpose of just going to
remove all the Jane and imports and
import new classes so there's a new test
annotation
it's an orc Jana Jupiter API right so I
need to import that and also the place
where the assertions come from has
changed as well
this would be the assertions class also
under the same package so for the ignore
annotation things are bit different
because we have tried to think about the
nails very hard and have decided that we
wanted to call this disabled and not
ignore anymore but it still comes from
the same package so now you can run the
test again and this time using Jane at
five one thing to note IntelliJ is
already smart enough to know this access
can be packaged private so we can remove
all these popular keywords that we don't
actually need anymore
in Jane it five and two tests will still
run all right let's look at some
assertions so this is a test that has a
showcase of some assertions so we have a
third equals assert now I should not now
assert the same and assert array equals
and all those continue to exist your
jane at five so that's the first piece
of good news I guess let's do the same
trick let's remove all the jane and
annotations that's important again and
that's import static methods from the
assertions class just going to take a
shortcut here okay
so almost compiles we only have this one
red line here right and that's because
we have changed the argument order a bit
so when you just write a regular
assertion you should hopefully not have
to worry about custom failure messages
all the time so this is like a default
in writing assertion
and then maybe at some point to find out
okay I don't really understand what's
going wrong with this test when it's
just executed then you add a custom
failure message and since that is not
often the case we have decided to kind
of follow the convention for optional
arguments and they come last so that's
just the reason in addition we do not
support suppliers or strings and in this
case doesn't really make a difference
because it's a string little literal
anyway right it doesn't get computed at
runtime or anything but in case you have
a failure message that aggregates some
data or collect some pieces here and
there it can make a difference because
the failure message is only ever printed
when it's needed and as most test cases
are written once and then live as a test
suite regression test kind of they don't
fail that off so you don't really often
need the failure message all right
scrolling down a bit we have hamcrest
assertions so in Jane at four they used
to be the assert that method and we have
decided not to take that over but you
can just use aesthetic methods from
hamcrest so hangers already provides
metro assert and we have decided not to
include the dependency to hem press to
just have this method that delegates to
hem dressed so now if you want to use
hemp rest you just use natural search
that's all and everything else will keep
working okay here's a more sophisticated
example this is our collector rule that
used to be there in Jade for and had the
purpose that you wanted to check
multiple things but not have to test
fail after the first failure so you
could write it like this instead of
writing assert that you would call the
error collector and check that some
value satisfies some mature and this is
now not gonna work anymore we don't
support rules and Jamie Jupiter that's
actually not true it's about some rules
but that's also not in scope for this
talk
so if you just agreement rules are gone
that's also fine I think instead we have
a new surgeon that's called a third all
and you can just pass it some lambda
functions for example instead of writing
check that we can write assert that and
copy that over and for the second one as
well so it's just come on this is this
one and don't need that anymore
so now if you execute this test you will
continue to get to failure messages
right the first one is expected it's now
but was foo and the second one expected
the same instance but was few so all of
those will be evaluated make sense when
you have an integration test for example
that runs for some time maybe and you
don't want you know to rerun it to just
gain more information okay next up we
have some demo regarding lifecycle
methods so this is what a J need for
test looks like that has before class
before after and after class
so before methods would be executed
before each test while before class
methods would only execute be executed
once before the entire test class that's
why they have to be static because they
don't have a test instance not not just
change here as well so you can just say
okay let's just remove all those a
quarter net imports again let's get rid
of the rule right away but we have
changed the names here again so we have
said okay this is really something that
we think before all is a clearer name
for and also before each because the
method is called before each right and
if you look at yeah any JavaScript
testing framework I guess you would also
find some callback that's called before
each
okay almost there good almost there but
you have to have this little problem
that we that I deleted this test rule
that was at the beginning of the class
right but the good news is we still can
get access to the test name which just
happens to use method parameter so can
write it like that so test info is a
class that comes also from the Jupiter
API and you can declare that as a
parameter to your method and then just
say okay give me the display name of
this test and to say holds true if I
declare this parameter down here and you
after each method now that's me let me
fix that so I mean just to be clear you
can use public right but you don't have
to okay so what let me execute this test
we see some system output here that's
also interesting so before all is only
printed once same for after all but we
have before each which is printed twice
and also you can see that we print kind
of the et hash code of the instance here
like the instance ID at runtime and you
can see that every test gets a fresh
instance that's the same behavior that
change in it for head so nothing has
changed there as well we will create a
fresh instance just to avoid that you
run accidentally at any state problems
in your tests okay what else do we have
yeah one wanted to show you something
about exception testing so this is like
the three ways to do exception testing
in Jayne at four right you have the old
school approach that you might have
known already from Janet three just
write a try-catch and a case this code
does not throw an exception we would
fail the test here and it K in case it
does we catch the exception and make
some assertions about it right that's
really verbose that's why Janet four
came up with this expected parameter on
the test annotation and you can sort now
say
okay I expect this kind of exception and
it should be thrown somewhere in this
cowl block here and in the method body
but you can't really say exactly where
in this method block it should be thrown
right so in case you have some some
setup code also in your test method and
that might also throw an exception you
might actually have a test that's green
but for the wrong reason so this is
where expect exception this rule here
comes in this was later introduced so
very connected and exactly say okay
below this this line here an exception
should be thrown so like if you had some
some setup code up here right yeah and
that would throw the exception the test
would fail because it was too early and
also you can expect for example the
message of the exception you can
actually assert that while with this
approach here you couldn't so we said
okay let's just we use Java 8 that's one
of the things that that Jenny Jupiter
requires so let's just do one approach
that should fit all use cases new
approach ok so we provide a new
assertion it's called assert throws and
you have to state ok which type of
exception you want to catch so it's just
going to be number format exception and
then comes the plug of code that should
throw the exception in our case it's
just pausing a foo which is obviously
not an integer now when you import it so
this would like be okay this actually
asserts that the exceptions being thrown
and if you now want it to have well some
control and add some assertions to it
you could it returns the exception
thrown right yes or throws so we can
store that in a local variable and then
make some assertions using
ever assertion library you want to use
we don't force you to use any any one
way right you can pick and choose what
you want okay let me remove all that
this should be an import oh okay for
your still hold import in here okay so
this test is not green because this cut
throws an exception and I will make it
red for seconds so we can see what it
prints so when passing 42 it's obviously
an integer and it says expected number
format exception to be thrown but
nothing was thrown right so that still
works in the way you would expect and if
you pass bar the second assertion would
fail because the message was not for
introducing foo that was for infants
from bar right so nothing really
surprising here so this is Joe our way
of doing it
and I think it's a much cleaner because
it just uses Java 8 language features
and no Excel now a special annotation
parameter or or you don't have to use a
try-catch or a rule anything it's just
plain Java code basically one more thing
we now support a thing called tags so in
Jamie for those used to be categories
and you had for each category basically
was you had to create this class or
interface you could point to and
basically there was just the mark of
interface or class and now we have
introduced tags so we don't really need
classes anymore because they close a
string based so I can write tag
integration and you can actually repeat
the tag annotation and say ok attacks lo
hand you don't need this anymore right
so this
and tag also listen on Jupiter API and
modify us again and now we have a test
that is tagged with two texts and you
can use those tags to filter your tests
when executing them back you did four
categories that's the same kind of
feature all right
that was the first demo there will be a
second one so we continue one thing I
did not mention is we can now use meta
annotations so Jane it is aware of those
so in case you use some annotations
often together right in conjunction like
add tag fast or a test you can now write
your own annotation and call it for
example fast test and make that a
combination of both annotations so that
enables reuse if you for example have
integration tests and regular unit tests
in your code base you could create a
customer notation for your integration
tests and then filter by this tag when
running them and just run the
integration tests or exclude the
integration tests to just run the unit
tests another new thing is called nested
test so now a test class can actually
have inner classes and that supports
arbitrary nesting levels so we get the
unit class can then also have an inner
class like we do to here we have when
new the first inner class and after
pushing would be the second one so you
can actually group tests and they shares
have become set up so we can have before
each method on each level and in this
example we're testing a stack so you can
really combine a set up for example
after pushing just pushes an element and
for each method and then all the tests
inside that inner class can use that set
up yeah we also combined that here with
a new feature that's called display name
so you can actually override the display
name
in your test let me also give you a
short example of that so we have this
test that all only asserted that one
plus one equals two so maybe we could
define a display name for that as well
so you can say this would be just the
lane right
you could not express that with an
Abbott method name because it's not so
technically valid Java then so now if
you execute that you would get this
display name right so a feature that
might be useful sometimes
I wouldn't recommend doing it for all
the tests but on the other hand that's
up to you so and it doesn't have the
problems you can still jump to this
method in the IDE because the
information is still there so it's and a
need for if you have such would have
such a name the IDE would have no clue
where this test is located at all right
another new feature it's called dynamic
tests so while regular tests are static
in nature as soon as you compile the
test class you know which test methods
are there right you just look at the
test class on the other end dynamic
tests they don't exist statically they
only exist at one time and we have added
a test factory a method into this test
class for example and it has returned
stream or an iterable or an iterator of
dynamic test instances and dynamic test
instance in this example is created
using a static factory method that's
called dynamic test and it has two
arguments the first one being the
display name just a string and the
second one basically being a lambda that
represents the test body so what you
normally would write in a test method
body is now in this lambda and you can
then use any way to generate a stream we
just use the in-stream for this example
and the in-stream is basically the
stream of all even numbers limit to 100
numbers and we then just map this this
integer to it in any test instance and
return that and when you execute that
in the beginning you IDE does not know
how many tests will be there right it
just knows okay there's this this method
dynamic tests from stream and as you
execute it the tests keep popping up and
get executed and report the normal
status and results so that's kind of an
experimental feature yeah yeah yeah
actually the first parameter here after
test dynamic test method has plus n
right so we could use any string there
yeah we just happened to be not very
creative here in this example but you
could yeah alright so there's kind of a
basic programming model and you might
ask okay it's maybe nice but why did we
need a new Jeon it at all right
can we just keep the old one well I will
tell you no of course so the first
problem with Janet forests there's no
coherent extensibility concept we
actually have two concepts so the first
one is called Runner you've probably all
seen this at run with annotation on the
top of class it's very powerful
you can customize almost every aspect of
the test execution using a runner but on
the downside you can only have one run
up for test class so you cannot for
example have a spring Jane at for class
runner combine that with a parameter ice
runner that's just not possible it's not
supported to kind of solve this problem
rules were introduced in jannat 4.7 you
see me deleting some of those in the
code but basically a rule is something
that's useful in jaynette for what it
does it wraps the execution of a test
method or a test class in case of class
rule
yeah and just I mean it can do anything
before the test execution or after the
test execution
it could even execute the test multiple
times so things like that and those are
really designed to be combined right
but they are also a bit simple so we
can't really do complicated stuff with
them but they create for simple use
cases so but now we have these two
competing extension concepts and none of
none of them is really like we wanted it
so I mean lot of what has happened in
the last year's and Jana 4 has been
around for a long while and has served
its purpose well but this is one of the
problems we want to tackle using the new
Jana 5 effort
another thing is another bad thing is
Jane is very popular right so that's not
a bad thing per se right but this is bad
thing because we have this one Jana jar
and everyone uses it so we have ITES
using it we have your tests using it two
different things right and other testing
frameworks also you'd like to use it
because they create a runner for example
to be able to integrate with IDs and
build tools that support Janet 4 but not
necessarily support their testing
framework and also if you try to chain
it extension you would depend on the jar
file and maybe you would need some
access to some internals and stuff and
that's also something that's really
slowed us down let me give an example
this is an example we wanted just to
rename fields in a private field in a
class had this F prefix that kind of I
don't know where that came from from
some time ago people used to do stuff
like that and nowadays I mean it's not
really modern anymore so we decided ok
let's get rid of this F prefix and just
rename the fields right and nothing bad
would happen or should it so well what
did happen we shipped for 12 beta one
and well we broke Gradle basically so
instead of saying expected message ok
this message was expected but was actual
message it now said expected not now but
was now another which is not that great
so the little things like that also kind
of really make it hard or made it hard
to continue working on Jane and as a
testing framework
so like my colleague Johanna said the
success of Jana does a platform prevents
the development of Jana does a tool so
that's also one things one of the main
things we wanted to solve and have a
solid foundation for yeah but keep
working on Jane it is a framework as a
testing tool and not just just as a
platform that brings us to
modularization and we've really thought
long and hard about this and there's
three concerns we wanted to separate
first of all we've already seen a
Jupiter API which is the API you used to
write tests
it just has interfaces mostly in some
annotations so you really not coupled to
any internals you just use this API jar
yeah second we wanted to have an
extensible mechanism to discover and
execute tests the reason for that being
while writing the new kind of framework
we didn't want really to depend on the
old framework but at the same time we of
course wanted to be able to execute old
tests at the same time as new tests so
they should be executed in one test run
so you shouldn't be able to
you shouldn't have to kind of separate
that out and when the change for tests
first and then attained five tests
instead it would would be great if you
could run both at the same time and
that's where this mechanism comes in in
place third we want to provide an API
for test execution by tools obviously at
some point you want to run your tests so
that's needed and this is called the
launcher API so let me give you the big
picture looks like this so we actually
build something that's called platform
and the platform is that that part of 25
that is used by DES and build tools so
they don't have to know anything about
the actual testing frameworks they just
have to know how to use the platform and
tell it okay please run this Java class
for me I don't care how please report
status back but please run it that's
what what the platform
basically and you see these colored
boxes at the top so we have vintage
Jupiter and third party so windage
interpreter is something that we provide
but we also open this platform up for
third-party testing frameworks like gen8
has always done using the run with
annotation but this time we actually
designed it to work like that and not
have the same kind of flaws that the old
architecture had so Jupiter is our new
testing kind of framework vintage is the
old one so if you look at the insides of
those big boxes you will see that we
have the two Puteri API and in the green
box and the two patear engine is also
part of Jupiter but you don't need to
pull in the Jupiter engine that's
something the build tool or IDE should
do for you so you don't depend on
implementation details in your tests you
just depend on the API jar and when you
look at the yellow box you will see that
if provided something that's called Jana
vintage engine this is part that
implements this spi that the platform
provides to be able to run they need for
tests on the new Jana platform so it's
kind of a plugin mechanism and if you
look at the arrows the error goes down
right so the Jupiter engine knows the
platform and not the other way around
and the same holds true for vintage and
third-party engines when you look at the
bottom we actually provide a cradle
plugin that uses the launcher API we
also have a maven surefire provider
already that's currently being migrated
over to apache but it still works on our
end so you can already use maven and
Gradle to run Jenny 5 tests there's also
Jana platform console that you can use
from the command line to execute Jenny 5
tests or Gen 4 tests for that matter
yeah there's one interesting piece the
jain a platform runner so the platform
actually has a gen8 4runner
so that makes it possible to run a J
need five tests on Jane it for this is
meant if you use an IDE that does not
support to train it five yet you can use
this kind of interim solution to run
this test in this in that ID so the test
imitation in this case actually comes
from the Jupiter API so it actually is a
new test and we just tell Jane it for to
run this using a training platform
runner which will then call the platform
launcher API and do the regular thing
that Jane at five does now you don't
have to do this on all your test test
classes if you're working in IDE that
does not support unit five you can
instead use that in a platform runner in
sweet note so like Jane it's for test
suite kind of way select classes you can
use the training platform runner to
select packages or also classes there's
a bunch of annotations also filter
things like include engines or exclude
engines and run this class and this will
automatically collect in this example
all your test classes in this package
and run them in your IDE so this is only
meant as an interim solution when you
use an old tool but I've been working
very closely with ites
IntelliJ in Eclipse most prominently to
add support and tell jay has already
shipped that I've already shown that in
my demo they've been supporting it for
quite a while now
Eclipse support is also available it's
not officially released yet it's
available on a branch there's a wiki
page in the eclipse wiki how do how to
enable that and the official release
will be probably in the first service
release for oxygen so September probably
this year yeah so there are lots of ways
to execute the tests you just have to
pick the one that works for you in case
of cradle maven we also provide sample
projects that you can use to get started
really quickly but I already have all
the setup that you need
to run your tests using cradle or maven
and there's also the console launcher I
mentioned that for executing them by a
via the command line so what this gives
us this module is a tional architecture
is both backward and forward
compatibility so backward compatibility
is important right this is this vintage
engine because you cannot migrate your
whole test base test codebase all at
once to the new API but what it what it
gives you it enables you to gradually
migrate tests or write new tests using
the new API and still keep around old
tests and it will still work it will
still run even though the new testing
framework the Jupiter engine does not
know anything about training for at the
same time there's forward compatibility
this is this runner that I just talked
about and it allows you to execute new
tests using old tools so it's compatible
in both ways and you can run it in both
ways yeah I'm motivated a bit extensions
are already also very one of the most
crucial things that we wanted to improve
using this new release and there's only
one way to register them it's called
extend with kind of sounds like one with
so we annotate your test classes or you
test methods with extend with and
specify an extension you want to
register and that supports an arbitrary
number of extensions at the same time so
you're not limited to just one like with
runners and it may also be used as a
meta annotation like all the other
trainer annotations cannot be used okay
but we also give you a demo on that need
to do some
get clean up here first check out the
base
all right so we now have this extensions
package and the first example I would
like to show you is how to write your
own extension that can tell whether a
test should be run oh it should be
skipped and yeah I've made up this
example right I'm going to this
conference today and I don't want my
boss to call me because the test broke
and I need to go to the office to fix it
so I have invented to disabled on
conference which is not implemented yet
so we can when you run this test now it
will fail right so what we can do I mean
this is just an annotation I have
defined here and we could annotate this
annotation with extent worth and give it
a class
no not that so by default IntelliJ has
not generated something that extends
extension but that's not very helpful
extension is just the marker interface
there's actually a bunch of extension
points that you could implement for this
example we're just gonna pick one of
them
that doesn't work
namely test execution condition and we
have to implement some interfaces for
that well only one method actually for
that so it gets the test extension
context that gives you some information
about the test like what classes is in
what's its name what tags does it have
but for this simple example we actually
don't need it we just we're just gonna
say okay conferences are always on
Thursdays or something like like this
like say okay local date now get day a
week that's the Thursday we're just
gonna skip the test and we have to
return a conditional evaluation result
and say okay the conference and in the
case it does not it's not Thursday just
gonna say okay then it's enabled
I'm gonna run this again it will be
skipped and it will tell you you're at
the conference right so this might not
be the most realistic example but it
showed okay we can have meta annotations
so I could have written this also like
that right would also work but it's not
as readable so since we support many
annotations right such an extension it
will often be the case that you also
write an accompanying annotation for it
that just makes it easier to use okay
let's look at a more complicated example
I have this test here that somehow wants
to have this temp dear path and what it
does it writes well two lines to a file
and then reads that file again and
checks that the content of the file is
actually the one that I just wrote it's
not very sophisticated so let's run it
right now we will fail it will say
there's no parameter resolved are
registered for parameter path right
because we have not registered any
extension so let's change that let's
write our own extension for it
again I'm creating this class and since
I want to resolve parameters I'm going
to implement parameter resolver this one
actually has two methods the first one
is supports that is supposed to check
whether this extension can actually
resolve this parameter so in our case
we'll simply check that the parameter
type is path come on this one once it's
a path we will just resolve it and we'll
just return a temporary directory so
this should be a path I'm just going to
return files dot create temp directory
just gonna call it J unit okay we cannot
thrown it I or exception here that's why
it come it complains let's instead throw
a parameter resolution exception I
scroll right you can see that we allowed
to throw that could not create temp dear
so that pretty much do it so we can run
the test now and it will be green so
we've now basically injected this path
into this test method and have used it
in there
of course they still something missing
right don't want to create lots of
temporary directories on our hard drive
without deleting them so we could also
then implement after each call back to
clean up after each test so I'll do that
we need somehow need to access this path
that we have created the temporary
directory so we're not just returning it
we have to store it somewhere
and extensions are not allowed to have
any stage instead we provide you means
to store stuff in a store so we can say
okay just going to get the root here or
if it's not there I will just compute it
and return this temporary directory to
return that so now I have done this and
now I can in my after each method also
accept access the store gets the root
this must be the same key here and if
it's there yeah that's a nice overloaded
method say I won't have path it does the
casting for you so if this route isn't
now we're just going to delete it
recursively as it turns out that's not
something Java supports out of the box
so let me copy that from my prepared
code here so just uses the firewalker
API to actually BD the directory again
all right so since before you won't
believe me I will just add some sis out
statements here deleting file and also
for the directories those get deleted
after the whole directory has been
visited
and if you execute it now you will see
that the files now deleted and also
active directory is deleted after the
test so we've seen that in one extension
we can implement multiple of those these
extension points and there's actually a
whole list of them so we've seen test
execution condition we've seen parameter
resolver and we've seen the after each
callback
but there's callbacks for all the
lifecycle phases like before all before
each before test execution the same
thing after we've seen test execution
condition there's also container
execution condition a container is
something like a test class it's not
actually a test itself but contains
tests so you could also implement such
an extension that checks at the class
level that the whole class should be
skipped for some reason yeah we've seen
parameter resolver but there's also test
instance post processor that allows you
to get the instance of the test before
it's executed and for example inject
values into fields or somehow prepare
the test instance for your test and
there's test execution exception handler
which allows you to well it's get it
gets called in case an exception occurs
in your test and it can for example wrap
the exception in another one that adds
some more information to it or it could
also just say okay that just dropped
this exception for some reason all right
this brings me to the road map we have
in m4 via plan support for parameterize
tests that used to be a runner in
Danette for now we have support on the
test method level so you can now instead
of annotating the test method with tests
you can say at parameterize test and
then you add a bunch of sources at least
one to it where those arguments
should come from so the first example
here we just use an array of strings and
each string represents a comma-separated
value so this test this method here
tests with parameters from annotation
would be called twice once with foo and
one and the second time with bar and two
and for each of those invocations you
will get a separate note in the test
tree that tells you ok but it is failed
or succeeded
there's also method source so you can
use a method that produces your
parameters in case it's easier to just
do that instead of putting them in a
string or you could load C as far as
these V lines also from a file that's
CSV file source actually there's a bunch
more planned so this is all currently in
development m4 is scheduled for April
first nothing suspicious about that date
I hope but yeah so this is already a
master so it should be looks similar to
this right it does not change a lot
before the release I hope and also we
have repeated test this just allows you
to repeat a test multiple times so in
case you have a flaky test this gives
you an easy way to just run it very
often to maybe find out under which
conditions exactly this happens and both
of those will be included in m4 the next
milestone as I said it's scheduled for
April and then we plan one additional
milestone m5 that focuses on Java 9
compatibility so we don't expect a lot
of changes there but we just want to
make sure that we don't have shipped our
GA release and then Java 9 comes out and
we find out ok you should have done it
differently so that's why this milestone
is there in case we find out that we
don't need to change anything we might
just drop it and move directly to the
next release candidate yeah our C one
time for June last last me
fix's I would say and then a month later
we plan to release the GA release just
in time for eclipse to pick it up for
the oxygen one service release so this
is the current roadmap what it would
like you it's like to get started we
have I think a very comprehensive user
guide that tells you how to use JUnit
how to set it up we have also sample
projects that get you started in no time
and of course there's Javadoc if you
want to know more details so this is
really I think very good information if
you want to get started and we want from
you is to get feedback so there's still
time even to change big things because
we haven't shipped our GA release yet so
please get in touch if you have a
question if you want to report a buck if
you have a question
there's also Stack Overflow there's a
tag that we watch very closely and
please don't hesitate to open the github
issue in case you find something that
you find suspicious or even a bug and
for those that don't have time to do all
that there's Twitter you can ping us
there as well we'll try to respond in a
timely manner yeah so that's the message
I would like to send try it out give
feedback if you find anything and let us
know okay that's the rest of my list
basically my talk if you have any
questions I would be happy to answer
them this one yes IntelliJ has promised
us that they will do exactly that so
shouldn't have to do all this by you by
yourself yeah
well if you use the makita runner or
something yeah then yes but we already
have a very simple extension from the
Quito and they plan to include that in
the Mojito in the makita release that
comes after our GA release so that it
will take some time
sure and if you have custom rules I did
say that we don't support them at all
that's actually not correct so if you
look at the user guide you will see that
there is some migration support we have
thought about that show you that there's
even a whole section dedicated to how to
migrate from jaynette for and there's
also limited in it for rule support so
if you rule extends external resource or
verifier or if you use expect exception
then we agree we have you covered we can
support your rule but the other rules
are just too generic so that we can
support them using this new extension
model and yes you would have to rewrite
them at some point so it's a bit of a
disruptive change if you are in that
manner that's true definitely ok
any other question
doesn't seem like it then oh this one
okay so you want to register an
extension without actually using the
annotation to register it
huh
let's actually we actually have a
listeners in concept that that's what
the IDE also uses and those are already
you can register those using the service
loader API so if you have a jar file and
have this this properties file in the
right place you can point us to your
implementation of this listener
interface and we will then call you so
for example for reporting purposes that
should be enough so if you don't need to
change any of the behavior of the code
that should cover your use case there's
been some discussion about also doing
this for extensions it's kind of a tough
choice because well this gives you a lot
of power and flexibility at the same
time it makes your tests harder to
understand so like if you need this
extension so your test can run then you
cannot just look at the test class and
understand what's going on anymore
so it's still being discussed and
there's also open issue for it and we
haven't really decided on it yet so I
would prefer personally that we only do
this full listener the things that don't
really want to interact with the test so
we can still understand the test just
the reporting will be different that's
just the rationale behind it okay cool
well then thank you all for coming and
to see you around</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>