<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Young Pups: New Collections APIs for Java 9 by Stuart Marks | Coder Coacher - Coaching Coders</title><meta content="Young Pups: New Collections APIs for Java 9 by Stuart Marks - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Devoxx/">Devoxx</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Young Pups: New Collections APIs for Java 9 by Stuart Marks</b></h2><h5 class="post__date">2015-11-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/OJrIMv4dAek" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">willkommen Bienvenue welcome Hodor
my name is Stuart marks thanks for
coming I work in the Oracle JDK core
libraries group and this is a talk about
the new collections api's in Java 9 I am
going to be talking about future
development in Java 9 and so everything
I say in this talk is subject to change
so this is a companion talk to a talk I
gave a couple weeks ago at Java one that
talk was entitled new tricks for old
dogs it's a joint talk I gave with mic'd
we go that was a set of talk about a set
of enhancements we made to collections
for Java 8 and so that was intended to
be paired with this talk which is about
enhancements for Java 9 and so Mike is a
dog lover and so he entitled that talk
new tricks for old dogs and this one is
about young pups which is new new new
little collections that are being
developed for Java 9 now if you look at
what's going on in these releases Java 9
lambda and streams
heard a lot about that and you're
continuing to hear a lot about that now
in Java 9 there's modules but there's
still the collections framework which is
a pretty old framework and it's still
very very much in use and so we're still
working on that we're making
enhancements improvements and
maintenance on it so that's what that's
what the theme of this is it's still
very important to work on and we're
continuing to enhance it I have a
created a hashtag for this talk it is
Java young pups I'm not going to be
monitoring Twitter myself during the
during the talk but if you have comments
questions or feedback I'd appreciate
your tweets on it and if possible I'll
get I'll get your replies and
information after the talk alright so
let's start off with the the proposal
itself and but actually before the
proposal some history that's leading up
to where the proposal lined it up so the
topic is collection literals and so if
you look at other programming languages
they have
they have concept of collection literals
so for instance in Python it's very easy
to create lists sets and dipped objects
which are the pythons equivalent of maps
and so a string list use the bracket
notation to create a list of strings a
string set you can use curly braces and
the string dict has curly braces but it
has a colon separating the key value
pairs and that's really nice and Python
is a nice programming language and
that's a nice feature of it but in Java
we have to suffer through this this
really verbose way of creating
collections so if we want to create a
list of strings probably the most
convenient way to do that is using
arrays dot as lists and so that takes an
array or varargs of string values and
that's not too bad but it's not too good
either quite frankly if you want to
create a set of strings
well actually the best way to do that is
to first create a list and then pass
that to the copy constructor of
something like a hash set so that's kind
of roundabout but the real pain comes
with maps because you have to create a
map instance and then add things to it
and so that makes your code really
verbose so why should Java have to
suffer for suffer through this this
verbose syntax for it for doing
something that in other languages is is
very convenient so we have tried to
solve this problem in the past and so if
you remember project Coyne was something
that went on a number of years ago
during the development of Java 7 so the
idea of project Coyne was that it was a
set of proposals for small change to the
java programming language and so one of
the proposals that was floated at the
time back in early 2009 was on
collection literals and that was
proposed by josh bloch he's the author
of effective java and he's also the
author of the collections framework
which was introduced back in 1.2 so josh
seems like you know kind of the guy to
introduce collection literals into the
language so that proposal was was
floated again in 2009 during project
coin so the the proposal was actually
remarkably similar to two pythons at
least in syntax now what it actually did
of course
there's a whole bunch of things that
were necessary to to deal with how how
that syntax dealt with Java collections
but I'm not going to go into the details
of that there was much much interest in
this this is a great feature everybody
has wanted it for a long time there was
lots of discussion the mailing list
mostly about syntax as it turns out of
course and also at the time if you go
read through the articles which I which
I did recently is that an alternative to
the proposing a language syntax was a
library only API for creating
collections and so so this was discussed
all the way back then and the question
there was do we need a special syntax
changing the programming language and is
it worth the cost of changing the
programming language or should we just
go with a library based proposal so that
was discussed but that never went
anywhere and in fact the whole
collections littles proposals never
actually went anywhere in project Coyne
there was a lot of interest and
discussion in it but I think basically
what happened was that they ran out of
time
Josh himself spent a lot of time working
on try with resources which did get into
project Coyne and thereby Java 7 but
there just was not enough time last and
anon enough expertise and personnel to
implement collection literals in Java 7
so that got dropped and so most
importantly nothing happened the
collection rule the collection literal
syntax was not introduced neither was
any kind of library based API for it
there was another attempt at this
more recently in early 2014 so that was
I guess about a year and a half ago at
this point this was at the tail end of
Java 8 development and the team started
looking at new new features to introduce
in future JDK releases and so collection
literals was one of the things that was
left over from project coin so it became
natural to say ok let's revisit this and
take a look at this again now there were
- ok so actually a little bit of
background here so this is
Jeff won 8-6 Jeff is a JDK enhancement
proposal so this is the framework and
process that we're using now for for
working on enhancements to open JDK and
so Jeff 186 was what we called a
research jap and so it was not actually
a Jeff to develop the feature it was a
Jeff to investigate whether it was
reasonable to develop the feature so
it's it's a bit of you know it's a bit
of meta project there but given that
language changes and stuff generate lots
of discussions and they tend to go
around in circles a lot I think it made
a lot of sense to to do a research gap
to explore the space to determine
whether it was feasible and then if it
was determined to be feasible then go
off in a particular direction so there
were actually two I I guess I would I
would divide this down into two major
approaches for how to how to proceed
with collection literals one was
actually very similar to Josh blocks
earlier project coin proposal which was
to develop a syntax and have that syntax
be bound directly to particular concrete
classes in the library now those classes
might be public or private that's kind
of a detail but the point is you have a
language feature that is bound directly
to concrete classes in the library on
the other hand there's the alternative
was a more general extensible approach
which was to say a collection literal is
actually some kind of abstract way of
specifying an aggregation and then what
happens is at runtime somehow this
abstraction of an aggregation is handed
to a builder for some arbitrary
collection which might be a list or set
of math or so some something else
possibly even an inner collections
interface that hasn't been implemented
yet or hasn't been defined yet and not
even possibly not even part of the JDK
so this is kind of the the fully general
extensible approach to collection
literals so after not that much
discussion and investigation of this
first simpler approach this was this was
rejected because the
well the way Brian gets put in a in a
male on one of the open JDK mailing
lists was something that was bound to
built-in types in the JDK would be
disappointing and so there's a group of
people who wanted something like
collection literals to apply to new
collection libraries that they were
developing separate from the JDK so gee
that makes a lot of sense that they
would be disappointed you can't use this
great new syntax if they're bound
directly to concrete implementations
that are JDK specific but what that what
what that brought to the surface was
this idea that the architecture of Java
is to have the programming language and
the class library kind of be at arm's
length so this is an example of the
loose coupling principle in general Java
the programming language tries very hard
not to have too many inter dependencies
with the class library and so there are
some there definitely are some and they
primarily but not exclusively they
primarily reside in the java dot lang
package that's the significance of that
package which is it's part of the class
library but it is intimately bound with
the language but the most of the rest of
the class library is is separately
defined and in principle you can replace
the class library with something else
and it would not affect the java
programming language so adding something
to the programming language that says oh
okay these collection classes over here
these specific concrete collection
classes are now baked directly into the
programming language that caused that
would make the language much more
tightly coupled with the library and
that caused people great discomfort so
there was there was resistance to doing
that and so so that's why this simpler
approach even though it has many tracked
ins to it that's why this simpler
approach was not was not pursued now
there's this more general approach which
is to make it flexible and extensible
and you can not only create a list
Center map but any collection interface
or something that hasn't been invented
yet or some third-party library well
when you try to do that it makes things
really complicated because people think
of collection libraries that haven't
been invented yet and they say
we want the Builder that to be able to
consume things in a particular way and
so the language has to accommodate
things it has to accommodate libraries
that haven't been invented yet and so
that's very very difficult and it's very
complicated and what happened was there
ways to do it there's certainly ways to
do it it's not it's him it's not that
it's an impossible task what happened
was things got very complicated but then
we left behind this nice clean simple
syntax of saying oh I want a list
bracket a comma B comma C so that went
by the wayside because you needed to
specify okay is this a linear list or is
it a set of pairs or something like that
and then you need to specify how that
was how that was going to be passed to a
builder of the callers of the
programmers choice and so forth so it
became very messy as Brian guest said it
became so messy that it was going to
overrun its design budget so it's not
that it's impossible to do it's just
that it's a cost-benefit trade off so
yeah we could go off and design this
very complicated very general very
flexible mechanism for collection
literals but it would be a great cost
and you know as painful as it is maybe
it's it's not giving us it's not giving
us what the benefits that we want in
particular it would have taken a lot of
time away from value types which you may
have heard Brian gets talked at other
conferences it's a very important
feature that's required a lot of
attention and so in fact doing something
like this would have been a distraction
from that and that was not a not not an
approach that they wanted to pursue so
based on this instead of designing an
extension to the programming language
they said okay let's revisit this idea
of a library based solution and what
Brian said at the time was it gives us X
percent of the benefit for 1% of the
cost where X is much larger than 1 and
so I think that's true and so what I did
was third time maybe the third time is
the charm now so I've filed Jeff 269
which is a library based API to replace
collection literals so I think that's
true I think we can get about 80
percent of the benefits of a language
based syntax for collection literals by
pursuing pure library api's with no
language changes now maybe in the future
with value types coming along we might
have some some different syntaxes
proposed for value types but not at this
time so for what we're targeting for JDK
9 or at least I hope to target is that
we get a set of library api's for that
replayed that functionally replace
collection literals with no language
changes whatsoever and in fact so that's
true we got most of the benefit at a
tiny fraction of the cost basically I'm
the only guy working on it and I think I
can make pretty good progress and
probably get something into JDK 9
whereas if if you have a language change
it requires the compiler people respect
people a bunch of architecture and a
whole bunch of discussion the stuff and
it might not converge and in fact we
have two instances in the past where it
really did not converge so I think we
have a good chance of making a lot of
headway the current status is that JEP
269 is proposed to target so I think
that means it's likely to get into JT
kind JDK 9 but of course you know I
can't make predictions about the future
I have a draft API out for review
actually two drafts and then there's a
proposed there's a sample implementation
in the sandbox for JDK 9 so it's not
committed yet but there is code there
and basically you know in fact is it's
not that complicated basically have
something that works pretty well all
right so let me go over the API that
that we're proposing to add so the goal
is it's an API but the goal is to be
very similar to what the goal of
collection literals was so we want
things to be simple and concise and
brief and convenient but we are not
trying to be very general so in
particular we can produce instances of
lists set and map so we're not going to
try to tackle Oh free a list of you know
or create a collection of some arbitrary
type the API is pretty simple we all
show some examples on the next page but
the main thing we do is
we're using a new Java 8 feature which
is the ability to add static methods to
interfaces so we use that all over the
place now I think one of the things that
one of the things that I found
surprising actually was this is real
simple API and the number of issues that
actually arise when you try to look at
it and define it is surprisingly high in
fact the bulk of this talk is not about
the api's themselves but the AP design
decisions that went on behind it and
then there are also a large number of
implementation issues it's very simple
to come up with an implementation but do
you want the best implementation or do
you want a better one then then the
simplest one might be and so there are
lots of interesting issues there so I'll
cover some of those in the talk as well
all right so here's the API mostly on
one slide so it's a set of static
methods being added to the list set and
map interfaces we are adding a set of
static factory methods list thought of
containing a bunch of fixed argument
overloads so 0 through 10 arguments so
there's actually if you look at the
proposed Javadoc it's basically list
thought of a comedy comedy so it's a
little bit it's a little bit verbose
there but the fact is what it allows you
to do is write out a fixed set of
arguments and pass it to list thought of
and it creates a list with exactly that
number of elements in addition if you
want to create a list with more than 10
elements there is a varargs overload so
you can pass an arbitrary number of
elements to this dot of alright it's the
same thing with set dot of 0 through 10
fixed arguments plus a VAR args overload
of set thought of map is a little bit
different so Maps instead of being what
we say is a linear collection of
elements of a single type it contains
key value pairs that are of a different
type and so in order to make things
convenient or providing fixed Arg set of
overloads for map up to 10 key value
pairs
now if you want more than ten pairs we
have problem and so what we settled on
was math dot of entries with a varargs
parameter of map dot entries and so we
created a convenient way to create map
dot entry objects I'll talk a little bit
more about that later all right so let's
revisit our examples so in the original
and the in classic Java code if you
wanted to create a list set in a map the
code at the top of the slide shows you
how to do that now under the doing more
or less the equivalent thing although
there are some differences I'll get into
later but the creating list set in map
that are that have the same contents as
those shown above is much simpler so we
have list thought of a comma B comma C
same with set and then with a map we
have alternating key and value pairs
which sorry alternating keys and values
which are of which are of different
types now if you want more than ten key
value pairs in a map then what you can
do is specify a set of map entries and
we've created a we've created a static
factory method entry that can create a
map entry for you and so that takes two
parameters a key and a value and then
you can provide a list of an arbitrary
number of those and pass that to map dot
of entries all right so basically that's
the API so we're done
right okay hey 40 minutes left okay now
know the rest of the talk is about the
design and implementation issues so
there's a lot of stuff going on under
the covers so I think the first thing is
how do you deal with maps and coming up
with the map of entries API actually
involved a lot of thinking and
discussion so if you look at lists and
set they're real simple because you can
you can have a certain number of fixed
arguments and then save varargs and for
args
you know Foggs works pretty well for
those but for map the problem is the
keys and values are potentially of
different types and so you can't have a
method with two VAR args to varargs
parameters and you you don't you don't
want to have a far X parameter
that is common to the type of the key
and value pairs you might as well I mean
basically that would end up being a
varargs of object and it wouldn't be
type safe anymore so so there's a big
wrestling match we had with the the
language here in order to figure out how
to pass an arbitrary number of keys and
values to to the map Factory so but I
came up with a set of criteria for what
we wanted to look for in an API so the
first is that it had to be as simple as
possible because again we're modeling
collection literals except in a library
API I think the most most very important
thing that's very easy to overlook is
that it needs to be compile time type
safe Java is a statically statically
typed language and coming up with an API
that was not statically typed safe like
you know honor of args array of objects
that would that would be a pretty lousy
API and that would stick out very very
poorly from from the rest of the the
api's in the library so having having it
be type safe is very important so here's
a subtle one which is we wanted the
number of key value pairs to be known at
compile time and so VAR args has that
property when you call a VAR args method
what happens is the colleague gets an
array and the array is of the exact
right length which matches the number of
arguments so there are a variety of
patterns like builder patterns where you
repeatedly call add or something like
that that we considered but the problem
is there that it would require some kind
of extensible or growable data structure
and certainly possible to do that but
that's that's a disadvantage because we
it would require extra copying at
creation time so a subtle point about
the API is that we wanted the key and
the value to be adjacent in the source
code so one of the alternatives was have
an array of keys and an array of values
but if you have a bunch of those and
they stopped fitting on a line then it
becomes really hard to match up keys and
values so we wanted those adjacent and
then finally we wanted to avoid boxing
if at all possible
okay so as I said our solution at least
to most of the problems was to come up
with a static factory method map of
entries which takes a virÃ¡g parameter
of math dot entry objects now creating a
map dot entry object is is actually it's
actually kind of cumbersome so if you've
done this before there's there's
actually an implementation in the JDK
already it's called abstract math dot
simple immutable entry and so that's
that's a real mouthful so what we did is
we created a new static factory simply
called entry it's on the map interface
and it takes a key and a value and so
basically call that to create a map
entry and then call that successively
and pass those values to map dot of
entries now it works pretty well as we
saw in the example on the on an earlier
slide but it does unfortunately have the
characteristic that it boxes the key in
the value into a new object which is
immediately unboxed by the factory
method and thrown away so that creates
more garbage than we would like at
creation time but maybe just maybe when
value types come along it might be
possible to make the return value of the
entry method be a value type and so if
you if you look at what's going on in
future Java development is to is to come
up with a new kind of new kind of new
kind of thing in Java called a value
type that does not involve allocation on
the heap so we might be able to do that
and so we're kind of carefully tuning
this to make sure that we don't make it
impossible to change this into a value
type in the future overall I think we've
met most of the criteria the that I know
I'd missed my miss my tag line on the
previous slide so when we looked at all
the different alternatives basically our
conclusion was they all suck so what we
ended up with was I think this is a
compromise that sucks the least so I
think it works it works ok it's not the
best thing that's possible this is the
area where if we had some specials
port from the language to have some kind
of syntax for specifying a pair that's
where this would have come in really
handy but since we didn't want to change
the programming language of the syntax
okay well so this is what we'll this is
what we'll come up with and this is what
we'll we'll live with all right so
moving on so I mentioned that the API
has a set of overloads and one of the
problems with overloads is that
especially if you have overloads with
the same number of arguments if you pass
a null that is ambiguous and so if you
say what happens if you say list of null
so the compiler will look through the
API and say hmm there are two matches
there's one which takes a single
argument list of E and then it also
matches list thought of varargs of E and
so in fact this this when the compiler
encounters an ambiguity like this it's a
compile time error it's not a warning
it's it's actually an error so you if
you say list dot of null your program
will not compile okay that seems like a
big problem
well actually we we've basically
finessed it we're not allowing nulls in
these collections so you're never gonna
want to say list but of null anyway so
yeah this is mvq s but sorry we don't
care
so I'll have more to say about nulls
later so another actually the thing
about the thing about API design and the
programming language is that over load
resolution is probably the most
complicated area that library designers
have to deal with this is a real pain
and so there's a lot of discussion about
dealing with overload resolution with
lambdas this isn't quite as bad but
there there are a number of subtle
issues that arise so here's another one
which is what happens you pass an array
to list thought of and pass it a single
argument well that's that's sort of
similar because that could well I'll
just go by the example here suppose you
have suppose you create an array of
strings and then you pass that to list
thought of so it's kind of similar to
list on null but if you pass an array
then it still matches still matches two
things so that could mean if you pass an
array of three strings to list thought
of what what could that mean could
two things it could mean create a list
that contains three strings or it could
mean create a list containing one
element which is the string array itself
so so which is it so it turns out that
because of the overload resolution rules
the varargs
overload is preferred because it's more
specific etc I don't I don't know all
the I've tried to read the section of
the language specification that that
that covers this and frankly I don't
understand it fully so but in any case
what happens is that it ends up calling
the varargs method and I think you
actually get the right result if you
pass an array of three strings to list
thought of that's like passing three
strings directly in the argument list
and you get a list of three strings okay
that's great in fact you don't even get
any warnings there when you do that the
overload resolution unambiguously
selects that particular overload and
that's what you got now sometimes you
might say okay well gee I want to create
a list that actually that actually
contains an array how do you do that
well first I have to say that really
seems like an edge case because mixing
lists and arrays is kind of a funny
thing to do so if you really want to do
that maybe you should consider creating
a list of Lists instead of a list of
arrays but sometimes they're neat
there's a need to do to create a list of
arrays and you can do that what you have
to do is you have to specify the the
actual type of those you want in a type
witness so there's this funny syntax
here list that of open brackets string
array closed bracket and that will
select the other overload so you can
actually create a list of arrays if you
wanted to do that now this only happens
if you have one element if you actually
have multiple arrays it actually works
just fine so this is only this is real
special case so this is kind of an ugly
workaround but I think it's a rare
enough case that it's like hey you're
doing something kind of weird let's just
document that this is the way to do it
and move on alright so there's another
design question which is
how many fixed dark overloads should
there be and so it's it's really hard to
come up with a good answer and in fact
in I've changed the proposal a couple
times and I get criticism no matter of
what so I think we just have to decide
but I think one one thing that's useful
is that the the the guys at Google who
developed the guava library have
something similar they have static
factory methods that have fixed arrgh
overloads and what's interesting is
they've for for their list factory it
take they have 11 fixed arguments and
five four set and five key value pairs
for math and so I asked them about that
and there was much back and forth and it
was sort of that's basically arbitrary
and at one point he's the answer was
this one goes to 11
so that's how they ended up with 11 so
so one thing they did though is they did
an analysis of the number of uses of
collection sizes in their code base and
found that there's a fairly steep
drop-off in terms of the number of
arguments that is if you if you add more
arguments the frequency of usage drops
off initially it looks like it's
exponential but I'm not sure I believe
that but it does drop off fairly steeply
and so somewhat arbitrarily I just said
okay let's just let's just use 10
because I think an early proposal had
five and there were on there were enough
cases where we wanted to you know there
are cases that seem to occur that
exceeded that limit so someone
arbitrarily chose 10 and so that's the
way the proposal stands now now I'm
saying there now I'm hearing feedback
like oh that's too many or actually you
don't need those at all but you know how
that goes so anyway but my intent in
choosing a rather high number is that
most of the cases and I'm not sure how
most is but I think it's upwards of 95
percent should be caught by using the
fixed arc overloads and then there's
always the failover to the varargs
methods if you have more than that
number but I think we want to capture
most of most of these cases using fixed
arguments all right earlier our promised
to talk about nulls and so the new
collections implementations will
disallow nulls entirely so if you try to
pass a null as a member of a list or set
or as a key or value of a map you'll get
null pointer exception and so I think in
retrospect I think it's mmm it's it's so
much controversial because people
actually use nulls this way but in
retrospect at least from the API design
standpoint allowing nulls as members of
collections in the original collections
framework was generally regarded as a
mistake and you can see that because the
early collections like well like array
list and and and so forth allowed them
as nulls and so new collections were
added in 1.3 and 1.4 and those all
allowed nulls but something happened in
Java 5 and in fact I think it was driven
by the concurrency stuff basically the
the concurrency utilities disallowed
nulls in all the concurrent collections
and in fact even in new collections that
were not part of the concurrency package
in Java 5 disallowed nulls and so that
set a precedent which I think we're
gonna stick to here which is every
collection added in Java 5 and beyond
has prohibited nulls so I'm not going to
be the one to turn that around so why
are we doing this well nulls are bad how
much more can you say about it but there
are actually some practical issues with
it as well because nulls really allowing
nulls as members of collections really
complicates your API so for instance the
the the issue that I think most people
are familiar with is math dot get and so
math dot get can return null well that
can actually mean two things if the math
allows nulls as members it might mean
the the there's a key there whose value
is null that's present in the map or it
might mean there's nothing present and
that key is not present in the map at
all and that's kind of a problem you
have to make another API call to deter
to disambiguate that now if you have a
map that doesn't allow null values then
it's unambiguous map get returning null
means hey there's no key in there now it
gets worse with things like math dot
compute which is a new Java 8 API that
takes a lambda that computes a new value
for a map and that actually uses null as
a special case to mean that an entry
that an entry is not present or that if
the return value of the klamath the
lambda function you pass in if that
returns null it means the entry should
be deleted so if you allow nulls as map
values then if you want to delete
something instead of making the value B
null you have to really complicate your
API to to accommodate that and so so
that's from the API standpoint we're
using null as a special case is very
useful and allowing null as an actual
collection element is is a real problem
now it's also useful in internal
implementations and so it's used all
over the place in collections
implementations to mean the absence of a
value so if you have like a feel like
your hand yeah
if for instance if you have like an
array which is how you know a table used
for hashing if there's null there that
means gee there's there's nothing there
and so you can immediately terminate
your search but if null is a valid
member then you have to do a bunch of
special casing in the implementation and
that well one that's that's that's
error-prone and it's a maintenance issue
but it actually also slows everything
down and so anyway for those reasons
we're not allowing nulls
all right and so this is sort of like
burying the lede here because one of the
things that I that's a prominent issue
with the new collections which I haven't
mentioned till now halfway through the
talk is that the return collections will
all be immutable and so this is kind of
interesting because people who've been
working in collections have been wanted
wanting this for a very long time but it
actually also comes as a surprise to
many people so I should clarify at this
point that I'm talking about what I'll
call conventional immutability so what
that means is if you get a little you
see they list out of something then the
list dot add remove and set methods will
throw unsupported operation exception so
we're not going to do something like an
immutable persistent collection where if
you if you so-called modify it you
get back a new list that that shares
structure anything like that so we're
not doing anything these are these are
conventional conventional immutable
collections that reject requests to
change them so why are we doing this
well immutability is good turns out that
there's a very common case of if you if
you're working if you have some program
it's a very common case to create and
initialize a collection with a known
fixed set of values and then never touch
it thereafter and so it would be nice if
to say okay well if you know you're
never going to touch it thereafter then
you can you could make that collection
actually be immutable instead of just
sort of not modified by convention and
so that's particularly useful as
initializers in static final fields
another thing about them you immutable
structures is that they're automatically
thread-safe
so if you once you've created one of
these immutable collections then you can
hand it off to threads safely and all of
them will see consistent views of that
collection don't have to do things you
don't have to do anything special to do
that now I'll talk more about this later
but if you make a data structure
immutable then you don't have to have
the the support in the data structure
itself to accommodate future mutability
so it's one thing to say gee I'm going
to create a hash set and and never
modify it but if you know you're never
gonna modify it if you issue a different
library call then the library can do
something much much much more efficient
and so I'll have some more slides on
that later and then finally there's been
this this this dull roar over over over
a while which is the demand for
immutable collections in the JDK and so
various third-party libraries have
provided immutable collections but the
GDK has up till now not had any
immutable collection implementations so
here they are the JDK does have what are
what are known as the unmodifiable
wrappers so if you wanted an
unmodifiable list you could say
collections not unmodifiable list and
pass a list to it but that only provides
an unmodified
view the underlying list is still
modifiable and modifications to it are
visible through the thing returned from
unmodifiable list so it's not actually
immutable at all you can sort of get
immutability by creating a list wrapping
it and then throwing away the original
one but you have to make sure to throw
it away because if you accidentally leak
that reference then that actually can
become a security hole because it's not
actually immutable ok so here's here's
another design decision that that I
thought would generate a lot of
controversy but it was it was a
surprisingly surprisingly quick
treatment on this what happens if you
are constructing a set or a map and you
have duplicate and duplicate elements
for the set or duplicate keys for the
map and so I did a survey of a bunch of
different programming languages and it
turns out that most of them will have
some policy like last one wins and I
found this kind of surprising because I
think if you're writing out elements in
a literal and they're duplicates that's
probably a programming error and so
ideally if we had a situation where we
had a collection literal and all of the
elements were compiled time constants
the compiler would say ok I've detected
a duplicate and make that be a compile
time error but this is not a language
feature and we can't do this at compile
time from the library so the best that
the library can do is at creation time
Institute a fail fast policy where when
it's when it's actually creating and
populating a set or a map then it has
the opportunity to check for duplicates
at that time and if it detects one
basically the question is what policy
should be applied there and so basically
we've decided to make that be an error
because it's most likely programming
error and it'll catch errors sooner at
creation time instead of having some odd
behavior occur sometime at runtime so
most like I said most other languages
our last one wins
in my survey I found that there are a
very few number of programming systems
that reject duplicates in this fashion
and so closure is one actually closure
has two means of doing it there's a
syntax that does reject duplicates and
then you can call call some kind of
constructor and that that has a last one
wins policy and ECMO strict ECMO script
in strict mode will reject duplicate
duplicate keys if you have if you
specify if you specify them all right so
here's an example of that so here is a
slightly modified example which is
almost the same it has one in the
previous slide but see if you can detect
the duplicate yeah okay so there's few
people that have sharp eyes here so
there are two entries that have colon as
the key now so you can imagine though if
there were a lot more entries and you're
you're fixing a bug on a deadline at
1:00 a.m. be pretty easy to miss and so
somebody said oh you need to change the
entry for colon to some other value it's
very easy to imagine you editing the
wrong one and then banging your head
against the debugger for awhile
wondering why that the value didn't
value didn't take effect so anyway
instead of having last one wins or are
worse actually is one you know some
undefined policy where one of the values
will be chosen we've decided to make
this be a fail fast error at run time at
creation time all right so let me step
away from the API a little bit and talk
about implementation issues and I think
the the main thing here is about space
efficiency so let's take an example
where we take a hash set and add two
strings to it so here now there's this
weird thing about load factors and
number of buckets and so forth in order
to do this without resizing we actually
have to pass three to hash that so
basically we create a new hash set and
add two elements to it and then we wrap
it in the unmodifiable wrapper like I
mentioned earlier so that's the way to
get you know the equivalent of an
immutable set in core JDK libraries
today so how many objects get
created when you do this okay so there's
the unmodifiable wrapper itself
there's the hash set but it turns out if
you look at the implementation of hash
set hash set contains a hash map that
where the keys are the set members and
the values are just some sentinel object
so there's a hash map in there as well
now if you look inside the organization
of hash map there's an array which it
calls the table which is an array of
object and then the actual elements that
our members are contained in node
classes and so our node objects and so
now we're up to six objects and there's
one node created for each element
alright so here's here's a diagram of
that so we have our set variable it
points to the wrapper the hash set the
hash map the table the table contains
two nodes and each node contains
references to the actual the actual set
element which is the string and then the
sentinel value which is called present
and so that's the same object for the
same value for every object because this
is just the set and the value is
irrelevant
all right so how big is this so I made
some quick calculations here this is not
necessarily very precise because it
depends on a bunch of things about you
know what architecture the JVM is 32
versus 64-bit and so forth but I made
some assumptions about this the first
thing is every object in Java has a well
depending on the exact circumstances but
in in this case if you have a 64-bit JVM
with compressed oops each object has a
12 by table header so that's just
overhead there's also the fields in the
object and most of these are 4 bytes so
an object reference is 4 bytes if your
heap this small enough and things like
an int or float are also 4 bytes so if
you count these up we have 6 objects but
each has several fields in particular
hash map has six fields which is rather
more than I had expected and each node
actually has four elements because
there's not only the key and the value
but there's also a next pointer and then
the
code four four four quick hash checking
so it turns out that in order to have a
hash set with two string elements it
takes 152 bytes and six objects which is
really a lot of overhead because if you
think about it two string references is
just two object references of four bytes
each so a paint the payload is actually
eight bytes but it takes 152 bytes to
store that so that's pretty bad alright
so we can do a lot better than that
actually it's like shooting fish in a
barrel quite frankly it's really easy so
let's say we create an immutable set
implementation that stores two elements
in fields so it takes one object and we
store the sum of the elements in fields
and so you see the diagram at the bottom
we just have one object that takes only
20 bytes or so and so the point here is
that by creating immutable collections
that we have a lower fixed cost so just
creating one of these collections has a
certain amount of overhead and so that
that fixed cost is lower and then
instead of having separate node objects
we can add more fields or use an array
and so the variable cost that is the
cost per element is much smaller now
you're saying well what good is a set
with two elements and what if you have
one element or three elements so the
design of this API is intended to keep
all of this private inside the library
and and and have a bunch of different
private implementation classes that are
chosen by the factory method depending
on a variety of criteria so we might
have you can consider several different
kinds of data organization for extremely
small collections you might have you
might decide okay let's just have a
couple of fields and not have an array
at all so if you have a set of two
elements which might be very common
let's just store those directly in
fields in the object in fact we don't
even need to store the size because this
is a special case set object that knows
that it has exactly two elements now
there's a bunch of these little things
where you might have a set with zero
elements a set with one elements so
not gonna have too many of these but for
the the the space advantages for the
extremely tiny sets and lists and maps
is is is very advantageous now if you
get bigger you might say okay at a
certain point you don't want to write
you know filled with you don't want to
have a field based implementation that
contains 18 elements or something like
that so at a certain point you might say
let's let's fall over to an array that
is of exactly the right size and then do
linear searching on it and it turns out
that linear searching gosh you know you
don't want a linear slowdown for that
but there's a very complicated trade-off
between say a linear search and a hash
based search and I don't know exactly
where the trade-off is my guess is that
it is somewhere between six and eight
elements but I'm not sure we have to do
some benchmarking on that so there's
another approach which is to have an
array based scheme but then it does
closed hashing but you need to leave
enough space in there so that your
closed hashing can work effectively
because there are going to be collisions
in it and then for really big things we
might just decide to failover to a hash
map internally um although it's not
clear to me that's necessary but that's
that's an option that we might provide
anyway the point here is that we can
have a multiplicity of different
implementations and they make different
space versus time trade-offs and the
library is in the best position to make
those trade-offs another point here is
that if you looked at the the
organization of hash set before it had
six objects and so that required a lot
of pointer chasing and so one of the
problems with modern with modern
computer architectures is that if you
have a pointer to something if that's if
that's in a different place in memory
you might take a cache miss and so
looking at an element in a set even if
it has only two members might involve
several cache miss that misses and it
might end up taking quite a bit longer
than you might expect and so simply by
creating fewer objects and putting
things in the object itself instead of
having arrays and nodes and structure of
nodes and so forth will improve the
locality of reference and we hope
improve the access time considerably so
the idea here is that we'll have all
these different implementation
and they're all going to be private
api's and so the only thing that the
programmer sees is set thought of or map
thought of and the implementation will
be chosen by the library and it'll be an
implementation of some internal class
and probably I think collection size is
the primary criterion by which an
implementation will be chosen but we may
have that we may take things in - we may
take other things into account for
instance if the a 32-bit JVM versus a
64-bit JVM might have different size
characteristics and might change the
trade-off point between a field-based
implementation and an array based
implementation so we need to do some
more investigation there and we also
need to do some more research about what
thresholds at which will will switch
from one implementation to the next now
the idea here is that if these are all
kept private and opaque to the
application that we can change those in
the JDK at any time possibly even in
minor releases and the idea is that all
these implementations strictly adhere to
our classic list set and map
implementations so the application can't
tell when it gets a different
implementation mostly I'll talk about
that in a moment so but anyway the idea
is that we can change these compatible
compatibly in in any release possibly in
minor ones well now there are a couple
wrinkles that let the implementation
show through one is serialization and so
if you're familiar with serialization
actually the first thing is everybody
hates serialization the fact is
everybody uses it - so I think we have
to make sure that these implementations
are all serializable but if you do take
the straightforward approach of
serializing something the internal
structure of the object actually leaks
out into the serial form and that's
actually a compatibility issue for the
jdk so we have some things where we
would like to reimplemented
but they are locked into there they're
locked into their current representation
including the name even if they're
private classes and they're locked into
the all of that because a serial form
exists externally
applications are actually using and so
that's actually another axis of
compatibility that we have to contend
with so the approach we are intending to
pursue here is to create a serial proxy
class if you look at the the Boche
blocks book effective Java he talks
about using us what he calls the serial
proxying technique basically instead of
serializing as itself if you serialize
one of these collections that will
create a proxy class load the data into
it and then serialize that and exactly
the opposite thing happens we need
deserialize so when you DC RI is one of
these things the proxy will say oh okay
I am actually an instance of that
implementation over there and then
recreated at runtime so another way that
implementation details can leak out is
by iteration order so if you now this
only applies to sets and well hash-based
sets and maps and so if you read the
documentation you'll you'll understand
that the the iteration order of these
structures is undefined but it turns out
in actual practice that the iteration
order for these is pretty stable and
since things like strings have really
bad hash codes the iteration order is
often very very predictable so if you
put one letter words in like set thought
of a B and C the iteration order is
actually ABC I mean so it's it's it's
pretty bad now it turns out that yes yes
yes the specification says iteration is
or order is undefined programs must not
rely on specific order of iteration the
fact is this happens all the time and so
it's it's very easy in fact it's
happened it's happened inside the JDK we
actually have had some problems where we
changed one of the data structures to
have a different iteration order and a
bunch of things broke it was really
painful in fact I think we we had to go
change it back and so this is a problem
because the iteration order is
supposedly unspecified but is actually
very stable which leads programs to make
indan inadvertent dependencies on that
order but then we go to change it and it
breaks a bunch of stuff so that that
means that there's
actually changing it so so that's a real
problem and well actually what what's
really the problem is there are times
when we actually do need to change the
iteration order so for instance in Java
8 the internal organization of hashmap
changed under certain circumstances to
be a each each hash bucket became a tree
instead of a linked list and so that
changed the iteration order and that was
unavoidable so that exposed some
programs that inadvertently had
dependencies on ordering to different
behavior and it caused those programs to
break so in the previous slide I was
talking about oh we can have all these
different implementations field based
array based hatch base and so forth and
then the library is going to choose one
of those and the application doesn't get
to choose which it is well if the
library chooses then that means that the
iteration order is going to be
unpredictable and I think that's a
feature and so in order to make sure
that's unpredictable we're gonna add a
random number to the hash code so that
the iteration order is randomized now
ideally if we really want to flush out
bugs in application code we would change
the iteration order on every single
iteration but that's actually a little
too much overhead and so probably what's
going to end up happening is that the
iteration order will be fixed for a
single run of the JVM but each different
run of JVM can have potentially a
different iteration order and so the
idea here is to kind of toughen up
application codes so it doesn't
inadvertently build in order
dependencies on iteration and so if you
accidentally write that code and you
have tests maybe your test will pass
once but if you run the tests again look
at a different iteration order and it'll
break pretty fast we hope so that's the
current idea here now note actually this
is only this randomized iteration or
order idea is applying only to the new
collections implementations the existing
collections implementations will retain
their current behavior I think there's
would be a pretty aggressive move to
make them have randomized iteration
order as well and I think that's an
interesting idea to talk about but
that's
not on the table at this time all right
so there's life in the old collections
framework so Java eight had lambdas and
streams Java 9 has modules but the
collections framework is still there but
we're still working on it so if you look
at my other talk there's a lot of stuff
added to the collections framework in
Java 8 and so what we covered in this
talk was a new set of api's and
immutable collection implementations
that provide space efficient and
convenient collections to applications
so I have a couple references here there
is the the slides for my Java one talked
a couple weeks ago are available at that
link and then Jeff 269 which is the jdk
enhancement proposal is is also
available that link so thank you I have
a couple minutes for questions if we can
open it up for questions and comments
right here sorry
okay so the question is so that the
implementations are not going to be
available in the public API but is there
going to be a builder No
so now if I think that's an interesting
use case and we might consider it kind
of the the escape hatch for that is if
you want to if you want to create an
immutable collection with a list of
objects that is computed then the way to
do that is to create an array containing
those elements and then call one of the
call of the array column one of the
factories that takes an array okay
another question right down here I'm
well the question is about optionals but
what about what about optionals okay so
no there's no special case handling for
optionals if you create a list of
optionals you get a list of optionals
for a variety of reasons I wouldn't
recommend that but I mean if you really
want to create a list of optionals you
just get a list of optionals other
question right here sir
okay ah so what's the quote what's the
reason for having the fixed args over
loads so basically its efficiency and so
if you look at the way that VAR args are
implemented then the compiler generates
some code that says okay well there's a
certain number here and so it generates
a bunch of byte codes that creates an
array and then loads those values into
the array and then on the Cawley side
the Cawley gets an array and then what's
going to have to happen is that those
are going to be copied out and so with
fixed args overloads there's a direct
path because the the overload if there's
a if there's an overload with three
fixed arguments it knows that it's
creating a list with exactly three
elements and so it can take a shortcut
there and that bypasses some copying and
memory allocation overhead hey one more
question that up there okay so a
question was why don't we why didn't we
just adopt Wafaa
and so we we talked to the guava guys a
fair amount back we don't talk to them
enough and we've taken some ideas from
guava and I think we will
I shouldn't say taken we've we
collaborate with the guava with the
guava team and we share ideas and and
pick up pick up ideas where it makes
sense and so one of the things is that
guava has a very large set of
collections collections libraries and
implementations and you know we've
considered picking it up but it's not a
matter of taking all of it we might want
to take some subset of it and in fact
this is sort of like taking some subset
of and one of the responses has been oh
yeah well this is just like guava is
such and so such and so one of the
aspects of the guava collections is that
they have immutable types in the type
system and so whereas here we just say
set of something and we get a set
implementation that happens to be
mutable guava you can say I want an
immutable set of and so that's actually
in the types of
there and so but if you well it's a
little bit a little bit Duty too
detailed for for this for the 30 seconds
remaining but if you look at their class
hierarchy it's actually it's actively a
little contorted and it's it's I
understand why they ended up the way
they did and they had good reasons for
doing that but it makes things a lot
more complicated so instead of just
taking guava or trying to do some
engineering of factoring out little bits
of guava
I think we're taking I think we're
taking some ideas from guava and in fact
the couple guys from guava have reviewed
this API and we've been discussing it so
I think there's there's some definitely
some influence there but it's really not
a possibility to just take all of guava
and adopt it so my time is up thank you
very much for your interest and
attention</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>