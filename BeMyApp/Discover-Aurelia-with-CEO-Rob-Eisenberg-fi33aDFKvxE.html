<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Discover Aurelia with CEO Rob Eisenberg | Coder Coacher - Coaching Coders</title><meta content="Discover Aurelia with CEO Rob Eisenberg - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/BeMyApp/">BeMyApp</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Discover Aurelia with CEO Rob Eisenberg</b></h2><h5 class="post__date">2016-03-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/fi33aDFKvxE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everyone and welcome to this special
edition webinar featuring irelia
flip-flop Eisenberg will be starting in
three minutes
Solis again will be starting in three
minutes you guys very soon
you
hi everyone and welcome to this webinar
featuring aralia J s we actually have
the CEO Rob Eisenberg co-founder of the
platform he's here to speak on the
actual subject and as well demo a few
examples and samples we really help you
discover it it's all full potential
so if not I will give the platform up to
Rob Rob you ready I'm all set thank you
all right well thank you very much for
having me and it's really a pleasure to
be with you and thank you everyone who
is here attending and I really respect
your time and interest in what we're
building what they're really up so s was
said my name is Rob Eisenberg I am a
software developer an architect that has
been working in the space of front-end
engineering for quite some time now over
10 years I've been building basically
tools and frameworks for front-end
development across the host of platforms
including things like windows unity 3d
all the zamel platforms flash flex
silverlight and the web and it's really
just been my passion for a very long
time to make front-end development
simpler make it elegant easy to build
what you need to build as part of your
job and but to be able to do it without
cutting corners as well to be able to
write really high quality code but but
to do it in the easy and sensible way in
2014 I spent some time working with
Google as a full time consultant to the
angular 2.0 team and I did that for
about ten months they had hired me
because of my breadth of experience in
this area and after about 10 months or
so it became abundantly clear that their
vision in mind were not the same we had
a lot of disagreements across a lot of
different areas and at that time I
decided to leave
and when I left I was still no less
passionate about front-end development
and helping developers to solve the
problems that they face in the real
world
so I began working on Orillia and it was
in the beginning of 2015 that we founded
a new company
Durandal Inc with me as the CEO with a
number of founders and a good sized core
team for the purpose of really bringing
Orillia to life as the platform solution
for future web development and it's been
a really exciting time over the last a
little bit over a year as we've launched
the product and seen just a fantastic
community response to it and so I'm
again just really excited to be here
with you today to show you what we've
been working on and hopefully you will
see that it's something you're gonna
want to use in building apps in the
future I Rob if anybody has any
questions we highly recommend you that
you actually just ask the questions on a
youtube channel so in the comments
section just ask any questions there
we're checking them like all the time so
at the end we can actually review them
so well can check them out Bob back to
you thank you so what we're gonna talk
about several things today first I just
want to give you a high-level view of
what it really is and the philosophy
behind it how its put together I want to
take you through a few awesome things
that really can do starting from the
hello world and how that's unique even
from other platforms and then I want to
take you through a few things that you
may not have seen before and then I want
to do a quick comparison with some other
similar technologies so you get a feel
for how really it fits in how it plays
in terms of its performance its size
standards compliance all these sorts of
things and then I want to give you a
final update on the project what is our
status what are we working on in our
next steps so you can have a feel for
where we're at and where we're heading
so with that let's begin by talking
about what is Aurelia and and its
simplest form it's just JavaScript but
it's actually a
script 2015-2016 javascript so we've
written the framework in the platform
from the beginning using the most modern
JavaScript that we can and we really
wanted to imagine what would it be like
to build a next-generation platform
starting with next-generation JavaScript
from the very beginning so in its
simplest form earlier is just JavaScript
but it's very modern JavaScript you also
hear me referring it referring to it as
a platform or a framework and that's
because it really is an all encompassing
set of libraries to help you build
front-end apps but it's not a monolithic
framework or one gigantic library it's
actually a collection of collaborating
libraries so we've been very careful
from an architectural perspective to
take Orillia and to break it into a
number of smaller libraries that you
will usually use as a group but you
could also use individually in other
projects some even on the server side
some and other non Orillia front-end
projects as well and we've just spent a
lot of time architect architecting this
and in a way that is consistent with
good architecture regardless of the
platform in terms of just building these
small focused libraries but that all can
come together to give you a very rich
application development experience so
what is the purpose of this javascript
in this collection of libraries well as
i've mentioned it's really about
building javascript client apps these
could be apps for the browser this could
be hybrid mobile apps for phone and
tablet this could even be desktop
applications via technologies like
electron or nwj s so really it's about
building the front end of your
application regardless of what platform
you're on for the web or even like I
said desktop or mobile and it's about
using open web technology to do that we
leverage of course in the same way that
we leverage the most modern JavaScript
we also leverage the most modern
capabilities of the web in terms of
using the modern Dom so we have no
abstractions away from the Dom to hinder
performance sort of caused memory
problems we are bare to the metal using
the modern Dom api's to their fullest we
also integrate with upcoming standards
like web components so you'll see as we
go through the demos today you'll see me
using
Gmail template elements and things like
this which are part of the web
components technology so it's modern
JavaScript and it's the most modern in
terms of its use of the DOM and
browser-based technologies and it brings
us all together for building the front
end of your app regardless of where you
are going to be deploying through the
browser or through app stores or through
just downloading and running an app on
your desktop what is the philosophy of
of aurélia well first of all what we
built here is completely open-source in
its MIT license so you can take this
code you can take these libraries and
you can use them in just about any
scenario you can imagine with no fear of
any sort of legal or IP issues the MIT
license is a very permissive license
it's the same license that projects like
jQuery used for example it's very common
for web technology to be MIT licensed so
open-source very permissive lis license
and it really is really about helping
you to write clean code and it
accomplishes this by providing some
simple conventions very much the way a
lot of modern MVC frameworks work so if
you've ever looked at Ruby on Rails if
you've ever looked at sort of the more
recent versions of Microsoft's MVC
framework or any of the modern MVC type
frameworks they usually have a little
bit of conventions built in and this
allows you to build your apps in certain
ways and for the framework to stay out
of your way if you need to get really
clean code really high productivity do
things the right way and not get bogged
down with the details of the framework
so much and that is really the same
philosophy that we have with aurélia
clean code through simple conventions we
also leverage a lot of modern tooling
and this just unable to developers to be
very productive again it helps in
enabling you to use the most modern
JavaScript in your own apps the most
modern testing capabilities and linting
capabilities and all the sort of things
that you'll want for building a real
production app and so we really favor a
lot of modern tooling and we put that
together for you so you don't have to
worry about how that all works out and
then I would say that we've really
focused on what
the LEDs and these are things like
testability maintainability
extensibility learnability all these
sorts of characteristics of the app that
you would like to have but are easy to
go by the wayside if you're not working
really hard on them and what it really
wants to do is make it easy for you to
accomplish these things making easy for
you to write testable code easy for you
to write maintainable code easy for your
code base to be extensible and for new
developers to come on board and to learn
it and so this is really baked in to the
core philosophy of Orillia in terms of
everything that we're doing how we're
building the framework and how we're
helping you to build apps we're always
thinking about these sorts of things the
great thing I mentioned earlier is that
we've only announced a really a little
bit over a year ago that was the Alpha
released and we've seen a rapid adoption
and a very large active community
growing up around this just to give you
some stats within a one year time period
we have across our libraries over 7,000
stars on github we have over 3,000
developers in our git er chat room with
approaching a quarter million messages
between those developers so a lot of
activity huge group we have over 300 I
think we've got about 310 contributors
to the project now and we've got a core
team of about 15 developers so it's a
very successful project a fantastic
community a very welcoming engaging
community very active community a lot of
participation so I it's been really
exciting to see that happen and that's
an important characteristic of what
we're building and on top of that though
we wanted to make sure that everything
we were building was commercially backed
one of the biggest problems in the
JavaScript world if you're trying to
support that the technology that you're
building is a lot of these frameworks
and libraries have no real substantial
backing behind them even the ones that
are built by large companies have no
official channel for support no official
channel for training or consulting
there's no way to opt in to any
commercial options that could give you
prioritized bug fixes or any of these
sorts of things provide you the support
that you would have
say if you adopted a native platform so
all that infrastructure around native
platforms is very much missing in a lot
of the JavaScript world and what we have
done is said you know we're gonna solve
this technology problem but we're also
gonna solve this side of the business
problem that's really important for this
and so that's another important aspect
of what we're doing with it really is
making sure that there's a solid
business and all those options
commercial options are there for you to
optionally take advantage of if you
desire well that's enough of the what
let's actually build build some little
demos here and give you a feel for how
Orillia is used if you want to get
started with Orillia usually the best
way is to download one of our beginner
kits and there's a getting started guide
in our documentation which will take you
through downloading one of these kits
there can be unzip there's nothing that
you need to install no setup you need to
do nothing at all with these beginner
kits they're just download unzip and go
we tried to make that really really easy
after you get through the beginning
process of learning and becoming
familiar with things and you're ready to
start building a production application
we have a separate set of kits which are
configured for production workflows and
those doing you know require a little
bit of installation and setup but that
also is gonna bring you a lot richer
functionality and things that you would
want if you're really building a
production app but when you're just
getting started you can use one of these
beginner kits and not have to worry
about all that and instead focus on
learning and experimenting with the
framework let me just show you real
quick our website because this is the
place you're gonna want to go to get
more information about Orillia and to
download these kits and read the
documentation so obviously we have our
home page you can learn about all kinds
of things like support consulting
training you can take a look at our core
team our founders and everybody that's
officially working on the project a
place we'll probably spend most your
time is in the docs and there's a number
of articles over here you can see
there's kind of different profiles
depending on how you describe yourself
to get different kinds of content you
can also see that all of our libraries
are documented all the methods classes
so if you're interested
learning about how dependency injection
works you can click on that library and
you can come in here and you can look at
any of the classes that are exported
such as The Container and see all the
information about it you'll probably
want to start in this article section of
the documentation reading through it and
learning a bit about really on how to
use it and the place you'll really start
is in this getting started guide and
here are these two kits that I just
talked about that you can choose between
based off of whether you want to do
standards compliant JavaScript basically
or whether you want to add strong typing
to it through using something like
typescript so this getting started guide
will take you through building your
first app so this is a good resource to
know about when you're getting started
what I'm going to do is I'm going to
take one of our kits and I'm gonna build
a sample app from scratch for you so
here I've got Visual Studio code open
which I'm going to be using for working
today on Aurelia you can use any code
editor you want we have great support
for atom for sublime for vias code
webstorm Visual Studio all the popular
editors vs code has really fantastic
support for intellisense on JavaScript
and you'll see that as I go along so
it's a really nice choice it's also free
open source and cross-platform so it's
it's an excellent choice I'm gonna use
that today what I'm gonna do is I'm
gonna start by building a real sample
app here I'm gonna keep it real simple
at first the place we're going to look
at beginning is the index.html and this
is just a place you would probably look
with any sort of application and so with
an aurélia app it's a JavaScript app so
you're not gonna see a whole lot in the
HTML file the HTML file the index.html
just serves to get the application
started it's a bit like its bootstraps
the application so let's look at what's
what we have in this index.html it's
going to look almost identical for every
aurélia app that you write in the head
of the document we have the title and
some metadata that's really not that
important let's collapse that the real
interesting part is in the body and in
the body you're gonna see that we have a
couple of script tags the first one is
system J s system J s is
the library that implements the equi
script six module loader so in modern
JavaScript we actually have modules we
actually have classes and a lot of
things that other platforms that have
for a long time so that's all been
brought into modern JavaScript but to
work with modules we need a module
loader this is the thing that
understands the dependencies between
modules make sure these things get
resolved correctly and optionally lazily
loads modules if necessary so system j/s
is going to give us the module loader
config jas is a file that configures the
loader it's generated by our tooling and
I'm not going to go into the details of
that right now
but suffice it to say that when you
request a module that lives somewhere on
the web server and config j/s has the
information for the loader that tells it
how to map from the user friendly module
name which you will use in your code
back to the path on the web server where
it's located
you don't write this by hand the tooling
generates it but you just include it so
that the module loader has the
information it needs to properly load
modules now once you've got your module
loader and its configuration scripts in
place all you need to do is bootstrap
the framework and you do that by calling
system import system is the API provided
by system j/s to actually import modules
in the Orillia bootstrapper module is
one of the modules that we provide its
sole purpose being starting up your
application it it configures things and
gets everything in place and then
renders your application and one of the
things that this bootstrapper module
does resemble a look at your HTML page
and it will look to see do you have any
irelia app attributes anywhere in your
HTML page and if it finds those it
understands that you as a developer
intend the element that that attribute
is on to be transformed into in a really
app in other words aurélia is going to
render the user interface into that
element and by convention if you don't
provide any value for this it's going to
go out and it's going to assume that
your app has a root component called
app and in earlier everything is built
in terms of components every component
has to
it has a JavaScript part and an HTML
part the JavaScript part has the state
and behavior of the component the HTML
part has the content that what is
rendered by HTML and CSS and in this
case every application and really has
what's called a root component you can
liken this a bit to something like a
main window or a main layout or a master
page if you've used a number of
different depending on what your
background is but it's that root
component that everything is inside of
because in Orillia we break user
interfaces down into small pieces inside
of your root component you might have
child components like a navigation
component and some something that
displays the current screen that you're
navigating to and inside of that screen
you might have child components that
display forms and different kinds of
things so but at the root of the app is
this one app component and by default
the convention is that it's called app
so it really 'knows that if you don't
specify something different it's going
to go look for this app component and
it's going to load it up and it's gonna
render it into the body tag now all
these things are configurable and over
aidable but this is the simple set of
conventions and it's the way that most
people do things so let's write this app
component to do that I'm going to come
over to my source folder and I'm going
to create this component and remember
that components in Orillia typically
have two parts the JavaScript part and
the HTML part so first I'm going to
create the app.js file that's going to
be the JavaScript part of my component
and I'm going to create a class
hey Rome it looks like
can you hear me yeah nobody can hear you
sorry I'm not sure what just happened
there
I might have bumped the mute button on
my mic so I'm gonna create the I'm not
sure where it cut out so let me just
back up a minute um I'm gonna create
this app level component and as the two
parts the JavaScript part and the HTML
part so I'm gonna create the JavaScript
part first called app j/s and I'm just
going to create a simple class called
app that's exported and I'm going to
give it a constructor with a simple
property called
and that's it so this is the JavaScript
part of our component doesn't really get
too much simpler than that I'm gonna
write the view part of the component now
and we get of it the same name app but
with a different file extension app HTML
and the framework just understands this
is how you build components so all you
have to do is follow this naming
convention I have my JavaScript file and
I have my HTML file for each component
and inside of the view
tag template tag comes from the web
component specifications so we're
actually using web components technology
to define the view for our aurélia
component so every view will have the
template and for this simple example I'm
just gonna put an h1 tag in here and I
want to render a message out here and
what's cool about it really is inside of
the view for a component all the
properties and methods of your
JavaScript class are available in the
view so this message property is going
to be available inside of this template
here and all we do is use the simple
binding syntax indicate that we want
that message to be rendered into the h1
tags content and if you're familiar with
extra script 2015 you'll notice that
this dollar sign curly brace syntax is
actually the same syntax that is used in
echo script 2015 string template
literals so we have borrowed the syntax
wherever we could from modern JavaScript
and made that work inside of HTML where
appropriate so here the same syntax used
in JavaScript for interpreting values or
variables into text you can use that
also in HTML now I'm going to go ahead
and get this running I'm using our
production kit so I'm going to go ahead
and start up a little web server here to
serve this content and then I'm going to
jump over to the browser and refresh it
and you'll see now that of course there
is that component that we wrote and if
we look in the Dom let me just make this
a bit bigger for you and we look at the
elements you'll see that there's our
body and right into the body it rendered
that h1 tag and inside of the h1 tag is
the content of our message so it's
really that simple and in fact this is
the way that you're going to go about
building all sorts of things and I
really am and what I want to point out
when I talk about awesome things that
are really a can-do look at the
JavaScript here you should
notice something is missing from the
JavaScript and it's fantastically
missing and what is that well you don't
see the Orillia framework you don't see
me importing any third-party libraries
you don't see me doing any configuration
of the JavaScript you don't see me
having to add any metadata any of that
kind of work what we have here is the
ability to create components out of what
your app is built by using plain
standards-based JavaScript with no
intrusion into that JavaScript from the
library or framework itself now in more
advanced scenarios you do have to work
with there really is libraries directly
however in a large percent of the cases
you don't have to import anything that's
a really a specific and in the place
even the places that you do it's
extremely minimal so the framework stays
out of your way and I'm showing here I
consider to be a very awesome thing
because there's in fact no other
framework or library in existence that I
am aware of that lets you build UI
components out of plain JavaScript
without even having to import any
library specific configuration or api's
at all this is a hundred percent your
JavaScript here which means when you're
writing your app with the really the
bulk of what you're going to be writing
is gonna be your code you're not going
to be writing a really a code per se
you're not going to be using our API is
extensively you're not gonna find our
API is littered throughout your code and
remember we talked about the illah DS
that we try and focus on maintainability
extensibility testability the more that
the framework stays out of your way that
you don't have to engage our api is but
that you can just write pure plain
JavaScript the easier it is to
accomplish all those things you get much
higher maintainability from the
beginning just by the nature of this
framework you get better extensibility
it's much easier to test these things so
although you're looking at a very simple
example right now it shows something
that I think is completely awesome and
very very important to the development
of real-world applications which is the
framework gets out of your way and lets
you write your code now let's move on
let's
do some other things I want to go beyond
this and I want to show you a little bit
more data binding so I'm going to add
some properties here
pretty and I'm going to add a last name
property
down and I'm going to add a I'm gonna
add a computed property and I'm gonna
call it full name it's gonna have just
going to use a bit of string
interpolation to have the
the left
returned from the property okay if you
haven't seen this before
these are property getters and it's
standard JavaScript and this backticks
syntax with the dollar sign is a modern
JavaScript feature for interpreting
variables into strings and as you can
note again it's the same syntax we
borrowed for our templating language
directly out of JavaScript so we try to
be consistent there but what I want to
show you is how I can now have user
input to type the first name and last
name and how I can render the full name
in real time as I mentioned every
property is available in the view that
is in the JavaScript so I'm going to put
an input control in here and I wanted to
value property to be bound to the first
name property of our our JavaScript
model okay and
i roam oh it looks like you're muted
right now sorry it for some reason keeps
meeting and unmuting so I'm not really
sure what's happening there I'm gonna
bind the last name to this second input
I'm gonna put the phone aim down here
interpolated I'm going to use another
interpolate advantium all right let's go
back over to our running app here you
can see or make it a little bit bigger
for you but now we've got the first name
rendering in this input box the last
name rendering in this input box and the
phone I'm rendering below it and as I
type you'll see also that name updates
on the fly this is a really is data
binding it's extremely powerful and
again notice that it's just plain
JavaScript that we're writing here
simple properties 100% pure vanilla
JavaScript but we're able to render that
in our view using this very simple
template anguish so before we had the
string interpolation or expand for
binding into the content but we can also
data bind any HTML attribute by simply
appending dot bind to the attribute name
so here we're binding the first name to
the value and your remaining the last
name to the value and it's really that
simple
what the dot bind what we call it's a
binding command what it tells are really
have to do is it tells it to use the
most reasonable binding behavior based
on what attribute and element your data
binding so if your data binding the
value of an input control it knows that
it should do bi-directional or two-way
data binding meaning that it will flow
data from your model class into the view
and from your view back into your
JavaScript model it will flow the data
both directions now anything other than
a form control anything other than
something that wants user input in that
way is going to use one directional data
flow by default so I really just knows
this is the best practice for you know
so the href of an a tag it just knows
that you want to use one directional
data binding but it knows that for
things like inputs and text areas and
selects that you're going to want to use
to a data binding and so this is the way
that the convention just makes learning
and using the framework simple but of
course you can always over
any of the behavior you want so if I
want to be explicit and say that this is
using two-way data-binding I could just
say two-way or if I want it to only use
one-way data-binding I can say one way
for that unidirectional data flow or if
I only want it to bind one time and
never synchronize thereafter I can say
one time you have we have the
conventions but you also have full
control over every aspect of the
framework but these conventions make it
really really simple and powerful to
build things okay so this is you know
like 60 or 70% of the data binding
framework that you've now learned here
and you can see how simple it is with
just interpolation or simple binding
let's go on and let's do a little bit
more here I want to have a list of
friends so I pay and then I want to have
a method called add fresh
to friends so my addfriend method is
going to every time the execute is going
to add a new friend to my list and I'm
gonna have another property I'm gonna
call potential friend this is gonna
store the name of somebody that might be
my friend if I and whether I choose to
add them
if we have a value and potential friend
we want to push it into our friends at
okay just produced pretty
straightforward
after we and after we do
at
a real sip here for adding friends again
this is just pure JavaScript this is how
you might do it if you're just doing it
in JavaScript representing the state and
behavior of your component we have the
ability to add friends and we're gonna
add a friend for whatever we have in
this potential friend property let me
show you how that plays out we're gonna
add down below here let me just add a
little little B
another input
his name and we're going to
whatever we're typing in this input box
will always be synchronized with that
property and then we're going to have a
little
to a difference how do we make this
button trigger that method addfriend on
our component well it's really the any
event in the Dom you can append the word
trigger and win that event fires it will
trigger the method on the component so I
can say click trigger equals ad
so whenever that button is clicked the
ad friend method will execute if there
is a value in potential friend which you
can see is coming from this input if it
has a value it's going to push it into
our friends array and then clear out the
potential friend value now we want to do
one more thing we want to be able to
have a list of our friends so let's add
a ul and for every friend in our array
we want to have an Li so how do we do
that well Borrelia we simply say repeat
for
yes and this is going to generate an Li
for every friend in that friends array
and notice that this syntax for a friend
of friends if you're familiar with
modern JavaScript
yes 2015 it adds a new loop type called
the for of loop for looping over any
type of iterable arrays Maps sets etc
and again we've adopted the same syntax
that you would learn for JavaScript and
we've enabled that syntax simply inside
of our HTML template language so you can
repeat over any array some of you by
saying repeat for a friend of friends
and inside of this LA of course I want
to render out the friend okay that
friend is our local variable inside of
the loop because this is a data binding
framework what this means is as that
array changes over time the lis will be
generated or removed over time so
everything will be kept in sync okay you
can see as I type and I hit add friend
we see Bob is added and then the
potential friend is cleared out there by
clearing out the friend's name box all
right so we've got one way binding
string interpolation two-way binding
repeating over arrays and again notice
that our JavaScript is just a plain
JavaScript class in fact there's nothing
remarkable about this code whatsoever
and that's actually a fantastic positive
characteristic for your components to
have it's just the Nilla javascript well
let me show you a couple really cool
things that are really a can-do that go
beyond this and the first thing I want
to show you is that every component is a
custom element and so because I have
this app root level component I can
actually render it again using an HTML
tag called act based off of the name of
the component
now I don't want to do this because this
is going to recursively render forever
so what I'm going to do is I'm going to
create an input of type
check box and I'm going to bind the
visibility of or the presence of this
app component to whether or not this
checkbox is checked and in this two
elements to create a reference to an
element you simply use the ref attribute
and give it a name so we're going to
call this the recursive checkbox and
then I'm going to conditionally have
this app HTML element rendered in here
and to do that I use our if behavior so
I say if not find recursive
other words I've given this I've made
this input of type checkbox'
referenceable with the name recursive
and then i've data bound this app
components visibility or not not really
its visibility but really presence
inside of the Dom to the checked
property of that input control so as I
check it I should now see the entire app
recompose itself inside of itself
recursively so let's see if this works
let me just add some here and as I check
the checkbox you see we get another
instance of app composed internally and
of course it has its own state every
component related the way in a component
should be and it really am so the state
doesn't mix between the two and we can
go on and on and on like that and so
every component again without changing
any code pure plain vanilla JavaScript
your HTML every component your write can
be used as a custom element so you get
really great reusability this way but it
gets even better than this because this
is static composition meaning I knew
that I wanted the app component here at
runtime but what if you don't know what
component you want at runtime what if
you've got data coming from the database
or configuration data or based on a
different user based off all these
runtime data characteristics you need to
compose different components based off
of that data well then you can use this
compose element in Orillia and it has a
view model
Oh points to give it a module ID - any
component module and it will dynamically
render that component as well and what's
really cool about this is that because
we have data binding you can actually
bind this new model to some property
on a class and as that property changes
over time Aurelia will recompose the
content of the Dom based off of that
value so this gives you extremely
dynamic powerful user interface
composition or even the entirety of your
units or interface it's possible to
construct at runtime based off of data
so it doesn't have to be static alright
so that is some of the really cool
things really can do again it's about
plain simple JavaScript no framework
intrusion or as little as possible it's
about having a simple but powerful data
binding language you've learned most of
it right here you've learn how to use
repeats and ifs you learn how to do
references you learned one way in a
two-way data-binding and you've learned
string interpolation that's the bulk of
what you need to do furthermore you've
learned that all the components can be
used either statically or dynamically by
using them as an HTML element in your
view or by using this compose special
compose element that we provide to
dynamically render different components
based off of data by combining even the
features i've shown here to you in the
last 20 minutes
it's literally possible to create just
about any application you can imagine so
I'm going to stop there with what I call
the kind of the hello world demo I'm
going to show you a few other demos that
are a bit more advanced and just to
highlight a few of the cool things that
really can do that you may not have seen
in other places at all either so I'm
going to open up some demos that I have
here and
now I want to show you a few more demos
we'll start at the index.html just like
we did before notice how this index.html
is the same as the other one it's a
completely different app but usually
your index will be just about the same
for every app so you can see it's got
source
it's got config it's got the
bootstrapper this time I've also
included bootstrap to just get a few
default styles
the main difference you'll see is that
this is really a app attribute now has a
value whereas before it didn't have a
value before we loaded everything up by
convention but if you provide a value to
that attribute then you can actually
write a special main module that gets
access to there really a framework
object and lets you configure the
framework before it starts so here I'm
just telling it to use all the standard
configuration options to turn on our
logging for development to start up the
framework and then to set our root
component to this special root component
for this particular demo so as I
mentioned we have these conventions but
you can always override things and even
when you override it and take control
you still have a very simple and elegant
API that you can use so here I want to
show you a capability of really called
HTML components and this is the
capability that allows you to write
custom elements or components in Orillia
using only HTML and no JavaScript
whatsoever
so let me actually just show you the
demo and this is just a very simple demo
of a couple of elements that input your
first name and a color and then render
out this name tag component you can see
if I change the name to Rob it's there
and if I change the color to blue it's
there so you can see how the component
is updating in real-time based off of
the data that I'm typing in these boxes
let me show you how this is built again
just like before we have our app
component our route component and you
can see that it's just a simple class
with the first name and a color property
and then you can see in its view and you
see that there's a form here that's
again using some bootstrap but it's just
collecting the first name and the color
values and it's binding to them but now
you can see something we haven't seen
before which is a custom element
called nametag which I wrote for this
demo and the name tag has its own
properties such as color to bind in the
color from this input control and it
also is able to bind the first name into
the content of the name tag now the cool
thing about this name tag component is
that not a single bit of JavaScript is
involved in authoring it in Aurelia's
views views are encapsulated and you can
require certain resources into your
views you can require custom elements
you can require in extensions to the
binding system it's a very fully
extensible pipeline free of you that
allows you to extend our templating
language in all sorts of ways and so
what i'm doing here is i'm basically
importing or requiring in an HTML file
and when you require an HTML file in
Orillia it automatically transforms that
HTML file into a component that can be
used as a custom element so because
we're importing the name tag HTML file
we have a name tag custom element in our
view that we can use and let me just
show you the component itself isn't name
tag HTML and you can see that it's just
HTML as you know that text hello my name
is there's some CSS that we're applying
the interesting thing is you can see
this content tag this is again borrowed
from web components the shadow Dom
specification allows us to can't do
can't what's called content projection
so that means that whatever is the
content of the custom element is
whatever is inside of the name tag when
it's rendered is going to be projected
into this location in the view so that
the name in this case will be rendered
inside of the body div so you can see
that we have this HTML here the other
cool thing you can see we can do in our
views is we can actually import CSS so
this name tag CSS is the CSS that is
only for this particular component so we
can assure that the CSS that's required
for the name tag element to render
properly is always loaded and available
before the component renders so you can
just write CSS like normal here I've
written some CSS to make it look like a
name tag and I've required that inside
my nametag component so that that CSS is
there and the name tag gets styled
correctly you can also see that I have
on my template some special attributes
one is called bindable and this allows
me to declare properties on the HTML
element that I can data bind to so here
I'm saying bindable color and then when
I use that element I have a color
attribute which I can find too I also
have this property I also have a special
property called CSS which really
provides in order to let you interpolate
values into the style so you can see
that the style background style is bound
to whatever that bindable color is and
this is how whenever you set the color
over here in this data binding
expression it will flow into the name
tag element and style the background
with whatever that color is so you can
see you could write JavaScript to do all
this kind of stuff and more advanced to
related components always usually
involve JavaScript just like in the
hello world demo I showed you with app J
s and app HTML and the component here
that is app J s and F HTML but for
really simple components components
where it's really just a reusable view
with a little bit of templating and some
properties that you need to set you
don't have to worry about writing any
JavaScript you can just write the HTML
and then when you import it into your
view you now have a reusable custom
element that can render itself entirely
from HTML you can see again I can use it
as many times as I want it's completely
element ok pretty cool so that's what we
call HTML only components for a minute
yeah we have a couple of questions there
so we can start already with the Q&amp;amp;A
that's fine with you I guess so I was
hoping to have a little bit more time
but yeah we can't cut the rest of the
presentation I thought I had a full hour
to present I'm sorry no worries if you
want a let's give it about 5 more
minutes and then we can start the Q&amp;amp;A
okay sure let me do a few more demos let
me show you another demo here
metaprogramming components
app I'm rendering and I want to show you
another component example here I've got
first
texe being rendered but what's cool
about this example is I'm actually
writing my component with markdown now
this is not something that's built into
the framework but this shows the
extensibility of the framework you can
actually teach Orillia how to interpret
different types of files and different
modules and so what happens here is I
wrote a plug-in to Orillia that lets you
require any markdown file and it turns
any markdown file into a custom element
and here's the markdown file you can see
it's just got some basic markdown it
even has content projection into the
markdown and inside of a root of the
component
I'm just importing that markdown file
and then using it as a custom element
again this is not something that really
does out of the box but you can tap into
our view engine and teach it how to load
and render different file types inside
of a view so that's really cool let me
show you a bit more of what it can do
I'll show you another quick example
called binding sin
people don't realize that we have in
Orillia that we've been binding to is
actually decoupled from our templating
language so here we have a very simple
demo like what I showed you before but I
want to show you inside of this binding
syntax demo again we have an app just
just like before but looking at the HTML
do you notice something here I'm using
an NG model attribute and I'm using
double curlies well it turns out that it
really is behind in syntax is decoupled
from the templating language so I can
actually on a per view basis or even
globally override the data binding
syntax with custom syntax so here I've
written a real simple plugin that
implements a segment of angularjs is
data binding syntax and by importing it
into this view I've effectively changed
the syntax for data binding in this view
so now I can use angular syntax now it's
still a really under the hood and it's
still using all of our mechanisms to
actually do the data binding but instead
we've got syntax that looks exactly like
angular now I actually can show you
something even cooler which is if you
look inside of our name tag component
the name tag component is actually
important another syntax based off of
knockout so you can see it's got data
binding using knockout syntax so again
I'm not actually using angular or
knockout but instead the framework is
actually so extensible that you can
teach it new types of syntax or even
make it compatible with the syntax of
other frameworks by simply writing a
plug-in and dropping it into the view
and it's still a really under the covers
this performs way better than angular or
knockout but you've got the syntax from
those in effect there commingling the
app component is using angular syntax
and the name tab component is using
knockout syntax and they're working
together seamlessly so this is just an
example of how powerful and extensible
it really is and in fact you could do
all sorts of things one of our core team
members just wrote a plug-in for react
that enables the same thing with react
in fact you just simply install the
plug-in and then you can require into
any view using this special plug-in
syntax any react component any native
react component
can be required into an irelia view and
then it can be used as a custom element
and internally it will use the react
component to render and you can even
data bind to it flowing unidirectionally
data in to that react component and it
will automatically really render when
any of these values change based off of
a really it's binding system so you can
see that even for libraries like react
if you want to use some cool react
component you found with Aurelia you
just drop this plug-in in and then you
just require in the native react
component without making any changes to
its source code or anything at all and
it just works in Orillia automatically
as a custom element so these are the
types of things you can do with their
really extend the framework to do all
kinds of amazing things since it make it
real simple and elegant for you as
developers to build applications if I
can just take three more minutes
let me just return to my dad can show a
couple of quick comparisons with other
frameworks real quick how does it really
a Duan sighs well it's actually quite
good on sighs it's right in the middle
of the size range on the low-end you've
got something like react + Redux which
is not really a framework it's not all
encompassing so it's not really the same
category but that's obvious the smallest
139 K is its size I have question marks
for the second size because it's not
really clear how large it would be once
you kind of add all the pieces that you
would on your project because people use
to customize and add a lot of
third-party things in this case angular
1 pretty small 152 is the standard
configuration 235 is what most people
are 152 is the minimal 235 is what most
people use that includes a router HDTV
animation polymer has two different
configurations question marks I have for
the third because it 302 K does not
actually include a router or an HTTP
client and I don't think it includes
animation either
when you get down to Orillia 255 is our
minimum the 323 includes the base plus a
router animation and HTTP client as you
go up things get larger when you get to
angular 2 you get something that's way
off and crazyland it's 999 K is the
minified version that includes an HTTP
client and a router and that does not
still does not include an animation
system and you can see that that's
basically has feature parity with ember
so it's more than twice the size of
ember to get the same features and it's
more than three times the size of
Aurelia and it still doesn't have the
same features parody with Aurelia so
angular 2 is way off on the large size
really is sitting right in the low mid
to low area and has a lot of bang for
buck and the features performance is
fantastic with Orillia using an
independent benchmark of rendering
performance it really is pretty much
right at the top of the list
the only thing close to it is angular 2
and it just kind of depends on the
browser and you know operating system
and all these kind of things which one
comes out faster but they're both right
there at the top the second number sub
numbers for Aurelia is using a new
plugin we have for UI virtualization
which allows it really to only render
portions of lists that are visible so
you can see that with that it really
becomes twice as fast at list rendering
then the next fasted fastest framework
so fantastic performance highly
standards-compliant both Orillia and
polymer are the two most standards
compliant using very compliant HTML
modern JavaScript and having full
support for web components really strong
separating a presentation pattern you
saw how we kept that javascript in HTML
nice and cleanly separated and how you
had pure JavaScript I really an ember
are two of the best at this angular one
ok as you get to the right kind of side
of the screen things kind of go downhill
from there a really a very unobtrusive
again remember the demos I showed you
just vanilla JavaScript the framework
just stays out of your way you don't get
that intermingling of code from the
library in with your own code very much
at all highly interoperable I mean you
show me even show how we have a plugin
for using react components directly
inside of Orillia we can do the same
thing with polymer components in fact
you can extend earlier
all sorts of way to make it just work
natively by mixing and matching just
about anything you want
highly interoperable especially compared
to other frameworks again on the
business side of things full corporate
commitment full official support
opportunities full sufficient official
training full set of official partners
consulting services enterprise support
all these sorts of things that you would
expect from a native platform that say a
Microsoft or an apple was producing
we're working on and are producing for
the web platform and so we're really
excited we think that's a really
important part of the of the puzzle so I
really is doing really well in terms of
how it compares to other frameworks the
status is that it is in a beta one with
the stable API extremely fully featured
Docs apps and development and production
fantastic growing community and as I
mentioned there's all kinds of
opportunities if you need training
consulting or support and of course you
have a global partner network as well we
are heading towards our release
candidate in the next month or two we
believe and so we're just polishing
things up fixing some bugs adding more
documentation and syncing with the
latest versions of some compiler and
package dependencies and standards so I
think it's a fantastic time to begin
working with Orillia and trying it out
and building stuff with it and we're
really excited about the future and with
that let's jump into any questions we
have perfect sounds good thanks a lot
Rob all right our first question is is
Kendal UI bridge completely ready to use
with Arabia the kendo UI bridge is a
just as an explanation for people
listening is a project by several
members of the community who have a love
for the Kindle UI widget toolkit and
what they've done is they've gone and
they built a set of custom elements that
make a new UI
really really nice use in Orillia you
get just custom HTML elements you can
use data binding and really as
templating and everything is fully
integrated in that way I believe that
they have almost full support for every
component both the open source and
commercial components I have not
personally used the library in any
projects but it from I communicate with
their project leaders frequently and my
understanding is that they're almost
ready to release a an official beta or
lease candidate something of that nature
that kind of bumps up their official
standing on you know what what is
supported I know of a number of people
that are using it successfully and so if
you like kendo UI and you like Orillia
you should definitely use that together
and I could say that just from looking
at kendo UI and how it works with other
frameworks I think that the Orillia
implementation of their components is
probably the nicest most elegant
cleanest way of using kendo even
probably better than using them natively
without a framework so it's really cool
great our next question is will the
documentation be approved any time soon
yes in fact there's several articles
being worked on right now it's hard to
answer that question because some people
say that they love our Docs and they
think they're perfect other people say
when are you going to improve it it's
very much an opinion oriented thing what
I can tell you is that there's a lot
more article content that is coming out
the API Doc's document every public API
and all the repos all classes methods
interfaces properties etc that's all
there I assume that the questioner is
asking about the actual how-to articles
and we've got a full plan for that and a
lot more articles that are being worked
on right now and that are coming out
they'll be coming out intrumental if
incrementally as well as multicultural
support for translations and other
languages that's on the way as well so
the answer is yes but documentation is
highly opinionated what people think
about that and it's always an ongoing
process and so yes we are improving it
great and next is
can I use HTML only tags as resources
can I use HTML only tags as what
resources I'm not really sure what that
question means you can create the HTML
only tags you can make them global and
use them across all your views you can
import them into individual you abuse
and use them as needed as a custom
element I'm not sure I'm not sure what
else the question is asking in that case
all right Paul if you want you could we
type your question again go back to it
next is when movie you'd be able to try
out a demo of Arabia okay so it really
interface is a commercial library that
we're working on it's an optional add-on
to Aurelia and it basically gives you a
set of components you can build apps
with you can it's highly uh focused on
hybrid mobile app development and it's
skins and themes and behaves differently
across different devices such as iOS and
Android but it also is a set of
components for browser-based apps using
angular or sorry Google's material
design and I can't give you a date on
that sorry
we're working as fast as we can it's
extremely complicated and we have a high
bar for quality so we'll have that as
soon as we have that okay next is how
does it handle darker bodies of data
regarding changes in UI updates very
well in fact because I really is
different from something like angular
which had a massive problem with the
head so angular 1 and angular 2 are both
other bonding systems are based on
dirty-checking which means that when
certain events happen it has to go check
every single bound property to see if
anything changed and then if it did it
kind of raises an event and so that
means as your application scales the 30
checking has to work harder and harder
to keep up with Orillia we don't use
dirty checking we use an observer based
mechanism so we know exactly what
changes when it changes and we don't
have to check anything that hasn't
potentially changed and additionally
it's more efficient than other
our observer based systems like knock
out because we don't instantaneously
update the Dom when a change happens we
batch all those changes using the micro
test queue of the browser so that all
the changes happen and are aggregated
and happened in a single Dom turn and
this makes things very very efficient
and so we can render very quickly we can
update very quickly and as though app
grows larger and larger that doesn't
affect how quickly we can re render or
update at all our next question is are
there any render constraints
capabilities like react for example for
pre-rendering are there any constraints
or irelia where really their renders
using the Dom so it natively works
against the Dom however the Dom Global's
are abstracted so while we don't support
rendering into a string today we have a
something that we're working on for
later this year that is that will enable
rendering to string and rendering
server-side rendering of the entire app
that is not in the current version that
is an optional add-on that we are
working on for sometime this year and
that's basically what I can say about
that you can always render to a
component and then get the inner HTML if
you really just want to get a string
okay
regarding framework mappings such as
knockout is a function E is the
functionality currently one-to-one or
your work in progress in terms of the
capabilities of Orillia you can pretty
much do everything that any of the other
major frameworks can do plus more so I
really might do things in a different
way but it can accomplish all the same
things he didn't catch it but did you
see if your radio uses Dom missing I
really does not need to use Dom
differing because it doesn't dirty check
it knows exactly what has changed when
it has changed so it doesn't need to
diff and that's a fundamentally
different thing we know that Dom dipping
the virtual Dom has got is kind of a
buzzword and everybody is about that
because the react but they don't realize
that react is a fundamentally dirty
check system and that comes with
performance and memory problems because
if you're regenerating and throwing out
and regenerating and throwing out that
actually causes garbage to accumulate
and that's not good for memory in the
browser and that's not good for
performance and other things over time
and one of the reasons really is
actually twice as fast as react just
because we don't do dirty checking we
don't have to do we don't have to
generate a virtual DOM and we don't have
to do any kind of dipping
because of our observer based model and
the way that our templating engine has
worked combining with the asynchronous
nature of it via using the micro test
queue we were able to know exactly what
changed we're able to aggregate the
changes across Dom nodes and we're able
to batch them as a single render unit to
the Dom for super highly performant free
rendering so no we don't use Dom dipping
because if we use Dom dipping it would
be slower and use up more memory so this
is really a next-generation technology
inspired by the prototype object
observed specification but implemented
on top of browsers using current api's
and using things like the micro test
queue and just efficient batching and
that's what makes it really really fast
and also of low memory okay
and we're back to Paul where he
mentioned about the HTML tag resources
what he need is I want to globalize HTML
all the tags so it can use HTML tags as
a resource yes and if for some reason
that's not working for you then that's a
bug because that that obviously is
supposed to work so I'm not sure if
you're asking that because you tried it
and it didn't work or because you
haven't tried it if you haven't try to
try it for some reason it's not working
then that is a bug and we'll fix it for
you okay
and Rob our next question is a bit of
code if you go back to the Hangout
you'll see I wrote it down it says can
you prefer
bindable properties from a butyl model
directly and then the gentleman wrote a
little code if you could take a look
actually understand that in the chat
window but let me see
can you reference bindable properties
from a new model directly he wants to do
know the syntax that you're asking to do
is not supported no you can reference
them yes but using the syntax that we
supply for that not the syntax that is
there now if you wanted to do that you
could actually probably implement that
on top of our binding system because it
is extensible and again if nobody if
people aren't seeing this code then this
is all very very vague but things like
dot bind and dot rev and - wind trigger
these are all what we call binding
commands and earlier and these commands
are actually extensible you can add your
own and you can extend the parser and
you can extend things to work in ways
that you want them to work so if you
have some scenario that you're using a
lot and you want to have a nicer syntax
for doing it because it's so common in
the particular application that you're
writing you can extend really in a
variety of ways from adding new custom
elements to adding a new template Abani
syntax to adding new resources into the
pipeline that's transformed things on
the fly so there's all kinds of ways
that you can extend the system to do
that now I usually try to tell people
not to add new syntax for the binding
language because that makes it harder to
learn how your app was developed if
somebody comes along behind you and
looks at it and it deviates from you
know the way every other really app is
written but it is completely possible
okay and we have another question how
does the HTML batch attach downgrade on
older browsers it works fine back to IE
9 and we have polyfills that polyfill
the various underlying capabilities that
we need to make that work so it
gracefully degrades in terms of how its
implemented but it works fine we support
ie9 and above basically
modern news 5 based browser I don't want
to go with how that's implemented in
pets but yeah it degrades gracefully
sounds good looks like that's all the
questions
oh we have one one side can I get high Q
matrix shout out sorry then understand
that I don't think that's an actual
question but I believe that is about it
Rob thinks again thanks everyone for
joining in where are we posting this
video right here on YouTube so if you
have the link if you want to check it
out just keep using the same thing to
come back to it you could just review
the whole thing I want to do again a big
shout out to rob and all his team ever
radio thanks a lot for all this and was
that I wish you guys a awesome evening
and a good day and welcome thank you
Cheers</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>