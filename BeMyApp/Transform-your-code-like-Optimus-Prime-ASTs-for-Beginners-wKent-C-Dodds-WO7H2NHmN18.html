<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Transform your code like Optimus Prime: ASTs for Beginners w/Kent C. Dodds | Coder Coacher - Coaching Coders</title><meta content="Transform your code like Optimus Prime: ASTs for Beginners w/Kent C. Dodds - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/BeMyApp/">BeMyApp</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Transform your code like Optimus Prime: ASTs for Beginners w/Kent C. Dodds</b></h2><h5 class="post__date">2016-07-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/WO7H2NHmN18" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everyone and welcome to another be my
webinar will be starting and very motley
again will be starting very shortly
you
Hey ladies and gentlemen welcome to
another be my webinar once again I'm
fine and and is a pleasure having all of
you here and this webinar issue we
actually have Kent C Dodds PayPal
full-stack JavaScript engineer he's
gonna be showing us how to actually
manipulate AST and a little bit more
information about it so I'm gonna let
the man of the hour do the introduction
without further ado Kent you have the
mic all right cool everybody see me user
okay cool let me just going to move this
out of the way sorry and I'll share my
screen all right so I move that I do
just for everyone tuning in if you have
any questions be sure to type them in
the comment section because at the end I
can't work should be answering your
questions so Kemp please continue yeah
sweet um so yeah and I've got the
YouTube video up so I will see them cool
is the it doesn't look like it's showing
my screen you need to focus on my screen
or something actually we see your screen
you see the slides okay cool
sweet so yeah this is a beginner's guide
to a STS transform your code like
Optimus Prime
so yeah this is just a bunch of
information about me I'm not gonna like
go through it all just my slides are
right there beginner ast slides and yeah
you can like all these things are linked
so if you want to know what those things
are then that's a good place to find out
so I like to start out my talks with
expectations so yeah just so that you
know what to expect you can stop this
video if it's not what you're looking
for so I'm not gonna be talking like
giving a deep dive to parsing tokenizing
and lexing James Kyle gave a fantastic
talk at ember comp recently about how
parsers work and it's super super cool
you could check it out but that's not
what this talk is going to be on about
it's also not everything you need to
know to be productive with a st's just
this is kind of a beginner's guide so
it'll be a basic introduction to the
concept of a estie's why they matter on
how they work and I'll give a sort of
practical demo of how to use them with
babbling yes lint and when I say sort of
practical it's basically not practical
at all at least the babble plug-in isn't
very practical the eastland plugin is
really useful except a plugin already
exists so this is mostly instructional
and yeah hopefully this gets you totally
psyched about STS so great yeah let's
get started so I think it's important to
start out with why this even matters why
you should care so here's a couple of
things about why the abstract syntax
tree or ast is really cool first is that
Babel uses an AST to transpile your yes
next code or ESA XD 1/7 or like es2016
and forward stage to features and stuff
transforms it into a code that works in
the browser today I made up this term
yes now I think yeah these aren't really
super common terms but that's what I'm
calling it so yeah two transforming code
from one thing to another and it's not
just about future features either it's
also can transform all kinds of things
and so here a couple of just a few of my
favorite plugins this is the babel
plugin lodash which basically you know
if if you're familiar with how bundlers
work and everything if you know you want
to minimize how much stuff you're
sending to the browser and so you could
write all of your code like this so that
here it's only going to get the the map
function from lodash or the add function
from lodash of P and so you're not
loading entire lodash in your project
just the pieces you need but writing
your import statements like this is a
real pain in the rear and so instead you
can use this Babel plug-in and write
your import statements like this and the
Babel plugin will update it for you
automatically it's very cool and yeah so
that's one of my favorite plugins it
just like makes
it optimizes for you so you don't have
to make your code harder to maintain to
be optimized another cool thing Babel
plug-in module alias this is one of my
very favorites also and so I'm sure
we've all seen stuff like this where you
have to go dot all the way up to like
your root directory to find your utils
and whatever this actually lets you
write your import statements like this
where you give an alias to a directory
and it will before like any of these
imports around or the require statements
run it will update it to what it
actually should be so that you can move
this file around and not have to update
all the import statements
I wouldn't recommend doing this for like
a ton of stuff but for like root level
things utils modules and stuff this is
really really handy and then another
favorite of mine babble plug and
transform react remove prop types so
some of these can get kind of long but
basically if you're familiar with react
you have these prop types that save you
so much headache but it's just dead
weight in production because you you
should be turning off that type checking
or that runtime type checking in
production and so what this plug-in does
is it takes all of your react components
finds the prop types and strips them and
so you don't have the extra weight of
the bytes and you also don't have the
extra weight of like processing the
creation of this object and anything
like that but again this is another
instance where the plug-in the tool
optimizes your code for you so you can
continue making your code as readable as
ever but you don't have to worry about
optimizing any thing at all it's it just
kind of magically happens for you so
it's super cool and then at linting yes
lint uses a STS to let your code and I'm
only going to show one of my very
favorite plugins there are tons of rules
and plugins that Uslan provides one of
my favorites is the es lint plugin
import and and this comes with a whole
bunch of useful things but one of the
coolest is it will tell you
when you're trying to import something
that actually can't be imported because
that file doesn't exist and this happens
all the time the get logger module is
actually in the same directory so that
dot should be removed but you don't
normally find that out until a runtime
or bundle time and having something
integrated in your editor is really
really nice and it'll also tell you if
you're trying to import a default when
this module isn't exporting a default or
if you're trying to pull out a named
export then it'll tell you hey that
thing's not exporting anything by that
name all kinds of really cool things and
it actually integrates really well with
webpack as well so if you're using
special stuff from webpack importing
like CSS and stuff then and you can get
that and it also works for require
statements I believe as well so really
cool stuff oh I forgot to refresh my
browser this should say yeah that's kind
of embarrassing this should say J's code
shift or yeah code montz with JS code
shift so um I don't have any they don't
have a cool logo unfortunately but good
mods are super super cool so basically
what it this is like babble but for one
time transformations and so you take
code like the react community uses this
a lot so when react pushes a breaking
change the Facebook uses react a ton
obviously they have twenty thousand
components it was the last number I
heard and yeah that's that's a lot so
what what they do when they need to make
a breaking change they can't go through
every single one of their components and
updated like that's just too many and so
they take their entire code base of
components and they run it through
what's called the code mod which will
generate an ast off of each for each
module and make some transformations to
that ast and then spit out the the new
code and so those transformations are
things to account for API breaking API
changes and that kind of thing so super
super practical and and then they open
source there
their code bonds so that other people
can upgrade painlessly as well and so
yeah that's kind of the why of a STS
they're awesome
so yeah what what even is this thing
what does this thing look like so we're
gonna go ahead and take a look at oh
whoops shoot
my apologies these are out of order so
I'm gonna go backwards okay sorry
so yeah code for humans this is so we
write our code so that humans can
understand it because like we're going
to be maintaining this in the long term
so we use variable names and we call
functions with useful names so here we
have this random and so all this text is
useful for humans to understand it but
it's like the computer doesn't really
care what these variable names are it's
just like all that really matters is
that unique random array is named what
it's used as it's used that's all that
really matters this could be called a
for all the computer cares so what the
computer does when it sees your when it
sees your code as it generates an AST so
this is your first look maybe for some
of you this is a look at an AST it's
kind of crazy it's kind of huge but this
describes our program so here we have a
file and the inside of that file it
there's a program that program has a
body you probably can't see this very
well we're going to get a better look at
this later but yeah it's basically a
giant JSON object that represents your
program it represents your code and
what's cool about this is it can then be
manipulated and changed so that people
can and like you can generate new code
off of it so the babble plugins will
take this ast make some changes to it
like maybe change this variable
declaration to an import statement or
something like that and and then it'll
take the resulting ast after all those
transformations in spit out code so
that's the ast represented as a JSON
object so here we're going to make it
a bit more consumable for us and we're
going to look at a tool right now to
kind of visualize what this actually
looks like so this is from joint J yes
they actually created this really cool
tool they created it to show off their
their graph thing here but we're going
to use it in part for the graph but also
for the fact that what they're
representing is a is an AST so pretty
cool so here we have this code you bump
that up a little bit where we specify a
variable called a and I give it the
value 42 and then another variable B
give it five then we have this function
declaration that has a body where we're
returning a plus B and use a parameter
and then variable C and is an expression
of those two together so let's look at
what the aste looks like from this so if
if we think about it we we have our
program that's all of the code and then
the body of our program is each one of
these things and so if we look at our
est we see that represented we have a
program and then this what we see here
is the body and so program has a couple
children
these are children inside the body the
first is the variable declaration that
we see the variable a equals 42 that
variable declaration this is called a
node in fact each one of these is called
a node and this variable declaration
node has a property on it called a
variable declared ur and and
incidentally the variable declarative
property is actually an array and you
can have multiple variable declares in
this case we have a single one and the
identifier is a and the literal is 42 so
the literal that is being assigned to
you but if we wanted to we see we have
the same thing for B equals 5 we could
actually combine these variable
declarations into a single one if you
are familiar you can actually get rid of
that second var declaration and just
combine these as a single line I don't
recommend doing this because
it's not in my opinion a very good
practice but for sure ast now we only
have three children here because we see
one variable two variable function so
three children that variable declaration
now is var 842 and B is 5 and it has two
children now two variable declaratives
and that's the a and the B and yeah and
then we have our function and that
function declaration has a block
statement that's the body of the
function and that block statement has
just a return statement in there but
let's go ahead and now change it up a
little bit we'll say constant result
equals that and then return a result and
show that AST so now this block
statement actually has two children two
child nodes a variable declaration and a
return statement oh and so our variable
declaration has a single declared err if
you remember from this variable
declaration they can have two but this
one has only one and on the left side
the identifier for that variable
declaration is the result and the on the
right side of that variable declaration
is a binary expression and that binary
expression is a plus D and so so on and
so forth and we also have call
expressions I'm not going to take you
through like every single node type that
there is because there are many but
hopefully this kind of gives you an idea
of like the concept of an abstract
syntax tree really being a tree of nodes
that compose together to create a
program hopefully that all makes sense
yeah so let's go ahead and explore the
ast a little bit differently now with
AST explorer so this thing's pretty cool
it's actually I I am understanding that
this thing is totally amazing and
basically on the left here we have our
code
on the right we have the generated AST
so we're not going to look at this code
I'm going to actually show you how to
use this with a couple of links so we'll
explore the ast with our own code and
this code is actually mostly copy pasted
from transformer names the transformer
name's module which I actually created
for this presentation so fun stuff
basically the purpose of the module is
to give you a random transformer name
whenever you call the random function so
pretty fun stuff but yeah let's go ahead
and explore this AST a little bit I'm
gonna slide this over a little and make
it even bigger so you can see so here we
have the root of the entire thing is the
file and as a child note of that is a
program and then it has a couple other
like metadata information that we're
going to just kind of skip over but here
in our program we can see the program
has a body and that's all of these
things together that body is an array of
other nodes so these are the children of
the program and then we have a variable
declaration that's our first thing up
here is this require four unique random
array we're declaring it as a Const
declaration type and it has an
identifier called unique random array
and you'll see if you look over on the
left as I'm hovering over things
everything's getting highlighted so you
can see what part of the program is
associated with that also as I click
around here it will update what is being
shown on the right so I can click around
and see unique random array that is a
string literal if I click on the you
require statement that is an identifier
and that identifier is the Collie for
this call expression so the entire
statement here which I can't actually
like click on in highlight but I can
highlight right here so the call
expression has Ocoee it has arguments so
all of these lots of these terms are
like terms that you should be familiar
with programming
day to day but yeah it's just given a
formal name and I actually really like
using the ast explorer to learn about
new features that I haven't seen yet or
or I'm not as familiar with if I see in
some open source code or something that
somebody's using a feature I'm not like
I'm not used to or using it in a way
that I haven't seen before then I'll
just paste the code in here and look at
the ast and get the names for things so
now I can like Google for that pretty
handy stuff so yeah we have our variable
declaration that's one part of our body
we have a couple more of those variable
declarations we also have this
expression statement where I'm doing an
assignment expression assigning on the
left side the value of module write the
object property of module exports and
then on the right side of this
assignment expression is an object
expression and the right side could be
an object expression it could be a call
expression it could be a literal three
all kinds of things and in this case
it's an object expression that has
properties object expressions have
properties that are object properties
and they each have a key and a value and
these in this case their identifier x'
but they could be binary expressions or
whatever so we could say like foo one
plus random 3 o then if we like it with
that our results in do we have another
object property with an identifier on
the left being the foo identifier and
then the value in this case being a
binary expression you remember from the
last one the value was just an
identifier so we have the binary
expression where whoops where did it my
stuff go do ya binary expression where
the left is a numeric literal and the
right is a call expression so hopefully
like hopefully this is starting to get a
little bit boring because it really like
once you kind of understand that it
more of a like composing these nodes
together to make a full program then it
becomes a little bit simpler and you're
able to kind of intuitively understand
what what's going on in this ast so I'm
gonna go ahead and move on to actually
manipulating this ast and transforming
it to do use do something useful so
let's go ahead and do that so we have
the the same code on the Left upper left
here that we had before all that we've
done now is I turned on this transform
here using Babel version 6 oh and I
forgot to kind of explain a little bit
more about how this Tool Works so the
ast Explorer it has the ability to
export a STS for several different
things I don't even know what web IDL is
but I'm sure it's really interesting but
to where we're parsing JavaScript here
and then you have a whole bunch of
options for the parsers that you use to
like generate the ast and then you can
provide a bunch of settings for that too
for the particular parts for your chosen
and then you can transform it and we can
choose based on what we've selected here
we can choose what we're going to use to
transform it we're going to use babel
version 6 because that's the like the
current version of babel and when you do
that it pops open this stuff on the
bottom that i've already prefilled with
a lot of stuff but dad on the on the
bottom left
transform that we're going to write and
on the bottom right is the resulting
code and so actually if we go to is T
xplornet and just I'd open it it gives
us a default transform that simply takes
some identifiers and reverses them so
the tips is now spit and spit nerve yeah
is print tips which is kind of fun so
we're going to transform our code in a
much more useful way what we're going to
do is we're going to find each one of
these identifiers and rename them as
transformer character names so all the
code that I have in here is a little bit
irrelevant basically is like in lining
the transformers names module and so
whoops that should be transformers names
so I get this function get random
transformers names and that will give me
it will just you name that will just
give me a single random transformer so
if I console.log that up open my console
and you console oh we got Powerglide
there so that is basically all that all
that we see here the important part that
I want you to pay attention to is what
we're exporting here so this is a babble
plug in all those plugins that I showed
you before the lodash plug-in and the
the mantra alias plug-in all that stuff
is just a file that is exporting a
function it accepts an argument that has
a whole bunch of utility functions on it
that we can use we're not actually going
to be using any of these for our simple
plug-in but there's a fantastic babel
handbook that i recommend you check out
to learn about how to do these
transformations yourself so yeah we have
this this function that we're exporting
and as part of the babel api what it's
expecting you to do is return an object
that has a couple properties on it and
we're only going to be
specifying the visitor property so this
is this property is an object that is
using what's called the visitor pattern
let me explain what this is
so like I've got this ast and it's super
cool but it's really big for even a
small program like this and if I wanted
to go find all of the identifiers z' to
change them to a random transformer name
then i would have a little bit of a hard
time because identifiers can be found
all kinds of places i can find them
inside of these object properties inside
of an object expression i can find them
inside of a the identifier for a
variable declaration or inside of as an
identifier in a binary expression or the
update expression like you can find
identifiers all over the place and so
what what finding these different nodes
what what that's called
is traversing the AST and traversing the
AST is not trivial and so the babble
plugin does all the traversal for you or
sorry the bubble plug-in API and does
the traversal for you and you just tell
it what nodes you're interested in
transforming and so basically what what
that allows you to do is sorry once
again ste just totally lost something so
yeah what what that allows you to do is
not have to worry about traversing the
tree yourself and you can leave that to
to Babel so we're going to go ahead and
write our our plugin using this visitor
pattern basically what you do it in this
object is you specify the the type of
nodes that you're interested in visiting
so we're interested in renaming all
identifiers and so that's the type of
node that we're interested in so if I
just click on the the nodes that I'm
interested in transforming I can see
those are all identifiers and I can take
this node type and just paste it in as a
property here the
value of this property will be a
function and that function will accept
an argument called path now this path
let's go ahead and console that log at
the path and here we get a ton of node
paths printed out each one of these
represents the node path for each
identifier in our program so if I were
to go ahead and remove all that I'm
going to get a two node path printed out
because we have the unique random array
and the require statement so I get a
bunch of these and I can open these up
and see a whole bunch of properties on
this we're going to use two of these one
of them is node and that is the actual
node that this identifier is like where
this identifier was found in the tree
and it also has parent so the parent
node and we're not going to use that one
right now but that one is used quite
frequently parent path is also used but
we'll also use scope what scope
represents is the scope in which the
identifier is found
so this transformers names is inside the
scope of the entire program so it's in
the scope of this function closure but
for the random items for example the
scope is not the entire program so the
the scope just includes this disclosure
and and because it's a Const it's
actually block scoped and so it's only
inside of this alt statement so that's
pretty pretty nifty pretty interesting
now we know what this path thing is all
about we can start manipulating the node
to accomplish our purposes so let's go
ahead and we'll just say I Const
transformers our transformer name goes
get random transformers name console.log
transformer oops
but then we see
we get a whole bunch of random
transformer names so that's cool now
what we're going to do is we'll go ahead
and say pass that note because that's
the node we're interested in here let's
go ahead and actually we'll console like
that so we know which property we want
to change we have a node and it has a
name number up here at the top we have
the name unique random array so let's
just kind of do this naively will save
hath not node dot name equals
transformer name now we can see we've
changed all the names for every one of
our our identifiers so that's cool but
we have a couple of problems here first
we have this unique random array
identifier here that we've reached
renamed to Lightspeed but it's being
used right here and that's being that's
now called windcharger
and that's a problem because this
program no longer will run and so what
we need to do is make sure that we
somehow track that the the names are
like being changed that like whatever is
that node is representing is actually
it's being changed everywhere and that
would be really difficult to do so or it
just would be a headache
and so the babble plug-in API allows for
us to you or gives us a utility to do
renaming of of identifiers and that is
using the path dot scope object Sophie
console right path that scope and we can
see the scope for every one of our
identifiers and yeah it gives us a whole
bunch of yeah like a ton of utility
functions I've not used most of these I
think I've pretty much only used one of
these and I'm looking for it now it is
renamed right there so we're going to
use path bat scope dot rename and the
API to this will take the original name
so we'll say path dot node dot name and
the new name transformer name
and now slingshot is slingshot here the
require statements are left alone
because I guess encoded in the in this
API is we don't want to mess with comma
J s which is kind of nice didn't know it
wasn't always that way and then we have
also on like on object identifiers it
also isn't going to rename notes because
it knows that this object is being
exported and so other modules could
potentially use those so it's handling
that for us as well and then we have
Omega Supreme
and menasor and yeah everything is a
transformer name so hooray we have built
our first totally useless babble plugin
so the inspiration for this kind of came
from Sebastian McKenzie who created
Babel originally called six-to-five and
in a J's come talk he actually made a
transform that was similar to this
except instead of transformer names
it was emoji and random combinations of
emoji and he took the entire jQuery
source and he transformed it to use
emoji for all its identifiers and that
was pretty hilarious and awesome you
should check out that talk oh cool so
yeah this is the visitor pattern we're
visiting a single node or a single node
type called identifier we're taking the
path that our function is getting called
with and we're using the scope property
to rename all variables or all
identifiers with that name with the name
of our node in that scope to a random
transformer name so fun stuff great so
let's go ahead and we'll just leave that
as it is you can check it out the
complete example here and we'll go to
the es lint plugin now so and
unfortunately I don't think I'll have
time to show you a J's code shift
example yeah maybe maybe you don't have
time to show an example but not time to
write one
so yeah here we have let's just go ahead
and explore this code here we have two
if statements here if something is
greater than three then we're gonna
console.log something is greater than
three and then less than three something
is less than three so pretty like basic
program but what we're going to what we
do with eslint is is we don't transform
code or anything we we're linting code
and so we're looking for practices that
aren't optimal for one reason or another
and here the practice that we're going
to be linking for is having no block
statement for an if statement and so if
we look at the difference between these
two if statements we have the curly
braces here what that's called in AST
language is it's called block statement
if we look at the if statement up here
and see the to do go up and up and up
where is this we'll go to a statement we
have a test and a consequent so the
consequent on this one is an expression
statement and as we saw the consequent
on this one is a block statement so
basically what we want to do is ensure
that all consequence for if statements
are block statements otherwise somebody
could come in here and if if you add a
new line to this this also works just
fine but if you console dot log and it
is awesome you know it could be really
easy to think that this console.log will
only happen when this if statement
results to true but that's not what's
going to happen because if you don't
have a block statement it only runs the
next line it doesn't run anymore so what
what actually will happen effectively is
this will do that and that's like the
equivalent and so it's better to put all
of your if statements inside of a block
so that when people come around to add
stuff they can see clearly whether
they're going to be inside the if
statement or not
oh that's what we're going to be linking
for in our new slogan so let's let's
take a look at the that transform here
so what we're let's see you can I know
so things are a little bit different for
each link and you can't use like out of
the box you can't use es6 and use your
sense plugins and so that's why we have
module exports in the other when we had
export default but essentially the same
idea we're exporting a function that
takes a utility this this one's called
context and we're going to be using
context in the context of our plugin and
the difference here is the what you're
returning is the visitor object itself
whereas with the babble plug-in it was
an object that contained the visitor
object so an object that had a visitor
property that was a visitor object and
so the the same kind of pattern applies
here if we wanted to link something
about identifier as we'd say identify
capital identifier and then have a
function there in our case though if we
look at our ast we can see that what we
want to lint is the if statement because
the if statement is the one that has a
consequent and so here we'll just say
we'll copy this know to type and it will
make that an if statement that if
statement we'll get the node if you
remember it with the babble plug-in it
had I took the path that had a node so
there are a couple of nuances about like
the API is for these things but they
serve totally different purposes so
hopefully that that makes sense and
let's go ahead and console.log our node
here just to make sure we're kind of
going the right right direction with
things so we have two nodes that make
sense because we have two if statements
the first node is a type if statement it
has a test which would be this something
is greater than three and it has a
consequent and just as we would expect
see these have a test in the consequent
and for this one the consequent is an
expression statement
for our second one the consequence is a
block statement and so what we can do is
we could say if node dot consequent is
equal or yes equal to block statement
whoops
dot type and we'll go ahead and return
now we're only logging one node and that
is the one that's breaking our rule the
consequent is not a bug statement it's
an expression statement and so what
we're going to do now is we're going to
use the context variable up here to
report that this is a problem and there
are a couple of things that you
absolutely must have with your report
you must have the node and that's
actually that's everything we
technically to get a report but this is
not a very helpful report we know that
something's wrong but we don't know what
it is and so we're going to also provide
a message oh why you know block and then
we get our message right there and if we
were to like actually create this as a
plug-in for you slant and use it in our
editor if our editor was like configured
to use the assailant then we'd see this
in line and it would be super awesome
there's another really cool thing that
you can do with this and that is and you
can provide a fix function this utility
called a fixer helps stuff so the
fixture is a utility that basically
helps you trance one st to fix the
problem and so this actually would be
fairly simple for us but I'm not I'm not
going to I delve into it but basically
we just need to transform this if
statement to have a consequent that's a
block statement rather and then that
block just contains the expression
statement I believe this actually this
entire rule as well as a fixer I believe
is implemented in insulins already so
we're not going to be open sourcing this
because it already exists but hopefully
it
gives you an idea of how the esn't API
works and really how simple this like
writing a plugin is so just to kind of
review for an insolent plugin you simply
export a function that takes a context
which you'll use to report the issues
and that returns an object has a bet
uses the visitor pattern and there's
each property being the node type that
you want to visit so in our case we want
to visit all if statements and it will
give us the node that we're interested
in and then here we can actually just a
for fun I'm gonna say haha not using a
block statement in my recent rule that's
bad but yeah just kidding so we're we're
basically kicking because the node
consequent have type that is block
statement if it does then it's just fine
it's not breaking this rule so continue
on to the next node if it doesn't then
we're going to use the context object to
report that it's breaking the rule it
will pass the node that has the problem
and the message that we want to have
shown and and the message can be dynamic
we can you know do whatever we want
based off of the node so we could
actually listen to a template literal
and alright let's see go why do you use
a notice dot consequence that type this
edie of a there we go so why do you
freshmen instead of a expression
statement instead of a block so that's
kind of handy and then we can also
provide a fixer to help fix fix things
up and so actually the way that that is
used by the user of our plugin they
would on the command line they'd say yes
st. my source directory and then they
would configure to be using your plugin
they'd just add bash - fix and it would
go ahead and apply all the transforms to
automatically fix all the problems um
that can be fixed so that is a slant and
yeah I'm like I said I'm sorry I don't
have a J's code shift example I believe
if I'm not mistaken I do still have like
20 minutes is that right
Fernando do I still have 20 minutes left
or what time is this supposed to be over
okay cool so I'll just show a coach J's
code shift a codemod I I have yet to
successfully create one of these but
let's see yes code mod if we go to
transforms arrow functions so this it's
bump it up this code mod if I understand
the name incorrectly is responsible for
taking a function and transforming it
into an arrow function so the it's a
wildly different API from what you've
seen before actually here let's let's do
no VARs instead that one might be a
little bit easier oh just kidding it's
huge but basically the idea is you how
you export a function that takes a file
and has an API that has a J's code shift
property on it that's pretty much what
all J's code shift code montz uses this
J's code shift and they always pretty
much always call it J and then you can
take the source from the file
wrap it in J and this it gives you kind
of like a they say it's a jQuery like
API
and so we wrap it in this and then we
get this root object that we can all
find on it and we can find variable
declarations and then we filter those
for the ones that are a kind of bar so
here we're transforming all of ours to
let presumably or Const it looks like
they do that here so that we filter all
those to only do the VARs and then we
filter those to do a whole bunch of
other stuff and yeah at the end of every
when everything's all said and done and
then we returned the source if stuff was
updated so that's basically like the
general idea of code mods there I do
have a resource at the end and to kind
of show you how to get started writing
code mods but it's super cool super
practical and one day I will be smart
enough to to write one um yeah so I
think that it I think that's it here's a
bunch of resources that hopefully is
really helpful some stuff about the code
mods that I was talking about and that
the Babel plugin handbook is really
useful and also as you saw there are a
bunch of different parsers that you can
use for your like transformations and
stuff and so there's a specification for
the ast nodes that results from these
different parsers they're all a little
bit different and so they're kind of
conforming on on a specification so you
can check out that also and yeah that's
it for me and I am happy to take any
questions I should actually also ask if
you could go to this URL it'll take you
to a Google form that takes like 60
seconds to fill out I would really
appreciate it and yeah that's that oh I
am happy to take your questions now
perfect can it looks like you did such
an amazing job presenting their
currently everybody understood and I
have actually looks like nobody got lost
during your presentation which is always
plus yeah well that's good
um yeah man I appreciate it thank you
very much
ladies and gentlemen do you have a can
see dogs ECT ASC expert as always don't
forget these links these videos are up
on YouTube so if you want you can use
the same link as always just to refresh
it say you want to rewatch it or get a
better look at his resources just take a
look um can't as always much appreciated
and I know it's very early bright and
early for you so much of Europe is much
appreciated and yeah please in general
if you have any questions you can just
let me know and I can easily for them to
Kent and with that have a good day folks
or where we pour your Cheers
bye</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>