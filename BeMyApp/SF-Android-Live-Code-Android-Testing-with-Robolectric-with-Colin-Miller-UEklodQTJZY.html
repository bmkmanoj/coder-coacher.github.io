<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>SF Android Live Code - Android Testing with Robolectric with Colin Miller | Coder Coacher - Coaching Coders</title><meta content="SF Android Live Code - Android Testing with Robolectric with Colin Miller - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/BeMyApp/">BeMyApp</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>SF Android Live Code - Android Testing with Robolectric with Colin Miller</b></h2><h5 class="post__date">2014-05-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/UEklodQTJZY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright cool so I'm Colin I'm from
LinkedIn and we've been doing
robolectric for our unit tests for a
little while now and I want to talk
about robolectric because I find unit
testing fairly important and I'm not a
big fan of what Google has basically
done giving us tools for unit testing
they kind of require a device and stuff
so so I want to talk a little about what
robolectric is and what what purpose it
solves I'm gonna try to make a
presentation portion short-ish so we can
get out to coding but it is important to
know so it's basically a J unit test
runner it's going to do some neat things
with the class loader one of the neat or
annoying things I guess about android is
the SDK when you download the SDK and
you're linking against it and you're
compiling your code against it the
actual code is really just a set of
stubs there's no real implementation
behind any of it in fact if you were to
just make a java program import the
android jar and call any method it's all
going to throw a runtime exception with
a stub and that makes it really
difficult to do any sort of testing just
straight in Java yeah that since the
actual implementation of the android jar
is only on an emulator or a device you
you would need to do it in one of those
i don't necessarily like using emulators
or devices there's some restrictions to
that you're kind of you're kind of stuck
into whatever it is that you're in and
it usually a slower you have to bring up
an emulator you have around your test
off demands of closing and immigrant
sort of thing so robolectric kind of
solves about your problems it solves
things like one it's headless that's
kind of cool so you don't need a UI for
it at all you're not you're not having
an emulator you're not having a device I
can run this on a Hudson box that is
that has no UI no graphical capability
at all and you'll actually run all of
our tests fine that's that's useful for
us I mean we have Hudson boxes pretty
common the other thing is it has access
to the android internals so when any
time you are accessing any of the
android classes it uses its class letter
to insert its own copies of them they're
called shadows for robolectric and a lot
of them actually just implement the the
same functionality that the android
source was androids open source so they
basically just reimplemented a lot of it
but it also gives you some access to
certain things that you wouldn't
normally see i'll try to show off some
of that in the live coding but it will
let you see some of the variables that
Android itself knows about but since
they're not really necessary for the
developer to know about they don't make
public but for testing purposes are
really useful to know about because you
want to verify that something actually
happened right so you have access to
that which is cool it's faster
especially cuz you don't have to launch
an emulator and everything plus a
another thing I've noticed that it can
be faster with is if like the the test
app that is up that you may have looked
at actually does different
configurations based on if it's a tablet
or if it's a phone right because that's
a pretty common thing now you can
actually have if you're doing your
regular unit testing with emulators
you'd actually have to run two sets of
tests one with an emulator that's a
tablet and one that's an emulator that's
a phone because your code might do
different things in those different
environments well with robolectric we
can just set it config and say oh for
this specific test pretend that we're a
tablet and loaded my resource files as
if I was a tablet and that sort of thing
and it all just run in the same suite
which is really nice and that's part of
the config so the config can let you
change some sort of things on my time
and i'll i'll go over a little bit of
that the last one that I find really
useful is your ability to mock server
responses inside of your tests really
easily it will whenever you make a
network request by default it actually
intercepts all of them you can let them
through but I find it really useful to
have it intercept these things mainly
because if I'm going to make a network
request I don't want a real server to
answer in my tests because I want my
test to be deterministic I want them to
run the same way every time and I might
want the server to return an error which
hopefully if I were with the server
correct they shouldn't normally be
throwing errors but I do want to make it
so that if it did I would know what
would happen in those sort of cases and
I can deterministically have the server
returned errors or any data that I might
want which I find pretty useful so
robolectric really useful we use it for
you uh for automation or for unit
testing really important I think
everyone should use some sort of
framework for unit testing if not
robolectric but robotic isn't going to
do everything for you you're not going
to get you I tests you're not going to
get your full integration tests with it
just using robolectric isn't really
enough you should still be doing you I
test you should be still doing full-on
integration tests along with it and we
do that at
as well so at LinkedIn we have three
different main types of tests that we
generally run for Android we have the
Arab electric unit test which the devs
right the unit tests are fairly required
anytime we submit any code for Android
it has to go through a code review
process part of the code review process
involves making sure that there are
tests if someone gives me an RB and it
doesn't have tests and they made a non
layout change i am going to not let them
have it go through and they won't be
able to connect their code because we
need to have tests for this stuff the
only thing that I generally don't is
like if someone wants to change the
point of a font or something or some
minor you I things they're not really
unit estable anyway and it's kind of
pointless that's meant for a UI test
that's not meant for an automate a unit
test so that's kind of silly residue UI
layout tests so when I say UI layout
test what we're really doing is we will
have templates or some sort of like set
up of a layout right but the layouts can
often have or be missing a bunch of
different data like if I had a layout
that had three different text fields any
of them could be null I need to say see
that when something is null or something
is missing or if something's really long
like I really long text or something
that's going to wrap that it still looks
correct and so we have tests that will
verify and run and those run in an
emulator we also have you I regression
automation test these are larger tests
that rather than testing specific UI
components or actually testing system
interactions they're actually running
they're running the full app they're
running it against prod they're using
test accounts and they're actually doing
full-on actions and making sure that
things don't fail those are written by
both QA and dev we use a framework
called a PM for doing that amongst our
different platforms so that's basically
all that awesome so I made a post of
this project it's a silly little project
all that is the to do list it was just
to give something for us to kind of look
at so you can you can download it
there's a build files for both maven and
Gradle I use maven because maven was
kind of the default that robolectric has
there they're starting to support more
things but there is a built there is a
Gradle build and it will work you can
actually run our tests in Gradle a small
amount of
modification you're going to make it
right in the IDE I did get that to work
and all this thing is is a to-do list
app so we have a single basic test here
that you kardi run remove the failing
line should be fine let's make sure my
whole environment actually is set up
cool so we have tests and they run and
that's great so one thing is ever to got
a bunch of stuff running for in here so
I want to test some of the main stuff
the other things i'm going to do is I'm
going to make a service and we'll make a
service right now and will test how the
service would work and then how the
interactions with the service could but
to start with let me see so I've got
this actually before this um cool thing
to show off is this thing is using a
pattern for doing different layouts
depending on the screen size right so if
it's a tablet it'll look one way a lot
of two fragments if it's a phone it'll
look another way so i can test that
actually pretty easily the main thing
that i want to know is what what
containers are going to exist grace we
can do that that's pretty easy let's
make a test here so I want to with this
you make this knob do the context let me
this effort
so this set up what it's actually doing
is on since we don't have the structures
of an emulator this is actually going to
build an activity right and it's going
to call all the the create the start of
the resume and all of those methods on
it and return it back to you so it's
gonna go through a life cycle tanks
which is pretty useful so this will give
us an activity also gives us a context
because it's an activity we can access
resources and all that and that's great
but anyway I've got this main activity
and I want to make sure that if I'm on a
tablet that is going to actually display
the correct fragment so I'll do that is
ok I think I may need to find it with a
layout think we're doing it with views
young
alright cool let's run this cool so this
failed and it's going to fail because by
default robo electric is going to
actually use the phone layout by default
it assumes our phone right so i need to
actually tell this thing that i'm using
of 8 a large screen device so i can do
that very easily alright so now it's can
use layout large
that is unrelated to this that's
probably just because I'm accidentally
making database calls on the UI thread
which I shouldn't be doing and I have to
do less chance for that but I rented
okay so anyway the test did pass i'll do
another quick one just to make sure that
when we are on a phone that we do get
the correct container
alright cool so that least tells me my
basic oncreate is working I've got the
correct containers are being inflated so
that's cool on the other thing I want to
try is this lists on sale is selected so
this method is for if you have looked at
it so the to do list is basically
there's a list of possible to do list we
cannot multiples you click on a to do
list and it's going to bring up the list
of items and that's to do this it's
gonna bring up that to do list basically
right for that task list so when you
click on it it ends up calling this
method and this is supposed to tell it
to if we're on a tablet to just tell
that second fragment hey update your
data with what it is if you're on a
phone that second fragment doesn't exist
so it says oh can you just launched a
new fragment and launch it with this
list ID right so I need to have probably
to test for for doing that so I'll start
with
say so the way that we're doing this is
we look to see what the fragment
container is in this case it shouldn't
have one so we're really just looking to
make sure that a fragment is getting
added so this should be pretty easy this
should really just be us doing activity
dot on less likely we give it a number
111 and now we should be able to say
that
cool got an error so it is in fact null
the fragment doesn't exist so it
probably a bug summers in my code
okay so it looks like when I'm going to
create when I'm doing it on a phone i'm
adding i'm adding the fragment to a
transaction and I'm passing it in a tag
right so this is what I'm trying to pull
out and I'm doing it here when I'm doing
on a tablet as well i'm doing a
fragments which though i am not letting
a tag to be able to identify the
fragment later let me just add that
cool yeah work that's good okay so this
is kind of some of the stuff you can do
for like just testing your activities
and whatnot I want to make something new
will make we're going to make a service
so service calls when I think of unit
testing I'm thinking of like I want to
have a test for that specific thing but
i don't really i want to know that calls
have been made to external dependencies
but i don't really want to test the
external dependency because it they
could change man over the care about is
implementation right so there's a couple
things I want to make a service and then
while I make in the service wanna make
sure that the service works that'd be
good and then afterwards I want to make
sure that if I call the service like if
I have something that's supposed to call
the service that the intent to start the
service actually happened I don't need
to service to have to add on to verify
that the service went through and do all
that stuff because the service has its
own will have its own test for that I
want to make sure that that that'll work
so we make a service okay so we use
metrics a lot at LinkedIn I mean we
pretty much track a lot of things that
we know usage patterns so I'll make a
really bad metric service because
putting it right now so
let if another call door opens all the
cheat sheet want this finish up oh aight
actually create the super thought
possible days this will pull to get in a
pointer exception so let's see um
because I don't really want to write an
entire metric service that would be huge
I'm just going to have it so that when
you do an action ill store into shared
preferences like using a key of whether
the action is and then increment a
number right because then we'll have at
least in a shared preferences you could
change this obviously to probably send a
network request or something like that
but by default will just have it set
something so let's make sure that that
would work if we were if we were to have
implemented it which we have it that's
fine this is the whole test drive Adele
then I want actually write the test
first and then we'll actually make the
implantation to see if it actually works
so we'll have it when you tap a total
this
I'm just giving it robolectric some
application context to have a context
i'm going to use tag so this will be our
action / mom
alright so I'm going to want to verify
that the before we do anything that the
shared preferences is as empty as well
as if it's going to be so let's do
so I shouldn't already exist so it
should just return 0 because that would
be the default value I'll make a service
call cool this should fail so we don't
have implementation
oh it passed my dad passed oh they had a
default of no wait why did it boss
oh right I'm testing the wrong test
thank you I've ran the other test let's
run this one instead there we go that's
wrong okay good thank you cool alright
so let's make sure that all of this is
going to work
I'm doing this for brevity I really
don't like nested code like this because
it often causes not fine are exceptions
so you get the idea
cool what
okay so that's a that's making it so
that we can test that the that the
metric would actually get implemented
they got called now let's make sure that
if we if we actually clicked on a list
item that the call gets made
so the way that we're going to do this
is so like I was saying before chat the
shadow classes that robolectric provides
gives us some of the information that
you'd normally don't get access to as
part of Android this could start a
service but since it's an intent service
that's not overly useful to see it start
instead of a unit test because it's just
going to run another thread and I don't
want to deal with the synchronization
and all that to actually see if it did
what it was supposed to do but and also
just see what it's supposed to do I have
a metric intense service test that will
test to make sure that you know that it
should work what I need to do actually
is verify that the that the service I
got started to sort the store call
happened which since we have an
implemented yet it actually hasn't so I
can do that is with this
an hour which one it is
so the only one I didn't really write
down first anybody remember on us on an
intent what stores the class that you
started the intent with I can look it up
but was hoping everything what was that
no it's hello this is this isn't an
activity right this is a service right
but this is on the intent the intent
itself if you started intent based on if
you start an intent with a with a class
so like the example would be like this
right if you do a new intent and you
pass it in this class not even tell me
here well because this is just throwing
the stubs all right to look this up and
look at this one first
you'll know what I see
get component us please of J component
all right so i should say that the
service that i started the class name of
the service that i started should equal
this class name of this intent typist
right nows because there was no neck
started service I probably actually just
put in that tunnel there's no service at
started cool so let's actually make make
this happen so I have a thing right here
that's all just doing is starting the
last list i do so we can bring it up
from there but it's also actually send a
metric so let's say on and make a bit
tongue
each
cool although that's obviously wrong
because you have to send data to to it
so we could just say well she'll just do
wrong
Thanks I code is still broken obviously
my test is proven that let's fix it
honestly I would probably make this so
that you get the intent back from the
metric service that's usually vas a ver
way to do it you'd have like a helper
method on a static method on the metric
service to say hey return me the the
list tap intent and then pass it along
instead of having you activity need to
know directly about that so this isn't
the best practice it it should work
cool so i can call metrics which are
according to my PM the most important
part of our application the next one I
want to do is some of that I'll go back
to the metrics service because that's a
good enough place to do it the network
calls right so I want to be able to have
a network hall that's going to step will
have it so that the metric will are they
enough call a web server to get the
string that it's going to use to store
not really overly useful but gives you
an example what and network hall
override with the plague
let's make a lucky
but I shall have it so that it will
return the server itself will return the
number that we're going to increment it
Bob that sounds fun so what I'll do that
is so I'm going to say that when we come
back to the same for example it will
return five so now we should be able to
say that so let's let me get the shared
preferences okay so just copy this
alright i'm not going to run who all
know that it's going to fail so let's
modify this a little bit so we're going
to say that we're going to a special
case
it's just
what time I don't put it on yes
just let us talk so long
Oh
oh I forgot this one over the dummy
no the default to one if if the server
doesn't respond or response badly like
that so I think that's about correct no
no one over
that's me
just like the right text
okay we go I don't know what the other
one was I think my ayah my film
environments kind of slightly screwed up
because I have a different one at work
and I was trying to like jerry-rig it
really quick to get it to work here it
works this time ok so that's an example
of how you could do a network request
with robo electric so I've covered you
know doing activities doing fragments
which is network requests the whole
thing is headless that's great anybody
have any questions at the right third
test but I don't know what you want
those are like the quick ones that I was
like oh these are some interesting ones
that I find are really useful that I
can't always do he's elite on hundred
okay so boom this is me any other
questions yeah for anything that's not
you I we generally use robolectric and
you can test unless anything the main
thing that I have a problem with
currently that I haven't I've tried so
many ways of trying to figure out a
solution is testing static methods it's
really hard if you have a class that or
a method that is accessing a static
method that you don't want to actually
call the static method you want to use
like a stub or a proxy there's not a
good way of mocking that and the reason
why is normally not other facilitate use
like powerful for a power mach has a
nice way of overriding static methods
power muck uses the class letter to kind
of override what the static method is
called but robolectric also overrides
the class loader so they conflict and
through I haven't decided to go through
the robolectric code and manually add
power mach into it because i don't
really feel like playing around class
loaders hey be useful I'll give a cookie
to ever wants to do it but but yeah I
don't that's not that's the main thing
that I have problems with testing and so
if I have something that I really need
to test that has static methods and I
really don't want to call them I'll
usually use a singleton and wrap it or
I'll use a singleton rapper and then
it's fine you could just you just mock
out the
the singleton yeah so we actually do all
of our stuff in Gradle so this project
had an example Gradle file there's a
couple of there's a couple cool things
that you have to annoy anything we have
to worry about with Gradle so Google
hasn't really released riddle yet as
like a full-on release right it's still
in beta we're still adding features and
it's getting better which is nice so if
you can use it there is a Gradle plug-in
that robolectric ass it actually is up
to date with the same version as as the
Gradle plug-in for foot because i'm
using the latest android plug-in 10 and
the latest android test plugin is the
same thing so it works fine this will
actually give you an IDE integration
it'll it'll import the entire thing the
only thing I noted so let me actually
just do it to show you so go to my
project I'm going to remove the the IML
file on the the idea directory so we're
going to import it you know to start so
when I import it from Gradle I'll use um
using a new rapper just for fun so it'll
import fine and like your source
directory your test source directory
will look fine the tests won't run by
default but there is a way to get it to
run I found there is there's two main
problems on that I ran into so we'll go
into my test and try to run it
alright so the first problem is kind of
the problem that reflects works trying
to solve and that's this stuff exception
but you can get around this by doing a
one-time going to change if you go into
modules and dependencies this is I've
not griddle isn't really working in
Eclipse addressing real eclipse I cannot
help you they don't have support for it
but if you're using IntelliJ or Android
studio then actually I would just say
intelligent cuz Android studio they
removed a bunch of functionality for
some reason you can just move the
android apk because that's what's
loading in the debt default jar move it
to the bottom it's the easiest way to do
this and what it's really looking for is
it's looking for j unit and it's saying
oh there exists a version MJ unit and
the android api i'll use that but every
method android api throws runtime
exception not awesome so now that it's
below j unit it should actually run
except it'll actually probably at a
different error but that's fun yeah so
then you get this this one this they
can't find the class and the reason why
i can't find the class is because for
some odd reason it never set the test
output directory so it has no idea where
your test classes are it builds it and
that's fine but it doesn't actually know
where your your test sources are so i'll
just go to the build directory will go
into test classes that's where my test
classes are I tell it there at once I
try to get this to work it's supposed to
maybe it would there's a there's an idea
plug-in that I was trying to set the
test output directory but I don't think
this gets read it right when you do an
import I think it only works when you do
Gradle like I did you know the idea
generation I don't know if the ID the
idea generation works with Gradle and
Android so I don't even tried it you
could try it but basically this is what
I'm trying to do oh yeah so for
dependencies it's just importing it's
got its using Android test compile oh so
this is the other thing um currently
google has decided that you only ever
want one test project for your project
which is unreasonable hopefully they're
going to add support for having multiple
test projects or having it so that you
can set it so right now it is doing is
it's overriding the Android test project
right it's going to use that in place
that gives us
integration that also means though if
you wanted to use UI Automator and do
your android tests using this you won't
be able to so the way that we do it
actually is we don't override android
tesla compile we actually don't even use
the android test plugin we make our own
task we just call it unit test and then
we do manually like adding in the test
pads and that sort of thing and then we
we do it on the command line so if you
want to run your tests on the command
line you can run you know a Gradle unit
test and then I'll run all your unit
tests and we have um we have additional
options where you can say Gradle unit
test and then pass on a parameter say I
only want to run this test test and
it'll run but it won't run in the IDE
it'll run on the command line and then
your output will be like you know in an
HTML file it's actually not that big of
a deal the whole thing runs on on Hudson
fine but unfortunately because we also
have UI tests we want it to utilize this
it's actually for our layout tests we
can't get the IDE support I might ask
them a change that honestly because I'm
pretty sure there's other ways we could
set up those other tests and ide support
would be awesome so but this is yeah
this is all you have to do so you can
access this I post I made a post on the
on the meetup that has links to this
whole code so you can use this as an
example for trying to get it into your
project to kind of get you started
hopefully it'll help well yeah so this
actually should run now I think it's
really nice built in the ID because you
can just get that fast you know yeah
there goes it actually runs right so you
can do it with Gradle riddle will work
small kind of concessions yet to make
for Google not doing things right in my
opinion whatever anything else
yes well this is this is using mockito I
mean you can use any mocking framework
if you wanted to use mounting right you
can use easy amok as well I just find
mosquitoes pretty useful pretty easy to
do it um I had a test I didn't write it
but I could I guess it could but so for
like in this activity one there's a
right so i did this phone so I if I were
to do tablets select well I would do it
a little bit differently and that's
because the tablets select it actually
uses a fragment that gets returned
because it's expecting it to go return
so the short version of what i do is we
actually spy on the activity and then
have it return unlock fragment manager
and have the fragment manager return a
mock task fragment and now i can verify
that fast because I again I don't wanna
keep them coupled I want to make it so
that it I don't necessarily have to call
update list ID I just need to know that
it got called alright so then I could
just do a verification that that that
and that the fragment that came out of
there it's update list ID actually got
called that's all the tests would have
been I could write yet
so yeah this is what we this is what we
are currently using at LinkedIn for our
unit s Norris prep or pretty well I
think we've got like over 800 tests
we've only been using it for like seven
months yes it hurt for Gradle support
yeah so the basic problem is intellij by
default will in its dependency it has
the API at the top so that's just
basically it's going to look there first
for any classes and since we're using j
unit and j unit is included into the
library all you need to do is just move
it down you basically flick on it and
end at the down arrow much times it's a
single manual step because support is
just not fully there yet with Gradle
integration but a couple manual steps
incent that bad used to not work at all
so this is actually a really big
increase just a couple changes we've
been using robolectric probably um since
it's like October something September
some of that yeah before that there was
some unit tests using android framework
but is really flaky and people weren't
we weren't really on to it and basically
what happened was i joined the team at
like now we're gonna do this and pushed
it in so I've been kind of the
spokesperson for getting robolectric
tests or just unit testing in general
for for that out and it's actually
worked out really well is solved quite a
few bugs and it's prevented quite a few
other ones so yeah so I think we have
huge codebase right and not everything
our coverage isn't awesome yet so what I
do is you kind of have to be reactive to
it right so if we see crashing bugs and
criticism and someone has to fix them I
request that there's unit tests for that
if you are making modification that hits
legacy code we tried it at that time
also add a couple of unit tests for it
right but it's it ends up being a
process you have to because there's the
code base is large enough that it's it's
not a great idea
is probably a good idea but it's not
really feasible for us to just sit down
for like three months and just write
tests for everything so you know we just
make sure that every commit has tests
and that we're testing new stuff not
only the stuff that we're it quite like
some of the stuff that's integrating
with the stuff that we have written and
slowly at it you know introducing it I
think it's the only same way we can
really handle it at this point the so we
have as far as modules are concerned we
have basically one module but we do have
other libraries that we that we've built
like our authentication library as a
separate library that we import right so
that's its own project it actually says
to put the outside it's really nice
having moved to Gradle because it can
import it as an AAR really easily and
it'll have its own unit tests and why
men they don't find with the loaded yes
pretty much every Android project that I
well some of the other of legacy ones
are one that we may have like gotten
through acquisitions might not be but
the the general the general stance right
now is to where you you know integrate
probe electric and write it especially
for new projects and integrated with old
projects when we can or if we haven't
yeah they're all independently tested
and then you know then we tested with
would jump up again until you actually
combine you to the main activision also
a run well yeah so if you're running
tests against the main application is
going to compile it which includes
bringing in all of us as dependencies
right so Dirk they will be there you
know you sometimes we might knock them
out like we don't actually make want to
make an authentication call you can mock
it or something but we expect that its
its interface is working correctly
because they have their own their own
for a black box testing so that's pretty
much what the QA ends up doing right so
that's mostly a UI testing sort of thing
that we're doing all right so they get a
set of requirements they don't know what
the code really looks like just get a
certain requirements on what it's
supposed to do and then they'll write
automation tests using a p.m. or
selenium to verify that it meets those
behaviors but we don't have we don't
have we don't have a team of like people
going in and doing black box testing
against like on a module or code level
might not be a bad idea but we don't
have that do we use what revolver no but
I want to look into it cuz i really
don't like a p.m. so well ok i don't
like aspects of a beam i like the idea
and i like where it's going i think in
six months maybe it'll be really good
but right now it has some pups with
xpath and i kind of want to look at
we're gonna be doing some some look at
our code base and redesigns coming up in
the next couple months so i want to be
able to take the time to investigate
that because it looks promising for for
our testing i think um do we good I
don't think so now I'm getting him know
I'm getting I don't think so i don't i
haven't seen all of the code Amy it's a
fairly large code base I haven't I'm not
a complete expert I've seen most of it
do you love to run and you are gonna do
like just using more fuel and running
tests on TBN well so this is what allows
us to do that right there's no real
other way of running mockito and stuff
like a vm because we're accessing
Android code right so the android jar
itself if you're to call any method
right so if you're extending an activity
and you want to call soup or whatever
what you're going to do they're all
going to throw runtime exceptions stub
because the jars that are provided by
Android as part of the SDK have no
implementation so really what
robolectric does and I've actually done
some development on robolectric it's
kind of neat you can see it on
so robolectric for like so here shadow
activity right so this is the activity
that actually gets called the way that
they end up doing it is they're saying
they have a nice an annotation for
implementing activity really cool thing
is you can actually create your own
shadows for anything that's in the
android sdk i'm kind of pushing them to
allow you to make shadows of anything
because you can't make sure that your
own code and there's places where that
would be really cool but you can make it
for the Android code and so what it does
is it actually keeps track of a real
object of of activity this code is
pulled in with robolectric from maven
repository where they basically
downloaded the entire Android code and
compiled it so it has real
implementation made modifications it
would actually work off of a device and
then now you have an actual real
activity which is cool so it'll actually
call the real Android code and all those
methods but it'll do certain things
where certain methods like say this get
application it will change the
implementation with this annotations
this is all done in class loader and
will return whatever they want to
internally this ends it being really
useful for when you want to get
information that you wouldn't otherwise
be able to get and that's stuff like the
get last started activity ring so even
look at oh it's not this sorry not in
shadow activity it's in my contest repre
reping there's something I don't know
was but basically yeah yeah so a shadow
is since we're not using it's basically
a reimplement ation of the actual on of
the actual android class that has been
injected with a class loader the reason
why you can so when by default when
you're using something like an activity
underlying it'll be using a shadow class
to to mimic the calls that you would
normally be doing on an activity so we
don't have a real device right so if i
want to say get my resources it's going
to have to have some sort of thing to
figure out how to get those resources
from the JVM
even for things like if I say I want to
make a component invisible or set it to
gone it's doesn't have it all ways to
actually do that but it doesn't to keep
track of it right so it'll have maps and
that sort of thing to keep track of it
for any of the shadow classes you can
you can generally get a get a shadow
version of it but is calling this
aesthetic method on the robolectric
class itself called shadow of then you
pass it in you know whatever whatever
object you have like if I have an
activity I can pass it and get shadow of
activity and we return the shadow
activity which is this class and the
neat the useful thing about the shadow
activities is they'll expose additional
methods that the base activity didn't
have so by default this real object
thing means that by default if any
method it can override any method on it
by using implementation if it doesn't
override it it'll just use the real like
the real version instead but for the
ones that it does override it it might
keep additional information so like
here's an example just get default key
mode thing that's not actually in
activity class but it might be something
useful for testing right so the shadow
class will let you access those things
that are useful for testing that are
hidden that are normally kept by Android
itself yes as a short answer so Android
studio is really just a fork of the
Community Edition that they've kind of
try to add and um android stuff but
they've also kind of removed a bunch of
useful things the fun thing is Google
since they're using Community Edition
which is open source you're actually
committing back to jet bridge JetBrains
gets all that stuff and then they
reabsorb it back into Community Edition
so and and the ultimate edition so if
you have the ultimate edition that's
what I use if not use the communication
you could use the Android studio I
haven't found a reason to really it
might be slightly behind as far as the
Gradle work because you know they'll
make it and they'll push it and then Jeb
rings I'll get it and then bill
incorporate it and they'll push it but
I've seen they've been pretty up to date
they've been pretty recent like I don't
I don't see much lag Android studio is
missing a bunch of those options like I
don't even think you get it to see a
dependency in less than Android studio I
know the other thing that I used to do
until we
so that used to be when we imported it
this directory was never marked as
source they've added that into the to
the library it didn't matter for us
since we weren't running in here but if
you want to get like all of your you
know your quick your you know I hit
control space or whatever and I bring up
stuff it's really useful and intelligent
community edition and in it in this you
can just say mark directory as a test
source awesome for some odd reason they
remove that in the Android studio and I
don't know why it would have been really
useful I think it's because they really
want it to sync with the Gradle file and
they want you making customizations they
expected the Gradle file as the source
of truth and you should not you
shouldn't be able to make any changes to
it but sometimes you really want to so I
would just say go to the community
edition honestly do you guys do any
device testing on physical devices we do
a lot of physical device so we don't do
it in automations well do a physical
device testing often like Ezra
developing because we want to see on
that will do a lot of bug bashes where
it's like okay everybody get out your
phones cuz we all have a bunch of
different phones try out stuff go
through test plans I think some of the
QA will actually do physical device
testing on different devices going
through test cases I don't know if any
of those are automated I know there's a
service that I don't know if we use I
thought we used for a little while that
actually has physical devices and they
would launch things onto physical
devices then press them for you with
like a sling em slicker thing I don't
know if we do do we do that anymore we
used to I thought or are we looked into
it no probably a good idea right because
we've definitely run into bugs were like
oh this happens on an HTC One for some
reason but doesn't happen on other
things and okay who's got an HTC One ok
now let's give that to a developer and
figure out the hell's going on so it's a
good idea but we don't have it like a
formal set up for it right now
do you that new school measure like for
compost um no we should um the IntelliJ
has a built-in code coverage and i was
thinking about adding Emma into it but
we I haven't had time to add it in and
the tools team's been really busy so we
haven't even had it it would be a good
idea I know our code coverage is
probably really bad right now because
we've only I mean we've got 800 test but
it's you know even 800 test is only
hitting a small section of the
application so it would be good but
right now it's just like we're just
adding test as much as possible i'm not
i'm not super worried about coverage at
this point coverage is just a metric i
think it can get people fall senses of
security on that anyway I'm less
interested about coverages and more
interested in about testing plausible
boundaries testing definitely if you
have a crash or something that obviously
went wrong when you fix it have a test
that would reproduce it I have actually
gotten some of our devs into trouble
because they will it'll have a patch
right I'll have an RV and I'll have a
test and I'll be great so I'll download
their their patch I'll apply it I'll
undo all their changes and run their
tests and if their test passes I don't
let them go through because they wrote a
test I didn't do anything the idea is
when you made your fix and you wrote a
test the test should fail if the fix
isn't applied right so gotten some
people getting like don't off of that
those are sort of things I'm looking for
is that yeah every time we commit you
know for making a change for making a
fix I want to have a test that if that
change wasn't there it would have failed
are you formally Ollie no no there's a
lot of people but this is this is our we
have kind of like a handbook sort of
thing on the practices so for Android
generally when we do the code reviews
it'll go out to all Android developers
who are on the review list which is
quite a few of us and then you can spit
specify each one so you get the option
of looking through all of them and then
there's a small not really small there's
probably like 10 or 12 or something like
that of us who have the permission to
actually say yes you can give a ship it
and it means something because if you
try to push something and you and you
haven't gotten approval from our be able
it'll reject it and we'll let it go
through our review board right so we
have a wii u's review board so if you
have a review board up for reviewing
your code someone actually has to look
at it and they have to give you a ship
it on it if they don't when you do a git
push
um the get system will reject it saying
that you don't have proper you know how
proper review and there's a list of
people who can give those right so it's
spread out it's not just everyone but we
try to get the reviews done within a you
know with definitely within the same day
usually within a couple hours usually
it's someone coming over to someone's
desk reading like hey look at this with
me and then we go over it you know to
make sure that at least two sets of eyes
have looked over a piece of code any
piece of code that's going on that's
unreal nigga i ugly so the the QA will
do a full integration tests on
production data using test users rights
Olivia test account that's on prod and
they'll make changes on that the the
nice thing about so that's automated
it's done on an emulator the nice thing
about that is it can catch both client
errors and server errors right if the
server start sending weirdness we can
often file server bugs if there's a
regression right or if like a service is
down or something it can sometimes find
those sort of things so they are they
are used the developers since we have a
we still have a backlog of things that
we need to write for regression some
some of those are written by developers
now like I've been working on them
recently but historically it's been QA
but it'll probably become more developer
anyway because we just know the code a
little bit better when you do this
others it'sit's yet depend on the test
we often have like heaven a new account
was created right so usually like I know
with ours a set of tests would have like
oh this set of test uses this user right
and then the idea is ideally that user
data shouldn't be changing so that the
test will be you know the same my issue
with doing it without our production
servers if someone starts editing a user
heavily then you know your test you're
gonna go out the window because the data
won't match what you what you expect so
and that can always it can always be be
an issue so each test generally will be
under a different user and if you do
test that modify data those can
sometimes get wonky because if I like
change something and it fails or if I
changed something and I try to change it
back in the change back failed future
runs might not work and so that's always
a fun issue
no these are integration tests those are
regression you I and integration tests
for the server right these are making
sure that yes our app actually works
against real data on a real server no
units has cirque ability separate these
unit tests if you ran a unit test and
you ran it again it should Pat it and it
passes the first time it should pass the
second time if not something is
definitely wrong okay tuve amazon gift
cards so if anyone didn't sign up on the
mailing list this is what you got</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>