<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>[Android Using C/C++ in Android apps] by Xavier Hallade | Coder Coacher - Coaching Coders</title><meta content="[Android Using C/C++ in Android apps] by Xavier Hallade - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/BeMyApp/">BeMyApp</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>[Android Using C/C++ in Android apps] by Xavier Hallade</b></h2><h5 class="post__date">2015-09-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/-Ne7FwYC4Bs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">first I'll talk about the Android NDK
but
two great c and c++ code into android
apps so one of our core principles it
relies on is the jni java native
interface and i'll talk about of course
the ids so Android studio and over IDs
if you're using unity use where you
don't care about these parts but still
and Indian if we have got some time we
go for QA overwise I'm available for
until 1pm actually I can't stay for you
all day anyway so the NDK is big tool
kit you can get from google it was
usually available from the NDK developer
documentation you can also no download
it from Android studio directly since
the recent releases when you use the NDK
everything relies on the Java native
interface so the Java native interface
is our principles that allows you to mix
Java and C and C++ code because Android
is a Java world I hope you already know
that and to communicate with the scene
in C++ parts you need specific
components and everything is diff
defined for the Java native interface
that's not something new introduced with
Android but something classic on Java
environments so it should get some Java
servers maybe 10 years ago java native
interface was already something you
could use before and nothing has changed
so we interface on the data side it
provides you several components you will
use so first system dot load library
that will allow you to load a binary
from a Java program and then the native
kewal so you put a native keyboard in
front of any java method it would be
declared as native and that means that
is in its implementation will be from a
native binary you will have loaded from
using system.data library so on the CN c
plus plus side to be able to provide
these in c++ implementation to the java
you have several things first of all the
gin I header so jen i dot H that gives
you java primitive types so a java
integer a java object
string and so on and specific data
components so with gni environment and
the Java Virtual Machines these are both
objects you will use to be able to
create Java objects from C and C++ call
java methods from c and c++ and so on so
you need to use these alerts it's really
her glee as hell and not always easy but
that's what you need to use provide your
implementation implementation tudela so
to provide your senseless first
implementations to java you need to use
return manipulate data objects so for
Reese you use vagina environment I
described before you can do an automatic
mapping so from your sins presentations
inside of the data files and the giraffe
at baton in the cloud native by using a
convention so this convention is a
search so you start with Java then on
the score when the package name then the
name of the class then finally the
method that has been declared as native
so if you have such prototype in your
dot C files it will be automatically
mapped to the java implementation when
the DOTA sofa is loaded you can if you
really don't like that name and i would
totally understand that you can use your
own conventions but in later manually
call register natives on Jan I and so on
what you manipulate our Java objects and
Java primitive types so here are all
those that are available so actually
everything objects universe from j
objects and that's a reference which
other objects so you don't directly
manipulate the memory of a java object
so many things could go wrong if you are
doing that and all the primitive types
are on the right so of course you need
to reinvent a boolean again because
aandava everything has a fixed size and
in since + + it varies across platforms
so you need to have objects that I've
always sent sighs what
it's running on 32 or 64-bit platforms
so let me come back to the question also
first why should you use CN c plus plus
on Android and why going for this
painful process I'd say you have many
reasons first of all if you want to
write a red cross platform game engine
or game in OpenGL ES when C++ is quite
obvious choice because you can compile
it for all the platforms menu some
differences between platforms right as
always when you try to look for platform
code you have really good libraries you
may want to reuse so we have tons of
reasons but when you add Android to your
list of targets for your code you need
to take into consideration that Android
is Android so it's not exactly standard
and compliant with all the other systems
you use before so for your sins plus
passcode you need to know it's using
bionic c library and not it's not
compatible with standard genius the c
library so it's you have some things
that are missing like p red clothes and
some of our processes but you also gain
access to specific android system
properties for you have specific NDK api
if you can use for example to replace
gel know in segments you have another
system for on android but yeah but
prevents you to write really
cross-platform code sometimes you need
to write that on specific code and in
general but not you need to cross
compile your code so to generate dot iso
files for android and for all the
android architectures it's that are
supported by the NDK and right now there
are seven of them so the NDK makes it
easy you just call any cables and it
will generate your dirty so files for
all the architectures it's better to use
the indicate for this instead of trying
to have all the two chains to generate
yourself the dot iso file because many
things can go wrong and are not
documented
what was for see I show doing some C++
by default nothing is supported but
object but already including vnd k and
the platforms you can switch the c++
runtime to something that provides more
functionalities for example by default
you may think you don't even have STD
and not even support for templates or
exceptions or runtime type inspections
but you can switch was turned out system
C library to another so where is the
list so JB I prefer + + SGL Bob GN last
year or lip C++ with different set of
filters you can ask why L like five
different c plus those from times the
answer here is simple really learn they
have different supports so if you're
looking for STD chrono it's not
available in all the different specifies
runtimes some of these run times are on
GPL version to some of ours aren't so
for each case you for your call you need
to ask yourself which one you want to
use and also if you're using a surplus
platform time you have to use the same
for all your applications so you can't
have different abilities runtimes
leaving in the same process and you can
specify which run time you want and if
you want to use the shared or stay
static version and also when using a
features like exceptional a TTI you also
need to specify but sure going to use
these features for the local cpp
features viable anyway I know it's maybe
a lot of information but make it more
clear so you so very some sense plus
four sources we are you have a method
that article native so here's how it
works at execution time so in your code
system that library is called to load a
dot iso file but
of binary implementations of your C C++
code and when you call sit in the
library the mapping is done between your
native implementations and the Java
headers and later during the exaction of
your code so usually you do a sit on the
tribe load library in a static block of
a Java class so it's it happens when the
class is first loaded and then later
when a native method is an encounter so
negative on the Java side the virtual
machine will execute for c and c++
implementation that has me been mapped
so where is now not a new thread or
whatever is happening it's just a
virtual machine that will execute your
code when it encounters a native method
so you don't go outside of any sandbox
you can bypass permissions or whatever
crazy stuff you wanted to do and then
once the implementation has been
executed it goes back to Java again and
it's quite seamless there is one
exception it's a classic addiction flow
where is a quite common method of doing
since plus person Android it's when you
use negative activity and negative
activity dot H so these are help us from
the SDK from generate NDK that allows
you to create an Android application
without even a single line of Java
because native activity dot H will take
care himself of creating an activity so
an android window instantiating an e GL
view and giving you an open GL surface
and processing giving you a threat to
process inputs everything so in that
case you don't have to do call system
book library yourself or RF mapping
between Java and C C++ methods because
everything is taken care of by the
native activity and you can just reuse
the surface and do your own sins + +
inside native activity but it's still
important to understand all the Java
native interface because even if you
have a native activity
you almost on you c and c++ you need to
integrate v with the android system and
it's a Java world so you you'll have to
use EG a knife from your sin C++ to call
methods that are only available in Java
because the NDK world is very separated
from the Java API so the Java API are
not they don't exist also as on the form
of any k AP is so let's talk about the
ID so Android studio who is using
Android studio in the room okay still
many people so plus google i/o end of
Maeve announced the integration of
JetBrains sea lion so a C and C++ editor
from JetBrains which is right right so
they announced its end of May and
everyone's been waiting for it and it
only has been released in July and
everything is quite alpha experimental
and all that stuff still as of now
before with eclipse viene k was quite
supported and no egg hips support for
Android I mean generate support for
eclipses quite dead and everyone should
switch to android studio and that enrich
view 4 cents prospers everything is did
experimental so it's not the best time
to start writing C and C++ code for an
Android many things are still
undocumented then some changes are
happening every new releases but the
support is great already when it rocks
you have Auto completion you have
automatic mapping of java method so see
here you just waitin whichever method
you but the native keyword and puff you
autocomplete any creates the right
prototype into a new see file and you'll
get Randy k module the only thing that
remains is you need to call system that
old library on the library that will
have been generated maths it's really a
lot and then always in C++ triple from
sea lion is quite
great I mean you've got refactoring you
get also a static inspection so you get
many many good things from the ID so
that made me switch from the I'm
definitely when you configure indicate
module inside Android studio so all the
configurations supposed to happen inside
the Builder kreidel files so here's the
Android NDK block so you see the module
name is the final name of the dot iso
file that will be generated the one you
will call using system load load library
so here I call it logn I so it will
generate data so files named named lib
logn i dot s oh and when you call system
dr. library I think I did hear ya you
reuse the same name so you forget the
lead prefix and the test so extension
you just call system that loader boy
hello Jen I so here's the full picture
by way of what's happening so when you
integrate some C and C++ code here you
see on the top the native implementation
so I'm including the jni header here I'm
returning a J string a java string and
he receive ugliest name in the world so
to define the native method that will be
automatically mapped to string from
chennai so you see it start with java
then package name then the name of the
class hello Jane I then the name of the
method spring from Jen I since I'm
returning a java string I am NOT for
joining a g-string that's quite obvious
but many people would like it to build
automated so I need to create a java
string so for this I use for Jen I
environment that is always passed as
first argument of any method that is
called from the Java Virtual Machine and
on this environment I call new string
UTF here it's in C not in C++ so you can
see I'm passing the end back when I call
the method but
c++ you can just remove this argument
it's not needed so I'm asking the
developer machine to create a new string
that contains arrow from gni the hello
from Chennai part is a C string at this
time and if we create so visit I've a
string and Ruto no reference to the Java
Virtual Machine and this it's a Java
object it will be taken care of like
garbage collection and all that stuff
this case for game decay you just have
one module with one implementation in
since + + that is mapped to one method
in Java but of course you can go further
and having the native activity as I've
mentioned so raise one sample from VN DK
i can recommend you to have a look at it
it's called tea pot as usual for many
demos so it's directly giving you a
drawing engine so here you have methods
those forces so we call this trend or a
teapot I think you already got that and
what you get is drawing on gin and you
can you can start from the sample and I
integrate it with already existing
OpenGL ES code for example and yes just
classic OpenGL ES code
so you see all the auto completion and
everything is working directly from the
ID and you also have the backing strip
off from the ID so these were all the
development step now when we are
integrating since plus first code into
an Android application it's very
important to think about publication
because you're integrating binary stuff
and in Vienna in Europe need to run on
many devices that may have different
platforms so of course for Metro
platform right notes are maybe I v7a let
you also find x86 x86 64 I'm 65 the
eighth a so all these platforms need to
be supported from your binaries so when
you'll you have produced configuration
so when you came module define your butt
brother and so on you compile and the ID
will generate data so files inside so
one notice of alper architecture so here
you see on 64 on the ABI and so on there
are seven of them right now and inside
the final APK this would be integrated
under the folder name lib and subfolders
name against all the ad is at
installation time your device will
choose the folder that you prefer among
the one that are available and use only
believes that are inside this folder and
if you have big data so files that
contains assets or whatsoever you can
also have one IP cape their architecture
that's also possible Android to do this
you need to switch to advanced mode in
the Google Play Developer console and
send all your IP case with difference
the iso files subfolders and if your own
version codes because the Play Store is
relying only on the version code systems
so you can see the body
to AAP kaise to my Google Play Developer
console if you can see beyond the pixels
so with different native platforms
because for the 41 I kept only x86
folder and for the other one I kept only
the army aviation folder and you can see
a summary of our version codes so and
against the welding is but here because
and it explains you what is important is
some devices may run multiple apks so
all the x86 Android devices in fact they
can run arm code because you have run
time translation so the device will
always receive the APK with our version
code whatever of a native platform is if
it is supported so we need to give the
iOS version code to the x86 platforms
and the other case I mean I maybe I
devices running sh6 code don't exist as
of now so keep this rule I or version
code for x86 platform
so back to what you can configure when
you are using the ND game so you saw
earlier from the bell adult file you
could of course Chandra module name so
the name of your data file you can also
specify the toolchain is version so in
android ndk you can by default it's GCC
for dot 8-430 to build our phones and
followed nine five eight sixty four
platforms you can also switch compiler
and so on important to you can set
specified CPD flags ldflags and lips and
ABI filters if you want to support on
your specific set of platforms you can
put this here and SG else or the c++
runtime of your choice honestly it's not
enough yet for some projects you may
want to have more so they are supported
by some some part but not fully yet so
for the future you may expect of the
darkest dark spot for include
directories and so on right now you can
specify two directories by tuning the
cflags think I've got an example for
this at least in the cheap example you
can look at all they did for example so
yeah it's not pretty but it works so
that's how you can specify more include
directories by using the speedy flags
sometimes when you walk with the NDK you
may have libraries such as opencv or our
server that are already pre-compiled so
on the form of dot they are those files
right then it's not well supported by
Gradle it should be supporting the
upcoming versions right now you can do
it finally with some hacky way so right
now if you need to rely on pre-built so
already existing that iso files r dot a
files what i would recommend is to
deactivate all the gradall configuration
and instead use the former way to use
the NDK with eclipse which one that was
to use eclipse at all it's to directly
call ng cable script yourself and use
net files so with the Android NDK you
can use not so regular make files but
Android NDK make files called Android at
MK an application at MK if you want to
do that you can just deactivate so from
your battle cradle you can tell the
system not to look at your gen I sources
and to integrate the tesco files from
the libs folder so when you use ND
cables from the the NDK all your dotage
so files will be generated inside lips
the lips folder so you can just tell
Brad all to integrate you lata so files
while enjoying your sources not try to
recompile anything this way you have the
IDE and even the bugging where they are
walking and you can fully configure your
nek modules so here's the shortest
possible Android at MK file that defines
urine DK module it sources and to create
that so file so look at module here you
see you again so here it's still a no
Jane I now you need to specify your
sources I can make usual make files and
to include the macro vitesse three ndk
to build to build a diversified em
there you can configure a lot of things
of course more than what we then what
you can do with the dual cradle so I
keep all this for reference because we
we don't have as much time as we need
but yeah you can easily configuring two
directories pre-compiled modules that
you rely on and so on and the over make
file is called application at MK and in
that one you only configure things so
variables that are for your notice of
files so the most important one is the
app platform that defines what is the
minimum and with API level you need to
run against by default there is a huge
bug in hundreds video and brothers
reports that will always choose the
highest possible one when you use
Android studio so you need to at least
test your application on earlier devices
to see if it's working because normally
what you do is to set this up platform
variable to the minimum version you want
to run against it's very important here
and then all the other parameters you
can already config your fees from
Android studio and brother so toolchain
the platforms for supporting v c++
runtime and so on no I said andresito
everything is quite experimental alpha
and you get many races you may use / IDs
I mean if you're using unity you don't
really care about Android studio and it
works it supports all the platforms what
I've said about version codes and dota
suffice integrated in the apps are still
is still true for when you're using
unity because you need to relies on the
data files but you may want also to use
for example visual studio so 2015
version as greatly improve android
support so now you can create dark here
native activity simple as a t5 first and
all your coding and packaging from
Visual Studio it's working right like
many of us feel targets and you even
have projects that can targets both
Android and iOS
while sharing OpenGL ES code that's
quite great yes you screenshot from
visual studio with Android code what's
working well now only one thing is when
you use and rich to visual studio as
usual you have salt targets you can have
armed target x86 target that means it
doesn't support having all the Android
targets at once so you need to recompile
for each platform but you need to tune
the Russian code accordingly when you
target different platforms and by
default it's not done that's quite sad
story luckily I've just written a file
for so you just copy and paste it in
your projects called custom rules a tech
center and that will address the version
code depending on your cpu target so
this way you just integrate this file
and you can easy publish your apk for
all the supported platform to the Play
Store and it will work not complain and
properly be distributed to Android
devices</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>