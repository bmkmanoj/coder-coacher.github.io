<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Testing React Applications w/Jack Franklin | Coder Coacher - Coaching Coders</title><meta content="Testing React Applications w/Jack Franklin - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/BeMyApp/">BeMyApp</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Testing React Applications w/Jack Franklin</b></h2><h5 class="post__date">2016-07-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/eWN8F_WOBAQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">everyone and welcome to another be my
webinar will be starting very shortly to
get movie starting shorten my ladies and
gentlemen a warning to another be my our
webinar and Fernando once again it is a
pleasure having already here in this
session we have been created will be
going over testing we are applications
ah jack is from here's a axial
javascript professional weapons with
jquery we are go for Linus and what
further ado I'll give it to the man of
the hour I developer evangelist to check
frankly are yours cool thank you
everybody thank you for London for
inviting me on it's really good to be
here he said my name is Jack I'm Jack
underscore Franklin on Twitter today and
we were talking for about half an hour
or so on testing react applications and
my experience of doing so I'm going to
show quite a lot of code and things
throughout the presentation and at the
end I've got a few links to like github
and the slides and all the rest of it so
please don't worry about all the code
i'm showing you i will send you link so
you can go and get it and run it on your
own laptops as well and i can put the
links into the group chat on the google
hangout too i believe there are
questions at the end as well as the put
your questions in and then we'll answer
some of those later on yeah but without
any further ado really I just want to
get started so I work for a company
called pusher first of all pushers are
hosted a real-time API platform we make
it really easy to build real time
features into your web apps or mobile
apps that's of interest we're at pusher
com or you can follow app pusher on
twitter you know feel free to ping me if
you've got any pusher specific questions
as well and i'm more than happy to talk
about that and I'm Jeff Franklin you can
find me on JavaScript playing calm and
on github as Jack franken as well and on
twitter with the underscore between the
two names so yeah today i want to talk
about testing react applications my
experience of doing so and just show you
a few of the kind of tools i use every
day when testing my react apps we test
because it gives us confidence in right
locations that work especially if you've
got a big team on a large application
across more than one or two developers
it's very easy for a team on working on
feature a to break a bit of the you know
another feature that already exists by
having tests around those features we
can be confident that the functionality
of the application is working as we add
more developers are more code to the
codebase it's also really nice for
fixing bugs because you can replicate a
bug in a test and fix that test and then
not only have you fixed that bug but
you've also ensured that bug can never
happen again because you've got a test
now covering that and i found in my
experience testing enables teams to move
quicker easier to refactor because
you've got those tests there to back you
up and generally they're just a great
thing to have this is a very dreadful
Shakespeare pun about TDD or not TDD but
the point here is something that I've
noticed is in reacts applications I tend
to write my components first and then
write the tests this is kind of
contradictory to my experience in say
Ruby or regular JavaScript if you like
where I'll often write the test first
there's no hard and fast rule here it's
really whatever suits you but I'd find
personally with react I like to write my
component
get an idea of how they're going to work
the functionality that's inside them and
then write the tests afterwards but you
could definitely right react test first
like you would have any other language
or framework before I go into the reacts
Pacific's as well there are a lot of
JavaScript testing frameworks available
the one I use is called tape is pretty
minimal and gives you kind of the bare
bones which is the reason I like it
however I've used also use mocker which
is very nice as jasmine there's jest
which is by Facebook there's a whole
load of them I'm sure there are 20 more
I could mention here all my code
examples are going to be using tape
primarily because that's my framework of
choice however the actual core of this
talk about testing react is framework
agnostic so if you hate to AP news maka
it's absolutely fine the actual tests
themselves don't depend on the
particular framework so even if you hate
tape you know there should still be a
lot of good stuff in here for you
finally as well I'm going to be using
some the latest es2015 features I'm
running it all through Babel to get it
working the main thing i'm using is our
functions which are just a nicer way of
writing regular function so a bit more
slimline they vary slightly differently
in a couple of situations but we won't
need to go into those today I'm also
using the es6 or es2015 module system so
rather than using the common jess
requires i'm using the import statements
again that's really all I'm touching
upon you don't need a good knowledge of
es2015 to take anything from the talk so
if we first start with just a basic test
intake just to give you an idea of how
these tests might look hopefully you can
see my mouse there if it's moving the
first thing we write cool is this test
function we give it a string which is
the description of the test and then a
function that takes in an argument which
is the thing we then cool tests on so
see here this adding numbers test I have
a function takes more argument t i canna
nest my tests by just calling test again
and down here i have the actual
assertions tape requires you to tell it
how many assertions you're going to make
sin this a case i say t dot plan one
that means hey tape i'm going to run one
test in a minute one assertion the
reason this is useful was because if you
have asynchronous tests you don't have
to kind of hook for my
to take tape just knows that you're
expecting a certain number of assertions
and therefore a way to certain amount of
time through a test to complete and here
in this test i use t dot equal to assert
that two plus two is equal to four down
here i use deep equal which compares
objects to sir this object matches this
object here that's really all tape gives
us which is one of the reasons i like it
and also won the reasons i like using it
for talks because i think it's fairly
minimal there's not too much to explain
so just a quick recap we use t dot plan
to tell tape how many tests you're
expecting this means tape the handles
asynchronous test really well we've
sings i t dot equal to check two things
are equal T dot ok Jack a thing is true
the deep equal to compare object and
there's a few others as well it's got
good support for running through Babel
for converting es2015 specs and the repo
are linked you to at the end has all
this configured for you and it's pretty
minimal there's not too much of a
surface area to it so to run the tests
I'll use a thing called Babel register
this is something that that will hook
him to any import or require statement
and run everything through Babel so it's
a nice way to run your tests without the
first do a big translation step so in a
typical project I'd create a test script
in my package.json I'd run tape and you
see here are this minus our Bible
register will load in Babel so it will
start converting all my files for me I
then just give it a path of files to
watch so in this case this will run any
tests file that's in a directory called
test and is named something dashed sjs
as I said all of this is in a repository
I'll give you access to at the end so if
i run that and i run my tests that
showed you earlier will get an output
that looks somewhat like this so adding
numbers two plus two equals four you'll
see this okay one which means that test
passed and you'll see this okay to which
means the second test passed as well
this is the output that tape will give
you by default it's called the tap
output which is the test anything
protocol the idea is that it's a
standard way of outputting test results
that's easy for computers to read it's
not that good for humans to read however
and but the reason it's good for
computers to read means that people can
write for matters around it so if you
don't like how this output looks
you can write your own formatter around
it thankfully there are lots of them out
there it's not designed for human eyes I
use one called faucet so we we pipe our
tape out through it through faucet and
if we run this you can see in the bit
tidier so we've got some kind of green
ticks there and it's just tidied up a
bit there are loads and loads and loads
of reporters available one of my
favorites is the nine cap version which
you can see there there are loads of
these I'm sure you can find one that
suits what you and your team want to
have outputted if not it's pretty
straightforward to write your own as
well so not going too much into that
other than just to let you know that
these are available you probably
wouldn't use the cat in a real situation
but it's quite entertaining so moving on
to a starting to look a bit more react
reacts is actually really really
testable I think people have a bit of a
bad notion of what it's like to test
frameworks because in the past it has
been very tricky to test something like
angular or ember or these much larger
frameworks i should say in the interest
of fairness that the testing experience
for angular member is also pretty good
these days in fact testing generally in
on the client side has come forward a
long way but i still personally find
react the nicest to test so to give us
an app that will work on through the
duration of this presentation i built a
little to-do app a long time ago when i
wrote a blog post around christmas time
so this is our to-do app it's quick
video I can click on what to do to
toggle it I can hit delete to delete
them I can fill in the box and hit
button to add a new one as I said I
wrote this around Christmas time so you
have to forgive the the Santa references
that are now incredibly outdated so
that's it there's not too much going on
here it's a pretty straightforward app
it's not using anything like Redux or
anything big we're kind of keeping it
quite straightforward this just give you
an idea of how this app is laid out so
we have this app component which is the
top level component I've got to do is
component and this renders a list of to
do's where each list item contains a
to-do component it's given the object
the representative to do so each to do
has an ID a name under they boolean done
field then against a couple of call back
because done change and delete to do
these are called when someone hits the
delete button or when they click to
toggle it to do then finally we have a
add to do component we
I renders the ad to do form and has a
callback called on you to do which it
should call when the user has filled out
the form and hit submit so all the state
is held need to do is component and
other components notify that component
when data has changed so before we dive
headfirst into react testing I want to
talk a bit about just testing generally
as well and then react applications what
I found the best pattern to help me test
is actually to embrace plain old
JavaScript objects most of your complex
business logic should actually exist in
my opinion outside of your react
components plain old JavaScript
functions are incredibly easy to test if
you've got functions that taken from
data and give you back either true or
false or some new data or something
they're it easy to test you don't have
to set up react you have to do any
boilerplate to test them they're just
plain old functions so one of the nicest
patterns I've found is actually pull any
complicated logic out of your components
into standalone functions your
components can call out to those
functions but you can test those
functions in isolation without having to
boot up the react application this is
the biggest thing you can do in my
opinion to make it much easier to test
your reality apps and even your ember
angular whatever apps writing plain old
JavaScript as much as you can so for
example in this application need to do
is one I've got a file called state
functions Jess and this exports three
functions one toggle done one called add
to do and one called delete to do each
of them take the state of your
application so a big list of other to
do's and some extra information they
need and they return the new state which
has had some some transformation applied
to it so toggle done for example takes
in the state and it takes the idea that
to do and it returns a new state where
the to do matching the ID has been
toggled between done and not done anyone
who's used Redux hey will recognize this
pattern this is very simple Redux does
they do a bit more work around it the
general idea is pull out functions that
can work on your state and data that are
isolated from your react components
testing this ad to do function for
example is them really easy so I create
my initial state which is an object with
two dues where I've got an array with
one to do in and then i create my new
stable
the ad to do function I give it the
initial state and I give it the need to
do and I can assert that the the second
to do in the array is equal to that to
do I just added there's no knowledge
hear about react there's no set up a
rear there's no nothing to boot my
application as it were I'm just testing
plain functions so I'd really encourage
you to do this as much as possible but
of course that's probably not why you're
here we'll probably here to learn about
testing react components so let's start
looking into that so the first thing
we're gonna do is actually test the to
do components are not the big list we're
going to test an individual to do
component just give an idea it takes in
three properties that to do which is an
object the done change function which
you should call when we toggle it to do
between done or not and delete to do
which should be cool when the user hits
the delete link just again more to give
you context anything else this is a
rough version of the code I've stripped
a bit out to save some space but this is
the general idea so we rented us to do
we give it this extra class of done dash
to do if it's done and that's what
applies the strikethrough styling then I
have a link to toggle it and we call
toggle done and I have a delete link as
well the toggle done function just calls
the done change passing in the ID of
itself and the delete to do function
does exactly the same just passes
through the ID so there's three bits of
functionality here that I would probably
want to test the the render div element
is given a class of done that to do if
the to do is done deleting it to do will
call this props delete to do it with the
right ID and clicking on it to do calls
this dot product toggle done with the
right ID so the first thing we can do to
start testing react components is
install the react add-on called test
utils watch your install just threw em
p.m. this link there takes you to the
full documentation for the test utils
and to start with we'll look at shallow
rendering so this is when you can text
your react components without actually
needing a Dom in place so rather than
actually render your components to a DOM
and test them that way how shallow
rendering works is we instead get an
object
back the represents what would have been
rendered to the Don you can then make
assertions on that object and no Dom
rendering has had to happen this keeps
your tests a bit quicker because you
don't have to go through the like
bootstrapping a DOM and rendering to the
DOM and making assertions on it so this
is how we create a shallow renderer that
we use in our tests so I import the test
utils here in my function shallow
renders to do I first create a renderer
using the test utils crate render a call
then I call render render and I pass in
it excuse me I pass it my element my
component I want to create it's in this
case I'm going to render aid to do
element I'm going to pass another to do
and I'm also going to pass in this done
change and to need to do functions that
the to do component expects and then we
return render a dog get render output
what that's going to do is it's going to
give us a massive JavaScript object that
represents what would have been rendered
to the screen I should as well is this
whole like create renderer and get
render output you tend to abstract that
into a function that you will call so
you only have this code once at the
output from this looks somewhat like
this now I've removed a lot of the keys
and values from this object to fit it on
a screen and to also just show the
important bits because there's a lot of
this stuff that isn't that important for
this particular talk but you get back
this object that represents what would
have been rendered so it's a oh whoops
excuse me a click too early it's a div
it's got these properties so that you
can see the classes that have been
applied and here's the children elements
there's my paragraph with the properties
and my anchor that says delete as well
but now we can make assertions on these
so for example if I wanted to assert
that we render the text of the to do on
to the screen I could create my to do
with an ID the name of buy milk and done
false I could call that shallow render
function we just created and give it
that to do and then I can test that this
is rendered so I can assert that the
result props children the first one its
children is buy milk and this work and
this this test does indeed pass I could
then say check that a done tweet gets
the additional class I've done to do so
this time I to do has done true a
shallow render it and now I set the
class name prop the result has the done
to do
a class applied to it so this works
quite well for testing kind of things
that you don't need user interaction in
there's just kind of assertions you want
to make on the rendered output without
having to simulate a user click or
anything it can be a bit messy to do
kind of best result props children or
property ogren this this test in
particular is more of an example I
wouldn't write a test the chap that
every single bit of my output you know
renders the right text for example I'd
like to think that kind of thing I'd
notice as a buffer if it wasn't
rendering the text of it to do so I
wouldn't write lots of tests like this
but I would write that the right class
is applied because that's something that
I could more easily miss when I was
working on a feature so that's how you
can test things that need user
interaction but for testing user
interaction we do actually need to fire
up Dom and render our components
properly now you could do this by
writing tests that we run in a browser
however I really like being able to run
tests in node this way I can have my
test run at the command line I don't
have to go into a browser to look at the
result of them and so on so react
components will always have state like
to do is that the user can edit and we
can test these by faking user input and
then checking the render output you
should never reach into a component to
get or set it state directly because
that breaks the abstraction if you like
reacts abstraction there from an input
point viewers your input is your users
actions and your output is the rendered
output of your components and you should
respect that in your tests as well your
tests the way I think about it even your
unit tests and your react components
should act as if they're a user doing
stuff on the page so to sell at the Dom
I'll use je s done jestem is a full dong
implementation but in node this means
that I don't need a browser I can keep
my tests purely in node so installed yes
Tom I have to do a bit of setup to
create my my dom in the node environment
so i set this global which is the node
global variable i set the document
property to be a jest on instant and i
set the window and navigator as well
this is enough to set up a Dom in my
note environment and trickery
into thinking it's being run in a
browser so it will render to the DOM and
all reacts calls will work perfectly
correctly it thinks it will be running
to a browser but it won't it'll just be
rendering to ajs Don so in any react
test well now where I need a Dom I just
need to import my setup or Jess script
which I just had on the previous slide
and that will create my Don for me
before my tests are run so for example
let's test toggling her to do so this
means that you could you can click the
to do and see that is toggled between
done or not so the first thing we'll use
is this test utils render into document
which will render component into a dom
node note that it's a detached dom node
so we'd actually need to clear up the
dawn between each test because these
elements are created in rendered into a
dom node but that's not put into the
body so dream nice for that reason
because we don't need to do any clear
erupted between tests so this is the the
most of the test oh so what we're
testing here is when I click it do the
the done callback property is is called
with the right ID so I'll create my
callback which will take the ID and make
the assertion that the idea is set to
one I'll cream like to do which will
have an idea of one and it will be the
buy milk to do I'll call them and let
into document and pass them that to do
and personally done change prop which is
the one I'm want to make assertions on
the final thing I need to do is actually
simulate the click to do that we first
need to find the element to click on so
we use the test utils find rendered on
component with tag function these are
pretty snappily are named as you can see
they're quite long winded but they are
very explicit which is nice we look in a
minute about library that actually wraps
around these and gives us so much nicer
way of working with this stuff and
finally will simulate a click so if we
found this paragraph and stored it into
the to do text
I Jagger either Jack folks it looks like
Jack Pardee having something of a shoe
this is give up a minute
you
folks are about this emphysema quickly
try to reach him he should be back up
and working and a bit
you
see hopefully this will
you
yes it's the same presentation quickly
answering a question it just seems that
the speaker does inside connection just
cut out somebody's neon five more
minutes hopefully he'll be able to
rejoin us folks
you
Oh losing on Gregor's back that went
pretty smoothly um cool apologies that I
literally just finished presenting and
realized that my internet I don't know
what happens um anyway I'm here now so
sorry about that where do I get to
before you lost me Yeah right before
last you were speaking about your slab
whisper story from the component on the
page that you want to click on all the
constants and canyons equals test out
utensils okay so um how'd i mentioned
enzyme negative hey right have you seen
the test in the to do's component know
that was your slow that you're showing
on screen okay great okay alright so
okay let's go from here again then
apologies for that everyone who's
watching and I have honestly no idea
what happened mind so that didn't seem
to cut out at any point oh well we'll go
from here then cool so apologies again
right so that the point here is so far
we've tested these these individual
components likely to do component and
the add new to do component however your
shoots great oh yeah sorry it's all
going wrong add okay so can you see my
slides coasting it's a good point yeah
is that where I was at something right
place you are you were past that yeah
you're like a few slides into it okay
all right I'll just go from here then
and then we've we've got it all cool
alright so apologies again so the the
point here with this is we tested the to
do component and the add new to do
component in isolation but we haven't
really got any tests that overall our
application is mostly working so these
tests will kind of cover the the overall
logic a bit more that they're almost
tiny bit kind of integration tests in
the way that they these tests will and
kind of indirectly test lower level
components as well this doesn't mean if
you had a much bigger
react at you test the kind of whole
thing in one big test but for four bits
we've got maybe two or three sub
components working together it's nice to
write one or two tests to make sure all
those components are working together to
so the to do is comparing it is pretty
large I don't really need to show you
too much of the code it just renders the
list of to do's here and the app to do
form down here so for example let's
write a high level test that when I
added to do it will get inserted into
the page and the user can see it so the
first thing I'll do is render the to
do's component like so I'll then locate
my input value as my input element on
the page with find rendered Dom
component with tag I'll set the value to
buy milk I'll then find the button using
the same function and I'll simulate a
click on that button the assertion I'm
going to make is that a new to do is
added into the page so in my case the
application is actually hard coded to
start with three to do so I hardcode
some into the state so I'll now assert
that the length of the to do is equal to
four and to do this I use this weird
method called scry rendered on
components with class and for the
longest time I had no idea what this
meant scry rendered on components with
class will find all components with the
given class and gives us back an array
of them this definition comes from the
word scrying which is the practice of
looking into a translucent ball so it's
like a crystal ball kind of person
gazing into it and seeing your future of
kind of weird no but I always wondered
why that method was called what it was
and then I think just before I did this
talk in Amsterdam for someone pointed
that out to me and send me a Twitter
links that was much appreciated so just
for I had mentioned that so our whole
test ends up looking someone like this
we rendered the whole component we find
the input we fill it in we click the
button and we're sir there's now one
more to do on the page it's also kind of
high level test that some of our
components are interacting correctly
however as you might notice test utils
is pre verbose and I'm not the only one
to notice this Airbnb released a live
record enzyme which is a nice wrapper
around these tests which makes it nicer
to
with its a library around the rear test
utils with a much nicer API effectively
it's also uh nepean ated in terms of
which JavaScript framework you want to
use where it's makka tape jasmine jest
or the rest of it so again not test
framework specific so install it through
NPM so ends I makes the API for shallow
rendering much nicer and the API for
actual Dom rendering nicer too so if we
start looking at shallow rendering
enzyme gives us a function called
shallow which we can just call with a
react component and it will shallow
render it for us so remember earlier I
have this shallow render to do function
which is a much it was much more
complicated i have to call that test
utils i'll get rendered output and all
the rest of it now i can just call
shallow from enzyme and my api for
finding data in that shallow rendered
output is much nicer so i can call
result find give it the element i want
to search for then call doc text to get
the text of it so it's a very j.crew
like api which reads very nicely and is
much more intuitive and easier to work
with there's a link there to the full
api docs on them we can also it makes it
much easier to test user interactions to
i can import this mount function whoops
sorry can import this mount function
this will just take a react component
and render it into the Dom I can use
this form dot find input to locate my
input field much nicer and set the value
and then again i can use formed find
button not simulate then give it click
as an argument so the just did the api
fit enzyme is Wayne Eaton I sir still
very explicit and clear but a bit more
succinct which is very nice as a final
bonus it's also possible to take all
these tests and run them in the browser
so I like working in node most of the
time because it's a quick a feedback
loop I can run my tests and the terminal
through my editor that's really nice but
of course when we're building browser
applications is important to test in the
actual browser so to do this you can use
any form of bundler browserify web pack
all the rest of it if every create one
big bundle of all your tests so here i
create take all my tests i transform
them through Babel and there's just two
files you have to exclude from
browserify else it will error
tape has a module called take run which
will run our tests in a browser forest
mock writing supports us out the box as
does Jasmine jest might do or there's a
bug in to make it happen so I busy but I
pull my JavaScript and I give it to tape
run and I tell it which browser to run
in in my case I'm just using Chrome
purely for example and then I could run
this did all this code and you'll see
the tape fires up browser for me you
won't see any output in there but my
tests are being executed and I'll get
the results in my terminal there as well
so although I work mostly in mode when I
maybe just before i deploy I'll do a
final run-through while test everything
in the browser to this is easily
automated through like a sauce labs or
browsers back on one of those type of
companies so just to wrap up and again
i'm sorry for the drop connection
halfway through not
get blood looks like we lost them a
second time he's going to send this or
something a quick email to let me know
wait to listen to your heart or five
minutes
hey there we go my word so I'm currently
tethering to my phone because my flat
Internet has decided to to completely
drop out on me so I hopefully can hear
me okay is there I'm going to let you
know the last thing you were showing was
um was it terminal okay basically you
need to finish using on say yeah let me
share my screen I am I can only
apologize i have no idea what was going
on with this one cool so you can see my
screen cool yes okay so we were here do
you recognize this is this yes yeah
great okay so we actually got many other
things that was just showing that you
can run the test in the browser these
final bits are just wrapping up really
and saying let's do some questions so
there's a link here to blog post the
repository on github visit to do ducks
react dash testing the slides are on
speaker deck already because I've done
this presentation life a real time stone
before and if anyone doesn't manage to
ask a question during this live stream
but it's watching it back or anything
and wants to ask me a question just find
me as Jack I'm Scott Franklin on Twitter
and I also blog at javascript playground
calm so that's that's absolutely it
that's all I had I'm sorry about the
internet who knows what's happened there
but i'm happy to say questions if people
have any case or the video through first
question and let me find some those
links in a minute as well okay a very
first question is is it equally
important to write tests for personal
project and i think that kind of depends
really on your your preference I like to
do it on any project that i know i'll be
working on probably more than a couple
of times you know for like a one-off
hack day or a weekend hackathon that
your app I wouldn't bother with test
because it slows me down there's a
project I think I'm going to be working
on for a decent period of time then yes
I would write tests again it's more kind
of personal preference how many you want
to write
do you have it our second question is
any thoughts about a v8 vs vs tape so
ava is another kind of testing framework
and i don't really have any any thoughts
or try diver and i liked it and
personally I enjoy kind of how
bare-bones tape is ava does a lot of
cool stuff though like it sets up babble
out of the box it has really good
support for like a sink tests runs them
in parallel it has a really good watch
rope mode etc and so it's it's really
nice i don't not like it at all I just
personally kind of like sticking with
with tape but again that is ninety-five
percent personal preference more than
anything else so you know I'd encourage
people to play around with a few of the
test frameworks and pick the one that
works best for you next question is we
use reactive yr x GS any thoughts on
testing of google observables conical
points this isn't something i've
personally done so i don't want to talk
too much about it or because i can't
really talk with any authority on this
and from what i imagine i can't imagine
it would change my testing approach too
much because i still like to test you
input as user input and output as kind
of the rendered components I haven't
done anything more like specific on RX
and react those that really that's all i
can offer there I'm afraid and last
question is or just get it from one
circuit any thoughts of automated
integration tests are they needed in
real applications or is testing single
components slow seducers you know so I'm
presuming this this person means things
are like the kind of end-to-end test
where you fire a browser and actually
click around and I think they are not
needed as much from my personal
experience with projects those tests
tend to be very brittle and they can
often just completely kind of break or
you know they'll fail randomly just
because the act of clicking in the
browser then you have to wait for that
click to happen there's often local
problems around
I found myself not needing them as much
in react I think because the test i
right do simulate clicks and I would
still be tempted to maybe have one or
two very high level overview tests may
be at your one or two most key like user
journey through your app but as a whole
I find that they're not needed as much
and I find actually for me I'm more
comfortable with thorough tests on their
components and like as this person said
they're reduces and then worry a bit
less about the high level kind of
end-to-end tests I'd probably still
write a couple but they wouldn't concern
me as much again a lot of that is also
can come down to personal preference and
what you and your team won and prefer
most of all oh yeah that seems about it
thank you very much once again for
coming a big thank you to Jack Franklyn
pitching sometimes showing us how to
test those for beer taps as always folks
if you have always want to check out our
other events email our towns we have our
live updates you can check out upcoming
webinars hackathons on our meetups as
well so that's have an awesome day
depending where you are and cheer
stomach thing</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>