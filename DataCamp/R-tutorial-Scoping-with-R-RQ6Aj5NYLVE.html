<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>R tutorial: Scoping with R | Coder Coacher - Coaching Coders</title><meta content="R tutorial: Scoping with R - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/DataCamp/">DataCamp</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>R tutorial: Scoping with R</b></h2><h5 class="post__date">2016-11-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/RQ6Aj5NYLVE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">scooping describes how our looks up
values when given a name it's important
to understand so that you can reason
about functions without running them if
I assign the value 10 to the name X and
then ask for X scoping describes the
process that I use us to find the value
10 inside functions scoping works as you
might expect when this function is
called the function begins execution in
a new working environment in this new
environment x and y are defined then put
in a vector and return unsurprisingly
the return value is the vector 1 2 if a
variable referred to inside a function
doesn't exist in the functions current
environment it looks in the environment
one level up in this function G Y is
defined but X is not when G is called
and execution reaches the line combined
x and y in a vector y is found locally
it takes the value 1 X is not found
locally so R looks for it in the
environment upon level the global
environment in this case and finds the
value 2 if X didn't exist in the global
environment the function will return an
error since X isn't defined locally or
any higher level scoping describes only
we're not when to look for a variable
this means it's possible the return
value of a function could depend on when
you call it for example here depending
on the state of our environment whether
X has the value 15 or 20 the call to F
with no arguments returns different
values this is really undesirable
behavior for a function because if we
look at a call to F in isolation we
don't know what it will return for this
reason when you're writing functions
they should never depend on variables
other than the arguments we'll talk more
about this in chapter 5 on our bus
functions lookup by name works exactly
the same when the name refers to a
function here when the function M is
called
and it reaches the line call l with the
value 10 I uses the L function defined
locally as X times 2 and returns 20 if
it is obvious you're using the name
function our ignores any non function
objects when it looks it up here's a
really tricky example see is being used
in three ways first as a function n are
correctly finds the c function that
combines values into a vector second C
is being used as a name and finally C
refers to a value which are looks up and
finds us three every time a function is
called it gets a clean working
environment this means different calls
to the same function are completely
independent here is a function J that if
the object a doesn't exist it creates it
and gives it the value one otherwise it
gives it the value a plus one
finally it returns the current value of
a regardless of how many times you call
J it always returns one since each time
it's called the working environment is
empty a is created in this working
environment but the environment
disappears as soon as J exits
this also means any local variables
created in a function and never
available in the global environment in
summary when you call a function a new
working environment is created to
conduct the execution of the functions
body this new environment is first
populated with the values of the
arguments as the function executes
values are looked for first in this
working environment and if they aren't
found they looked for in the environment
the function was created on</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>