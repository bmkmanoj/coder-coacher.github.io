<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Code Jam’s Kickstart | Coder Coacher - Coaching Coders</title><meta content="Code Jam’s Kickstart - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Students/">Google Students</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Code Jam’s Kickstart</b></h2><h5 class="post__date">2017-06-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/zTEW3WsGWKs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">everybody I mean I'm one of the
co-chairman ears so I write problems and
prepare them and try to make sure the
platform runs as smoothly as possible
hi everyone I'm Mellie I walk on
kickstart in my 20% time I designed
problems and write test cases College
all right so I just want to talk you
through a little bit about what
kickstart is and then we'll talk about a
problem so first of all what is
kickstart
it's a code Jam spin-off competition
that's targeted specifically at students
and it used to be so we only offered
this in Asia at one point it was called
the a PAC University test for three
years but now we're excited to be
expanding this to North America as well
and there are many online rounds each
one is kind of targeted at a certain
geographic region but anybody is welcome
to participate in any of them and there
are various puzzles in each round
designed by Google engineers like me and
other people so I want to say a little
bit about the difficulty of these
problems if you've looked at code Jam if
you looked at like some of the World
Finals problems for instance from last
year you might be like I like these are
so hard how in the world could I
possibly solve these so don't worry the
problems in these rounds are like they
range from maybe like a code Jam
qualification round problem to maybe
like a hard code jam round one problem
we've targeted the difficulty
appropriately for this audience so even
if you've never like done much coding I
like I was the first time I competed in
code Jam I had barely code it I still
had a great time because there's a range
of difficulty levels so please don't
feel daunted about competing so as I
said there are some rounds that are
targeted toward North America in
particular so we have a practice round
coming up this weekend Sunday June 11th
at noon and that will run for three
hours that contains only like problems
from past kickstart contests so this is
just for practice like the results of
this don't matter you can approach it as
like a way to get familiar with the
competition arena but like you're not
being judged or anything on this just to
try the problems and have fun then round
C will be two weeks after that on June
25th it'll also be at noon and it will
run for three hours and then a few
months up to that September 24th so
we're going to have a kind of unusual 12
hour around and in that round you'll be
able to start at any time but if you
want to be if you want your results to
be
considered by recruiters for example
you'll need to finish all the problems
within three hours not finished all the
problems but everything that you do
submit needs to be within a certain
three hour window so there will be more
details on that as we get closer to that
time and so I do something like this one
reason is that some of the algorithms
and techniques that you use in this kind
of contest are similar to what you do
day to day on the job at Google and in
particular these problems are very much
like technical interview problems so
participating in these contests is
excellent practice for that it'll also
show you what the code Jam arena is like
so if you do kickstart this year and
then you want to join the code Jam
global contest next year you'll be all
set to do that depending on how you
score in the rounds and this threshold
varies from round around you may be
contacted by a recruiter again don't
worry about like what the exact cutoff
is for each round like just kind of
solve as many problems as you can and
most importantly have fun so I
personally think and I hope you agree
with me this kind of problem is really
fun to solve like if you have that
insight like oh I didn't get it always
see it oh yeah like you can get really
like having that aha moment can be a
real thrill and you can come away with a
problem learning a technique that you
can apply on the job I've actually done
that so lots of good reasons to
participate and as for how to prepare
for one of these most of what you need
you'll pretty much get in coursework so
fundamental algorithms know how to sort
know data structures it's really
important to be comfortable with a least
one programming language like there
needs to be a language where you can
quickly turn your thoughts into code
without too many too many problems too
much debugging you can use almost every
let any language you want the terms list
what's usable but basically anything
that's publicly available is okay so
just make sure there's one language
where you're kind of ready to go and you
don't waste too much time like looking
up syntax and that sort of thing and
then also for code Jam it's really
important to be able to test your code
so this is a good skill to have in
general your co-workers will love you if
you're good at testing your own code
like down the line but in the contest if
you get even one test case wrong then
it's you get zero points for the problem
like that's kind of how it is in all
these programming contests so you need
to think really hard like what are the
edge cases what could make my code run
too slowly or give an incorrect result
you want to spend some time thinking
about that before us
your code and let's talk about what's
actually involved in solving a problem
so when the contest opens you'll see
several problems you can work on them in
any order you want
they don't have separate timers or
anything just pick one and start looking
at it read the problem think of an
answer write your solution and then by
the way when you're writing your
solution you don't have to code
beautifully like on the job it's really
good to write very clear code that's
well commented in a programming contest
we recognize that like you know
everybody's kind of pressed for time
it's possible that like maybe recruiters
will read the code or and certainly like
your colleagues doing the competition
will be able to look at your code after
the contest but that said everyone knows
since this is kind of a unique situation
where speed is really helpful so I
anyway when you're when you written your
code you can push a button to download
an input file you'll run your code on
that input file to generate output and
then you'll submit that output along
with your source code and if you get the
small data set right then yeah you can
move on and do the same thing for the
large data set you might have to kind of
rework your algorithm to make sure it's
fast enough for the large and if you're
wrong no worries on the small you'll get
the chance to resubmit and you just get
a small penalty you only get one chance
at the large though so again like I said
make sure you test your code carefully
think about those test cases and be
really happy with what you submit for
the large alright so there's no better
way to learn than to walk through an
exact actual kickstart problem so I'm
going to pass it over here thank you
so this problem that we are going to
walk through is called evaluation it's
from it's a third of the fourth problem
from the round C of kickstart 2016 so
you can follow the short link that we
have specified so imagine that you are
programming in a language like Python
where everything is an every variable is
an object and assume that there are
functions which take multiple programs
for example function f takes two
parameters so what we have given you is
a set of assignment operations so for
example we say that a consumes output a
function f which takes per parameters B
and C where B and C are again some
variables so as you can see in the slide
there are three assignment operations
what you have to do is you have to
decide for an ordering of these
assignment operations such that they can
be evaluated safely so for example
it's never guaranteed that any kind of
ordering will work so as you can see if
the ordering of these assignments is
kept as ABC this will not work because a
needs so to calculate e a we need the
variables B and C to be available
however B can be calculated without any
dependencies so as a solution you can
see that the ordering PC a will work
because B does not have any dependencies
for the C can be calculated using the
value of B and a finally can be
calculated using the values of B and C
so and further it's never a guarantee as
I said so imagine there's an assignment
operation like a equal to F of a this is
a cyclic dependency there's no guarantee
that this will work so we have these
kind of complex inter dependencies and
these could be very large in the size of
the chain so what what a very simple
idea of approaching some problems is to
think like how humans think like
radially so there are some operations
that we are trying to do and what we can
do is we can I trade through them I
trade through the whole list in order
and wherever we see a function we can
evaluate the thing in fo behalf we will
evaluate it and there is no reason we
are not going to do that because it can
only help us later
so what happens if you reach the end of
the list there might still be some
assignment operations left so what we do
is we start again so in the given
example in the first iteration we can
calculate B and we can calculate C again
because b has been calculated in the
next iteration we can calculate a so in
two iterations we can say that we can we
have a valid ordering for these
assignment operations now what happens
if you when do you stop so the condition
for stopping you can say is that if you
make a full pass through the list once
without evaluating anything then it's
impossible for all the all the
assignment operations to be done safely
otherwise
we will eventually evaluate everything
and then we'll have a valid ordering the
order in which we are literate the
functions now a very essential part of
solving these programming puzzles is the
efficiency of them
so consider always consider the worst
case of your algorithm so imagine you
have a list of operations list of
assignment operations and in one
iteration you can only do one assignment
this will require you worst-case order
of n iterations and in that way your
total algorithm would be order of n
square which is a which is not that good
for the large input large data set it
will work for the small but for the
large we need to increase the efficiency
of our algorithm now what you can do is
so a very good approach to solving these
kind of problems is to represent the
input in another form we can reframe the
problem we can reorganize the input that
we have in a different kind of structure
which will help us visualize the input
and come up with some efficient
algorithms so if you imagine these
variables as nodes and expressions as
the directed edges what we'll have is a
directed graph now what an edge from X
to Y it means is that you must do X
before Y so if a is dependent on B and C
we add a net we add two edges one from B
to a and one from C to it now this might
sound really similar to you what we are
looking at is a topological sort of a
directed graph what topological sort say
is that given directed graph you need to
find a permutation of nodes such that
for each edge from node I to node J the
node I should occur before node J in the
permutation so in this slide as you can
see the permutation C a B is not a valid
because there is an edge from B to C and
B occurs after see in this permutation
how all three edges satisfy the
permutation BC a now I'm going to walk
through a really famous topological
sorting algorithm it's called cranes
algorithm and so for for you what I have
is a classical pancake recipe now you
have the ingredients floor eggs milk oil
and then you mix them and finally you
cook them in a pan which has some oil
heated oil and then you finally serve of
course this is really stripped off I
mean I would've loved if pancakes with
these easy to make so now if you can do
only one step at a time what you're
trying to do is to follow a topological
sorting of these tasks of course you
can't serve before cooking and so on so
the idea is really similar to the greedy
algorithm that we had formalized earlier
what we can do is we can do all the
tasks which doesn't have any dependency
so you can follow any kind of ordering
for these tasks so for example you can
go to a shop where you get oil or you
can probably go to a supermarket where
you get flow legs etc when you do these
tasks some other tasks will be able able
for you to do so what we can observe
here is that doing some tasks opens up
some new frontiers for us so as you can
see the next step would be to heat oil
or set and mix the ingredients we have
so the algorithm that we can formalize
this at any step of the of the algorithm
what we are going to do is we are going
to maintain a set of available tasks and
we are going to choose one of the tasks
from this set to do and doing this will
create some new tasks which don't have
any more dependencies so that which
those ours can be added to this set so
the next step after formalizing an
algorithm is to implement that in a
language of your choice and before
implementing you need to figure out some
details like the kind of data structures
you are going to use so we need to
represent the dependencies that is the
directed edges and we need to represent
this set of available tasks of course
the complexity of the algorithm is going
to depend on the choice of these data
structures so if this said that we are
going to maintain if it is able to
handle insertion and removal in constant
time then that's the best we can do for
such a set
so I will go into some detail here and
what we are going to do is for each node
in the directed graph we are going to
maintain a list of vertices v such that
there is an outgoing edge from u to V
further for all the nodes we are also
going to make a maintain the number of
dependencies that that certain node has
which will be equal to the number of in
degrees it is it has and further the
invariant that we have is that the set s
of nodes at all steps will have those
vertices for which there are no
dependencies and further we have this
pseudocode which simply says that if you
have tasks to do keep doing them and
just choose one task out of this set s
let's say it's you and just say that I'm
going to do this task that is appended
to the answer then for all the all the
nodes v such that we were dependent on
you we are going to reduce the number of
dependencies of V and if doing so makes
them available for doing we add it to
the set s and finally build on our
answer now as you can observe if set s
is maintained like a queue or a hash map
even the complexity will be order of
number of odd number of nodes and plus
number of edges as we are traversing
through both only once so so that was an
example of one kickstart problem that
happened to have a kind of well-known
algorithm lurking underneath the surface
but it's important to remember not every
problem is going to be like that
sometimes are going to have to have kind
of a creative insight of your own and
there are a lot of ways to arrive there
I mean one way to do it is to like work
through a few small cases by hand like
let's say you see a problem and you
don't really know where to begin so work
on some small cases and you might see a
pattern that you can apply to the the
whole politically the small data set or
even the large data set so doing some
thinking before writing any code it
could be really helpful but everybody's
style is a little bit different right
like some people may like be able to
think while they code and kind of and
that that synergy might work well for
them so just be prepared for not only
standard algorithms but original
insights as well
and I think with that we'll open it up
to questions so we'll take some
questions about kick start about this
problem anything you're interested in
all right so we have a first question
are we at a disadvantage for not having
done rounds a and B so I want to
emphasize that the kickstart rounds are
all independent competing in one doesn't
influence like how you'll be evaluated
on any future rounds
there's no advancement structure like in
regular code Jam where you have to get
to round one and then get to round two
and so on so you're not at a
disadvantage and in fact like if you're
worried oh I haven't done the same
problems so I have had enough practice
you can go to the past problems page and
see the ground a and B problems and work
through them and think through them okay
and we have another are there
limitations to the number of times or
attempts you can try out problems people
filled up so as Yin its said earlier for
the small data set you can submit any
you can try any number of times you will
be shown the result of the attempt
immediately however the large data said
you can only attempt once and the result
for that will be shown to you at the end
of the raft yeah that builds up a little
bit of drama you won't know right away
whether your large was correct so even
if it looks like somebody else has
solved all the problems they may not
have had all the answers right all right
so we have another question how related
is actual software engineering at Google
that is kind of contest so it's a fair
point that programming contest problems
are not necessarily exactly like what
you do at work like I don't spend my day
at work arranging pieces on a chess
board and a certain arcane way or
finding like the prime number or
whatever actually I do do some of that
because my job is to help write code Jam
but in general most software engineers
don't do that however getting a good
algorithm is really important on the job
in addition to these contest problems
I've seen a real-world situation at work
where somebody coded something thinking
oh you know like this is o of N squared
but the list is never gonna be that big
right and at the time like that was true
the list would never get that big but
then things change down the line and a
list with tons of elements made it in
and this was this actually like crashed
an entire pipeline because it took so
long to evaluate that that list sort of
squared
self I do another yeah so I think this
kind of programming can contest they
help you think about the complexities
and they test rigorously the what kind
of corner cases you are covering how
much you are thinking about the problem
actually so just just an analogy that I
like to make is that imagine this
programming contest as working out in
the gym and the actual software
engineering job as working for Marines
in the US Army so I think for for a
person who is looking to get in into the
Marines doing this workout is a good
option yeah there's there's not much
better to practice than actually solving
these contest problems I would say
that's probably the best way to prepare
for the contest sorry one second uh we
have another question how much coding or
programming experience do I need to
participate so when I started code Jam I
had barely done any coding and I was
able to kind of I mean I didn't do
amazing but I was able to kind of pull
my way along and I've learned a little
more and got better and better in future
rounds I would say that so that problem
that we showed you had topological sort
in it so if you hadn't been explicit
that idea before it might have been a
little bit hard to come up with
naturally but you still could have
gotten the small data set of that
problem just by coming up with the
greedy algorithm and running through
that so we try to set it so that anybody
can come in and have insights and make a
lot of progress but to get every single
problem right again which is not
necessarily needed for recruiters to
take an interest in the performance you
might have to have seen a lot of
algorithms and course work and so on so
at the end of the day you are dealing
with logic abstractions and programming
is just a tool to convert these
abstractions into into code so I have
seen people with mathematical background
performing really well in this kind of
programming context once they get hold
of the basic data structures and the
programming language so apart from the
basics of a programming language I won't
say that you need a lot of experience
alright so we have when a problem is
given how do you approach it and what
should be the thought process so I other
people's mileage may vary here but I
find that it's very rare that
just look at a problem and instantly
know what to do it often helps me to
kind of think through some individual
cases and try to spot a pattern but then
everyone has a different strategy so
that lovely what do you think I think
the kind of thing we did in this
topological sort problem what we did was
we try to represent the input in a
different way we represented the
dependencies as a graph so the first
thing is to strip down from the problem
the nitty-gritties and try to make a
make it a general form of it so for
example you can you can summarize the
problem in one sentence you can say that
given a directed acyclic graph find the
longest path through so once you get
down to the bare bones of the problem
then you can probably go ahead with your
standard techniques that you know of
basically some dynamic programming
really algorithms and once you explore a
certain parts of exploring of solving
the problem you need to prove some
things on the way such that you are not
going in Thailand into the wrong
directions and usually what I do is I
don't code before once I finalized and
prove my algorithm and I think that
that's a good strategy
the famous computer scientist Dijkstra
said once like people should write out
their whole code on paper before like
typing anything and this was in the era
when computing resources were more
expensive and you really didn't want to
waste time like writing a program of the
wrong way
I'm not going to advocate that everybody
write everything out on paper like
Dijkstra said but I think this point is
worth thinking of that it can save you a
lot of time to have the idea correct
before you start writing any code
sometimes ok so we have what level of
student is this competition for so
that's something I meant to mention
earlier a bi student like I include
undergraduate so the secondary education
undergraduate but all the way up through
PhD so anybody on that range is welcome
but again even if you're not a student
you're welcome to still participate in
kickstart it's just kind of targeted
specifically towards students and we
have how our top participants determined
after each round so the rank the score
do you want talk about the scoring
system so like for each problem there's
certain points attached to it so for
example for this
all input there might be five points and
for the large data set it might be 10
points so at the end of the contest your
score is summed and then there are
penalties for wrong attempts from the
small data set and that will cost you 20
minutes penalty for ins 4 minutes sorry
yeah four minutes penalty and then for
the number of people four people with
the same school we take this time
penalty in consideration and otherwise
the total score is taken into
consideration so you sometimes make a
strategic decision about whether to go
for the small data set for a problem or
to like maybe like think a little bit
harder and eventually get the large and
we give to the problems point values to
help you make this decision at the end
of the day it's your total number of
points that matters first and then time
penalty will be the tiebreaker so if you
have maybe five minutes left in the
contest and you know how to do one of
the smalls it might be better to just
like bang out the code for that small
and get those eight points or whatever
but if you have an hour left and you're
debating whether to do the smaller the
large you have to think like well you
know how many other people are going to
solve the small if I get one of the
largest it's not going to be a big
advantage you just have to kind of like
pick and choose based on your confidence
level you can solve individual data sets
oh here's a great question our programs
also judged on space complexity so code
jam is a little bit unique right now and
that you're running the code on your own
machine in a lot of other contests like
you'll be given a specific memory limit
and if you go over that memory limit
then your solution will be marked wrong
but since you're running on your own
computer it's kind of up to you to pick
whatever space complexity doesn't like
give you a heap overflow or like
otherwise crash your machine but you're
going to be evaluated pretty much on
whether you're able to create the right
set of answers for your input data set
and you'll never like lose points after
the fact because some of those in your
code and says oh the space complexity
goodness is not great so I would
encourage you to code in a way that
doesn't make your machine hang in the
middle of a contest by trying to create
a list with like 80 billion elements or
something like that but space complexity
is not as important in this contest as
time complexity I would say
we have how do you develop the skills
for finding corner test cases so I'm not
sure if this is asking how we actually
write the corner test cases or how the
competitors are how competitors should
develop them it's pretty similar oh so
like most of it is intuition but there's
there's a trick that I usually employ I
mean I had to employ in countries so for
example you're solving the problem and
you're getting a wrong answer repeatedly
what you can do is look at the
constraints and write a brute force
solution that you know is perfectly
working because the a you are applying
brute force and if your implementation
skills are not that bad you're not going
to make a mistake in the booth for
solution for the you write a generator
which generates all the possible inputs
so of course that'll cover the sample
inputs value and then you can match the
output of your brute force solution with
the solution that you have written so
this technique has been really useful to
me sometimes and but there's no
guarantee that this will work so so I
remember so 40 of the contestants it
didn't work out really well because it's
not always possible that you generate
every possible case so you might have to
think like a problem designer like we do
so we in general I want to create advice
that I think you should follow I do that
all the time when you're competing when
we're designing the small data set we
try to cover every corner case we can
think of we never want to sort of like
trick you by having the small data set
be really easy and then you're like oh
well my same could work for the large
and then you miss some corner case it's
possible that because of the way the
small and large limits are set there
might be phenomena that only emerge in a
large data set that you won't find in
the small the most obvious of these like
which is all true almost every time is
that the large data set has like larger
numbers or more data or something so
your code has to be efficient to run it
what we try to do is we won't have like
a literal so if there's some problem
involving like points on a cube or
something like we won't like only put
corners like in the large data set and
not in the smaller set because that
would be mean and it wouldn't like meet
our goals of you know generally
evaluating customs so yeah this just to
add one thing like if your code is
efficient enough and it's working on the
small data set mostly
you're missing out on some issues that
occur due to large values which is like
integer overflow could be possibly one
of the piece yeah all right so we have
what graph algorithm showing oh that
would help me during the contests um so
in these cutting contests Dijkstra's
algorithm comes up a fair bit definitely
worth knowing I mean that's a nice
classic beautiful algorithm anyway so
it's not your toolbox that one probably
should be and topological sort is
arguably I mean as well it showed it is
arguably graph algorithm a lot of other
graph problems and these might not come
up necessarily as much in kick start but
like it's common to have to do dynamic
programming on a graph so knowing how
the dynamic programming works is really
helpful in programming contests probably
more so than like on the job that that's
a skill that's worth developing for not
only this but technical interviews any
other sort of graph algorithms Oh like
basic algorithms like depth-first search
should sup light spot good start yeah
okay all right how does the difficulty
compared to the global code Jam
competition so yeah it's going to be
mostly like qualification round and
round one type problems not getting into
like round two and I mean in code Jam
it's not like all the round one problems
are the same difficulty but the hardest
kickstart problem is generally going to
be like the hardest round one problem
and sometimes those can be pretty hard I
mean we've seen quite a range at
kickstart like sometimes the very
hardest problem only gets a handful of
solutions but at other times it'll get
hundreds or even more so we try to
provide a range so that there's like at
least one problem wherever it can kind
of like get started and warmed up and
then the difficulty ramps up enough and
just kind of keep going up that hill
until time runs out and we have how long
do rounds usually lasts so they're
always three hours except for that
twelve hour round which is kind of a new
experimental thing for kickstart and
again we'll make sure we post more
details on that as we get closer to that
is there a way to know who is in the
lead similar to other coding
competitions like I mean like the the
scoreboard for instance okay yeah you
can have a look at the scoreboard but
there's no guarantee that someone who
submitted all the solutions is going to
finally get get those correct so but as
a general rule if someone's getting his
small correct and is trying to attempt
the large there's a fair chance they'll
make it so but in kickstart I'd kind of
encourage you not to worry about who's
in the lead because it's not like in
code Jam where like exactly twenty five
people are going to be flown to Dublin
to compete in the finals and if
everybody achieves a certain score
that's sort of above at the cutoff or
above it all of those people in theory
could be eligible for contact by the
recruiter so it might be useful so
there's one exception which is looking
at how many people have solved each
problem can kind of tell you which
problems are more tractable and which
ones might be used yes to work on first
usually this is in the order that we
present them sometimes you know it
doesn't end up that way so that can help
you pick and choose what to work on but
again don't the time spent looking at
the scoreboard and looking at other
people's scores this time you could be
coding up answers to the problems is how
I like to think of it alright so okay
and one last question how do you decide
which algorithm is best to implement
solve a problem the one which gets you
the accepted thank you for the what you
can take a factor is the complexity of
implementation I mean I'm not all know
the time complexity but the complexity
of implementation on your part so for
example you're trying to solve a
geometry problem and sometimes you might
want to go just deal with all the
variables and doubles floating point in
tedious but how if you're implementing
it to maintaining all the geometric
coordinates as integers that that might
help with the complexity of
implementation sometimes and I will say
like it's okay to come in with
algorithms that you've pre-written
yourself like you might have like a
Dijkstra's like function written up
before the contest you shouldn't feel
any undue pressure to come in with a
giant library of pre coded stuff because
as I said there's a lot of a lot of
problems where you have to have an
original insight and you're writing
original code but you're welcome to do
that
if it helps you prepare better so I
think that's about it thanks for tuning
in and don't forget to register at a gos
lat
code Jam kickstart all one word and you
can look at RFA hues or our terms and
conditions or you can reach out to code
Jam kickstart at Google calm
so thanks a lot for joining us</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>