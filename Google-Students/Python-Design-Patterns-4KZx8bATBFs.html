<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Python Design Patterns | Coder Coacher - Coaching Coders</title><meta content="Python Design Patterns - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Students/">Google Students</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Python Design Patterns</b></h2><h5 class="post__date">2008-06-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/4KZx8bATBFs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'd like to introduce author and Googler
Alex Martelli and he will be telling us
all about Python design patterns thank
you very much thank you everybody
actually I'll be telling you about half
or two or one third of it depending
because this is just the first part of a
talk that will need to be split into two
or three parts depending on some issues
so let's say that every for every
argument we can roughly classify how
much we already understand about it how
much study and practice we have to level
hardly heard about it haven't even heard
about it or just barely of level zero of
journeymen sorry uh print wise
apprentice is like I've started don't
really know much yet but I'm stating
started a journey man or master so how
many of you would say about Python I
hardly heard about it okay how many
consider yourselves apprentices how many
journeyman mm-hmm how many masters of
Python okay now same question about
design patterns I've hardly heard about
them of apprentice just getting started
okay journeyman masculine pretty well
master could teach about those things
okay so we have just about the right
level of audience I think we can split
it into by compressing about three hours
of materials into two hours worth of
presentation this is roughly how this is
structured
they show Hari traditional levels more
or less correspond to apprentice
journeyman master although there are
other implications there I aim for
pretty low to medium level for design
patterns not really giving any
absolutely revolutionary insight there
and somewhat higher than that about
Python
I don't really teach any of the basics
give some insight but roughly this is
the number of slides I have on each
subjects were full item really countless
about 90 so we'll try to cover about
half of it that is basically all the way
to structural patterns this time and in
the second part focus on behavioral
patterns QA besides the end of the talk
are welcome anytime but of course I may
be just about to answer whatever
question you're thinking of in the next
slide or so so please try to wait a
second before asking just to see if I
I'm already going to answer it so
patterns what's patterns you know unless
you're hardly ever about it that the
very concept was born about 30 years ago
in the words of architect and
philosopher Christopher Alexander
basically thinking about buildings and
towns places where people live and work
they're made of entities he decided to
call patterns and by looking at things
in terms of languages of patterns
interacting with each other the
different details can be subsumed in a
grander view he also has this much more
for from third book a pattern language
very verbose but very important quote
every pattern describes a problem which
occurs often and the core of the
solution to the problem in such a style
that if you really understand in applied
we can apply the same solution without
ever doing things the same way twice
that is the essence of patterns in the
most general sense possible crucial
issue which Alexandra stresses only a
thousand times in his books and his
followers maybe five and another five
hundred in the software box is that
design is not independent of technology
patterns are not a design concept in the
sense of being implemented in dependent
from the technology to be chosen in
implementation if you're going to build
in bricks or wood or concrete
some things remain the same but many
important things changes you don't
exactly use the same patterns similarly
to quote Gamma tau from the foundational
book of design patterns as a software
discipline point of view affects your
own interpretation of what counts as a
pattern in charge of programming
language is important because it changes
the point of view that's why I titled
this talk design pattern for Python
because I'm specifically addressing this
point of view in my talk more generally
design patterns are thrived particularly
in within object-oriented development
for no particular reason I mean they
could apply just as well to assembly
level programming or or functional
programming that I guess object-oriented
is the mainstream nowadays mostly thanks
to that wonderful book which I was
holding a second ago into that
incredible sequence of conferences and
proceedings and online debate and
constructive criticism that is a pattern
language of programming series slash
community they were so hyped than
there's such a nice name that three or
four years ago I was starting to get
really worried that they'd be swept away
as a fad or fashion as so many other
good and not-so-good ideas in software
have been because people are always
looking for a silver bullet well not as
we know there isn't one but a lot of
other people and fortunately the concept
does matured and I think we're past the
danger of being swept away by hype and I
keep repeating they're not independent
from programming languages so what are
they traditional design patterns applied
to software they're not something like
data structures or algorithms on the
simple and so I the linkedlist
or a quicksort is not a design pattern
they're not even domain-specific
architecture for entire subsystems
something that's too big and abstract so
for example
HTTP sessions built on top of cookies
that's not a design pattern that's too
specific off the field of building
session building sessions on top of a
non session oriented protocol so
somewhere in the middle between the
low-level things and in the
domain-specific more complicated things
that's where we have the patterns to
quote the Ganga four again descriptions
of communicating objects in classes
that's because we are in the OR domain
we would say communicating functions and
I are hoarders functions if we were
talking about functional programming
customized to solve a general design
problem in a particular context
sometimes we're talking mostly about
classes but far more often we're talking
about how the objects relate and the
purpose of the pattern is a very generic
description or category
what is this pattern all about and
you're supposed to do a very formal
right half of a design pattern I'm
focusing on two really important aspect
the name of the pattern is absolutely
crucial because if you don't name things
they don't stay well in your memory and
the known uses which I will be coding at
every step and also referred to as K use
are absolutely crucial if you cannot
quote at least three examples from
disparate pieces of software it's not a
design pattern that's absolutely crucial
in both Alexandra's conception the gangs
of four you don't invent a design
pattern you discover it in nature so to
speak you discover it in the state of
the art of practitioners in the field
and then there's all sort of formalized
terminology such as forces which forces
meaning constraints and desires
thus pattern soles and so on but they
complete schema is hardly ever
appropriate it depends on what audience
if you want to go present at PLO P then
by all means do a completely for
all right up but if you're talking about
the typical in front of the whiteboard
design discussion with colleagues then
something more simple a little bit more
of course than just the name and no
users but say the results are rational
or context and problem are reasonably
important but you do need to use a whole
complex approach so there's a plenty of
books which I would recommend depending
on exactly what you're going to most
importantly I would not repeat not
recommend the original book to anybody
except people at real level if you
already know all there is to know about
design pattern that is the time to read
this book is definitely not an
introductory I would not recommend
pattern hatching to anybody except those
who have already read throughout design
patterns critiqued it and have
particularly and are able to argue
convincingly as to why this is right but
that was wrong because this is basically
what Reseda does here I would not
recommend this one to anybody who's
already married because it could put
your marriage in danger in danger but
although otherwise it's quite a cool
book very funniest as you can expect
seriously the best introductory
introductory books are essentially those
two shallow am trot for very formal
classroom like and head first for if you
like thinking visually and and with a
bit of disorder very creatively this is
extremely this is Bob Martin extremely
recommended because he the only really
good book that merges design patterns is
in what comes out of your design with
methodologies what goes into your design
how how do you proceed with that and a
few others up this is of course strictly
if you are in a C++ shop where you are
actually allowed to use all of C++
otherwise you'll feel very frustrated
okay um so as Alfred Brown and Wolff in
one of the books I recommend have
already pointed out extremely clearly
I'm just summarizing their arguments
many classic design patterns are
workaround for the existence of static
typing so they wrote this voltage motor
companion about half of the gang go
forward very strong small tech
programmers but they basically took
their small talk hats off when they
wrote the book and accepted static
typing as a way of life its need not be
so it's not in small talk it's not in
Python is not in many other languages so
basically forget all the static typing
constraints if you're going to program
small talk or Python and vice versa
there are specific strengths of the
languages you're using with such as the
dynamic abilities introspection and so
on which you may really want to
capitalize on and I keep focusing on
names as important which is why I keep
using the classic names even when things
appear very different in Python some
patterns simply disappear because they
get incorporated into standard libraries
and in languages
typical example is iterator modern
languages have iterator built in or in
the standard library so the I traitor
pattern which covers quite an important
role in the original book absolutely has
no reason to exist as a pattern any more
than you would consider it a pattern of
subroutine call if you are programming
binary machine code knowing there is a
pattern called subroutine call whereby
you push the return address somewhere
before you jump to somewhere else would
be crucial but your language offers
calling to subroutine as a built-in
feature of the language it's not a
pattern anymore same goes for iterator
so the categories of purpose of DPS in
the traditional framing which I'm
strictly following would be creational
structural behavioral the creational
ones are the ones concerned with
instantiation of object the structural
one deal with mutual composition of
classes and objects you can imagine
something that exists in a certain way
and the behavioral one deal with the
interaction of course there's a few
creational patterns a bit more
structural one in an enormous sea of
behavioral ones because the number of
the
pretty important interactions is much
higher than the number of possible
structural relationship which in turn
swamps the number of creational things
so I hope to cover today some of the
patterns in these first two and leave a
behavioural stuff for the second part
something that holds no matter where no
matter what language no matter what else
as long as you're doing object-oriented
design patterns at least two absolutely
crucial ideas which pervade the book
pervade the design pattern thinking
program to an interface not an
implementation this is also a great idea
to do if you're doing machine code not
just in all 300 programming how careful
you have to do you have to be to do that
depends on your language as well in
Python it's generally automatic unless
you take real trouble to do things wrong
you are doing things right you are
implicitly using duck typing which is
the extreme form of programming to an
interface in other languages you have to
be more bit more careful about it not
all that much and favor object
composition of a class inheritance so an
object-oriented programming was first
introduced in arrogance was basically
seen as essentially synonym with
object-oriented programming you had to
do everything by inheritance it took
decades I would say to basically find
out all the ways in which this is not a
good idea and wean ourselves
collectively speaking from our use of
inheritance in favor of more flexible
mechanisms for composition I still
remember the first time I read a book on
C++ style which told me it's wrong to
inherit a car from engine why it's so
handy yes well a car is not an engine a
car has an engine and so on and so forth
that was over 20 years ago but it's
taken the industry collectively almost
as much but most of us still probably
tend to inherit too much unless we sit
and think about it because inheritance
is so handy
and the cost are not obvious until you
have progressed a bit with your design
so inherit only when it's convenient I
know that's kind of more of a pragmatic
I know they party line is supposed to be
inherit only when you can assert a risk
of invariance and is a well I think you
cannot ever assert is a I think as
Korzybski put it they is of identity is
the most widespread error in thinking
and perceiving the world so you can
never assert is if you want to be really
fanatic about it at least not if you're
into Korzybski Wittgenstein and others
of my favorite thinkers on the other
hand checking that it's really
convenient yes you want to expose all
methods that are in the base you want to
do a lot of reuse a little override and
maybe extend a little bit and you are
perfectly fine with being so tightly
coupled with the class your inheriting
from that you will never entangle the
coupling then if all of this holds then
it's right otherwise go for hold or wrap
hold and wrap in the case of Python our
subtle distinction I insist on doing it
like this kids are holding the Python as
you can see which is much safer than
having the Python wrapped around you but
that depends on how big is the Python
this one is particularly large up so by
hold I mean an object as a certain sub
object is an attribute and everybody
including the object itself an external
client know that and call owed or a stop
some method it's simple it's direct is
immediate the problem is the coupling is
very strong it's all wrong
you're exposing the detail that always
implemented by by having an S and what
methods s needs to have to all and
sundry
the wrapping is a hole by private name
or most often by private name and the
delegation so everybody else calls Oh
doc method as opposed to odor test of
method you can do that explicitly like
in every language by defining method to
call self as method or you can do it
automatically it will get after we'll
see a few examples later because it's
such a commonplace an idiom the point is
you get the coupling right read up on
the load the meter is not particularly
Python specific but it's a very simple
simplified guideline to good
object-oriented design never have more
than one dot if you're saying Oh dot s
dot method you have two dots and you
know something is wrong now that's it is
oversimplified but it's a handy rule of
thumb so this is an example of wrapping
with being much more appropriate and
inheritance because inheritance cannot
restrict the if you inherit you first of
all among other things commit to
exposing every single method in public
attribute of your base class so what if
you want to do own but a few well you
can do that by wrapping to restrict so
this is an initialization which takes
something to wrap and a set of things of
names to block and records it and then
whenever you try to get any attribute on
this object to with a certain name if
the name is among the blocked ones then
an attribute error is raised you claim
it's not there otherwise you delegate to
the wrapped object incidentally if the
wrapped object itself doesn't have this
acted with either they will raise they
will raise the attribute error we just
propagate it but perfectly fine so this
isn't exactly a pattern but it's a
typical example of idiomatic use of get
a true in Python okay creational
patterns they don't really play all that
much of our own in Python although yes
decorator I have decorator later and I
wouldn't really claim it is because it's
removing something as opposed to adding
something decorator normally have
something this removes something so yeah
I guess it's very very close to
decorator but I deal with it here
because of the removal aspects so it's
important to have thought a little bit
about creational patterns even though
they don't really play that much of a
role in Python I've always wondered why
don't they why are they so crucial in
other languages well I would guess it is
mostly because as we'll see the factory
concept is essentially built in Python
you don't have to do something different
to call a generic factory function
versus instantiating a specific class so
it comes very handy but being aware of
it is not a bad idea anyway
so I'm dealing with two sub categories
of creational patterns one is we want
just one instance to exist the note I
this in this case I start by stating the
problem rather than any solution because
or problem or context or forces were
solving we only want one instance of
something to exist normally in
object-oriented programming you make a
class and then instantiate it as many
times as needed sometimes you think
right wrong that you only want it
instantiated once rarely exactly three
times or something like that
so let's stick with once the solution
for about 99% of the cases in Python is
don't use a class use a module the main
thing about class is being able to
instantiate in them repeatedly just use
a module in that module will have
intrinsically just one instance if you
if that module gets imported from
several places as you know Python
internally make sure only one instance
of the module is used there are some
problems with that modules don't support
sub classing so you can't
do any tweak modules don't support
special methods so you can't use for
example arithmetic operators you can do
pluses x / which are sometimes nice to
have second approach is just make one is
you only want one instance well make one
instance and use it that's it what you
need to enforce the existence of just
one instance it this works for another
99% of the case is not covered by the
first 99% the only real issue with it is
that you have to commit to the time when
that instance is made because all the
rest of your software needs to be able
to know there is an instance around and
know what name to access it from or
which means to access it from and then
there's a classic singleton factor which
I call Highlander for reasons I hope are
obvious
the problem with singleton is that
despite the claims in in the Ganga for
book it really doesn't work with
sub-classing very well at all it will
will discuss that essentially well what
we'll see it when when you come to the
Python code which applies any language
and then there's monal state mono state
is the name originally given to it in
bay I think it was in the C++ user
Journal but I call it Borg and the one
problem with it is that we don't hate it
for the reasons is never really
explained to me
okay I'm sorry I didn't connect so that
there can be only one is of course the
Highlander referencing in this thing
which is much better than single stone
the twenty bridge player means the suit
in which I only have one card it is very
handy for doing rafts but it's not
nothing to do the object-oriented
programming so Python has this special
method new which is essentially they
play so where theoretically new
instances of the class get constructed
and this thing guarantees it only
constructs a new instance once and then
keeps returning it why do I claim that
sub classing is a problem well suppose
there's class food that inherits from
singleton and plus bar the Daenerys from
foo now I instantiate foo and then
instantiate bar what now do I still have
one instance of singleton or which
classes it or do I suddenly have to
depends on in this case I made it per
class but this means there's more than
one instance of singleton there is more
than one completely disjoint object on
which a test of is instance will say yes
it is an instance alternatively you can
forbid that you have you can have this
fail but then you are not supporting sub
classing there is really no way to
support sub classing well in singleton
that's they one of the big reason
singleton is totally bankrupt and
although it's most popular design
pattern you can do some quick Google
Trends to find out the names of our
design pattern in ever works in any
language because there is a concept
means you can always subtract something
it doesn't know well at least it was no
way to say this class is not so
classical further but then instances of
the subclass are instances of the model
class and that kind of breaks everything
once again they the quote so Borg is
basically forget about instances who
care about instances as long as they all
share the same state they may as well be
one and you're very happy there is
absolutely no case in which this gives
any problem so in the in mono stay to
you do that is in C++ the original
version you do that by forcing every
method to be static every data member to
be static that unfortunately doesn't
really support inheritance either so
that Robert Martin has a very nice
critique of mono state in singleton in
an essay on his site object mentor but
in in Python you have reasonable control
over the object state so basically you
can set the dictionary where the object
olds all of its states to the shared
state of a class and so you can make as
many objects as you want they will all
be the same except in terms of identity
in terms of everything they will share
the same state any modification in
excess will always go to the same state
and when you want to subclass you just
have in one at one level of the
subclasses to assert this and of course
all descendants until otherwise claimed
have the same shared state so but if
you're doing data overriding which is a
typical Python features not common to
all object-oriented language whereby a
class can override so you see as long as
you access it this way the shared state
is not a static issue of this class
board but an issue of whatever class is
being generated this is the equivalent
of what those multiples calls a class
method I can also has class method so
the other and much more interesting
issue of creational patterns is that we
don't want to commit throughout our code
to instantiating specific classes this
is absolutely crucial because they this
is where the program to an interface and
not to an implementation must offer
breaks down in the real
world people do strive hard to program
to the interface and now they need a new
widget and they do call new widget or
well I think it's new widget in both
Java and C++ and they're in that very
spot they have destroyed their
independence from the active
implementation because their instantiate
in a specific class so this is why this
whole group of creational patterns is so
important because you absolutely need to
approve that from your code they are
essentially two approaches one which I
will not deal in depth that is very well
covered in on and gave you is dependency
injection which basically means your
object never create other objects they
always get whatever they need injected
from the outside this is extremely
wonderful for testing purposes and it
does help a lot avoiding the specific
class problem the problem with
dependency injection per se it doesn't
cover you okay
you don't know how many widgets you'll
need part of your objects work is to
determine that and generate five or
seven or 22 widgets and you don't really
know how many how do you inject those
dependents into the object in the first
place you don't you injector Factory
that is a Factory is something that can
some call level some function more for
example that can create new objects of
whatever class is appropriate the
factory knows or can reuse old ones if
needed they can be methods or variable
by subclasses they can be functions or
other color balls and you can have an
abstract factory class that basically is
a collection of methods for creation of
factory methods consistent with each
other so in Python each and every time
in class is essentially a factory
because you call it it's a callable like
any other you call it like you would
call anything else and this is the most
crucial thing that makes it
interchangeable with any other
call a ball which could be a function or
whatever else internally it may
implement that new met special method we
mentioned which means it can actually do
anything it can do anything in terms of
instantiation it doesn't actually have
to give out new instances and it may be
injected directly since classes are
objects there's no need to have a
boilerplate function to call the class
just pass the class as an argument and
and there you are it can be injected
modules also can be kind of abstract
Factory in a known or way for example of
you never import POSIX or import NT I've
never seen it in Python code anywhere
you import OS and OS is the module which
knows or finds out okay am I on a POSIX
operating system or an entire operating
system and basically subsumes and
generates the single instance of one or
the other as needed if not you cannot
inherit and further refine the idea
which is why classes are more flexible
but sometimes you don't do you don't
really want at least in design terms we
don't really want to have different
implementations of the operating system
interface module depending on which
variant of Windows NT we are on or which
variants of UNIX systems were on
although it might be a better idea this
isn't the way it was designed in the
first place so this is the only no news
I'm going to give for any creation
pattern in Python and it's not really in
the library which kind of underscores
the fact that he not all that used
whenever you call a type
intrinsically it basically starts with a
new method and if the new method
actually returns an instance of the
class it's been asked for then that
instance get initialized so I think
intrinsically does a two-phase
construction
which is a pattern not in the book but
very popular in other real particularly
in in gooeys you often have you don't
really want to initialize the window
object as soon as it's created because
you first need to establish connected in
various in different ways and then all
the initialization must take place so
two-phase construction is the
constructor proper dose hardly anything
and then all the hard work is done in a
separate initialization method it's very
popular in many realm's and Python
basically embodies it internally this
way this is an example of a very highly
generically factory function one which
is able to load any object from any
package in reach you give it the name of
the package and the name of the object
and it does everything else of course it
would be easy to design it with a single
argument which is the dot separated name
and does they split on the last dot but
they just since the role of the package
name and the object name are different I
designed this uses the built-in import
function which basically given a package
a couple of dictionaries to hold context
and possibly a list of object names that
will be needed returns that the module
from the package and then get attribute
can take in particular the name object
from so for example you can dynamically
load of course this doesn't make any
sense because it's absolutely equivalent
to from P 1 P 2 P 3 import C 4 as CLS so
there's a language construct for that
but by using this function you can get
these strings from all sort of places
and do dark magic which is probably not
the best idea to do in production code
but can be very handy for testing as
usual alright so this just about covers
my extremely short coverage of
creational patterns this could be a
great idea for questions because I'm not
going to talk about creational patterns
ever again oh okay and move on to
structural factors I'm actually only
dealing with one subcategory in this
series of talks for now
which I call masquerading an adoption I
mostly do that because finding a nice
side picture for structure is almost
impossible why for masks you can find
pretty cool ones this is my main
motivation not really these five buttons
set up to a facade bridge decorator and
proxy have something in common they're
all about objects that basically take
the place of another or make believe
they are another right okay that's a bit
vague but let's go on case by case
so adapter tweaks an interface at either
class or object level you need to
consider both variants facade simplifies
the subsystems interface bridge allows
you to use many implementations of an
abstract of an abstraction so build many
implementations of an abstraction using
many different implementations of a
certain functionality without having to
repeat it is recoding decorator reuse
and tweaks without inheritance and proxy
the couples access to an object
selection ality from where the object is
whether you're allowed to reach for it
and so on so adapter we have some kind
code gamma that requires a protocol C
protocol is my favorite generic
equivalent of interface IC interface is
something that's purely syntactical all
protocol implies pragmatic constraints
as well supplier code Sigma provides
some different protocol s which
basically has all the C needs but in
different arranged in different ways so
I write some adapter code that sneaks in
the middle between the client and the
supplier it looks like a supplier to the
client it looks like a client to the
supplier and implements protocol C by
making calls to to protocol s so let's
have a toy example very very toy what we
require is a method foo bar the tag
takes a fool in the bar unfortunately
what we are given is a method bar foo
that takes a bar in a fool so how do we
reduce the impedance mismatch with an
adapter for example let's stick to
object-oriented we have a class which
whose method bar-food dates a bar in foo
and oral client code is is called to to
use a different library where the
classes have a method foo bar which
wanted of wina bar this is how we do it
with wrapping delegation so we write the
wrapper which takes the wrappi and saves
it and whenever you call foo bar with
foo and bar it delegates that to barfoo
on the rapi with vari foo it's not
rocket science but it's the tiniest and
yet useful example of adapter that i
could put together and this is how you
instantiate it you pass the existing bar
for as part of the instantiation if you
want to work at a class level you can do
it with inheritance so basically you
delegate to yourself
so a foo bar in this case in Eric's from
a bar floor and abs method foo bar which
calls marshal this isn't necessarily
appropriate because it also you also end
up with a original barfle so this is
maybe faster but it the other approach
the project approach is doesn't cleaner
there are many known uses of adapter in
the Python standard library oh I forgot
to mention that all my known users are
from the Python standard library it's a
large library you can find examples it's
pretty representative of a good Python
code for example a socket can be seen as
a file object it has a underline file
object adapter which basically wraps the
role functionality of socket into the
rich interface of file objects that's
the case of an adapter that actually has
to do a lot of work because sockets are
unbuffered and files are buffered so all
the buffering functionality is hidden
there I don't think that's very
appropriate I would not like to have a
during class outside reuse there but
that's how we coded it don't know if
you're familiar with the doc test which
are very handy fast quick to write with
not quite as proper and nice as the unit
test but if you have a lot of doctors
you can adapt them into unit tests with
this test suite adapter DB hash is
another example of adapter pythons under
library includes a an interface to the
Berkeley standard distribution database
which is an extremely rich and
complicated system sometimes we want to
access it just if it was a good old dbm
kind of file from the early days of UNIX
DB hash gives us that or stringer yo you
have if you have a string and want to
access it at it as if it was a file you
don't have to write it on this which
would be silly you wrapped it in a
string day or shelve basically takes
something that has a very limited subset
of dictionaries essentially forcing
string keys and values and offering just
the very basic methods and make it look
just like a rich dictionary because it
uses speak also it can translate any
object to a string and back and user
user did mix in to add all the other
dictionary functionality so from these
known users and some other looking at
real world code we see that in real life
some adapters require a lot of code not
a bit more than the foo bar bar food
sample I get which is why identified as
a toy example mixing classes are
absolutely a great way to adapt to rich
protocols you can implement advanced
method nice easy things I would exempt
mixing classes from my general dislike
of inheritance I think mixing classes
are the greatest thing since sliced
bread adopters of course on a level of
complexity I can actually imagine
although I don't remember a specific
case where I would code an adapter as
simple as they borrow food to food bar
and death
that's like you can't really get any
simpler than that and on the other hand
at the other end of the spectrum you
really do use it after for such things
as DB Hashem and BSD DB and it's not
just about classes and their instances
in particular we'll see that after a
facade but color balls are are a very
good target for that so a facade occurs
when some supplier code or each
subsystem ideally provides a lot of
complexity a lot of complex and rich
functionality and we need a simple
subset
not necessarily because we've already
written to that simple service just
because we don't want like a bazillion
other users of our code to have to code
to this complicated thing when they only
need the one tenth of the functionality
so basically the facade code is they
find implements and supply the simple
sub subset C by making internal its
goals to s as needed so what's the
difference between a facade and adapter
it's kind of subtle adapter is about
supplying a given protocol required by
client code so you imagine yourself
already having a client so the protocol
you need is fixed or you are designing
the client protocol to be OMA genius so
you can use polymorphism facade on the
other hand is about having this very
rich interface that does a bazillion
things when you know only few is needed
and you want to present them in a very
simple to use way and most often
although this will not come very clearly
across from their own users because they
haven't found any but in real life
facade typically France for many objects
for a complex subsystem full of stuff
while adapter is typically a one on one
relationship so the best way to present
the solder found is in this site which
is extremely controversial if you like
controversy about design patterns and
PHP and my sequel you will find them a
plenty here this is the concept this is
how it would be without facade so I have
my subsystem with a lot of
asses and everybody from the outside is
needing to make calls too many classes
with a facade I take a little extra step
so basically everybody calls the facade
and the facade deals with the complexity
of the of the subsystem so I don't use
many figures here apart from silly
ornamentation but I really like this one
because it shows you the advantage
basically here not you're making the
life of every kind part very complicated
because they need to learn about all
sort of important internal details of
your subsystem and you're making your
future life hell because you will be
constrained forever to keep this complex
interface around because everybody is
making calls on your inside if you do go
to the trouble of opening a facade the
lives of the clients are simpler because
all the things they need are
concentrated in one simplified place and
your life is simpler because the moment
you decide to redo this completely you
only need to make sure you can keep
emulating the facade in your maintenance
is much easier this is far more than the
simpler adapter provides unfortunately
the known users don't really support
that I have not found any real
complicated subsystem with a facade
email as a bit of that the email package
is pretty rich inside but the reason the
for for the signal of the facade is
actually to emulate an older legacy
implementation of email sending so it's
not really the best of examples the
facades around are basically simplifying
adaptors of single objects which is not
exactly the best idea for example in
modeless in chat there's a type FIFO
which for signs for lists it just gives
you push and pop functionality on top of
lists rich functionality you could see
DB hash a society for BSD DB this is
probably the closest we actually get to
a facade I also gave it as an example of
an adapter so I'm cheating but all sets
now sets are built in but they used to
be a facade on top of Dix cubes do a lot
of stuff but one way of frame
name is a facade for a double-ended
queue with a lock because the
thread-safe are also after some facades
do so in real life a son may have
substantial amounts of code the
important thing is to simplify the
interface even if that means you do have
to add a bit more code in sometimes
minor functional additions like handed
method it a personal level of complexity
but it really matters when you're really
dealing with complicated subsystem
otherwise it's kind of gratuitous any
inheritance is never useful since you're
simplifying you're restricting and since
you're restricting inheritance is
useless inheritance always widens
interfaces never restrict them and this
is an example both adopting and
sustaining also works for calico levels
not just in object-oriented cases in
Python columns play a very large role in
Python programming because you can
easily pass them as argument returns as
results so you often need to adapt or
facade them so the Sun still partial
which performs carrying the operation so
the most elementary kind of
simplification you can do on a callable
is stick some of the arguments and in
frontal partials that you do that and
you have decorator syntax they add
something to make it as easy as can be
to apply a higher-order function to wrap
an existing callable closures lexically
nested functions provide for with
extreme directness for the simple needs
you may have in terms of shading and of
course you can always write a class with
a special method call this is by the way
is from a economic fundamentals text it
explains how to compute the worth of
color balls come compared to standard
law what color balls means load loans
that can be repaid in advance with no
penalty so bridge
you have a lot of realizations ro of a
certain obstruction a each of them could
be using any of several implementation
yodel functionality s and you don't want
to code n1 times n2 boilerplate classes
so what you do is make sure the abstract
superclass of over your abstractions
holds a reference to the abstract super
interface of all the possible
implementation and each row has to go
through our to reach F that's the
easiest way I have to bridge this is a
toy example in got it only I wouldn't do
it this way but it's one way to do a
bridge so say we have an abstract parser
and obviously parses does is accept a
scanner object and hold it and then what
opens sorry I skipped that you need to
underscore here and it type out my part
every time it stands for any attribute
it asks the scanner for that attribute
so that is essentially the same idiom I
was using earlier for except it doesn't
do any addition nor any subtraction
either so it's even simpler but the
point is that they any any parser can a
subclass contract parser and whenever
say needs the next token or needs to
push back a token on a push back stack
it doesn't have to worry about what
scanner approach as long as the
interfaces are are closed
it basically calls them in this case on
self it abused that's because I've used
this idiom it could be self if I hadn't
disk editor I would say self dot scanner
dot next token self-taught scanner dog
push back so basically they all get full
of there
so there's several known uses such as
socket servers one of the most complex
we end with a decorator decorator crab
medical which basically is how to search
some semantics to
basically it's kind of like an adapter
except that the incoming and outgoing
interfaces are identical and this is
kind of a complex subject for ten
minutes left I will point out zip file
which basically looks like a file and
wraps a file but inserts dynamically and
transport lis compression and
decompression in the middle our
recursive locks which looked just like
lock but know who is holding them and
and allow the same thread that already
holds them to acquire them again codecs
which basically transform a byte stream
to a byte stream but with some typically
internationalization into positive and
this is the hudsucker proxy by the way
is for access restriction objective
remotely or in persisted forms we have
like we Chris Roxy has to do with
lifetime issue which is a typical use
for proxy we want to be able to access
some object as long as it exists but not
keep it alive just for our purposes for
example for caching that why we regress
exist a shelf which I already gave is
another example also those proxying are
ID Lib remote debugger is a typical
example it lets you insert the bugging
into a remote process by essentially by
proxying for it
ah and this is part one and we do have
seven minutes left for questions and
answers so I hope there are some
otherwise I rushed through the last part
and warrant Lee I was kind of hoping I
could cut this in two parts other than
three which is why I inserted the pose
here any question
yes I gave the URL at the very start but
let me do that again
HTTP WI XIT slash grew underscore pidp
PDF and that is just one big PDF it
covers both the part we've done today
and the part would do sometime in the
future we haven't set a date yet but
Alex you gave great examples library do
you have any good examples from sure
solutely the questions of you get great
examples from the Piper libraries to
have any good examples you know right
from Google codes actually yes now that
I for governments on a day we start at
the DCI we should leave this for I do
have excellent example from third-party
libraries and applications for example
one internal important class of design
patterns which I uncovered at all our
design patterns for a synchronous
communication they're covered very well
for C++ in a couple of book by dr.
Schmidt and they're incorporated inside
the Python library in a very simplified
way known as a sink or a sink chart the
third party package called twisted which
is basically the best implementation
I've ever seen of those patterns barn on
in that includes OAC
which is a great library but twisted is
better so there's plenty of third-party
libraries you could look at important
applications I've never really studied
there but I'm pretty sure you can find a
lot of like take sugar the interface of
the One Laptop Per child its own path
I'm I'm pretty sure they're using a lot
of design patterns an interesting way it
would be a great thing to do a report on
that or big applications written in
Python such as mailman a Chandler jungle
there's so many of them that are open
source so you don't have to have
strained excess other questions
so you've talked a lot about Python
specific design patterns I was curious
as to whether you thought that there are
any I mean you talked more about
generally you talk more about general
design patterns
I was curious as to whether you think
there anything that you've discussed
today that are more relevant in Python
than in other languages I mean you
talked a little bit some that I less
tried to focus my discussion only on
those aspects which are relevant to
fight one yes right but but all of the
design patterns that you've talked about
as far as I could tell could be applied
to today oh come from the right exactly
in the second part I will get into one
design pattern in extreme depth this
part has been more of a survey the
second part will be mostly about not
just behavioral patterns in general but
three of them template method statement
strategy and I really get into the issue
of how introspection and dynamic
approaches served their most of them so
I'm not talking about patterns that only
apply to Python mug ranges in that it
besides that there are languages which
are basically equivalent in power such
as Ruby too pretty would be pretty weird
to have something that only applies to
Python not Ruby or vice versa because it
would have to be some weird syntactic
peculiarities up iterators are different
but the idea rater pattern doesn't apply
to either languages because they both
have AI traitors built-in in different
ways small talk like in the case of Ruby
and much more similar to the Jenga for
design pattern in case of Python but in
other case they're built into the
language so that's not so much a design
pattern anymore in those cases apply
I had a question that I noticed in your
talk when you were working on one of the
patterns where you were wrapping an
object oh it occurred to me that you
were wrapping the object in such a way
that someone that was looking into the
object wouldn't see those methods as
part of the interface you mean for
introspection purposes right and I was
wondering is that's a danger that
language like Python has that you never
run into in C++ and one if you comment
I'm going to do to consider well you you
would you could run it into in C++ C
word if you were doing debugging you
would I you in debugging with some
advanced debugger including a class
browser so you get this object which is
actually proxying you may not actually
be able to tell what it does have or if
you're using dynamic cast or other
advanced aspects of C++ your debugger
depending how smart your debugger is it
may get rather confused if you
specifically want to support interactive
debugging you basically have to add the
old introspection to your wrapper to
make sure it looks to the outside
including a debugger exactly as it would
look in the inside it's a lot of
overhead if unless you're specifically
very interested interacting debugging as
you know I go by the by the motto
debugging sucks testing rocks so I'm
much more interested in supporting
extended testing than in supporting
ascendent debugging when I undo bugging
something I'm going to be aware of the
above the actual issues anyway so for
example suppose I'm debugging something
and I have problems on a proxy that
actually supposed to send the calls out
Australia I'd better know that because
the reason things are misbehaving they
are nothing
with my code and everything to do with
the underground cable through the
Pacific Ocean having just been cut by an
earthquake so trying to have proxies and
other such consoles be totally
transparent it's possibly a misguided
expensive labor given these issues
particularly in case of okay doesn't
work now what well is there actually a
transatlantic cable in the middle you
can't really abstract from that because
it could get cut from an earthquake all
right I think we're out of time actually
okay</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>