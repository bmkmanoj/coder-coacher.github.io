<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Code Jam Kickstart: Info, coding tips, and Q&amp;A | Coder Coacher - Coaching Coders</title><meta content="Code Jam Kickstart: Info, coding tips, and Q&amp;A - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Students/">Google Students</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Code Jam Kickstart: Info, coding tips, and Q&amp;A</b></h2><h5 class="post__date">2017-10-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/WZkTPJE0aRE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so your life thanks a lot for waiting
let's get started
so I am Nishant I'm here with mullet and
Akash and we'll be talking to you about
code Jam kickstart so let me give a
brief summary of what's going to come
will be first talking about what exactly
is code Jam kickstart then we'll follow
it up with some of the previous
questions that have been asked in this
contest and we'll try to teach you how
you can approach those problems and
solve them we will follow it up with
couple of tips and tricks and finally
we'll get to the questions
before we get started let me do a quick
round of introduction so high I am
nishanth red card I've been working with
Google for the past 10 years I've been
active with the competitive programming
community and participating a couple of
contests severe and I'm also actively
involved in setting problems for
kickstart and other contests hosted by
Google I have with me null it yeah hi
everyone I work on days at Google and
I've also been very involved with
creating problems for score Jama and
kickstart and so on and we have Akash
yeah hello
so I'm being part of Google for more
than three years now and I am also
actively involved in problem setting for
code Jam for epic tests and now
Kickstarter we also have with us a
couple of chat moderators I believe you
would have already interacted with them
we have debug a seam on check so let's
get started what is kickstart kickstart
is a code Jam competition for students
you may already be aware of the four
giant platform which is used by Google
for conducting several online contests
one of them being the Google Code Chan
which happens once every year that is
for all students and professionals alike
kickstart is just like the other contest
it's a online contest no gaming contest
which happens throughout the years it
throughout the year it is not a single
now but it has multiple dogs this year
we have completed six rounds and the
seventh one is going
and soon each contest has multiple
algorithmic puzzles and each one of them
is designed by Google engineers so why
participate what is it what is it for
you first and foremost you will get a
glimpse into the programming skills that
are needed for a technical career at
Google we as Googlers are expected to be
good at for Gotham's and data structures
we passed similar problems in this
contest in our interviews and so on
secondly you will get acquainted with
the code Jam competition arena as I
mentioned this is a platform used by
Google to conduct several contests and
another reason would be you make it if
you ace in the contest if you do well if
you are in the top view you may get
contacted by a Google recruiter for a
courier opening at Google and most
importantly according to me is that you
will have fun you will compete with your
friends and test your coding skills
discuss the problems after that all Nall
have a lot of fun so when is kickstart
as already mentioned we have already
completed six rounds of kickstart
seventh one is happening on 22nd October
how many of you know what was kickstart
previously called you may have guessed
it it was called the APAC contest we
change the name to kick-start because we
expanded it beyond the asia-pacific it
is also conducted in the United States
in Australia and so on so go ahead you
still have the seventh round go and
register we have the link for you then
so participating is one thing practicing
and doing well is also quite important
so how do you prepare in this contest we
test your fundamental data structures
and algorithms and you should be well
versed with stacks queues lists and
other such data structures and the basic
algorithms which would include the
sorting algorithms and a few more you
should be well versed with data such as
the graphs trees hash tables why are
they used what's the time complexity of
in
deletion all those things the basics of
data structures you can code in any
language of a choice that is you can
have a preference of coding and Python
feel free to do so you can code in shell
script Ruby anything that you please and
finally we should be good at catching
the bugs that you introduce in your code
you should be able to test your code
debug it well and and submit a correct
solution which works on all edge cases
then let's take a look at the code jump
platform how do you actually submit a
solution the first step is read the
problem come up with a solution and
algorithm and implement the code for it
then you will have two input files
present on the page one would be the
small input set that'll be the large
input set go ahead download the small
input set and run it with your solution
this will generate an output file make
sure you generate an output file from
this that there is a timing time limit
of four minutes for the small input you
generate your solution in that time
submit your output and the source code
on the side if it passes repeat this
step for the last dataset if it fails go
ahead debug your code fix whatever age
cases there might be that you might have
missed out and then try again for the
small input once it passes go for the
last data sector so now let's move on to
the questions but before that for this
particular talk we have fixed a theme we
have big dynamic programming as theme of
the problems that we have picked not all
the problems are conic programming but
it is basically the theme of the contest
so theme of the talk is similar to the
code laptop we had shared previously so
let's move on to the problems I will
hand it over to null it to talk about
the first problem so this is a problem
from kick start round be this here we
have and this is one of the easiest
problems from the contest so you can
follow the link that is present in the
slide so very in very
simple terms this problem says that you
are given an array of n positive
integers and then the problem center
wants you to consider all the non-empty
subsets of this array so and then for
each of the subsets you find the value
but you find the difference between
maximum and the minimum value in the
subset and added to your answer and
eventually you have to output this
answer modulo a prime because there are
a huge number of subsets and this value
put out growth the maximum value that
can be represented in a 64-bit integer
so if you consider the example that is
been specified in the slide we have an
array consisting of three integers and
then we have listed down all the subsets
of this array for each of the subsets we
consider the difference between maximum
value and the minimum value and then we
output now what a very intuitive
approach to any problem is that you
should first of all come up with a
working solution a correct and working
solution don't worry too much about the
complexity and the efficiency so in this
problem a very intuitive solution could
be generating all subsets which would
work for the small input so as as kids
start ingenious we make sure that even
if you are not able to come up with a
very efficient algorithm there are some
points that you can gather on the small
input so how to generate all the subsets
this is a very standard bit why stray
where you can represent each of the
subsets by an integer between 0 and 2
power n minus 1 inclusive in base 2 so
here's the pseudocode for generating all
the subsets so we I trade over I from 0
to 2 power n minus 1 and for each
integer I if J H bit of I is set in base
2 we say that the J element belongs to
the subject so using some bitwise
strings we generate a sub set and then
we work on this subset so in this case
the work we would be doing on a subset
is adding the difference between maximum
and minimum value to a global counter
now this works really well for the small
input but for large input the value of n
is up to 10 power 4 and generating all
subsets for such a huge array is not
possible with the memory and time limit
constraints that we have now comes the
part of making some observations so the
first observation that we should make is
what does a subset contribute to the
answer what are the elements that make a
difference in our answer so for a subset
we are considering only the smallest and
the largest values in it so in a subset
the smallest value contributes minus V
to the answer and the largest value V
prime contributes plus V prime to the
answer moving on so imagine this let's
say we have sorted the array and we
define F of I as number of subsets which
consider of which consists of a I as
this minimum value since there are n
minus I minus 1 values greater than a I
consider that we have sorted the array
we can choose any subset of these n
minus I minus 1 values and add AI to
that subset this will generate all the
subsets which have AI as the minimum
value so we can say that F of I is 2
power n minus I minus 1 because there
are 2 power K possible subsets of an
array of size K similarly we define G of
I as number of subsets in which AI is
the maximum value and by similar logic
we can arrive at a conclusion that G of
AI is equal to 2 power I now we approach
this problem by adding the contribution
of each value to the answer so we wanna
find out what is the contribution of AI
to the answer when it is the minimum
value in the subset which is f of I such
subsets it contributes minus a of 5 so
in that case it's contribution is minus
of F of 5 into
and when it is a maximum value it
contributes G of I into a of five now
for each of the AI we can add their
contribution to the answer and the only
thing that we are left is how to
calculate s of I and G of 5 efficiently
so F of I is basically 2 bar and n minus
I minus 1 which is a power of 2 so a
great hint in this case is that we are
going to need to power I for all I
between 0 to n and that can be
calculated easily using pre-computation
so if you have calculated to power I
minus 1 you can multiply it with 2 to
get 2 power now what are the common
pitfalls that someone can fall into in
solving this problem so two major things
to solve such a problem is to come up
with an algorithm first and then
implementing it so you might some you
might miss some observations and go
towards a cumbersome number theoretical
approach which is certainly correct but
might take up a lot of your time and
there might be a lot of implementation
bugs if there it's a complicated
approach even for the simple approach
it's very easy to make some
implementation mistakes in which you you
have integer overflow let's say you are
not covering all the corner cases so for
languages like Python which have big
number i briefed the these kind of
mistake would not occur but contestants
who are working with language like Java
and C++ should take care of these things
so before we move on to the next
question we have a question from homonym
she says please explain the pseudocode
again let's go back to the pseudocode
yeah so as we said that every subset can
be represented by an integer between 0
to 2 power n minus 1 and I've used some
of the bitwise operators so one less
than less than n basically says bitwise
less
ship one by n times which basically
generates to power n now for each I we
are going to do some computation to
generate a subset using this value I
what we have built a convention is that
if the J's bit of I in base 2 is said
basically it's a value 1 then n value
that then JH value belongs to the subset
so I I trade over j from 0 to n minus 1
and then for each j i check whether the
transmitted in i is set or not that i am
doing in line number seven I raise one
to so I basically take bitwise or of I
and 2 power J and as you you should
observe that 2 power J is basically 12 J
has the chance bit set that's it and all
other bits are 0 and if you take bitwise
or with I you will get a positive value
if IH bit I also has the J etcetera so
if that is the case then we added to our
subjective hope that explains ok let's
move on to the next problem
yeah finally we are on to our theme
which is dynamic programming and dynamic
programming is one of the favorite topic
of problem setters in various contests
like code jam and kickstart and it's a
very interesting philosophy as well so
in this problem weakly is in a party
where there are infinite cakes and each
cake is a square shape so we have
infinite supply of cakes with side 1 2 3
and so on
now weekly aims to eat cake such that
the total area of cakes he is gonna eat
is n and is given to you in the input
and Vicki wants to do sir to do such a
thing by eating minimum number of kids
minimum number of distinct gates
basically for example let's say Wheatley
wants to eat total area of size 4 so
either he can eat four cakes each of
side 1 in which case the area of each
cake is 1
or he can just eat a single cake of
sight - which is a young food and this
is a better solution in which case he
just has to eat one cake now like it any
other dynamic programming problem we
should observe that n is expressed as
some smaller numbers so we should try to
break down the problem into smaller
subproblems so let's say I define f of n
as the solution for n so f of n is
defined as the minimum number of squares
in which it can be expressed as a sum
off now let's assume that wheatley is
going to eat a cake of size k note that
there are various possible values of K
that can be chosen if he has chosen k
then his job or P is left with is he has
to eat an area of N minus K square and
this forms the basis for our dynamic
programming solution so we say that to
find f of n UI trait our different
values of K in line number 4 as you can
observe and then you calculate the
answer for the remaining part so in line
number 6 we are saying that this one
cake we have already eaten which is
offside K and now we are left with a job
to eat total area of size n minus K
square we do this for all possible case
and take the minimum of them and return
the answer can you observe how many
different values can K take note that
there is a condition in line number 5
which says when we stop so we saw when K
square exceeds n because Weekly doesn't
have a capacity of more than n there is
no reason of considering K as one of the
possible constituents of the answer and
the final step in solving in coming up
with the problem is to calculate how
efficient that solution is so as you
might remember in the code lab we have
we had mentioned a technique of
calculating the complexity which
basically says the total complexity is
the total number of different steps in
dynamic programming solution so in this
case which is order of n because f of I
can where I can go from 0 to n and the
there is a certain cost of transition
which is basically the different values
of K that we are considering for a given
n now we have for a given n we are
considering at most root n values of K
and then due to this we can say that the
complexity of our solution is n into
square root of n there is an alternative
solution using Lagrange's theorem which
says that every positive number can be
expressed as a sum of at most four
different perfect squares so our answer
can never exceed 4 by this theorem I
won't go into the details of the proof
but assuming this is true the our only
job is to express n as sum of K
different squares where K doesn't exceed
4 so we just have to iterate over
possible different values of first K
minus 1 squares so let's say they have a
1 a 2 a of K minus 1 then we can make an
assertion whether whether a certain
solution is valid by checking whether n
minus summation AI is a perfect square
or not and again this works in n root n
because AI can have an at most the
maximum value of AI can be rooted and K
does not exceed 3 ok so before moving on
to the next problem
let's take one question by suji he says
can you guarantee that if I master
object-oriented programming course will
I be able to solve the problems the only
thing that I can say is if you practice
solving these problems then you will be
able to solve this problems I don't see
that musting any theories made the
object-oriented programming it's anime
programming maybe any other theory in
algorithms will you'll be able to solve
this problem
the only way is by practicing more and
more problems
one of the hardest part of solving a
problem is the first part that you
analytically come up with some
interesting observations you
might have noticed in the first two
problems that we have mentioned some key
observations but those are are not
covered in the theory of computer
science so they are not covered in
object-oriented programming first those
will come naturally only when you have
solved a lot of problems similar
problems and that is when you would be
able to solve a similar problem like
this okay so yes so before moving ok so
for the next problem I will invite Akash
who will talk about an interesting
problem Thank You Lilith and mission for
explaining soul well yeah so this is a
little tricky one so first I will try to
explain the problem and then I will help
you in building the solution what steps
you can take in coming up to the dynamic
programming solution this might look
look little tricky as of course it's one
of the hardest problems in that
particular round
it's from round B problem C named as
Christmas tree
so the problem goes as follows you are
asked to find the maximum number of
cells in a Christmas tree of given
height K now the Christmas tree is
defined as a fight K is defined as that
such that it contains K different
triangles on top of each other now what
is a triangle a triangle in this
particular problem is an isosceles
triangle which contains the symbol
hashes in this in the following manner
that we shown in this particular image
so if we see here we shown two different
triangles in these images the first one
is of height 2 so this triangle height
is different from height of the
Christmas tree itself so you can see
that the the triangle in the figure
second the larger one is of height three
so similarly we have a triangle of
height one which contains only a single
hash character so in going forward we
will define a valid triangle that will
only contain the hashes characters in in
triangle to the right so now in this
figure we are showing a Christmas tree
so the tree is defined as if it is if
there are multiple triangles connected
to each other it can be only one
triangle itself that is also a tree so
in this particular case in this figure
we are showing that the two triangles
from the previous slide are connected to
each other so this forms a tree so now
you can see that from this particular
figure it's not necessarily that the
lower triangle should be in the middle
of the upper one but it can be connected
to it anywhere in the base so there are
three different possibilities of
connecting the lower triangle to the
upper one to its base as the base size
of the upper triangle is three now how
do we solve it so is like any
traditional dynamic programming problem
you first need a state state to
represent the problem characteristics so
in this particular case we have three as
our focus in which we need to find the
maximum number of hashes in a given tree
of height K so in the input itself you
are given the grid in which that tree
can be represented apart from that you
are given K itself K means the total
number of triangles that can be present
in a tree now with those number of
triangles you need to find the total the
max number of hashes characters that can
be present in that ring okay so now that
tree let's try to define a state which
represents a tree so the there are
multiple choices for that one of the
choices can be we can define the
lowermost base triangle for that tree
then we can just put one more triangles
on top of it or we can do it in the
reverse way we can define the topmost
point of the tree and the number of
triangles that are present in that tree
so the number of triangles is basically
the height of the tree so if we define
in this way we can say that f of X comma
Y comma K where XY is the top most point
of the tree
XY is the basically the cell number in
the grid from where that
particular tree starts so if that XY is
the stock more starting point and K is
the number of total number of triangles
that are present in that tree then F X Y
K represents the max max number of hash
characters in that tree and this is
exactly what we want to compute let's a
we computed F X Y K for every X Y K in
the strip then we just need to output
the max of all the possible values okay
let's try to break this into smaller
subsets what can we do the first thing
that comes to our mind is we can just
fix the topmost triangle of some height
we can say that the topmost triangle is
of height H then after that we can
recursively solve the subproblems
because if we fix the topmost triangle
the below tree will also follow the same
properties of the bigger tree so if we
remove the topmost triangle then it is
still a tree but the height will be
reduced to K minus 1 because there are K
minus 1 triangles now
so if we have topmost triangle of height
H and we computed the maximum value of
edge as like the size of the grid we can
we'll start iterating from one to the
max size of the grid for H now let's say
we fix that height but we can let's say
we know that maximum height we pre
computed that height sum up currently I
am leaving that to you guys you can try
that later yeah let's move on to the
next one so the key things to observe in
a triangle are let's see if the height
of the triangle is H then what is the
size of the base it's increasing by 2
every after every level so the level one
triangle the size of the base is one for
level two it's three as you can see from
the previous speakers but the size of
the triangle of height H will be 2h
minus 1 now what will be the total
number of cells in that particular
triangle so that will be
to the summation of 1 plus 3 to H minus
1 so that is equal to X square so we'll
use this property now we want to compute
F X Y K and we just said that we are
fixing the topmost triangle and its
height is H now what let's say we remove
this triangle and then we are just
solving the subparts for the trees that
are attached to this particular triangle
so where are those will be attached so
those will then those trees will start
from row number X plus h and then
y-coordinate will vary from the
coordinates of the base of the topmost
triangle so it will start from y minus h
plus 1 and the height of those trees
will be K minus 1 because we already
removed one triangle from the initial
bigger tree so we will check for the
answers for all those trees and come
take the maximum of those and add the H
square value which is the total number
of trying hash characters in a topmost
angle so that will give us the solution
I know it's it might be little tricky
you can revisit it later
but yeah this is the way so this
particular slide is missing one H square
term that will be added to this
expression because edge square is the
number of total hash characters in the
topmost triangle that we just removed
from the bigger now what now we will try
to analyze the time complexity of this
solution but as we explained in code lab
as well the time complexity of a dynamic
programming solution can be computed as
the total number of states multiplied by
the total cost for computing a single
state now in this particular case if you
ask what is the total number of states
present in this particular thing it will
be the total size of the grid multiplied
by the total number of triangles
possible so everything is given in the
input so the total state
a number of rows medical ID number of
columns medical ID number of triangles
now the now we need to compute the cost
associated to calculate each state so
that will be we will iterate on the
height of the topmost triangle we will
iterate over its base to compute the
maximum of the values that are present
in the tree is beside it so that we give
the cost the total cost to compute that
will be and cross and for a single state
this is the worst case but it will be
equivalent to this so if you multiply
these more terms then we will get the
final complexity that is equal to n
square n square times K so if you look
at the constraints present in this
particular problem so n m and K all can
go up 200 so if you multiply these then
it will be roughly around 10 power 10
supercomputer or 7 daily usage computers
are generally fast enough to compute
around 10 over 9 iterations per second
or maybe little more than that so if you
see it will not take much time but there
are hundred test cases as well so that
will be roughly around 100 seconds or
maybe 150 seconds to compute if there
are all worst cases in that particular
test file so that is ok but may not be
fast enough if you are using a slow
computer or if your code is not well
optimized and there are lots of constant
factors involved in that so to do that
we have one optimization that we can do
in this particular case so you go back
to that previous expression we are
computing a maximum of certain
expressions so if you observe that those
all the all expressions are part of a
single array and can be seen as a sub
array of that particular array so there
will be total total number of rows
multiplied by the total number of
triangles that can be present in a tree
that many number of arrays and in every
a we need a maximum of some sub F so
that you can easily pre compute so you
can also try this
problem later so this pre-computation
can also be done in n square M square so
if you do that pre-computation then the
maximum that expression that we have for
maximum can be computed in 100 is the
notation to denote the time complexities
so if you use that fact then the time
compressed complexity can be reduced to
n n square time scale which is
definitely fast enough and your poor
will she only work in under 5 seconds
for sure I hope I am able to explain it
but if you not then the main motto to
explain this tricky problem is to show
you how to build up a solution step by
step there might be different things for
different problems but the traditional
dynamic programming goes in this fluid
only so most of the problems will be
tackled in this way ok thanks a lot
Akash before moving on let's take
another question
so Amol says a small query regarding
language used for computer coding it
occurred to me that scanning input using
Java is slow should C++ be preferred
over other languages for comparative
coding yeah sure so in Java I've seen
that bufferedreader is usually faster
than scanning input and also all the
problems headers usually make sure that
we have at least solution in C++ and
Java because these are the most famous
languages used by the computers also on
various platforms there's a multiplier
that is given to Java so usually Java is
a time limit which is 3x then C++ so I I
would say like C++ and Java are quite
equivalent in terms of efficiency if you
want to save that so for code Jam
kickstart there is an additional
constraint that you have to download to
input file
now if doing good fun was really large
then downloading would also take time so
we consider that and usually the input
files are not large enough so there is
no problem with in putting them in Java
for signals so another
because they are usually small okay
moving on so as we had said earlier we
would talk about some of the nuances of
programming in such a time-based
environment and so for example in a
kickstart round you just have two hours
and you have to come up with an
algorithm and then write a bug-free
solution run it on the input files so
it's very possible that you are going to
make a mistake and it happens a lot of
time so what I want to talk about is how
can we avoid making these mistakes so
one of the major mistakes that newbies
make is the integer overflow which is
basically a sign of not considering all
the corner cases for example you are
writing a code which consists of 100
lines and there's a possibility that you
can make a path in a line and there are
hundreds of possibilities so every line
of code that you write in a programming
context it should be exploring and
thinking at all the times that what are
the common case is what are the
different values this variable can take
do I need to be aware about the integer
overflow am i missing some invariance e
in my for loop and so on also there are
some other things like you need to
optimize your editor and coding speed
based on you can define various macros
and for example also like what I usually
do is I I define a C++ template in which
I can trace variables very easily which
helps me to debug to do printf debugging
very quickly also over the time you can
make a library of your own algorithms
that you can reuse in the programming
contest and also there are some other
slight improvements you can make in your
coding speed with the help of
autocomplete Auto indentation basically
editor features but it depends on
person-to-person I won't say that it
makes a huge difference but if it works
well with you that's great also there
are efficient ways to code basically so
for
you can use references in C++ instead of
referring to a variable again and again
you can define a reference with a
smaller character now so and as you can
see on the left side there are some
macros that have been defined but it
eventually one thing that like many
people ask is do I need to care about
the quality of the code that I write
right in online context like kick start
and I would say that that's not
necessary at all we are not looking at
your code it's a cold hard like
cold-hearted machine which is judging
your coat so you should not worry too
much about the poor quality you need me
you need not comment what you are doing
so we will have a look at those skills
in interviews so ok great thanks a lot
learn it so you still have some time if
there are any questions you can still
ask in the chat and we'll take them so
there is one question by Hemant Kumar in
which way the upcoming contest is
different from the last one I would like
to say it is not different in terms of
the skills required for the theme
specifically of course the problems are
different but the contest in general
would follow a similar pattern a similar
theme as the previous six contests
remember the next contest is on 22nd
October are there any more questions and
I guess this is going to be the last
contest for this year that's right so
this is going to be the last contest for
2017 so if you have not already
participated even if you have go ahead
participate have fun enjoy I mean it's
good to be over top even if it's not it
could be a good learning experience so I
guess we're done with questions so Akash
like any like I would like to know are
there some very memorable contests for
you because there are a lot
recent TopCoder one was probably one of
the number of elements for me because I
achieved the read writing event that was
on my target when I started doing the
programming around five six years back I
was always excited to become to achieve
this landmark and finally I'm able to do
this okay fantastic so there's one more
question by Prashant so on us all the
previous the problem previously and
uploaded a working code I believe you're
talking about the second problem that we
discussed which satisfied the example
dataset and small data set as well but
after uploading the correct solution it
directly showed incorrect so then I mean
it's probably because there is some edge
case which you might have missed one of
the things that we just talked about was
did you consider a possibility of an
integer overflow because usually what
happens in a large data set the
constraints are quite hard so there may
be input of 10 raised to 4 are you sure
you did not do integer overflow if not
you should take a look again at your
code and see if there are similar bugs
like these the edge cases and the large
inputs said can be quite tricky and it
may fail only on the large data set but
not in a small but if you take a good
look at your code you probably would be
able to find it so also I would like to
mention that there is a very famous
trick you can call it trick but let's
say you're you know that your algorithm
is correct but there is some weird bug
in some Colin case that you are not
covering and your solution is working as
small as you said so one of the things
that I've employed in the past is that I
write a brute force solution which
basically I am pretty sure that I'm not
going to create a bug in a brute force
solution and then I generate I randomly
generate some input and then I match the
output between my solution and the brute
force solution the reason this works is
the brute force solution will only work
on the small input and to debug my
solution
I need the small input as well because
if it's too huge I won't know what's
happening so you can employ this method
if
that's a good answer
there's one more question why fuchsia
what are the best resources for learning
for fashion I think oh yeah so the best
way to start doing any competitive
programming or anything related to
interviews or preparing for something
similar so once you should have one
particular goal you should know what you
want to learn so that way your 1/2
problem is solved if you don't know what
to learn then discuss or consult with
you the experience once we who are
already in doing it from here once you
know what to learn then you can search
for the material relative to that there
is no one source for everything so there
are multiple things which are really
good we have multiple communities over
multiple online judges which are fairly
active and can point you to the code
editorial a good resource for any
particular topic so first thing
important is to what you want to learn
let's say you are we want to learn max
flow now so you should search for its
materials if you don't find any which
are understandable to you so it varies
from person to person also some
editorials and resources are simpler for
one but not for the other then you can
ask others on various forums about the
material that can be more useful for
that particular problem yeah that's the
way yeah essentially if you see then
there are basically two approaches one
is like redford search so you go to the
Kickstarter site start solving previous
problem and then you look into the
analysis that there is some concept that
you don't know so you could you go learn
that concept and then come back and
start solving problems again this is the
BFS F another DFS approaches let's say
you encounter a topic which you don't
know about what you can do is learn
about that solve the problem that you
are trying to solve and at the same time
we dive into some other nuances of that
algorithm so let's say you don't know
about max flow and you encounter a
problem you can search for other
problems
related to max low and then solve five
or ten of them so that would really like
make a concrete and then you would know
you would have a complete understanding
of max - our Zilla Rick
frankly for me I have referred to a lot
of material fun talk further husband
just to leave you into giving you to
give you a starting point you can take a
look at the material available on the
top right Phillips our next question
what about Python is it good in terms of
complexity for the kids start I think
our input sizes are small and we have a
very relaxed time limit you get four
minutes to generate your solution leave
your output file
so for kickstart and code Jam
I think Python works as well as Java or
C++ you would not believe we have we
have seen solutions in Excel and in code
gen hiding that was very interesting so
yeah Python works well make security
asks I wanted to know in what scene are
used you suggest using STL any tips when
you should use a steel always that saves
a lot of time for you even in terms of
coding plus understanding the concepts
of a bigger problem so if you tackle a
bigger problem that is involving high
good data structures and lots of
different computations then using a
scale makes it a lot easier not just not
in just in terms of poor but evenly in
your own understanding because you know
that this particular problem is directly
solved by a Sonisphere the use of STL is
kind of must almost always even if you
are writing code in c now but you want
to learn STL and want to switch to c++ I
would recommend start writing in C++
even without STL so slowly and surely
you will try to develop a habit that you
can understand other C++ code well so
once you do that you
see that people are doing that same
stuff that you you are doing this stuff
in like hundred lines of code but other
people's must be doing it may be doing
it in like 30 40 lines of code using a
scale then you will be fascinated to you
learn that and that way you can improve
in using experience yes certainly
so another thing is like you can look at
other people's code so once you have
written your code we can take a look at
some elegant solutions solutions which
are much smaller in size than you what
additional things that they do more
often than not they would have use some
elegant STM solution which would help
you learn that even faster does human
tasks does wrong attempts effect right
so the scoring on kickstart is first
decided by the score it's not decided by
the number of number of attempts we made
to get to the right solution but if
there is a tie on the score then the the
wrong atoms add a penalty of time which
is used for breaking the ties so it does
affect your I'm certainly but first the
code is to get the right solution
because that leaves your points then
worried about wrong solutions of it in
Europe okay so I guess that is in from
the question spot
we are also done with stock thanks a lot
for attending it was really nice talking
to you guys have fun and best of luck
for the upcoming projects thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>