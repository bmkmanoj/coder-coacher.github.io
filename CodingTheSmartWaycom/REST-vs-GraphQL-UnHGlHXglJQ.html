<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>REST vs. GraphQL | Coder Coacher - Coaching Coders</title><meta content="REST vs. GraphQL - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CodingTheSmartWaycom/">CodingTheSmartWay.com</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>REST vs. GraphQL</b></h2><h5 class="post__date">2018-03-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/UnHGlHXglJQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi guys this is Sebastian again from
coding the smart way comm and today in
this tutorial we are going to take a
look at rest over source graph QL and
this is just a generic comparison so if
you have in the past mainly be working
with rest we will see some of the
shortcomings of a rest based approach
when accessing data in your web
application in your mobile application
and compare it in a very practical way
so we will be doing a lot of examples
here with a graph QL based approach and
see in which way graph QL can help you
to overcome the major shortcomings of of
restful Web Services so also this video
today is sponsored by udemy udemy is a
really great platform for learning new
skills online and if you are taking a
look at the udemy's website you can find
a bunch of really cool courses
so for example you can take a look at
the web development section here and you
will find always a list of top courses
for web developers you will also find a
list with courses which are new and
noteworthy so just take a look here in
that section and I also have a special
recommendation for you if you would like
to start out with reactors that see
modern reactor with a redox cars made by
Stephen grinder a read or read expert
and you can see it here an outstanding
writing for point 7 out of 5 stars and
that's the right cost for you if you
would like to start with react learns of
fundamentals of redux and ya start from
scratch today so take a look at that
course so definitely check it out today
and to get started just click on the
links in the video description and you
will get a site-wide discount
which is valid for all the courses you
can find on udemy and with that let's
start with today's tutorial okay so
let's get started with first a short
introduction so rest and graph GL are
both API design architectures and those
API design architectures are used to
send data over HTTP and used today to
build our web services for all sorts of
data-driven applications and to those
applications can be mobile applications
web applications desktop applications so
whatever you like each application which
is retrieving data over a network is
probably making use of web services and
the rest approach is one of the
approaches which is most common today so
rest C a traditional approach but rest
has some shortcomings especially when it
comes to data driven applications so if
you are requiring a lot of data in your
application with many entities involved
there are shortcomings we will address
those shortcomings in this tutorial we
will take a look at a practical example
which is addressing those shortcomings
and then compared to graph QL where fql
is a new way to think about api's and
graph KL is much more efficient and
flexible for data driven applications
because you can you can query data in
the way you would exactly retrieve the
response so you can combine entities you
can limit the response to only contain
certain fields and so on so ref QL is
the new way and in this tutorial you
will see examples then for graph QL
and in which way those examples are
sewing the shortcomings of rest okay so
let's move on let's focus a little bit
on the limitations of rest so as already
mentioned the first limitation of rest
is that multiple round trips are needed
to fetch related resources so it rests
first of all everything as a resource
and you can only request one resource
per query so if we are talking maybe
about posts and/or related commands you
need one service call to retrieve the
posts and then another service called to
retrieve the related commands and this
is of course them ending in sending
multiple queries to the server and this
is this is exactly what is described
with multiple round trips another
shortcoming is the issue of over
fetching under fetching there is no way
to limit the response they only contain
a subset of fields so for example if you
post entity has a lot of fields and you
will only have to get back the title
information of the post that is not
possible with rest and you will always
get back for a specific post entry all
the fields which are available so here
again you can see the issue described
you have for example a front-end
application away ball and the first
request to the rest based web service
you are making an HTTP GET request to
retrieve the post with ID 1 so this
request is being sent to an endpoint
slash post
slash 1 and then we need a second
request because we would like to have
the post answer which is a label by
using the user and T here or the user
endpoint and then another HTTP GET
request has to go to slash user slash
one if one is the ID of the post author
so T requests two times we were getting
back the data and then our front end
occasion is the place where we then
combine both data and making sure that
everything is displayed correctly so to
understand this a little bit better
let's try out a practical rest example
in the next step so to be able to try
out a practical rest example we of
course need a rest-based web service
which is a Weibull for testing and a
service which can be used for exactly
that purpose is Jason placeholder which
is available at HTTP Jason placeholder
dot type ecoute comm and this service is
offering if I scroll a little bit down
those lists of resources and those are
endpoints so we can use that URL
extended by the endpoint for example
slash posts to retrieve a list of
hundred post items and you can see it
here we can also use or extend the posts
and point with slash 1 or slash to or
any number which is a Weibull to
retrieve a specific post for a certain
ID so we will use that service to try it
out because this is making it very easy
we do not need to implement the rest web
service on our own we can just make use
of Zee service and to send HTTP get
request to Jason placeholder we will use
a tool which is called postman and
postman you can it's free you can get it
here at get postman and calm
it's a Weibull for all the major
operating systems and the free version
is sufficient for trying out the
examples we will do in the next steps so
I have already downloaded the postman
app and installed it here on my system
so postman as Weibull i'm
in here you can see it here that's the
postman UI and now I can use that tool
to sound get requests to J's in
placeholder so you can see it here I've
already prepared my first get a request
which is going to Jason placeholder
tampico comm / post / 1 to retrieve the
post with ID 1 and I hit on button sent
to send out of the request and then you
can see I'm getting back a response and
the response body is a JSON object
containing the information of user ID ID
title body so you can see it's working
and now we have all the information
available so each post is consisting of
those four properties as mentioned
there's no way that I'm sending a
request to only retrieve one of those
information for example the title I'm
always getting back the full set of data
and that in that case are four data
fields so now I have the information
that the post answer is the user with ID
1 and the user information of course is
not included in that response but if I
now want to have access to that user
information I need to send another
gather request to the server and
retrieve the user information for the
user with ID 1 so this is going then to
you the following URL so it's adjacent
placeholder type a comma comma slash
uses which is another endpoint slash 1
because I would like to retrieve the
user information for a user with ID 1
so let's hit on the button send and you
can see I'm getting back and also the
JSON structure here this time the user
information is comprising much more
fields as you can see here but as
expected I'm getting back for the user
ID
all the information which are able so
for example I have to name the email all
the address information the phone number
the website and even the company
information is included and maybe I'm I
just want to have the user name and the
email address and I'm getting all that
back so I'm over fetching because I'm
getting back more data than my
application is requiring and so that's
the reason why we are talking about rest
limitations so with that example now you
have seen we need to request to actually
retrieve the post with author
information no possibility to limit the
response to only contain data fields
which were actually needed by our
application so I think this is making it
very clear where where we see
shortcomings in rest Web Services
ok now let's turn to graph QL and talk
about the advantages here so graph QL is
not dealing with dedicated resources
instead everything and graph QL can be
regarded as a graph and that's because
that is also making clear by the name
graph QL
so when fetching data you can walk along
the graph and go from one entity to
another entity for example going from
the posts entity to the users empty and
include everything in just one request
and retrieve that connected information
so another advantage here is that the
request is not only containing multiple
entities in just one query the request
is describing what's exactly needed so
you can for every entity involved in
that query you can specify which
information should be returned and you
can see a practical example here on the
right side that elders Geographic ul
query language and you can see it's very
similar to Jason but it's not Jason it's
the graph QL query language what we see
here and we are requesting in the
Excel example a course was ID 888 and
then we would like to have the titles
are description the rating information
here and then we are going to the next
entity which is answer and then Fozzy
also requesting the name and then going
to the causes entity once again to
retrieve for that author of the course
with that specific ID the list of all
courses and containing the title
information for that so that is a way in
which graphically our queries are
written and you can see from from that
simple example that you are much more
flexible and requesting data than
compared to what's possible was rest so
let's start with some ref QL examples
and of course to be able to send graph
QL queries we need a graph your own
server which we can use for that purpose
and I'd like to use a server which is
offering the same kind of data so post
and user data as we seen before for our
rest example unfortunately Jason
placeholder is not offering a graph QL
API so we need to implement that
graphical our server on our own but
that's not a big problem because as
there is service which is called Apollo
launch pad which is a Weibull at launch
pad graph qo calm bets in a cloud-based
development environment which combines
on the left side a code editor which can
be used to implement a graphical server
and at the right side on a running
graphical instance which is an
in-browser ide to send a request to that
server so everything in one place so
that makes it very easy to first
implement as a server we do need and
then
send graph QL requests to that server we
need not to set up a local development
environment everything can take place
here in the browser so in the next step
I will be implementing the server if you
would like to skip that set of zat step
and go directly to the section in which
we are explaining graph QL queries you
can do so you can use on the Apollo
launch pad I have prepared which is
already set up with a server we do need
the link is in the in the tutorial
description and if you would like to
implement it from scratch just follow
along that's the next step now so first
of all we need to define the schema
which is attached to our server and this
is done by using the graph QL schema
language and you can see it here a very
simple query schema is already defined
this is just returning a string for the
hello quarry and the string us is
returned by that resolve a function
hello world so if I'm going to execute
it here you can see it's working we are
getting back hello world but that's not
what we want to have so I'm going to
delete that
hello query type here instead we would
like to have a post query type and this
post-career table should be able to to
deal with an ID so we have one parameter
here that's the zrd integer and that's
mandatory and that's returning a post
type so later on we will be defining the
custom post type that's the first query
type and then we have a second crude
type which is needed here that's as a
user query type and again we have our D
parameter here
so and as this is returning a user okay
so let's get rid of that okay so to
query types and now we need to until
define the custom types in our schema as
well so first of all we have the type
post which is built up of the following
properties so we have ID which is in
which which is int then we have user
which is of time user title which is of
type string and the body field which is
of type string again okay if finally we
have the type user and user consists of
to make it as simple of again four
fields we have the ID here which is an
integer then we have the name of the
user which is a string the email address
of the user of type string and the
associated posts which is of type array
of post okay like so so that is what we
need here in the type definition that is
the schemer and the schemer is the first
part we need to configure the graph QL
server here so let's save it so now
before implementing the second part
which is needed to set up the graph ul
server which R&amp;amp;Z resolvers here which
contain the logic to retrieve data based
on this schema definition we of course
need to have data label and to again
make it easy you will
use in-memory data so we will not
connect a database in the backend or
something like that instead I have
already prepared to erase as you can see
here so let's insert those to erase the
first array is the post data array
containing just some sample data sets
for the post entity so you can see it
here with ID 1 2 3 and 4 and then we
have another array available for the
user and T which is called users data
and that array is containing two user
objects with ID name and email address
so that is a data our graph QL service
will be dealing with and to make that
data available for queries we need to
implement now resolver functions and
that is the next step and then we have
everything together we have the
in-memory data we have the schemer
definition and finally Z resolve a
function that is what makes the graph QL
server running in the end so here in the
results object you can already find a
resolver function which is assigned to Z
hello query but we have removed hello
query so we can remove the corresponding
resolve a function here as well and
instead I'm going to add resolver
functions for the post query which
should be named get post and second I'm
adding for the user query a function
which is called get user so of course we
need to implement now both functions get
post and get user so that both functions
are available otherwise we were getting
an error here you can see get post is
not defined that user is not defined we
are going to
change that now okay let's first
implement get post so vara get vara get
post equals function the first parameter
is root which is not used and as a
second is an object from which we can
extract the parameters so we have here
one parameter defined which is ID and by
using that extraction syntax here we can
extract ID and make it away but gas ID
was in our function at the same time so
what we need to return here is from our
past posts data array we are calling the
filter function and to filter we need to
pass in a function and we're using the
error function here like so and within
that filter within that error function
which is passed to the filter method
here we are returning AB data sets if
post our D equals our D and because
filter is giving us back an array we
need to to select the first element of
that array because we expect if we
filter by ID to only get one element
back of course so we're using brackets
here and using the element at position 1
so that's at index is 0 to get the first
element from that array okay like so and
now let's continue with the second
resolve a function which is get user and
it's basically the same so we were
extracting the ID here and then let's
implement a function body here return
user state and now we are using the
second data array here calling again the
filter function passing in an error
function here which is filtering for the
ID so user dot Rd equal ID ID like so
okay that should be working again we
need to select the first element from
that array okay now can see the error
messages gun bills have functions are
defined and are assigned here to my
queries ask resolver functions so he in
the results object we need to add two
more things because now we have defined
the query object here and now we need to
tell our graph QL server how to retrieve
posts for for user and the other way
around how to retrieve for a given post
the user information and that is being
done by adding another property here and
assigning to user an object which is
containing posts and now we can include
an error function here which is
containing the logic how to retrieve for
a user the list of posts and this
function is getting the user here and
then using the filter function here
which is them executed for the posts
data array and selecting everything for
which the user ID value is equal to user
dot ID
okay like so and then the other way
around so for post we need to define the
logic which is then used to retrieve the
user and so if the user field here and
we were assigning the function again an
error function with the logic so the
function takes a parameter the post
which is currently selected then we're
using find users date errors the first
parameter that's the data array and then
we need to find all objects which have
an ID of what is inside post dot user ID
like so okay now you can see two error
messages here filter is not defined find
is not defined that's quite clear
because we need to make sure that both
both functions are imported which has
not been done yet and so let's answer
corresponding import statement on top so
finded filter are imported from an
external library which is called lodash
and the library is available here in a
polar launchpad so we can directly
import from the delay library so it's
very easy to add those functions so
import find and filter from load - okay
so let's save it let's see if the error
message is done and you can see it here
error message has gone filter and find
our label and can be used here in the
logic which is been defined for
retrieving posts for a user and the user
for a specific post so the service
now be ready and it's already running if
you would like to use it in your
external front and application for
example you can use that end point which
is displayed here below to access the
graphical server from your application
for just testing out some curves we can
use the built-in graphical user
interface here and that is what we are
going to do now because that is the
easiest way to just input the some query
code here and try out what we are
getting back from our running server so
let's start simple I'm starting here
with the query keyword and I am able to
give every query a name so let's name it
posts and user and then I'm opening up
curly braces here arm and within that
curly braces I'm now including the exact
query I would like to send and we have
two options here we have defined the
post query MD user query and I'm
starting out with the post query here
and as you remember the post query ills
expecting to get a z ID as a parameter
so I'm setting ID to one to retrieve the
post was ID one okay again I'm opening
up curly braces here and within that
second pair of curly braces I'm
including the list of fields I'd like to
get back for that post so I'm able to
just retrieve the ID and maybe the title
and you can see as I type I'm already
getting the suggestions here so it's
it's like intellisense in your
development environment so I can simply
hit return and it's completing the
suggestion here with the title field and
so let's try it out in the first step
here what we are getting back you can
see zetsu the result and the result else
a JSON object you can see here and the
data property is containing what we have
were requested
post with ID 1 and the title information
included so exactly what has been
requested requested here is a Weibull in
the data property of the returned JSON
object so ok let's say we do not only
want to have ID and title in the
response we also would like to retrieve
the value of the body property so it's
very simple to extend it here with body
and rerun the query once again and now I
can see the answer here is including Rd
title and the body information so very
easy and now we can move on and let's
say but let's further extend it and
let's say we would like to have the user
information so I'm able to type in user
and now user is a different entity and
you can see I am able to include user
here when requesting my post with ID 1
and because it is another entity I'm
able to opening up curly braces who once
again and within that that assert pair
of curly braces yeah I'm able to include
the fields of user which I wanted to
retrieve and the first example here is
let's say we would like to help the name
of the user was which is associated with
post ID 1 let's rerun as a query here
and you can now see I'm getting back
exactly an object which is matching the
structure here of Mercury
I have post ID 1 title information body
information and then the user property
is included which is another object here
and the object is containing a property
of name with the corresponding value so
of course I'm not limited to only
request the name of the user I can
extend the list here to also include is
the ID of that user and the email
address may be then execute it again and
now you can see for the included user
object here I'm getting back
Adie name and email address and now
what's very coolest because we can then
extend it further and for that specific
user request all the posts which belong
to that user so we are starting with
post going to the user and then going
back to posts but not only the post was
ID one all posts belonging to that user
and that is done by by using the posts
property which is defined for user and
then again opening up curly braces here
and including the fields we would like
to get back for each post which is
belonging to that specific user let's
say it's ID and title okay let's rerun
it okay and now you can see we are
getting back here in the result for the
specific user which is assigned to post
of ID one the list of posts away before
that user and in that case here you can
see other list as comprising two posts
the post was ID one of course because
that was our starting point here and a
first post was ID three so that is a
list we are getting back here and of
course we can go one step further for
the little list of post for every entry
we can include in the result the user
information so that I can add user here
and then add another pair of curly
braces and say okay please give me the
user name for each of those posts so
rerun that code here and now you can see
in both cases of course it's the same
name because we started from from just
one user here and then getting the list
of post and then including the user
information again as it should be that's
very clear the same user s seen here so
what we did so far was to make use of
the graph which else behind our graphic
you our server and just to give you a
visual read
intention of that graph you can take a
look at the following picture here here
you can see everything on the graph is
connected so we can start from post ID 1
go on to the user will see Associated ID
to that post and then from there move on
to another post of that user
the post was IDs 3 we saw earlier in
that list and then go back if you would
like so by combining multiple entities
in one query you can walk along the
graph here and the quest entities which
are connected in the way you would like
to do that so so far all the examples we
have executed here in Apollo launch pad
have been started with post ID 1 of
course you we can select any other entry
point in that graph from for example
start was a specific user to request
data so let me do another example here
and let me our name that query users and
posts ok like so and then maybe we start
with a user query and say we would like
to select a user with ID of 2 and then a
request for that specific user the ID
and the name so let's try it out first
so we're getting back the user so now
our entry point is user and then if you
would like of course we can navigate to
posts and say ok for that a specific
user was ID 2 let's print out the list
of posts and for every post include the
title so let's check it and you can see
it's working as expected for that user
we are getting again two results here
with the title information so this
simply means in our data tube posts are
associated with the user was Adi - so
this one Sebastian from
holding the smart way dot comments
thanks very much for watching if you do
like my videos please don't forget to
subscribe to my channel on YouTube
please also don't forget to visit my
website at coding the smart way comm and
I hope very much to see you in one of my
next tutorials so stay tuned bye</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>