<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Java Stack, Heap with Reference and Instance Variables - Imtiaz Ahmad | Coder Coacher - Coaching Coders</title><meta content="Java Stack, Heap with Reference and Instance Variables - Imtiaz Ahmad - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udemy-Tech/">Udemy Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Java Stack, Heap with Reference and Instance Variables - Imtiaz Ahmad</b></h2><h5 class="post__date">2018-05-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Bly-hHvMvvA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi there in this video I want to cover
some important concepts that are
confusing for newcomers in the Java
language when you're first starting out
in Java you may get to a point where you
can program a loop maybe read and write
data from files and if-else statements
and so on but eventually you need to
step out of the baby crib and so to
speak and and involve more classes and
objects to write larger applications and
that could be a challenging leap for a
lot of people because it involves
digging a little deeper and
understanding really what's going on
behind the scenes when a java
application is running so that's exactly
what I'm going to cover here on this
white board and we're gonna go over
concepts like what's an object what's a
class but more importantly where do
these objects come from where do they go
what's the heap what's the stack what is
garbage collection what's application
one time you've got reference variables
instance variables local variables all
of this terminology I'm going to
demystify it here for you in this video
all right so let's start from the very
beginning you open up eclipse or
IntelliJ or whatever editor IDE that you
used to write java code when you open
that and try to create a class write
that class is not going to have any
anything else in it it's just going to
have the keyword class the name of that
class and open and closed brackets okay
with no code it's an empty class when
you hit the Run button in Eclipse or any
editor it's going to complain that Java
interpreter is going to complain it's
going to error out it's gonna say okay
you have this file what do you want to
do with it right because there's no
instructions in there and this is an
important point in Java instructions you
know code needs to be wrapped inside of
named blocks right you could think of
these as methods okay everything in Java
the instructions to the computer on
completing tasks should be inside of
methods okay methods are what do all of
the work in a java application so for
example if I have an empty class with no
methods in there and I try to create a
loop and do some kind of calculation
that's inaccurate Java code it's not
even going to compile okay you can maybe
declare some variables but that's it you
can't do much much more than that so
that's an important point to keep in
mind methods are what do all of the work
so when they when you hit the Run button
what when and the interpreter complains
hey I don't know what to do with this
file it's looking for a particular
method okay and that is called the main
method that's the starting point of
every java application is the main
method okay so i'm gonna write some code
here and you can actually copy it and
paste it into your main method of any
class and running it and it should work
it should work okay so anything I write
on the board here at the code assume
that I'm writing it inside of the body
of the main method okay so let's go back
to when you hit the Run button what
really happens well there are two memory
locations that become reserved for your
java application to run successfully
okay and these are you know resources of
your computer your ram and one of them
one these are you can think of these as
memory areas
reserved for the successful completion
of your application one area is referred
to as a stack and the other memory area
is referred to as the heap so I'll go
over each one of those individually
let's first talk about the stack okay
and I'm gonna draw it out here stack
when you get the one button the first
method invocation is of course main
right that's the starting point so
what's going to happen is a frame is
going to be created all right and you
can just think of these frames as sort
of memory areas inside of this stack
memory area it's further breakdown think
of these as slots and we can say main
here to indicate that this frame belongs
to the main all right so all of the all
of the variables inside of the main
method those are local variables local
to the main method okay
so inside the main method all the code
that I'm going to write here consider
again is in the main method if I create
a variable of type int let's say it's
called age all right
the interpreter is going to go line by
line executing my code okay when it gets
to this this declaration of a variable
what's going to happen is in the main
frame inside of the stack a specific
reservation is going to be made for this
variable okay and that's going to be
called of course age all right so you
can think of this little box as a
reserved place to maintain the data for
the age variable all right now on the
next line I can just assign age any
value for example 12 or some time later
in the program I could change the value
to 15 okay and this particular slot in
the mainframe age it's going to continue
to change right that's where the data
will be maintained all right
so that's really what is referred to as
a local variable okay now let's say we
are past this point and we have another
method invocation inside of main all
right let's say we have some method
called do work all right when it gets to
this line here then do work is going to
be added to the stack okay it's going to
be piled on top of main right do work
and inside the body of this method
wherever this method is defined inside
of the body of the method there may be
local variables there too right it could
be of type integer of string or any
other object type variables will go into
those in a little bit but those
variables are going to have reservations
in this frame in the do work frame okay
so let's say in this do work method
definition there's some variable called
weight okay and that variable is going
to have a special reservation here
inside of the do work right all right
and let's actually define do work I'm
gonna for brevity I'm not going to enter
all of the other keywords that are
required like public void and all of
that let's just say this is the method
definition right of do work and in here
we have a variable called weight and
it's of type float hopefully you can
read this and let's say it's 120 dot 30
okay so this variable is going to reside
in this stack the do work stack okay and
inside of this method definition I can
invoke further invoke other methods
let's say we have some method called do
more okay
say this method goes out to the internet
and downloads a bunch of files and
enters them into the database or
whatever it is that it does while this
method is executing of course this will
also be on the stack all right this will
be added on top of the stack and it's
gonna be called do-more and whatever
variables that are in this methods body
right those are local variables they
will be preserved in they will have
special reservations in this frame the
do-more frame okay so once once do work
is complete right it moves down to here
do do Moors frame is going to be
eliminated from the stack okay it's
gonna be gone and the next thing on the
stack is of course do work all right so
once do work is completed once we exit
this method then in the main method
we're ready to move on to the next line
and do work is now complete okay so now
in the stack do work is going to be
eliminated all right and now we're back
in the on top of the main right we're
still inside of the main method here
okay I can define a variable here called
you know name string name and there's
going to be a special memory in here
special area let's just say it's an
empty string name there's gonna be a
special area for this particular
variable name you know I'm just kind of
draw it I'm just gonna put some scroll
there just consider that as the name
variable alright so this is the purpose
of the stack it maintains method
invocations okay method inside of a
method inside of a method write those
calls are gonna be piling up on the
stack and when that internal method is
complete that's gonna pop off the stack
when the next wrapper method is complete
that's going to pop off the stack when
the application is done running we're of
course done with the main then main has
also gone from the stack and all of the
memory is clear it's available for us to
run other programs alright so stack
that's the stack in a nutshell now let's
move on to the heap okay and we are
still inside of the main method here I'm
not going to erase this stuff let's just
erase this we don't need to work anymore
we've already executed it so let's say
we are going down in the main method
line by line and we come across this
code we have car and the variable name
is called my car this is a local
reference variable okay this reference
variable belongs inside of main okay and
I'm going to create a slot for this of
course and this can be called my car so
at this point in this frame special
memory is reserved for being able to
maintain the data for whatever my car is
going to have okay and this variable is
going to point to the actual object okay
right now we haven't assigned it
anything we've just declared it alright
and the slot has been created in the
frame but we haven't we have to assign
it a particular object and you've seen
how to do that it can be my car is equal
to new car so this car is not a
primitive datatype it's a complex
datatype it's a class a type okay
somewhere in our application there's a
class defined that has the specification
of what cars are supposed to do right
and this variable my car right does not
actually contain the object okay this is
a very important point a lot of thing a
lot of people get confused this is not a
regular variable this is referred to as
a reference variable okay it refers to
where the actual object resides in
memory and this brings us to our next
point the actual object that's created
with this new keyword new car resides in
the memory area the other memory area
that I was talking about the heap
so let's draw that all right this is
consider this to be the heap all right
at this point we don't have an object
yet at this particular line but when we
get to this line we do have an object
that gets created on the heap and that
object is triggered by this new car
command so we have a car object all
right and this my car variable right
inside of the mainframe the the main
stack frame is now going to point to car
ok so what really gets assigned to this
my car variable is not the actual object
what gets assigned to it is the memory
address all right on the heap where this
car object resides in memory that
address is the thing that gets assigned
to my car all right that's a very
important point it's different for
primitive data types age when we assign
it at 12 the variable actually equals
the 12 when we give it age the variable
actually contains you know the number 15
right in binary form but that's not
important it actually contains the data
in this case my car does not contain the
actual object it contains a reference
all right
the address for in memory where that
object is located that's what this guy
contains all right so if I was to
actually if I was to create a sign my
car to some other object let's say my
car the next line my car is equal to new
car again all right now what's gonna
happen is instead of this my car
variable which you could probably barely
see but this you know this memory
location in which my car data is
supposed to be there instead of that
pointing to this particular car object
we have another car object that has been
created all right and that is because of
this line right here this command all
right and now my car is not going to
contain the address for the old object
it's actually going to contain the
address for this
you object alright in the heap so this
is where we come in to garbage
collection okay once we pass this point
once we're done here we move on to other
finer things in the program we've
completely lost track of where the old
car object was right remember we've
assigned my car variable a new address
of where the object resides
so we've completely lost all connection
and communication with this old car
object all right so this is actually you
can think of it as a rogue object that's
a candidate for being deleted all right
this is where garbage collection comes
in garbage collection is a process that
runs in the heap and every so often it
comes and it looks for objects that
don't have any relationship to them
right any variable that's pointing to
them it looks for those objects and it
eliminates them to clear the space in
the memory all right so this car object
this poor guy is going to go is gonna
it's going to be destroyed all right and
and we have reserved more memory right
the whole reason for the garbage
collection process to exist is so that
we can save memory for future bigger and
better things if we left that core
object in the memory with no variable
pointing to it of this obviously it's
useless to us right it's not going to
ever be used we can never access it why
is it there it should be eliminated
that's where the whole garbage
collection concept comes in in Java okay
so hopefully this all made sense we
talked about primitive data types and we
talked about class types right this car
and we also talked about local variables
right these are all essentially local
variables to the main method right in
this particular frame on the stack
but we also have something called
reference variables all right and those
are you know this for example my car
this is even though it's local to the
main method this my car is not
containing the actual object it contains
a reference to where the object is on
the heap okay
that's a reference variable so there is
one other type of variable that I want
to discuss okay and that is referred to
as the instance variable okay so let me
erase some of this stuff and then we'll
go over that an instance variable is
exactly what it sounds like it's a
variable that belongs to particular
instance okay we can have many many
instances of the same class and all of
them will be uniquely identifiable by
the data that is me that is in their
instance variable so essentially a class
with some variables in it
those variables are instance variables
and when you create an instance of that
class you can modify the state of that
instance by changing those variables
okay so let me explain to you what that
means we haven't created the class car
that we saw earlier so let's create that
class and we'll go over some more
examples class car and this of course is
outside of the main method so you can go
ahead and create that car if you haven't
already done so and in the main method
we're gonna be actually creating
instances of it so the first thing I
want to add to this class for now is
just going to be an instance variable of
type int and it's gonna be called HP
which represents you know every car has
horsepower so that's basically what
that's going to represent and we're not
going to add any other methods to this
for now and let's create an instance of
car so we can do a car and I'm going to
call it my two car just so that it
doesn't collide with the previous
variables that we've defined is equal to
new car right when I create an instance
of this an object or you know you can an
object and instance these two
terminologies are used interchangeably
they're essentially the same thing when
the interpreter sees this line here an
object in the heap is going to be
created and it's going to be of type car
okay a car object and this particular
variable is going to contain the
reference to where that object is on the
heap
of course this variable is in the main
stack main frame of the stack so we can
have a little slot here and we'll say
it's my 2 car all right that's gonna
this variable is going to contain the
address of where this car object resides
and by the way now that we have HP as a
an instance variable belonging to every
single object that we create of this
class it's going to have a special slot
on the heap that is going to be used to
maintain data for HP for every single
object right so I'm going to put this in
HP and let's give my two car some
horsepower so we can do my two car dot
HP is equal to let's give it a hundred
and twenty and this particular data is
going to get a hundred and twenty this
variable is gonna get the data 120 all
right now let's create another instance
we can do a car my three car is equal to
new car okay at this point a variable is
created here in the stack frame my three
car okay and this variable is going to
contain the the address of course of
where this object is created in the heap
right and that object is right here car
and it of course has to maintain a slot
for HP right and let's give my three car
its horsepower to be you know let's make
it super fast thousand so this value
here is gonna contain a thousand as the
integer okay now what I want to get into
so hopefully you understand what an
instance variable is an instance
variable is used to maintain state for
that particular object right
these two are car instances right each
one has its own variables maintaining
that their particular state
alright I want to go into one other
thing and that is an instance variable
that is
not a primitive this is a primitive data
type but is a complex data type let's
say we have some other class in our Java
project called engine all right I can
actually create an instance or a rather
an instance variable that is of type
engine and we'll call it my engine okay
we're not going to instantiate it here
we're gonna do it in the main so let's
say I want to give a car an engine I
could do for example my 3 car I can say
my 3 car dot my engine and engine Oh
which engine right where's our engine we
haven't created an engine yet right so
we need to first create an engine object
this is just a reference variable it
doesn't have any data assigned to it yet
so let's create the engine first object
and then assign that to that particular
variable ok so I can it's going to be
the same approach of course engine we
can call it big engine is equal to new
engine and since we're in the main here
this variable of course is we need to we
need a place in the stack frame called
big engine and of course this new
command here new engine creates an
object right so that object will be
appeared here on the heap so let's
create that all right here here's our
engine sorry for my handwriting ok so
this big engine variable contains the
address of where this engine object is
on the heap all right so now I can
assign this variable to my three car dot
my engine eight that's the variable name
right my engine
I can give it big engine so what exactly
is did I give this thing I didn't give
it the actual object engine I didn't
really give it that I gave it the
reference okay I gave it the the actual
address in memory on the heap where big
engine resides all right so by the way
now that we have another variable to
maintain in the car class we need to
have two more slots here to maintain
engine data okay they're gonna be called
my engine my engine okay
now the the car that we're giving an
engine to my three car is the guy that
has a thousand horsepower right it's a
super fast car so we're actually going
to get this engine the address of where
this engine object belongs is going to
be assigned to this car this instance is
my engine variable right sorry for the
handwriting but hopefully this makes
sense it's pretty self-explanatory and
we're gonna be seeing plenty more
examples in the remaining screencasts
thanks for watching
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>