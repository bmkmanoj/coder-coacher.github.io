<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>ReactJS and Redux Tutorial Part 4: Working with State and Immutability - Maximilian Schwarzmuller | Coder Coacher - Coaching Coders</title><meta content="ReactJS and Redux Tutorial Part 4: Working with State and Immutability - Maximilian Schwarzmuller - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udemy-Tech/">Udemy Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>ReactJS and Redux Tutorial Part 4: Working with State and Immutability - Maximilian Schwarzmuller</b></h2><h5 class="post__date">2018-04-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/FiJUHP0ni9c" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">in the last video we ended up with our
basics redox flow here where we had an
initial state of a number of one and
then we just patched some actions to add
and subtract values to that value and as
you can see this works fine now
typically your application doesn't use a
number as a state it might use an object
instead and you might want to change
values in that object it also might use
arrays and since objects and arrays are
reference types which means they are no
primitives which get copied but instead
have one place in memory and then
pointers pointing to that place we want
to make sure that we're changing the
state in an immutable way which means
we're always taking the old state make a
copy added this copy and return a new
state so that the old state stays
untouched let's see how we do that
I'll make some changes here I'll create
a new constant which I'll name initial
state and as will be a JavaScript object
this initial state here well let's say
have a result of 1 so before we had this
initial state of 1 now this is one
property in the initial state object and
then it has the last the values array
which is empty at the beginning like
this next in my reducer here I can use
the es6 addition of default values or
default parameters in methods to set my
state equal to initial state in the case
that no state is added or is sent to
reducer so once we dispatch actions read
acts will automatically pass the current
state to the reducer so the initial
state and ignored but if we first set up
our store and we don't have a state
therefore yet then the initial state
object here is used to initialize the
state that's just some ear sex work and
if you're not sure how all of this works
well I got a ear sex video on this
channel and I even got a es6 course on
udemy so you might want to check these
out if you want to learn more links in
the description so initial state is set
up here and since I'm setting it up here
I can remove the second argument in the
create store method so now I'm only
passing the reducer because the reducer
on its own handles the initializes
initialization of the state here so far
so good we changed the state to be an
object and we changed the way we
initialize the state now with that I
want to use this object to then change
the state in the switch statement here
whenever we dispatch an action now I'll
leave the action the way we create them
all the actions remain the same we still
only pass values as Paulo payloads these
are not adjusted to objects there is no
need to do so because we're still only
adding 100 we're not adding an object
with 100 that's important to realize the
payload here is always just a value you
want to change in the reducer is the
place where you then have to figure out
how to correctly change the state so how
would we correctly change the state for
the add action here well we take the
state object here and we could do the
following thing we could simply stay say
that state result is equal to action dot
payload or is equal to old State result
+ action dot payload now if I save this
and go back to the application you see
that my store is updated the result is
101 123 and then not a number because
the subtract action here hasn't been
updated yet so this looks fine ignore
that the last values is not updated
because I'm not implementing this yet so
the result is updated but here's an
interesting thing even though we see
result 101 here if we expand the object
we see result 123 and the reason is
because we're not doing this in an
immutable way I'm simply taking the old
property and changing the value there
for all old objects or the state in the
older objects here like the first action
here is also changed because it's one of
the same object it's the same place in
the memory and hence we don't have an
immutable approach here now why is an
immutable approach better because
currently we got no way of getting back
to an older state we can't see how our
state changed throughout the application
and therefore we're back in the world
we're handling the state is a bit more
complicated because it's always hard to
know what the current state of the
application is so a better way is to not
do it this way not directly manipulate
the property but instead create a new
state here I do this by creating a new
JavaScript object so state is now a new
JavaScript object it's no longer the
state we're passing here it's a new
JavaScript object and then this
JavaScript object I want to use all the
properties of the old state now a quick
and easy wave in es6 to get all the
properties of an object and add it as
properties to a new object exactly what
I want to do here is to use the spread
operator the spread operator are free
dots and here I take the state and this
may basically tells JavaScript or es6
give me all the properties of the state
object this object here which has a
result and a last value property and add
them as properties to this new object so
in this specific case here
that's exactly the same as if I would
have written state result and then state
last values but of course I would have
needed to also set is equal to result
and then here two last values like this
now that's much longer and the big
problem of course is if we change to sit
here we have to change it all over the
place here so that is a much better way
to achieve the same now of course I
don't want to simply get the old
properties I want to change the result
property that is why I now add result
and set it equal to be state result this
again is the old state here so the
result of the old state and at my
payload to it action payload that is why
I simply pass the value here as a
payload and not some kind of object
because the dispatching here or the
action is not responsible for passing
the finish new state object that's the
job of the reducer so the reducer always
works with the payloads which are types
like numbers strings may be objects of
course but never the new state so now I
set this or I created this new value
consisting of the old result property
and the payload of my action and I'm
setting the stood a result property now
if you watch carefully you might think
well I'm spreading my old state object
here this old state object has a result
and has lost values and now I'm setting
result again so now I kind of created
something like this result would be
state result lost values would be State
lost values so I have result twice and
that exactly is what helps but that's no
problem because the latter result
property
so to last when I specify here overrides
all prior properties with the same name
which is the behavior I want I first
spread all the properties of my old
state and then I override the ones I
want to override now as you can see I'm
not touching the last values yet and if
my initial state would have much more
values some of them which are never
touched by an add action well then these
properties would never be overwritten in
the turn off this add action so if I
save this reload my application here you
now see store updated with results 101
and 123 but now if I expand them you see
that the value actually isn't changed
because a brand new object is created
all the time and we don't see the old
object being overwritten instead as
happened before now with that let's also
implement this for the subtraction here
so let's copy this simply subtract the
payload save this now you can see the
values being changed here again the
result and the old object is not touched
and with that we get an immutable way of
using strings of using objects could be
of using objects as our estate now we
also have this last values array here so
let's say in this last values array here
I want to store well the value that was
used in this action so I could use my
newly created state remember I'm
creating a new state here and set last
values or use this last values here to
push action dot payload payload
like this and I'll also take this and do
the same for this abstract action I'll
save this reload my application you see
everything works here you see the array
here is growing we have an array where
we have 122 and 80 Oh
again we have the same problem as before
even though we get the information that
this array has one element it actually
has free because it was changed after
the time this object was created because
I'm not doing this in an immutable way
I'm simply taking my state and then I
push a new value here but since this
last values array is the one we spread
from the old state we're always using
the same array which is stored somewhere
in memory we're not recreating it so
whilst the object the state object is
handled in an immutable way the property
this last values array here is not and
this certainly is not the way we want to
do it so we want to do this in an
immutable way too and the way to do it
is to overwrite the last values property
just like we overwrite result here and
then set this to be equal to you a new
array where again use the spread
operator to spread out the old last
values array spread operators can be
used on both arrays and objects to
either fetch out all the properties in
the case of objects or all the elements
in the case of arrays so state last
values felts this array with all the old
values and then I add a new value action
payload so that's kind of pushing in an
immutable way and I'll do the same in
the subtract case no important thing in
this case here I could of course remove
this spreading of my state object
because I'm overwriting all the
properties that exist anyways but I'm
leaving it here because in reality you
will oftentimes have a case where your
action doesn't change all the properties
of your state we might have an
additional property like let's say
username here set it equal to max and
this is never touched so therefore we
want to still spread the state and only
changed eval
we need to change now if I save this and
reload my application again well we see
user name is always the same the array
contains one two and then three elements
which is of course the case in the last
object but now the first object is also
correct and at this point of time where
we changed the state for the first time
we only have the first value that was
added 100 in the second place here we
have 122 and then the last time we
dispatch in action we get 122 and then
80 and the result has changed
appropriately too so that is how you
handle objects and arrays in an
immutable way in your redox state and
that is a key thing to know and to use
to make a predictable state or to have a
predictable state in your application</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>