<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>ReactJS and Redux Tutorial Part 2: Why Use Redux? - Maximilian Schwarzmuller | Coder Coacher - Coaching Coders</title><meta content="ReactJS and Redux Tutorial Part 2: Why Use Redux? - Maximilian Schwarzmuller - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udemy-Tech/">Udemy Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>ReactJS and Redux Tutorial Part 2: Why Use Redux? - Maximilian Schwarzmuller</b></h2><h5 class="post__date">2018-04-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/86q4LyE8h3E" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">the core problem with react chests state
management is of course that we get app
component we got sub components and if I
want to change a text I can't do this
directly instead I have to inform the
parent change the text there and forgot
additional components well then it gets
even more complex therefore Redux has a
different approach here we have our view
or our application we might say and in
this application in any given component
we dispatch actions so one action might
be changed name to stick with the
previous example this action then is ran
through a reducer that is where the
Redux
Redux reducer where the name comes from
a reducer has one simple job or task it
takes the action handles the action so
if the action has changed name the
reducer will have a method which knows
what to do upon a change named action
namely change the name and it will then
take the old state and manipulate it in
a way that it now reflects this actions
of text the old state adds or execute
this single action on the old state and
gives us back a new state now this is
best an immutable which means don't
change the old state instead take it as
a basis and then create a brand new
state so kind of a copy of the old state
with the change employees so the old
state stays untouched we just create a
new state and return this note you don't
have to follow this immutable approach
and I will come back to this in a future
video but it's a good practice to do so
because it gives you unique States in
your application which makes it very
clear at which point of time you had
which state so we're in this reducer and
we're getting back a new state now this
state is then stored in well a store and
we have only one store in the whole
application in our
relax world this store has one simple
task store our state that's why it's
called store and we may have multiple
reducers but we only have one store so
multiple reducers for multiple parts of
our application but only one store which
holds one unique store and then our
application can subscribe to that store
or specific components can subscribe to
parts of that score store parts of the
state they need and whenever the state
is updated and therefore a new status
passed to the store the store will
automatically send it to all the
components interested and the
application will update so back to the
previous example we had a rap component
with all the other components here but
now we also have to store and if we want
you to change something in the user
component from the main component well
then we dispatch the action and reduce
the state or change the state and then
we pass the state to all the components
interested that's all so that's the
theory let's start seeing this in action</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>