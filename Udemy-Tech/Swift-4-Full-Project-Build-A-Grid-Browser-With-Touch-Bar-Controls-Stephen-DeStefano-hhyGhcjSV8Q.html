<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Swift 4 Full Project - Build A Grid Browser With Touch Bar Controls - Stephen DeStefano | Coder Coacher - Coaching Coders</title><meta content="Swift 4 Full Project - Build A Grid Browser With Touch Bar Controls - Stephen DeStefano - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udemy-Tech/">Udemy Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Swift 4 Full Project - Build A Grid Browser With Touch Bar Controls - Stephen DeStefano</b></h2><h5 class="post__date">2018-04-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/hhyGhcjSV8Q" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to the grid browser so first off
we create our toolbar up top and we can
add rows to our browser just by clicking
on the plus sign as many rows as we'd
like and you'd browse just like that or
you can add columns to it so you have a
bunch of different places to browse in
different websites on different parts of
your grid
and you could delete them just like that
as well
can enter another address in here
and we're taken to the
website the one that has the focus is
the blue border we can change the focus
here and then click on the links right
in here and navigate through there we
can go back and forward with our
navigation buttons here back through the
history however far back we need to go
it'll be there and then we went ahead
and implemented the really cool touch
bar so this is the touch bar simulator
that's running and we have our
navigation buttons up here as well so
you can navigate through your browser we
have the URL button here so we can click
on that and enter another URL
Panem back at Google here
on the focus of the site and you got
your touch bar activated and over here
we put this popover button we titled it
grid you click on that and you can go
ahead and add rows or remove rows right
from your touch bar as well
close that up we also added sharing to
the touch bar so if you click on sharing
you can access mail messages maybe you
want to mail this out this website notes
reminder you can send it to Twitter
Facebook Linkedin and a bunch more
and so this project is up next and
you'll get to work with the touch bar
api's as well as working with these
classes and methods
you
in this project you're going to make a
web browser with a difference rather
than browsing sites of course multiple
tabs this app will let users browse lots
of sites simultaneously this project
will give you more of a chance to
practice working with the responder
chain and NS toolbar but you'll also be
working with WK webview which will
display content so go ahead and fire up
Xcode let's create a new mac OS cocoa
application call it project 4
we'll leave storyboards checked and
we'll leave the other check boxes
unchecked
and create
you
come right into storyboard
most of this interface for the app will
be created in code rather than in
storyboard and this isn't because I want
to torture you it's because learning to
make your UI in code is a useful skill
because it's sometimes the best approach
in this project it's required because
we're going to let users add and delete
rows and columns of web browsers so we
need to be able to create and destroy
them dynamically the one part of the UI
that will be created in storyboards is
the toolbar here's an iOS developer tip
and as segmented control it's pretty
much identical to UI segmented control
although it's not as flexible with its
size him so right here on the
storyboards let's go ahead to the window
controller scene here's our window let's
drag a toolbar onto it as we did in the
previous project
and as we did before click on the
toolbar and let's delete some items here
first we want to delete from the default
toolbar items menu here so you want to
do this in order you don't want to
delete up here first
first we come down here get rid of those
three items and leave the flexible space
now we can come up to a loud toolbar
items and remove them from here
what we're going to use our segmented
buttons we're going to use labels and a
text field so the first thing we want to
drag on here are segmented controls
just drop them right on there
three of them now let's get a text field
go ahead and drag it to this side here
should drop it right in there and
finally we need to labels
you
so now what we want to do is we want to
select the toolbar item that's the first
item it's not what's inside of it it's
the toolbar item itself let's remove the
label and the palette label we'll do
this with each control
and we see the name changes over the
toolbar item
you
we don't need these labels so we're just
getting rid of them
you
okay now let's make the following
changes let's select the first segmented
control here
so you have to open up the toolbar item
and then select that right here as we
remember the toolbar item and what's
inside our separate things with their
own properties so now we have the
segmented control selected let's change
the segments from 3 to 2
let's go ahead and enter an image here
it's going to be NS go left and we see
it comes up and s go left template
we get the little arrow on the segment
there now let's change segment zero he
had a segment 1 and let's put in here
and s go right
you
let's go ahead and select the second
segmented control
let's give this to segments as well
let's give this an image of NS ad
template
let's change the segment to one is the
other part of the button and let's give
this part an image of NS remove template
now on to the third segment control
give this to segments
and we'll do it the same way as the
second segment control we're going to
give it the same images and I said
template change it to
one
Hennis remove
now go ahead and select the toolbar item
that surrounds the text field
and let's go to size inspector and
change its width or maximum width to
four thousand
select the text field so we'll come in
here go to the attributes inspector
let's give it some
shoulder text enter
URL
go ahead and select the label the first
label
inside its toolbar item let's change the
title here from label to rows
you
let's go ahead and select the second
label change its title to see OLS four
columns
now for something a bit contentious the
default style of our segment control is
textured square but Mac OS has a
dedicated style for segment controls
when they are used to group related
buttons together that style is called
separated and you're welcome to try it
and see what you think so you select one
of the segmented controls and go into
the attributes inspector
now you can see the style here textured
square
and change it
operated
see if that's something you like but to
my eyes the separated style never looks
quite right it is however what finder
and safari use so you're welcome to use
it in this code though I'll be using the
rounded style instead
and it looks blue here an interface
builder but it will be gray when the app
runs but regardless of what style you
choose you do need to change this mode
setting for all three segmented controls
here from select one two momentary
them act like buttons so they don't stay
down when clicked so let's go ahead and
change the rest of these out to rounded
and again choose whatever you like
and then momentary
you
so that's all the buttons configured so
all that remains is to arrange them
neatly in the toolbar here's the order
that we want the left and right
segmented control should be first
let's actually get rid of this flexible
space then let's put a space here then
the text field
and another space
then the rose label
then the plus/minus segmented control
another space
the columns label
and the other plus/minus
that control
so let's go ahead and run it and check
it out we should see our toolbar looking
pretty good
and here's our toolbar up here
the rows let's make this bigger there we
go
so it's coming together but we can make
it better
so back here in the outline let's select
toolbar now here in the display let's
change this icon and label to just icon
only and let's uncheck customizable now
go ahead and select the window directly
above the toolbar
let's give it a width of 650 in the size
inspector
now go ahead and check the minimum
sighs box here this way it has a minimum
width of 650 and then the user can make
it bigger if they want but we want it no
smaller than that so our controls are
visible and before we're done with the
design of our UI we're going to make one
small extra change to make our app more
like Safari
in project three you learned how to make
a custom window controller and you're
going to repeat that same thing here so
we come up here stop this from running
and create a new file
Cocco class
and we're going to
all this window controller and we're sub
classing NS window controller and also
uncheck create zip file
and as always make sure you have the
yellow folder
so we created our class window
controller but we need to connect it to
the storyboard so let's head back there
to select the window controller scene
and in the identity inspector for the
class choose window controller now for
the interesting part in window
controller dot Swift will see a Windows
load method
this is doing nothing right now other
than calling it super method so let's
add a line of code directly underneath
that
you
now if we run the app again
we'll notice that the window title is
hidden there was a title right at the
top that said window and now that's gone
and the toolbar has moved up to the same
level as the window traffic lights this
is commonly used in what Apple calls
shoebox apps apps that run in single
windows like iTunes in Safari where
there's no file name attached to it and
before we're done with the storyboard
we'd need to make some connections we're
going to use the responder chain for the
segmented controls being clicked and for
the user pressing return inside the text
field so we're going to create some
method stubs and those are methods that
have names but no bodies so that way we
have something to link to from IB let's
go ahead and open up view controller
you
and let's add four methods down here
you
they all have no code in their body so
they don't do anything but they all have
the magic IB action marker so they can
be used in IB let's open up storyboard
for the last time here
now let's go ahead and click on the
toolbar
and we're going to control drag from the
allowed toolbar items right to the first
responder
you can control drag right up here or
the first-responder here
so the first up is the navigation
segment control here control drag right
up here
let's look for navigation clicked just
start typing in navigation and here it
is
now you know what I just did there and
this is good that it happened because I
didn't have the navigation segment
control selected I had the toolbar item
selected I was going to go ahead and
break that connection
we come into the can
Specter right there and you can break
that so let's do that again let's open
up the toolbar item in underneath here
that's what I want to control drag from
and I'll actually drag from here
and would choose navigation clicked
again
so that's a gotcha there it's very easy
to make that mistake and just control
drag from an item thinking you have the
control selected when you don't you have
the toolbar item selected
and next up is the first segmented
control with the plus/minus here let's
go ahead and control drag this and we'll
choose adjust rows
now the second segmented
with the plus/minus
we'll be adjust columns
you
okay with the textfield selected
we want URL entered
we need to make one last connection but
this
is the assistant editor let's go ahead
and get in there
you
let's select the window controller and
what we want is the window view
controller file so let's go ahead and
hunt that down
here we go so let's control drag from
the text field
and we can control drag from in here
make sure we have that highlighted there
we go
sure you're on the textfield and not the
toolbar item that encapsulate sit let's
go ahead and drag it right into the file
here we're going to create an outlet
call it address entry
and now we're done with storyboard let's
go back to the standard editor come into
view controller
you think we have our circles here so
we're all
connected to I be well run it again make
sure we didn't break anything
and we're okay
nothing works yet because we haven't
written code but that will be up next
we've used auto layout in bits and
pieces so far but mostly letting Xcode
do all the hard work for us in this
project we're going to take things a
step further by introducing two ways to
create Auto layout constraints and code
will just be touching on them briefly
here but don't worry we'll return to
them in project six the first thing
we're going to use is called NS stack
view if you're coming from iOS you'll
find it the same as UI stack view
although Mac OS had at first a stack
view is a container designed to handle
layout for you it doesn't do any sort of
drawing of its own when you add a view
to a stack view it gets sized and
positioned automatically rather than you
having to size and position it by hand
they work great in horizontal and
vertical axes and we'll be using both in
this app the second thing we're going to
use our order layout anchors again these
are identical to their iOS counterparts
anchors let you create auto layout
constraints easily by effectively saying
make my top the same as my containers
top so using a combination of these two
we can create a grid layout and we'll
start by creating one stack for you to
handle rows in our grid and we'll set
its anchors so that it fills the entire
window will then create a stack view for
each column which is what will contain
the web views to do layout in code you
need to learn a new property at a new
method the property is called translate
Auto resizing mask into constraints and
what it means is automatically make auto
layout constraints by looking at the
size and position of this view this is
important because you can create a view
using a custom size and position and
those values will be respected without
you having to dabble in Auto layout the
problem is if you do want to use auto
layout those values will conflict with
your constraints so when creating views
for use with Auto layout you will
normally want to set the translate Auto
resizing mask into constraints
- false the method you need to learn is
called ads sub view and it adds one view
to another this lets you create nested
views however you want it's a trivial
method but I'm mentioning it because you
shouldn't use it when working with stack
views a stack view is there to help you
do layouts when you add a view to it the
view gets positioned and size
automatically based on where it can fit
into the stack view if you try to force
a sub view in there which is effectively
what the ad sub view method does then
the auto layout rules won't get
recalculated correctly instead you
should use the add arranged sub view
method which works correctly and now
before moving on I should add that
removing sub views is also done in two
different ways
for regular views calling the remove
from super view method is enough but if
you're working with stack views you need
to call the remove arrange sub view
method as well as the removed from super
view method and failure to do one of
them will cause you to leak memory okay
let's go ahead and dive into some code
first off we're going to need to import
the WebKit framework which gives us
access to wk web view that's Apple's
high performance web browser component
and it exists on both Mac OS and iOS so
at the top we'll add that import
as we are creating an inter
with web views in the app we're going to
want to be notified when the web views
do interesting things this is all
handled by a protocol called wk
navigation delegate so we do need to
make the view controller conform to this
we're going to start by creating a new
method called make webview and this will
do pretty much what you imagine it will
create a new webview and return it I
made it a method because it's going to
be used in more than one place and we
need to do a little configuration of the
new web views so it's best to keep that
kind of thing neatly isolated three
parts of this method or worth detailed
discussion first we're going to set the
navigation delegate property of the
webview to self which means tell me when
you browse between pages this is
important because we have an address bar
in our toolbar and it's important to
update that when the current URL changes
we already declared that viewcontroller
conforms to WK navigation delegate and
this is what starts sending messages our
way second we're going to be using this
line of code webview dot wants layer
equals true and this is a strange
anarchism in mac OS but it's an
important one so I need to make sure you
understand it at least in broad terms in
the early days of Mac OS back when it
was Mac OS X drawing was done without
the kind of hardware acceleration that
we take for granted core animation is a
graphics compositing framework that was
developed as part of the iPhone project
and enables high speed rendering effects
and animations it got added into Mac OS
in Leopard which was OS X 10.5 but that
was already six years after the initial
release of Mac OS X what this means is
that Mac OS wasn't designed with core
animation in mind and iOS was and so
every UI view which is the equivalent of
NS view here has a core animation layer
attached to it for high-performance
rendering on Mac OS this layer didn't
even exist until leopard and even then
wasn't really used all that much Apple
started recommending that all views be
layer backed from Mountain Lion onwards
fast forwarding a little bit even up to
xcode 7.3 core animation layers weren't
enabled by default when you created new
projects and finally that changed in
xcode 8.0 so new views in a storyboard
have a core animation layer by default
now I know putting a history lesson in
the middle of a coding tutorial can be a
little boring but the reason that was
put here is simple even though some
progress has been made Mac OS still has
an uneasy relationship with core
animation layers on iOS every UI view
has a CA layer behind it guaranteed but
on Mac OS you don't have that guarantee
not even in xcode 8 and when you create
a new view in code on mac OS it will not
have a layer by default it might acquire
one at a later date but it also might
not you don't know so in this app we
need every WK webview to have a core
animation layer behind it because we're
going to use it to draw a blue line
around the webview that's currently
selected this is easily done using CA
layer as you'll see later but we do need
to request it by setting wants layer to
be true and that guarantees we'll have a
layer behind the view regardless of what
anything else is doing and the third
thing you need to learn is how WK
webview loads website URLs you think of
URLs as something like this string but
in cocoa they get wrapped in a special
data type called URL creating a URL from
a string might fail because you could
type gibberish rather than a valid
website so swift gives you a URL
optional but that's not what wk webview
wants either instead it wants a URL
request which is a combination of a URL
plus some extra information such as a
timeout length and a policy for how data
should be cached
so you convert the string into a URL and
then you put that URL inside a URL
request and that's exactly what wk
webview loads so now at long last we can
write the make webview method and after
all that talk you'll be surprised it's
just five lines of code
you
the next stage is a bit easier and it
takes us significantly closer to having
a useful app I already said we're going
to store our user interface as a series
of rows using NS stack view and with
each row containing another and a stack
view so we get a grid effect so let's
add this property at the top
you
when the view first loads were going to
set up our stack view and create an
initial column and a web view this is
all going to go into the viewdidload
method and it needs to do four things
create the rows stack view making it
vertical and setting it translate Auto
resizing mask into constraints property
to false so that we can apply our own
auto layout constraints use anchors to
create auto layout constraints pinning
the stack view to the edges of its
container then create an initial column
which is another stack view and place a
single web view inside it and finally
add the initial column to the rows stack
view so our app starts with a single web
view visible and before we dive into the
code for that I want to explain three
things first stack views are horizontal
by default which means as you add
arranged sub views to them they get
stacked left to right that's fine for
our columns but for the rows stack view
we'll be giving it a vertical
orientation second stack views can space
their views in a number of different
ways but the best choice for this
project is called fill equally it makes
sure every sub view has equal amounts of
space and finally anchors our simplified
layer / auto layout and it makes it easy
to express common requirements consider
this line of code that means make the
leading edge of first view the same as
the leading edge for the second view and
the leading edge is usually the left
edge but some languages read right to
left and for them the leading edge would
be the right edge auto layout handles
flipping things around for you so let's
put the code in the viewdidload method
right after the super call
you
and that's all the code we need to get
the app up and running but there's one
last thing I want you to do before
running the app and that is we need to
enable outgoing internet connections
otherwise we won't get this to work and
this is a security feature that stops
apps from acting maliciously but it just
means we need to tell Xcode that our app
project needs to make external
connections in order to work so come up
here and click on project 4 and I'm
under the targets project 4 here I'm in
the capabilities tab and you notice we
have this app sandbox make sure this is
clicked on and then click on this check
box outgoing connections and if you get
this fix issue just click on fix issue
that should do it so we should be able
to run it and we should be good to go
and we're up and running we're at the
Apple website here
so up next we're going to take a look at
app transport security and in this
project we use the Apple comm website
can see here and this was no accident in
fact some of you have probably already
tried changing that to your own website
and you may have found that the app
didn't work
now before you send Paul and myself some
angry emails this is actually a feature
Apple insists that apps on Mac OS and
other platforms use secure protocols
like HTTP for transferring any kind of
user data this is great for users
because they can feel safe in the
knowledge that their data is secure but
for developers it can be a little bit of
a headache what if you want to access
insecure data because there's no other
way this security system is called app
Transport Security and although it
blocks everything that's insecure by
default there are ways to configure it
otherwise for example you can configure
it to require HTTPS for all URLs except
for a handful that you specify and if
you do this to one of your apps and
submit to the App Store for public
release you're required to explain to
Apple why you need to use the app
transport security exemption in the case
of a web browser we have no idea what
websites the user might visit so
obviously we don't want to specify
hundreds of thousands of domains in our
exception list
fortunately app Transport Security
provides an exception called an S allows
arbitrary loads in web content and that
adds the general app transport exemption
for any content loaded inside a wk
webview so this means the rest of our
app such as it is is restricted by app
Transport Security but Apple's own
components are free to load in secure
data an example that's most websites and
because this setting affects the whole
app it's not something you change in
code instead you need to modify a file
that has been in every project so far
but we've ignored it until now here's
called the info.plist
where the Peters part is short for
property lists
it contains a handful of basic pieces of
information about your app such as the
name of your main storyboard file and
what version it is and where we need to
add our app transport security
configuration let's go ahead and open
that file
and we see we open up into a different
editor with lots of rows across three
columns so if we right-click in the big
white space below the existing rows and
then choose add row
we're asked to choose a key name for the
new row so let's select app transport
security settings
and we can type that in
comes right up
when we choose app transport security
settings as our Rose key name we see
that the type category in the second
column it changes to dictionary and
there's a small disclosure arrow that
appears to the left it's this right here
so if we click that open and click to
select a row
and clicking that plus sign creates
another row right inside the app
transport security row so we have three
options here we're going to choose this
one allows arbitrary loads in web
content
and we notice when once we do that the
type changes to boolean here and its
value is set at no so let's go ahead and
change this to yes you can double click
it type in yes
and finally we're done we've configured
app Transport Security so that web views
can load HTTP well the rest of our app
can't which is the correct setting for
this app so now we should be able to
change the initial URL from apple.com to
something else that doesn't use HTTPS
earlier we added method stubs for adjust
columns and adjust rows both of which
are called from segmented controls in
the toolbar using the responder chain
we're going to fill in those method
stubs now so that they work as expected
the adjust column method will either add
or remove columns and the adjust rows
will do the same for rows deciding
whether to add or remove is easy enough
we made all the segmented controls have
a momentary mode and that means when
they get depressed they trigger their
action then return to their normal state
and this means that when our methods are
called we can read the selected segment
property of the segmented control to
figure out which of its two buttons were
pressed so let's tackle the adjust
columns method first because it's a
little easier if it gets called with
this selected segment equal to zero it
means we're adding a new column to do
that we need to loop over each and a
stack view that is contained inside the
rows stack view so doing that has some
pretty interesting syntax and Swift for
example look at this code
you
and yes you're seeing correctly we're
using the for the case and the let
keywords in the same line of code what
it means is loop over all the arranged
sub views of rows assigning each one to
a temporary constant called row but only
if it's an NS stack view stack views can
store anything inside themselves so the
arranged sub views array holds an S view
'z rather than Ana staff use and as we
need to modify each of these rows we
need to typecast them to their true form
before we can use them deleting columns
is trickier first we need to repeat the
same typecast we had when adding columns
second we don't want the user to delete
a column if it's the last one so we need
to check that we have at least two
columns before proceeding and third
removing a view from a stack view is a
two-step process you need to call the
remove arranged sub view method on the
stack view then the remove from super
view method on the view that you want to
delete so here's the code for the adjust
columns method and I'll put in some
comments as well
you
writing the adjust rows method is
slightly trickier again we can
distinguish between the plus and the
minus by reading the selected segment
property but that's where the similarity
ends
when we want to add a row we're first
going to take a count of how many
columns we need each row has the same
number of columns so we can figure out
how many columns we need by counting the
number that exists in the first row like
this
you
as with adjusting columns we need to
typecast an arranged sub view as NS
stack view because Swift thinks it's
just a regular view once we know how
many columns we need we're going to
create an array of web views that will
be used to populate the new stack view
row this can be done using the map
method of ranges which let us convert a
sequence of one type into an array of
another first ranges are those same
things that you've used in for loops for
I in 1.10 uses a range from 1 to 10 if
we put our range inside parentheses to
avoid confusing Swift we can call the
map method on the result what this means
is that for every number in the range do
something with it and return that
something in a new array the something
part is down to us so for example this
code would create an array containing
the numbers 2 4 6
you
in this case we don't actually care what
the numbers are because we're just going
to call the make web view method so we
can create a new row full of web views
like this
you
and the underscore dot in part is where
Swift would normally send us the value
of each number so the underscore means
we don't need that value and once those
two are done we can create the new row
stack view by passing it the view array
we just made which will cause those
views to be added to the stack view when
it's created
we'll also be using the dot fill equally
distribution again so that each web view
takes equal space to remove a row we
first ensure that we have at least two
rows and that the last row is indeed a
stack view if those two checks pass we
can loop over the last rows arranged sub
views property calling the remove from
super view method on everything that we
find
and finally we call the remove arranged
sub view method on the rows array to
remove the final row so I'll go ahead
and fill out the adjust row methods now
and I'll put the comments in for each
step of the way
you
and the comments guide you through each
step of the way here so this is a good
pause to go try the app now I'm sure we
won't be able to enter custom URLs yet
but we can at least add as many rows and
columns as we want
you
and that's a row
and that's a column
I can delete
so we're looking pretty good and things
are starting to come together and next
up we need to let users click on web
views to activate them so we'll get to
know and ask click gesture recognizer
users of this app are going to have two
three four or six perhaps or more web
views visible at the same time so how
can they know which one is selected
well it's for this very reason that I
wanted to make sure that all our web
views had a core animation layer behind
them see a layer lets us draw a border
around views with just two lines of code
so the next stage of this project is to
let users click on web views to activate
them this will involve meeting NS click
gesture recognizer which lets us detect
clicks on any view as well as a brief
introduction to see a layer for drawing
the borders let's start with the CA
layer so we can draw a border around the
webview that's currently selected only
one webview will respond to mouse clicks
and work with the URL text field in the
toolbar and we want to make that clear
to the user so let's go ahead and add a
property up that can track which webview
is currently active
you
there are two places when will need
change that property when we create the
first webview and when any webview is
clicked because it will be done in more
than one place we want to put the
selection code in a method so that we
don't repeat that code so we'll call the
method select webview this will update
the selected webview property and then
make the selected webview have a thick
blue border core animation layers have
border width and border color properties
that let us draw the border but there's
a small detail that I need to explain
first in cocoa most colors are specified
using a data type called an S color so
you can write things like NS color dot
red to get a bright red color
however core animation operates at a
lower level than cocoa which means it
doesn't understand what cocoa data types
are instead it has its own way of
creating colors called CG color where C
G stands for core graphics it's rare
that you'll want to work with a CG color
directly but luckily there's an easy way
to convert an NS color into a CG color
of course there's a built-in CG color
property so when you want to assign the
color blue to a core animations layers
border color you need to use a CG color
like this
and that's all you need to know so let's
go ahead and add the select webview
method down at the bottom
you
the next step is to highlight new web
views when they are clicked which is
best done using NS click gesture
recognizer this allows us to detect when
clicks happen on any view and have any
method be triggered perfect for
selecting web views but think about it
if the user wants to select a web view
so they can change its URL what happens
if the web view also reads their click
chances are they'll navigate to a
different page which will be annoying
alternatively we can stop the gesture
handler from passing on the click to the
web view but then how would they control
the web view they wanted so there are
two options here and I'm going to show
you both first we need to write a method
that will be triggered when a web view
is tapped this is going to ensure it was
called from web view then deselect the
current selected web view if there was
one and finally it will call this select
web view method here so let's add this
method called web view clicked
you
as you can see NS clicked gesture
recognizer has a view property that
stores the view it was attached to
that's a general Ennis vo though so the
method starts by safely typecasting it
to wk web view so we can work with it to
deselect the currently selected web view
all we need to do is set its border
width to zero we don't need to change
its border color because when the width
is zero the border is invisible the next
step is to enable web view selection and
like I said there are two places this
can happen when a web view is clicked
meaning triggered using our new web view
clicked method and when it's the first
web view to be created so we need to
distinguish between I clicked because I
want to select this web view and I
clicked because I want to navigate
inside this web view and there are two
ways that we could do this the first is
to create an and ask click just to
recognize her and set its number of
clicks required property to two when we
do this users must double click to
select a web view then single click to
navigate inside so to try it out let's
add this code to the end of the make web
view method
you
in the way that NS click gesture
recognizer is created is both
interesting and new so let's look at it
more detail first easy stuff the target
parameter means who should be informed
when this recognizer is triggered and
the action parameter means what should I
tell the target when this recognizer is
triggered what's a little more complex
is the way the action parameter is
passed it's using this pound selector
followed by the name of the method we
wrote this is a compiler directive
rather than regular Swift code it's an
instruction to the Swift compiler that
means we want to specify the name of a
method because the compiler now knows
exactly what the method is called which
is the webview clicked and where it
exists which is self ie the view
controller it can check that it actually
exists when it builds your code so if
you make a typo and write pound selector
webview click your app won't build so
let's run it and try it out
we'll create a row here and another
column
if I click this it's not selected so I
need to double click it because we set
the number of clicks required to be two
and now we see we have the blue border
so again select this double click and
the border goes around here and sits
selected one click won't do it and of
course you can still come in here and
select with one click open the menu and
that works perfectly fine but to select
the whole webpage you need to double
click it
so it's working pretty good but it does
introduce a small annoyance the only way
Mac OS can be sure you didn't double
click is if it waits for about a half a
second if other clicks come in that time
then the whole gesture is a double click
so our code is called if not it's
considered a single click and pass
through to the webview
and now the second way to disambiguate
clicks is using the NS just to recognize
our delegate protocol we can assign
ourselves as the delegate for the click
gesture recognizer and it will ask us
whether the recognizer should be active
every time the user clicks this lets us
use single clicks everywhere if a single
click comes in and it's on a selected
webview we can ignore it and pass it
straight to the webview otherwise we'll
immediately assume it's the user
changing their selection so let's come
back here and to make web view and let's
actually copy this code here and we'll
comment this out
paste it in again
and we'll just change it around a little
bit
you
and let me just put a comment up here so
we know what these blocks of code are
doing
okay so now we need to conform to this
delegate protocol let's come up to the
top and let's change the header up here
gesture recognizer protocol
so when any recognizer wants to know
whether it should start recognizing a
gesture it sends a message to its
delegate named should attempt to
recognize with if that method returns
true the recognizer will remain active
if not the recognizer will deactivate
for this gesture and pass the click
through normally so this is perfect for
our use because we can check the view
property of the recognizer if it's our
selected webview we can return false to
have the click pass through to the
webview otherwise we can return true to
make the recognizer behave normally so
that a different webview can be selected
and I realize this might sound
complicated but the truth is that the
gesture recognizer does almost all of
the work for us
we just need to either return true or
false and we're done so let's go ahead
and add this method down at the bottom
here
and if we just start typing gesture
and look for should attempt to recognize
with here it is
you
and that's it for that method so if we
go ahead and run the app now with this
new approach I think this one works
better because it eliminates UI
complexity
hey I'm just doing one click and boom
it's being selected and you can still go
ahead and choose menu items in here
navigate around just one click is
selecting it so this probably is a
better approach
everyone knows how to click but double
clicking to select isn't obvious while
also removing the ever so slightly
irritating split-second delay that the
double-click recognizer introduced
now before this step is completed the
last thing to do is select the first
webview that gets created to do that
let's add this code at the end of the
make webview method
you
so let's check that out
so if nothing is selected the first
webview is automatically selected
so we're looking pretty good
next up we'll work with handling
navigation before this app is complete
we need to add code to handle navigation
specifically we need to do these four
things here let the user enter their own
urls into the navigation bar make the
back and forward buttons work update the
navigation bar when the selected webview
changes and update the navigation bar
whenever the address changes the first
of these two are straightforward so
let's start with those we already have a
method stub for the URL entered which is
where we'll start this is called
whenever the user presses return in the
URL entry field so it's down to us to
act on it and here's what the URL
entered method needs to do it needs to
do three things ensure we have a
selected webview to navigate with
because it's possible the user just
deleted their selected webview so we
need to be sure try to convert the
string inside the sender parameter
that's our text field into a URL and
this will fail if the user asked to
navigate to somewhere other than say
example.com so we need to be careful and
if we do get a valid URL from the user
let's wrap it in a URL request and make
the selected webview loaded and the best
way to express the first step is with
guard because we're checking a
precondition of our method before
continuing let's go ahead and put the
code into the URL entered method
you
okay that's one task down and already
the app is significantly more useful you
can actually browse to websites that you
choose which is a pretty fundamental
feature of web browsers
you
just put in a website here
and we go ahead and navigate over to
another website like that
and now our second task is to make the
back and forward buttons work these work
the same as the plus and minus buttons
that we worked with earlier they are
momentary so the segmented control gets
depressed
our method is called and the segmented
control gets reset that means we can
read the selected segment property to
figure out which button was pressed so
that's how our segmented control works
the question is how do we make the
selected webview go back and forward
well that's simple WK webview has
methods called go back and go forward
easy enough so here's the code for the
navigation clicked method
you
and so that's two tasks down so now we
can navigate around our websites history
go ahead and click on something here
and we navigate back and forward
so we're looking pretty good so far
and now the next two tests both require
our viewcontroller to update the
navigation bar the text field was placed
inside the toolbar the problem is the
view controller has no idea that the
text field even exists so there's no
obvious way to modify it in project one
we did a little view controller digging
moving up and down the view controller
hierarchy by reading parents and
children this is often the best way to
solve this problem but I should add that
you always need to do it carefully so
you want to use the as with the question
mark to conditionally typecast things
otherwise a small change in your view
hierarchy will cause the app to crash in
this instance our view controller has no
direct way of accessing the address
entry text field however it can find a
way with a little navigation our view
controller has a view property the view
property has an optional window property
the window property has a window
controller property so we can try to
typecast view dot window dot window
controller as a window controller object
if that works we can find its address
entry property and adjust it let's go
ahead and add some code to the end of
the select web view method
you
the absolute string property of URL is
essentially the string form of the
complete URL which is what most browser
address bar is use I used the nil
coalescing operator here as well that's
the two question marks this is required
because the selected webview might not
have a URL to read from but we need a
value to place into the address entry
field using nil coalescing here means
put in the string form of this URL if it
exists otherwise put in an empty string
something to note this is not the only
solution to this problem but it's the
easiest an alternative is to create a
local property for the text field in
side view controller and set its value
in window did load so that solves the
third task and we should be able to
click web views to have their address
placed in the address bar
and there we go so if I go ahead and
navigate
website here
and I go ahead and click
the Apple website that gets placed into
the address bar click on Yahoo that gets
placed
and the last task is to change the
address bar automatically when the URL
of the selected webview changes we
already made view controller the
navigation delegate of each of our web
views so we'll be notified when a URL of
any webview changes all we need to do is
check whether the URL changed on the
selected webview because we don't want
the address bar to change when any other
view did something that would just be
too confusing and the code for this is
almost identical to what we just wrote
but this time we need to place it inside
a navigation delegate method called did
commit this method gets called when the
web browser has started loading any page
so we'll take advantage of that chance
to update the address bar let's go ahead
and add the did commit method now
and if we start typing did commit
it comes right up
you
so that's it we can run it and we should
see that the address gets changed
automatically
okay let's add a column and a row let's
add another website here
chemical with Yahoo
and so when you navigate around so here
for example we see Apple comm if I click
on Mac we see that the new address for
macbook is populated Mac air gets
populated back to Yahoo and if you click
the links here on Yahoo those particular
links will populate as well so now the
address bar is completely updating as
the URL changes next up adding touch bar
controls in 2016 Apple introduced the
touch bar which is a touch-sensitive
display that replaces the old school
function keys every app has control over
it when running in the foreground and
users with the touch bar expect you to
do something interesting with it
hopefully any touch bar code you write
is silently ignored when running on
devices without the bar so you don't
feel worried about checking for devices
however the touch bar api's are only
available in Mac OS 10 point twelve
point two or later so if you're not
running that mac OS version then you'll
need to mark your code appropriately so
Swift won't complain and here's a tip if
you have a touch bar enabled Mac you can
follow this part of the project normally
if you don't you should use the touch
bar simulator that's built into Xcode
just come up here to the windows menu
and choose show touch bar and that
brings it up
and before we get started
with some code there are a few
guidelines that you need to be aware of
to make sure that you're a good touch
bar citizen and here they are your touch
bar should be relevant to whatever the
user is currently doing if you have more
than one view controller to sign your
touch bars to work appropriately for
each one the touch bar is designed to
add extra options for the users press
not to display information that's the
screens job and never make options
available exclusively inside your touch
bar because not everyone has one there
are no api's to check whether a touch
bar is active and that's intentional and
don't assume you have complete control
over the touch bar most users have the
system control strip taking up the right
quarter of the display and there's also
an escape key on the left and finally if
there's a system icon that matches your
needs use it otherwise design your own
or use text okay that's all the rules
time for some code we're going to extend
the project so that it uses the touch
bar in the following ways we want back
and forward buttons to control
navigation and enter a URL button to
activate the address entry text bar and
a sharing button so we can share the
current URL using the system's sharing
service picker and we want a grid button
that lets the user add or remove rows
and columns and I've chosen that layout
because it will show you how to use
buttons segment to controls the sharing
control and also a popover menu
all-in-one and we could design simpler
touch bars but it wouldn't be as useful
for learners and just like any user
interface there are two ways of creating
a touch bar using interface builder and
using code both work well enough but
using codes easier to understand because
of the way the touch bar customization
works touch bar code is written in three
steps first you need to create
identifiers for every control that might
appear in your touch bar second you need
to create the corresponding control for
each identifier you define and finally
you need to create and configure an NS
touch bar telling it what controls it
should have let's start out with the
easiest part the identifier Mac OS needs
to
be able to identify every touch bar
control uniquely no matter which view
controller it's attached to and as
you'll soon see some touch bar items can
contain their own touch bars using
popovers and again Mac OS uses those
identifiers to help it distinguish
between all your controls Mac OS comes
with a number of touch bar identifiers
built in so we're going to get started
by extending that list with our own
remember these should be unique and
Apple's preferred method is to use the
same domain name format used in bundle
IDs so we'll be using identifiers such
as comm dot hacking with Swift project
for dot navigation where the first three
parts make up the bundle ID for the
project and the navigation part is this
specific ID for this touch bar control
so we're going to add one extension to
declare all our identifiers up front so
let's start up at the top to add that
extension it's just outside the class
and you can put that before or after the
class that doesn't matter so that's the
first step complete the second step is
to write a method that converts each of
those identifiers in to touch bar
controls that can be used this is done
using the make item for identifier
method of the anis touch bar delegate
protocol so before we write any more
code let's make the view controller
conform to the NS touch bar delegate
protocol
and with that protocol in place xcode's
autocomplete index should be updated
which will now include the make item for
identifier method so let's add the
following code
you should be able to just
King touch bar
so let's add a switch in here
that will be called whenever Mac OS
needs to create a touch bar item and it
will be passed the identifier of the
item it needs our job is to switch on
that identifier and take the appropriate
action but for now we're just returning
nil and if this code doesn't compile and
x KO d view a large warning like NS
touch bar item is only available on OS X
10.10 or newer then we need to add
another step here but if you've updated
to High Sierra or later if something
else is out you'll be good to go but the
issue is that the touch bar was
introduced after Mac OS Sierra was
launched
so it's possible some of your Apps users
might be in that small gap between
versions and they'll hit problems if
your code tries to run so Swift does
have a brilliant solution and you can
mark the whole method as being available
from mac OS 12.12.2012 xcode error to
make that happen all you have to do is
just add one line of code directly
before the method
so again if you're having issues and you
didn't update you OS you would add this
so I'll put a comment here
- exactly what that's for
I'll comment that out because I don't
need that running I see our here but
it's there if you need it so we're going
to be filling in this switch block with
all the cases required to make each of
our touch bar controls work but first I
want to complete step 3 which is
creating the touch bar itself all view
controllers have a built in method
called make touch bar and it does
nothing by default but you can override
it to build and customize your touch bar
as you need there are four identifiers
you need to think about here the touch
bar itself needs a customization
identifier with that one the user won't
be able to adjust the touch bar so that
it shows their preferred controls and
the default item identifiers array
contains all the items you want to
appear on the touch bar when it's first
created users can change this later but
there's always a default set that they
can drag in and the principal item
identifier is for any item so important
that it should be placed in the center
of the touch bar we'll be using this for
our enter a URL button and the
customization allowed identifiers array
lets us list which touch bar controls we
want to appear in the mac OS touch bar
editing screen this screen is all
created and managed for us but we do
need to say which items are eligible and
the customization required identifiers
array lets us list which touch bar
controls must not be removed from the
touch bar we're going to be using them
all here so you can see exactly how the
process works but in practice
I'd be surprised if you wanted to force
touch bar items on your users so before
we get into the code there's one more
thing I want to introduce and take a
deep breath it's a long property name
called is automatic customized touch bar
menu item enabled property view and
that's pretty self documenting when set
to true Mac OS will automatically add a
customized touch bar menu item to your
apps view menu
it's false by default but we're
interested in getting the full touch bar
experience here so
set it to true however this is a
property of your whole application
rather than a specific view controller
so we're going to use the NS app global
variable for the first time this is a
reference to the currently running
instance on your application and there
are lots of other options in there that
you can explore later on if you're
curious okay time for some code let's
add the following method
you
and note that I added another at
available here in case you need it
comment it out it's there and that
completes our three steps however it's
still not enough to actually work even
though we've created our identifiers and
configured the touch bar itself our make
item for identifier method is empty and
so it's not going to do anything and
that's intentional we're going to fill
in each item individually has case
sections in our switch block so you can
see your results faster first let's add
the enter URL button all this will do is
move focus to the address entry text
field in the tool bar so the user can
navigate to a website and this is a
button so we need a method to run when
it's tapped so let's start there let's
add this following method to the view
controller here
that's similar to the did commit method
we wrote already and it navigates
upwards to the window controller we're
inside but then it calls a new method
make first responder this is the Mac OS
way of saying make this thing have the
users focus which in the case of text
field makes them start editing now that
we have a method that our button can
call when it's tapped we can add our
first case to the make item for
identifier method
you
and as you can see that uses a regular
NS button just like we've seen before
this time though it wraps it inside an
NS custom touch bar item object and note
that we configured our touch bar to have
several items but the method above only
handles one of them and that's okay Mac
OS will call the method once for each
identifier it's given but any that
return nil will just be ignored so
that's enough to start with so if we run
the app now we should see our enter a
URL button but you might need to click
the webview first
you
okay let's go ahead and bring up our
touch bar
you
and there's our button enter a URL and
when the URL box is active Mac OS will
show its own set of touch bar controls
such as Auto completing text prompts
which will take the place of our own
button so if I make the URL box active
and you can see there are some other
things there that the touch bar
introduces while the URL is active and
this actually can be a bit confusing to
users so we're going to tweak it
slightly if they press the escape button
over here on the touch bar will deselect
the URL bar which will cause them to
return to the touch bar we just created
this is actually pretty easy the text
automatically catches any keys that are
pressed including the escape key but it
will also check to see whether the
window it's inside implements a method
called cancel operation if it does that
method is triggered when Escape is
pressed and we'll be using that to force
the text field to resign control now we
have a custom window controller but not
a custom window and I don't really want
to create a custom window class just to
add one little method so instead we're
going to tell the window to pass its
methods on to its window controller so
we can add our code there and this is
done using a simple connection and IB so
let's head over to storyboard
and let's look inside the window
controller
and inside that we see window here what
I want you to do is control drag from
window to window controller then choose
delegate
next let's open the window controller
file and let's add this code
you
and you've already seen the make
first-responder
but this time we're calling it on the
windows content of view controller this
makes the whole window active rather
than the text field which means our
touch bar will become visible again
remember the text field catches the
escape of press but it checks to see if
its window implements the cancel
operation method here the window then
forwards that on to its delegate our
window controller which does implement
that method so it's executed so if we
run the app again we should be able to
tap the enter or URL button on the touch
bar and then press escape to return to
normal
you
and then press escape here to return to
normal
so this escape gets us right back to
where we want to be and before we're
done with this button I'd like to make
one small change I'd like to make it
bigger now broadly speaking you don't
want to mess around with the sizes of
your touch bar controls they size
themselves automatically based on their
contents you really don't have any idea
how much space you're going to be
working with but we can tell the button
that we're happy for it to take up more
space if it's available and have Mac OS
grow and shrink it for us to do that
let's add this line of code
let's come back into the viewcontroller
now let's go to the
touch bar method that we have and right
here after this line of code which is
let button equal anis button
remember the content hugging priority
describes how important it is that this
control fit tightly around its contents
a priority of 10 when a scale of 1000
it's very low so the button will be nice
and wide by default let's add a second
control now back in forward navigation
buttons this will use an NS segmented
control just like we had in our toolbar
and in fact we can even point it at the
same navigation clicked method because
it works the same way the toolbar
segmented controlled used the image
template which was NS go left and hence
go right but Apple provides a set of
template images specifically for the
touch bar these are a little thicker
than the standard Mac OS icon so they
stand out on the relatively small screen
so we'll be using them instead just like
with the NS button we'll be wrapping the
NS segmented control inside an NS custom
touch bar item so it can be added to the
touch bar let's add this new case under
the previous one
you
and because we already wrote the
navigation click method that new touch
bar control works immediately so if we
launch the app we can give it a try
go ahead and click on an image and we
have
vacation buttons right here and it works
right away
we have our big URL button here as well
and so far we've seen a custom button
and a segmented control next I want to
introduce you to a built-in button
called
NS sharing service picker touch bar item
this is the touch bar counterpart of and
as sharing service picker and lets users
share content using whichever sharing
service are available to add this to our
touch bar we need to write three
separate pieces of code first let's add
the following case below the one we just
wrote
you
and that creates a new sharing service
picker and sets our viewcontroller class
to be its delegate and the second step
is to fix this error so we can form to
the sharing protocol let's come up here
and add that
and we'll still have the error because
we need to implement the
items for method which is what the
sharing service picker calls when the
user selects it and it's your job to
implement this method and return from it
an array of items that should be shared
which in our case is just the current
URL of the web browser now there's two
small complications first there might
not be a selected webview right now in
which case we'll share nothing and
second there might be a selected webview
but it might not have a URL and again
we'll share nothing in that case however
if we have a selected webview and it has
a URL we'll send that back to the
sharing service picker so let's add the
following method
and we have the ad available here to
avoid problems if you're running an
older version of Mac OS and that's
sharing complete and I hope you agree it
took a lot less work than adding sharing
in project three
and there's our sharing button right
here and you can see that you can share
via mail messages notes and Twitter
Facebook and so forth
up next we're going to add one more
control to the touch bar so you can
learn a little more it's going to be an
NS popover touch bar item and these are
touch bar controls that contain their
own nested touch bar so that's up next
in this final lecture we're going to add
one more control to our touch bar so you
can learn a little bit more
it's an NS popover touch bar item these
are touch bar controls that contain
their own nested touch bar which appears
when a button is tapped in our project
we're going to make it reveal segmented
controls to add or remove rows and
columns which will reuse those same two
methods so just rows and adjust columns
so we need to add three new cases in
total want to create the pop-up button
want to create the rows segmented
control and want to create the columns
segmented control in the tool bar we've
used the NS a template and NS remove
template for the images in the segmented
controls but that doesn't work so well
here because we need the labels to be
attached to the segmented controls so
instead we're going to use labels on the
segmented controls for example add row
and remove row so let's add these two
cases working in the touch bar make item
four identify our method
note that both of these controls have a
customization label property set this
wasn't used with the navigation control
because it wasn't part of the
customization allowed item identifier
array this label is a text string that
gets displayed underneath controls
inside the customized touch bar screen
and although the navigation segmented
control will appear in there it's part
of the default set that gets displayed
as one item so it doesn't need its own
individual label everything else like
our two segmenting controls needs a
label describing what it does and here's
a little warning if you don't provide a
customization label for a control that
is customizable you're going to see a
warning text in its place and beyond
that they work just like the navigation
segmented control that we added earlier
although of course they'll hook tup to
different methods to bring them together
under a popover touch bar button we need
to add one last case the adjust grid
case this will create an NS popover
touch bar item and then create a new NS
touch bar method inside it and that has
the adjusted rows and adjusted columns
for its default item identifiers and
then it will also use self as its
delegate because we already wrote code
to handle adjusting rows and columns and
it means the user can rearrange the
buttons however they want and as with
the previous two segmented controls our
NS popover touch bar button needs a
customization label so it appears in the
touch part editing window we also need
to set it collapsed representation label
property which is the text displayed on
the popover button when it's not folded
out so with that said let's add the
final case in this method
you
and that's the final case statement
written so finally the method is
complete so go ahead let's try running
the app and experiment with what you've
made
bring up the touch bar
so here's our grid button and we can
click on that and it reveals our four
buttons here to add a row you can see a
row gets added we can remove a row we
can add a column and remove a column
and then press over
back at the enter URL so the project's
complete and there are lots of new
things learned here things like in a
stack view wk web view URL URL request
see a layer click gesture recognizer and
pound selector now also we learned about
Auto layout anchors and some other
things but more importantly you have
another real-world app completed and
this is something that's actually
interesting and useful so you can carry
on developing it further if you want or
add it to your growing library of code
that you can reuse later how about a
little homework if you want to extend
this app further there are lots of
things you can add it is a web browser
after all
so about try adding a reload button to
the toolbar and this is just as easy as
navigating back and forward because wk
webview has a dedicated method you can
use for something a little more complex
try making the reload button act as
either reload or stop depending on
whether the current webview is in the
process of loading and you can use the
is loading property of WK webview to
help you out there but you'll also need
to implement that did finish delegate
method and for something even more
complex try enabling or disabling the
back and forward buttons depending on
whether the selected webview can
navigate in those directions you'll find
that the can go back and the can go
forward properties are useful for this
task but it does take some thinking
great job getting through this and
working with the really cool touch bar
another great project up next</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>