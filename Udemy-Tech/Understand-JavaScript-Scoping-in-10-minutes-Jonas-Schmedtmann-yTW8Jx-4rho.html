<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Understand JavaScript Scoping in 10 minutes! Jonas Schmedtmann | Coder Coacher - Coaching Coders</title><meta content="Understand JavaScript Scoping in 10 minutes! Jonas Schmedtmann - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udemy-Tech/">Udemy Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Understand JavaScript Scoping in 10 minutes! Jonas Schmedtmann</b></h2><h5 class="post__date">2018-03-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/yTW8Jx-4rho" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi I am Jonas I'm a web development
teacher at udemy.com
and this is a free preview of my
best-selling complete JavaScript course
so in this video you will learn and
finally understand how scoping and the
scope chain work in JavaScript we talked
about how execution contexts are created
and how that is related to variable and
function hoisting that was the first
step of the creation phase so let's now
talk about the second step the creation
of the scoping chain so what does
scoping even mean scoping basically
answers the question where can we access
a certain variable or function in
JavaScript
each function creates a scope which is a
space or an environment in which the
variables that it defines are accessible
in many other programming languages a
scope is also created by if blocks four
blocks or wild blocks but not in
JavaScript so here in JavaScript the
only way that we have to create a new
scope is to write a new function and
this is something very very important in
JavaScript also in JavaScript we have
lexical scoping and lexical just means
where something is written in the code
so it's about the position of something
within our code lexical scoping means
that a function that is lexically within
another function which means that it's
written inside of another function it
gets access to a scope of the outer
function also called
the parent function and with that it
also gets access to the variables and
functions that the parent function
defines but let's look at an example to
get a better idea of this so here we
have some more demo code in blue we have
the global scope which is the scope that
is accessible from
everywhere from all functions like the
global execution context you can think
of the global scope as the default scope
so in this scope we have access to the
variable a and also to the first
function in orange we have the scope of
the first function which defines the
variable B and a second function and
this is a local scope not a global scope
and do you remember what I said about
lexical scoping in the last slide thanks
to lexical scope this scope has also
access to its parent scope and all the
variables and function that it defines
and in this case that's the global scope
and finally in green the scope of the
second function in there we have a
console dot log statement which attempts
to print values of variables a B and C
now these variables are not defined in
that function only C but as we already
know a scalp has access to the scope of
the function in which it sits lexically
so when running this code the JavaScript
engine will not find variable B in the
current scope right so it just goes up
and looks in the scope of its parent
function and says oh here is B so let's
use that and the same happens for
variable a it does not find it in the
current scope and also not in the parent
scope so it goes even more up all the
way to the global scope and this is
exactly called the scope chain only if
the JavaScript engine does not find a
variable anywhere it throws an error and
stops execution now it's very important
to note that this does not work
backwards
for example the global scope will never
ever have access to the variables B or C
unless we return the values from the
functions so locally scoped variables
are not visible to their parent scopes
and this is why I put that red arrow
pointing upwards because that's the only
direction the scope chain works now how
does this actually work behind the
scenes
remember the execution context object
that we've been talking about before in
the creation phase each execution
context object will get the exact scope
chain which is basically all the
variable objects that an execution
context has access to because remember
the variable object is what stores all
the defined variables and functions so
in this example in the second scope we
have access to the variable object of
the second functions of the first
function and the global variable object
so what do you think will happen with
this code in practice let's go back to
our text editor and find out so I have
this code already here in my starter
code which is the one that you will have
available for download so here's the
exact same code that we had in a slide
before so how exactly do you think this
is going to work I'll give you a minute
to think about it all right so let's see
the solution great
so the console.log actually printed
variable a b and c so hey hi and hello
right hey hi and hello so why does this
work so this works because of course the
scoping chain and in this case thanks to
the scoping chain the second function
has access to the variables of the first
function and of the global scope and
that's because the second function is
written inside of the first which in
turn is written inside of the global
scope and that's why we call it lexical
scoping so another extremely important
concept and very much used in practice
as well
all right so we have seen that the
concepts of execution context scope and
scope chain are very related now before
moving on I just want to make sure that
you really understand how these are
related and where the differences are so
we saw that the scope chain for each
execution context is stored in the
execution context object but I just
wanted to make very clear that the
execution stack is different from the
scope chain so here we see another
simple code example and we already know
how the execution stack works right so
the first function gets called which
then calls the second function which in
turn calls the third function and for
each of these calls a new execution
contexts is put on top of the execution
stack now for the scope chain things are
a bit different we see that the global
scope contains the a variable as well as
the first and third functions then the
scope of the first function contains the
second function and this is how I like
to represent it now let's remember that
the execution stack is the order in
which functions are called
but the scope chain is the order in
which functions are written in a code
where they are lexically in our code so
the order in which functions are called
does not determine the scope of the
variables within these functions what
determines the scope of variables is
where the functions are written since
the third function is not in the scope
of the second function of course it
cannot access variables B and C defined
in a second and first functions it can
only access the global variable a
because the function is written in a
global scope so its execution contexts
that store the scope chain of each
function in the variable object but they
do not have an effect on the scope chain
itself this is important to understand
so what do you think will happen in this
case let's go find out let's first
analyze the code that we have here so we
have in a global scope the VAR a which
is defined as hello
we have the first function here and we
have the third function all in a global
scope or in the global execution context
and then inside of the first function we
have to be variable we have the second
function call and the function
declaration and we already know that
because of hoisting we can call the
function before it's written here right
okay and then in the third function we
just define variable D and attempt to
console log variable C all right so I'll
give you a minute to think about what's
going to happen once I hit the refresh
button here in order to run this script
okay so I'm going to do it I'm going to
push the button alright and so we have
an error which tells us that C is not
defined so two things here the first
thing is why can the second function
even call the third function so this bug
here came from line 73 right which means
that someone or somewhere this function
was called which of course was here so
the third function was called from the
second function and this once again is
possible because of scoping the second
function has access to the third
function because of the scope chain
right so the second function has access
to the global escape out here in which
the third function also sits lexically
and so the second function has the
ability to call the third function
because of the scope chain and there's
nothing new here right and now the
second thing
why do we actually get this error saying
that C is not defined even though it was
the second function who called third
function so the second function is the
function that defined the C variable and
then called the third function but still
the third function cannot access
variable C which it is trying to print
here which as we see resulted in this
error so by now I'm sure that it's
obvious to you that the third function
cannot access variable C because the
execution stack is different from the
scope chain and so to answer the
question who can access the C variable
the order in which the functions were
called does not matter all that matters
is that the third function is in a
different scope than the second function
and so it cannot access variable C so
which variables could the third function
actually access so try to figure that
out by yourself so did you get it okay
so it's variable a and D so let's just
test that so I'm going to console.log
this one here and then do console not
log a plus D and if I run this now then
I have hello John and hello is a and
John is d so these are the only
variables that we have access to because
they are in a scope chain for the third
function alright and that's it thank you
so much for watching as I mentioned
right in the beginning this was a free
preview of my best-selling JavaScript
course so if you like this video you can
check out the complete course over at
udemy calm it comes with over 17 hours
of content real-world projects and
premium support you can sign up today
using my exclusive youtube coupon just
click the link in the description below
in ICU in class
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>