<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>How to Choose the Right Database? - MongoDB, Cassandra, MySQL, HBase - Frank Kane | Coder Coacher - Coaching Coders</title><meta content="How to Choose the Right Database? - MongoDB, Cassandra, MySQL, HBase - Frank Kane - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udemy-Tech/">Udemy Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>How to Choose the Right Database? - MongoDB, Cassandra, MySQL, HBase - Frank Kane</b></h2><h5 class="post__date">2018-03-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/v5e_PasMdXc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this video is an excerpt from a larger
course I made check the description for
a link what we're going to talk about
now is how to choose a database
technology for a given application and a
given set of requirements there are tons
of options out there sequel or no sequel
Cassandra HBase MongoDB and lots more
let's talk about how they all differ and
look at some case studies to illustrate
how you would choose one over the other
so let's talk about actually choosing a
database we've talked about a lot of
different options my sequel MongoDB
Cassandra HBase and of course there's
others as well maybe you don't even need
an external database at all so how do
you make this decision when you're
actually architecting a given system
well there's no real formula you can
follow but there are things you should
think about or at least things you
should consider it's not an easy
decision that's why people who make
these decisions make the big bucks but I
can't least guide you through some of
the considerations that you might make
when making this decision as to what
database if any you might need for your
system one thing to think about is what
systems you need to integrate together
so different technologies have different
connectors for different other
technologies for example if you have a
big analytics job that's currently
running an apache spark then you
probably want to limit yourself to
external databases that can connect
easily to apache spark most of the ones
we've talked about today can but that's
just one example maybe you have some
front-end system that actually depends
on having a sequel interface to a
back-end database and you're thinking
about moving from a monolithic
relational database to a distributed
non-relational database in that case it
might make life a lot easier if the non
relational database you're moving to
offer some sort of sequel like interface
that can be easily migrated to from your
front-end application so think about the
pieces that need to talk together in
your system and see if they can actually
talk together or not with existing
off-the-shelf components and whether
those components are actually well
maintained and up-to-date that might
limit your choices right then and there
so it's the first thing to think about
think about scaling requirements as well
so how much data are you really talking
about is it going to grow unbounded over
time if so then you need some sort of
database technology that is not limited
to the data that you can store on one PC
right so you're going to have to look at
something like a Sandra or MongoDB or
HBase where you can actually distribute
the storage of your data across an
entire cluster and scale horizontally
instead of vertically think too about
your transaction rates how many requests
you intend to get per second you know if
we're talking about thousands then again
a single database service server is not
gonna cut it you need something that's
distributed where you can spread out the
load of those transactions more evenly
typically in these sorts of situations
we're talking about a big website where
we have a lot of web servers that are
serving a lot of people at the same time
you know if you're working at a really
big technology web-based company that's
gonna be the case and in those
situations you need to be looking at
distributed no sequel databases more so
than monolithic relational databases
think too about the support you might
need so do you actually have the
in-house expertise to spin up this new
technology and actually configure it
properly it's gonna be harder than you
think especially if you're using this in
the real world or in any sort of
situation where you have personally
identifiable information in the mix from
your end-users in that case you need to
make sure you're thinking very deeply
about the security of your system and
the truth is most of the knows sequel
databases we've talked about if you just
configure them by with their default
settings there'll be no security at all
anybody at all can connect to these
things and retrieve data or write data
into them so you need to make sure you
have someone available who knows what
they're doing for setting this up in a
secure manner that might mean you know
if you are in a big organization that
has these experts in-house that's great
don't even think about it but if you're
in a smaller organization you might want
to consider does this technology I'm
choosing actually offer professional
paid support that will help guide me
through these setup decisions in the
initial administration of my server over
time or are there administrators that I
can outsource the ongoing administration
to over time so in this case you know a
more corporate solution like MongoDB
might actually be a good choice because
you know they have paid support and even
for the more open source Apache projects
there are companies out there that do
offer paid professional support for them
as well so do your homework and try to
figure out can I really do this on my
own and if not what resources are out
there in the marketplace to help me
budget considerations well apart from
the cost of support you're probably not
going to really be thinking about money
very much because everything we've
talked about so far is open source you
know it is free to use you're going to
be probably
installing it on Linux servers where the
operating system is also free really
we're just talking about the cost of the
server's themselves here so think about
the cost of those servers they can be
significant in a large application or a
large distribution but apart from the
cost of the servers which you know and
these days you can rent that time to on
things like Amazon ec2 servers or eight
Amazon web servers or you know Google
also offers its own cloud services as
well in this day and age budget usually
isn't a concern when you're designing
these systems because you can rent the
time you need yeah that will add up to
something over time you need to figure
out what that's gonna be but if you're
working for a company odds are budget is
not going to be your main concern in
this sort of a decision something that
you do want to consider though is the
cap theorem our old buddy where we need
to pick two out of three consistency
availability or partition tolerance so
again the way to think about this is
when you're thinking about the scale of
your requirements do you need to have
partition tolerance do you have
sufficient scale where you know you're
going to eventually need more than one
server serving up this data just for
handling the transactions you're talking
about and also for the scale of the data
that you're talking about if so
partition tolerance is non-negotiable
you need that one and your only real
choice in that case is consistency or
availability and that will determine
which one of these sides of the triangle
you might want to lean toward so the
type of application will determine what
you want there only you know the actual
requirements that you have for
availability is it actually okay if your
system goes down for a few seconds or a
few minutes if not then availability is
gonna be your prime concern is it okay
if you have eventual consistency where
if you write something people might get
the old value back on subsequent reads
for a few seconds if so who cares about
consistency right again I would take
availability instead but if you're
dealing with something that's dealing
with real transactional information like
you know stock transactions or some sort
of financial transactions you might
value consistency above all else in that
case you want to really focus on that
corner of the triangle so again
understand how to read this diagram here
Cassandra for example lies on the
availability and partition tolerance
side of the triangle where we're
favoring these two over consistency
and when we talk about HBase in MongoDB
they are favoring consistency and
partition tolerance above availability
now I should point out that the cap
theorem isn't really a hard and fast
rule I mean it sounds like you know
Dogma when people talk about it but the
reality is these trade-offs have become
a little bit more loose in recent years
so for example consider Cassandra is it
really trading off consistency for
availability and partition tolerance
well you can actually configure the
amount of consistency that you want from
Cassandra you can tell it I want to make
sure I get back the same result from
every replica of this data before I
actually consider that transaction to be
final and if you're running it in that
mode you're kind of getting all three to
some extent you know so this this
triangle isn't quite as wide or distinct
as it used to be in all honesty you know
the the lines are getting blurred
between these different trade-offs over
time so be honest truth is any of these
technologies can be made to work in
pretty much any situation if you try
hard enough it's really a question of
you know choosing the technology that's
best suited to the trade-offs that you
want to make even with my sequel for
example you can set up sharding still
you can still make it partition tolerant
but it's just more of a hassle on more
of an administrative problem and above
all my advice is always to keep it
simple so you know if you don't need to
set up a highly complex no sequel
cluster and something that needs a lot
of maintenance like you know MongoDB or
HBase where you have all these external
servers that maintain his configuration
don't do it if you don't need to think
about the minimum requirements that you
need for your system and keep it as
simple as possible if you don't need to
deal with massive scale
don't put deploy a no sequel database if
you don't already have one right just to
use a my sequel instance somewhere it'll
be fine so keep it simple do not deploy
a whole new system that does not have
good expertise within your organization
unless you really need to simple
technologies and simple architectures
are going to be a lot easier to maintain
and believe me you're not gonna be happy
when you're woken up at 2:00 in the
morning because some random server went
down on this overly complex database
system that you set up for no good
reason
so really keep it simple stupid
simplicity is really the
guiding principle that all of your
architecture decisions should be based
around so let's look at a few examples
some fabricated case studies and talk
about how you might approach these
decisions so let's say that I'm just
tasked with building an internal phone
directory application I want a little
intranet page on my organization where I
can look up phone numbers and email
addresses of my colleagues so in this
case we know the scale is going to be
limited you know I'm not ever gonna have
so many employees in my organization
that I can't handle the scale of the
transactions or the scale of the data
you know even in a large company that
has tens of thousands of people you can
store that on a single disk you know
without breaking a sweat
right it's just not a big deal scale is
not a big consideration consistency it's
knock onto the end of the world if
somebody changes their phone extension
and people get the old one for a few
seconds after that updates been made so
consistency not a big deal you know
eventual consistency over the span of a
few seconds or even a few minutes
totally fine availability requirements
you know you probably get some annoyed
executives that the system goes down for
any any noticeable length of time but
it's not a mission-critical system at
the end of the day but you know of the
things we've talked about so far
availability is probably the thing we
care about the most so far and let's
think about simplicity as well odds are
you already have my sequel installed on
your front end web server already you
know a lot of things run on what we call
lamp stacks where it's a you know my
sequel is just part of the the stack of
your building on top of so you probably
already have my sequel installed
somewhere in your organization and you
most certainly have people inside your
organization that know how to use my
sequel and maintain it and administer it
so the choice here becomes pretty
obvious you would just go with my sequel
right because you don't need to deal
with partition tolerance you know and
you care about availability and it's
already installed people already
understand it so it's gonna be a nice
simple solution where you know you
already don't have to worry about
support very much because people already
know how it works it's simple it's cheap
that's going to be the way to go for
this sort of an application let's look
at another example let's say I want to
set up a system that mines my web server
logs and tries to look for interesting
analytical patterns
so imagine you're building like Google
Analytics for your internal website or
something you want to answer questions
like what's the most popular time of day
on my website or what's the average
session length things like that well how
would you approach this problem well
first of all step back and ask yourself
do I even have enough scale here to
warrant a non relational database at all
why am I even thinking about this
question right if all I'm doing is
analytics that's what Hadoop is for
that's what SPARC is for you can you can
import this data into HDFS on your
cluster and analyze it offline you know
we're not talking about high transaction
rates here where we care about very
quickly getting the answer to a specific
query over and over and over again
thousands of times per second that's the
sort of problem that no sequel databases
are meant for and if you don't have that
problem then don't introduce this new
technology that you don't need you could
solve this problem just by importing
your log data into HDFS and we'll talk
about ways to do that later in the
course but it doesn't involve external
databases at all once that data is
residing on my HDFS cluster I can write
a spark job that mines that data
you know assigns the appropriate
structure to it and it can actually run
machine learning algorithms on it even
using sparks ml lips so in this case why
would you have an external database at
all if you can just use spark you can
use tools like hive and pig you can even
like connect something like tableau if
you want something more graphical but
there's no need here to set up an
external database at all necessarily
unless you need to vend this data to a
very large audience externally right so
if you were actually building Google
Analytics for real where you had you
know millions of people that wanted to
hit it and get answers from it at once
then sure you'd want to expose that
through some sort of external database
system that's integrated with your
cluster but if you're just using this
internally for analytic use there's no
need to even talk about things like no
sequel or Mongo or Cassandra or
something like that so the answer in
that case would be none of the above
just use your Hadoop cluster and the
capabilities that the hoodia ecosystem
gives you without resorting to outside
database technologies let's look at
another example let's say I'm building a
movie recommendation system so again I'm
importing logs or some sort of customer
behavior data user ratings or something
like that
and I might have a big spark job or
something else that produces movie
recommendations for my end-users once a
night you know the the the supposition
here is that people's recommendations
won't change very quickly so computing
them offline periodically is acceptable
in this case but you need something to
vend that data to your web applications
so you know when a user comes to your
website and says I want to see
recommendations you need to be able to
get that list of recommendations for
that user very quickly and let's assume
that you're doing this at some massive
scale like your Netflix or IMDB or
Amazon or something like that right big
companies like that don't like downtime
very much you know so you do care about
availability but above all it has to be
fast you need to make sure that it's not
gonna hold up the rendering of your
front end web pages but you can give up
consistency so it's okay if for a few
seconds after new recommendations have
been computed for a user that you're
still getting the old recommendation so
thinking back to the cap theorem we care
about availability we care about
partition tolerance very much the thing
that we're willing to give up maybe is
consistency so in that case Cassandra
might be a good choice if you look at
that cap triangle Cassandra sits on that
side where we're favoring availability
and partition tolerance over consistency
and again if you do care about
consistency you can still dial up the
consistency meter on Cassandra if you
want to you can specify in your requests
actually I'm willing to wait a little
bit longer for a result that I know is
consistent so with that let me kick it
over to you let's do a little exercise
and see how you would attack a given
problem and choose the database so let's
imagine if you will that you're building
a massive stock trading system wow
that's scary stuff if you screw up
there's people's and money on the line
right people are gonna be really upset
if things go wrong here so you you care
about consistency more than anything if
someone makes a stock trade you need to
make sure that subsequent requests
reflect that data you know you cannot
have inconsistencies when you're dealing
with a system like this we're also
dealing with big data here so we do care
about partition tolerance we do have a
lot of data here a lot of trades a lot
of stocks out there and it could exceed
the bounds of what a single server could
store or what a single server could vend
you know to the transaction rates that
we expect to see and it's all really
really
important stuff you know this is a case
where security is tantamount you know
whenever money's involved you can pretty
much guarantee that some hackers
somewhere is gonna try to break into
your system and wreak havoc so you're
gonna want to make sure that if you
don't have the internal resources for
addressing the security of a system like
this you have access to external
resources that you can pay to guarantee
the sort of support and security that
you require and you're gonna have to
have enough budget to pay for that
support okay so in our next lecture
let's talk about what the right answer
might be and there's really no right or
wrong answer you know there are more
than one way to do this still but think
about the cap theorem thinking about
your budget requirements think about
simplicity and come back in the next
lecture and let's see what do you think
the right technology choice might be for
an external database for actually
vending these stock trades to and from
the public see in the next lecture so in
our previous lecture we talked about
some of the considerations you might
make when choosing an external database
for your system that is potentially
integrated with your Hadoop cluster and
we posed this scenario where you're
building a massive stock trading system
where maybe you want to run big
analytics job on a Hadoop or spark in
the background but you still need to
have some sort of a front-end interface
to the actual stock trades themselves so
what would be a good choice of a
database in this situation in this case
we care about consistency above all else
we do have big data that we need to deal
with so we can't assume that this data
will all fit on one server or that one
server can even handle the transactions
that we might require and we really care
about security and having outside
support so how would we attack this
decision well again let's take a look at
the cap triangle when we had to choose
between consistency availability and
partition tolerance we've established
that partition tolerance is a given you
know we know that we have enough data
that we need to have partitions so
that's non-negotiable
our decision is between consistency and
availability and we've said that in this
application consistency is actually more
important than availability obviously we
want both you know your stock trading
system going down it's not gonna make
for some very happy people but it's got
it would be potentially worse if the
actual data got corrupted people were
getting back different data than what
was actually being put into this
them so we care about consistency and
partition tolerance above all else so
that means we want to lean towards
systems that are more like HBase or
MongoDB right so these are going to be
highly consistent because they have a
single master a single primary database
that you all talk to but because it has
a single primary master that means that
there are some availability try it
trade-offs if that primary master goes
down you know the system that needs to
elect a new primary and all of your
application clients need to move over to
that quickly so this would seem to be
the right choice here but how would you
choose between HBase and MongoDB well
remember we talked about you want to
have strong external support because you
have a lot of security requirements in
this system and you're gonna need some
real expert advice on how to set this up
properly so in this case I might lean
towards something more like MongoDB
where you know there's a big company
behind it that it makes its living
selling support for it now there are
other companies out there that do
specialize in offering support for
things like HBase or other Apache
projects so don't make that a hard
decision there you know do your research
figure out what support is out there and
what's their track record have these
people actually supported applications
like yours before that have the strict
requirements that you actually have and
in this sort of a situation finding the
right partner to actually help you with
the installation and administration of
the database might guide you toward one
technology over the other but still you
know you want to understand what edge of
the triangle that you're focusing on in
this application now I do want to point
out again that this the cap theorem has
kind of come under attack lately you
know there have been enough
technological advances that it's no
longer entirely true that you have to
give up one for the other to you know
like I've talked about Cassandra can
actually you can actually specify the
about of consistency that you want so if
you wanted to you could make Cassandra
work for this application and Cassandra
does also have professional companies
behind it that offer support for it as
well so it would not be a crazy move to
use Cassandra it also would not be a
crazy move to use my sequel you know if
you take a hard look at the scale of
your data and how much partition
tolerance you really need maybe multiple
shards of my sequel or okay maybe
having a front-end application logic
that actually knows which my sequel
instance to talk to you for a given
range of transactions or you know a
given set of stock ticker symbols or
something like that would be a perfectly
reasonable thing to do so don't take the
cap theorem as gospel but think of it
more as a way of guiding you toward
technologies that are really engineered
from the ground up for the things that
you're trying to achieve so I would
still stand by my choice of MongoDB or
HBase in this sort of a situation again
you know the sort of support you can get
is probably gonna be more important
given the security considerations that
you have but there are other
considerations too like simplicity so if
I already have a Hadoop cluster
HBase just sits on top of Hadoop I don't
need new servers I don't need new
processes it's just sitting on top of
the HDFS filesystem that you already
have so all things being equal thinking
about integration considerations
maybe HBase would be the right choice
for you you know if you already had a
Hadoop cluster up and running that you
wanted to use so again these decisions
aren't easy there's not going to be a
right or wrong answer but some answers
will be better than others okay so think
about what your answer wasn't what your
thought process was compared to my
thought process and hopefully you ended
up in kind of the same the same ballpark
again there's no right or wrong answer
but some answers are better than others
so there you have a real-world example
of actually choosing a database hope it
demystifies a little bit for you and
makes you better understand the
different trade-offs you're making in
these different types of technologies so
there you have it external databases
with Hadoop thanks for watching if you'd
like to learn more check out my ultimate
hands-on Hadoop course on udemy in it
you'll learn over 25 different
technologies in the Hadoop ecosystem and
build up a powerful arsenal against your
big data just use the coupon code in the
description below and you'll get a large
and special discount see you there</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>