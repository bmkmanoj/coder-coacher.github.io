<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Spring Framework 5 Tutorial: Testing Spring Framework Applications - John Thompson | Coder Coacher - Coaching Coders</title><meta content="Spring Framework 5 Tutorial: Testing Spring Framework Applications - John Thompson - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udemy-Tech/">Udemy Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Spring Framework 5 Tutorial: Testing Spring Framework Applications - John Thompson</b></h2><h5 class="post__date">2018-03-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/aoB7GIND9PM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right we are going to take a look at
some of the testing stuff that we have
for spring so what I want to do is
establish common terminology around
testing what is the difference between a
unit testing and integration test is
pretty important what is a functional
test important stuff and then we're
going to dive in and look at the tools
that we have for testing spring
applications all right in this video we
are going to talk about testing within
the spring framework now I want to get
into some testing terminology first code
under test so this is a phrase that is
going to refer to the code or the
application that you are testing so this
is the actual application code it could
be a class a method or a whole
application if we're doing functional
testing so and then the other term that
we need to distinguish is test fixture a
test fixture is a fixed state of a set
of objects used as a baseline for
running tests and the purpose of a test
fixture is to ensure that there will be
a well known and fixed environment in
which the tests that are run so that the
results are repeatable and this is right
out of the j-unit documentation so this
is pretty fairly important you got two
distinctions here one is let's say keep
it simple you have a class that does
something the test fixture is the test
itself and anything that class is going
to depend on so that could include input
data a mock objects maybe loading a
database with known data or giving an
own set of inputs to that that method
that you're testing so two very
important distinctions here I see people
get these a little blurred at times but
you have code under tusks that is going
to be your your code that you wrote for
the application the the class or
whatever the method and then the test
fixture is the stuff around it that
you're using to test that code unit test
slash unit testing this is code written
to test code under test
should be very specific you're going at
after to test a specific portion of code
such as a method within a class now the
percentage of the lines of code tested
ideally is in the 70% range 70 80
percent some people disagree on this
some people like to see it more some
people say less there's a diminishing
returns on this so you're writing code
to test code you do want to have solid
coverage but if you start getting up
around 100 percent and that's where
you're becoming very very nitpicky so
you get a de missioning returns when you
start getting beyond 80 percent so
you'll be writing tested like code log
statements and getters and setters and
things like that where you don't have a
lot of value in the test code so I like
to shoot in the 70 80 percent range it's
has a good place to be because you are
getting effective test coverage there
now you should be unity in your test
it's a kind of a made-up word there but
your unit tests should be small and fast
now they're going to be targeting very
specific things and a true unit test is
not going to have any external
dependencies it should not be running on
a database I should not be bringing up a
spring context it should just be your
your java class and your test code so
that that is a true unit test and that
is in it addition to or in contrast to I
should say integration tests now these
are designed to test test behaviors
between objects and parts of the overall
system
integration tests are a much larger
scope than unit tests they can include
the spring context database message
brokers the downside of your integration
test is that they are going to run
slower than unit tests and that's an
important distinction your your unit
tests when you're just targeting a
method on a class is going to run in a
fraction of a second integration test if
you're bringing up a database through
the spring context and that could take
30 seconds or so or 40 seconds but the
distinction is a fraction of a second so
it versus 30 seconds as
exponentially larger and the importances
and when you start getting into a large
project your integration tests are gonna
take time to run it could take five
minutes it could take ten minutes it
could take a half hour depending on how
large the project you have and I see a
lot of developers favor integration
tests on things that could be done in a
unit test so I like to try to focus on
unit tests over integration tests but
integration tests absolutely do have a
place now functional tests typically
means you're going to test a running
application your application is live and
likely deployed in a known environment
so you're you're gonna be bringing up as
much as you can in that and you're going
to be looking at functional touch points
you could be using a selenium webdriver
or Jeb and Spock to test a automatically
test a web application to run amok
browser and test browser actions it
could be calling web services calling
the API and a web service and sending
and sending and receiving messages over
a message broker so this is where you
are doing functional or also called
end-to-end testing as another bucket for
a functional test and let's talk about
test-driven development so that's what
we're gonna be doing in this course
going forward this is a best practice
effectively what you want to do is write
your tests first and of course they're
going to be failing and then you're
gonna produce code to fix the test now
behavior driven development something
that builds upon test-driven development
and it specifies that test any unit of
software should be specified in terms of
the desired behavior of the unit this is
often done with DSL to create a national
language the goal of BDD is to open up
the testimonial for hands so you could
have a strong QA or testing person
that's technically adept but you give
them a natural language DSL where they
can configure different scenarios I've
used cucumber that's a good alternative
I've never used J behave but I hear good
things about it but my personal favorite
for BDD is Spock and that's a groovy
based test framework and
a good example of Spock is you get a
given one then I really like using Spock
especially the given one went then
because it gives you a good framework
about thinking about your test so you're
gonna think about a scenario where
you're given a set of data when is the
action like calling it method on a class
and the then statement is what you
expect to happen and you're going to
create test criteria around that so it's
a really good thing to use and I
personally really favored Spock for the
tests that I write now a couple other
terminologies as a mock and we are going
to definitely be taking an advantage of
mocks it's a fake implementation of a
class and used for testing kind of like
a test double and you see how I've been
teaching you to implement an interface
and do dependency injection with an
interface well guess what our mocks can
implement that interface and allows us
to test dependency injection classes so
we can inject a mock and therefore our
unit test now a spy as a partial mock
and usually use this for a heavyweight
class where you want to add in use that
class but you want to select methods
specific methods of that real class to
mock out so don't see this use a lot I
mean there are scenarios where you do
want to use this as a tool in the
toolbox
I generally favor mocking over using
spies but there are scenarios where you
do need to use this by all right testing
goals touched on this a little bit
already but generally you want the
majority of your tests to be unit tests
bringing up the spring contest does make
your test exponentially slower so I
really focus on testing business logic
inside of unit tests and that's where
you want to test the majority your
integration tests are going to be
testing more and things you're looking
make sure that interactions work
properly between different components so
you're not going to be as granular in
the specific specificity of what you're
testing with integration test you're
going to be a little bit loose around
the specific criteria you're looking
more for the interaction there where
your unit test you're going to be more
precise and what your
asking the Tusk to verify and a good way
to think about this is think of it like
a pyramid where the base of that pyramid
is gonna be made up if your unit to us
that's where you should have the most
number of tusks and then the middle of
that is gonna be your integration test
and at the top that's where your
functional test can't lift so you're
gonna should you know ideal world you're
gonna have lots and lots of you know to
us less integration tests and even less
functional tests
okay test cope dependencies we have been
using the spring analyzer and that has
been bringing in our spring boots
starter tests dependency and when we do
that we get the following dependencies
in there so we get J unit and that is
really the de facto standard for unit
testing java applications wildly popular
it's really risen to the top of
popularity most shops that I work with
use J unit that's kind of like it said
it's the de facto standard so it is a
very very popular and it's a simple
testing framework to use and we will be
looking at that shortly spring test and
spring boot test these are a set of
utilities that spring provides for
testing spring and spring boot
applications assert J that is a fluent
assertion library and we'll take a look
at that later ham crust is a library of
metro objects so J unit itself does have
some capabilities as far as doing
assertions but a ham crust gives us a
lot a lot more interesting capabilities
mockito is a java mocking frame where
it's very popular and we will definitely
be utilizing mockito
and we have Jason a cert and Jason hath
these two we when we get into developing
restful interfaces we will be leveraging
those now we spoke about J unit J unit
four is very popular right now it was
originally written by Erich gamma and
Kent Beck and Ken Peck is a very iconic
guy in the community he's the creator of
extreme programming and big agile guy
there's a lot of great great working
great contributions to to the community
now at the time of recording J unit 5 is
in alpha milestone 1 is expecting
July 2017 and it's supposed to go
GA got a little typo there third quarter
of 2017 now let's take a look at some of
the J unit 4 annotations at tests it is
an annotation to declare a test method
so that says that it is going to be a
independent test and the other ones that
are important is before and after these
are going to be things that execute
before each test and it's a good way to
initialize something and after you don't
see it used too much but that is going
to be cleaning up things then you have
the for class and after class these are
going to be executed once before they're
starting all tests and then after class
likewise don't see too much use for
those but you do have use cases for that
ignore is a way to disable a test
sometimes you do break things by
accident and you acknowledge it and you
say okay I'm going to ignore this while
I work on something else and fix it and
come back and fix it so there are cases
where you do want to use ignore but
sometimes you really don't want to then
the test annotation you can also say
you're expecting an exception so you do
want to test non happy paths and make
sure if you have a condition that you're
expecting it which can cause an
exception you want to be testing for
that and then test timeout as a way to
say if the test takes them longer than X
number of milliseconds and we have a
variety of spring boot annotations I'm
gonna go through these somewhat quickly
and talk about the ones that we are most
likely to be using we have run with we
will definitely be using that and that
brings up a spring runner and this is
what allows spring to work with j-unit
to bring up the spring context spring
boot test is an annotation that is going
to look for the spring boot application
and bring up its configuration so it's
kind of automatically going to use your
same configuration and then you can also
override that with the annotation test
configuration so that's going to specify
a specific configuration
at Mach bean it's going to inject a
mockito Mach so this is a really handy
way to create a mock object and get a
mockito Mach into your tusks and we'll
definitely be walking through examples
of that and then spy being somewhere is
a drink injection mockito spy and then
let's see here we get Jason test web MVC
test and data JP a test these are all
different annotations bring up different
spring causes slices of the system so
jason test is something that should
you'd be using when you are expecting to
use Jason input and output likely
developing a restful api and you have
web MVC test this is going to bring up a
test context without a full HTTP server
so that this is actually a very
important one it allows us to test the
spring web MVC controllers with a mock
HTTP session an environment without the
heavyweight of bringing up like a tomcat
server we're deploying to tomcat then
data JPA tests this is going to bring up
a test data layer with an embedded
database and also the entity managers so
that this gives us like we can you test
us bring data JPA
against a in-memory database now we have
a variety of other annotations here's
JDBC test is like the data JDBC test but
it does not bring up the entity manager
so you're going to be doing test for SQL
with that you can test with Mongo Russ
client rest Doc's is something that
we'll be looking at in the future when
we get to talking about restful api and
then a very important one is context
configuration this allows us to specify
a context for the test it gives us a lot
of control of how spring brings up the
context active profiles is something
that we'll definitely be looking at in
the future of course allows us to
specify active profile as to which
active profile we want to be using for a
specific test test property source
allows us to specify specific property
files for the test
Dirty's context is a very important one
that is going to reset the spring
context so when you're running the
spring context it is going to get
cashed between tusks so you run multiple
tests against a single spring context
it's not going to get recreated for each
one but when you do the dirties context
if you've corrupted something in an
environment this is where you want to
use this and it's going to rebuild the
spring context after that test runs and
this is a very expensive to do so there
is a need for it but use that one with
caution the next one I want to talk
about is transactional this is something
that we're gonna use
definitely when we're testing database
integration and we haven't really talked
too much about transactions but what
this allows us to do is run our tests
manipulate data and by default a spring
will roll it back now if you don't mark
it as transactional what's going to
happen is the test will run and it's
going to populate that data the test out
of generated by the test to your
database and it will be persisted so it
could corrupt another tough so this is a
good annotation to have and then before
transaction after transaction that's
stuff to do before obviously
transactions commit is to specify that
we want that test to commit its data
unlike rolling backward which is what
happens by default now we can actually
specify rollback if we need to SQL is a
very handy one it allows us to specify
SQL scripts that we want to run for our
test and then SQL config will allow us
control some metadata around the test
and SQL group just allows us to group
together several SQL annotations and SQL
can fix repeat is says to repeat the
test X number of times and then we have
timed it's very similar to je units time
out but it will actually wait for the
test to complete unlike je unit and then
if profile value and profile of value
source configuration these are kind of
rarely used but we can say that we are
indicating that US is available for a
specific profile
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>