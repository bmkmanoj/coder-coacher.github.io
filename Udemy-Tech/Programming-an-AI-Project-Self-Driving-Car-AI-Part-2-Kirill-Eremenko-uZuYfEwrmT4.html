<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Programming an AI (Project): Self Driving Car AI Part 2 - Kirill Eremenko | Coder Coacher - Coaching Coders</title><meta content="Programming an AI (Project): Self Driving Car AI Part 2 - Kirill Eremenko - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udemy-Tech/">Udemy Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Programming an AI (Project): Self Driving Car AI Part 2 - Kirill Eremenko</b></h2><h5 class="post__date">2018-03-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/uZuYfEwrmT4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello and welcome to this tutorial in
the previous tutorial we initialized the
map and now time for the exciting stuff
we create the car and we do that with a
class of course you will see that the
class is very practical to create some
things that have a lot of properties
because as you can see not only I'm
defining some variables for my car but
also some functions which of course is
the function that will make the car move
to the left to the right or going
straight so we have a couple of
variables that are important to describe
the environment we have for example the
angle which is the angle between the x
axis and the axis of the direction of
the car then we have the rotation which
is its last rotation which remember is
either 0 degree 20 degrees or minus 20
degrees then we have the velocity the x
coordinate of the velocity vector and
the y coordinate of the velocity vector
and then the vector of coordinates
velocity x and velocity y then we have
the sensors and the signals and that's
very important the Chordettes we're
making will have three sensors sensor 1
sensor 2 and sensor 3 sensor one will be
detecting if there is any scent in front
of the car then sensor 2 is the sensor
that will detect if there is any scent
at the left of the car and sent to 3 is
the sensor that will detect if there is
any scent at the right of the car and
then from these three sensors we get the
signals that is the signals received by
each of the sensors so signal one is the
signal received by sensor 1 signal 2 is
the signal received by sensor 2 and
signal 3 is the single received by
senses 3 and so how does it work
signal 1 is the density of sand around
sensor 1 signal 2 is the density of
scent around sensor 2 and signal 3 is
the density of sent around sensor 3 and
how do we compute this density of sand
well that's very simple we take some big
squares around each of the sensors these
are actually squares of 200 by 200 and
each of the squares we divide the number
of ones in the square by the total
number of cells in the square that is 20
times 20 equals 400 and that gives us
the density of sent because the ones
correspond to the center we do this for
each sensor and that gives us the
density of sent around each sensor that
is the signals all right so now we have
everything to detect the scent and then
we have the move function and of course
the move function is what will allow the
core to go to the left going straight or
going to the right so let's go through
it quickly we have here the update of
the position of the car with its last
position which is self that pass here
and the velocity vector so thanks to the
velocity vector the position will be
updated in the direction of the velocity
vector then we get the rotation which we
will get further down in the code right
here rotation equals action to rotation
action here we will select the action
and then getting the rotation and so
this self rotation equals rotation here
is this rotation that we get to know how
we need to rotate the car that is going
to the left or to the right then we
update the angle which I remind is the
angle between the x axis and the axis of
the direction of the car and then once
the car has moved then we have to update
the sensors and the signal because of
course when the car has just rotated
well the sensors have rotated as well
and therefore we need to rotate them by
using the rotate function and to which
we add the new position and why do we
have this vector of 30 zero well that's
simply because 30 is the distance
between the car and the sensor you know
it is the distance between the car and
what the car detects and then once the
sensors are updated well then it's time
to update the signals and so here we do
exactly what I explained to compute the
signals we get the x coordinates of our
sensor then we take all the cells from
minus 10 to +10 then we do the same for
the y coordinate taking all the cells
from minus 10 to +10 so therefore we get
the square of 20 by 20 pixels
surrounding the sensor and inside the
square we sum all the ones so basically
we sum all the cells because the cells
contain either 0 or 1 and since in a 20
by 20 square there is 20 times 20 equals
400 cells
well we divided by 400 to get the
density of once inside the square and
that's how we get the signal of the
density of sent around the sensor and we
did the same for the second sensor and
the third sensor to get the second
signal and the third signal okay so
that's to detect the scent and then
these three lines of code here are very
important it's another bad reward that
we want to give to our car when and is
reaching one of the edges of the map you
know we don't want the car to rush into
some walls and therefore we want to
penalize it to punish it when it's
getting too close to a wall and
therefore that's what we do here if the
first sensor is larger than longer minus
10 that is larger than here because
longer is this distance here so longer
minus 10 is right here so if sensor 1x
larger than longer minus 10 concerns all
the points that are here that is if the
car is getting closer to the right edge
of the map or if self-censor 1x lower
than 10 that's right here if the car is
getting closer to the left edge of the
map or if sensor y is larger than larger
minus 10 that's the upper edge of the
map and or if self-censor y is lower
than 10 that is the lower edge of the
map and so if the sensor 1 is reaching
any of these four edges well we will put
the signal of the sensor signal one is
the signal of sensor one we will set it
to be one and what does that mean that
means full scent like a full density of
scent it's like the worst thing you
could get there is so much scent that
it's going to stop your car so signal
will be one and therefore the car will
get a terribly bad reward all right and
then we do the same for signal 2 and
signal 3 from sensor 2 and sensor 3 all
right and then we create the game class
so that's basically the class to create
the game because so far we have
only created the car and now of course
we have to create the map we have to
create the game itself so we will not be
playing the game
it's our AI that will be playing the
game and the game is actually to avoid
the obstacles and to go from the airport
to downtown and vice versa so in this
game class we need to create some
objects like the car then we need to
define the update function that is the
most important and actually we will
focus on that right now because that's
in this update function that who will
select the action that the car has to do
at each time to accomplish its goal and
this section is exactly the output of
our neural network the neural network
that will be at the heart of our
artificial intelligence and so this
action is returned by the brain of the
car which I remind is the object of our
dqn class that we'll be making in our AI
file and this object has a method that
is called update and it takes as input
the last reward and the last signal so
the last reward is of called the last
reward obtained by the car and the last
signal is of course the last signal of
the three sensors signal one from sensor
one signal two from sensor to signals
three from sensor three but then I'm
adding two other inputs which is the
orientation of the car with respect to
the goal so for example if the car is
heading towards the goal then the
orientation will be equal to zero if it
goes slightly to the right then the
orientation will be close to 45 degrees
and if you go slightly to the left the
orientation will be close to minus 45
degrees so that's the fourth input of
our input state and then there is a last
input which is minus orientation so
usually the inputs of a neural network
are independent there is no
multicollinearity but it doesn't really
matter if we add this because the neural
network will just fix that with the
weights but still I noticed that by
adding this minus orientation well that
allows the car the training of the car
to stabilize the exploration you know
we're doing this so that the AI doesn't
always explore in the same direction by
adding this minus orientation we make
sure that's it explores in both
directions right or left and so they
the three signals plus the orientation
and - orientation are the five inputs of
our encoded vector which will go into
the network that our input vector that
will go into the network and after it
goes into the network while the network
returns the output which is the action
to play at each time and the output is
returned by this update function that
contains the network itself and the
outputs of the network and therefore
that's why we have to input the last
signal that is the input state and also
the last reward because the action to
play also depends on the last reward all
right and then we update the mean score
of the wards we update the rotation we
use the move function to rotate the car
according to the action that were
selected we have take the distance of
the car to the goal and we update the
positions of the sensors ball one ball
two and both three corresponds to the
balls that will represent the sensors on
the map you will see that very quickly
and then here that part is very
important because that's where we
penalize the car if it goes onto some
scent because as you can see this means
if the car is on to some scent well it
will be slowed down
so that's where we reduce its velocity
you know its velocity is usually six as
you can see here and if it goes onto
some scent it will be 1 so it will be
slowed down to 1 you all see how the
curve will be slowed down once it goes
onto some scent so it is slowed down and
besides it gets a bad reward it gets a
-1 reward and that's actually the worst
reward you could get the best reward is
one the worst reward is minus one and
the reward is between minus one and plus
one and then otherwise if the car isn't
on to some sand while it keeps its usual
speed speed of six and then we add
something else if it's getting closer to
the goal then it will get a slightly
positive reward and if it's getting
further away from the goal well it gets
a slightly negative reward minus 0.2 and
then last conditions that are related to
the rewards well that's if the car is
getting too close to one of the edges as
we spoke of early
remember when we talked about fool send
well if the car is getting too close to
the left edge of the map it gets minus
one award if it gets too close to the
right edge of the map it gets reward to
minus one and if it gets too close to
the bottom edge of the map it gets
reward minus one and if it gets too
close to the upper left of the map it
gets rewards minus one so that's a
terrible punishment and so you will see
how it will learn fast not to rush into
some walls all right and then this is to
update the goal when the goal is reached
so you know when the car reaches the
airport which is the first goal that is
the upper-left corner of the map while
the goal changes to the bottom right
corner of the map which is downtown and
that's exactly what we do here we update
the x-coordinate of the goal and the
y-coordinate of the goal and then we
update the distance from the car to the
goal all right and then that's less
important that's just a class that will
add the painting tools you know for us
to be able to paint some roads or some
obstacles on the map that's more related
to Chi V you can have a look if you want
I'll provide the commented version of
this code and I'll provide some
reference if you want to go deeper and
how to do that with Sky V but we're
getting further from artificial
intelligence so I'm not going to go into
the details of it and that's the same
for the last code section here with the
car app class that is just to add the
API buttons clear save and load so
that's what we do here clear canvas save
and that's actually very important that
for us to be able to save the AI you
know to save the brain so that you can
reuse it later by taking the load
function which is another tool we add on
the map to load the brain of the car
that is to load the memory of the car
how to navigate in the map and then
finally we have the last of the last
code section which runs the whole thing
that is which runs the map and the AI
itself and actually that's what we're
gonna do right now let's have a look at
everything we make in this code so right
now the AI is not implemented so the car
will have a very random movement it will
actually look like
an insect but don't worry we will fix
that not only we will train it to move
like a real car and train it to navigate
following some roads and avoiding some
obstacles so let's do this I'm going to
select everything and execute and here
is the map and here is the car all right
so that's little thing here that you see
that looks like an insect is our car so
as I told you the actions are totally
random so at each time the car selects
randomly in action whether to go
straight to the left or to the right so
that's why it is making some nonsense
movements and that's why it's looking
like an insect so we will fix that of
course and of course since the AI is dis
activated well it is not going to the
goal which is the airport here or to
downtown at the bottom right of the map
and we will fix all this by making the
AI so we will implement the AI into this
car or this insect so you can see the
three balls here the yellow one the red
one and white one that are three sensors
so that's what will detect if there is
some scent around it
and speaking of scent well let's draw
some so to do so I just need to do a
click left here and you know drawing
some send by still clicking left so
right now I'm adding some sand we can
add some more so each time an even
saying as you can see that's putting
once in the sand array that's the scent
array that's two zero zero coordinates
of the origin and here there are a lot
of ones and as you can see well that's
good to see the car we just went on to
the scent and what slow down so as you
can see right right now it is really
slowed down because it's going onto the
sand and right now it's trying to escape
and so you know what's we'll do is we
will draw some roads and we will draw
some roads from the airport to downtown
and we will turn the car to stay in the
road and to avoid the obstacles all
right and as you can see there is the
clear button to clear the sand there is
the Save button to save the brain of the
car and actually there is the score
curve that we spoke of so that saves the
AI that saves your model actually the
brain of your car and then you can you
know when you leave your code or turn
off your computer and you want to go
back to it again you can use the load
button to load your model that is to
load the brain and that will get the
trains AI of your car alright so now I
can't wait to start making the AI this
will be a lot of fun we will make our
neural network and we will punish the
car as soon as it doesn't do what we
want so let's do that from the next
tutorial and until then enjoy AI</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>