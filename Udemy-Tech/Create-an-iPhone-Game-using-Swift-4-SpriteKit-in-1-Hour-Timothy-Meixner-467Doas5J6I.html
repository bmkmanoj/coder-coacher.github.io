<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Create an iPhone Game using Swift 4 &amp; SpriteKit in 1 Hour! - Timothy Meixner | Coder Coacher - Coaching Coders</title><meta content="Create an iPhone Game using Swift 4 &amp; SpriteKit in 1 Hour! - Timothy Meixner - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udemy-Tech/">Udemy Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Create an iPhone Game using Swift 4 &amp; SpriteKit in 1 Hour! - Timothy Meixner</b></h2><h5 class="post__date">2018-03-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/467Doas5J6I" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">creating a game is one of the most
exciting and satisfying things any
developer can do and contrary to popular
belief most of the best-selling games
aren't actually the ones with the
flashiest graphics or the most
complicated gameplay but the ones where
anybody can just pick up their phone and
play right away what if I told you that
you can build such a game in under two
hours hi my name is Samantha and in this
video we'll learn how do we create the
popular iOS game color switch naturally
it would help if you have some
experience with iOS development and
Swift so that you are able to understand
the code but don't worry I'll try to
keep it as basic and simple as possible
so that even beginners can follow along
and if you have any questions during
this tutorial just let us know in the
comments but now without further ado
we'll jump right into Xcode and start
developing our color switch app for iOS
so let's open
Xcode and create a new project select
game as the template and hit next the
name will be color switch and the rest
can stay the way it is the language is
set to Swift and the technology is
sprite kit which is exactly what we want
scene kit as well as metal are more
complex frameworks that we don't need
for any 2d game such as color switch as
always we can then select where we want
to save the project and when we hit
create we have our game template ready
to go as we can see now a bunch of files
in here already and before we start
writing our own code in this we'll just
run the app once to see what Apple has
provided us we can see the standard
sprite kit template that automatically
gets created whenever you create a new
Sparky project in Xcode we have a label
here saying hello world and when we
click and drag on the screen we have
those little animations it's basically
just a quick demo that isn't that
impressive which is why we're going to
stop the app again and we want to make
our own game now which has nothing to do
with this template let's take a moment
and clean up the template and delete the
files that we don't need for example
these two SKS files game scene as well
as actions an SKS file is basically like
a storyboard for sprite kit which can be
pretty helpful for some games but not
for our colors which app since we are
going to add all of the functionality
directly within the code now let's have
a look at our game scene dot Swift file
where we already have a lot of code and
we really didn't want to start with a
template we just want to start it with a
plain
project so let's delete the import of
gameplay kit as well as the two
properties at the top and all of the
content of the did move to view method
as well but the method itself is
something that we want to keep but as
far as the rest of this code goes we can
just delete all of it all we want to
have is the game scene class as a
subclass of SK scene as well as the did
move the view method and the sprite kit
import at the top next we're heading to
the game view controller we can again
delete the gameplay kit import as well
as everything underneath of your load
method just a bunch of boilerplate code
that we don't actually need
want to take a moment and take a look at
the buted load method and help you
understand what actually happens in
there first we have an F flat statement
which costs all you as sk view meaning a
sprite in view all this means is that
this view of this view controller is
being used as sk view market view that
is able to render a sprite kit contents
inside it says load the sk scene from
game scene SKS but since we just deleted
this file we're going to initialize our
game scene differently so we don't need
an if let's statement and we can just
delete this as well as the curly
brackets I don't want to initialize an
SK scene with a file name I want to
initialize an instance of the game scene
and for the size I will specify view but
bounds dot size this means that we
initialize a game scene class that will
throw the entire view so that we can add
our elements to the scene and they will
fit the entire screen next there's a
property being set for our scene and
that is the scale mode which is being
set to aspect fill this just means that
our scene contents will fill the entire
screen next we have a view presents in
call which makes sure that our view is
showing our scene the next line where it
says view that ignores sibling order is
equal to true just means that the
elements of our scene can be rendered in
a non fixed way which has a lot of
advantages for us performance wise the
last two lines are just debug info that
tell us the frames per second as well as
the node count which can be really
helpful when developing a game and I'll
show you where they are exactly in a
minute before we run the app we wanna
head over
to our project settings and fix our
device orientation since our game will
be played in portrait mode we can just
uncheck landscape left and right we can
then go into our info dog Peters file
where we add the entry called do you
control a base status bar appearance
with a value of no to make sure that our
status bar is hidden while we're in here
we can also delete these unnecessary
orientations for the iPad so that all of
our basic settings are the way we want
them to be for the color switch app
let's run the app again to see our
current state and if we did everything
correctly we should have nothing but an
empty view which is exactly what we got
so that's perfect in the bottom right
corner we can see the debug information
that I talked about
it says nodes one and one point zero for
the frames per second now you might be
wondering why does it say one node when
there isn't anything displayed on the
screen well nodes are just elements that
are contained inside of a view but thing
is our SK scene is a node as well and
this note may not be visible but it is
still present inside of all of you so
don't worry about it
all of the debug information is correct
perfect we have an empty project and are
ready to implement our game
before we get started I want to give you
a quick tip that will especially later
when working on bigger projects coming
very handy on the left in our project
navigator we're able to create so called
groups that will allow us to sort our
files a bit better and just keep our
project cleaner because currently we
have all of our files in your Swift
files storyboard files such in no
particular order inside of the navigator
so when I right click and select new
group I can create a new group and let's
just do that and call that group view
controller and let's just put all of our
viewcontroller files in there then we're
going to create a second group called
scenes well I'll just put my game scene
file and then another group called
template where we'll add our appdelegate
file and then finally a group called
assets where we have our storyboard the
asset catalog and the launch screen
storyboard I can just push this input of
P this file to the top so it's just out
of the way a bit before we move on we
want to select our asset catalog but we
can add graphics that we want to use in
our app we have attached the graphics
we'll use and the downloads of this
lecture and when we open this folder we
see that we have the images called ball
and color circle at 2x so let's just
drag them into our asset catalog you
know as you can see we have our ball at
1x and the color circle I 2x but don't
let that confuse you because we had at
two acts in our file name of the color
circle Xcode automatically recognizes
that this resolution is the one used for
ratina displays which has
of twice the resolution of regular
devices since our ball isn't really a
complex graphic we don't really need
this but if you like you can absolutely
use a retinal version as well just make
sure whenever you use lots of graphics
in your app or game that you keep in
mind that it can make your app
relatively big if you have lots of high
resolution graphic files now that we've
added to necessary graphics we can go
back into our game scene notes with file
but we want to add something to our
scene let's add a new property which is
going to be our color wheel at the
bottom of the screen therefore I'm going
to define a property called color switch
of type as case bright note with an
exclamation mark because we are going to
initialize this property shortly and
were therefore able to force unwrap it I
don't want to add an additional
initializer which is are we going to
make this a force unwrapped optional
property now we could create our layout
entirely within the dit move to view
method which is going to be called
whenever our scene appears on-screen but
we don't want to do it this way instead
we're going to add a new method called
layout scene with no parameters so in
our didn't move to view method all we're
going to do is called layout scene this
way if anybody would read our code they
would instantly see when didn't move to
view is called something happens with
our layout and if they're curious they
can then just jump to our layout scene
method and see what is actually
happening in detail now before we add
our color switch I want to change the
background color to something that is
more like a flat color scheme similar to
what we had in our salmon SAS
application so let's do background color
and set it to a UI color with RGB values
Rett is going to be 44 divided by 255
green will be 62 divided by 255 and blue
will be 80 divided by 255 alpha will be
1.0 meaningful opacity if you want to
use a different color for your
background yours always more than
welcome to do that this is just what I
figured out and I think it looks pretty
nice now let's add our color switch so
let's initialize our colors which as
eske's bright note and past the
initializer with image named what we
then need to pass the name of our image
from the asset catalog meaning color
switch and that's all we need to
initialize it in s case bright note is
usually used for showing a visual node
such as an image or a texture in our
case an image now I want to set a few
properties for our sprite node that will
allow us to position it properly on our
screen the first will be color switch
dot size where I can easily specify the
size of the node
meaning what dimensions it should have
the great thing is that we are able to
do that depending on our screen so for
instance frame dot size that width
divided by 3 will give us a third of the
width of our screen since our colors
which is a circle and as therefore the
same height and width I can do the same
for height so frame God's eyes but with
divided by 3 again now that we've
specified the image as well as its
dimension we want to adjust the position
of the image so let's do color switch
dot position and now we need to specify
a CG point where we need a x and a y
value just like in a coordinate system
we can again use properties using frame
so for the x value we can do frame that
mid X for example which will be the
middle of our screen on the x axis Y
will be framed in Y which is right at
the bottom of our screen so let's adjust
as a bit by doing color switch dot size
dot height so it doesn't look like the
color switch is stuck at the bottom of
our screen if we would run the app now
we would be able to see our image just
yet because we're still missing
something we didn't add the actual
sprite no to our scene yet so to do this
we can use a child to press the note we
want in this case it would be T at child
color switch now we've selected the
image specify the dimensions and add the
note to our scene and we should be able
to see it when we start the app but
before we actually run the app I want to
add all ball 2 so let's add a new method
to our game scene because later on we'll
need to be able to spawn our ball
multiple times so let's create the
method spawn ball with no parameters and
we want to make sure that this method is
called at the bottom of our layout scene
method so that we can be sure that we
have a ball right from the start we
can't initialize the spoiler to be by
using a constant defined as a SK sprite
note with the image named ball which
again is just the name of the image in
our asset catalog let's specify the
position of our ball by doing ball that
position is equal to CG point and for X
we want it to be in the middle of the
screen again so frame dot mid X
and for the Y value we want to have the
ball at the top of our screen so frame
dot max Y again we need to add our note
to our scene and we can do it with the
add chart method and the argument ball
and then we have to obviously add the
size for our ball as well so it will be
ball that size with CG size and for the
height and width we're going to use 30
point-0
because we don't need it to be that big
and before we start the app we have to
fix this to be color circle because that
is the actual name of our image not
colors which I'm sorry now we've added
two nodes to our scene we've specified
their dimensions as well as their
respective positions on the screen and
we also changed the background color
let's run the app and see if there are
any changes perfect we got our custom
background color the color switch wheel
and we can even see the ball is already
there what we're still missing is any
kind of motion animal probably be nice
if we could use the gravity to just drop
our ball down
to be able to work with physics in our
Sparky game there are few things that we
need to do so let's begin by adding a
new Swift file just right-click on the
left and select new file and as I said
it will be a swift file the file will be
called settings and instead of
foundation we want to import sprite kit
this file would just contain a few
constants and we've been able to use
these constants within our game so let's
create an enumeration called physics
categories with no raw values but why am
i doing this here well it's like this if
I work with tight properties within an
enumeration so static as the keyword and
instead of an instance poverty I create
a tight property I don't need to create
any instances of my type I can just use
it like a constant within my code so
let's create three type properties the
first one being static let none which
will be a you in 32 and set to 0
physics categories in Swift or in sprite
kit are always declared as U and 32
values since 0 would usually be
identified as an integer value we have
to specify the type to be an you in 32
which means that it's an unsigned 32-bit
integer this constant is pretty obvious
and what it does we have the physics
category none which means that we do not
want any physical simulation to take
place and that's why the value is 0 the
next one will be slightly more
sophisticated or complicated because we
have ball category for our ball which is
also nu and 32
but it will be set to 0 x1 now this does
look weird but it's really just a
different way of writing the number one
why we have to write it this way will
become clearer in a second when we
define the third category as esthetic
let switch also as in you in 32 and it
will be also 0 x1 put with this operator
attached to it this operator is a
so-called bitwise shift operator and
what it does is shift all my bits by one
to the left so if we would write this
out the number I have here would be 10
this will give me so-called masks let me
just write it this way so it becomes
easier to understand I'm then able to
compare these masks with the values that
are underneath each digit so 0 &amp;amp; 1 &amp;amp; 1 &amp;amp;
0 how all of this really makes sense is
what we are going to have a look at in a
moment when we go into our game scene
and really start working with a physics
categories for now that's all we need in
our settings file and we can go right
back into our game scene where we will
now have to add physics bodies to our
color switch as well as our ball to do
so we will have to set their respective
physics body properties and for the
color switch I'll do that right below
setting its position by writing color
switch dot physics body which is an
optional property of this bright note
that I now want to set to a new sk
physics body instance and for the
initializer i will choose this one with
the circle of radius parameter since our
colors which is obviously a circle so
this makes perfect sense since the
physics body is able to mirror its shape
perfectly for the circle to have the
right size we should use half the height
or
the width of the circle which would be
the diameter of our color switch so
that's right
call us which dot size dot width divided
by two
next we wanted to find what category
this physics body has and therefore
we're going to write color switch dot
physics body does category bitmask and
this is where we want to use the value
that we defined in our settings file but
you're sending it to physics categories
switch category this contains a U and 32
which is exactly the type this property
expects we can then jump into our spawn
ball method but we will now also below
the line width position at a physics
body
we were once more start by initializing
the physics property as a new escape
physics body instance and this time
we'll just write circle of radius and
15.0 for the radius which is exactly
half the diameter of our ball on second
thought it will probably be better to
just use Balder side sword width divided
by 2 since in this way whenever we want
to change the size of the ball the
physics body of it would automatically
adapt next just like we did for our
color switch we will set the category
bitmask property of the physics body and
this time we'll use physics categories
ball category for the ball however we
also want to set two more properties of
our physics body and those are the
contact tests bitmask and the collision
bitmask which define whether contacts
between certain physics bodies should be
checked and whether certain physics
bodies can collide with each other so
that's right ball that physics body
contact test bit mask
and set it to physics categories dots
which category since we want to be able
to tell when our ball touches the switch
the next line will be board our physics
body dot collision bitmask
which were set to physics categories dot
none since we don't want our ball to
collide with the colors which we only
want to check if there was a contact now
we did add the physics bodies to our
sprites and before we continue let's run
the app and take a look at how this
effects our game so far there will be a
slight problem with our app now but
let's take a look after the app started
we can for a blink of an eye see our
elements but they immediately move out
of the screen this happens because the
physics bodies are influenced by the
gravity of our game scene which
logically pulls them downward
indefinitely for our ball that's exactly
what we want to switch however should
keep its position so let's stop the app
and we'll then use a certain physics
body property on our color switch to fix
this we start by accessing the physics
body property of our color switch and
then right dot is dynamic and set it to
false which bus stop or physics body
from being affected by any forces
including gravity other than that we
could already see that gravity pulled
our elements downward really quickly and
for our particular game here it would
probably be better if we could slow down
gravity a bit fortunately for us there's
a built in a way to achieve this in
sprite kit so to fix this I'll need a
new method right above the layout scene
method called set up physics this method
will also be called from audit move to
view method right before calling layout
seen inside of the new method I now want
to change my gravity
writing physics world dark gravity and I
can already see that I have to specify a
CG vector for the gravity here so let's
do just that by defining a new CG vector
instance which will take a DX and dy
parameter specifying gravity in the x
and y directions for the x value which
basically means to the left or to the
right there is no default gravity and we
want to keep it that way so let's say a
zero point zero here the default value
for dy is negative 9.8 which is the
gravity of Earth but since this was
pretty fast in our app will reduce this
value to be negative two point zero this
should slow things down significantly so
that our game kind of becomes more
playable we don't want our users to be
frustrated instantly and that should be
it for now so let's run the app again to
see if our changes were applied if they
were our colors which should stay in its
place and the ball should fall much
slower than before the app started and
we can see just that Oh ball however
still falls right through our color
switch and out of the frame since we
haven't implemented any code that should
handle the contact between these two
elements yet
you registered your occurring physics
contacts in our game we were once more
use an existing protocol that I get
pattern the contact delegate of the
physics world since we want to handle
the delegate calls in our game scene I
will write below setting our gravity in
our set up physics method right physics
world that contact delegate and then set
it to self will now get an error since
the class game scene does not conform
with this protocol yet however we can
fix this pretty easily right below our
class create an extension of game scene
so let's write extension game scene and
then after a colon adopt the SK physics
contact delegate protocol this protocol
only contains optional methods so as
soon as we add this here our error
should disappear we still want to
implement one method of the protocol
here and that is the did begin contact
method this method always gets called
when a contact is registered in our
scene and we can then use the contact
parameter to get all the information
about this contact since we did set the
contact test bitmask
of our balls physics body to the switch
category this is a contact that will be
registered and passed to my method
inside of the method we can now use our
bit masks to determine what kind of
contact has happened for us this is
relatively simple since we pretty much
only have one possible contact in more
complex games there might be a lot more
possible context that we then would need
to differentiate
but not for this game so I'll start by
defining a constant called contact mask
which will be set to
contact Bodie a dog category bitmask
bitwise or contact body B that category
bitmask
our parameter contact contains the
physics bodies of both of our notes and
we can use their category bit masks and
the bitwise or operator to combine them
now let's remember how we define our bit
masks we had 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 and this
bitwise operator will now combine them
by always setting the bit 1 if the
origin bits are different in this case
the contact mask would then be 1:1 if we
define our K gold bit masks the way we
did these calculated contact masks will
be unique and each contact has its own
contact mask we can then compare the
contact mask in all did begin contact
method to contact masks we know usually
would use a switch statement to check
for multiple different contacts since
again there is only one contact here and
if condition should be sufficient so
let's do if contact mask is equal to
physics category start bar category good
boys or physics categories dots which
category and if this calculation with
this bitwise or operator now yields the
same result as our contact mask we can
assume that the contact that occurred
was between a ball and a switch to get
rid of our error we should of course
compare this to contact mask and not to
contact inside of the if statement we
can now react to recontact between the
ball and the color switch so to test
this now I'll add a print statement that
will print contact in German to the
console to
we've implemented the delegate correctly
will now run the app and if we did
everything right we should get the
appropriate print contact as soon as our
little ball passes the color switch and
as soon as ITF started and the ball fair
through a circle we can see the output
on the bottom of our screen perfect in
the end we don't only want to print
contact here obviously but instead we
want to react according me to do so
we'll need a bit more logic for our game
which should color our ball in one of
the four colors so we would be able to
check whether or not the user has
selected the right color in our switch
to start off I want to create two
enumerations above our games in class
one will contain the four static colors
for our ball and the second enumeration
will define the different states of our
color switch since the switch is
actually just one image we will need
some way of knowing which color is
currently facing up but let's begin with
the enumeration called play colors it
will contain the different colors our
ball can have and we start with a type
constant called colors which will
contain an array of UI color instances
I'll begin with a UI color and then
choose he initializer
with the red green and alpha parameters
I can then add the corresponding values
for my color and I will use the exact
same colors I've used when creating the
color switch graphic so for this red
color the values will be 231 divided by
255 76 divided by 255 and 60 divided by
255 alpha is going to be 1 and therefore
will have full opacity I'll skip over
adding the other three colors since this
is just a lot of repetitive typing with
the appropriate values
I suggest you pause the video in a
second if you would like to copy the
same colors that I used and I have
completed my color array with our four
colors if you want to use the same now
would be the time to pause the video and
just copy these values or you could just
use the file from the download folder
where you won't have to type any of
these numbers we can then add our second
enumeration for the states of our color
switch and I'll therefore call this
enumeration switch state it will also
have raw values of type integer for this
enumeration
we're actually going to add cases and
those will just be the colors of my
switch in the right clockwise order so
red yellow green and blue if I don't
specify any values for my raw values
here we will just get the raw values
zero through three which is exactly what
we want
I can then jump back into my game scene
class but I want to add two new
properties which I can do right below
the color switch poverty the first one
will be a variable called switch state
which I will initially set to state
don't read if you remember correctly
this is our initial state in the game
with the red part of our switch at the
top the other property will be a
variable called current color index and
it will be an optional integer value
we'll use this value to subscript our
colors array later on to determine the
colors for our balls however it will
only be set later on so we'll just leave
it optional for now I can then scroll
down to my spawn ball method Y now want
to add something before actually adding
the ball I want to set our value for the
current color index property and it will
be an integer containing the arc for
random uniform method which will get the
parameters at for cast it as an unsigned
integer of 32 now this does look a bit
complicated but all it really does is
create a random number between 0 and 3
since the upper bound for here isn't
included in the arc for random uniform
method to be able to save this in the
current color index property we then
have to cast it as an integer and that's
all I now want to initialize my sprite
note ball slightly differently so let's
the lead
ye olde initializer and instead
initialize an S case brighten out with
texture color and size 40 texture I will
pass an SK texture initialized with our
ball image and this will just be the
normal image for this bright note which
we set as its texture so that we are now
able to add play colors the colors at
the index current color index as the
color for this texture
I can add an exclamation mark here after
current color since we've just
initialized it in the line above and I
can therefore be certain that it
actually has a value now this just
colors our texture with a random color
from our for play colors array each time
the method is called
I can then directly in the initializer
add the size I'll just copy from where
we said it before I can then of course
the lead there's old line where we just
set the size to actually make sure our
color is visible I would have to send
another property on my sprite node and
that is color blend factor and we'll set
it to 1 this makes sure that the color
is actually applied to my texture since
the default value is 0 which will just
display the textures own color
I will also set the name property on my
ball to be ball and we'll need to use
this in a second in our contact delegate
but before we get there we want to make
sure that we can actually manipulate our
color switch so it is able to rotate
we'll need two new methods for this one
custom method and one it is over a
contained in our scene which will need
to override I'll begin with our custom
method which is called turn wheel since
our colors which kind of looks like
wheel it doesn't need any parameters all
you want to do is execute static code
each time we
we do want to call this method each time
the user taps on the screen in a spike
did gain we can easily register this by
overriding the touch this began method
this method always gets called when a
tap is registered on screen and all I
want to do here is call our turn wheel
method I could of course also write the
complete code right here and the touches
began method it is oftentimes easier to
read and understand however if we
encapsulate certain functionality in
their own method and then only call this
method that we've given a descriptive
name to in appropriate places
somebody who would read this code what
any touches began method quickly see
that this method will turn my wheel and
if he or she wants to know more about
this or how this is implemented exactly
they can simply check the method turn
wheel and as also what will continue
with now implementing our turn wheel
method will have to be very cautious
though because we will set the value for
our switch state property here using the
rod value initializer we can use
integers for this and theoretically
we'll always add one for the next state
but this will only work as long as our
row value is below four since four would
not be a valid argument and we would
only get a nil value for the property so
to avoid this I'm going to use an if
flat statement by writing if let new
state and setting into switch state
which will try to initialize with the
ball value switch state dot raw value
plus one meaning one higher than our
current state if this does return a
valid value and not nil I can just set
switch state to this new state if it
does return nil this means that we have
a value that is too high for our
enumeration which on the other hand
means that we just want to reset the
state to the one with the raw value 0
therefore I'll add an else statement in
which I will set switch state to drat
which is our first case in the
enumeration now this covers the internal
logic of our color switch we do however
still need to make sure that it also
actually turns and to do that I can use
SK actions and sprite kit
these actions can perform a lot of
different manipulations on nodes
ranging from position changes scaling
changes to plane sounds and many more
what we want to do here is use our color
switch node and then call the run action
method which will then be passed and SK
action for this action I will say SK
action dot rotate by angle with a
duration parameter we can specify an
angle that we want to rotate by and how
long this should take since we want to
perform exactly a quarter of a turn I'll
say dog pi divided by 240 angle we do
have to specify this angle in radians
and since in this system 2pi equals 360
degrees a quarter turn would of course
be a quarter of this value for the
duration I will pass 0.25 seconds so the
disturbing motion will be relatively
quick we can then return to our tip
begin contact method where one of two
cases can happen we either have the
correct color of the switch facing up or
wrong one
for the second case I will also already
add another method called game over
which as of now will only contain a
print statement with the string game
over to allow us to easily check if our
game logic actually works in e did begin
contact method inside of the if
statement I can then delete the print
and set want to actually check my
contact to begin we'll need to determine
which node is in which body of our
content I can do so by writing a flat
ball
equal to and then I will use a ternary
operator by checking if contact body a
dot name is equal to ball and if this is
true the note for body a contains our
ball and I can therefore try to set this
constant ball to contact the body a dot
node as SK sprite note in the other case
I will set it to contact dot body B dot
note as SK sprite note I will of course
have to add nose here after my body age
probably check the name this does look
pretty complicated I get it but all we
really do is check which node is our
ball and then assign it to the constant
ball we can do so by checking the notes
name which if you remember we set in the
spawn ball method if we now have this
node we can check whether or not the
user has selected the correct color by
checking if current color index which is
the index that we've used to color our
ball and then this index has to match
our switch state raw value so to clarify
if I now say we have our color wrap
which is the first entry in our colors
array therefore our current color index
will be 0 if then our switch States roll
there you would also be 0 we would see
that this is a match because our colors
which would be turned the right way and
in this case I would therefore just
print correct to the console and I will
also want to spawn a new ball obviously
I will also want to remove our ball and
I'll use another action to do so let's
write but
and this time I want to choose the
method with an action and completion
parameter with this I can specify an
action to run and also what should
happen as soon as this action is
finished
for the action I'll just say SK action
dot fade out with duration and a
duration will once more be a quarter
second if I then hit return on my
completion parameter I can add some code
to be executed after this time the first
thing would then be to call ba dot
remove from parent which will remove the
old ball from our scene this also D
initializes our note so that the memory
it used gets freed up again other than
that I want to add a new ball to my
scene which I can easily do with my
spawn ball method since we are in a
closure block here I will have to
explicitly refer to my game scene class
so I will write self that's born ball to
correctly called a method and this
concludes this part of the if statement
where the user has the right color
facing up now let's add the else part
where the user got it wrong and in here
I'll just call the game over method that
we just defined now I know that this
lecture was a lot of coding but we have
now actually implemented pretty much
most of our game logic so that the most
basic interaction should work properly
to see if all this worked let's run the
app again and we should now be able to
turn our switch by tapping on the screen
and if we catch our balls we should have
a new one spawn at the top and also get
an appropriate output in our console
whether we had the right color up or not
I can see that I'm able to turn my
switch by clicking and if we select the
correct colors correct gets printed to
my console if I select the wrong color
we can see that the game over print is
in the console and no
balla spawning alright all of this seems
to be working very well but still
completely missing though is some sort
of scoring system so maybe every time
when we catch the right ball we should
get a point
to be able to keep track of our score on
the game we need two new things in our
game scene class the first will be a
property of type integer but we're used
to slowly actual coins in and we also
want to be able to display our score
somewhere on the screen to do this we're
going to use an SK label node which we
use in sprite kit to display text so
let's start by adding our two new
properties in a game scene class one
will be a constant called score label
which I will initialize as an SK label
node with the text 0 I can define this
as a constant which was still allow us
to change the text but we won't change
the actual label node itself we can then
define a variable called score which I
will set to be initially 0 I now have my
label as well as my scoring variable in
position and I'm able to work with them
inside of the class the first thing I'm
going to do now is in our layout scene
method take a look at how we can add our
label to the scene so I'll do this below
our color switch and before we call the
spawn ball method I'll start by setting
some properties on my label beginning
with score label and our font name which
will be set to a veneer next bold this
is just the phone that I chose feel free
to choose any font you like I'll also
set the font size property on my skull
able to 60.0 which will make my label
relatively big the font color of my
label will be set to UI color dot white
so that it's a nice contrast to our
relatively dark background just like we
did for the east brightness now set the
position property to a CG point instance
with X&amp;amp;Y coordinates why don't you try
and add these values in a way that I was
call evil has placed
right in the middle of our screen we can
just use the frame property with the
very useful mid X and mid y coordinates
provided by spiking which will position
the label right in the center of our
screen and that's all we need to set for
the properties of our label and I can
finally call a child on our scene to add
the score label to it before we do the
actual scoring indeed begin contact
method at the bottom right below setup
scene create a new method called update
label with our parameters all we want to
do here is set score label the text to
the current value of our score variable
obviously as a string by using string
interpolation well it might actually be
better to call this method updates go
label so it's more descriptive and it
really describes what it's supposed to
do even though in this case we only have
one label in the scene we can then
scroll down to our did begin contact
method and I now want to replace this
print statement with the actual logic to
increase our score I'll begin by writing
score plus equals one to increase our
score variable using the compound plus
operator and this will be done every
time we manage to turn our switch to the
right color matching the ball after I
increment it the score I can then call
the update score label method to reflect
this change in our score label before a
testers I will scroll all the way back
to our setup physics method where I will
once more degrees our gravity to
negative one point zero which will make
it even slower and easier to test now
let's run the application and see if
this simple code that we just added
displays and correctly increases on
score we can see our label and we will
also see as soon as I catch the ball
it gets incremented correctly so yeah
this is working fine
while our balls are falling down I can
see that it kind of seems random if all
Porter's displayed above or below the
label note and if I failed to turn the
switch to the right position we will
still get our game overstatement in the
console and the game will stop but we
should probably fix the visual position
of the ball in relation to the label
note so let's stop the app and quickly
take another look at our game view
controller class where we set this
ignore zipping all the property on our
view to true what this means is that all
of you renders the visual elements in no
particular order but in a way that it is
most efficient performance wise this
means that it can be random whether
certain elements are drawn above or
below each other
lucky for us we can manually specify
this position in our code so let's jump
into the settings file and do just that
would create an enumeration called Z
positions and we use this to define
constants for the Z positions of our
node which determine the layout our node
is drawn in we're using CG floats for
this and the bigger the value the closer
the element will be towards us I now
want to add three values here for three
elements for label and switch so let's
start with static let label as a CG
float which will be set to zero since
our label should be in a background and
not displayed in front of any other node
static let ball of types eg float will
be set to 1 so it is drawn above our
label and then finally let color switch
as a ZT float which will be set to 2 so
it is drawn above our ball with this
I've now defined Z positions for all of
my elements in this enumeration I still
have to set them to the actual nodes in
my game scene though I would then add
three positions to my color switch score
label and the ball in this ball ball
method and we'll begin with the color
switch right below the line where we set
its position by writing color switch dot
C position and setting it to Z position
stuff color switch just like that I'm
going to write score Leila dot C
position and set it to see positions dot
label and finally in the spawn ball
method also after setting the balls
position I will set ball dot C position
to see positions double and if I now
rerun the application we should be able
to see that our ball is always drawn in
front of our label and that's exactly
what happens here to see position
property is a neat way to easily define
different layers in our game since it is
often important to have at least some
kind of Def and order even in a 2-d game
what we still aren't really handling
well is our game over since we do get
the console output and our game stops
but we are then kind of staying in a
state of our app where we can't do
anything but maybe be better if we had a
menu screen that could show the user
their best and most recent score while
enabling them to restart the game if
they like this will also avoid jumping
directly into the game when we start the
app for the first time where the first
ball is already halfway down before we
can even see
to create a second screen which will
continue our menu we will inspire kid
need to create a new scene just like in
a normal app we'd use another you can't
roller to do so I will in my folder
scenes add a new farm it will be a cocoa
touch class and it will be a subclass of
SK scene and it will be called menu
scene as soon as I've created a new file
I will have to change the import right
at the top
since unfortunately Xcode will always
import UI kid for us
which then results in an error since the
type s casein is undeclared as soon as I
change the import to spike it though our
arrow disappears before we start
implementing the class itself I want to
quickly go back into our game view
controller file but I want to now give
our app starts show the menu scene
instead of our game scene I can do that
by just exchanging the class and the
line where I initialized scene the
initializer will stay exactly the same
and so does everything else in the class
if we stop the app now we will see our
menu scene so now it's time to implement
it together
before we go back into the menu scene
lots with file I will select my asset
catalog we're at the last graphic we
need for our game and your resources
folder you'll find an image with the
name logo at 2x which I will now just
drag into our asset catalog this is just
a simple logo image which we can now use
in our menu scene so that's exactly what
we're going to do since the content of
this menu scene class will be similar to
a lot of stuff we've already done
together
I will only implement the basic
structure of our class so that you if
you like
can give this a shot and try it on your
own first
I will override our didn't move to view
method which again will be called as
soon as our scene appears on screen
inside of the dit move to view method I
want to set my background color property
and we can just copy this from our game
scene so that we don't have to have all
the values for the color again
and I want to add different visual
elements to my scene the first being our
logo and therefore I will create a new
method called add logo then I want to
add some labels to my scene so I will
create a new method called add labels
and I will then call both new methods
from I did move to view method by
calling add logo and add labels inside
of the add logo method we want to create
a new sprite note containing our logo
image that should be positioned closely
to the top in the add labels method I
want to add three labels which I will
quickly initialize for you one will be a
play label as an asking able note
containing the text tap to play one will
be a high score label as in SK label
note with the text high score and
finally a recent score label also as an
escalator note with the text recent
score these labels should then be
positioned right below each other on the
menu screen now that this basic
structure exists why don't you try
completing our menu class so that our
logo and labels are properly shown so
why don't you pause the video for a
moment and give it a girl will continue
by doing it together starting in our at
logo method I will define a new constant
called logo which I will initialize as
an S a sprite note with an image named
logo that we just added to our asset
catalog I now want to change the size of
my logo by writing logo the size and
setting into a CG size instance I now
have to define a width and
hi for my logo and I want to set this
depending on our screen size fold it
with I will set it to frame that width
divided by four and for the height
others do the same
turns out over a square I can then set
the logos position by setting its
position property to a CG point with the
coordinate axis frame midex to center it
and for y I will set framed up mid y2
which I will add frame dot size dot hi
divided by four to position my logo
slightly above the center of the y axis
I will also add this dot size property
in the line above well resized our
sprite node I can then call the add
chart method just like we did for adding
nodes in our game scene to add the logo
to our menu scene that's all we need to
do for our logo so we can move on to our
add labels method I will start with our
play label which we've already
initialized by setting its font name
property to a veneer next bold
so now I'll do play label dot font size
and set it to 50 point zero since it
will contain slightly more text and all
score label in the game scene and that's
why we want to make it slightly smaller
I can then set the font color to you I
color that white
I'm already able to set the position
property to a CG point since the play
neighbors should be in the center of our
scene so we'll just do frame that mid X
and framed out mid why I can then call
add child and play label to add the
label to our scene
now since the other two labels are
pretty similar I can just copy this part
here and then paste it for the other two
labels where we just going to change
some values to start will of course have
to replace play label with the
appropriate other labels so in this case
high score label and we also want to
make the other two labels slightly
smaller so I will reduce the font size
to 40 point zero for the position of our
high school label the x value can stay
as it is but the y value will be
something else I'll subtract high score
label door frame dot size dot height x
for front frame top mid Y to have a
little space to our play label in the
middle for recent score I will also
begin by replacing the names reduce the
font size to 40 point 0 and for its by
position I will say highschool a little
dot position dot y and then subtract
recent score label dot frame that size
or height terms to to position the
recent score labels slightly below the
high score naval and that's basically
all we need to do to add our logo and
the three labels
our menu scene however we also want to
be able to start a game by tapping on
the screen just like our tap to play
label suggests and therefore I were also
override the touches began method in my
menu scene as soon as I type in touches
I can select he touches began method and
insert it into my scene all we want to
do here is initialize a game scene and
then show it I can do so by creating a
constant called game scene which I will
initialize as a game scene instance with
a size view that bounds dot size pretty
similar on how we did it for our game
view controller but we just presented
the menu scene we do have to add an
exclamation mark here after view but
we're able to do so since our menu scene
is currently presented in this view and
we can therefore be sure that it isn't
Neil I can then write you to present
scene and pass our game scene instance
to this method which will bring us to
the game scene we've now pretty much
completed the basic structure of our
menu scene so let's run the app again
and take a look at what we've got as the
app starts I can see that we are now in
our menu and not at the game itself our
Dogo is being shown and so are our
labels as soon as I tap on the screen
our game scene is shown and we can play
the game just like we did before the
only problem is as soon as we hit our
game over state was still stuck in this
game scene and we are not able to get
back to the menu we should also probably
make sure that we're actually saving our
scores in the game in a way that we can
access them and show them to our users
in the menu scene
when I'll have to make sure that we can
go back to our menu scene from the game
and therefore we will go back to our
game scene dot Swift file where we'll
take another look at what currently
happens when our game is over
indeed it begin contact method for
calling the game over method which as of
now just prints came over to our console
but we need to change this so let's
leave this print statement we now want
to go back to our menu and therefore
we're pretty much doing the same thing
like we did in our menu to get to the
game scene by defining a constant called
menu scene and initializing it as a menu
scene instance with the size set to view
the bounds that size and then we would
call you that present scene and present
our menu scene this would already bring
us back to the menu from where we could
start another game which is pretty neat
but before they actually do that we want
to save our high school if we manage to
get one and in any case we want to save
our recent score we're going to use user
defaults to do so which are a very
convenient way of saving small pieces of
data persistently in our applications so
all I need to do is use a default dot
standard dot set integer key and we can
then define a integer value to save and
the key which it should be assigned to
this key will then be used to retrieve
the safe value which we'll do in our
menu seen in a second but let's just
pass our score for the value here and
for the key I will say recent score this
always saves our most recent score for
this key for the high score I will first
have to check if our current score is
bigger than the current high school so
to do so I'll write if score is bigger
than user defaults that standard that
integer for key with the key high score
which will allow us to compare
our current score to the score currently
saved as the high school which we can
get with this expression here if we
don't have a value saved for this key
yet this will return zero which is
exactly what we needed to return since
obviously if we never scored any points
in our game our high school will be 0
however if our current score is bigger
I will also called user defaults dot
standard dot set and then press score
for the key high score to also save our
score as the new high score for our game
before we now run the app again I want
to quickly go back into our menus in dot
Swift fun where I want to add something
to our high school as well as to our
recent squalane but for the high score I
will after the text high score add a
colon and a space and then aplenty
string user defaults that standard that
integer for key high score with string
interpolation for the recent score label
I will do the same but this time use
user defaults that standard integer for
key recent score and that's all we're
now displaying the appropriate values
which we did save in the game over
method in our game scene so let's run
the app and take a look we should now be
able to see the value 0 for both scores
as the app stars we can see that this is
actually the case and if I now play a
game and let's say collect one point we
should get back to the menu on a game
over which just happened and we can now
see the value 1 for both scores if I now
play again and this time fail directly
we can see that our high score is still
1 but the reason score is 0 these values
were saving with user defaults will also
persist across app stance which is
pretty neat because we don't want to
reset our high score every time the
player closes the app the
radically our app is already working
pretty well right about now
we have a solid game flow and can go
from our menu to playing in back while
correctly saving our scores however we
do want to talk about two minor things
that we can do with SK actions like a
small animation in our menu or a sound
in our game which can make this already
great but very small game even a bit
more sophisticated
to add a bit more life to our menu scene
we want to add a small animation to our
play label and to do so I will write
below the add labels method create a new
method called animate which will get a
parameter labor of type SK label note
inside of this method I want to test two
different animations for our label the
first one would be to slowly fade out
and fade in our labor repeatedly to kind
of get a flashing animation to achieve
this I will begin with a constant called
fade-out which will be an SK action dot
fade out and for the duration parameter
I will say 0.5 so half a second I will
then add a constant called fade in as in
SK action door fade in with the same
duration of 0.5 this obviously needs to
say fade out not fade in I'm sorry I can
then combine these two actions to run
simultaneously or after one another in
this case I will of course choose the
second option by defining a constant
called sequence as an SK action dot
sequence and I can already see that I
will have to pass an array of SK actions
to this method and I will of course pass
fade out and fade in as the two actions
here finally I want to run this sequence
action on the label that gets passed to
this method indefinitely
so I will right labor the run action and
then pass an SK action dot repeat
forever which will then repeat my
sequence action forever what this does
is just run the sequence action
infinitely on the label note that we
passed to this method like I said we
want to run this on our play label and
therefore in the add labels method
after we've added the play table as a
child I'll need to call an animate with
the play label and that should already
do the trick so let's run the app and
take a look as soon as the app starts we
can now see that our label is flashing
on a menu screen as I said this doesn't
change any functionality of our game but
it's often a good idea to spend some
time on visual appearance of our apps
especially when developing games so that
they not only work well but also look
good with this action and the action
will define now I just want to give you
some ideas how you can use really simple
code to achieve these kind of effects so
let's stop this and I'll show you
another way but I'm fading our label but
scanning it up and down which will
result in a kind of pulsing motion of
the label I'll define a constant called
scale-up which will be an SK action
scale - and for scaling up Oh note I
will pass 1.1 to make it slightly bigger
for the duration I will again say 0.5
and I will then define a constant courts
gave down as a SK action dot scale to
where I will reset the scale to 1.0 so
to return to our original scale again
with the duration 0.5 actually I'll just
replace the fade out and fade in actions
in these sequences so that now this new
action is used for our label animation
I'll just comment the two fate actions
at the top here to avoid warnings and
then run the app again and as it starts
we can now see a slightly different
animation of our label which also looks
pretty good and draws the users
attention to our tab to play call to
action this will be it for our animation
with labels and you can of course use
animations on other nodes as well maybe
images
for example I will stop the app and now
we'll learn how to add a little sound
effect to our game in your resource
folder you'll find an audio file called
bling which I would just drag over in my
project here if we listen to it really
quickly it's just a short the coin sound
which we can use in our game whenever we
score to do that I would go into my game
scene let's scroll down to my did begin
contact method where this happened so
right where we increment our score I
want to add a new action that I can run
directly on my scene so I could just
call run and then define an SK action
dot play sound file named for the name
of my sound file I'll just say bling
wait for completion can be false here in
our case this doesn't really change
anything but we still need to provide a
value for it now this was really easy
and just one line of code we added sound
to I am hopefully so let's run it up and
see if it actually works
we start an old menu with our nifty
little animations and if I then start a
game we can hear our new sound every
time we collect the ball now for the
first time this has been a bit laggy in
our simulator but I can assure you that
on a real device that this won't be a
problem just like we've implemented this
we could of course add more sounds to a
game like a game over sound or sound for
tapping but since you now know how to do
this it would be a great opportunity to
practice this if you do it on your own
if you are interested in making your own
games for iOS you should check out our
course about game development on udemy
in over 15 hours we will teach you how
to make games like Angry Birds Crossy
Road and many more we'll also show you
how to publish your game and submit it
to the App Store you can use the link in
the description of this code to get a
special disc
and if you enjoyed this video make sure
that you give it a thumbs up subscribe
to the channel and let us know what kind
of videos you want to see next in the
comments thanks so much for watching and
see you in the next video</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>