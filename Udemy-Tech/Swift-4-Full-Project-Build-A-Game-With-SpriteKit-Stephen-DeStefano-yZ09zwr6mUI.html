<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Swift 4 Full Project - Build A Game With SpriteKit - Stephen DeStefano | Coder Coacher - Coaching Coders</title><meta content="Swift 4 Full Project - Build A Game With SpriteKit - Stephen DeStefano - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udemy-Tech/">Udemy Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Swift 4 Full Project - Build A Game With SpriteKit - Stephen DeStefano</b></h2><h5 class="post__date">2018-04-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/yZ09zwr6mUI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">in this project we're going to build a
match-three game this is the kind of
thing that first was popularized by
bejeweled years ago players will see a
grid of items to choose from either
aliens gems or balloons depending on
what you chose and it's their job to tap
them in groups to score maximum points
along the way you'll get some practice
with sprites labels more particle
effects touch detection and more and to
get started we need to create a new
project using the template that came
with this course use that template
because it's cleaned out and it saves us
a lot of time from deleting a lot of
stuff doesn't have any special code it's
just a blank slate for us to start with
so take a copy of that and name it
project for match shapes in this game
we're going to show the player a grid of
shapes for them to match each of the
shapes will be a different color which
is where the challenge comes in tamping
groups of three will earn some points
four will learn more and five will learn
even more points and so on and later
will penalize them too if they select
only one item that stops them from
tapping the screen wildly first things
first though we need to place a
background image to go behind the shapes
and I provided a picture for the
background in the assets for this
project so that'll set the scene pretty
nicely so go ahead and drag in the wood
at 2x dot PNG file into the asset
catalog and while you're in there
dragging all the images that start with
the word shape because we'll be using
them too okay now that that's in the
project the next step is to draw the
wood on the screen by adding our first
code to the game steam file this comes
with a few empty methods built in but
for now we're going to focus on this did
move to method this gets called when
your game just finished loading and you
can go ahead and configure it however
you need and this method is the perfect
place for us to create our background
image so I'd like to introduce you to SK
sprite note this is sprite kids way of
loading and drawing images to the screen
we want to load our background image so
we can create the sprite note just by
using its name wood and we don't need to
position it here because the background
image is the same size as the screen
but we do need to give it a Z position
which controls the order in which layers
are drawn in other words which layers
join above or below another in this case
we're going to set it to negative 2 this
way it puts it behind everything else
that we add later so let's go ahead and
configure the background it's only a
couple lines of code here three lines
actually
so go ahead and run the game now and you
should see that the wood background is
filling the whole screen
and there's our wood background and it's
nice that it's working and all but it's
really hardly exciting so let's get on
to making a grid of shapes up next now
that we have a background image the next
step is to draw a grid of objects on top
of it we're going to organize the grid
as a series of rows and columns with
each object knowing its own row and
column this structure might seem
complicated at first but it's important
when the player taps an object in the
grid will be able to read it's row and
column immediately and then use those
values to find other objects that are
nearby to make this easier we're going
to create a custom subclass of SK sprite
node so that we can store row and column
properties and apart from those two
we'll use it just like any other sprite
node this is just for convenience so
let's create a new file
cocoa touch class we're going to name it
item
and we're subclassing ask a sprite note
as soon as we open this up we go ahead
and build it we're going to get this
error right away because we need to
import sprite kit
and as I said all this custom subclass
will do is add two properties that store
the row and column of the item object so
let's add these two properties
and that's it we're done with the item
Dutch Swift file so let's return back to
the game scene file
so we can start drawing some objects
first we need to create some properties
to help us create and store the grid an
array of arrays of item and item size to
store how much space to give each item
plus items per column and items per row
to store our grid size let's create
these properties now
you
and see OLS here is an array of arrays
because it is an array of columns each
of which is an array of individual items
for that column and each object will
have a precise position on the screen
based on its row and column will add a
little X&amp;amp;Y offset to make them Center
neatly on the screen but otherwise we
can find the position of an object by
multiplying its row and column without
item size property this is a helpful
thing to be able to calculate as needed
so we're going to put it in a method
let's add this just after the update
method we'll call it position
you
we're also going to write a dedicated
method for creating individual objects
we'll be using it now to set up the game
but later on too because we need to
create more objects off-screen to refill
the grid when they get removed and this
method will create a new object set its
row and column properties and position
it using the position 4 method and then
add it to the scene for now we're always
going to use this object for the image
but importantly we're going to assign
that string to be the name of our new
object so that we can check for matches
later let's add this method called
create item
and in this method create item we're
setting the item image to this image now
your image could vary depending on which
project variation you're working on the
image could be shape their circle or
balloon - red or it's going to be alien
- blue so one of those three images
you'll be setting - the item image
constant and now the last step for our
grid is to call the create item method
once for each item in our grid and
remember our grid is a series of column
arrays and each column array contains
lots of items so each time we loop over
a row we'll create a new item array to
hold its data and then loop over each
item column and call the create item
method so let's put the following code
at the end of did move to
you
and we're done with this step and did
take quite a bit of work to get right
but actually this was one of the most
complex parts of the game so good job
but wait wouldn't it be nice if all the
objects were different colors like this
game needs
well that's surprisingly easy to do we
can create an array of all the image
names we've added then use a method
called GK random source shared random
dot next in that's going to generate us
a number between 0 and an upper bound
exclusive which in our case will be the
number of images we want to pick from
and with that randomization we can get
ourselves a random object every time
first let's go back to the create item
method
and this actually should be plural
change that to item images and that
should be okay now
okay this line here let Adam in adjust
call this image let's change this a
little bit let's remove this let's
create an array
you
and now we'll have a grid of random
colored images on the screen when you
run it but let me show you what the
create item method will look like if you
chose another path
so this is how the created item
it should look like if you chose the
match shapes path if you've chosen the
pop balloons path your method will look
like this
and if you've chosen the zap aliens path
your create item method will look like
this
so go ahead and run the project and
you'll see how the game has changed much
better and I think you'll agree
in our game players will match grid
items to win and we decide how many
points they score by seeing how big a
color group that they tapped so if they
tapped a group of three items we remove
all three but if they tapped more than
three we removed them all again and
award more points and this requires a
technique called recursion that's a
function that calls itself repeatedly
this is because we don't know how many
matches to expect when the user touches
the screen so we'll make a sort of
flood-fill here's how it works we'll
create a current matches property that
stores a set of items that are currently
matched sets are like a race except they
don't have an order and can only contain
each item once initially we'll give it
the grid item that was tapped we'll find
all the same colored grid items that are
above below left and right of that first
item and we'll call the method for each
of them the method then finds all the
same colored grid items that are above
below left and right of those and so on
until all matching adjacent items are
inside the current matches property and
two parts of that a harder than you
might realize but there's a solution for
both first how can we find the items
that are adjacent to the one that was
tapped let's add the following method
here to the game team
you
as you can see you give that a CG point
where to look for the items and it
returns an optional item and the notes a
method belongs to our scene and that's
going to return a list of all these
sprite kit nodes at a screen location
the thing is we don't want all the nodes
we don't want to destroy the background
for example that's where the flat map
comes in it means only return the nodes
that are actually an instance of item
and once that completes returning items
dot first will either contain one grid
item or nothing at all if we checked
outside the grid the second tricky part
is how we stop the loop continuing
forever think about this if the user
taps a blue item we might look above and
find another blue item there so we
search from that second blue item and
surprised there's another blue item
below although obviously this is just
the first one again this would continue
forever unless we stopped it the first
one finds a second the second flies the
first and the first point a second and
so on
until the game crashes so fixing this is
as simple as using the current matches
set whenever we match an item we'll add
it to current matches so we don't check
it again let's start by adding a
property called current matches
now for the important method the match
item method this will create an array of
items to check called check items and
this will be an array of type item
that's optional because we'll fill it
with results from calling the item hat
method and then we insert the current
item in current matches so it isn't
checked again and then we append to the
check items the results of calling the
item hat above below left and right of
our current item and then we looped over
the checked items reading only non nil
items then check if the item exists in
current matches so we don't check it
again and check if the item has the same
name as the current item and if so call
the match item method again from there
and it's that last part that makes the
function recursive we start matching
whichever item was tapped and then move
to matching items that are adjacent then
out woods further and further so now
it's time to add the match item method
and once we have all matching I
we can remove them from the game well
add a more advanced implementation soon
but here is something simple to get it
started let's say add this method below
the match item method
and finally we start a recursive
function when the user selects an item
on the screen this is the job of the
touches began method which gets called
when the user places one or more fingers
on the screen we don't need multi-touch
here so we'll start by pulling out the
first touch that took place we can find
where that took place in the game by
calling our scenes location in method
and pass that to our item add method to
figure out which item was tapped once we
know that will clear the current match
is set and we'll call the match item
method with whatever they tapped and
then call the remove matches method to
destroy all the matched items so let's
put the following code inside touches
begin
you
so go ahead and give it a try now and
you should be able to tap any color
groups to see them disappear
right now the player can poke holes in
our grid by matching groups but what we
really want are for those holes to get
filled as the items dropped down into
the slots and will create new items at
the top this takes four steps we need to
update the remove matches method so it
deletes items in a specific order that
we need to ensure the user can tap
quickly and cause problems then we need
to update the create item method so can
handle creating new items off the screen
and then we need to create a new method
called move down and that's going to
animate the items falling down and then
it calls the create item method to fill
the gaps at the top let's start with the
remove matches method this is the
current code that we have this removes
everything from the current matches but
it has two problems first it doesn't
remove any items from the columns
property so they don't get fully
destroyed second it destroys them in the
order they were matched which causes
problems when we start removing them
from an array imagine an array
containing the letters a B and C a is at
position 0 B at 1 and C at 2 if we say
remove B from position 1 and C from
position 2 then our program would crash
you see when you remove B from position
1 C would move down to be at position 1
which means when you say remove seed
from position 2 it isn't there anymore
so the program crashes in this game
we're removing items from our columns
and row arrays but if we remove them
from the bottom of columns then remove
items higher up will hit exactly that
problem and to solve this what we'll do
is we'll sort the current matches
property so it's items are arranged by
rows highest first so let's add this
following code to this remove matches
method we'll put it at the start
now the items are sorted safely we can
safely remove them from our columns
array remember this is an array of
arrays we'll get a specific column then
remove the item at a specific row now
let's modify this foreign loop
the next task is simpler we removed
items from our race but we haven't
created new ones yet
this is dangerous cost if the user taps
quickly we might try removing things we
haven't created yet and that will
definitely crash to fix this will
disable touches when the user taps an
item then re-enable it later let's start
by adding the following code to the
touches began directly before the
current matches dot remove all line
and the third step is upgrading the
create item method
we want to make this method handle
creating items off screen and it already
has a parameter for that purpose so
we'll replace the item dot position
equals position for loin with logic if
we're creating the item off-screen then
animate it in otherwise place it
directly so let's go ahead and replace
this line here just delete it and put
the following code in its place
so for creating the item off the screen
then we'll animate it in otherwise let's
place it in there directly in that
comment that says animate in that needs
some more thought here's what it's got
to do we have to calculate the correct
location for the item and then assign
that to the item then adjust its y
position to be 600 points higher so it's
off the screen then we'll create an
animation that moves the item to its
correct position and then run the
animation and when it finishes re-enable
user interaction so touches work again
and sprite get animations use a class
called SK action which animates movement
opacity scale and more even better when
it finishes you can run any other code
you want which is perfect for reenable
interaction so right under the animate
in comment we're going to add that code
for that
and finally we'll write the move down
method which will cause the items to
drop down to fill rows that got removed
we'll write this in two parts starting
with code to move the items that need it
this is done by looping over all columns
then looping over each row in each
column and adjusting each shapes row
property to reflect its new row once we
know that we can use our position 4
method to calculate its screen position
and create another SK action to animate
it there so coming to the bottom to add
this new method called move down
and that comment at the end there is
where we'll add items to each column
until they're back at the numbers
specified in the items per column this
is as simple as looping until the items
per column is reached and then calling
the create item method each time and
appending the new item to its column so
continuing under create new items
you
and now that the move down method is in
place we need to call it in the touches
began right at the end
and with that we're done for now so go
ahead and try it out and you'll see that
when you tap on items that have matching
colors next to it those items get
removed and everything drops down and
you'll see new items being created just
at the top of the row up next we're
going to have some choices to make every
so often we'll give the user a special
item the question is what should it do
that's up next
it's time for another choice every so
often will give the user a special item
the question is what should it do do you
want that item to destroy all
surrounding grid items regardless of
color or maybe make one color of a grid
item become another color or how about
let the player destroy any ten items so
make a choice head over to that part of
the lecture and let's start coding it up
in this choice we're going to randomly
give the player a bonus item that
destroys all nearby grid items
regardless of their color this smart
bomb is going to appear once for roughly
every 25 grid items that the player
destroys which should add some variety
to the game first we need to modify the
create item method so that it will only
consider creating special items when
they're being created off-screen this
allows us to call the create item method
without it possibly creating special
items which is ideal for creating the
initial items in the grid
if the create item method is called with
the start off-screen set to true we'll
generate a random number between 0 and
49 inclusive and if that's equal to 0
then we'll go ahead and generate a smart
bomb item for the player to select so
head over to the create items method
so inside the create item method will
create that smart bomb and again if
you're following the path of the match
shapes your item images array will look
like this if you're following the
project variation called pop balloons
your item images array is going to look
like this
and if you're following the third
variation called zap aliens this is what
your item images array will look like
other than those different images all
the code is exactly the same so let's
keep going let's make a little room at
the top working in the create item
method let's add the following code up
here first before we do that comment out
these two lines the image array constant
and the item image we'll use them in a
moment
okay here's what we're doing here if the
start off screen is true and the user
has matched 25 items it's down to zero
now let's go ahead and create that smart
bomb else if they haven't matched 25
items yet let's go ahead and continue
with creating the images randomly cut
this line out and put it right here in
the else block
and let's go ahead and uncomment this
line now remove the let
because we already declared it up here
let's put this in the else blocks we'll
cut this out and pop that in there
do a builders should be okay okay so
we've modified the create item method to
create the smart bomb
so if starts off screen is true and the
user has matched 25 items let's create
the smart bomb else let's randomly
continue creating the grid item images
and you're going to need that bomb image
now so grab that from the resource
folder and drop it into the asset
catalog that's bomb add 2x dot PNG okay
we're looking pretty good this creates
the smart bomb powerup but we still need
to adjust the touches began to handle it
first let's create a method stub that we
can call let's add this to the bottom of
the file here
okay we have a method in place that will
trigger the smart bomb we need to call
that from touches began let's come back
up there
just before this call here to the match
item method let's make a little room
there
okay so we did a little check to see if
the tapped item is equal to the bomb if
it is let's go ahead and trigger our
special item and our smart bomb powerup
will cause multiple chain reactions it's
going to act as if the user tapped the
items above below left and right of the
bomb at the same time and potentially
destroying many grid items at the same
time and you might not believe this but
actually to make the smart bomb takes
just one line of code in fact it takes
less than one line of code because all
we need to do is modify an existing line
and the line we need to change is inside
the match item method
this line right here if check dot name
equals original dot name and that
restricts our chain reaction so that
only identical grid items get destroyed
when matching adjacent items in the grid
because our smart bomb will destroy
everything around it including other
smart bombs we need to modify this check
so that it evaluates as true if the
names are the same or if the original is
named bomb so let's add an ore to this
check
and remarkably enough that's our smart
bomb code done that was pretty easy
right and we can push this a little
further by making the screen flash white
when the explosion happens to make it
look more impressive and this is only a
few lines of code first we'll create a
white sprite node that fills our screen
which is just one line of code because
you can create sprite notes from a color
and a size and once we have that we'll
set the Z position to one so that it
sits over all the shapes and then add it
to the scene and this is why we added
the trigger special item method earlier
it's the perfect place to make a bomb
flash effect let's head over there
so we're adding our flash effect to the
scene now to make that disappear we're
going to run a new SK action on it
called fade-out with duration and then
call remove from parent when it
completes let's add the following two
lines below this
now go ahead and give it a try and
you'll see that the screen flash makes
the whole explosion effect more
interesting when you click on the smart
bomb it'll blow up some grid items in
its surrounding area and then we'll get
that nice flash and if you like that
flash effect you can keep it or you can
just eliminate that it's your choice of
next we need to start keeping score and
for this choice we'll make one color of
an item become another color so what
we'll do is we'll randomly give the
player a bonus item that makes one item
change its color to another and this
color changer will appear once roughly
every 25 grid items that the player
destroys which should add some variety
to the game first we need to modify the
create item method so that it will only
consider creating special items when
they are being created off-screen this
allows us to call the create item method
without it possibly creating special
items which is ideal for creating the
initial items in the grid and if the
create item method is called with the
start off-screen set to true will
generate a random number between 0 and
49 inclusive and if that's equal to 0
will generate a color change or item for
the player to select so heading over to
the create item method
and just to note if you're working on
the matched shaped project then your
item images array is going to look like
this if you're following the pop
balloons project your item images will
look like this and if you're following
the Zap aliens project then your item
image array will look like this other
than that the code is the same for all
three projects okay here's what we want
to do let's make a little room
let's comment out these two lines here
the item images array and the item image
here and at the top let's declare item
image again
let's add this following check
so what we're doing ears we're checking
to see if the start off-screen property
is true and also to see if the user has
matched up 25 grid items if he has let's
go ahead and create that color changer
we're calling multi if he hasn't let's
come into the else block and what we'll
do in the else block is let's uncomment
this line out our item images array cut
this out here and pop it in the else
block we'll go ahead and we'll start
creating the item images again if he
hasn't reached 25 and starts off-screen
is not true also let's uncomment this
line out to let's remove the led
go ahead and cut this one out and put
this right under your item images array
in the else condition here go ahead and
build it we should be okay move this up
and don't forget to grab this multi at
2x PNG image and drop it into the asset
catalog so this creates the color change
or power up but we still need to adjust
the touches began method to handle this
first let's create a new method to stub
that we can call put this at the bottom
and we can call that directly from
touches began by adding a little code
directly before the match item call head
over to touches began
right here we see this matched item make
a little room and add a condition check
here
so if the tapped item is a multi then we
go ahead and we trigger the special
color changer powerup and now for the
hard part when the user taps the color
changer we'll pick one type of grid item
and we'll change it to a different type
maybe it's blue red or green we'll just
change it to another color and to make
this work we're going to create an array
of all possible grid items and shuffle
it so let's start by adding some code to
the trigger special item method
and a quick note if you're following the
matched shapes project your item images
array in this function is going to look
like this and following the pop balloons
project your item images array will look
like this and if you're working in the
zap aliens project your item images
array will look like this other than
that the code is exactly the same and
take a look at that second line here
that is how you shuffle an array in
Swift and I know it's a little bit
hideous but we have no choice so now
that we have a random array of items we
can decide what to change from and what
to change to this is as simple as
reading the item images at index 0 and
item images at index 1 so let's add the
following next two lines
and once we know what image we're
changing to we need to create a texture
out of it
textures are the image data that sits
behind sprite notes and we needed here
because we want to change the picture
being shown by each sprite node without
having to delete and re-edit sprite kit
textures are handled using a class
called SK texture and you create them
just like creating an sk sprite node
let's add the next line
now for the important part we know what
we're changing from and we know what
we're changing to so we need to loop
over all the rows and columns to make
the actual change happen and the code
for this is exactly what you'd expect
loop over all columns and loop over the
items inside each column and then check
whether the item name is equal to change
from and if so change it to name to
change to and it's texture to change to
texture sprite nodes have a dedicated
texture property that we can adjust so
this code couldn't be much easier let's
put these final two lines in the trigger
special item now
and that was pretty easy right but if
you want you can push this a little
further by making the screen flash white
when the color change happens to make it
look a little more impressive and this
only takes a few lines of code first
we'll create a new white sprite node
that fills our screen which is just one
line of code because you can create
sprite note from a color and a size once
we have that we'll set it Z position to
one so that it sits over all the other
grid items we'll put this at the start
of this trigger method
and to make that disappear we're going
to run a new SK action on it called
fade-out with duration and then we can
call remove parent when it completes
let's go ahead and add two more lines of
code
and that's it so go ahead and run it
you'll see that when you click on the
multi powerup it will change one of the
colors to another color for example it
may take blue and change all the blue
grid items to red which makes the game
easier because you'll have more red
items to click on and you'll be able to
match much more items scoring more
points and when you do click on that
multi it'll also flash the screen white
which gives it a nice impressive look up
next we need to start keeping score and
in this choice we're going to randomly
give the player a bonus item that allows
free grid item selection ten times this
free selector will appear once for
roughly every 25 grid items that the
player destroys which should add some
variety to the game first we need to
modify the create item method so that it
will only consider creating special
items when they're being created
off-screen this allows us to call the
create item method without it possibly
creating special items which is ideal
for creating the initial items in the
grid
if the create item method is called with
start off-screen set to true then we'll
generate a random number between 0 and
49 inclusive and if that number is equal
to 0 will generate a free selector item
for the player to select so let's head
over to the create item method
and we're going to modify this a little
bit and a quick note if you're following
the project match shaped your items
image array up here will look like this
and if you're working with the project
titled pop balloons then your items
image array will look like this and for
the zap alien project this is what your
item image rate should look like
so what we want to do here is let's
create a little room at the top
we're going to change these two lines of
code a little bit to comment this one
out and comment this one out and up here
let's go ahead and declare item image
again
and add this condition
so what we're doing is we're checking
the startup screen property to see if
that's true and also to check to see if
the user has matched 25 items if he has
let's go ahead and create this multi
bonus item if he hasn't let's come into
the else block and let's create our item
images array in there so cut this out
here and pop it in the else block so
then we'll just keep creating the new
items for the grid until they reach 25
then we won't come into the else block
again let's also uncomment this out
let's remove the LED
and cut this line
and put this in the else block as well
let's do a build and we're looking
pretty good let's move this up and then
go ahead and drop in the multi a 2x dot
PNG image into the asset catalog so this
creates the free selector power up but
we will still need to adjust the touches
began method to handle it first let's
create a method stub that we can call
let's add this down at the bottom
and we can call that directly from
touches
by adding a little code directly before
the match item call Ted over to touches
began
right here before the match item call
let's add this condition
so if the tapped item is equal to the
multi then let's go ahead and call the
trigger special item method so we can
create that bonus item and at the start
of this project I said we'd penalize
players if they selected only one item
so they wouldn't be able to tap the
screen wildly well with this special
item that rule changes when they
activate the free selector they can tap
any ten single items without penalty
which allows them to prepare some epic
combos we haven't written the penalizing
code yet but we can still write the code
to let single selection work later first
go ahead and find the multi - background
at 2x dot PNG in the assets folder and
then drag that into the asset catalog
that provides a rainbow background to
show the user that they can tap whatever
they want we put this behind the alien
grid while the power is active so it's
obvious to the user next let's add this
property at the top
that will track how many times the user
can select without penalty if it's less
than or equal to zero they'll be
penalized as normal and there are only
two things we need to do in order to
fill in the trigger special item method
we need to set this property free
selection count to 10 so the player has
free moves and then display the multi
background image so the user knows the
powerup is active will place the image
at Z position negative one which is in
front of the background but behind the
grid items so let's head over back to
the trigger method let's put the code in
here
and that works but with a small change
we can make it more fun we'll make an sk
action to rotate the rainbow then ask sk
action to make a loop forever using its
repeat forever action let's add a little
more code at the end of the trigger
special item
you
and in case you're wondering that dot pi
is equal to 180 degrees so we're
rotating the rainbow 180 degrees every
two seconds and the final step is to
make the rainbow background disappear
when the free selection count reaches
zero we'll subtract one every time they
tap a grid item and if that hits zero
it's time to remove the rainbow we can
do that by using the filter method on
the children of our game scene to look
for the name called Multi background and
then removing whatever we find this
approach means that free selection count
will keep going down as they tap grid
items well below zero but that's okay
and actually helps because it means our
filter method call will happen only when
it is exactly zero so we're going to do
this in touches began
we'll put this directly before the if
tapped name call
you
and that loop is important because there
may be more than one rainbow background
visible so we need to remove them all
and that completes that bonus item go
ahead and run it and give it a try
you'll see that when you tap on the
multi bonus item the rainbow background
will appear and you have ten penalty
free moves and after the tenth free move
you're back to regular gameplay and then
the background goes back to its original
image
okay it's now time to keep score and
this is always important to track the
users score so what we want to do is we
want to add a score integer that tracks
the current value plus some score label
text that shows the scored of the user
however we're also going to write some
logic to create their score each time
they make a move which is where the real
player skill comes in first easy stuff
we're going to display the player's
score using a sprite kit node called SK
label node and you create these using a
font name and position and size them
just like a sprite note the difference
is that they contain text that you can
change it in time let's come under the
properties at the top and let's add the
score label property
that creates the label note but we need
to do more work to configure it and add
it to our game scene specifically we
want to position the text so it sits at
the top-right corner of the screen using
a right alignment so that as the score
goes up it doesn't flow off the screen
let's go ahead and position it and it
did move to
you
and that'll place the label using the
max X and Max Y values of our game scene
which is what places it at the top right
corner and don't run the game just yet
because you won't see any difference we
haven't given the score label any text
to do that we're going to create a
second property called score which will
hold the players current score value
we're going to implement this using a
did set property observer so that
whenever the score changes the score
label automatically updates let's go add
that property back at the top
now we can give our score label its
initial
adding a single line to that did move to
let's add the following right under the
add child to the score label
and that's enough to trigger the
property observers squirrel able to
display some tax and now when it comes
to adjusting the score we're not just
going to add one for every grid item the
player matches that's too easy we got to
make them work a little bit instead
we're going to follow some rules if they
tapped only one grid item will penalize
them somehow and you'll decide that
later on if they tapped only two grid
items will do nothing meaning they
should try harder and if they tap three
or more items then we'll add increasing
numbers of points by using the power
function the pal function calculates
powers in our case of powers of two and
it allows us to award players lots of
points as they match larger groups will
use the pal function to calculate to ^
how many matches they've found so that's
2 ^ 3 if they had three matches that'll
be 8 points 2 ^ 4 if they had four
matches
that's 16 points and so on so they'll
double their points for every extra grid
item they match in the group and to stop
things from going overboard we'll add a
cap of 16 to the number of points they
can score for a single group first let's
say add a empty method stub this will be
called penalize player
now let's add another stump here this
will be called a justice core
you
now all that remains is to add a call to
the adjust score at the end of touches
began
you
so go ahead and give it a try and you
can see that we have scoring in place up
next it's time for another choice do you
want the game to end because we set a
limit that ran out or because we set a
move limit and the player used them all
and that choice is up next
and now it's time for another choice do
you want the game to end because we set
a time limit that ran out or because we
set a move limit and the player used
them all so go ahead and pick a choice
head over to that part of the lecture
and let's code that out for this choice
we're going to pressure the player into
thinking quickly by adding a time limit
to the game we could use another label
note for this but I think it's more
interesting to learn something new so
instead we'll use SK shape node to draw
a shrinking rectangle on the screen
shape nodes render any shape you want on
the screen providing fill color strokes
and even glows if you need them for our
timer bar we're just going to draw our
green rectangle first let's add a
property at the top it'll be of type sk
shape node
you
and that creates a shape note using a
500 by 40 rectangle and as with the
score label we need to configure this
timer and the edit to the scene inside
did move to except this time we'll place
it in the top left and we're going to
set it to a green color but at the same
time we'll remove the stroke the line
around the edge by setting that to clear
so right here and did move to we can
position our timer
you
and all that code is enough to display
the timer so now we just need to write
some code to update it as play continues
and this is going to be done by creating
a game start time property which will
store the time the game got started and
allow us to calculate how much time has
passed and it's going to be empty at
first because we don't know what time
the system clock will initially read so
we'll make it optional let's say that
optional appear
and we need our timer shape-note to
always reflect how much time is
remaining in the game which means we'll
be resizing it constantly and the best
place to do that is in the update method
that gets called by sprite kit every
time it's about to draw a new frame to
the game scene so let's take a look at
that method update
and you could see that this method gets
passed a single parameter which reflects
the current system time if our game
start time property already has a value
then we can subtract the current time
from the start time to figure out how
much time is elapsed and then subtract
that from 100 to figure out how much
time remains once we have the remaining
time we can divide it by 100 and get a
value from 0 to 1 which is exactly what
the X scale property of a shape node
wants this lets us squeeze the shape
node horizontally where 1 means full
size 0.5 means half width and 0 means no
width and of course our game start time
property might not have a value yet and
that's because this might be the first
time the update is being called when
that happens we'll just set games start
time to be whatever the current time is
so the next time the update method gets
called everything works as intended so
let's add the code inside update
you
and that method gets called
automatically so we're done so go ahead
and build it try it out and you'll see
that we have a timer implemented in the
game
for this choice we're going to pressure
the player into making moves carefully
by giving them a limited allocation of
moves and the setup for this is
identical to how we displayed the score
label except this time we'll place the
moves label in the top left corner let's
start by adding two properties
you
and we're using this max function so the
label never shows moves negative one by
accident now let's put the following
code into the did move two so we can set
up the moves label as we did with the
score label
you
and note that uses the min X plus ad to
place the moves label in the top left
corner where's the score label used max
X minus 80 to get it into the top right
corner and so far this has just been a
repeat of code that we've already seen
and amazingly now it only takes a one
line of code to make our move count at
work we need to subtract from our
counter each time the player makes a
move we do that in touches begin
let's put this one line of code directly
after the current matches dot remove all
call
and boom done go ahead and run it you'll
see that the moves label now subtracts 1
every time the player makes the move
counting down from a hundred so now that
we have an incentive for the player to
work hard it's time for another choice
if they select only one item should we
subtract from their score or make all
the grid items change color or how about
take 10 moves off their count and that
choice is up next now that we have an
incentive for the player to work hard
it's time for another choice how would
you like to penalize them if they select
only one grid item would you like to
subtract from their score or how about
make all the grid items change color
well maybe take 10 seconds off their
time go ahead and make a choice head
over to that part of the lecture and
let's start coding that out for this
choice if the player chooses to match
only one grid item we're going to
penalize them by subtracting from their
score how much to subtract that's down
to you but it needs to be severe enough
to dissuade them from doing it unless it
allows an incredible combo in my testing
I found 1000 to be a magic number
just enough to hurt players but still
worth doing if it lets them match 10 or
more grid items as a result and this is
just one line of code right here in the
penalized player function
boom that's done so go ahead and run it
and check it out you'll see that when
the player taps only one grid item
they're going to be penalized a thousand
points
for this choice if the player chooses to
match only one grid item we're going to
penalize them by completely changing all
the shape colors effectively resetting
the game grid changing our shapes is
actually really easy because each sprite
node has a texture property that
contains its image sprite cake textures
are handled using a class called SK
texture and you can create them just
like creating an SK sprite node then
assign them to an existing sprite node
without having to delete and re add them
here's what we'll do we'll create an
array of all the image names on the grid
that we can use then we'll loop over all
the columns and all items in each column
and we'll pick a random number between 0
and the number of items we have we'll
use that image name for our new item
name saying them will create an SK
texture from that image name and we'll
use that for our items texture so doing
all this in penalize player
you
and that's it and again your item images
array will contain these elements if
you're following along in the match
shapes project and if you're working in
the pop balloons variation your item
images will look like this
and finally if you're working in the zap
aliens project this is what your item
images will contain
now go ahead and try selecting a single
shape and you should see the rest of the
grid change
for this choice if the player chose to
match only one grid item will penalize
them by subtracting from their remaining
time and will subtract ten seconds that
seems to be a good number to take off
and you might not have a game timer set
up in your project yet we had that
choice in part seven which was titled
set a time limit and if you didn't
choose that choice that's okay we'll go
ahead and follow the steps to set up a
time limit and give the player 100
seconds that counts down and so when we
want to penalize them we'll take 10
seconds off their time er and if you did
choose that path that means you have
your timer set up so then all you need
to do is put this line of code inside
the penalized player method and that'll
subtract 10 seconds from that timer okay
if you're still here that means we need
to implement that timer so let's get
started with that we're going to
pressure the player into thinking
quickly by adding a time limit to the
game we could use another label node for
this but I think it's more interesting
to learn something new so instead we'll
use SK shaped node to draw a shrinking
rectangle on the screen shape nodes
render any shape you want on the screen
providing fill color strokes and even
glows if you need them for our timer bar
we're just going to draw our green
rectangle first let's add a property at
the top it'll be of type SK shaped node
you
and that creates a shape note using a
500 by 40 rectangle and as with the
score label we need to configure this
timer and the edit to the scene inside
did move to except this time we'll place
it in the top left and we're going to
set it to a green color but at the same
time we'll remove the stroke the line
around the edge by setting that to clear
so right here and did move to we can
position our timer
you
and all that code is enough to display
the timer so now we just need to write
some code to update it as play continues
and this is going to be done by creating
a game start time property which will
store the time the game got started and
allow us to calculate how much time has
passed and it's going to be empty at
first because we don't know what time
the system clock will initially read so
we'll make it optional let's say that
optional appear
and we need our timer shape-note to
always reflect how much time is
remaining in the game which means we'll
be resizing it constantly and the best
place to do that is in the update method
that gets called by sprite kit every
time it's about to draw a new frame to
the game scene so let's take a look at
that method update
and you could see that this method gets
passed a single parameter which reflects
the current system time if our game
start time property already has a value
then we can subtract the current time
from the start time to figure out how
much time is elapsed and then subtract
that from 100 to figure out how much
time remains once we have the remaining
time we can divide it by 100 and get a
value from 0 to 1 which is exactly what
the X scale property of a shape node
wants this lets us squeeze the shape
node horizontally where 1 means full
size 0.5 means half width and 0 means no
a--the and of course our game start time
property might not have a value yet and
that's because this might be the first
time the update is being called when
that happens we'll just set games start
time to be whatever the current time is
so the next time the update method gets
called everything works as intended so
let's add the code inside update
you
and that method gets called
automatically so we're done and all we
have to do is add one line of code
inside the penalized player method so
let's head over there and just put this
one line in and that's it and the syntax
is a little strange because game start
time is optional and what it means is if
this has a value subtract 10 from it
otherwise don't do anything so go ahead
and try it out you'll see that we have a
100 second green timer bar that's
counting down and when the player goes
ahead and matches a single grid item
1/10 of that bar gets shrunk and really
quick so we're taking ten seconds off
pretty quick and if he clicks on 10 of
those that's 100 seconds so we'll be
going to his bar really quick so this is
good incentive to match more than a
single grid item
and no game is complete without some
sound and music and sprite kit makes
both of these easy to add we'll start
with some background music first because
that only takes two lines of code go
into the resource folder for this
project and you'll see these three
tracks to choose from
try listening to all three and decide
which one you like best and copy it into
your Xcode project and all three of
these tracks were created by Kevin
MacLeod and released under the Creative
Commons by attribution license in short
that means you're free to use his music
in your games as long as you give them
credit somewhere and now that your
chosen song is the next code we can use
it in our game by adding two lines of
code to the did move to method I'll go
ahead and add some music
man let's go ahead and add these two
lines right into the did move to method
you
and the magic of SK audio note is that
it automatically loops when its music
ends so our background music will play
continuously now for some sound effects
we want each grid item that's matched to
be accompanied by a short sound effect
and this doesn't need to be looped so
instead of using SK audio note we'll use
a new SK action instead called play
sound file name so look in the resource
folder for the project for match dot WAV
and drag it into the Xcode navigator
here
now let's head over to touches began
because that's when we want to implement
this sound
just below the call to current matches
dot remove all let's add a line of code
and that creates the action and it runs
it immediately causing the sound to play
immediately and you don't need the dot
wav file extension either sprite
configures that stuff out and of course
if we're going to play a sound each time
we match a particular grid item we
should also play something special when
the player activates one of those
special items like the smart bomb go
ahead and drag in the file called smart
bomb dot wave
remember we're triggering those special
in the trigger special item method an
appropriately named method
let's add this line of code right at the
start of the method
and that's all our sounded music
so give it a try and I think you'll
agree it helps bring the whole game
together and all good things must come
to an end and this game is no different
so our final task is to create an
endgame method that shows a game over
message and it starts a new game after a
couple of seconds of past and in the
resource folder for this project I've
included three game ovah graphics for
you to choose from choose the one you
like and drop it into the asset catalog
I'm just going to assume that you've
chosen game over - one at 2x so when you
see me type that out just put in the
image that you prefer we need to make
several code changes but nothing too
difficult and there are two options to
choose from here if your game has
implemented the move limit will we set a
move limit in a previous lecture of 100
moves for the player if you have that
setup I'll show you the code to end the
game with that and then following that
I'll show you the code to end the game
if you implemented a timer so the code
is different for these two variations
that I'll show you both first for the
move limit implementation here's how we
end the game let's create an end game
method first
you
and this map that shows our game over
message on the screen and starts another
game after a few seconds of past and
showing a sprite on a screen as trivial
and this time we're giving it a Z
position of 100 so that it's definitely
join above everything else in our scene
we're using a framework here called
Grand Central Dispatch GCD and that runs
code after a delay with GCD we specify a
deadline by which our code should run
usually written as the current time plus
a certain number of seconds here we put
four seconds and what happens here is
the code will create a new game scene
using the file game scene sks and then
we ask it to stretch to fit all
available space and then presented
immediately and game scene SKS does come
built into echos default sprite kit
project with some extra clutter but in
the template I provided I've cleaned it
out for you and there's our game over
image ready to be displayed but we need
to call this method to display it and
actually the best place to call this is
is in the create item method
here we're creating our items we're
checking if starts off-screen is true
and then we run the animation and then
we enable user interaction when it
finishes that's this line here so what
we want to do is we want to call the end
game and we want to stop user
interaction so right here it's being
enabled we'll keep that enabled but
we'll put a condition statement under
that that checks our moves remaining
property to see if it's less than or
equal to zero if you remember we have
this moves or remaining property if
you've chosen this path and you
implemented the moves remaining feature
so we set it to a hundred so the user
has 100 moves to end the game when they
get to 0 it's game over for them so
let's code that in right under here
so we're just doing those two things
we're setting user interaction enabled
to false so the user can't tap the
screen anymore until the new game starts
and then we call the end game to present
our message and that's all it takes to
enable our game over screen and start a
new game when the moves remaining
property gets down to zero the users
atom moves so the game over label will
display four seconds will countdown and
a new game will start now let's take a
look at ending the game if you've
implemented the timer okay so you have a
timer implemented and we need to end the
game first we need a property that
stores when the game is ended let's
create an is game over property
second we need to exit from touches
began if that property is true an
example we need to stop the player from
touching things if the game is over so
we'll put a guard check right into
touches began
and now we need to write the endgame
method and if you're still with me from
the previous part of the lecture here
you saw me put that method in it's
called endgame I'll put it in again here
because we're going to change it around
a little bit
you
so we're checking with the guard
stateman to make sure we haven't called
this already and we set the is game over
Bowl to true and then we create and show
the game over sprite we give it a Z
position of a hundred that way it
definitely is above everything else and
then we add it to the screen so after
four seconds we're creating a new game
scene from the game scene SKS file and
we make it stretch to fill all the space
by using dot aspect fill so it fills all
size iPads and then we present the scene
immediately so the last thing we need to
do is call the endgame method when the
player runs out of time and the best
place for that is in the update method
so right at the end here of this line
timer dot X scale let's put a condition
statement in here
so if the time remaining is less than it
equal to zero
we're simply call the endgame and the
endgame will stop all user interaction
and then after four seconds present the
new game scene and that's our game
finally complete so go ahead and run it
and you'll see that you can complete a
full game and that's the end of the
final project and I hope you feel that
you've learned a lot in this project
here's what you've done you've drawn
sprites on the screen with SK sprite
node you've added animation with SK
action
you played looping audio with SK audio
node do text with SK label node you've
read screen touches and looked up what
nodes were tapped and you've used GCD to
launch a new game after some time is
passed and a whole bunch more and you
should be really proud of your progress
match three games are usually popular
around the world and hopefully you
already have a few ideas how you can
make this better if not here are some
ideas to get you started for an easy
challenge try adding extra time for the
player if they manage to match sixteen
items all at once for something more
challenging stop the music when the game
ends this is best done by making our
background music into a property then
calling the run method on it with the SK
action dot stopped inside the endgame
method and for a real mental workout see
if you can write a method that
recommends a move to players if they
press a hint button a simple way of
implementing this would be to check the
match count for all items in the grid
then show a yellow square over the item
with the most matches so this brings us
to the end of the project and the end of
the course I hope you enjoyed going
through these sprite kit games there are
a lot of fun to put together and there's
a lot of choices to make you can mix and
match different projects with different
choices so there's quite a huge variety
here and as always it's been a real
pleasure to present to you Paul Hudson's
material there's more great content on
the way so stay tuned and I'll see you
all in future courses</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>