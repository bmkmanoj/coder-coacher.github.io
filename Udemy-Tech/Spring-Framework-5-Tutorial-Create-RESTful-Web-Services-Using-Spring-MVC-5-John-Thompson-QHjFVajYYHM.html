<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Spring Framework 5 Tutorial: Create RESTful Web Services Using Spring MVC 5 - John Thompson | Coder Coacher - Coaching Coders</title><meta content="Spring Framework 5 Tutorial: Create RESTful Web Services Using Spring MVC 5 - John Thompson - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udemy-Tech/">Udemy Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Spring Framework 5 Tutorial: Create RESTful Web Services Using Spring MVC 5 - John Thompson</b></h2><h5 class="post__date">2018-03-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/QHjFVajYYHM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hey folks my name is John Thompson I'm
the founder of Spring Framework guru so
in this video we are going to take a
look at creating restful web services
using spring boots so we are going to be
looking at spring boot 2 and spring
framework 5 inside of that spring
framework 5 actually introduced two
frameworks one is spring MVC and then
the other is web flux in this video we
are going to be looking specifically at
spring MVC and the annotation controller
style based of generating web services
using spring and spring boots so we are
going to be using spring boots which
kind of jumpstart things a little bit
for us and I'm going to show you how we
can rapidly build a web service a very
basic restful web service using these
tool sets so this web server said we're
going to build it's going to be backed
by an h2 in memory database which we
could easily swap out for any other
relational database between that we are
going to be using hibernate for the JPA
provider so JP a Java persistence API
that is the standard or EMM tool for
Java so we're going to be utilizing that
and on top of that I'm going to show you
how to use spring data jva for that so
that provides us a wrap or a real handy
wrapper so all we have to do is declare
our entity and then an interface using
spring data JPA and we have our
persistent services built so spring
boots going to take care of transactions
and setting up the datasource for us
initializing entity scan so that is all
handled by this framework so there's a
lot that we're not going to do but it's
provided by it for us through spring
boot and then finally we are going to
set up a Russ controller I'm going to
show you how to set up several Russell
endpoints and we are going to use Jason
as our language so primarily Jason are
going to be dealing with XML just JSON
in this example but I'll show you how to
get a list of objects back from the
database so we are going to make a full
trip to the - to the database and then
render back JSON to the web client both
and we'll show you how to get you
get it by ID and we'll even show you how
to create new objects in the database
using a post HTTP POST method so we're
going to cover a lot of ground on this
so this is some a very introductory type
level video for creating restful web
services using spring MVC and this is
all built around spring boot 2 and
spring 5 so a lot of really cool content
if you're not familiar with the spring
framework this is a really good video to
see how we can create or how you can
create restful web services using spring
MVC alright in this video we are going
to take a look at creating restful web
services using spring framework in
specifically Spring Framework 5 and
we're gonna look at using the MVC
library with inside of Spring Framework
5 and this is kind of a traditional way
of building web services with Spring
Framework and to do this there's
actually two different ways we're gonna
use spring initializer to create the
project there's two methods I'm going to
show you both of them and the first
method is to go over to a start that
spring dot IO and this is a website that
the spring team is set up for us to
rapidly create projects and what's
really nice about this is that it
creates a set of curated dependencies
using spring but--and a parent pom if
you go back 10 years ago before spring
boot actually spring boots only a couple
years ago but 10 years ago when we're
doing spring applications the mixture of
dependencies was very tricky so this is
a huge step up for us as far as creating
that initial project so I'm gonna go
ahead and use a maven project and
obviously we are going to be using Java
and here I am going to be using the new
new spring spring boot too and right now
at the time recording we're on milestone
7 and this is the supposed to be the
final milestone before we go into
release candidates so right now they're
still doing some integration with the
different libraries of the Spring
Framework but for what we're doing this
is going to be very stable so I'm going
to select that and I'm not going to
change the group idea this and but I am
going to switch over to the full version
right here so we can see the different
options and you can see there's a lot
going
on here but the first thing we want to
do is grab the web and we are going to
play with project Lombok that's a really
cool project that we can utilize and
don't get confused here we're not going
to be setting up rest repository or web
services this option for web services
here is specifically for soap web
services but we're get we are going to
be doing Rus Web Services and scroll
down here and we are going to be using
JPA
and this is going to bring in spring
data JPA so that's some really cool
stuff and for our purposes we are just
going to be using the h2 database so
that's going to be an in-memory database
that's perfectly fine for our
demonstration we're going to show you
how to set things up with that being
that we are doing restful Web Services
we don't need any template engines and
you can see there's a lot of options
here especially for cloud we're not
getting into the cloud stuff right now
you can see this stuff is read out so
it's not ready for spring boot too but
we do want to bring in spring boot
actuator we'll show you some cool stuff
with that so I'm going to go ahead and
generate the project and you can see
here that we downloaded a zip file and
this is one way that we can generate
this so inside the zip file is going to
be a completely configured project for
us so it's going to have stubs of a
couple classes and then the Maven pom
with all the dependencies in it but what
I'm gonna do is show you how to do the
same thing inside of IntelliJ
so let's come back over here to IntelliJ
and what I want to do is save new
project you can see that I have this new
project dialog up and you can see it's
going against the URL of start spring
dot IO and if you look at the chrome
it's the same URL to start that spring
data i/o so IntelliJ is going over to
the spring data i/o website and
utilizing the spring initializer right
under the covers but we can do
everything right from inside of our IDE
now the first thing I want to do is come
up here and select the latest Java
version on my machine that's one five
two and we're going to go ahead and
click on next
and I'm going to change the domain here
if you're new to Java development for
packages and also groups you always use
the reverse domain name so that prevents
class conflicts so long-held tradition
inside the Java community
and we'll just call the artifacts spring
MVC wrestling so we will be using spring
MVC and just go ahead and click on next
and now you can see these options here
these options look a lot like what we
saw on the web here notice uh all the
same or similar option so we should have
everything here you can see the major of
my cloud discovery circuit breaker cloud
messaging so circuit breaker cloud
messaging etc are here and these are
different categories that we can select
from so here we want to grab a project
Lombok
SQL so when you watch APA and h2 and
then down here on ops we wanted to do
actuator and also you can see up here
the spring booth version we want to get
to the m7 version so that spring boot -
which includes Spring Framework five at
the time of recording we are m7 that's
milestone seven a spring boot - this is
expected to be the final milestone
before we go into the release candidates
so at the end of January 2018 they are
expected to release our c1 which would
be the first release candidate for
spring boot - so let's go ahead and
select this the stuff inside of m7 is
pretty stable there just resolving a few
edge cases right now is some of the
smaller libraries but for our purposes
the stuff that we are working out it's
going to be pretty stable going forward
so I'm going to go ahead and say next
and I'm checking just double-checking a
spring MVC rust and I'm happy with where
it's touring on my machine so I'm going
to click finish
and right now IntelliJ is going out
there at downloaded zip file and it's
unzipping it and now it's modding the
project you can see it down at the
bottom of the screen it's going through
its indexing the project downloading
dependencies and now we can see that
everything has come up and you can see
here's the project structure that was
created and let's take a look at the
maven pom here and you can see this is a
data that I provided so customize that
maven pom for us based on the data we
provided in the setup and what's
important here that's really nice about
using spring initializer is that we are
going against the spring boots starter
parent project and what this does for us
is it brings down a set of curated
dependencies you notice here none of the
stuff in here is specifying version
information so that's all curated by
pivotal and the backers of Spring
Framework and now we're getting a set of
dependencies that are going to work
together we're not missing anything so
we're gonna get everything that we need
and before spring boot setting all this
stuff up was a huge headache absolutely
huge headache because it takes you a day
or so to go through find all the
dependencies and then you get in there
like oh I'm missing this chart or oh I
need this version so this really
alleviates a lot of headaches from the
developer because I remember starting
off in the early days and it was really
kind of like the Wild West trying to get
the right mix it would spend a half a
day try and get things set up and down
here on line 63 we can see that we have
repositories and this is because we are
on the release candidates and milestones
so we need to include these as well as
the snapshots for the plugins so that is
our maven dependency let's go ahead and
take a look at this so we can see here's
our project I want just take a look at
the dependencies and show you what's
happening here so we have the spring
boot starter JPA and this actually bring
in spring boot starter AOP JDBC
hibernate
there's a h2 database and what this is
bringing in is a lot of different
dependencies for us and also the spring
boot starter actuator we can see that
the various things that are bringing in
so we get a lot of dependencies right
out of the box by bringing in these
spring boot starters and it also
includes in here we can see that it
brought it in the spring boot starter
test and so right out of the box we are
gonna get things like j-unit and mockito
and ham crust so these are all very
common libraries that we'd have to
include manually if we were not using
spring boots so this is a really handy
thing to to startup aren't going to
collapse that panel and let's come over
here and expand out the source and let's
take a look at what was created for us
so we get the whole project structure
created and we can see that we have a
standard spring boot application and
this is a special class here that this
is going to be used to launch spring
boots so as a spring boot application as
saying run this class so this class is
actually a spring boot configuration
class so we can add in beans and hearing
configuration options you'll see a lot
of demonstrations of that I'm not a big
fan of that I like to keep my
configuration separate I just think
that's a little more tidy to do in your
organization but one thing that does
trip up new people to spring boot is
this class is going to do a component
scan in this package and down so if I
were to create something a spring
component and just guru that spring
framework this class would not pick it
up so I'd have to tell it to
specifically look there but everything
that we're gonna do today is going to be
working from this package so it's
automatically gonna pick that up so
we're gonna get a lot of a spring boot
goodness and a lot of people call it
magic but once you understand the
broader spring framework it's a lot of
it's taken care a lot of stuffs and
making sensible defaults and sensible
choices for things that you'd normally
have to do anyways what spring food it's
going to provide that for us so the
first thing that we want to do for our
demonstration is set up a a domain class
so we're going to use JPA for this so
I'm going to come in here create a new
package
and call that domain
and let's come in here and we'll just do
a customer object so nothing too too
fancy I'm gonna create a new java class
called customer
now to make this a JPA class we want to
do
and energy our Java X persistence
during ID value
the first name
now but I could use IntelliJ to generate
the getters and setters and whatnot but
I'm gonna show you a shortcut and we are
going to use project Lombok and we are
going to annotate this with the data
annotation so what's going to happen
here is let's take a closer look at the
data so I'm doing a command click on
data so this is going to set up getter
setters required arcs constructor two
strings and equal codes so project
Lombok through
it's an annotation processor so it hooks
into the Java compiler process it's
going to create these classes for us so
it's going to set everything up for us
so we don't have to generate all that
boilerplate code project Wambach's going
to do it just by annotating that class
so it's real handy tool to use if you
are following along inside of IntelliJ
you want to come up here the project
settings and go under build compiler
annotation processors and make sure that
you have enable annotation processing
clicked off because IntelliJ may not be
happy I not an eclipse user but I
believe there's something similar inside
of Eclipse where you want to enable the
annotation processing and I'm pretty
sure that there is a plug-in for project
Lombok with eclipse but I am the wrong
person about to ask for tips on Eclipse
because I have not used Eclipse in a
number of years so I'm a big IntelliJ
fan said adios to eclipse a long time
ago so let's go ahead and move forward
with this
and then the last thing we need to do is
set up our JPA entity
so we're gonna bring in the Java X
persistence annotation
so that's a generated value
and generation type identity so that's
going to set up the identity for us
and that is our JPA domain class so now
what we want to do is use spring data
JPA and do that we are going to come
over here and do a new package
call it repositories and this files a
repository model that's how spring data
JPA works and what we're going to do is
declare an interface this time
now you don't have to call it customer
repository that is by convention you
call it whatever you want but remember
more people are going to be reading your
code then writing code so you want to be
nice to the people behind you and file
some very common conventions and one
common convention is to use entity and
then repository and in this case we are
going to do an x10
are going to extend out the JPA
repository and we are going to leverage
Java generics
I'm going to say customer and then the
second property is going to be for the
ID value so this is the entity and then
ID and let's take a closer look at JPA
repository
you can see here this is the spring data
JPA
interface and this is going to give us a
number of options and we're going to
utilize those so this really out of the
box gives us basic functionality and
what happens is spring data JPA is going
to provide us this class at runtime so
we are declaring the interface I'm not
going to get too far down the rabbit
hole on spring data JPA but the way it
works is you declare the interface and
then it's going to provide the
implementation and we're going to be
able to utilize that now underneath the
covers spring data JPA is going to take
care of all the mapping commands of
working with the database through
hibernate so that's completely
abstracted from through us so we are
going to be able to use just the ORM it
is an absolute huge time saver for us so
let's go ahead and move on with that and
another good design pattern here so now
we have our domain and our repository
what we like to do here is also create
up a service layer so I'm going to
create a new package called service
and let's come in here and create a
customer service
and let's do that as a interface now
let's go ahead and declare what we want
so we want
I'm going to pour that
so we want a method in there to find the
customer by ID and let's also get a list
of customers
I'm not gonna pass anything in on that
but now we'll have to two methods here
where we can get a find a customer buy
an ID or find all customers now let's
come in here yeah I'm gonna do an alter
and IntelliJ is giving me an option to
implement the interface so I'm gonna go
ahead and do that and this is a Java
Convention so we've created an interface
and typically you're going to do impl
that is a pretty common java convention
now some people don't like using AI empl
if you only have one that's perfectly
fine but if you had others like here I
might be doing a JPA
simple but I could also be doing a
MongoDB temple so I could have different
persistence stores that I'm going
against and abstract it from my
controller layer but in this case we are
just going to be running against JPA so
I'm just creating a very simple
implementation of it so let's go ahead
and move forward with this IntelliJ it's
gonna set that up now let's go ahead and
work on the implementation of this so
the first thing is we're gonna want to
get a handle on that repository for us
so it's coming here
and I am declaring a final variable
instructor for that and we are going to
pass in the customers repository so the
only way that we can instantiate this
class is to inject in a custom
repository it looks like a typo in
repository my mistake there so let's go
ahead and work on the implementation
list so we are going to return back a
customer
so pretty simple implementation here and
then also here
to return back a full list now I'm not
showing you some of the options that as
far as like paging and sorting we are
just doing two very simple
implementations here and this will set
up our data layer and let's go ahead now
we are going to be backing it with an h2
database so our database isn't going to
have anything inside of it so let's go
ahead and work on setting up that
database and a real common design
pattern with the Spring Framework is to
use an h2 database and you want to
initialize it with data so I have a very
handy way to do that and the Grails guys
used to call it bootstrap ADIZ to have a
bootstrap class for this so let's go
ahead and create a new package here
and I'm just calling it bootstrap
I'm going to create a job
and we'll just call it bootstrap data
and if you're not familiar bootstrap is
from simulator to booting up a computer
system and it's from American slang
where there's a saying of pull yourself
up by your bootstraps so it's getting
getting yourself up in the morning by
your bootstraps so it's this is a kind
of initialization routine and we are
going to use a spring boot specific
class so there's a couple different ways
to initialize data here we are going to
do this through spring boot this that
you can do a pure spring way by tapping
into application events but spring boot
does have a couple options for us we are
going to implement command line runner
make this a component so the spring
context will pick it up you can see that
IntelliJ saying that's a red line so
let's go ahead and implement methods so
it takes in this run so now a class is
happy but we want to initialize data so
remembering our customer service
implementation so we brought in the
customer repository so I am going to
copy that over
so remember cut and paste is bad so
don't be doing cut and paste
let's go ahead and do that in control
and for
instructor allow IntelliJ to do it and
if you're familiar with spring notice
I'm not doing an auto wire here so in
spring I think goes for three as long as
you have required rx constructor in just
one constructor the spring is going to
go ahead and auto air that for us and
let's fix this customer repository name
here so coming here to refactor rename
you'll fix that little typo there that
starting bug me so you can see that
IntelliJ did go in and and redo that so
for this
will regenerate the property name
and so now what we want to do is create
a new customer
I'm gonna pause the video while I type
this out I don't think you need to watch
me setup pojos okay I've jump ahead a
little bit and fleshed out creating some
customer objects so you can see they're
on line 25 I start grading three new
customer objects of no big mystery there
you can see Michael Westen Sam axe and
Fiona Glenanne I'm not sure if Glenanne
is spelled correctly or not
but if you watching my videos you know
that I am a fan of Burn Notice so these
are the characters out of Brno so we're
gonna use them as our test customers in
this example but anyways online 25 30
and 35 I'm creating new customer objects
and then you can see on 28 33 and 38 I
am saving those using the spring data
repository interface now you can see
that it's been set up there and I come
into the class on line 23 I am doing a
smile put a floating customer data and
then you can see down here I'm saying
that we loaded X number customer so
let's go ahead and run this right now so
I'm gonna go ahead and run the spring
boot rust application IntelliJ brings
that up by default so let's go ahead and
start that up and I just want to make
sure that we are getting that output
so that spring boot does start up you
can see its shadow from hibernate you
can see I made one small mistake here so
it started and stopped so nothing's
really going on here and there's a very
simple explanation for that so if we
look at the Maven palm at the actuator
and JPA h2 but I forgot to bring in the
spring boot starter web so let's go
ahead and rectify that now
and we can see there's several different
options here love reactive web slugs and
web we just want the web and that brings
them this traditional spring MVC so
let's bring that in and would tell
IntelliJ to import the changes and what
this is let's let's examine that a
little closer
we're got nested under
there it is I had to do a refresh of
spring boots starter web is there and
this bring in a couple different starter
so we get Jason Tomcat that's the
important one also spring MVC but the
way spring boot is going to be working
especially at spring MVC as it brings in
an embedded tomcat servlet container and
Tomcat wasn't there on the class pass so
spring boot didn't configure it so we
start it up and shut down right away so
let's go ahead and run this again and
we'll see a much different result
so we'll see it start up and then stay
running because we are running inside a
servlet container
now we can see there's additional
chatter there in the log files we can
see that it set up some end points for
us and then we can see that it also
loaded customer data so we did bring in
spring boot actuator so we do have a web
application running right now even
though we have not defined a controller
spring boot actuator does give us some
endpoints we can see here that I'm
clicking on the health and we can see it
as bringing up application we are seeing
that the database is alive and we are
good at dissipate so these are different
health indicators available for us
through a spring boot actuator if I was
writing like rabbitmq do we do we see
metrics on rabbit if I had other options
in there there's a number of different
options that we can add to the health
endpoint so it's a very rudimentary
application but a real nice thing about
having spring boot actuator installed as
it does give you a health check at
endpoint so if we need it to monitor
that application with some type of
enterprise tool to make sure that it's
alive this is an endpoint that we could
utilize so now we do have our
application up and running I am going to
shut it down for right now and let's go
ahead and collapse the Maven so
basically we've set up our back-end
persistence tour we have a service that
will respond to it but what we have not
done yet is we have not created the
controller so let's go ahead and do that
now so I'm going to come in here and
create a new package
and you might I guess I might call it
controllers
now some people prefer to call us
endpoints not necessarily wrong
controllers isn't necessarily wrong it's
a personal preference so now I'm going
to create a customer controller
now what we wanted to hear is spring nBC
has annotation called rest controller
and this annotation I believe is also
available inside of spring web flex but
that is the reactive stack for web
applications which we are not addressing
today and so this designates this class
as a rust Controller so now the first
thing that we want to do is get a hold
of our service so now let's go ahead and
do
so that that's our customer service
installation I can do a command and for
a constructor and that's going to set up
our class so now by annotating this as a
rest controller and providing this
constructor what this is saying is it's
a spring component so the rest
controllers is bringing stereotyped so
this is going to get wired up as a
spring beam and it's bringing when it
creates this class it's automatically
going to checked in an instance of our
customer service and I'm getting a
little red squiggly there so let's
double check something and I actually
did make mistake here so this actually
needs to be annotated with service so
that is another spring stereotype so now
spring is going to manage this component
also as a spring bean and let's come
back back over to our controller and now
you can see a little squiggly one away
so now that is available there and now
let's go ahead and set up our first
mapping
so we returned back a list of customers
so pretty simple implementation you know
a little red line there because I forgot
the return statement so this is gonna be
the method that we are gonna use for our
customers but we want to make this a
little more interesting because there's
no mapping to it so we've set up our
spring object at this point but we have
not done anything to set up the URL
mapping so that's what we need to tackle
right now
so there's an annotation for get mapping
so for get request coming to the
controller we are going to invoke this
method but we have not provided any URL
mapping now one thing I do like to do is
come up here and do public
and we'll call us a string
so very good habit and development is
the don't repeat yourself principal so
the base URL for this API something
that's going to be utilizing a lot
throughout it now some people like to
externalize this into a properties file
so it can be overridden at runtime I
personally think declaring a static
final string is ideal for this because
that string is going to change and
chances are this URL value is probably
not going to change but some of those
going to be changing in different
environments the attic externalize it
but here this is perfectly fine to do so
now it sets up our string for the URL
that we won't be utilizing
and let's go ahead and map this so we do
that with a request mapping annotation
and by doing this we are setting up for
every method on this we are declaring
that the space URL is going to be
utilize so any requests coming in the
space URL is going to be invoked now I
do have the option if I want to do
something more complex I could do
request mapping on the method level but
here what I'm saying is when I get a get
request to API slash B 1 slash customers
I'm going to invoke this method here so
let's go ahead and test this no I'm
going to go ahead and run the
application
now let's go up here and we can see
you can see right here that that has
been mapped so if this is the debug
output from Spring MBC so we have mapped
API v1 customers to method get on that
method of the controller now let's jump
over to postman is a handy tool for
testing web requests
let's go over here to API v1
I'm gonna go ahead and say Sun that and
now we can see that I did in fact get a
list of customers so we can see that D
value first name last name Michael
Westen Sam accent Fiona Glenanne so that
is our a pretty simple object model from
the customer so that is a list of that
but what if we wanted to get a customer
buy ID so I'd like to be able to come in
here and do now let's get the ona she's
far cuter than Michael anyways so let's
do that and now Fiona isn't found
because this has not been mapped yet so
let's come back over here to IntelliJ
and implement that method
it's a pretty simple method that we are
implementing here so we want to return
back customer service find buy ID and/or
get pass in that ID value
now it's pretty simple implementation
but we need to set this up a little bit
so as far as how we want this behave so
let's do get mapping
and now what we want to do is come in
here and do slash squiggly ID
so this is telling spring to look for
the ID value in the URL so that this is
setting that up and get mappings kinda
like a hybrid of annotation so it it
includes request mapping so I could have
done I get mapping and request mapping
but it's a little cleaner to do it this
way just with the ID value there you'll
see you'll see examples of both where
the user request mapping and get mapping
or just request mapping and specify that
as a parameter inside of the annotation
for a request mapping so there's a
couple different methods that you can
see out there get mapping different
annotations were added to I want to say
spring 4.2 maybe 4.1 I could be use a
little bit wrong on that but now what we
need to do here is we set up this a path
variable but we have not done anything
here so what we want do is come in here
and say
path variable and now what this is doing
it's telling spring and this is by
convention because I'm using the ID
value so that's the name of the method
parameter and it's going to match this
so that that is a convention so as long
as I do the squiggly ID and have a
method property called ID now I could
have two or three of these with
different names obviously as far as path
variable so you can't get a pretty long
list of pass variables in there so
you're not limited up as long as they
have unique names spring it's going to
handle that so that that's the way
that's working as far as ID so now what
this is saying it's when we come in here
and we have a value so API v1 customers
slash and an ID value we are going to
parse out that ID value out of the URL
and take it from a string to a long and
pass at in terrifying customer by ID and
then return back that customer object so
let's go ahead and because I'm not
running spring boot dev tools right now
I'm going to have to bounce a spring
boot for that those changes take effect
and again while this is starting up we
are recycling the container we are going
to bring back the up to h2 database and
we are going to insert data again from
our bootstrap class a very handy thing
that we're doing here so let's go ahead
and toggle over to postman now
and we'll do a send on that and we got
an internal server error
let's see what happened there
so it looks like we turn back an all
type let's take a quick look here
no we did not okay I took a closer look
at this error and this kind of weird one
and this was my mistake and let's come
back over here and take a look at the
implementation so we are getting a lazy
initialization error and this is a
mistake in my implementation over here
to service implementation so I did a get
one so if I come in here and take a look
at that
this is returning back a reference and
by that it's a little bit different so
this is a pretty technical difference so
I am doing a get one which turns back a
reference and that is not what I want
because that reference needs to exist
inside of the hibernate context so
hibernate does a lot of lazy
initialization which is really cool so
things aren't pulled out of the database
until they're needed so in this case
that's what's happening in this case but
I'm getting outside of the hibernate
context and that's a bad because we
don't want that but I do want to get
that object and the proper thing to do
and this is a mistake on my part when I
wrote this
let's rather than get one I want to do
find my ID
and that's going to return back and
optional and I'm just gonna say get
so that's my mistake there and this is a
change inside of spring data so spring
data prior to spring five would return
back just the object and rather than an
optional so that I'm going to do
something bad here and just say get so
that that is bad and intelligence give
me a warning but that's just for
demonstration purposes and the more
recent versions of spring data they are
returning back the optional so you do
have to work with the Java eight
optional class which is a very good
thing to do and I do expand upon this in
my courses but for here let's go ahead
and work with that and I'm going to go
ahead and reinitialize us so we'll
restart spring bootie and we'll come up
with a fresh database and get our code
change in there and we can see we are
back up and running let's toggle back
over to postman and now if I come in
here and do this I was actually running
in the debugger
come back over here we can see that
female Atlanta is returned properly now
one more thing that I want to show you
is how to create create a new object so
we'll go ahead and create a customer
let's jump back over to IntelliJ now and
we will implement that so first thing
I'm going to work backwards this time so
let's go to the customer controller
and actually I'm gonna stop this we
don't need that running right now yeah
we'll stop him so I'm at the customer
controller so let's go ahead and
implement that at the controller level
and I'll work backwards
so we're going to create a method that's
going to take in a customer object and
we want to return back a customer
service say a customer you know they'll
take in the customer object
and let's go ahead and decorate this now
before we do the implementation of that
method so what I want to do is a post
mapping so remember in our our restful
api has to create a resource it's going
to be through a post and now I'm going
to show you one additional annotation
here because of post mapping we want
that to return back a HTTP created
status so we are going to use the
response status annotation
it is them so that sets that up to
return back that so and what this is
saying so when I do a post against API
v1 customers of a customer object we are
going to call customer service to a safe
customer which we have not implemented
yet and we are going to return back a
new customer object or the persisted one
so let's go ahead and implement that you
know hitting option enter and I'm going
to go ahead and create that method you
can see that IntelliJ automatically
added that for us
go ahead and implement methods and in
this case what we want to do is custom
repository
save customer so that's gonna save that
new customer entity for us so you can
see how easy it is working with spring
data JPA
to go ahead and persist that so let's go
ahead and start this and we'll test that
out I'm going to bring this up normally
now we are up and running and we have
three customers
and let's go ahead and copy those
and now what we want to do as a post
you
I'm going to paste in that Jason and we
don't want that that I devalue
and I can't remember the Jesse's last
name from Burn Notice call it Jesse
someone I really don't remember his name
remember Jesse if I don't remember his
last name so now we're gonna post this
object so we have first name last name
and this is adjacent object so we're
gonna do a post against this endpoint so
let's go ahead and send that now and we
see that it did not bind properly so
we've got a first name last name and
null
over here and do it get on that and
these null properties are here because I
made a very simple mistake so what's
happening is I did do the post against
that and I did return back the ID value
but what happened here is if I come back
over here to my controller take a look
at this
customer but what happened was I didn't
tell it to find it out of the hospital
so now with the request body annotation
that is going to tell spring MVC to find
it and underneath the covers what spring
is doing it does wire in the checks and
Jason library and it's going to do all
the the marshaling and on marshalling
for us kind of seamlessly through the
framework so let's go ahead and try this
again I bet it's gonna work a lot better
this time so come back over to postman
we'll go ahead and use Jessie Agana
and again I'm gonna do a post against
the localhost:8080 API v1 customers
which is API that we've mapped and we
are doing a post let's go ahead and do
that
and we need to set the content type
and now I forgot content type in postman
now we can see that ID for Jessie
someone was created so now let's come
back over here and you can see this is
where it was that's persisted from the
time that I did not have that the
request spotting annotation on the
method so let's go ahead and send that
again and now we can see that is there
come back over here
some indeedy now if we come back over
here to five
we can see that that data is in fact
persisting okay let's jump back over to
IntelliJ right now and I'm not going to
implement the remainder of the request
methods but let's go ahead and recap
what we did here so let me stop this so
we can get the screen back shut that
down so first we went in and created the
customer entity so this is a standard
JPA entity no big mystery here so this
is using JPA
and with spring boot and the way we're
configured we are using the hibernate
implementation of JPA underneath the
covers the spring boot does bring that
in and configures it automatically for
us the next thing we went in is we went
in and created the JPA repository and
this is out of the spring data JPA
project which gives us a very robust
toolset as far as working with JPA
entities now I only scratch down the
surface of the capabilities of spring
data JPA it's a very robust project and
here I'm just going to demonstrating a
very very simple application now the
next thing is we went in and created our
bootstrap class and bootstrap data this
class is going to run because it
implements the interface command line
Runner and command line Runner is a
spring boot interface and that basically
says run me on startup so that's what
this is going to do it is a spring
components of what happens is the spring
context comes up injects in a customer
repository again that spring data JPA
and spring data JPA is providing us the
runtime of that because we only provided
the interface in our configuration so
spring data JPA is going to provide us
the implementation at runtime and that
gets injected into this class which
gives us our persistence operations
that's been getting persisted to an h2
in-memory database that's way we are
configured because we've brought in h2
and spring boot is providing us all the
auto configuration for working
whispering h2 database if you notice we
did not set up a data source that is
being provided by spring boot for h2 so
this sets up and creates our initial set
of data for us and then finally
we went over here and created our rest
controller the rest controller sets up
the mapping then the request mapping and
I did use a public static final string
so I don't repeat myself when I need to
use this string value again and here we
are injecting in a customer service
implantation and it's pretty common
pattern here to create a service like a
service wrapper over your spring data
repositories now I do have examples out
there where I've just worked with the
repository directly but here let's take
a quick look at the implementation of
that the service implementation is for
working with their repositories and in a
real business application typically you
are going to have your web logic in the
controller and any additional business
logic here inside of the service layer
so the service layer is where you want
to be implementing that business logic
not inside your controllers I've seen
this principle really abused we're doing
crazy things inside of customer
controllers like obtaining database
connections and everything inside a
controller and I'll talk about violating
the single responsibility principle very
very bad practices but here we have a
very simple application I'm just trying
to show you a few best best practices
along the way of using the
implementation of us a customer or a
service layer so service layer is going
to be a wrapper around our persistence
layer which in this case is the spring
data repositories so let's come back
over here to the customer controller I
have mapped out three different paths on
those controller of URLs so everything
is utilizing the base URL API v1
customers and when you're dealing with
restful api is a lot of times you're
going to see an api b1 and then a v2 and
v3 s @ api valve's you'll change the
version to allow clients to use the old
version then switch over to the new
version when they're ready now here like
I said we have three implementations if
you just do a get against that URL we
are going to get a list if you do it
with an ID value we're going to return
back an entity with that ID from that
query and then finally I
host mapping so that we can post Jason
to that end point now URL value so in
this case I am posting that and you can
see on line 37 I initially forgot to do
request body there but that request by
the annotation says look at the request
by oddity and parse out what's there in
those case we are expecting to see a
customer object in the form of Jason
posted against that end point and we are
going to parse that into a Java object
using Jackson underneath the covers and
again spring Buddha's configuring
everything for us so that happens
drooler framework that gets parsed from
jason to a POJO a customer pojo and then
we pass that pocho into a service layer
and of course that goes to spring data
JP a hibernate gets persisted to the
database through JP a slash hibernate
and then we return back the object to
our client alright I hope you enjoyed
this video we did cover quite a bit of
ground and I wasn't able to go in-depth
as I would like to on some of these
subjects if you are interested check out
my course I do have a very large course
a very popular course on Spring
Framework 5 on you to me and that is
available where I do explore these
topics and a lot more depth where I can
get into this in a lot more depth but
this is a great overview I hope you
really got a lot of benefit out of this
you can see how quickly you can utilize
the tooling of the spring framework and
leverage the framework to really deliver
a lot of great functionality quickly
once you become comfortable with this
you can really knock out a lot of
business functionality and this is why
this is just an example why that the
spring framework is so popular in the
enterprise today a lot of companies are
adapting the spring framework because
developers are have a great toolset to
rapidly develop enterprise class
software</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>