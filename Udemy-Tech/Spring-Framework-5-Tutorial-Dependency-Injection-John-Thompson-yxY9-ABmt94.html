<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Spring Framework 5 Tutorial: Dependency Injection - John Thompson | Coder Coacher - Coaching Coders</title><meta content="Spring Framework 5 Tutorial: Dependency Injection - John Thompson - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udemy-Tech/">Udemy Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Spring Framework 5 Tutorial: Dependency Injection - John Thompson</b></h2><h5 class="post__date">2018-03-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/yxY9-ABmt94" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright one of the core tenants of the
spring framework is dependency injection
so this is kind of like from the early
days of spring where it really got its
root set dependency injection is right
at the middle of the Spring Framework
Spring Framework is much much bigger
much more robust than just dependency
injection but if you're new to Spring
Framework dependency injection having
such a robust tool set around performing
dependency injection is really a game
changer in how you develop applications
it gives you a tremendous amount more
flexibility as to how you can compose
your applications and have the framework
make a lot of decisions for you at
runtime and it gives you a capabilities
now I've seen people do to kind of see
injection very poorly they may clad bad
choices and the the tool set does give
you a lot of versatility but you can
shoot yourself in the foot with it just
because you do have these options
doesn't mean that you should use these
options just like anything else it's a
tool set you have options and the
framework doesn't always prevent you
from making bad choices so when we talk
about dependency injection and object
oriented programming there are three
primary ways that you can do dependency
injection one you can wire a dependency
through a property so set that up right
on our property then we can go to a
traditional Hojo where we have getters
and setters and then do a dependency
injection against a setter and allow the
setter to set that properties and set
the property through a setter also a
perfectly valid approach and then
finally being that Java is an
object-oriented
we can take that dependency and provide
a constructor for it and build that
object at runtime when we construct that
object use the constructor to set that
dependency so now there are good things
and bad things about all these different
approaches but ultimately there are some
best practices that you do want to be
utilizing in this video I am going to go
through these different types of
dependency injections show you examples
of each
and we're going to evolve from probably
a very poor practice to what I consider
and most of the spring community
considers best practices around
dependency injection so that this is a
short video but I hope you find a lot of
information about how you can write
quality Spring Framework code in your
own applications we're in this video I
want to talk about dependency injection
and some of the best practices within
the Spring Framework and there's a
couple different things that we can go
through as far as dependency injection
goes and I've seen a lot of very very
bad practices in use with dependency
injection so I've set up a little demo
for us to work with here and it's gonna
be a little live coding here as I go
through the different examples but what
I have here is I'm emulating a
controller and what we have is a
customer controller and he heart wires
and a customer service and I'm using
that as a pseudo database object just
kind of pretending here that it's a
database object and that customer
service takes in a database URL a
username and password and to be honest
I've actually seen this in production
databases where they have things
hard-coded like this and it is awful to
work with so this is a very very bad
practice that I'm showing you here as
part of the demonstration we're gonna
refactor this too to make our lives a
little bit better so let's go ahead and
I'm gonna come in here and do an alt
enter and we are going to create a test
for our controller and we want to test
that customer method and let's do a
setup method as well and we're just
going to use JUnit for
and we're going to bring in the spring
runner
and call it a spring boot test and this
is going to bring up the full context
and so let's bring up the full context
and here let's go ahead and checked in
so I'm going to say customer controller
and let's run this test
and that's actually
all right I actually use the wrapper
type there
it's a pretty simple toast here we're
not really going to test anything this
is more to exercise the spring context
so I want to bring up the spring context
so let's go ahead and make sure that
this does run and what I'm expecting to
do is spring the spring context is going
to come up and it is going to pick up
that bean the customer controller and we
can see here that I did get the customer
from the database so just to show you
the implementation my customer service
so I have a print line there getting a
customer from the database which is
showing down here getting customer from
the database so that did run so that
that's going to be our test to make sure
that the class runs as we go through
these different options for auto wiring
this up so let's come back to our
customer controller now it as you may
know there's different types of
dependency injection the simplest would
be do
and and do it that way and let's go
ahead and what I'm gonna do is say now
that we've refactored this customer
service to managed objects so we're
going to manage our customer services
managed object using the spring
framework so this goes away
and now I can say Otto why are those
and here customer service
now there are ways to manage this inside
a spring I'm not going to get into that
so let's pretend that spring is going to
take over the management of this
component so spring is going to provide
us a customer service so I don't have to
do all that configuration so this here's
a good practice because we're getting
away from setting the database URL and
passwords here so that has now gone from
our projects I'm just going to delete
that all together and we're going to
pretend that this object is being
managed by the spring context because
now I've set this up as this as a
component and actually let's call it a
service make a little more sense here
and these annotations here controller
component and service those are spring
stereotypes and those stereotypes behave
the same so people ask what the
difference is for these three there is
no underlying difference to the Spring
Framework they function the same there
are more to express the intent so I'm
calling this a service the other thing
I'm calling a controller and the core
thing to remember is Spring pretty much
to reach them the same underneath the
covers but they are spring mashed
components now so they get brought into
the spring context so now I've declared
that as a service and let's take a look
at the customer controller so controller
is a spring component and we are auto
wiring it by a public property this time
so we are going to go ahead and auto
wire that so let's go ahead and run our
test and make sure that runs
till runs now that is a public property
and what you'll see sometimes is people
do this I notice I don't have a
constructor but now I have a private
property now do you think this is going
to run let's take a look
so this does in fact run this runs
properly and the prominent here is and
I've seen some very experienced people
do this and actually on production type
code and I actually got in a
conversation with somebody that actually
has a fairly good bit of spring
knowledge and we talked about this and
like that's a pretty poor practice
because basically what you're saying is
that you don't want to be able to run a
unit test against this class while you
could but it'd take a lot of hacking and
underneath the covers what the spring
framework is doing is it is using
reflection it's probably going in and
adding a constructor for that property
to the class at runtime so it's going to
use reflection for you to go ahead and
modify that class at runtime provide a
constructor for it and inject that
property for it because it is private
property so it can't be accessed from
the outside world without doing
something like that for you as a
developer you're not gonna go through
all that rigmarole of handling that and
that becomes a real headache to do if
you want a unit test it so when I see
somebody auto wiring private properties
like this directly I think that is a
very bad practice something you
definitely do not want to be doing and
because your effect I'm saying I don't
want unit test this class so the stat
this test in this class is going to be
managed by a spring framework always if
I want to test it I'm gonna have to do
it inside an integration test like we
are here because just a quick reminder
when I bring up the controller test once
I add this this is now an integration
test because we are bringing up the
spring context is no longer technically
a unit test so now it's an integration
test because we are bringing up the
spring contest and you can see even
though I have a very very light project
and I am on a practically brand new
MacBook Pro and it's a screamer and it
still takes 44 milliseconds to run that
one test now if you had hundreds of
tests this would be very slow something
that we don't want on our tester you
know test should be light and fast so
that's an important contrast here so
what we could do here is one thing we
can do is make this come back here
and we can come in and add in a setter
for this
and now we can move it down there we'll
move the auto air to the the Sutter and
let's go ahead and run this and this is
an example of auto wiring by a setter so
this is Sutter based dependency
injection and this isn't a bad bad habit
I used to prefer using Sutter based
dependency injection and actually the
older realreal older versions of spring
used to be a little bit buggy with
constructor based dependency injection
and that's not necessarily a bad thing
that was just the nature of spring at
the time but now the constructor based
dependency injection is really rock
solid and I'm talking like conversion to
5a spring so this is a long long time
ago I hope nobody listening to this
video is actually using version two five
of spring still but I digress here the
important part here is that you do have
the option to use setup based dependency
injection and this is a much better
scenario than auto wiring the private
property directly now we've created a
setter for it we don't have a getter so
the setter in theory the class at run
time could be modified so that that is
the one downside we can also create the
class without that dependency injection
so that that is another downside of that
so how do you get around that what we
can do is get rid of this
and come up with a constructor
now we can auto wire buy it in the
constructor so this is an example
constructor based dependency injection
so let's go ahead and run that
and we can see that runs properly so now
now this is a better scenario because we
are running the constructor and we
cannot instantiate this class now one
argument again for the setter based
dependency injection is by default just
the framework will throw an exception if
you do not set that a dependency now we
are enforcing that dependency to be
injected through the principles of
object-oriented design so this is a much
better scenario and but something in
that a downside of this here is this
could be modified somehow at runtime so
it is good to make this a final
so now we have a final property so let's
go and make sure that still runs and
what final says is that just as a
reminder inside of Java's is that once I
set this it cannot be changed so this is
a final variable it gets set inside the
constructor and it can never be changed
so if I try to set it make sure let's
see if this
so now we can see that this is squawking
inside the compiler and the Java
compiler actually complains so that
IntelliJ is yelling at me and so it's a
Java compiler so I can't go ahead and
break that so you know there are ways
around that so but ultimately Java
wolves will smack you down and say no
you can't do that so that that is a good
habit to get into now there's one other
thing here that I'm not too happy about
we are going against a concrete type so
this customer service here is a class so
this is a concrete type we are not going
against an interface so interfaces are
something good to code against generally
especially in dependency injection
because right now with the dependency
injection we are expecting an instance
of that class that type to be injected
but now let's go ahead and change this
so I'm going to come in here do a right
click on that and come to refactor
interface and I want
name a customer service so I want to
rename the original class
so it do customer service imple rename
that and we want to bring that member in
so now we can see that IntelliJ did the
refactoring for us so our implementation
of that has been named customer service
imple we implement the customer service
interface customer service interface has
the one method get customer from dB now
let's take a look at our customer
controller and you can see nice job
IntelliJ we are still using the
interface here inside the customer
controller but now we are doing
dependency injection of the customer
service inside the controller so let's
go ahead and make sure this still runs
you know we we can see that as in fact
running okay so now one thing that we
can do here is drop the auto wired
annotation so I think it was in spring
4.3 that became optional now that we
have a constructor and it doesn't matter
if it's a hard type or an interface with
this but as long as you have one
constructor and the property so the
constructor can be resolved by the
spring framework it will do the
dependency injection for us so let's go
ahead and run that
so now we can see that that does in fact
run okay so for the reasons that I've
outlined here you can see now that we
are doing dependency injection against
an interface through a constructor so
this gives us the most flexibility and
is the best in terms of adhering to
object-oriented principles because we
are injecting against the interface so
if I want to test this class outside of
that hard implementation type I could
easily create a mock of that I could
create an own test instance of that when
I am running that customer service
implementation I set it up to be against
a mock database it could go against a
web service ago to against message queue
so we could have scenarios we are
injecting multiple implementations for
different use cases within our
organization so it gives us a lot of
versatility both at runtime in our
production environments and as the
application of valves and for testing it
also gives us a lot of versatility in
testing because now if I'm testing that
customer controller it's pretty simple
if I'm using j-unit and mockito I can
easily create a mock and inject that in
a test time and I don't need a
full-blown integration test or if I'm
using Spock I'm a big fan of Spock also
that has a very nice mocking framework I
could do that or I could even write my
own implementation for a test so there's
a lot of versatility having that
interface there and this here what I'm
showing you here is where you have a
private final variable it's using an
interface and a constructor that is
setting that property inside of for your
dependents ingestion that is generally
accepted as a best practice when you are
doing dependency injection both with
Java in general and the spring framework
ok this wraps up my video on dependency
injection and the best practices around
a dependency injection using the Spring
Framework as you can see my preference
is to take a final property set that up
and use a constructor to set that
property so you cannot create that
object without injecting the dependency
and that dependency once it is set it
cannot be changed so this is considered
a best practice
a little maybe a little league overly
paranoid for some it does lose some
flexibility I've had people ask well
we're doing constructor and we are
injecting a lot of dependencies and
that's a lot of parameters and checked
into the constructor yes it is and if
you do have that case and that is a
specific use case where you are
injecting a number of classes and into
your class through a dependency
injection like wow that's a lot of stuff
to inject in your constructor you might
want to take a step back know maybe this
class is doing too much and maybe you
need to refactor your code because
having a lot of properties in a
constructor is a code smell because
chances are and that object is doing
more than one thing so remember a single
responsibility principle where your
classes should have one functional life
if you have a half-dozen dependencies
being injected in through a constructor
or setters something doesn't smell right
with your code so you should step back
and take a look at that but generally
inside the spring community and the
generally accepted principle right now
is to use what I showed you to use
dependency injection against an
interface have that as a final property
and inject it in through a constructor</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>