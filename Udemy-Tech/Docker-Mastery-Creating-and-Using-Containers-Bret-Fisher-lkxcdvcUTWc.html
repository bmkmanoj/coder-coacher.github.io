<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Docker Mastery:  Creating and Using Containers  - Bret Fisher | Coder Coacher - Coaching Coders</title><meta content="Docker Mastery:  Creating and Using Containers  - Bret Fisher - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udemy-Tech/">Udemy Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Docker Mastery:  Creating and Using Containers  - Bret Fisher</b></h2><h5 class="post__date">2018-03-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/lkxcdvcUTWc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hey docker fans I'm Brett
this hour-long video is from the first
few sections of my docker mastery course
on udemy I've mashed together 9 lecture
videos into this power-packed youtube
video for learning how to create and
manage containers on your local machine
it starts off assuming that you have
docker installed so if you don't have
that latest version on your machine then
check for a playlist in this YouTube
channel called the best way to install
docker I put that there specifically for
the various OS is like Mac Linux and
Windows and how to make sure you always
have the latest version on them so have
fun and keep on doctoring
all right since this is the first
lecture in this section I'm going to
cover real quick with this whole section
about and that's containers containers
are the fundamental building block of
the docker toolkit and that's one of the
first things we're gonna learn we're not
gonna build images or do any advanced
stuff until once we've learned what
containers are how to run them a little
bit of how they're different from a VM
and other basic functionality of a
container so the first thing we want to
do is make sure that we have the latest
version of docker and it's working once
we get through that in this lecture
other lectures we'll talk about how to
start containers how to do manage
different aspects of a container start
it stop it delete it create it that sort
of stuff and we're going to use engine
decks for all that and engine next is a
really basic web server that is going to
be easy for us to use just to learn the
docker commands and how to do docker
container stuff after that we're going
to jump into some networking basics so
you'll learn docker networking and how
the containers talk to each other and
for this whole section the only real
requirement is that you have the latest
version of docker installed and then
it's working properly so in this lecture
we're gonna make sure real quick that
that's setup correctly so in order for
the docker command line to work properly
you need to make sure you're in the
proper terminal for your operating
system
I'm going to be using Mac so I can use
either terminal or I term - the two
popular choices on the Mac and then on
Windows if you're on docker for Windows
you'll use PowerShell if you're on the
docker toolbox you'll use the QuickStart
terminal that comes with a docker
toolbox and if you're on Linux you'll
just use a Linux shell of your choosing
these are all things that I talked about
in the previous section for your setup
of your operating system so if you have
more questions just look at those videos
but let's get started the first command
is docker version and this command
simply returns the version of your
client that's the CLI that we just used
and the server also
called the engine and the engine is
running back in the background on your
machine on Windows it's usually called a
service on Mac and Linux it's usually
called a daemon and what is happening
here is our docker command line is
actually talking to the server on my
machine and then returning its values as
well as the client values themselves
ideally they should be the same but they
don't have to be the same versions and
you want them to be the latest version
as possible if you have an older version
like 112 or 113 you definitely want to
make sure that you go to the previous
section and get the proper versions
installed because we'll be using a lot
of new features that are only in the
latest versions the fact that I did get
returned information from the server
validates that I can talk to the server
and then it's working properly if you do
get an error there that means maybe you
need to do a sudo docker version if
you're maybe on linux or possibly your
doctor isn't actually running and you
maybe need to go to the previous section
set up videos to make sure that the
docker is running properly now let's get
a little more information out of our
docker engine if we do a docker info
it'll return a lot more stuff than just
the version it'll actually give us a lot
of the details about our configuration
and setup for our engine some of these
are obvious like the number of
containers you have running or possibly
the number of images you have stored in
docker but a lot of this other stuff may
not make sense now and that's fine we're
going to go through a lot of it
throughout this course now you might be
wondering what are all the commands you
can use in docker and you can get a list
of those by simply just typing docker
and hitting return you'll see a long
list down here at the bottom and this is
not actually the full list because if
you notice up here at the top we now
have this management command so starting
in early 2017 docker realized that we're
getting so many commands down here in
this list where I would just type docker
space and the command that there were so
many of them that they needed to create
an easier way to organize all these
commands and that's when they created
management commands and that creates a
format where you have docker space the
management command and then the sub
command so you will see throughout this
course that we're trying to use a little
bit of both
we mostly will use the new model of
docker let's use an example here of
container run and that's the new format
of that command but since the beginning
of the docker project docker run has
usually been the way that we type that
command it's just recently that the
docker container run has become the new
way to run that command now the cool
thing about docker is that it's really
focused on backwards compatibility so
the docker run will probably work
forever but new commands that we get are
not going to be using this docker
command value it will be using docker
space command space sub-command values
so each time I use these commands we
will explain what they are and I will
show you possibly the old way of doing
it and the new way of doing it depending
on whether the command has that option
so it'll start to make sense as we go
through this course ok even though we
had a very short lecture and it was
pretty simple let's just review real
quick those commands the darker version
command is the one I always use first on
a new docker system just to make sure
that my client can talk to the engine
and then I'm running the version that I
would expect secondly docker info gives
me a lot of the configuration values out
of the engine just to make sure that
it's set up the way that I expect and
lastly we talked about the command line
structure the old way still works so for
older commands that have been around for
the last four plus years they still work
with docker command and then the options
but for new commands going forward
docker is creating a new model of the
management commands with docker space
command space sub command and the
example we used was docker run one of
the most common commands you use in
docker
where the old way was docker run but the
new way of docker container run also
works and you can decide how you want to
use those commands whether you want to
use the old way or the new way because
they both will still work
okay let's do some fun stuff in this
lecture we're gonna quickly talk about
the difference between images and
containers and then we're gonna jump
right into playing around with a
container we're gonna start it we're
going to stop and remove it and do some
common administrative functions and then
we're going to check out the container
logs and the processes running in our
container so Before we jump in real
quick it's good to know the difference
between an image and a container an
image is the binaries and libraries and
source code that all make up your
application and the container is a
running instance of that image now you
can have mini containers all based off
the same image in this lecture we're
going to be using the open source engine
X web server and so we'll be starting
our containers based off that engine X
image and we get all of our images from
registries registries are kind of like
what github is - source code image
registries are for container images and
the default one for docker is docker hub
which you can check out at hub docker
comm will play more with that later but
for now be aware that these two things
are quite different and in the next
section we're going to jump into images
but for now let's focus on containers
okay now we're going to start a new
container and use some docker commands
to manage that container docker
container run publish 8080 nginx don't
worry if you don't know with all that
means we'll go through it all in a
minute I'll hit enter switch over to my
browser and type in localhost there we
go our engine X server is listening and
I can hit refresh several times and
you'll see the log entry is happening in
our command line here now what did we
just do in the background the docker
engine actually looked for an image
called nginx
and it pulled down the latest image for
Engine X from docker hub and then it
started it as a new process in a new
container for us to use the published
part of the command exposes my local
port 80 on my local machine and sends
all traffic from it to the executable
running inside that container on port 80
and since nginx is a web server it's
going to default to port 80 and the
traffic just forwards automatically
through my browser to my local host and
into that container but we don't always
want this thing running in the
foreground inside of our command lines
so let's hit control C and I'm going to
hit the up arrow and I'm going to back
up a little bit and type in detach now
detach tells docker to run it in the
background and we get back the unique
container ID of our container and and
every time you run a new container you
get a new unique ID so if we go back
over to our browser and hit refresh a
couple times you can see that it's still
running so let's do a command to list
our containers our container LS and
you'll see the one that's still running
here it's matching the container ID of
the command we just ran and you'll see
the container it's still running that we
just started so let's stop that
container real quick docker container
stop and then the container ID and for
the container ID I only have to type the
first few digits enough for it to be
unique and it stopped it now if I do a
docker container LS you'll notice
nothing shows up so the LS command only
shows by default running containers if I
do an LS - a I get back - now why do I
get two so when we ran each time the
docker container run command it started
a new container from the
engine X image and you'll notice on the
right here that there's these random
names like we didn't use these how did
we get these so the container ID is
always created for us and the name is
also required to be unique and if we
don't specify it it will be created for
us so we can always name something
ourselves but if we let it pick its own
it's actually an interesting little bit
of history around docker is that they've
had this for years now that that name
will randomly be generated from an open
source list of adjectives and the
surnames of notable hackers or
scientists and it's pretty funny
sometimes you'll get some really
peculiar names in there so let's create
a new one docker container run put in
our publish and our detach but this time
we're going to specify a name I'm gonna
call it web host Engine X and now if I
do my docker container LS - eh you'll
see three containers the one we just
started and it has a name of web host
and then the two that we previously
started and then stopped now since we're
not running this in the foreground
anymore we can't see the logs so let's
go back to our browser and I'm going to
hit refresh a couple of times to
generate some logs and then back to our
terminal and I'll do docker container
logs web host and it'll spit out the
latest logs in the web host now there's
a couple of options you'll want to play
around with on the logs command to have
it follow the logs automatically or it
can just capture the last few log events
so that you don't end up with the entire
log file being dumped to your screen and
we can also use some other Ducker
container commands to check on that
running container
so we can try docker container top and
you can see the help there that lets us
know we need to specify container name
web host and you can see this is the
process running inside the container now
for nginx we don't need to necessarily
know all this but it's just interesting
to note that with nginx there's actually
a master process and then it spawns
worker processes based on the
configuration and again we can always
type docker container and - - help to
get a list of all the commands we could
try on that container now let's clean up
what we just did so let's do a docker
container LSA and it's going to list all
three of my containers now I'm actually
going to remove all three at the same
time sometimes sub commands of docker
can actually take multiple values so in
this case I can do a Ducker container RM
and then I can actually specify 6 3f 6 9
0 and OD e oops 0 de so I got an error
what just happened here all right the
first two were safely deleted the third
one it's telling me I can't remove a
running container because it's a safety
measure it makes sure that you don't
accidentally remove the actual process
that's still running so if you do a
docker container LS you'll see we still
have one running now I could actually do
a docker container stop to stop it first
and then remove it but I'm actually
gonna do a docker container RM - F for
force and 6 3f and there we go now if I
do a docker container LS - eh you'll see
that's nothing's there so now we've
cleaned up our mess okay so in just a
matter of minutes we were able to use a
single command to download and run an
engine X webserver with a default
configuration listening on port 80 and
then we were able to create several of
those
play with the logs and then remove the
containers to clean up what we had done
so in this lecture let's have a quick
discussion about what actually happens
in the background when we run the docker
container run command so there's a
misconception sometimes that docker is
really just running containers and
that's its main job but there's actually
so much it's happening in the background
that it does in addition to those
containers executing commands so when we
type docker container run in the
background it's actually going to look
for the image that we specified at the
end of that command so you remember when
we typed Engine X at the very end that
was the name of the image we wanted to
run as a new container so it's gonna
look for that locally in the image cache
if it doesn't find it there that is
going to hop over to docker hub which is
its default remote image repository by
default it'll look it up there and
download it and store it in the image
cache so if we didn't specify a version
and we didn't we just typed in nginx you
can actually type in Engine X colon some
version and we'll get into that in the
next section
but without specifying a version it'll
just choose the latest then once it's
got that image and ready to go it's
going to start up a new container based
on that image it's not going to make a
copy of the image it's actually going to
just start a new layer of changes right
on top of where that image left off and
it's going to customize the networking
so it's going to give it a specific
virtual IP address that's inside a
docker virtual network and it's actually
going to open up the port that we
specified if we didn't specify the
publish command the - - publish then
it's not going to open up any ports at
all and since we did the ad colon 80
that's telling it to take the port 80 on
the host and forward all that traffic to
the port 80 in the container and then
that container finally will actually
start using a command specified in the
docker file which we'll also talk about
the next section so you can actually
change a majority of these commands from
the command line these are all really
defaults we can actually specify
the version of our image we can specify
different ports or the default command
to run when it starts that container but
since we had a very simple command it
just used a lot of defaults coming out
of the box so as you can see definitely
a lot going on the background and later
on we're going to dive into each one of
these in separate sections so if you go
looking around the web for a definition
of what a container is you'll often see
people comparing containers to virtual
machines and true there are some
similarities but there's so many things
that just aren't the same I want us to
back up and say let's not even compare
them to virtual machines because really
they're just a process there are process
running on your host operating system in
our case Linux and let's take a look
because it's super easy to understand
the concept that's really just a
restricted process inside our host
operating system and nothing like a
virtual machine so let's start up a
Mongo database
we're gonna call it Mongo we're gonna
run it in the background and we're using
the Mongo image alright we can see that
it's running and docker also has
something called docker top that it will
let me list the processes that are
running inside a specific container and
we'll see there that we have a single
process called Mongo D and we can see it
sped which is its process ID and we can
also do that from the host because this
is just a process running on our host
operating system
any host tool that I would use to look
at processes is going to see this
process so we can use a process list for
example I'm going to list all of them on
the system and you'll actually see in
here if I search one of them is called
Mongo D you'll even notice that it's
actually running under a different
process ID than the rest of the system
and that's just because of the security
layers that we'll talk about with
containers and how they're a little
different than regular processes running
on the host but we can clearly see here
this is a process on the host it's not a
it's not hiding inside a virtual machine
that we can't get access to it's right
there in front of us if I stop this
container
you can do a docker PS you'll see it's
not running we can do a docker top Mongo
it's not actually gonna give us anything
because the containers not running and
if we do a PS aux and we search for
Mongo again we're not going to see
anything highlighted in that list right
I'm actually searching inside my
terminal an easier way to do this would
be to do PS aux and then use grep which
is a filtering tool that will look
through the output and we can tell to
look at the word Mongo and the only
thing it's actually going to find is the
command that I just run to search for
the word Mongo it's listing that we
would expect to see another command here
right below it another output of a
process if it was indeed running and so
we can start back up again docker start
Mongo because that container was still
there just not running in the background
kind of like a stopped process and we
can do a dock of PS again and it's back
to running again we can do a docker top
long ago again and see that there's one
process again running inside the
container it's just been started new
it's only been up for six seconds as we
can see here and if we do a PS and UX
grep Mongo you'll see that I'm now
actually seeing the Mongo deep process
in this lecture requirements are that
you know how to start a container and
what we're going to be doing at the
command line here is running docker
commands to understand what's going on
inside a running container and there's
multiple ways that we can see what's
going on in there we've covered the top
command which is a process list of
what's happening inside the container
but there's other stuff we can do as
well so we can use the inspect command
to actually see the details of how the
containers started and how its
configured we can look at these stats
command which actually gives us a view
of all of our containers and the
performance statistics for each one of
them in a real-time stream so let's dive
in okay in order to look at some of
these commands and how they act with
containers we're going to need to
actually start a few containers so the
first one we're going to start is an
engine X container like we've done
before docker container run - d - - name
let's call it nginx and we're gonna use
the nginx image okay and then the second
one we'll use is another my sequel
server so docker container run - D - -
name my sequel and we'll also need to
specify the environment variable like we
did before so random root password
equals true and then the my sequel image
note that with the my sequel image as
you can read on duct or hub it'll tell
you that you have to specify one of
three options for the password either
you can specify a password in the
command line or you can let it use no
password or you can do what I've done
here which will have it on first boot
actually create a random password like
we did in the exercise a few minutes ago
okay so if we do a docker container LS
we should see two running containers
great so we've used Ducker container top
before and if I just specify the my
sequel you'll see that it actually lists
the processes running inside that
container
and we can do the same thing docker
container top engine X and that lists
the processes running in that container
but another way to look at how this
container is configured when it was
started and all of its metadata config
we can actually use the inspect command
docker container and SPECT and then just
say my sequel and we get back a JSON
array of all of the data about how this
container was started and a lot of this
will start to make sense as we go
throughout this course and as you can
see it is obviously a lot of data about
this container but as interesting as
this config data is it doesn't tell us
anything about the active container and
what it's doing so let's use the docker
container stats command and if I give
you a - - help you can see that it
allows us to actually specify a
container to only show that or if we
just leave it empty and just type Ducker
container stats we actually get back a
streaming view of live performance data
about our containers now unfortunately
it only shows the container ID not the
container name but you can see by the
CPU column that every few seconds
something's changing now obviously in a
production environment you're gonna have
a more complicated monitoring and
performance solution for tracking all
this stuff but it's really great for
local machines where you need to make
sure that you're not exhausting your
machine's RAM because maybe you have too
big of a database or they're not filling
up the hard drive because of an
out-of-control process so this is a
quick command to just make sure that
everything is with in its memory limits
and that it's not using a ton of
networking and the block i/o is actually
for your disk performance and as you can
see these containers aren't really doing
anything because we haven't asked them
to do anything now to get out of this
control see and let's do a quick docker
container LS so that we can match the
container ID up with our stats command
so you can see that my sequel server was
the one actually using almost 400 Meg on
startup okay just to recap but we
in this lecture we actually first used
the docker container top command to list
all the processes that will be running
in a single container and then we got
into container inspect and container
inspect we can actually see how the
container was run what was run with it
and what the environment and options
were when it started and then containers
stats which is sort of a live updating
ability to see all containers and what
resources they're taking up as they're
running okay so requirements for this
lecture are that you know how to start a
container from previous lectures and we
just finished the last lecture talking
about seeing what's going on in a
container from the outside and this is
all about getting into a container to
mess around with the inside so there's a
few commands that we can use the first
one is container run with a - IT and
we'll talk about how the - IT works to
actually get a shell inside the
container and then for running
containers that you want to run a second
process you can also use the container
exec and we'll show several examples of
that and then along the way we're gonna
actually mention a few differences
between a regular Linux distribution
like Ubuntu for installing on a virtual
machine or on hardware and then what
those links distros are like inside of a
container let's get started so looking
into a container from the outside is
very handy at times but one of the first
questions that people often ask me is
how do I get into the container and
actually do things in it live from the
command line and sometimes people
confuse this with wanting an ssh server
inside their container so they can SSH
into it but we don't actually need to do
that because we have several commands at
our disposal that let us get a shell
inside the container itself while it's
running and the first one is just the
docker container run command but we're
going to specify a few extra options
we're gonna do a - I T now the - I T is
actually two separate options and if I
just show the help real quick you can
see that the T
actually gives us a pseudo TTY or a
prompt similar to what you would have
through SSH and then if we scroll up to
I and that's really what allows us to
keep that session open so that we can
keep running more commands so if we do a
docker container run - I T and then run
another engine X let's call it proxy and
then we're gonna have to specify an
alternate command if you remember at the
beginning of this section where we
talked about the format of the docker
command line when you're doing a Ducker
container run as you can see through the
help here at the end after the image you
have optional command and arguments that
you can send into this new container
that you're about to start to tell it
what to run the image has a default
command in it that we will see later how
to configure but if you wanted to change
what was run on startup you can do that
right from the run line so let's just
say bash because Bash is one of the
common shells that you would usually
find in a container that'll give you a
shell to work with and look at that I'm
in a prompt now you'll notice my prompt
says root which is the user that the
container started as it doesn't actually
mean I'm root on the host it just means
I'm acting as root on the container and
that number after it is actually the
container ID so if I do a LS - al I get
a full listing of everything where I'm
at and you can see that I'm in the root
path of the file system inside the
container so I'm actually looking at all
the files inside the container which is
based on the engine X image and from
here I could go change config files I
could download packages from the
internet and do just about any common
administrative thing that you would do
from a normal shell so to get out of the
shell when you're done I'm going to type
exit like you would with any shell and
now that container has stopped if we
actually did a docker container LS you
would not see it there remember we
called it proxy so I have to do a - a
and it's there now see the command that
it run the default command for an engine
decks container is to run the engine X
program itself but when we typed our
last command we change that default
program to actually be bash which gave
us our shell and when we exited the
shell the container stopped because
containers only run as long as the
command that it ran on startup runs and
since we change that to bash simply
exiting bash quit it now what if I used
a full distribution of Linux instead of
actually doing the engine X let's do a
full Ubuntu and it's actually going to
download the kyboot to image and place
me in the prompt of this new container
if you've ever used Ubuntu you know
about the apt package manager and so I
can use that here just like I would in a
standard Ubuntu server and I could
actually install something apt-get
install - yes curl now the thing about
Ubuntu and other distributions inside a
container is they're usually very
minimal a live CD or a download of the
ISO of Ubuntu which you would normally
put on a virtual machine is gonna have a
lot more software installed by default
then a Ubuntu container which is really
a very minimal version of Ubuntu that
you can always add more software to with
the apt package manager so now this
running container has curl installed and
I can use it just like I would on a
local machine and once I exit the shell
again it will actually stop the
container docker container LS and you
notice I don't see it and there's that
Ubuntu image that we just ran now if I
started that container up again it would
have curl installed in it but if I
created a new container from the Ubuntu
image that different container would not
have the curl command line installed now
what if we wanted to rerun that
container and get bashed right back in
it again well we could use the docker
containers start command now you'll
notice it's slightly different when we
start an existing container
but it's similar to the IT it's just an
AI and then the name of our container
ubuntu no notice we're right back in it
and I can curl Google again
and it works and if I exit it stopped it
again now what if I want to actually see
the shell inside a running container
that's already running something like my
sequel or nginx well we can do that too
and that's using the exec command docker
container exec and you can see we have a
few options here and the most common one
is let's say I want to jump into the my
sequel container because I need to do
some administrative stuff on the my
sequel itself I could do the IT again
and then the name of the container and
then the program I want to run and in
this case again it's bash and I'm now in
the container with my sequel I can
actually do a PSA aux right inside the
container which lists the processes and
this will of course show me the my
sequel daemon that's running in the
background as well as the bash process
that I'm currently sitting in and as
well as the PS command that I just ran
and in this shell I could jump into my
sequel itself with the my sequel command
line and you'll notice when I exit this
bash shell doing LS my sequel is still
running because the docker container
exec actually runs an additional process
on an existing running container it's
not going to affect the route process
for the my sequel daemon so let's try it
one more as you can see here this is
very useful for jumping into containers
when you need to troubleshoot or when
you need to change something slightly on
a running system as well as using
containers of different distributions to
give you the environment you would have
if you had a full machine like a Ubuntu
or an Alpine now what's alpine we
haven't mentioned Alpine before Alpine
is another distribution of Linux but
Alpine is designed to be very small it's
actually only five meagan size
if I do a darker pull Alpine that will
pull down the latest Alpine image and if
I do a darker image LS you can actually
see how small the Alpine limit is
compared to the EBU - so the neat thing
about Alpine is that it also comes with
its own package manager and so you'll
see Alpine is an option on docker hub a
lot in the next section when we go over
images and docker hub but for now let's
do a bash shell inside of Alpine sucker
container run IT Alpine bash now what
just happened here why did I get an
error it tells me that it's starting the
container process and it caused the
executable file bash to not be found in
the path and what that really means is
that Bash isn't in the container and
this goes back to the concept that we
can only run things in the container
that already exists in its image when
you started it or maybe something that
you've added later through the exec or
run commands but in this case how would
I get in the Alpine image well Alpine is
so small that it doesn't actually have
bash in it but it does have Sh so we can
replace the command with SH which is not
quite as full featured as bash but does
get us right into the container and if
you were to search Alpine Linux on the
internet you would learn that it's
package manager is a PK and we could
actually use that to install bash if we
really needed it okay just a recap real
quick of what we learned in this lesson
so we learned about the - IT option for
container run which gives us the
equivalent of an interactive shell to
actually do things in the container as
we would if we were SS aged into a
server of some sort then we learned a
new command for Ducker container exec
with the I T that does exactly the same
thing as run but it does it on an
existing container that's running not
starting a new container and last we
learned a little bit
Alpine and how that's different from
major Linux distributions and how it's
actually like for Meghan size and ideal
for container images requirements for
this section include understanding how
to start a container and then basic
tcp/ip networking concepts such as
subnets and IPs and ports and firewalls
you don't have to know all that but
it'll definitely make it a lot easier
for you to understand this section which
is focused on conceptual stuff but
before we actually get into a bunch of
the command line stuff in the next
lecture so I just want to remind you
about the - P option on your container
run commands which exposes the port on
your machine but there's actually a lot
more going on in the background of
docker networking that will talk about
docker has this concept of batteries
included but removable which basically
means that the defaults are pretty easy
and common to work with but that you can
change a lot of the options under the
hood and we'll quickly check out in this
lecture the container port command that
gives you a quick output of what ports
are open for that container on your
network and then we're going to break
down some of the concepts of docker
networking and virtual networks and how
packets flow around the network and
we'll finish up with a network diagram
showing how containers talk amongst each
other and how that's different from the
- P of exposing them on to the physical
network so when you actually start a
container you're really in the
background connecting to a particular
docker network and by default that is
the bridge network as we'll check out in
a minute and then each one of those
networks that you would connect to
actually route out through a NAT
firewall which is actually the docker
daemon configuring the hosts IP address
on its default interface so that your
containers can get out to the internet
or to the rest of your network and then
get back but we don't actually need to
use the - P when we have specific
containers wanting to talk to each other
inside our hosts
for example if you had an application
that had a sequel server and a PHP
Apache container those two containers
should be on the same network and
they're able to talk to each other
without actually opening their ports up
to the rest of your physical network and
if you had another application that was
unrelated that let's say was using Mongo
and nodejs you could create a network
for that so that they could talk with
each other without using the - peat to
expose them to the network but they
couldn't actually talk to the other
network where you might have an
unrelated app running but the thing is
is that just about all those settings I
described they're actually changeable
and this brings up a good saying that
docker likes to use that is batteries
included but removable and you'll see
that throughout this course that a lot
of times there are defaults that just
work out of the box you don't even have
to specify them you just notice that
things are configured in a sort of
standard way but a lot of these options
are configurable either at runtime or
even changeable after the fact and we'll
see some of that take place here when we
play around with the network's some of
the things that you can actually change
would be creating multiple virtual
networks maybe one per app or different
ones based on different security
requirements and you can actually just
like in the physical world have two
physical NICs on a real computer you can
actually have two virtual networks
connected to one container or you can
actually have the container talked to no
networks and you can skip any of the
virtual network configuration that comes
out of the box and actually use - - net
equals host and you'll lose some of the
containerization benefits but in some
cases it might be required and later on
we're actually going to get into docker
network drivers and there's this whole
plug-in ecosystem around docker that
extends the capabilities of docker to a
lot of third-party tools but in this
case we're gonna look at a couple of
different docker network drivers and how
they might change up our networking and
give us new abilities and this is really
just scratching the surface there's
actually networking concepts throughout
this course where we'll be talking about
more advanced topics of multi hoe
private networking and concepts like sub
interfaces and so on but for now let's
dive into some command line stuff as a
quick review let's look at the dash P of
our container running commands so docker
container run if you remember when we
first ran a container we used the dash P
to expose port 80 of our nginx
and that took the left side which is the
host port and forwards traffic from that
port into the port 80 of the container
and if we did a docker container port
web host it actually shows us in a nice
easy format which ports are forwarding
traffic to that container from the host
into the container itself but we haven't
talked about the IP address of the
container and so you might just assume
that the container is using the same IP
as the host but by default that's not
true and we can easily get the docker IP
of that container by inspecting it and
we're going to use the format command or
option really which you'll notice is
actually has a pretty specific format
for how to filter incoming stuff now you
can always use the grep command which we
used earlier to filter out your text
output but the format the - - format
it's actually a little cleaner and
consistent so we do two curly brackets
and then once we get used to knowing the
format of the config file
we know that network settings IP address
is the actual node of that JSON output
that we want to look at and then web
host oops that means I didn't spell it
right IP a DD and that's not what I
expected if I was going to use the IP of
my host because I know my max on my
local network and if I do and I have
config on my Mac I just know that the IP
address is on my home network or a one
- 168 subnets so that's interesting that
they're not the same network so why is
that let's see if it'll make more sense
if I draw it out so if my host operating
system is connected to my network so
this is my network physical network and
then this is the Ethernet interface on
my host machine in my case is my Mac
there's a little firewall in there that
does several things and it blocks all
incoming traffic coming in from the
network so that everything is blocked by
default so I would call it a firewall
and any traffic that's coming out from
my containers is gonna be NAT 'add by
default so it's acting like a pretty
common edge firewall on a network but
there's this concept of the virtual
networks and by default you'll see a
network called bridge or docker 0 and
when you start a new container we'll
call it c1 that container is attached to
that network that virtual network and
that virtual network it's automatically
attached to your Ethernet interface on
your host so that it can get out now in
our case when we just launched that
engine X we gave it a - P 8080 and that
told it over here to open up port 80 on
my ethernet interface on my Mac and
forward anything coming in to port 80
through that virtual network to port 80
in that container now by default when I
create a second container it's put on
that same bridge network and those two
containers can talk freely back and
forth on their exposed ports but unless
I specify the - P no traffic coming into
my internal networks here is going to
get to my containers now I can actually
create more virtual networks and call
them what I want so I'm going to call
this one
net my app let's say and let's say I
connect two containers here I got a my
sequel and then I got an Apache and on
my sequel I didn't open up any ports and
never specified a - P but on the Apache
one I gave it a - P of 8080 colon 80
that would mean over here on the right
at my Ethernet interface on my host it's
going to start listening on port 8080
and as soon as traffic comes in to my
host on port 8080 it's gonna route it
through down to this new virtual network
I created and into that Apache server on
port 80 but inside this virtual network
the Apache server is free to talk to the
my sequel server over its listening port
so when you think about virtual networks
and docker and where containers belong
think about how you would put different
containers in proximity to each other
because they're related in their
application as you can see these two
examples if I had container 1 container
2 up top wearing something different if
they're not going to be talking to the
services in this network down below then
it would make sense to keep them on
separate virtual networks and if they
ever had to talk to each other they
would have to go through their published
ports all the way out and back in and as
a reminder on any interface on your host
you can't listen on more than one port
for multiple containers so you can't
have two containers listening on the
port 80 at the host level okay only one
can do that and if you try to start
another container it would actually air
out and say that there's already
something else on that port and that's
not a docker limitation that's just a
limitation of how IP networking
typically works so just a quick recap on
this section we actually spend a lot of
time on the concepts of docker
networking including the exposing of
ports on your hosts to the physical
network using the - P and the idea
of docker focusing on saying defaults
where they call it batteries included
but removable and how for local dev and
testing you probably can just get by
with the defaults but everything is
changeable and then we learned about the
container port command which is a quick
way to look at the ports exposed for
your particular containers and then we
broke down the packets moving around
virtual networks and how those relate to
other virtual networks and how they get
in and out of your docker machine so
these are all really good concepts to
understand as we jump into the actual
CLI stuff in the next lecture for this
lecture you need to understand some of
the previous concepts around networking
and also around creating containers now
that we understand the concepts of
docker networking and how all the
virtual networking and IP stuff works
let's look at some of the command-line
options for managing it so first is the
obvious network LS since we can create
multiple networks we surely have an LS
command to list them we have the usual
inspect command which you're probably
used to by now from all the other
inspecting we're doing and that will
show us the details about a specific
network and then we have a create
command that has an optional driver that
we can specify for using built-in and
third-party drivers to create a new
virtual network and then we have the
connect and disconnect commands for
changing a live running container so
that a new NIC is created on a virtual
network for that container it's kind of
like sticking a network card in a
computer while it's running so here we
go okay so back to my command line and
taking the concepts that we just learned
I can actually do a docker Network LS
and this shows me all of the networks
that have been created now in this case
when you run the same command you're
probably going to see the same three and
depending on your operating system and
version of docker you might see the
bridge network called docker zero or
bridge but they both mean the same thing
which is it's the default network that
bridges through the NAT firewall to
a physical network that your host is
connected to and up until now we haven't
had to worry about it because all of our
containers have just attached to that
network and worked but now that we have
this nginx container running if I do a
darker Network inspect the bridge
network you'll actually see that it
lists the containers attached to that
network and you'll see that our engine
x1 that we called web host is attached
there you can actually see its IP
address and you'll see up here that
these networks automatically assign IP
addresses and it's showing you here with
the IPAN config that the subnet defaults
to 172 at 1:7 which is typically the
default network for any docker host but
it can be changed and then the Gateway
for this network that will eventually
route out to the physical network and if
we went back to the docker network LS we
can see these other two networks the
host network is what we talked about
before that is a special network that
skips the virtual networking of docker
and attaches the container directly to
the host interface and as you can
imagine there's pros and cons to that
because it prevents the security
boundaries of the containerization from
protecting the interface of that
container but it also in certain
situations can improve the performance
of high-throughput networking and get
around a few other issues with specific
special software out there and then we
have the last one of none which is kind
of the equivalent of having an interface
on your computer that's not attached to
anything but we can create our own so
let's create a docker Network create my
underscore app underscore net all right
now we're gonna do a docker and network
out less again and you'll notice that it
created my new virtual network with a
driver of bridge and that's because
that's the default driver it's a simple
driver that simply creates a virtual
network locally with its own subnet
somewhere around the 170 2.17 and above
because it'll increment as it goes so 17
then 8
19:20 so on and it doesn't have any of
the advanced features that we might see
later in this course like overlay
networks that allow private networking
between hosts and other third party
drivers like weave and if you look at
the docker network create command with
help you'll see that I can specify not
just the driver that I want to use but a
lot of the IP and network options that
you might need in an advanced scenario
now we can do several things with these
networks and how we connect them to our
containers we can use the - - Network
option when we create a container so
docker container run name new engine X
and then network and then my app net and
then the nginx image and if we did a
docker network inspect on the my app
network you would see that the new
engine X I just created is now on that
network and it has a new IP address of
170 2.18 so it's the next subnet in the
list but we don't actually have to start
new containers because just like in the
real world where you can unplug and
replug in Ethernet devices and reconnect
to wireless networks you can also do the
same with existing networks and existing
containers and for this we use the
docker Network connect and disconnect
options and you can use - - help to see
all the options there for docker network
and in this case what we want to do is
docker network we want to take the
existing container that we created first
and connect it to our new network so I'm
going to pick the new myapp Network and
then I'm gonna pick the original web
host we created and now if I do a docker
container inspect of my original web
host
you'll see that it's actually now on two
networks the original bridge network and
I basically did the equivalent of giving
it a new Ethernet interface on a
different network with a different IP
that was received from the DHCP so we're
now on the 17 network in the 18 Network
and if I wanted to disconnect that I
could do the same with just disconnect
and then if I went back and did an
inspection again you'll see that it's
now back with only the one network so as
you can see there's lots of interesting
options for docker networking and really
the end goal here and one thing I love
to brag about with containers is that if
you're running all of the applications
on a single server in this case you're
able to really protect them because in
the physical world where we were
creating virtual machines and hosts in a
network we would often over expose the
ports and networking on our application
servers so in these cases if you were to
take your app containers and have them
all in one network together in a virtual
network you're only going to be exposing
the ports on your hosts that you
specifically use the dash P width and
everything else is a little bit safer
with that protected firewall inside
their virtual network now later on when
we get into docker swarm we're actually
going to learn about multi host
networking and how this gets even better
when we start to scale up and scale out
so to recap we just covered a bunch of
commands for managing docker networks we
played around with the LS and the
inspect commands created a docker
network and use the default driver of
bridge so we didn't actually need to use
the dash dash driver and last we tried
out the network connect and the network
disconnect commands for adding and then
removing a NIC from a running container
requirements for this lecture are that
you've seen the previous Network
lectures and our understanding of the
key concepts for docker networks and the
commands that go with it all right in
this lecture you're gonna learn and play
with DNS and how it effects containers
in custom networks and default networks
and we're gonna go over quickly how
important it is that we have good DNS
because you can't rely on IP addresses
inside containers since things are so
dynamic and we'll look at the
differences between default and custom
networks in regards to how they deal
with DNS and then we'll check out the -
- link option for container run for
enabling DNS on the default bridge
network so there's one more thing that's
crucial to all of these containers and
virtual networks and them talking to
each other and that's naming because in
the world of containers constantly
launching and disappearing and moving
and expanding and shrinking and all the
wonderfulness of these micro services
that we're seeing crop up everywhere is
that we no longer can easily rely on IP
addresses as the way to talk from one
thing to the other because we can't
assume from minute to minute that the IP
addresses are even going to be the same
the container might go away or it might
fail and then docker brings it up
somewhere else it's just too dynamic and
too complicated to deal with that so it
turns out if there is a built in
solution for this and that is DNS naming
and docker uses the container names as
the equivalent of a host name for
containers talking to each other now if
you remember we just had two containers
running and if you remember the new
engine X was on a new network called my
app net right it has the one container
on it now because I created this new
network that's not the default bridge
Network it actually gets a special new
feature which is automatic dns
resolution for all the containers on
that virtual network from all the other
containers on that virtual
work using their container names if I
were to create a second container on
that virtual network they'll be able to
find each other regardless of what the
IP address is with their container names
so let's try this docker container run
name and we'll call it my nginx and
we're going to specify the network as my
app net from the index image so now if
we look at that network we should see
two containers and if I do a docker
container exec from the new container I
just created
oops we also need the I T in there and
we do a ping to the new nginx you notice
that DNS resolution just works and this
makes it super easy for you to have one
container and you need to set a
configuration file in it to talk to the
babies that say the PHP server talked to
the my sequel back-end control see out
of that and you'll see that it works the
other way as well if I jump into the new
engine X container and I try to ping the
my engine X you see that the resolution
works both ways and this is what solves
a huge problem when you're spinning up
containers because you can't predict how
long they're gonna last and where they
might be a minute from now in a
production design where you've got a
cluster of docker swarm servers so it
may not change very much on your local
machine but if you stop three or four
containers and then you start the same
containers and you start them in a
different order they may not have the
same IP address but their host names or
their container names will always be the
same and so you can rely on them now I
should note if we do a duct or network
list the default bridge network has one
disadvantage here it does not have the
DNS server built into it by default so
you can you
the - - link so when you create a
container you'll notice there's a link
option and you can actually specify
manual links between containers in that
default bridge network but really it's
just much easier to create a new network
for your apps so that you don't have to
do this every time and in a future
section when we talk about docker
compose you'll see how so much of this
gets even easier because compose
automatically will create new virtual
networks whenever you spin up an app
with it so communicating amongst your
containers gets even easier so just as a
quick recap we covered in this lecture
about how containers can't really or
shouldn't really rely on IP addresses
for talking to each other because they
just can't be relied on and that DNS is
really the standard here for how we do
intercommunication between containers on
the same host and across hosts and so I
recommended you always create custom
networks since it's just easier that way
than doing the - - link all the time and
then I gave you a teaser about docker
compose and how it's going to make all
this easier especially the networking
hey thanks for watching this video on
creating and managing containers with
docker this video comes from my docker
mastery course on udemy which has over
eight hours of content just like this
and I've put a big discount coupon in
the description of this video in case
you're interested in checking that out
over thirty four thousand people have
joined me in the last year to learn
docker through the course and every day
there are students in there with me
learning docker and using it in their
own projects and we've built a nice
little community so I hope you join us
and I'll see you in the course
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>