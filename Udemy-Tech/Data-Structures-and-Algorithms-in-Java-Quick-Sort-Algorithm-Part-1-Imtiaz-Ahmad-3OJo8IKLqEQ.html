<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Data Structures and Algorithms in Java - Quick Sort Algorithm Part 1 - Imtiaz Ahmad | Coder Coacher - Coaching Coders</title><meta content="Data Structures and Algorithms in Java - Quick Sort Algorithm Part 1 - Imtiaz Ahmad - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udemy-Tech/">Udemy Tech</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Data Structures and Algorithms in Java - Quick Sort Algorithm Part 1 - Imtiaz Ahmad</b></h2><h5 class="post__date">2018-03-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/3OJo8IKLqEQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi in this lesson we'll talk about
quicksort quicksort is another divide
and conquer algorithm and it's used to
sort an array of elements its average
running time is n log n so generally it
runs about the same speed as merge sort
but notice I said the average running
time is n log n in the worst case it
could be as slow as N squared so it
still doesn't quite beat merge sort so
worst-case running time which is n log n
right so why would someone choose
quicksort as opposed to merge sort well
if you recall from a few lessons ago
when we were talking about merge sort it
required creating additional arrays to
store the the right and left halves and
this required a lot of space so if
you're sorting a lot of data and space
is an issue quicksort is actually a
better approach because it sorts the
array in place rather than creating new
arrays and generally it does one closer
to n log n so how does this quicksort
algorithm work just like in merge sort
imported the important procedure there
was the merging process right that was
the heart of the algorithm quicksort has
an important procedure as well the heart
of the quicksort algorithm is the
partitioning process right and the whole
idea behind partitioning is the
algorithm first picks a slot in the
array and considers it to be the pivot
okay and then iterating over the array
it throws everything that is less than
that pivot value to the left and
everything that is greater than that
pivot value to the right and then
finally it places that element you know
the one that picked and considered to be
the pivot in the correct position of
where it belongs in the array okay and
at that point all elements that are to
the left are guaranteed to be smaller
than that pivot value and all elements
to the right are guaranteed to be
greater than that pivot value so that
pivot value is considered sorted right
so that middle element wherever it is is
considered to be sorted and it won't
move again
essentially what partitioning the step
does and once the pivot is placed in the
correct spot the partitioning repeats in
the left half of the array as well as
the right half of the array anew pivots
are picked and then partitioned and then
placed into their accurate spots in the
sub arrays okay so it's a
divide-and-conquer algorithm so let's go
over an example here I have this is the
general idea behind quicksort and the
most important step like I said is the
partition that's why I highlighted it in
red and I'm not going to go over the
pseudocode for that we're gonna see that
in the screencast but this is the
general pseudocode for the quicksort
algorithm and this is a recursive
algorithm it invokes itself twice once
for the left half of the array and then
for the right half and as long as it has
more values to sort it continues to
break left and right halves of the sub
arrays as it narrows in and sorts the
values okay and the idea is to every
time get a pivot properly placed in the
array all right and that provides a
guarantee that all the elements that are
left or better to the left of the pivot
are sorted not sorted but smaller and
all the elements that are to the right
are are larger than that pivot okay and
as you get more pivots you will
eventually put all of the pivots in the
correct spot of where they belong in the
array okay so let's go over an example
oh the way this algorithm is going to be
invoked first of all is this is the
array right this array is the argument P
as you've seen in the previous lessons
all the algorithms P is the first lot of
the array or is the last slot of the
array so that convention still applies
so when we invoke quicksort here we pass
in the array we pass in 0 for the p and
r is going to have the value 7 okay and
then it'll do all the magical stuff so
what is the magic this is the most
important step the partition step so
let's go over how partitioning works now
there are two variables that are going
to be managed in this partitioning step
and I'll just call it I and J okay and
you can really name them whatever but
these are going to be the
different index positions of the slots
right so the J starts with the zero
index position and I starts with one
less so I is at negative one it doesn't
point to any slot or anything but that's
how the algorithm starts up okay we
initialize it with negative 1 and J
initializes with zero and we need to
pick a pivot generally the last element
in the array is picked to be the pivot
okay a lot of computer science textbooks
show the last element to be the pivot
that's just an example but you can pick
really any element that you want and
sometimes it's a good idea to have a
better idea as to what pivot you're
picking because depending on the pivot
that you pick the performance of the
algorithm would be different and that'll
make more sense when we actually try
some practice problems so let's get
started the idea is to bring this six
somewhere in here and guarantee that all
of the elements that are gonna be left
of six are going to be smaller than six
and all the elements to the right are
gonna be larger than six so we put six
right here in the correct position and
that position will never change for the
number six so let's start the way this
algorithm is going to work is we need to
check against six all of these values
and the question that we're asking is is
10 less than or equal to 6 if 7 less
than or equal to 6 is 1 less than or
equal to 6 that's what's going on in in
the iteration so let's start with 10 is
10 less than or equal to 6
no it's not so what do we do we actually
advance J we increment J to the next
slot okay and we ask the same question
is 7 less than 6 no it's not so we
advanced J again notice is still where
it is I haven't advanced I yet so J
moves to the next slot is 1 less than or
equal to 6 yes it is at this point once
we come across a value that is less than
or equal to 6 once J points to a slot
that contains a value that is less than
or equal to 6 we advance I okay by 1 we
increment it by 1
so now I is pointing to the slot zero
and J is pointing to the slot that is
less than or equal to six
as soon as we advance I write we swap
the values so 10 goes into the slot that
six that J was pointing to and 1 goes
into the slot that I was pointing to and
then we continue on we advance J to the
next slot and we ask the same question
is 3 less than or equal to 6
yes it is if that's the case then we of
course have to advance I to the next
slot all right and then we swap okay and
we advance J again move J to the next
slot is 5 less than 6 less than or equal
to 6
yes it is so we advance I again and we
swap so notice what we're doing here
we're moving all the values that are
less than 6 over to the left side okay
and if once we're done with this entire
array and we've moved all of the values
that are left that are less than 6 to
the left side we can very easily and and
correctly place 6 past those values and
that would be considered sorted so let's
advance to the next slot J is now going
to be in this slot we asked the same
question is 8 less than or equal to 6 no
it's not ok continue on is 9 less than
or equal to 6
no it's not so we continue to advance J
and then finally J goes to this slot and
it asks it compares and says o is 6 less
than or equal to 6 yes it is
so at this point what do we have to do
we have to advance I ok and then we swap
all right now we can guarantee that all
numbers that are to the left of six are
smaller than six that's the only
guarantee we can really give at this
point all the numbers that are greater
than 6 are are to the right so that's
the only guarantee we can give right
notice that they're not sorted here 10 8
9 7 those are not really sorted numbers
but we do have a guarantee that this guy
is in the is in the correct position
this is 100% accurate so after all that
swapping partition is finally complete
but you might be wondering what did it
really do for us what did it give what's
the end result well the end result of a
partition step is a guarantee okay and
what is it guaranteeing well it's
guaranteeing that the number that we had
picked to be the pivot which was 6 is in
the correct slot position okay this
number is guaranteed to be sorted so if
all of the other numbers if all of the
other numbers were sorted 6 would still
be where it is right now okay so that's
what the partition step gives us it
gives us the index position of the
correctly placed pivot which is the
number 6 that this is the correctly
placed pivot the index position that
partition will return is the number 3
okay that's what partition will return
and that were assigning 2q okay and then
we're using this 3 in the invocations of
quicksort here okay so the
responsibility or the first invocation
of quicksort is to deal with the left
half of the array and the second
invocation of quicksort deals with the
right half of the array okay and you can
see the arguments that are being being
passed here a is of course the array but
P is the starting point and that's going
to be 0 so this first invocation of
quicksort is going to be from 0 all the
way up to Q minus 1 Q minus 1 is
actually 2 so that's what this first
invocation of quicksort is going to be
dealing with the left side of the array
okay the second invocation of quicksort
is going to be dealing with Q plus 1 all
the way up to R which is the last slot
so Q plus 1 is 4 so it's
be dealing with a range between four and
seven okay and each one of these
invocations are further going to be
invoking the partition step right this
is a recursive algorithm inside of this
quicksort which takes the entire array
it's going to get the midpoint here not
really the midpoint but the partition
point and then it passes that on to
these guys and they will further have
their own guaranteed pivots properly
placed in the slots okay so hopefully
this makes sense and if not don't worry
we're going to be getting plenty of
practice in the screencast so I'll show
you the pseudocode for partition and you
can code it up in Java as well as the
the rest of the pseudocode here there's
a couple of details I want to add and
we're going to go into that in the
screencast</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>