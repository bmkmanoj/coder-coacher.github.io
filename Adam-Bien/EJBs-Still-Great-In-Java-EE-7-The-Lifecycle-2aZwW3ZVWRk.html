<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>EJBs? Still Great In Java EE 7 (The Lifecycle) | Coder Coacher - Coaching Coders</title><meta content="EJBs? Still Great In Java EE 7 (The Lifecycle) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Adam-Bien/">Adam Bien</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>EJBs? Still Great In Java EE 7 (The Lifecycle)</b></h2><h5 class="post__date">2012-11-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/2aZwW3ZVWRk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi my name is Adam bean and today I
would like to discuss lifecycle of a GPS
and managed beans and I will create a
very simple java application typically
one with JSF I presenter hello Java EE
lifecycle and I would like to use a JSF
page a simple presenter or backing bean
a half page and it should be and I
control so this is a Jess F page then I
would like to use a backing pin called
index a single boundary and they control
so the boundary is going to be any gb
the control is just a marriage pin which
does the actual work and returns a nice
message like Java rocks and the boundary
uses the control uses the control and
via injection and just delegates to it
so usually in real world empty delegates
are not that great but I would just like
to each to explain you their life cycles
or for demo purposes I think a single
empty delegate is okay to have and the
first one is a model what means is
requests scoped named managed bean and
we have one method here get message and
we inject the boundary here
and we just use the method of the
boundary as well again in typical
applications that you want empty
delegates are just not that common okay
now the interesting story I would like
to to to trace the creation of the of
the managed beans and agb's so for that
purpose I create a method which is
annotated with post construct and this
returns just shows boundary and I will
just copy that it works in for managed
beans as well and in this method I would
like just to use the same with control
so and now try to deploy the stuff oh I
forgot the following I forgot to use
actually the name pin so just use that
index message so now try to deploy
everything so just run it and see what
happens so the Derby database is booted
and the GlassFish starts as well the
application gets deployed and browser
started so java rocks you see we see the
output bound control boundaries and the
controller was created first and then
the boundary so on each requests you see
that actually nothing happens so the
reason for that is the boundary is an
EJB and it is pooled so it is created
once and the container is going to
create additional instances in case in
case the load increases so what cannot
happen that two threads are accessing
the same instance but let try to remove
the stateless here and I would just
repeat a test and what you see is now on
each requests the boundary is created
because the boundary is created and the
control as well and the reason for that
is both are
managed beans with dependent scope and
they inherited this code from the index
so they're actually dependent on the
scope of the index managed bean so with
a single at stateless you can not only
you not only get transactions for free
but also better performance so yeah stay
lean thanks for watching this screencast
and see you on upcoming conferences
workshops and on ax so thank you very
much and see you next time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>