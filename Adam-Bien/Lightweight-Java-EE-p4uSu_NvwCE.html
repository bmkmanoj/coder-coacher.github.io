<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Lightweight Java EE | Coder Coacher - Coaching Coders</title><meta content="Lightweight Java EE - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Adam-Bien/">Adam Bien</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Lightweight Java EE</b></h2><h5 class="post__date">2012-09-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/p4uSu_NvwCE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi my name is Alan bean and today I
would like to discuss with you why or
show you why I consider Java as very
lightweight effective and productive
platform I'm working as developer
consultant and I focus on development
and sometimes I'm I'm writing books and
articles and sometimes it means if I'm
on the road or in my dead time and
leisure I'm writing articles and books
and occasionally I also speak at
conferences I really enjoy for instance
the JavaOne conference and about three
three times a year I'm delivering
workshops that are organizing workshops
at Munich's Airport there are lots of
fun so we are coding together three days
Java six applications and and and
discussing best practices and and
patterns what's funny in recent years I
actually deleted more code than I've
written why that what I see in my
enterprise daily work is there is a lots
of exaggerations in directions data
access objects data transfer objects and
and no one actually knows why they are
there this is actually the Sun set part
of the story so there is a lots of
plumbing without actually knowing why
it's there and the reasons are of course
there are of course historical reasons
so starting with j 2 ej do we require
lots of plumbing and now we have more
modern platforms like java f5 and java 6
but the plumbing just remained but
what's said so is that it is the
discipline it's still considered as be a
best practice so on to what i try to do
is just to do to remove all the plumbing
and concentrate and focus on business
logic and it is actually not a big deal
to write over complicated and
exaggerated applications it is a lot
harder to write to write business driven
applications with a minimal amount of
infrastructure but what's interesting
Java is 6 is perfect capable for that so
with Java 6 you can just concentrate on
the business logic and and enhance the
business logic or inject the
infrastructure later ok this is one of
the recent books talks about rethinking
the best practices and this book talks
about a small application I've written
from a web block called x-ray and it
says real-time statistics software
written with Java 6 maven 3 and rest
services so what are in my opinion the
core feature of Java 6 the conceptual
feature convention of a configuration in
my opinion is the biggest what it
actually means is you don't have to
configure anything you can just Khan you
can just concentrate on on the on the
business logic and write just write
business code and Java is 6 will provide
you with suitable defaults what suitable
means is for instance if you are
building a JSF application
you don't have to provide faces
config.xml for page flow you can just
return in action method or you can
return an action name in the method and
if the action name matches was a JSF
view yeah this view will be just the use
as the next page without any further
configuration this wasn't possible
before Java 6 or in JPA case if you have
an entity with persistent entity with
attributes and all the attributes are
persistent you don't have to configure
that what do you have to configure is
the exception from the rule for instance
if you had a transient attribute you
would have to declare that as transient
and finally dependency injection so what
or sorry dependency injection is in CDI
case what it actually means is if the if
there is only one possibility you can
just right inject the possibility with
at inject without if it is not ambiguous
you will you will
you won't have to provide any additional
configuration if it were a big with you
you would have to configure that
and finally eg bees if you if you deploy
on a GB it is transactional and monitor
able and secure and thread safe per
default you don't have to configure
anything so I really enjoy that because
before Java is 6-inch ri5 we had to
write a lots of XML and Excel XML was
just dump xml because all the
information was already in source code
and we had to repeat that in in xml so
what we used back then was it stock led
to a small enhancement of actuary
Javadoc doclet and it stopped
regenerated all the plumbing for us so
it was obvious back then in j2 we won
for that the whole xml configuration is
actually superfluous if it can be
generated so an dependency injection was
introduced with java 5 but it was very
very simple so you could just inject it
with a TGB and you could only inject a
jb's and it was sufficient for more for
most applications but you couldn't build
for instance application server based on
a TGB dependency injection this was
changed in in Java 6 so in addition to
simplistic a TGB dependency injection at
inject was introduced on what at inject
means us you can inject external
components with at inject and pojos and
it is extremely powerful model actually
it I think it there are no more limits
you can inject whatever you want
whenever you want and there are even
pluggable extensions and the CDI
dependency injection is also based on on
conventions as I already said is if you
have just one dependency you can just
inject it without any configuration and
by the way the usual configuration of
CDI happens in source code with
annotations and not with XML dry don't
repeat yourself and die
the application is evil
is also interesting concept what it
means Java six allows you to write the
metadata in one place for instance if
you have JP a entity and you annotate
the fields with pin validations J's are
3 or 3 it will be validated twice and
proper probably three times in Java 7 so
in Java 6 it will validated for JSF and
be also validated for JP a and in Java 7
you could even reuse that for restful
web services and keep it simple and
stupid it's also funny funny concept by
the way dry and cares and the Agni you
aren't gonna need it are actually
general term terms and have nothing to
do with Java but can be perfectly
applied to Java EE so what kiss means is
with Java 6 you can you can write
actually application to then lots easier
than Java C so you can keep them very
very very simple so and what becomes
mind more important because of movement
like DevOps or continuous deployment is
the enterprise readiness what I would I
understand under this term is if you
deploy a Java 6 application it will be
monitored by the application server per
default so there is no more reasons to
to provide additional tools monitoring
is whatever you will get at least
statistics about threading transactions
progress queue depth errors every
application server will provide you with
these statistics and this is a huge
difference to two web containers the
applications out-of-the-box applications
deployed on web containers like jetty or
tomcat are nothing else than a blight
flight so you so what you only will see
usually without any custom code is the
yeah the behavior of the sublet which
what is basically nothing because the
servlet is just usually the controller
of a view framework and you can
configure it entirely or or or or not at
all and you will only see the statistics
for methods to get in the post which are
actually global so on the end
price ranges I also understand somehow
well-defined deployment it means in the
case of GlassFish you could deploy
applications with putting your war or
ear to a folder or using even rest to
upload your application or or the admin
console so enterprise readiness means
the application servers are usually
already well integrated with tools
delivered by operations and you can
easily monitor them and deploy them and
scale or or manage the application
servers so productivity unusual story
what I really like is JCP dot orc Java
community process because the whole Java
EE documentation is free and waits for
download and this is actually what I
what I do in my projects so so what what
I usually do I have here a I download
I'm sorry I go to my folder just to show
you and these are all JSF specifications
that these are all PDF specifications
I'm I'm using in our Java six
specifications and I don't read and read
them completely of course but they are
perfect just to find to find answers for
your questions for instance if you are
interested in a connector
implementations here is it free
implementations about connectors and if
you are interested for instance in
connection management you will you will
you will find the answer inside inside
the the PDF so you see everything
correction related and state diagrams
how how igce connector manages manages
connections and the same is true for
instance we already talked about
persistence GPA you will find a lots of
examples process here select statement
GPA quelle whatever you need and
everything is for free so what I use in
case I'm
I need some some more information I just
search this this topic for searches
folder four for four terms and you can
download everything from JCP for free so
if you go to JCP dark JCP dark and for
instance use 316 mr. Java six
specifications the number of the Java EE
jsr Java specification requests are by
six and you can just download from here
to PDF file and our 317 should be I
think it should be or JP or something
yes it's persistence JP a persistence
and 318 should be G B's and 303 is the
bean validation and this is actually
unique why because I'm not aware of any
other other platform which comes a well
documented out of the box and what it
this is not only specifications well I'm
readable specification is also Java
basics tutorial which comes for free as
PDF and what you also see here is there
are lots of individuals and companies
working together on such a GSR Java
specification requests and why is why is
this good is because because of the
broad support right now Java is six
supported by about by about 14 different
application service which is actually a
huge ax success so all major application
servers are already supporting Java 6
and why is this good for us as
developers you only have to read to read
this specification or to learn at once
and you can you are able to deploy your
application on multiple application
services actually what I enjoy the truth
is defined and one place in JCP dot org
and it is of course reused by book out
of authors but you don't have to buy
books it's just enough to start to
download these specifications and there
is also great Java EE tutorial also free
so you can download the tutorial or
browse through the toy or download
download the PDF book so what's what I
also enjoy is the setup so if you are
starting with let's say maven that's
let's let's do it then I just start
maven archetype generate there's a
wizard and I just have to find a Java 6
project type it is around 380 or
something it is here 3 8 7 is the number
web app Java 6 so 3 8 7 and group ID is
calm
Java EE or better is of course or Java
EE artifact is rocks version is okay
package perfect yes and what it did it
create for me a project with the name
rocks so now I would like just to show
you the structure of the projects and
would start a NetBeans a free ID which
is extremely capable of implementing on
developing Java projects I would just go
to the junk folder this is what I use
for demos so it's stir and now I can
just start it just running it so this
will already work but more interesting
is the single dependency so if I look at
the dependencies
there is only one external dependency
required as Java a Web API whose
diversion 600 what it means you only
need one single jar to compile all the
Java 6 all the Java 6 application which
is actually quite interesting yeah ok so
declaring versus implementing is also
interesting it is actually really
interesting topic about Java EE and
complexity in general what I see in my
project developers an attempt to start
with nothing with plain web container
with the excuse it is more simpler than
Java basics and then end up implementing
transactions and threading with
overcomplicated thread locals and
singleton solutions in Java basics case
you would only have to apply a single
annotation at transaction attribute and
with just with this annotations their
job a6 application server will have to
will manage the transactions for you so
the question is would you like rather to
implement everything from scratch and at
the end of the day you will end up with
a simplistic application server or just
use the application server for that and
in my opinion the complexity comes not
from from Java EE the complexity
complexity comes from the nature of Java
EE everything is so complicated because
we have to deal with distribution cash
synchronization locking consistency
availability and all the stuff and this
is complex not Java EE and of course is
a lot of easier starting with simple
servlet and implementing everything on
the go but you will end up with hard to
maintainable application because you
will have to maintain the
infrastructural code you build plus your
domain logic and what's what I also
enjoy in Java 6 is a clear separation
between platform and domain code so
there is actually no dependency between
a business code and Java code for
instance if you would like to plan a GB
you'd only have to to apply a single
annotations at stateless on the class
and this is enough to have an eg be
there is no need to to in implement an
interface on inherit from abstract
abstract class so lightweight what's
really funny is in actually in several
projects whether I would or what I see
is of funny phenomenon is architects are
selling and architectures lightweight
and they have Tomcats or jetties in
production and what turn out turns out
is that the application archive is
orders of magnitude bigger than the
whole server installation so it is not
uncommon to have 20 max server
installations and 500 makes worse or
years which have to be deployed to the
service usually worse in the case of of
web containers in my case this is not
lightweight what I have no problem
deploying bigger servers and then could
be even 500 Meg's or even one gigabyte
which is not the case for instance in
glass switches around 200 Meg's and
JBoss and the others are comes with
similar similar size probably some
commercial applications well a more
heavyweight but the vast majority of
open source application servers are
extremely come with extremely small
footprint and what in my opinion
lightweight means that you are deploying
extremely small Wars to a bigger service
why because I'm really interesting in in
short turnaround cycles a small war can
be can be can be zipped and packaged
very fast and in a bigger war takes
longer and and this is just waste of
time so I'm interested in smaller Wars
and bigger servers I have no problem
with a bigger server because hard disk
is it's extremely cheap and and even the
difference in a in the RAM footprint
between application servers and and and
and web containers is negligible so
No Tomcat was thought but probably will
use about five max RAM and GlassFish or
Jabba's or Tommy will need about I would
say 20 to 260 mix of RAM small
deployables very important in my case
fast deployment it should deployment
should takes take seconds and not
minutes or hours and what I really enjoy
is you don't need any external
dependencies and as I said in my during
my introduction I'm working with Java
since 1995 and what cost trouble were
forgotten external dependencies it is
not uncommon to use an external
dependency and open source one which is
not more no more supported and this
dependency over time becomes harder and
harder to manage and you cannot fix them
because there is no more because there
is no one maintained by the code by the
community so what we had to do once is
we had to decompile the external
dependency fix the problem recompile
that and document our does the process
so that these external dependencies
wouldn't be replaced accidentally
replaced by an another maven deployment
so external dependencies cost some some
amount of work and what you should do
for long living projects is if you
really would like to do to rely on
external dependencies just to download
the sort the whole source code make it
buildable and in case something's
something go wrong in the in the future
you can just build your own or maintain
your own source tree yeah this is the
cost of external dependencies so what I
do in my projects in Java 6 projects I
actually forbid to use any external
dependency and if someone would like to
have something have just to justify that
by writing just a very short explanation
why this external dependency solves a
particular problem if it is and if the
reasons are are hard to explain it is
probably not worth to use that also so
try to minimize external dependence
is usually everything you need is
already on the job a sixth server so
conceptual scalability what I mean by
that so you don't need XML at start you
probably only need of your notations and
only view I would say you need at
stateless for transactions and inject
for inject another layer at persistence
context to inject entity manager and one
identity to declare class as persistent
and at at ID to declare and persistent
ID and you can you can build with that
any crud application you like create
read update delete there is no bloat you
only need this dependencies without any
additional work the learning curve is
really flat so actually what I what I
seen right now is people are using Java
6 without knowing that is actually Java
6 and some projects developer built the
main logic without knowing that they
actually enhancing eg B or CDI managed
beans so it is a very good idea to start
with only a viewer notations and unlearn
on on the go I wouldn't start with
extensive trainings and causes I would
just I would just think about a small
applications what what's what's fun or
half way usable and try to implement
this application which is less amount of
Java SiC is only possible and it's as as
very very as lines of code as only are
only possible so try to concentrate on
the business logic and use Java 6 on
demand so our view lines of code say
more than thousand slides so this is
actually the reason I was why why I
would like to show you
Java from the from the code perspective
and would like to start with with a
small application and the question is
what we should build and I would start
with Java 1 favorites it would be a
small application with which cares about
your favorite sessions so Java EE web
application
and this is actually new in Java 6 so
you can deploy a whole application as as
warz there is no need to in to introduce
years words are faster and simpler so
Java 1 fav favorites enable context and
dependency injection will generate a
very small XML deployment descriptor a
very short one and it is extremely short
because it actually consists of single
of one tech but this guys is important
without beans XML you won't have @inject
dependency injection so I would just
create a project and then try to run it
so Java one favorites run this will
create the war and deploy the
application and it's deployed so then I
would like to create a Jess F page
because it is the easiest way to start
with and usually you would like to have
something which which is testable and I
usually start either with Jess F or with
restful web services so Java one
favorites
welcome so as you see Jess F is deployed
so what you would need is a so we just I
would try to build a more realistic Java
six application so what do I would like
to introduce as a baking bean with the
name index and the backing bean will
care about the state of the JSF page
package is arc dot Java one favorites so
and the Thursday annotation called model
and what model does is it makes the
index visible for JSF and this index
will be created and destroyed for each
request so this request code named
actually you can see that it is named on
the request code request code means the
minute this managed bean only survives
one request and named means it is
visible to Jess F and the default is the
simple name of the class so get
greetings and just to show you how it
works
welcome Luke and now you should be able
to to use this in the page and as you
see welcome Duke works perfectly so this
was the index so if I click here I will
you see this is the the reason why I was
able to refer to the baking business the
name of the class with first lower cased
character so and greetings invokes a
method get greeted get greetings but
what I would like to do to create is a
class called technical session TS
they're actually no esoteric sessions at
JavaOne but the official name is
technical session with I think name
there's a name and ID and the ID is like
TS something and I will just create a an
constructor and also a just drink method
for good to string method yes both it's
better now okay so what I did I create a
technical session class with some
attributes getters and setters are
needed for data binding what I would
like to do is to populate the data or to
bind the data from from the JSF 2d to
the class or move the data from the J's
F to the class automatically and for
this purpose I will have to enhance the
index with private technical session and
show you the life cycle now create a
life cycle call back on in it and with
post construct and I will create
technical session here and would like to
expose this as a method get' session so
now you see there's an error and what I
would like to do is I would like to
create a form and
so two text fields and the first one
will bind the session and ID and the
other one to name this would be the ID
and the name name and what we also need
is very simple I could use some UI
containers but for our purposes just to
show you the capabilities of Java it
should be just enough and a command
button and I would like to bind the
button to the backing beam action and
the action is index pad so I have to
create a method first I'm in the index
and in the method add object and
I would like to add that so just
probably just give it to system out plus
this session return so saving and just
you see ID is TS 42 and you Crocs would
be the your favorite and what you see is
technical session ID TS 42 d works so
what do we have already is we are able
to pass pre-populated domain object
between the JSF page and the backing
beam we would like of course to store
the the technical session to a database
for this reason the most simplest thing
you can you can do is is to create a a
session store a GB and the session
storage a B is an stateless session bean
and what we also need is to use JPA and
for this reason i would create here
entity and this guy needs to be a
primary key so now you see here we have
a problem
and the problem is we don't have any
persistence unit
so what persistence unit is it is very
small
xml d prime minister or small it's the
Diploma descriptor which defines in
which database this entity is going to
be stored so i will just create it and
you see this is a clips link and sample
is the central database and drop and
create means that the database is
recreated or the schema is recreated on
each deployment and the persistence unit
doesn't doesn't actually matter because
we have only one if you have only one
persistence you need
the convention is it can be just
injected without actually knowing the
name so now it's created and in the
session store I'm able to to inject the
entity manager with persistence context
and I don't have to specify the name
because there is only one and I need a
method save technical session ts yam
merge or persist so what what means is
yeah the session is an either persistent
or I'm sorry either inserted or updated
in the database so this is the Rubies
ready to go and it's stateless means we
the transaction is getting to be started
here and committed at this point so
let's try it again so what we have ID is
T as 42 and Juke rocks was the ID and
seems to work so let's look at the
database it was technical sessions and
technical session and there is no Duke
why not because I forgot to inject the
egb to our backing beam so let's do that
sessions to our sessions to our ad
inject and here I would like to persist
and not session sorry session stopped to
save the session so um what we did right
now we injected the session store into
the method ad and into the index and we
can we are able to use the eg be from
from a backing pin and so let's retry
that and we just we start with from the
beginning he has 21 rockin Duke rockin
Duke and look still okay and as you see
rockin Duke is Terra so and also able to
introduce a new Duke Tech Duke and the
tagged Duke should be here so as as the
whole the whole lifecycle from from from
the lifecycle of flow of events from JSF
to baking bean to eg b31 and GPA seems
to work
the most interesting part is here the
persistence context is injected and by
the way the entity manager is configured
in a persistence XML and the only
dependency on GlassFish right now the
stay application serve I'm using is this
line of code what it means is I'm
relying on eclipse link but I think if
I'm deleting that it would mean just
take what is deployed on the application
server you also see here the pins XML
which is basically empty there's a
single tank and yeah the technical
session is the entity and it is used by
JPA and JSF for data binding and index
is the backing pin so with three
components you are able to build your
own
yeah crowd implementations and what you
can also do what it's also well
integrated as spin validations for
instance I could say the the name of the
session shouldn't be the size should be
between two characters and and let's say
10 so right now let's try good say ts
size must be between 2 and 10 as you can
see I can use bean validations from jsr
3 or 3 and apply them on entity this is
what I what I mean meant by dry don't
repeat yourself and and this this
metadata is used for validation twice
the first time just in Jes F and the
second time in JPA if I would somehow
manage to hack JSF I still wouldn't be
able to to save the technical session in
in the database what also interesting
here is the annotation at inject so if
we look at that it comes from Java X dot
inject and this annotation here is
defined by a specification called
dependency injection for Java and it
comes 3:30 as you can see as it was
defined by row Johnson from spring
source is the spring creator and Bob Lee
at that time he was at Google and its
lead was leader of the project called
Jews and many other companies and what's
interesting with the specification it
was actually introduced afterwards Java
6 was almost ready to go Andrew Johnson
proposed this specification and what
happened then is Java 6 was was refactor
to adopt the specification at inject and
at named we saw at named
ready so right now we have inside Java
six the same binary the same annotations
as Spring has in spring 3 and plus plus
would say so it also means is it is
actually doesn't make any sense anymore
to combine Java 6 and spring for
dependency injection reasons it is
technically possible but it will be in
long longer term harder to maintain
because no one know developer will be
able to say just looking at the code
whether spring or Java Asics are in
charge of injecting the particular
component I noted it was at inject so at
inject is the annotation which came from
spring is also core core part of Java 6
in Java 6 you can use at inject to
inject everything and just using spring
in Java 6 wouldn't make any sense
because then you would have to service
provider implementations for dependency
injection I jump just just talking about
the core dependency injection this is
interesting what also interesting is our
transactions so transactions are
necessary so I can show you here with
just disabling stateless what happened
right now this session store is no more
and egb it is a CD I managed bean and as
a CD I managed bean is not able to start
transactions so we will retry our our
attempt to study session PS and 21 and
you see transaction required exceptions
we are not able to store the entity
because it yeah we are not starting the
application we are not investing the
entity manager within a transaction so
it's required just riri attempting this
now TS and 21 now it works perfectly
again so and what's funny if you look
internet JPA just for instance you
we'll find a lot of tutorials this one
for instance is from eclipse and what
you see is they just show you how to
integrate JSF with GPA without eg B's
usually jeebies are considered
considered to be too complex which is
funny but instead of using GPS the idea
doing the following they are creating
here entitymanager factory for each call
and then the developer has to wrap each
call in each interaction with the entity
manager with with own transactions right
here you see as it fetches the
transaction begins commits here is no
actually in a rollback which is
unfortunate there should be also a
rollback in case the something it goes
wrong here yeah a little bit problematic
and and just getting rid of eg B's would
result right now in Java 6 with lots of
complexity because you will have to do
to control it transactions by yourself
yes this is so far our our our small
applications consisting of a GB CDI a GB
CDI and and and backing beam what do you
what you could what you could also also
do for instance you can declare your
methods as asynchronous for instance
let's say this takes a long time and
this is an i/o operations which can take
a bit longer so we will have to simulate
that with thread sweep let's say 2
seconds
and just we try to reach to to recreate
that so T as 22 as you see it takes
about two seconds or I would say exactly
two seconds to store an entry so and to
make it asynchronous you won't have to
look in the spec for asynchronous and
you will probably find an annotations
with the name asynchronous and this
annotation starts execute the method in
a background thread in a transaction and
the background thread is managed by the
application server also from usually in
a thread pool and this should solve the
problem so in as you can see now we
don't we don't have to wait the
operation is performed in background so
a single annotation no interface and no
interface there is no inter voice
between introduces asynchronous
processing in in Java six what you could
also do let's say we would like to
measure the actual performance so we
would like to introduce a a performance
monitor class it would be an interceptor
and the Interceptor would just measure
the performance of a method throws an
exception
proceed and I would like to wrap that in
try and finally finally block to measure
the performance actually to be long
start and let's say see get method plus
executed in in in system current
Millie's ministered so just is already
milliseconds and we are ready to go and
interceptor person you you need to
implement a single method the name
doesn't matter but the signature does so
it has to return object expect
invocation context and throw an
exception and there is an annotation
called around invoke and I would like to
use this guy here interceptors and
performance monitor this is the guy
yes so 27 and you should be able to see
here the performance are two seconds as
you saw this is an asynchronous
operation takes exactly two seconds but
we can just try it here
for the index class it could be
significantly shorter shorter you see
this get session is executed in zero
milliseconds and the which is quite fast
and the session store save took 2
seconds and 8 m2 and seconds and 8
milliseconds so it is actually okay
what's also interesting in Java 6 is
extremely easy to distribute event so
let's say I would like to notify someone
per email that I've favorite for
instance we'll start in the in the in
the favorite application so um I would
create a simple class called favorite
listener and this guy is interested in
favorites on on storing and there is a
new annotation called observes and this
annotation it just replaces actually the
observer pattern from Java C
I would like to exert the technical
session and this guy say thanks for
notification last yes and yeah this guy
is ready to go so we it is a listener
it's somehow like local
publish/subscribe pattern so you can
just send and receive as many events as
you like to and what only considered is
the type of the event the name doesn't
matter and the type is important so I
would do it in the in actually it
doesn't matter we can we could for
instance do it here right now orb I'm
saving it so what you can do is you can
just inject the event of type technical
session listeners and with simple at
inject so and what you will see here is
I would like to do it afterwards
listeners fire session so let's retry
that as you can see saying thanks for a
notification was delivered immediately
and the index good session was still
very fast zero milliseconds of course
and the method ad took a bit longer so
so what what is alright now it is
extremely easy to distribute events in
Java 6 and this partially will replace
JMS for local event for local event
delivery so to conclude my my
presentation it is actually extremely
easy to to implement Java 6 applications
deployment is extremely fast all the
tools like profiler debuggers are are
available for you and in my opinion you
should start with Java 6 first and in
case it's not enough then look for the
alternative because Java 6 is extremely
well documented and supported and is
also extremely popular by the way all
events in the reasons 2 years were
completely sold out all Java EE related
events on conferences Java 1 sessions
were repeated and and and workshops so
it is actually a very good sign and what
I also saw this year first time ever is
that Java 6 catches some momentum in
startups so actually um young company
startups at least here in Europe are
asking me can you help us we have some
idea idea we would like to do to build
it with Java EE and yeah some some some
companies got a feedback that even it
wouldn't be possible without Egypt
without Java 6 to implement such
functionality in such a short amount of
time so thank you for for watching this
screencast and see you
webblock twitter or one of my upcoming
events and workshops and enjoy java 6
hacking thank you very much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>