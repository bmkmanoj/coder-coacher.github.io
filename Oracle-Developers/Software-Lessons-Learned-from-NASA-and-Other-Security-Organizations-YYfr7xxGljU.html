<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Software Lessons Learned from NASA and Other Security Organizations | Coder Coacher - Coaching Coders</title><meta content="Software Lessons Learned from NASA and Other Security Organizations - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Software Lessons Learned from NASA and Other Security Organizations</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/YYfr7xxGljU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">i'm going to try some non conventional
things and they may go horribly wrong or
they may be pretty fun so we're going to
try for fun and see what happens a lot
of the stuff is completely experimental
of course some of the older stuff is all
you know catch up but anyway so one I
don't have any slides I decided to do
all my slides in code so we'll see if
that works out it may be good it may not
be but it'll least be fun it's late in
the day and I think we need a little bit
of something different than what we're
seeing a you know anyway so I'm David
Blevins and i've been working in you
know the ee space for quite a while and
open source as well so you know 15 years
working on a project called open ejb 11
years in apache software foundation and
this would be my 10th year in the JCP
ejb3 pono was the first spec that i had
the privilege of working on I was pretty
much of an almost an observer in that
spec you know it's 10 when you get
involved you tend to hang back and just
kind of check things out for a while
before you really feel comfortable about
you know jumping in full full force but
yeah also a e6 and e7 and you know
things are ramping up so hopefully you
know be able to continue to to
contribute as much as I possibly can
alright so first the disclaimer this
topic is huge so it's not possible to
cover everything that's happened from
j2ee to now it's it's there's way too
much the Delta is massive I mean we
can't spend an hour we can spend an hour
just talking about like what's happened
in jsf or something like that so we're
going to try and you know basically I
want to focus on the non-obvious stuff
you know I want to focus on stuff that
maybe doesn't get talked about on a
regular basis things that you might have
missed you know and maybe sort of a
little bit of an
lighten moniez things are there if we
can maybe possibly get into that more I
want to talk about some of the successes
and some of the victories and some of
the things that have fundamentally
changed the way we operate in you know
EE and the JCP and just the whole thing
put together so sort of a zoomed back
perspective I think that we tend to lack
you know the 10,000 foot view of
Technology and we tend to focus too much
on this line of code and that API call
and that kind of stuff and it's
difficult to see the whole elephant
sometimes no one presents the whole
elephant from a general perspective
industry and technology so i want to see
if i can put some perspective on it and
then also want to talk about things that
we might do going forward and of course
ultimately if you've seen any
presentations of my I'm gonna do my best
to try and get you to participate so
we'll see if I can make that case all
right so topics I want to do a quick
history of just kind of big macro
changes not necessarily not necessarily
demo able but things that you gotta know
between j2ee and now then in terms of
actual technical focus I want to talk a
little bit embedded containers I want to
talk about testing and then some CGI
stuff so first of all let's let's gauge
the room who here programs in Java or
things that questions so stupid they
shouldn't answer okay I just want to
calibrate to make sure that everyone's
capable of raising their hand because
I'm going to ask you to raise your hand
a lot so I'm just adjusting so we didn't
quite get a hundred percent of the room
so I know that like a ninety-five
percent is actually a hundred percent so
I've recalibrated okay so who here has
been using you know java ee who uses
java ee now all right so we're talking
to the preaching to the choir here okay
so this is still so who who was new to
java ee very few hands okay well then
you guys already know all the stuff
let's go have a beer
okay all right well so testing is often
been a very difficult thing in Java EE
so that's going to be a topic CDI data
that's you know sort of a fun little
thing that we've got going there and
then JCP is a critical topic if you
don't understand who knows what the JCP
is all right wow really okay I'm
assuming that either your hands got
really tired or we need to talk about
this more JCP is the community that
creates the java ee specifications this
is now something that you can
participate in and it's it's important
to know where your food comes from and
your technology is coming from is the
JCP so we'll definitely going to talk
about that there are some things that
we're going to do you know hopefully in
this version of EE or maybe future
versions or might be things that we
consider revamping the way that JMS md
bees consume messages we did some work
on that in EE 7 that we didn't really
get to take it full advantage of that we
can possibly do in EE ate here one of
the things we try to get in a little bit
earlier with this concept of meta
annotation so when I say try to get in
it's already in a few different
specifications we just start
standardizing it and then I'm kind of
curious how lambdas are going to really
affect our AP is so that's the general
that's the general focus all right so
first the quick history all right who is
aware that annotations actually got into
the Java language because of kind of the
big deployment descriptor thing so who's
a fan of ejb who likes ejb okay all
right sounds like fifty percent of the
room so for the other fifty percent of
you do you like annotations yeah okay of
course Thank You ejb so you know we did
all this big deployment descriptor stuff
which was generally ok if
really bad and persistence when you're
describing all of your mappings and your
methods and stuff like that an XML
becomes really really painful so one of
the only things that people could
actually stomach doing in the ejb two
and one time frame was this tool called
ex doclet which basically had the
brilliant idea of taking the at tags and
Javadoc and then generating the XML
documents from them and so this is the
inspiration really behind annotations
and we immediately use them to eradicate
when I say eradicate I mean make
optional significant amounts of XML and
you know so if you like annotations in
the Java language and and you complain
about job and you complain about ejb
understand that those two things are
counter to each other if one hadn't
existed we might not have gotten the
other so sometimes we need to learn
lessons and that's a good thing the
other one from a high level aside from
annotations just completely revamping
and changing the way we do api's you
know when annotations came out and EE 5
really it was very limited use in the
platform in general it was heavily used
in EJ being very lightly outside of that
and we didn't see significant annotation
adoption until the second revision of
the e where EE where annotations were
present so ee 6 they're everywhere and
beyond that were of course continuing if
you use them a lot of what people
complain about EE is they complain about
the complexity and stuff like that and
you kind of have to ask people you know
what what point in time are you
complaining because if you're
complaining like pre annotations then
your your your complaints are probably
very updated your complaining post
annotations then maybe you've got
something to to offer to the
conversation the other one is that we
have tremendously simplified the
packaging so who's who's aware that you
can put just about everything in a war
file these days okay that's maybe twenty
five percent of the room so ear file
were the dominant packaging format and
it was very Russian doll you have
archived in an archive and an archive
and inside that is an archived and then
inside there's a pointer to another
archive just kidding the last ones maybe
not quite false but anyway so you had to
I do you had to take your war file and
it has a web INF directory and it's got
a lib in classes in there and you got
libraries in your web fought in your web
archive and if you wanted to have an ejb
in the mix suddenly you have to leave
that packaging structure and you have to
go to ears we all were all familiar with
that pain point and it changes your
build it changes everything and it was
very uncomfortable and so we decided to
just basically collapse that structure
and say hey you know instead of having
to make this big shift in the way you
build your software just to take
advantage of ejbs you can put them in
the web app and that was one of the
major complications and one of the major
complaints about Java EE was this
packaging complexity it also gave you
significant amounts of class loader
complexity as well because at the top
level of the ear where all of the ejb
jar files were that's one class loader
and each web app is effectively a child
class loader of that and so you have
lots of complexity that you have to
choke down so not only do you have more
packaging to worry about when you go
from a simple web app to an ear you
would have different class loading and
it really was a too much to choke down
just to get the advantage that a couple
different features you might have needed
an ejb war and it really held you can be
back in the long run so we collapse that
down everything goes in the war file
except rar files maybe we'll see if we
can do something about that so rar files
are connectors and they were pretty
unused but I suspect they might be more
used going forward so the other big
change that eliminates a lot of the
complaints about EJ Java EE in general
java ee you people say l it's big and
bloated and heavy well there are two
aspects to that so one is the number of
specifications in Java EE and so in EE 6
we decided to acknowledge the need for
smaller runtimes and so you know if you
imagine here's tom cat and here's Java
EE we basically went right there and
said that's the web profile you know and
so web profiles roughly half the
specifications of the full profile and
it doesn't include things like cmp
entity beans korba jax-rpc who's ever
had to work with jax-rpc Wow some
veterans in the room yeah okay I admire
every one of you i had implemented it's
no fun anyway it was immediately
obsoleted with jax-ws but you got to
keep both in the box for backwards
compatibility reasons so with the web
profile we were able to to op make
optional significant numbers of kind of
outdated obsoleted specs it results in a
much that's allowed result in a much
smaller runtime overall the other thing
that people complain about EE being
heavy is you know that's a lot of that's
the implementation and those have gotten
significantly lighter in the years not
only would did we you know kind of
create the web profile that was in the
e6 event in de 7 we even started to sort
of trim down the full profile a little
bit and so in e 7 CMP to entity beans
are what's called optional which means
that you know you don't have to you know
implement that feature in your app
server obviously if you do implement it
a little bit you have to pass the test
but you're not required to do that
anymore that's the best we can sort of
do in the standards in terms of actually
deprecating and removing something is
just simply you know make it optional
and make it so people don't have to
carry that burden forward unless it
makes sense for them and their customers
or their users that's the most pragmatic
approach that that you can really get to
it all right so before I get on to see
i'm going to show you one of the more
fun things that was added so we added in
e6 this concept of an embedded EJB
container so who's heard of that
okay and that's like ten percent to the
room maybe so microservices and things
like that all talking about public
static void main running everything as
plain libraries inside your side your
job playing java SE vm this is something
we actually added in EE 6 for those
purposes and for testing so it's this
new API or newish it's new to the room
so it's new and what you can do is you
put the libraries of your app server
into your classpath like you would
spring libraries or like you would an
embedded database and then you make this
call and that will bootstrap basically a
container inside your java SE vm same
way you can do that with jpa and same
way you can do that with like an
embedded database and things like that
what will happen is that the whole class
path will be a sec effectively treated
as one application so like kind of like
an ear like a big virtual ear all the
little jars in there will be scanned to
see if they contain you know ejbs and so
on so forth and then the result is one
application that you get to now run and
build and test against so when we added
that we also added global jndi support
which is sorely needed and now you can
basically bootstrap your container at
the beginning you can look up your beans
and then you can just run plain old unit
tests so here we have a project that's
got exactly two files in them one is the
bean and one is a test case this is
significantly different than the way
we're normally thinking about EE in
general we're used to thinking about
archives and descriptors and class
loaders and all sorts of stuff but here
we just have
a test case and one plain old java
object which happens to also being ejb
but it does basic things like add
subtract multiply and so forth we want
to run this thing just simply we can do
it right there in the IDE right click we
say run and then it will actually if I'm
lucky because I haven't run this to yet
today I ran it yesterday or rather last
night like 5am yeah so there we go it
was about three seconds and of course a
lot of that is disk loading so once it's
in memory I'll shrink down to about two
seconds and this is significantly
different than what we're used to seeing
when we when we you know think of e how
many people have heard that it's
impossible to test Java EE oh come on
really yeah how many people write unit
tests in there and they're java
applications ok so that was only like
twenty percent of the room so the other
eighty eighty percent of the room are
not writing unit tests you should write
unit tests the eighty percent probably
i'm going to guess are not writing unit
tests because it's probably something
you assumed was very hard when in fact
you can do a lot of your back-end
testing incredibly easily using just
this little embedded EJB container
concept it has its limitations in the
sense that it only standardly applies to
ejb light we have a different couple
different options salud that we could
you know incorporate but there's also
this you know first of all let me show
you something really cool you can
actually because this is all playing
java SE there's no there's no there's no
processes running externally you can
throw a breakpoint on here run this test
again in debug mode
and Powell should show up there you go
so now we can actually see our variables
down here at the bottom that's too tiny
for us but but yeah you can actually
step through and walk through from your
test case through to your beans who
thinks that that's really cool okay that
should be like one hundred percent of
the hand so our calibration is going
down i'm going to assume i'm going to
assume so that's just one of the changes
that we made in the ee 6 which i think
has been uh not quite noticed enough
considering the impact that should have
on you that eighty percent of the room
only you know only twenty percent of the
room doing actual unit testing insight
for their iggy applications that's not
nearly enough it needs to be a lot more
and you could see that was like you know
two seconds test i mean like show me the
heavy you know it's you know that that
that's a mindset of ee being complicated
and heavy is is really not the current
reality it that's 2006 when you really
kind of think about how much in the past
that is that's a long time things tend
to change who's only been in the
software industry for five years or less
who's been out of school for five years
or less okay yeah that's a pretty good
amount of the room as time ticks along
the people who have kind of been burned
by the two thousand to two thousand five
frame of you know big monolithic app
servers you know we're slowly retiring
all right so you can also do more fun
testing you can do persistence
standardly inside with the embedded EJB
container so here we have a unit test
and we are our little application as
just two classes so we have a movie jpa
bean and we have a stick full session
bean that does the actual persistence
work with the entity manager injected
into it
and in our test case we simply have to
go ahead and this little part here
non-standard so hopefully that might be
something we could consider for some
future version of the specification we
sort of have this little informal
extension which is you grab the context
and you say inject and you get your
instance injected I don't know that this
would be what I would recommend that we
actually standardized that actual syntax
we could probably come up with something
better we neglected we chose not to add
this to the specification in EE 6
because it was we wisely thought it was
a bad idea to do it just for one
specification and not offer sort of a
general dependency injection thing
that's sort of after the fact across the
platform that was a very wise decision
now tell you one of the things that I
think that even I've personally have
learned in EE 7 we had the conversation
should we add embedded container type of
profiles for web you know for web apps
and should we add them for CDI and
should we add them for this spec in that
spec it's the natural request when you
see something like that the problem is
is that what happens if you are using a
web app or an app let's just call it an
app that contains an ejb and a servlet
oh my gosh which bootstrap API use you
know and if it contains a CDI bean now I
have three choices of bootstrap api's to
use it was perhaps it was a good step
forward for us to add the you know
embedded EJB container API because it
required you know the industry to think
in small se terms it was an absolutely
critical step forward but it did it did
leave a bit of a bit of a mess in terms
of now it's a little bit more tricky for
us to complete the puzzle and add one
API where you can bootstrap the whole
container in your java SE environment
which should be something
should be able to do that's my
definition of EE nirvana when you can
actually just have your public static
void main have one application in one
class loader and have all the features
of EU right there that would be so so
great that's really what people are
talking about with like this whole
microservices thing and you have it a
little example of it that uses some
non-standard extensions I have a
singleton and it's got some jax-rs path
stuff on it and it's got a basic get
method and then there is simply a public
static void main that loads up the EJB
container using a combination of system
properties and files found on the
classpath and then go ahead and it
blocks the vm so effectively we are
making a tiny little mini server and
this little me server has one restful
service in it with one method and it's
you know about as what as small as you
can get for an application for us to run
that type of thing let me go into that
section the project increased font
okay maven clean stall
so in this little project I have who's
familiar with maven by the way who yeah
the whole room okay our calibration is
back up to ninety five percent that's
good I have just the shade plugin which
is a plug-in that allows you to make
kind of an uber jar so I have a project
basically that contains the embedded
container my restful service and then it
makes in big goober jar so I have
effectively one jar and I call
microservices snapshot and that's the
only thing that I need to run my
application now
okay I'll address already in use okay
this is what I get hold on real quick
okay tons of processes running
okay let's give that a whirl again
alright
and FYI i have way more content and i
have time so we're going to go and pick
and choose based upon preference what is
the deal what's that oh all right notes
dealer you thought my job and are ready
okay that's good now I got a connection
refused one more try third time's the
charm isn't that right okay yes it was
through time's a charm okay so here's my
arrest service logged in in the startup
log if I go to a browser I hit that I
get my nice little JSON back and then
obviously this is a tweet quotes from
earlier in the conference about deadlox
for kids go after your dreams just going
to be technology behind it great great
quote so there's a micro service
everything you've heard about
microservices probably leads you to
believe you cannot do them with java ee
that is entirely not true that does it
mean that everything about this is
standard but if you're going to go in
the non standard approach and go
completely into some other direction
then you're obviously into the
non-standard section anyway does not
mean we couldn't do this as a standard
approach it means we have yet to do this
as a standard approach and that's one of
the things I think is really critical
that people lack an understanding of
time we as developers tend to only think
one year in the future and so when
something isn't the way it is now we
just somehow assume it's never going to
have the thing that we want we don't
imagine the e specifications as
malleable and as changeable when in fact
they are you know so it's it's it's it's
quite interesting thing that if you were
to go backwards you know five years you
would never imagine any parsian of this
being standard and now at least some
portion of it is standard but what we do
instead of things like this is we sort
of just take all these jars and we mash
them together or as the hipsters like to
say we potato them together and then you
know we come out with this little with
this little you know mashup you know or
potato up that you know is like which is
which is which is you know completely
understand ur deceased a nerd
and we could actually complete the
puzzle if we put the work into it so let
me let me you know let me talk just a
little bit about the JCP here because
I'm I'm going to run short on time but
it's important topic
all right I mean auto order look there
it was okay so here's accuse assort
short history of the JCP in in in 2004
we know in two thousand there weren't
any open source involvement in Java EE
in general and it was completely closed
you know type of forum invite only I
should say and it worked all right in
2004 though you know things like
Geronimo and jboss and Jonas there were
all these open source implementations
that didn't have access to the java ee t
ck and they were really doing more harm
than good by not being certified and so
eventually we got it worked out to where
we could actually certify them and so we
had the first certified open source java
app servers in 2004 so that gets us from
2000 2004 now from between that time and
2009 we saw our actual first open source
TCK so CDI and bean validation actually
have TCK that's open source so who knows
what a TCK is i'm going to guess this
going to be really low okay yeah so that
was seven ten percent of the room glow
when you create a standard technology
how do you know that people implement it
correctly well they have to have access
to some tests and everyone has to pass
these tests these tests are what offer
our portability so them being visible to
you is an important aspect of having a
truly open forum means that when you
find a bug in your app server you should
theoretically in an ideal scenario be
able to go to the tck and see if there's
a test floor and if not maybe contribute
one and then that would ensure that
future versions of the specification
cover that because guess what does it
matter if your IBM or oracle or whatever
the size of your company is you always
are going to have limits on your
resources and
this has an impact on all of us there's
never enough tests anybody who says they
have enough tests is probably just not
looking hard enough it is never enough
test so that was 2009 so we've gone from
no open source to some open source
implementations and now we're seeing
open source basically in the JCP itself
and then in two thousand you know in
java ee 7 here we completely opened up
the JCP process this is the biggest game
change that we've seen in the last 10
years we now have the ability to
participate in the JCP AKA participate
in the creation of java ee itself this
is a fundamental shift and absolutely
everything if you don't get to vote for
your leader then you get to complain and
if you don't like them you can say they
suck and I'm very dissatisfied with them
and things like that but if you have the
ability to influence and you have the
ability to participate and you do not
like the solutions that come out then
you're the one who has to step up and
that is the biggest shift in our
industry we have an interesting
standards body that almost no other
language has you know there's not a ruby
Standards Committee and there's not a
you know so on so forth that and those
do not encourage competing
implementations and things like we have
sort of a magical ecosystem here that
started out completely proprietary is
opened up slowly slowly throughout the
years and now it's ours and it's very
very different than what you may have
thought about in the past I I was having
a conversation with you know want
somebody in the lobby and they were
saying oh you know give me that one key
java ee feature that I need because I
think all the features suck and I said
standards are their own justification
that's the only answer that's important
because you can add anything that you
want to the standard and if there's
something basically if someone says oh I
don't like the standard because of one
two three and four
like great you've just listed for things
you could help up with you've just
you've just enumerated your to-do list
you know step up so what's going to
happen over the next few years it's a
little unclear it all depends upon us at
this moment we have an industry that was
probably for not predominantly vendor
participated in and it's been slowly
opened up and you know this time around
credit Swiss for example is trying to
get a JSR in for you know configuration
and that's one of the first times that
we're seeing you know a non vendor put a
JSR into the JCP process and i would
love to see a ton more of that really
there are hundreds of companies out
there and there are you know three four
you know major vendors or or so it
really is our game to play it's really
are two to do we want with and obviously
we have to work together but you know we
could be carrying the burden ourselves
we could be defining the technology that
we use inside of our enterprises and you
know these this is the change that it
really depends on how much we get it
that will benefit us it's a tool and
it's not a silver bullet anyway so
who-who's I've got a plethora of topics
who's familiar with CDI okay that was a
very large percentage of the room who is
familiar with any of the new JMS MDB
types of magic stuff that we're going
who's seeing any of the talks that maybe
Nigel Deacon has done this this this
week all right who uses JMS okay that's
a large part of the room art will do
that all right so here is what a
message-driven being looks like
currently you have here basically a hash
map at the top of a class and that
configures the class and who has ever
had to look up the keys that your JMS
provider supports when you want to do an
MDB and it's you found it just a really
big pain in the butt yeah okay lots of
the room theoretically and you know all
of this stuff is loosely typed so it's
string and string and string and string
and when we standardized annotations
into EE and ejb specifically we missed
the opportunity to really revamp MDB
relationship and so we took this name
value pair thing we had an XML and we
moved it straight into annotation form
in the specification this is very much
like the servlet kind of concept of
you've got one big service method and
everything is in that service method and
it makes it so you have to do lots of
basic work you know what kind of message
is this and then I got to cast it and
then I got to grab the object and then I
can do something so you got to load a
lot of boilerplate and what jax-rs has
showed us is that there is way better
ways to do this kind of API so here's a
glimpse after some changes that we made
an 87 of what a possible future could be
4m DBS okay who thinks that that is
significantly better okay who thinks
this is worse I guess we didn't get
enough hands there yeah I mean this is
strongly tight so some of the this is a
not the full one oh yeah this is what
should be hold on a second
there we go that's what that should look
like now ask the question again who
thinks this is way better okay okay who
thinks I didn't debug my code well
enough for tested significantly me too
so the significant change is really two
one is that all of our properties are
now now strongly typed we know exactly
what they take we also know their
default values in this case none and you
know we this we have you know the name
of it and then more significantly in
very much jacks or a style we can have
multiple methods that might take a
message and so instead of having 1mdb /
consumption of a topic or a queue and
then having like 50m DBS you could just
have like one and 50 methods in there
basically it's up to you now so the same
thing that jax-rs brought into consuming
HTTP messages we could do a similar API
now for mbbs and that's just really
really really cool another thing that I
think is going to have significant
impact on the platform is this concept
of meta annotations so those concepts of
men annotations is we have duplicated
annotations significantly in our
applications over the years so here's an
ejb that just uses the schedule
annotation API and so this one is going
to be invoked basically from May to June
and it's going to plant the corn and
this meth is going to be invoked from
you know september-october it's going to
harvest the cone and of course if you
know any jokes about farmers they have
to check on their daughters every second
of every hour of every day and so we
have a little method on here it says
check on the daughters you know and so
this is great but when you have a
significant amount of stuff like this in
your code it can you know take a long
time it can be very difficult to
maintain so the idea is to be able
to do like that way way way more
maintainable and it's descriptive so I
pretty much had to read you the schedule
before but this you can read yourself
and by the way this this we have an
implementation of this already and so
this test case will run and it just
basically weights five seconds and says
did you check on the daughters five
times and that will that will go and so
this is something that I think is really
it definitely benefits e but are also
event its benefits java SE being able to
you know imply other annotations with
with annotations is very valuable here's
i've presented this a few times and i
think i found a great way to describe
why it is i think it's absolutely
astonishing that we had don't have this
already so here is let me close all this
stuff here is some java code which
effectively would be the equivalent of
this HTML come on expand all
okay we wouldn't do this in HTML these
days but we do do this in Java this is
our reality in Java this is sort of like
a one-for-one port and I'll increase the
font here of what we do in annotations
compared to what we don't want to do and
HTML in HTML we know we don't want to
duplicate all these attributes and
everything all the time but yet we do
this in our Java code as if it's okay
and what we have which will when we when
we first tried XML we missed something
we got it wrong in the sense that your
XML was always pointing at methods of a
particular class so when you refactor
those methods it broke all of your XML
and that would be similar to where if
your CSS used like a really long path
syntax to point at a certain part of
your HTML document and then that gave it
the style but then you changed your HTML
and all your CSS broke well that was our
reality with our relationship of XML to
Java code then when we added annotations
all that stuff went right back into the
source code and is now duplicated
numerous times throughout our code so it
is easier to maintain but then we lost
the ability to actually externalise any
configuration if there's one thing that
the relationship between CSS and HTML
has proven to us it's that if you label
the tags to elements and then apply the
style to the labels you gain all the
flexibility you realistically need and
this is ultimately what meta annotations
is all about so here would be the meta
annotation equivalent of that HTML and
that XML file
so there we have title body that works
too and then that would be our HTML
equivalent this is so much easier to
maintain as our code base grows we can
now tweak and change these various
annotations which themselves have on
them what we normally were copying
around it bobbles my mind why we didn't
consider this so much earlier I mean I
understand it because we evolved as an
industry and when problems have to be
really really bad for us to make it to
really feel the justification for the
change but when we look at how we do
things in other spaces you know HTML
would be would we did this in HTML
copying the attributes for like a decade
until we learned yeah this really sucks
I think we're right about that phase in
Java once we actually extract these
things out you could you could
effectively write a file that maybe
would override the news annotation and
then we could regain the ability to do
xml-based configuration but not
reintroduce the part where we're
pointing at particular methods in that
really inflexible part so we'd be
pointing at annotations and then the
code can change as much as it wants the
annotations would keep our link with
that section of the code just the way
CSS classes keep our link with our HTML
and it can change as much as it wants
that is a big game changer for the way
we do all work and job I think it would
be great thing great great thing for us
to add okay another one is the potential
impact of lambdas but before I go I want
to make a digression another one about
standards
so who has heard of spring data okay so
spring data is basically this API that
allows you to simplify all the
boilerplate associated with the
entitymanager persist find query methods
and things like that who's familiar with
the concept of the spring people do not
like ejb okay that was a rhetorical
question what's the worst thing that
they always talk about when they talk
about ejb cmp perhaps okay yeah so
here's the spring concept for this
you've got this interface and in the
interface we have a find method and we
gotta find by last name find my first
name find my person or last name and we
have a basic jpa entity bean and it
extends this myth this superclass
abstract persist able so the
relationship between this interface and
this entity basically allows the spring
boot library to do all the magic
required for those finders to be hooked
up and so on and so forth so I actually
fully put this in the test case I
grabbed this straight off the website as
as is so here we go I better run it or
see how long it takes because we all
know that spring is way lighter than
Java EE man this is like fact because
I've heard it more than once so I'm
assuming it must be true so that run
about five seconds so you know I think
it would be good for us to write an API
to to kill this because of course we
have to copy the spring guys at every
possible turn because we can't get left
behind right i mean you know like
jobbies gotta move forward or it's going
to get left behind this is what I know
so I wrote a new better API okay
and here it is so I have instead of a
sample configuration a user repository
and a user object I have a simple
configuration user repository and a user
object and here's what my user
repository looks like it has the extends
from crud repository it's got a fine
method and then I can just go ahead in
my test case and do all the same stuff
all right I'll go ahead and run mine
ok
alright that ran are about five seconds
so they both ran about five seconds so
I'm assuming you all agree with me that
mine is like way better right it's
completely new and original who would
agree that I've really added some
innovation here come on one hand yeah
yeah someone's gotta agree with me right
yeah okay good good yeah would you
believe that one of these is 13 years
old yeah here's the little joke I'm
going to go put them up side by side
there's simple user repository that's
the spring one and here's simple user
repository that's the new one split pain
here that's not what I wanted to split
ok
alright so we're stacking them up side
by side okay they don't look very
different they're pretty much line for
line the same but here's the joke did it
right it is the same right oh well maybe
we'll see yeah yeah yeah hold on simple
user repository okay that's better so it
wasn't got my name on it it's way more
innovative everybody should know that
okay guess what this is that isn't cmp
to entity bean isn't this really ironic
I think is this is like one of those
moments where you realize that you've
become your father yeah you know when
this new cool awesome idea is the exact
thing that you kicked in the dirt ten
years ago and you're now presenting it
here as a brand new awesome cool thing I
mean you know it's better because it
uses jpa instead of the oldest E&amp;amp;P API
behind mine there's actually a bunch of
XML that's a key but that just goes to
show that maybe the right tools weren't
there to do the job correctly and when
the tools change you need to stop
thinking about things in the same old
static way if you were using EE in the
annotation in an XML era and now you're
you're doing it you're having that same
mentality today you got it you got to
ditch it things can change and in fact
now we're more the same than ever this
whole spring versus EE thing is kind of
garbage we're making the same stuff the
only thing we're not doing is
participating in the JCP together and
that is my biggest gripe I love the
innovation coming out of spring I just
think hey guys join up in fact when I
say they love the innovation coming out
of spring if they were on the ee expert
groups I would just be
talk about how great they are because we
need people like dad expert groups so
I'm not going to dare say that that crew
is bad I love the Google ideas join up
these things are now open there's no
reason to not do it you know it's it's a
it's quite a vital thing I'm going to
run at a time but I'm going to do one
more okay so here's a possible view on
how lambdas could affect the language so
we've just established that we've just
appellant we just established how XML
kind of encouraged one style of AP is
and annotations encouraged a different
set of AP is and then we're talking like
you know seven years of our life and
another seven years of our life and
what's the next seven possibly going to
look like well here is what currently a
timer service looks like in ejb you know
we can say this is the same planting one
that we had before but done using the
programmatic API that is an ejb you have
to basically create a config object
which is you know some state you say you
pass the state to the timer service you
give it the time that you want so you
can say hey from May you know 15 to the
end of the month fire this state at me
every day at 8am and you get really
though only one method that will get
invoked as a result of that timer so you
can have you know we got here five
timers that all do different things but
our API only allows us to have one at
time up method so we have to find ways
to cram in all different work that we
want to do under the covers of that one
time out method and so we have to do
things like this in our timer config
we're putting the string in there and
then we check for that
string in our timer object and then we
execute the appropriate method based
upon what configuration that timer was
given and that allows us to have
different logic this is the best we can
do currently however when you think
about what lambdas offer instead of
having to you know pass data around or
annotate methods you can pass methods
around so what do we were to do this
differently I got to change my lane
language sin to know I won't you have to
trust me that this is now complaining
only because I have my ID set up for
Java 7 basically that is java SE 84 a
method reference and that allows you to
point to a method and pass methods
around so instead of us making this
config object and passing it into the
timer service and saying execute my
one-timer method with this data at this
particular time every day now if you
have 5 10 or more timers that you want
to create they all have to get shoved
into that one time I'll method we have
the opportunity to pass the method that
you want executed at that particular
time so we can programmatically
basically set up any number of timers
all right there inside the code
programmatically by passing methods
around its I really have the feeling
that the change we saw from how we
design api's from XML to annotations was
great and st. it really we don't a lot
of those api's are completely different
I think we're going to see a similar
reinvention of EE in general because of
the impact of lambdas method references
an obstreperous a shin that comes with
it it fundamentally we fought before
like you don't need interceptors like
you used to before we had to take on
method that was immobile and we had to
stack on a bunch of annotations because
that's the only way we can attach
behavior to it now we can have that
behavior as lambdas or method references
and wrap them with other method method
references effectively on the client
side creating a runtime you know clade
creating a little interceptor stack and
executing it and this is fundamentally
different so I do recall very vividly
there was one person in the expert Carla
de Wolfe who was a great great engineer
works for Red Hat and when we were
adding at a synchronous into the ejb 3.1
and a specification he came out and said
you know but we're forcing the the the
desire for it to be asynchronous on the
actual implementation logic and then you
can't actually let the client decide
whether or not it should be a
synchronous and asynchronous call or not
it's always going to have to be
asynchronous call and he said it would
be so great if we could actually just
move that decision on to the client side
and we just couldn't think of a great
API for doing that because it would have
involved in her classes or some sort of
weird thing passing kind of stuff around
now with method references you can pass
behavior around and you could wrap it
with an at asynchronous or not a
synchronous type of a you know methods
expression and then execute that and
actually gain some interesting things
there so I think that probably what's
going to happen is that in ee8 will see
some innovations from lambdas and and
streams and things like that but just
like our first spec revision with
annotations was pretty modest and pretty
conservative I think we're going to see
a pretty modest and conservative ee8
with with some lambda expressions and
things like that ee 9 is probably going
to bring a truck load because then the
industry will really have understood how
to use them and it will be much more
significant
but I do say that the timeline on all
this stuff really depends on us you know
it's a it's yeah I didn't get to go into
CEI but the timeline in this stuff is
really all on us you know we get out
what we put in I think that's the bottom
line is if you know I'm on a time but
garbage in garbage out that's a common
expression I do want to make one comment
about portability I always hear
portability being referenced as a reason
that Yee is bad no this portability is
not a silver bullet it's a life raft it
doesn't it's a chance at survival
without portability you have no chance
that survival keep that in mind I think
unrealistic expectations of portability
make people discard it as a concept
completely standards do offer some
portability and understand that don't
put unrealistic expectations on it to
where you think it's invaluable and just
throw it aside I wouldn't go cutting a
life rafts off my ship anytime soon it's
better than nothing you can release
maybe save some things and that's the
right healthy way to view portability
and the next 10 years are up there us
they're up to us get involved in the JCP
and please help us create the next ten
years thank you very much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>