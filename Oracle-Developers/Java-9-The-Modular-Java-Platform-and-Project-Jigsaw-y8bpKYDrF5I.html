<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Java 9: The Modular Java Platform and Project Jigsaw | Coder Coacher - Coaching Coders</title><meta content="Java 9: The Modular Java Platform and Project Jigsaw - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Java 9: The Modular Java Platform and Project Jigsaw</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/y8bpKYDrF5I" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">right now we're here to talk about
jigsaw for an entire hour and nobody is
gonna cut us off
well they might cut us out off at after
an entire hour but we plan to be done by
then all right
the JDK Java SC is a monolith it's as
big gargantuan thing that is essentially
indivisible well it comes in a couple of
flavors now but it still it's still this
big giant thing this has a number of bad
consequences one is it's hard to fit
Java SE into small devices we introduced
the compact profiles in Java 8 which
helped somewhat with this problem they
do allow a very minimal configuration to
fit into 11 megabytes on Linux arm but
there's not much flexibility in that
limited set of compact profiles if you
mind that why end up needing you know
one XML thing then that that's not the
core XML stuff then you have to drag in
all 54 Meg's and that's no fun because
it's a it's a monolith performance is an
issue it performances an issue on a
number of fronts of course the Java
speak performance these days is actually
pretty darn good what's often it's still
very painful is start a performance
because there's just so much stuff to
load they've got a class path full of
jar files arranged in linear order it it
is not unusual in our experience to see
products and customers where the class
path contains over a thousand jar files
so guess what happens if you invoke
class dot for name and pass at the name
of a class that doesn't exist in any of
those you're gonna open every single one
in a linear search now there are some
clever indexing schemes that kid that
can look that a bit but you know we
ought to be able to do better there are
also lots of kinds of optimizations we
can do things like ahead of time
compilation and aggressive inlining that
are are possible with today's model with
extractor but still fairly difficult
another problem is security you might
have heard the last couple of years
security of the Java platform has been
an issue fortunately it's much less of
an issue now than it was a couple of
years ago but it's still something that
we we're thinking very deeply about and
we are looking for ways to improve the
platform and its implementations so that
they can be made more secure secure so
it's easier to look at the code and and
validate that oh yes you have this this
piece of code is not be going to be able
to have used that other piece of code
over there even if an adversary manages
to get in part a part of the route of of
the security problem is is early Java's
you know basically let lack of anything
except classes and packages so here are
all of the packages in the in the
compact one profile in Java 8 now a
bunch of these you expect to see there
you know Java tough time you know
java.net you know drop it out lying
everybody wants to use drop it online
that's all good stuff you should you
know user code should be able to get too
bad there's some some JDK stuff some of
this is is meant to be used by others
there was a JDK done I know that's
missing from this one but a bunch of
this JDK stuff is actually internal
there's a bunch of Sun stuff absolutely
not absolutely none of which was ever
intended for use outside of the platform
implementation so how do we how do we
prevent say a Java applet running in a
browser from accessing the Sun stuff in
it and the JDK and journal stuff well
there's a mechanism called the the check
package access method in the security
manager class so if a security manager
is operative then this check package
access method needs to be invoked at
just the right time in hundreds of
places throughout the JDK codebase to
see if the code on the current thread
can actually access one of these
packages now imagine what happens if you
miss one of those several hundred
code locations see the SS 9.3 at least
usually so that's pretty painful we
really need something you know something
less brittle than this mechanism another
sort of related issue to security is is
just the fact that these internal things
exist and if you're not running with a
security manager which probably most
Java code doesn't Java developers
knowingly or not have come to depend on
internal api's this makes it pretty hard
for those of us who work on the platform
itself to evolve it you know the the
whole the whole intent at the beginning
was no you shouldn't be using this stuff
but of course people do now in some
cases this is understandable you know
there are certain things that you know
if you're really after the absolute most
bleeding edge performance then you're
just you're really gonna want to use
some of this gun safe and we understand
that and and that that's that's kind of
understandable but other other cases
where where people are writing libraries
that dig into the guts of of the the
copy of the XML parser that's in there
is just no but it leaves us in this
conundrum where you know we may have no
sympathy for developers who write the
code that directly depends on this but
lots of Java developers to use libraries
and they might not even know that the
libraries they're using or the libraries
that that their libraries that they're
using you're using
depends on this stuff and we don't want
to break them so we've been very
conservative about not changing this
internal stuff even though it's marked
internal and even though we've been
telling people for 18 years not to use
it
all right so the JDK is a monolith that
brings the problem problems with it of
course you know what we would really
like rather than this huge and huge
indivisible thing is a pile of Legos
right we want it we want a box of parts
that we can assemble to solve whatever
problem we have to hand with just the
parts that we need rather than having to
carry along a whole bunch of other parts
that we don't need so this is where
jigsaw comes in
here's to doing a jigsaw puzzle so
jigsaw is a colleague of mine likes to
say nobody's actually asking for jigsaw
as such and you know what he's actually
right but people people are asking have
been asking for it for some years now
for solutions to the problems I just
outlined and so that's you know that's
why did we see jigsaw as a unified
solution to to all of those issues it
will help with with getting Java on to
small devices in a more flexible way
because you can you can use just the
modules that you need it will help with
performance because we can we can we can
do like do like lots of lots more
optimization when you can tell that the
scope of what of the code that some code
could reach is limited by the modules
upon which it depends help with security
because models define a natural boundary
a natural Verity of can be a very hard
boundary so that a module can hide its
internals you hide it in the same sense
that a private method is hidden in a way
that's protected you have controlled by
the virtual machine deep inside and of
course that also helps with with
encapsulation maintainability because
well if you know some biscuit base 64
decoder is is behind the wall then well
you can't use it and when it's no longer
used internally in the JDK we can just
remove it alright so that leads to the
question of course what is a module so
we but the whole point of jigsaw is to
define a standard module system for the
Java platform for which there where
there will be a jsr of course and apply
that model system to the platform itself
into the JDK and eventually to 2sc
applications and and even EE
applications what is a module well I'll
show you the Marvell graph though the
whole graph of models in the JDK in a
little bit but to start with let's just
look at what we call the base module so
there's there's one module called Java
base upon which every other module
depends so it dropping out bases it's
the java dot Lang of the module world if
you're a module you're gonna
depends on dominant pace whether you
want to or not you can say that you
depend on job at a base but if you don't
say that the compiler will will infer it
for you
so government base has what couple
thousand classes in it among other
things it has the very important drop it
up lying package because well everybody
needs traveling object got lang string
another module that we have is the
sequel module lots of applications need
to use JDBC so there's a sequel module
it has the java dot sequel package java
ex-nazi package some internal packages
that are aren't shown here so inside the
sequel module i started so the sequel
model depends on up on the pace
obviously because there there must be
references to java.lang string in here
right oh yeah there's one
so the sequel module needs to use types
in the drop applying package and base
module but if we go to compile that we
will actually get an error because drama
time Lang is not exported in this
diagram so far it's not exported by Java
ad base
it sits behind a wall it's essentially
private ok so let's fix that I'm
intentionally avoiding any linguistic
notation here this is purely visual
notation to get the concepts across
let's fix that by exporting the Java dot
line package to any other module
wildcard and we'll stick that here and
that means Java dot lying is available
to any module that chooses to depend on
the base module which as I just said is
every single one of them so we do that
and then all of the types in the
java.lang package are now available for
use by code in the sequel module ok
confident sequel and job X that's sequel
to find a bunch of useful types that
anybody should be able to use right so
we will make those available also by a
wild-card so any model that depends on
this will get all of these all of the
types in these two packages which is
pretty much what you expect now there's
some other code in the sequel module in
for example the driver manager class
that uses the Sun don't reflect API now
sometime reflect is an internal package
you can tell by the first first four
characters s you end on
and that is also in the drop of a base
model but it's not exported by job at a
base so if we tried to compile this
naively well it still wouldn't work so
what we need to do is export it to make
it available to the sequel module but we
don't want to put a wild-card here if we
put a wild-card here then anybody can
invoke some don't reflect and we haven't
made our security story any better so
what we do is a limited export we export
reflect package only to the sequel
module so if your the sequel module you
can you can use this and you'll get
you'll you'll get the types from the sub
not reflect package if you're some other
module and you depend on top of that
base you won't and and you won't in a
very strict way the VM won't let you get
it even if you go through a reflection
API you won't be able to get it okay
there's some other code in the sequel
module for example in the driver class
there's a method called get parent
logger which returns a logger from
everybody's favorite logging API Java
util logging so obviously to compile the
sequel module we need we need to fix
that up so sequel depends on logging
though the logging package is exported
to all comers of course and so those
types are available here logging of
course depends on base cuz it's gonna
need java.lang object it turns out
logging also uses some dot reflect so we
can fix that up by exporting some not
reflect also to the logging module okay
let's consider an application we have an
application it's gonna depend on Java on
base because every module depends on
Java web base it wants to do some
database access so it depends on is
equal so it gets all the types from the
sequel and Java X dot sequel packages
that's all good
there's some code in the app module that
gets a JDBC driver invokes the get
parent logger method and then invokes
the info method on the resulting logger
now in what package is this info method
defined anybody
Bueller logging exactly does the app
module depend on logging no so that
would be a problem there are a couple of
ways we could fix this one is we could
say well if you want to do that then you
have to be clever enough for your ID has
to be clever enough to add one of these
great dependents edges from from app to
logging so that so that it all works out
but that would be kind of funky because
in a sense conceptually the sequel
module is giving you access to that info
method even though you didn't argue you
didn't actually depend on on the logging
module so what we do instead is define a
notion of a module depending on another
and re exporting all of the second
modules exploits so sequel depends on
logging and this dark arrow indicates re
exports so everything everything that
logging exports to everyone is also
implicitly re exported by the sequel
module so now because App depends on
Java not sequel it implicitly gets all
of the types in Java util logging made
available to it that way that in this
sense the code in Apps sees a consistent
view of all of the types in Java dot
sequel if coda if code and Java dot
sequel it changes if say a new API is
added the refers to another type in some
other module that you never needed
before when you're using when you're
using the sequel module the react sport
just makes it automatically available to
you you don't have to go changing your
code around all the time as the API in a
module evolves and expands over time
okay I'm just to finish up there there
are of course well there many months
there are many packages and drop it up
base but there's another one some dot
invoke which it turns out truly is
totally internal it's not exported to
anybody this has as some of the guts of
the invokedynamic method handles
implementation and for kind of obvious
reasons we don't want anybody to get to
that and so we won't okay any questions
about this stuff so far a lot of time
time for questions at the end too
okay so we want to sorry yes in our in
our conceptual level of modules you have
to ask for it explicitly it's not it's
not implied so for example if if app
were we're really some library module
some other model that depends on it
won't get the sequel types
unless this edge were made darker data
to it to re-export those so so as the
creator and maintainer of a module you
get to choose so the other models that
you depend on to do you want to re
export their types or are you just using
them internally yeah are which
transitive
only only along these dark edges insofar
as you have re-exports edges everything
will be transitive yes correct
okay let's move on so the next slide I'm
going to show you is the Montville graph
so we want a standard module system
apply to the to the platform itself it's
kind of a complicated picture of our
warning up front but we'll walk through
it fortunately since this is a nice cozy
room I can just stand here and point to
things so starting at the and well first
let me explain the color scheme if
something is orange then it's part it's
intended to be part of the Java sc9
platform definition so the se9 platform
definition will include sort of the
orange sub graph of this graph if
something's blue then it's a module in
the JDK which may or may not be
something upon which a library or
application can depend we have depending
on whether it's in whether its internal
or not okay so down here is the base
module every module depends on the base
module directly or well directly it
turns out the edges I've shown here are
the transitive reduction if I showed you
every edge then this would be a
completely the screw ttle slide full of
spaghetti so the transitive reduction
that is all redundant edges are emitted
if you want precise definition consult
Wikipedia that definition is actually
pretty good so there's the base module
at the very bottom we have sort of a
stack of modules going up so the grey
circles show the relationship of modules
to the compact profiles that we defined
in in se8 so the base modules here on
its own the compact one profile the
circle here has base logging and the
scripting API
no actual scripting engine compact2 is
in this next circle that ads are my
sequel the core XML just the parsers and
transformers and stuff and includes
everything to come back one compact
three this circle includes everything in
compact two plus security sazzle
security jgs s management naming sequel
rosette instrument security Akal
competin the compiler api but no actual
compiler preferences in case anybody
actually uses them and XML crypto and
then finally what you can't quite see
the the lightest circle probably but it
goes all the way up here that's actually
an oval this is the the SD module pulls
in everything in compact 3 and adds the
parts of the SCA API that remain which
are XML Web Services XML soap XML
binding CORBA activation desktop this is
actually a giant module it's a WT and
swing and 2d annotations common which is
the teeny little module it just has a
few other things and so that's all they
were interested blue edges sorry III
wasn't quick completely court and
color-coordinated blue edges are
re-exports dependences so if if you
write and write an application that
depends on compact one you will get all
of the all of the exported types in
compact one logging scripting and of
course base similarly if you if you
write something that depends directly on
management then you'll also get our my
angel get base so you always get base
the grey edges are meant to show
implementation dependences so for
example where's a good example scripting
not not scripting down azar this is than
is the nas horn scripting engine Estoril
x support point out it's pronounced and
Nas horn not nashorn in Osborn
that of course depends depends on the
scripting API it also turns out to
depend on the logging API but these are
strictly implementation dependences if
there is a little nos or an API that is
a public API and is supported for
external use so if you write an
application that depends on nas whoring
you'll get the nas for an API but ye but
if you want if you want the actual
scripting API you'll have to go import
it you have to go depend on that module
yourself and you'll have if you want
logging you really want logging you'll
have to go depends on the logging module
yourself so that's what they do that's
what the grey edges mean
okay so I've talked about the blue edges
the gray edges the orange modules the
blue modules are other modules that
happen to be in the JDK we have a bunch
of things that provides provides
services through the Java util service
loader API so care sets is one of them a
bunch of these the crypto providers
agents there's a file system for Fornaio
there's the HTTP server that's used to
create xml web services endpoints so
this is an example another it's an
implementation dependence if you depend
on the XML Web Services module you won't
actually get to see the HTTP server API
but if you use this API to create a Web
Services endpoint then it will use that
but it's strictly in a simplement ation
we've got tools Java doc the Java C
compiler RM I see the tools to go with
XML Web Services and binding a hotspot
agents bunch of serviceability things
more naming stuff naming with our my
naming with DNS more security stuff and
oh yeah smart card i/o
way up here smart card i/o is an amazing
amusing exception it should really be
colored both orange and blue because it
turns out it is a JCP standard but it's
a jsr that is not part of java SE so
it's not orange but it actually is
standard so it's it's kind of on the
edge
so that's the mantra graph and the
beauty of it is once once you've done
this and Mike who does too
- Mandy Chung and Alan Bateman who've
done most of the work over the years to
create this out of the bowl of spaghetti
we started with one two once you've done
this if you have an application that
only uses three modules you know you
pick the three compute the transitive
closure in this graph and those are the
only modules you need okay questions
about this it's that available on a PDF
somewhere not at the moment so so this
this this is available in a fairly large
ping if you go look at JEP 200 in open
JDK so this whole modular ization effort
is a is a fairly big project as you
might imagine we have in open JDK we
have this this process called the the
JDK enhancement proposal process where
we we propose proposed changes that are
of significant size or need exposure and
take them through through a little
process - so we can communicate with
with other people who are interested in
it document what we're doing and
eventually stuff like that will get fed
into the appropriate jsr if necessary so
Jeff's have numbers Jeff 200 is the
jigsaw module graph definition if you
visit that you will see a ping image
generated by graphviz from a dot file
that's actually you know from our
current prototype build this was this is
based on that graph I believe every
every edge in that graph is in this
graph I abbreviated many of the names
because in actuality all of these orange
ones have jav a dot on the front always
blue ones have JDK dot on the front
except for smart card IO which is JAV a
dot on the front and if I had done that
then people even in the front row
wouldn't have been able to read the
slide but otherwise I believe
all of the edges are here so so that's
there and as this we're reasonably
confident in the overall shape of this
graph at this point we've been working
on this for years
it will probably shimmer a bit as we
proceed you know through through JDK 9
but it's we think it's pretty stable
yeah sorry
drop it FX right excellent
excellent question John so Java FX is
not on here the you know as I said the
graph the graph is generated
automatically from the build it is an
oddity of our build system that was that
when we when you if you go to open JDK
and clone a JDK 9 repository forest
there's no code for Java FX in there
right
the Java FX code is over in another
related project called open GFX when we
build the Oracle JDK binaries we do a
JDK build and a Java FX build and
release engineering matches them
together yeah this is far from ideal
we know this you know really there
should be a Java FX module here but it's
not here because this is generated from
the JDK build you know eventually we you
know our intent is to move the FX code
into the same code base as the JDK but
that too is a fairly big project yeah in
the back
if you have an application it could you
hold that question till the end when we
talk about the hardship part of the
story okay any other questions about the
graph yeah how are we going to keep
people from getting into cyclic
dependencies good question
so as perhaps you observe this is an
acyclic graph that's intentional we are
our our position now is that a a cyclic
model graph is a bug there are those who
disagree with this point of view but we
cite cycles in a module model graph tend
to be an indication of poor module
design so in in a mantra in the static
mantra graph which is intended to
represent the entire JDK or in the sub
graph of it that is spun up when you run
a modular application there won't be any
cycles now it turns out at runtime
sometimes there are good reasons to
introduce cycles if for example you need
an instrumentation module to be
dynamically loaded and it's going to
instrument something in Java not lying
well it's also going to use stuff and
drop it on lying and so you wind up with
you can't wind up introducing cycles in
the dynamic modulus as statically and
from a comprehensive ility and debug
ability point of view we think that they
have to be acyclic and we're enforcing
that when when the module graphs are
computed
it is it is an acyclic graph there are
no cycles in it sorry ooh good eyes
that's actually that's actually a bug in
the diagram there there's there's an
edge going from naming to security sasol
and there's an edge going from security
jg SS to naming and they are exactly
aligned that's I didn't I didn't catch
that when I was tweaking all these
arrows so thank you for pointing that
out I will I will fix it yeah
so I so then you have this this is this
is the part where you we we we already
have plans we are we've already been
talking to all the major IDE people to
make sure they had the other stands with
understand what's coming and can create
appropriate tooling and we'll have api's
that will help them you know writes the
wizards or whatever to need to help you
come up with a good modular structure
for your app yes they're the at runtime
there what there will be a reflective
API you can you can get you know a you
will eventually be able to get a an
object that is the module equivalent of
Java line class and do reflection on it
find out what's inside it find out what
you know what it's depending upon what
it exports and you add add other edges
if you have suitable privileges and so
forth
exactly yes yes so so there's the se9
standard we'll have we'll have
essentially the orange orange subgraph
here it will it will define precisely
what the blue hedges mean versus the
gray edges it will be made clear that
just because say the compiler module
depends an implementation dependence on
the login module today doesn't mean it
will tomorrow and that shouldn't affect
anybody who's depending on that on the
other hand since the sequel depends on
logging in and as we saw earlier we
exports some of its types there's a
contract saying that will seek will
better include the logging types and to
try to to remove to remove this edge
would break any code that's using it
could break any code that's using a
sequel module and so that would be a bad
thing
so yes can mechanic compatibility as
usual will be extremely important okay
let's move on because Ellen's got some
demos we want to get through so we're
gonna have all these modules how do you
what do they look like how do you make
use of them so for the the modules of
the JDK we can't just use jar files
because a bunch of a bunch of the jTA's
modules have native code and other stuff
in them because well they're non-trivial
so we're gonna we're introducing a new
format which at the moment we called we
called J mod in our prototype if it's
still just a basically a zip file but
over over time it will probably become
something else we will prove we will
eventually provide an API for these
files we're going to try not to document
the format because we want to be able to
over time it's sort of a meta module of
its very own so if you you you have
modules at compile time you'll be able
to say okay Java compiler you know that
this module I'm compiling only only
needs those others and maybe you want to
limit it even more there'll be flags for
that when you launch the Java Runtime
you'll be able to say which modules you
want it'll go do the transitive closure
computation set up your multiple graph
and you'll be good to go we're also
deeply weird that well you know just
like just like generics rembert remember
generics it Sutton you love him or hate
him one of the good aspects of the
generics design was it didn't force you
to change all of your code just to run
on Java 5 it was designed with this this
aspect of migration compatibility so you
could gradually add generics to your
code and as you had time rather than
rather than be forced into it so with
this module system you know we're keenly
aware people as much as people might
want to give up the classpath they're
not gonna be able to do so right away
and they're people are not gonna go
convert all of their their all of the
jars on maven central into beautiful J
mod modules or a night that won't happen
so that there are going to be
well-defined ways to have code on the
class path that interacts with code and
modules and vice versa new thing that
we're introducing today the development
model with with Java is is you compile
you compile source code into a bunch of
class files maybe you package them up as
jars and then you run them at runtime
there are optimizations we'd like to do
and pack two forms of packaging we would
like to do that don't fit into that
model so we're introducing a new tool
called j-link it's the java linker
finally Java gets the linker when I
first came to Java and start working on
1996 I looked at it you know being an
old and old seeing scheme hackers like
where's the linker well here it is so
Jane link is is it's basically basically
a transformer of code it can take class
files it can take jar files it can take
J mod files with both both class files
and native code combined stuff together
you compute I'm autograph statically at
link time
and then spit out depending away what
you're asking for a custom runtime image
just for your application
so I'm sorry a customer at runtime
images that just has the modules you
mean you could also spend it spit out a
runtime image that rather than been Java
just has been you know what if the
whatever the name of your app is you
know the rest of you of the other usual
stuff but this would be an image just
for your app if there's no native code
it could spit out a combined jar file it
could spit out a combined dream on it
could also spit out a custom JVM image
how many people are familiar with a
class data sharing feature of the
hotspot VM so it's the class data
sharing is a way to load up a bunch of
classes create the entry at the internal
hotspot class data structures drop them
into a file that you can then memory map
it later patch up and and run very
quickly so J link could create that kind
of a thing it would be highly specific
to whatever be and you're using but it
will start up a lot faster than it would
today so Allen will show the the J link
tool in actual practice all right
there's no pain without game internal
api's are going to become inaccessible
or at least a whole lot harder to access
we've we started already in SaaS and JD
JDK looking at and at internal api's
doing scans of say all of maven central
various large software products and
finding what internal stuff that used
and where appropriate creating you know
creating actual supported public api's
Mandy wrote a tool called Jade EPS which
is actually in JDK 8 you can run Jade
EPS on a jar file or a directory full of
class files and it will analyze them and
tell you at least from a static analysis
point of view what internal stuff in the
JDK are you depending on so if you if
you're using you know some misty 4
decoder it will point that out
and it would be you know it'd be an
excellent idea to run Jade ups and fix
your code up sooner rather than later
ArcheAge aren't tools dodge are so these
files have been around since almost the
beginning of time in in JDK releases
anyway they're also going away why are
they going away because jar is a
horrible format for an optimized runtime
Jim Lasky who you may not know from the
Nostrum project excuse me it's actually
been contributing to jigsaw has come up
with a much more efficient file format
that we think will will beat the pants
off these guys and also brings that it
brings a lot more flexibility to us then
jar files which after all are just zip
files in a pretty dress another thing
that will change is the structure of the
dairy so it's gonna look like this
rather than what you find today there
will still be a Lib Lib directory with
architecture specific stuff in it the
actual modules and things we're gonna
move move the extensions directory up to
the top level will keep the bin
directory everything everything that's
in the bin bin directory will will
continue to be there we're creating a
cough directory for user editable
configuration files if you look at a
Jerry or JDK today they're in the Lib
directory not only is there all this
architecture specific stuff but there
are things like securities property
files well you know the security
properties file is something that some
users will edit and that's enough
support it
you know Lib JVM DSO is not a file that
users should so we're separating those
out so you can affect can in effect and
treat everything read-only except text
in context does the place you can drop
in extended extensions if you need to
and comp is where you can find user
editable configuration files we're
actually considering whether this
extension mechanism is even needed going
forward but that's that's a separate
discussion okay any questions about this
all right let's see some demos
I can make the speakers folks in the
back see this Mike Mike okay I got Mike
folks see this make it bigger bigger and
move it to the right all right smaller
screen all right
there's a huge Fontenot for me is that
okay if I missed something can you see
that at the back okay all right okay so
I'm going to use a version of Java here
which is just the very middle of jigsaw
and so Mark showed them the modular
graph and this is a JDK that has is
built from these modules the launcher is
modified with a couple of prototype
options one of them is called X this
modules which we missed the modules that
are linked into the one-time so I'm
gonna I'm gonna execute that and it gets
down a whole bunch of JDK Java dot star
55 module since is the exact 55 modules
that were our marks slide from about 10
to 15 minutes ago so that's that that's
really really neat the other thing is
Mark mentioned about our key touch jar
and tools that you are going the way if
I look into this JDK I am NOT going to
find those jars Lots they're gone
there's still a couple of jar files
range to
exported security policies they still
exist in this image but there's no RTR
everything is actually linked into the
image and we will eventually kill those
to kill them all of them okay so the
first thing I'm going to do is I'm going
to use Jane ink to create a small one
time that is the subset of these modules
so these 55 modules are packaged in this
new format which we called a mod so I've
actually have a directory here called
Jane mong-joon mods
plural and you see in there all bunch of
find the artifacts dumped gmod so I'm
going to start by creating an image with
just a subset of the modules that are in
the GDK and that should be significantly
smaller than the GDK that I started off
with so the command of Tekken here is J
link I'm giving it an option here called
module path and in the minute I'll be
using module path again but think of
think of module path is the module
equivalent of the class path the class
path you find classes and jar files on
the module path defined modulus so I'm
giving it the modules directory I'm
going to tell it what modules I want to
link into this runtime I'll start with
just linking the XML and other link in
the sequel modules I'm going to tell it
the format I'm going to use and so at
the moment that this linker produces
images in different formats for for here
I'm using something called J image
you'll hear more about that very soon
and I wanted
that worked out borders I'm gonna just
gonna call it my room time and I'm going
to also use compression on this so this
was this now will will link together the
XML and the sequel modules and the
transitive dependencies and produce a
small runtime and it's put it into this
directory called my runtime and if I do
rate undo a find on my runtime you can
see here the files that are actually
linked into this there's only a small
set of files if I do the equivalent of
the the list modules that I did on the
full JDK I see here there's only a small
set of modules I've got linked in here
as for modules got linked in and based
logging sequel and XML I asked for it I
asked it that it included the sequel
mxml modules everything everything that
eventually will depend on base and there
is actually a sequel API that exposes
logging so it depends on logging so it
got intended itself and this runs and
just took just to show you I've got a
the compulsory hello world will actually
run with a small one time like that
because HelloWorld is just in the system
that out it doesn't need anything more
than just to show that this isn't to
this linking of modules together it's
not something that's specific to JDK
modules I'm now going to start to link
in some non jdk modules so i'm going to
blow away this one time and i'm going to
link in some other additional modules
that I put into this directory called my
j-mods I've got a few modules in there
I've got the and jax-rs API module
I've got logged for J just as another
logging module but many people might be
familiar with I've got the log4j core
which is the
one implementation because if thought is
a facade and I've got another done
application
I'll start by just linking in into my
room time I go to making any blog for
Jason love for J here is is it's linked
as a j-mart here I'm talking a few
minutes as to how we help how we
actually got to that point so I'm going
to go back to my my my J link canal and
I'm going to and I'm just going to
extend to be the the Mitel path to
include my j-mods
and I'm also going to I'm going to add
in here they love for Jay API the log4j
API does not depend on the core it it's
it finds that reflectively at at one
time and I'm going to link those to
produce my new runtime so it's the same
J Lincoln and accept them linking and
just specified if there's some
additional modules as the lease to
install so this is turning away here
there's a couple of warnings here just
because there's a there's a few
duplicate for me it's something we'll
have to deal with some at some point so
I'm not going to run the this modules
again and we'll have a look to see what
modules are linked into this runtime the
list is much longer here there's a whole
bunch of extra modules I'm kind of
surprised to see in there and that's
because log4j is not a small little
logging library it's actually colossal
it requires a whole bunch of things and
if we look at that module and just look
at the the list modules and I'm asking
to list more information about the log4j
API module and I'm seeing what it
depends on it depends on the management
module because it uses
GMX and it depends of base module and
then these are the API is then that it
exports and I'll show you another reason
why there's so many modules linked in
here by looking at the blog for Jake or
and we can see it depends on a bunch of
other modules the desktop module this is
a big module with a WT and swing and so
on what's the reason for that is because
log4j is actually using a whole bunch of
beans classes that are Indian via the
desktop module it's also using XML
because you can log an XML and so on so
the point is is I've been able to take
some some some some libraries the Loomis
modulus and compile them into my into my
runtime which is actually quite nice and
I'll show an example of this this is the
this is running now so I'm just running
with the class path to begin with and
I'm going to run a little application
that does pitocin doesn't do very much
it just uses logging just to show it
actually running and it's not there
where is it what is in the test
directory what today it's called Maya by
color sorry we do this again I'm
learning Java this time just using the
class path and I'm going to run this
simple application that is using the
logging API so I have not given it I've
not put the logging library onto my
class path instead it's actually finding
it in the LinkedIn Livington image and
just to show that it's actually being
loaded I'm gonna run with the verbose
option so anyone is used to Java that
for post optional Davitt it traces the
classes are actually being loaded and
we'll see here as they stances as if
they spin house you'll actually see
they're being loaded from my apologies
this is can I make this a bit wider I
have you can see here that they're being
loaded from module log4j API
and so on so that that that's actually
quite interesting too just to see
third-party libraries just be linked
into the image well we can do better
than that we can actually linking the
main application into the image as well
to produce to produce a runtime that is
a single application so blow away that
image and this time I'll go back to my J
link command where was that I'm going to
get rid of all of these - mods and I'm
going to just link in my application so
gonna go the only the only module I'm
gonna ask to link in to this front end
is going to be my application and that
will take a few seconds to run the
system turned on compression here
and this runtime as has my modules in
there and in addition it's it generated
me a sample launcher that one's my
application so don't have to do any Java
command I don't have to give a class
path or anything like that it's
generated me a launcher that will run my
application and exactly the same way as
I did with the complete the class
concept before so that's very very
simple the J mod itself in there it
actually has information in to tell it
what the main application so I don't
have a huge amount of time because we've
run about a few minutes foot we're not
going into G into compiling modules now
but what I can tell you is is is is that
in that chain mod I mean that my
application B tells of what is with what
is what the main class that is too long
okay so it's it should talk a little bit
about encapsulation while we have I have
a bit of time and so let me let me use
this runtime to look again at the log4j
module the log4j module exports four
eight four packages log4j message spi
and states now if I look at the Javadoc
for log4j there's actually a bunch of
other packages in there and if I look at
the utilities in particular it's an
internal package and this is this is not
meant to be used by applications using
this API its internal to the to to to to
the log4j but if I run something that
uses it so and I have a little test here
that that tries to make use of one of
these and one of the api's is not
exported by the log4j
using it by poor reflection it's not
actually it's not actually think
directly to us we'd see what happens and
when I when I attend to tutor on that it
failed so when I ran it it's it what we
have here is is is this chest is trying
to use cool reflection to access a part
of the log4j module that is not exported
so it fails at runtime with a legal axis
exception and that's what you would
expect with strong module boundaries and
an encapsulation so that's that's said
that that's just wrong with the life
Virginia and module what it can do is as
well is is just show you a couple of
other examples to show how this is what
this is going to be with the and can I
make this bigger is that any better
wider
okay so I'm going to do the same thing
here with a number of tests that are
making use of JDK internal api's so mark
should years ago that some dot star is
off is off limits he meant it so here's
a little example of a piece of code
that's making use of a Sun that starry
night so I've managed to trick the
compiler to actually to compile this and
we see what happens when we actually run
it and and see what happens so I don't
know what I can make this console bigger
can people see that from the back what
happened to your illegal access error
illegal access error so this is this is
the consequence that this is this thing
this is it failing at at one time with
the legal access error now we've got the
same test over here and I can make this
one a bit bigger which is using poor
reflection just to do the same thing and
we'd run that and see what happens
and this failed at no time so it's
backwards with the with the exception
that for reflection throws when
something is not accessible so this
would be this is you like the equivalent
of what would happen if you're trying to
access something that is private or
package private and you're in a
different different package so it's
exactly the same kind of test and here's
the equivalent using method handles
which is the new reflection API that's
there see since it's a Java C 7 and we
do the same test to see what happens if
you try to use the new reflection API
and runtime to access that non exported
API and it also fails with exception so
hopefully that gives you an idea of what
what Mark was talking about sorry ok
thank you very much Ellen so hopefully
that's right so speaking of time we have
about four minutes for questions we
could do right now there's also a Boff
four jigsaw Q&amp;amp;A at 7 p.m. this evening
over in the park 55 cyril magnin and
some number so if we if we don't have
time to answer your question here you
plate please feel free to come to the
boffin and and ask it there so we have
four minutes yes sir well there be any
concepts of versions for module versions
are versions are their own morass of
issues there there will be concepts of
versions for modules in earlier
iterations of project jigsaw we were
actually trying to solve the versioning
problem we've come to realize that there
are plenty of other tools that already
tackle that very difficult problem you
know called maven and Gradle and Ivy and
and and whatnot so we're not going to
tackle versioning problem we're going to
depend on other tools to do that to do
version resolution deal with conflicts
and all that stuff our current thinking
is that a module should be able to
contain version information should be
able to contain constraints you know and
it will will make sure that these are
easy to match up to whatever constraints
you have for example in the
of rate palms the module system will
check those but it's not going to do
some fancy try to resolve in any cost
all of your dependencies and find the
optimal model graph no it's it's gonna
be very stupid if there's if there's one
unique model graph it will find that if
there's ever a choice or a conflict it
will give up and ask you to reconfigure
your build system to create a coherent
model graph that actually makes sense
right we're no we're not doing
dependency management we will do
dependency checking but we're depending
on build tools to do dependency
management so remember Alan showed them
out the the module path concept we're
depending on on build tools to help you
construct your module path but all the
right modules in there whether they're
modular jar files or J mods or whatever
the model system resolver will compute
them all flow graph if it can but if it
gets to a situation where there's a
conflict they'll say no can't do this at
runtime your your build is broken you
know go fix your dependences so that a
sensible model graph will result
right no it's our intent for example
with in the case of maven is is that is
the truth will be in the palm and but
whatever metadata is needed by the
module system will be transferred from
the pom automatically so you only have
to maintain that in in one place
you know pom whether you like it or not
is you know a working standard way to
back well there's not really any concept
of install anymore
if you try to let me try to link or
configure it run time' graph with two
different versions of the same module it
will fail and ask you to choose just one
we we don't see this as a serious
limitation and it's an amazingly
powerful simplifying assumption for both
the module system itself and and for
users after after all today on the class
path you can't have more than one
version of anything it doesn't work so a
module system that also has that
limitation does not does not seem does
not seem too harsh 30 seconds yes
will there be tools for module signing
in due course most likely we're not yet
sure whether that's something we
actually would need in jdk 9 but bubbles
see Tim sorry relationship with between
class loaders and modules is they are
they are at a high level orthogonal
concepts so if you wait one of our one
of our design goals has been if you have
a complex application that's doing its
own custom has its own custom class
loader hierarchy you should be able to
modularize it without having to do
surgery to your hierarchy okay there
there are a number of you know quite
quite a number of large applications out
there including some Oracle products
with sophisticated client class floating
hierarchies we don't want to ask them to
change so we won't on the other hand if
you want you know if you want if you if
you want to use the eventual models to
system API just to spit up an
environment where every module has its
own class loader sure you can do that
too
but that won't be the default we've also
been been very careful with the the
existing you know fixed class loader
hierarchy the the hierarchy that was
introduced in 1.2 with the boot
extension and application class loaders
you know as sometimes brain-dead as that
is changing that would probably break
everybody so we're not going to yet we
we get we can load modules with those
class loaders okay we're a little bit
over time again if you have questions
7:00 p.m. this evening over in Park 55
thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>