<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Redline Smalltalk: A Future on the Java Virtual Machine | Coder Coacher - Coaching Coders</title><meta content="Redline Smalltalk: A Future on the Java Virtual Machine - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Redline Smalltalk: A Future on the Java Virtual Machine</b></h2><h5 class="post__date">2015-06-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Ha-U7SwhpVA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm James Ladd and I'm here to present
on redline small talk I'm the developer
and I have a very small budget so as you
can see I'm also marketing and mascot
so all in one so there you go just in
case you didn't recognize me so most
people I know who write software at one
point or another will want to write a
compiler it's like one of those rites of
passage and I find that if you're out
there left on your own you have this
wonderful thing you can turn to called
the Internet and it's a fantastic thing
because it's got so many examples and
that's one of the good things about the
Internet the other thing that sucks
about the Internet or a thing that sucks
is all the examples out there because
it's hard to pick which ones are going
to be useful to you and which ones are
really just small examples of something
that really don't make too much sense to
you
and invariably if you're writing a
compiler you end up coming across this
book and this is really quite full-on so
if you want to write a compiler I
suggest you don't read this book just
yet you maybe go through this slide a
couple of times and ask me some
questions or ask some other people
who've implanted compilers some
questions because it's a lot better than
doing it alone so really even though I'm
talking about redline small talk having
a future on the JVM one of the key
things I'm trying to do is to mystify
what it is to implement a compiler and
I'm hoping that by the end of this talk
you'll go hey that compiler I could do
one of those I'll give it a try me
so why the java virtual machine that is
a good question well as you may know and
I guess most of you here would know
since it is a Java sponsored Oracle
event is that it's everywhere it's on
everything
and it has great performance and it's
always improving so that's a good reason
for using the JVM the other reason is if
you're developing in your favorite
language you may find that the work that
you're that you do the people out your
work will not let you run your program
unless it's running on the JVM and
that's good news nowadays because lots
and lots of languages just like small
talk are coming up for the JVM and if
that's you as a developer that might be
your DevOps guy who say no you can't run
this unless it runs on the JVM I had one
of those and it's one of the reasons I
created small talk on the JVM so that
people had more choice in the languages
that they could use admittedly when I
started I think there was only two
languages available for the JVM at the
time JRuby and then red line small talk
of course we have a power more since
then so why small talk I fell in love
with small talk a very long time ago
in 1985 I think there was an issue of
bike magazine that covered small talk
and it sounded wonderful and since
everything I was doing was based on the
command line small talk seemed like an
amazing environment I've had a love
affair with it ever since it's also 30
years old I ran into somebody just the
other day walking through this
conference and said hey how about you
come and see small talk and he said wow
haven't heard of that language before
when was it created so why small talk
well it's a very productive language
it's very fast and dynamic you write
some code you execute the code there's
no compiled loop you just use an
evaluation scheme just run it just
evaluate change your code accordingly
and repeat it's also very flexible
everything in small talk is written in
small talk therefore you can change
anything of the environment at any time
the compiler the tools your windowing
system everything that you're doing is
written in small talk and therefore you
have flexibility at the highest level
and the lowest level it's also simple
and pure so in a nutshell the reason why
I wanted to do small talk on the virtual
machine is because nothing is as simple
and productive as small talk and I was
in a situation where it had to run on
the JVM so let's get back to compilers
there's a lot of things to learn with
compilers a lot of things to get your
head around
you've got lectures and byte codes and
grammar and parsers and a runtime and an
analyzer it's
quite a lot to think about and I'll go
through each of those things and try and
demystify them for you so let's work out
how we're going to do that we're going
to start at the beginning with sauce and
we're going to hopefully end at the end
with an executable program that is
called the pipeline and we're going to
go through it first thing you might need
to do is define what it is the language
is going to be like so you need to
define a grammar that may be an existing
grammar or it may be one that you choose
to create yourself I chose one that
already existed the small talk ie
grandma and I'll get back to you on that
then you need a parser now your grammar
can be used to generate a parser and
Alexa you don't necessarily need those
two separate beasts you can just
generate one parser that component
combines both the lexer and the puzzle
and it takes the stream of characters
that you might have in your source file
and turns it into a stream of an array
or a list of nodes that represent the
logic and other constructs of your code
then you need an analyzer that analyzer
walks that tree and it determines what
it is that it needs to generate is that
thing in it does that node represent a
string in which case I need to create a
string does that class does that node
represent a class in which case they
need to generate one of those or does it
represent an if-else condition in which
case I need to do some logic around that
as well you also need a generator and
the generator will write the executable
code whether that be bytecode or
assembler it really doesn't matter the
point is you have a generator that's
going to generate something you might
even want to just go from small talk
source or your particular language into
Java and then compile the Java code
that's another approach either way your
generator is going to generate some code
you also need a runtime this is a very
support library for that language and I
don't mean run time as in a lot of
classes that your developers could use I
mean a set of classes that your language
needs because if your language is very
different to say how the Java language
is then you need some stuff to support
that and again I'll get into the details
of that a bit more when I tell you what
happened in this particular case with
red line you also need a class library
now this one is more about supporting
the developers so they can't just have a
language and start you know start with a
blank slate although that is the kind of
appealing it's good if they have some
objects that they can deal with to do
say string manipulation or file
manipulation or something to do with
graphics and mice and all that sort of
stuff so this is where your developer
library is very important if you're
writing a language the other thing
you'll need to choose is whether you
want to be very foreign or very native
to the platform now remember we're
talking about the JVM so I could be very
in sync or very native to the JVM and do
things in say bytecode and handling
method dispatch the way that the JVM
does or I could do something very
different to that and you need to make
those choices when you're creating a
compiler and you're building things the
other choice you need to make is how you
want to go about integrating with other
classes and some this is where some
language implementations get really
tricky or where you start to find a bit
of a rough spot in their implementation
because the way they implement with
other languages is through either you
building manual adapters which is time
consuming the error-prone or it
integrates using something where they
essentially escape out or drop out into
the other language and it doesn't look
or feel quite so right but what I want
you to understand is that you really can
make a language for the JVM and it's not
as hard as you might think so I'm hoping
that all of us will go away and create a
new language after this once I dive into
a few more details and show you an endo
end example so we started on the
pipeline to understand what the concepts
were going through each of those items
and how they play together now I'm just
going to dive down a bit further down
one level lower and bring it all
together and let you know how it worked
with examples from Red Line small talk
so to understand what we're going to do
we have to understand a little bit about
small talk it's a very very simple
language everything is set out in this
format you have the receiver which is an
object there's a message that you're
going to send it and it could have an
optional
the thing I like best about small talk
is I just explained to you the entire
syntax I don't know many other languages
that will let you other than say Lisp
explain the entire syntax in us in as
few slides or as much text so let's go
through an example 1+1 1 is a receiver
it's an object it's being sent the
message + and it has and the argument 1
it will respond with the object 2 then
you have the other example where the
calendar object is being sent a keyword
message which is output so at this
particular date put this event and then
you've got the last example which is a
unary message which is asking for the
vote to increment itself now this is I
guess in some ways very Java risk if you
wanted to change output to one word
output and send it to arguments vote
increment could be vote dot increment
you can see some similarities but
essentially these are all method calls
or rather message passing I won't go
into the semantics of what a method
versus a message passes we just need to
understand the syntax here so here's
another good example I think a few
people in the audience here would
understand how to evaluate this even if
they've never done small talk before so
here's an actual example that will work
through we have a transcript object
we're sending at the keyword message
show with an argument which is a string
now you notice that the transcript
object has a capital T therefore it's
the actual class and we're going to call
the show method on the class and we're
going to send it the argument hello Java
1 now just for those Java people in the
audience it is ok to actually call
methods on the class
all right so you need to define your
grammar as I said and here we have at
the top is an example of a keyword
expression which is in the antlia
grammar and it looks a bit you know it
looks a bit involved and it takes quite
a while to get all this right what I
suggest you do is have a look at at all
like antler works there's a plugin for
IntelliJ and for eclipse it allows you
to find your grammar and then step
through that grammar to test each of the
rules and in the example you can see on
the screen we have the rules on the Left
we have an example piece of code that
we're evaluating with the arithmetic and
then down in the bottom you can see a
tree of nodes and those are the nodes
that are being built by that grammar
this is an extremely easy and quick way
to build your language it's also an easy
and quick way to work out if your
grammar is a good grammar unfortunately
it took me quite a long time to realize
until I actually hired Jim Idol from
temple wave to help me that small talk
was one of those rare grammars that was
not able to be done by handler just my
luck
so after I hired him and he told me and
we worked through a couple of examples I
had to put up with a couple of errors in
my grammar but those actually didn't
affect the outcome so one of the things
to keep in mind is how well antler is
suited to the language you're building
most languages it's not a problem
so I recommend having a look at those
tools they're very good so we have our
message and we have our expression and
it gets parsed into nodes so these are
abbreviated we may we would certainly
have more nodes than this but I'm
cutting it down for examples so we have
our program it's an expression it has a
receiver a message and arguments and
each of those different types of nodes
where we have a class which is
transcript we have the keyword which is
shown and we have the argument which is
hello Java one once we've passed that
and we have those nodes the next thing
we want to do is analyze them now most
people would understand their patterns
and you really just want a visitor
some people who write compilers will
argue against the visitor pattern and
you should talk to them because there's
probably good reason not to use a
visitor pattern but if this is the first
time you're trying to do a compiler give
it a go
it's not that hard to do the visitor
pattern it will walk that tree of nodes
and it will inspect each of the nodes
and decide what to do with it in some
cases you may find a node like
expression and do absolutely nothing
with it other times you'll just simply
visit its component parts of it and in
this particular case we're visiting the
program node we then visit the
expression node we then visit the class
node and when we get there we say all I
need to do something with this because
it's the receiver of the expression and
here I need to generate some code and in
this particular case I'm going to
generate a get class and the class is
called transcript so that's how I'm
taking the example converting it to the
nodes the nodes are then being parsed
and I'm generating out some code to call
get class now you might be thinking if I
need to call get class don't I need a
compiler to compile that how do I go
from that particular call into byte code
now you use your generator now the
generator that I used was object Webb's
azzam byte code engineering library it's
free it's very very good and it also has
some great tools so if we look at that
example of generate of generating a get
class you can use the eclipse plug-in
for the Azzam web tools and if you can
write that code that you want to
generate in Java you can actually click
the Azzam button and it will tell you
what the corresponding calls are to the
azzam framework to generate that
bytecode and that is really super simple
way so if you can code in Java and you
have a construct you want to represent
in your new language write it in Java
generate and then you get those calls
then you put them in your program as
part of the generator so you have a call
like get class transcript and underneath
the covers I might call a class loader I
might tell it to get the transcript
class I might tell it to give me an
instance of that class and then I might
tell it to execute a particular hidden
method which is what I do in red line so
I write that in Java
I think press the Azzam key it shows me
the
equivalent Azzam calls and I put that in
my generator and I'm done I'm now
calling classes and pulling them out
from through the class loader and
whether they be a Java class or a small
talk class that works so easy way to get
your code generated you can go full hog
and start writing out byte codes by
yourself but that's probably somewhere
where I'll get to but for now this was a
quick and easy way to do it you also
find that after you've done enough
constructs copy and paste is your friend
and it will probably work for most of
the things you need to do in your
compiler at least to get the first
version out so the other thing you'll
need is the runtime as I mentioned now I
had to implement some special functions
in my runtime the base like base object
for all of the small talk classes is not
Java's objection it has to be a
different object and so I had to create
a special method message passing
framework which is really just a perform
function which takes a series of
parameters and then looks up a method
and dispatches to it which is very
different to the way that the the way
that Java does it so I had to implement
that custom method myself
luckily Charles nada hi Charles help me
with invokedynamic and he went in has a
look at the way the method dispatch was
working and modified that to use
invokedynamic so it's actually working
really quite quick and quite fast I also
had to implement a different class
hierarchy in Java classes are not
first-class objects they really just
quickly cut our templates in small talk
they're true first-class objects and so
I had to create that hierarchy and
behind every class or every object that
is a class in small talk is another
class called a meta class I won't go
into that because they'll do your head
in but the matching hierarchy had to be
done and therefore I had to implement
that the other thing that small talk has
that Java didn't have until Oh
today was lambdas or block support of
course you can do anonymous inner
classes and get it that way but in in
small talk you could do lambdas 30 years
ago
and well I guess in languages older than
that you could do it as well but that
had to be implemented as well because
the way it's handled is very different
to a Java handles it and you have to
handle pushing and popping different
values on the stack yourself and then
handling that thing to be a proper
closure and passing it around and
there's a whole pile of different
semantics with small talk about what
happens when you have a return in a Lam
during its passed into methods and other
methods but so that had to be done too
and that's in the runtime support but I
had to create for readline small talk
you may have to do that for your
language as well it really depends on
what your language is wanting to do and
the capabilities that are in it the
other thing is a class library that you
need for developers now red line small
talk comes with all of the classes that
make sense as defined by the blue book
this lovely book here small talk ad
defines the language and its
implementation it also tells you how to
implement the virtual machine luckily I
didn't have to do that bit I can use the
JVM that's another reason for using the
JVM it's fast and it takes a whole pile
of worries out of your out of the scope
of your project but now I have a class
library the other thing that you can do
is choose to give existing libraries to
your customers in my case I have a way
of dynamically wrapping Java classes so
that they look and feel just like
Smalltalk classes and that's done on the
fly but the end result is that I can use
any of the existing Java libraries and I
can call them just like small talk
classes and likewise I can call small
talk classes from Java so here's another
example of integration there was two
types of integration that I mentioned
this is actually an example of a method
from the transcript class that we were
talking to here it's calling standard
out on the class and what happens here
with the jet with red line small talk is
the receiver JVM is a special receiver
there isn't actually an object in the
class library called JVM this is just
something to escape into a lower level
during the compilation and get static
named as is just a keyword method what
happens when this this method is
executed or passed is the JVM calls are
actually
turned into emissions of bytecode into
the stream at compilation time so I can
write code that emits bytecode so that I
can do anything that the JVM will do
even if I didn't code it for you
you can go in and call it yourself but
the I guess the beauty of this example
is if you're familiar with small talk it
looks and feels just like small talk so
you know some other languages when you
start to talk say with closure when you
want to call Java it starts to look very
very unlike Lisp and to me there's a big
rub with that if I wanted to do Java our
do Java if I want to use Lisp I want to
stay in Lisp as much as I can and for me
this was the nicest way to give you the
ability to emit any byte code that you
want it to admit but make it feel and
look just like small talk and I guess
another thing of note for for both
Charles and Tom is that you're talking
about Genie for Java and having a chat
about that my suggestion is that it
looks and feels as much like Java as
possible and we can have a beer about
that right so hopefully I know this is a
quick tour of small talk it's a quick
tour of writing a compiler but hopefully
you're understand that they're really
not that hard once you get the pieces in
the line and you start to understand
what they do then it's quite easy to
write something simple and then build on
it from there so compilers really aren't
that hard so you want to write your own
language I suggest you do it's a really
great exercise when you say to people
hey I wrote my own language they look at
you as some kind of God that is
appealing on a small degree but you also
get a pile of users that can be really
really quite helpful
this graphic for example was actually
done by one of the supporters for
redline and that's his avatar on Twitter
and I think that that's I don't know
that's kind of cool that he likes it
enough to do that and you two might
build up your language and start to help
other people I know
when I write software and customers use
my software that makes me very happy
there's an something meta or bigger than
that when you write this
the software that somebody else uses to
write the stuff that the customer likes
and I guess that's the thing with
components you know you're giving other
people tools with which they had make
other customers happy and that's sort of
this magnitude you know it's like this
pyramid scheme and of joy so the Java
Virtual Machine is a great platform
we've got some very very talented people
well supported by a large company to
continue to improve that platform and
make it better again they did not
sponsor my costume this is not Duke this
is the red line logo if you've seen Duke
walking around tell them that it's on
swords at noon right so red line is for
you I know I've talked about how to
build a compiler and I've shown an
example for using red line I would
suggest that if you want to get into
language development you might want to
help a project like red line you might
want to help a project like JRuby come
I'm sure both of us would very much like
your help I certainly would now red line
small talk used to come with what's
known as an image file so it's like a
big snapshot of memory that gets dumped
to disk and that has some terrific
advantages especially if something
crashed in the field your customer can
send you this one file and everything
would be there exactly as the system was
at the time of the failure and that
makes it incredibly productive and it's
a really good thing it's also to me one
of the biggest barriers of entry for
people who haven't been familiar with
that in the past and so what I want to
make clear is that small talk works the
way Red Line small talk works the way
that you work today you can use git you
can use the command line you can use the
plugin for IntelliJ you can use the
plugin for Eclipse you can also do
things using any of the other IDs you
can integrate with your existing Java
code so instead of having this one image
you're working more with separate source
files the way that you're used to today
I'd also like to mention that IntelliJ
were very helpful in getting the
IntelliJ plug-in going specifically
Constantine I'll take a punt at his
second name bull Nick off or bull in
coffee he's not here so I guess it
doesn't matter how I pronounce it but he
was incredibly helpful getting
laj done and you meet some wonderful
people when you try to implement a
language also ken Gilmer was helping
with the plugin for Eclipse and again
that's so that you can use the tools
that you use today rather than having to
learn some new thing that you're not
familiar with these people have been
very helpful and there's a lots of other
people in a community that also been
very helpful so it's quite rewarding to
implement a compiler even if it doesn't
get to version one and if people don't
use it I do have to face that it'll get
to version one with red line but I do
have to also face the fact that it may
never see production but that's ok this
exercise has been incredibly rewarding
look I get to be here if this doesn't
pay for itself right so you can make a
language it's not as hard as you think
and if you want to give me a high I'm
more than happy to talk to you about
your language more than happy to talk to
you about red line and more than happy
to talk to you about the JVM and how to
go about building your language for that
platform because it is a wonderful
platform and so if anyone has some
questions I would be glad to answer them
now
right their question was did I need
invokedynamic for blocks I didn't need
invoke dynamic I had not got to a
position with any production app to see
a performance problem however Charles
had a look at the code and said hey I
could do invokedynamic and I certainly
was going to pass up that opportunity so
it was more a question if it came to me
rather than me needing it but the method
dispatch is quite different to Java so I
actually don't know if it's going to be
a positive or negative impact at this
stage
well that is that is correct to clarify
I'm using it for message dispatch
for the way that small talk is
implemented on the JVM I will still keep
my lambda implementation it has to do
with the way returns are handled which
is very different in semantics to
lambdas
although there could be some things in
lambdas that clean up my implementation
if it wasn't for the fact of how when
you return from a block in small talk if
I'm in method a and it gets passed all
the way down to Z and the returns at Zed
it comes back to the very first point
which that doesn't necessarily happen
with lambdas and therefore there's a
different sort of escape semantics
needed correct I have my own context
that's a true object
yep right as necessary at this stage
when people get to production and start
to use it in a very known use case then
I'll look at optimizing it right now it
would be premature so I just want to get
it working and then I'll optimize it I
do at this stage yes yes I mean there's
a very sweet spot to go and optimize
away straightaway the same with method
cache and the same with the pile of
things yes but yeah first thing just get
it working no no right yeah I mean I can
I can rely on I can rely on Java's
identity there
yeah I have considered that because you
can and I'll just go back to that slide
to sort of give reference right here we
are so because I have the ability for a
small talk method to basically tell what
bytecode is admitted what I could do is
essentially go back to all the
primitives and have them implement
themselves as direct bytecode and
therefore get away with the runtime
underneath that supports it and I've
thought about doing that
I have tended to favor at this stage
having a call to a primitive as defined
by the Blue Book and leaving that in
Java and having just a few things like
this particular IO example being placed
in direct bytecode manipulation so that
in keeping with small talk the majority
of the things you see are in small talk
and that things like this that are a bit
yes they're small talk ask but are
essentially emitting stuff for a
different machine out of the person's
visibility so it's with small talk on
small talk for small talk but I can see
it is something that would potentially
make things a lot more lightweight and
certainly a lot easier for other people
to modify
absolutely everything you expect from a
small talk you get the only thing you
don't get is an image file
correct correct
great
look it is it's as much as I would like
you to do this and walk around like this
it's not a prerequisite for enjoying
redline small talk please great
everything everything you expect from a
small talk is there the other thing you
can do is take a Java class even a final
one and add methods to it using small
talk because it's on the Java side
that's correct yes
what what is it
right
a genius
right okay so there's a couple of
questions there I like small talk
because that's the syntax there are five
key words that you'll know they are
allowed to use like self and true and
false but that's it
everything else is expressed in this one
uniform way and that beauty allows me to
get on with the job of writing the
software I want to write as opposed to
working at how to express what it was I
wanted to write second of all if I want
to add a new construct to the language
because it is receive a message argument
there's no reason why I can't use the
same approach to do that so when small
talk ad was released it didn't have a
switch statement but you can add one
today and it looks and feels just like
small talk
absolutely absolutely it was and and I
find that very good because you're not I
guess the thing I that rubs me the wrong
way with deer sells is I've learned how
to do a language and then you go do I've
got this fancy DSL and I might well now
I have to learn it what if it felt and
looked and acted just like everything
else that consistency can't be
discounted now back to the other
question of why aren't people using a
lot of small talk small talk
implementations today with the exception
of red lion are super quick very very
quick and they're getting faster and
faster I actually think that when done
correctly on the JVM they'll be faster
still because it's a very good platform
the reason it doesn't get used I think
is because it is commercial question you
have to license the current small talk
environments so all the commercial
providers right now will charge you red
line is free it's open source it runs on
the JVM and you can use any of the
libraries already available in Java you
can use it in IntelliJ and Eclipse and
if you've got a need for XYZ ed vendors
small talk to run on the JVM tomorrow
then we will give you a porting library
so that you can say well I'm using sync
on small talk so you get the pack off us
that will add all the right methods and
things in the right places and now
you're running on the JVM
so that's the other goal is to move
people from those onto the JVM and if
you look at some of the performance
stats and things that JRuby have done
you could probably see that taking Ruby
putting it on JRuby on the JVM has been
quite the performance boon and money
saver for people and I'm hoping that
that's the same way for small talk I may
have left my run a little bit late but
it's my home
any other questions all right then I
guess the only thing left for me to do
is little dance thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>