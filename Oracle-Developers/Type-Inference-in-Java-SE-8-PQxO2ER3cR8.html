<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Type Inference in Java SE 8 | Coder Coacher - Coaching Coders</title><meta content="Type Inference in Java SE 8 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Type Inference in Java SE 8</b></h2><h5 class="post__date">2015-06-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/PQxO2ER3cR8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so my name is Dan Smith I am an Oracle
employee I work on the language team
glad to see so many people excited about
types if you're not here to learn about
types now is your chance to escape
before we lose your sanity and this and
this stuff part of my goal here is to
try to demystify what goes on with type
inference so hopefully you can leave
with a better sense of what's inside of
that black box and so when the compiler
blows up on you you can kind of see
where it's coming from anyway but my
recent job at Oracle has been to work on
the lambda project and that's a big part
of Java 8 it involves changes in syntax
obviously but a lot of type system work
has been done in order to make lambda
expressions and method references
interact well with the rest of the
language and in the process this was a
good opportunity to take a look at how
type inference behaves and make some
changes and improvements there's a
roadmap of where we want to go I'll
start off with some context and
terminology so we're all speaking the
same language and three big areas of
changes we've made improvements that I
want to illustrate and describe target
typing variable dependencies and how we
handle lambda expressions and Method
references and then I'll finish up
talking a little bit about coming from
Java 7 or Java 6 what changes you can
expect to be able to make what the
migration experience might be like so a
disclaimer I'm an engineer I'm not a
product guy so this is pre-release
software subject to change let me start
with some context then so here's the the
kind of code that type inference is
there to support we have a method well
okay this is an interface with two
different methods
that arbitrarily pick one of two
arguments the first case it takes in
Sand picks an INT in the second case you
could pass anything to it and the idea
of using generics here is that you'll
get back whatever type you passed into
the method so my example is just an
invocation of pick I give it an integer
and a string and type inferences job is
to decide what method we're calling and
what the type of the return is so that
when I call some method on that thing
the type checker knows whether that's
okay or not so there's two parts first
of all overload resolution
generally speaking overload resolution
is about looking at a set of methods
like we have the two different pick
methods and it needs to go through and
decide which ones are applicable in this
case which one could be used without
type error and then the second step is
to decide if there's more than one which
one is the best one in this example the
the second argument hello is not an int
and so we know right away the first
method is not applicable to decide if
the second method is applicable we need
to know whether these arguments are
compatible with the type T though we
don't know what that it whether that's
true until we know what T means and so
type inference will come in to help
decide what we know about T and whether
there could be a choice for T that would
make this method applicable am I losing
sound when I turn my head I'll try to
keep the microphone close
all right second step is invocation
typing so after we've said okay here's
the method we want to use we still need
to decide what T actually represents and
so that involves looking at what we know
about T picking a type and then
substituting that into the signature to
decide what the return type is so with
that framework in mind let me dive into
a little bit of how how inference works
on the inside
first of all just in order to talk about
inference at all what we need our
inference variables these are meta
variables four types if the term meta
variable seems kind of strange what I'm
talking about is we have types like int
and list of string and type variables or
types so T is could be a type and we
need to speak generally about these and
so type variables generalize over types
I have some examples t array list of t a
pair of question mark extends a1 and a2
array
these are not actually types even though
just for convenience we call them that
but they're generalizations any type of
t well any choice for t t array is
talking about that time I'm using
lowercase letters here to distinguish
these from type variables in which we
use uppercase letters generally I'm
hoping generally I use Greek letters I'm
hoping to reduce the complexity by an
order of magnitude here by switching to
the the Latin letters so this is easy
right it's just those letters that you
know and love okay then we have
inference variables now we can talk
about things like okay is a ray list of
string a subtype of list of question
mark extends T is that a true statement
or a false statement
and unlike normal assertions about
subtyping that depends on what the
choice of T is so the result of this
question is not true or false the result
is it's true if T fits within a certain
set of constraints
okay so constraint formulas can have a
few different forms generally we'll see
the two forms that I've Illustrated
either one type arrow another type which
is an assertion about compatibility that
type is compatible with the thing on the
right or those generally are can be
simplified to just a subtyping assertion
Mapp is a subtype of some other map and
and so in the inference problem we're
will generally see these things come up
is I'm invoking a method and so I know
the types of the arguments and I need to
know that the arguments are compatible
with the parameter types of the method
and so that those will directly map to
constraint formulas like this
bounds are similar but these are a lot
simpler they always have the form of
just having an inference variable on one
side of the equation and then we can
have an equal sign or subtyping and then
on the other side a type or another
variable that these are simpler so alpha
equals string we can have upper bounds
alpha subtype of integer or alpha
subtype of number integer is a subtype
of alpha that's a lower bound and there
can also be variables on both sides and
I'll get into what we do in those
situations a little bit later so how do
we get from constraint formulas to
bounds that's reduction and I think a
little a lot of the specification of
what inference is is just a matter of
listing all the rules of how we reduce
constraint formulas into different
possible bounds so I just have one
example here with four steps along the
way we start out with a compatibility
assertion of a hashmap targeting a
particular map type the first step is
just to say okay that's just subtyping
so so it reduces to a subtyping formula
the second step is now we can look at
the the type arguments we know the the
first type argument string has to
exactly match a 1 so we get from that
the bound a 1 is equal to string the
second type argument number array it
needs to fall within the the constraints
of that wild-card question mark extends
a to array and so we get another
constraint formula number array is a
subtype of a two array and then the last
step is to turn that the the number
array constraint formula into a bound
lower bound on a 2 a 2 is a super type
of number so that's that's how a
reduction works
what we get out of reduction generally
is a set of different bounds and so the
other half of inference is to take those
sets of bounds and come up with a
reasonable choice for the inference
variables so my first example here is
pretty straightforward I have a equal
the string B is a sub type of object and
a super type of integer so we'll say a
resolves to string and B resolves to
integer I make the point on the on the
bottom of this slide that's an arbitrary
choice it doesn't have to be integer
there are a lot of types that are well a
handful of types that are a subtype of
object and a super type of integer and
so part of the the design of the
algorithm is to come up with a heuristic
for what we'll choose when there's more
than one right answer we also get into
more complex cases where if a has two
different lower bounds then we'll do
some extra work to decide on what this
is saying is tell me a super type that
is a super type of integer and a super
type of string and so we'll do some work
to find what we consider the best type
that is a super type of both of those
and you can have two different upper
bounds for a variable and again we can
we can get types like runnable and
closable out of that
so those two parts working together
reduction and resolution get us the
answer for four for the typing of the
expression what what you'll see
sometimes if inference doesn't do what
you want it to do something like this
where I have an invocation of
collections empty list that's a generic
method there are a lot of different
choices for tea in that case what kind
of list gets returned and what the
compiler will do in Java 7 is choose
object and so you get a compiler error
the this outer invocation of the put
method is given a string and a list of
object and it needs a string and a list
of string and so the workaround and I'm
sure you've probably most of you have
done this from time to time is you have
to type in explicitly hopefully can you
see that you can see the the last line
on my slide here explicitly add the type
argument string so that since the the
compiler couldn't figure it out we will
we will tell it explicitly what what
that inference variable should be
resolved to so ideally we don't want
situations like this there's sort of a
balance between not wanting to raise the
level of complexity to such a point that
it's really hard to predict or
understand what's going on and on the
other hand avoiding making programmers
do all the work and type in all of the
the type arguments explicitly so in
particular cases like this there there's
some low-hanging fruit where we can
really do a much better job without
making a big change in complexity
so so that's it for context we move on
now to a few of the different
enhancements that we've made first off
is target typing so there there's a sort
of strange attribute of certain
expressions in Java in which the type of
the expression depends on where the
expression occurs the symbol K ssin of
collections empty lists you can't look
at that and tell what the type of the
expression is it could be a list of
string could be a list of integer it
depends what it gets assigned to and
seven we added diamond constructor
invocations and it's the same thing this
isn't something new actually going all
the way back to the original java
language
there were array initializers that have
this property where you don't need to
say exactly what the type of your array
is that can be inferred from the context
but we're making heavier use of it in
particular with lambda expressions
innate those the type depends entirely
on the context and what type is expected
and so we're calling these things poly
expressions and we've done a lot of work
to make the use of context more
consistent across the language so
there's a variety of contexts now in
which the the typing information we're
calling it the target type that can
impact the the typing of an expression
the first is assignment that's the way
it is in seven so that includes variable
declarations and it may not be obvious
but return statements are also treated
like assignments and so that continues
to work in the same way we also have
lambda expressions can have an
expression as their body and that's
essentially a return statement so it
also has
context that is used for typing its body
we noticed that conditional expressions
are often a lot of times you've got a
one line method or a one line lambda
body and it's really nice to be able to
just write it out in a single line
but inference gets in the way of that if
you need context because by adding that
question mark in the colon the target
type disappears from from the
perspective of the compiler and so in
eight we've added the ability to push
down the the context to the the two
operands of the conditional expression
and then last this is the big one method
arguments so a method declaration knows
what types it expects and at the call
site now we will use that information in
order to impact the typing of the
arguments that that change by itself is
probably will have a bigger impact than
anything else I'm going to talk about
after this on like your code on them
when we've looked at source code just
doing this flipping the switch solves
like eighty percent or something of the
cases of explicit type arguments needing
to be passed so that's a big win I made
that number eighty percent up by the way
totally arbitrary but it's high I should
probably should have gone for like
ninety five or something okay delayed
resolution so going along with that
we've also identified cases like like
this one where if you if you look at the
arguments of arrays days lists and
passing in three different integers
right now that gets treated with just
strictly bottom-up typing and the type
of this expression is a list of integer
but we know the the algorithm already
has sitting around that information
there's some context where I want a list
of number and so it's kind of silly that
it complains here so in eight rather
than being eager to instantiate the
inference variable we'll wait and look
at the target type and that will add
some extra information and then we'll
instantiate it so you see the bounds
that we'll be working with Java 7 only
sees integer as a subtype of teeth so it
will resolve to integer in Java 8 we'll
add T equals number which is derived
from the assignment to list of number
before resolving
another thing we do and this is pretty
cool is we so what's different about
about this invocation collections dot
checked list is that the context is
coming from a method one and not only
that but the method checked list is
generic also so we need to know what the
what the inference variable of
collections dot checked list is before
we entirely know the target type of new
ArrayList and so generally speaking for
for the new ArrayList invocation all we
know is that I'm calling at T one for
the inference variable on that nested
constructor call t1 is a subtype of
object it could be anything when we look
at checked list we have an ArrayList of
something being returned from the
constructor invocation and that targets
a list of t2 then we also know from the
second argument I have class of string
and that targets class of t2 what Java
says 7 does is it fills in that blank
with object because again it's just
working with what it knows that there is
no context provided to new ArrayList and
so we've got two different constraints
one that forces t2 to be object and
another that forces t2 to be string that
won't work and we'll get a compiler what
it does instead is it keeps that
inference variable abstract I don't need
to know what t1 is yet I'll just say I
have an ArrayList of t1 whatever that is
and proceed with inference what we get
out of that is whatever t1 is it needs
to be equal to t2 and then further down
down the
we see that t2 must be equal the string
from the second constraint and so that
can work its way back and we'll choose
string for both t1 and t2 so what this
does is it opens up the the inference
computation to be a little less local
when there's nested generic methods
being called or nested diamond
constructor invocations all of the
typing information all of the typing
decisions for type inference and get
delayed to the outermost context and
once we have everything all the
information we can find in that
expression then we make our final
choices about what the inference
variables should represent last note
about target typing overload resolution
is context independent I mentioned these
are two separate problems before and
this gets it was sort of subtle
previously and now it's becoming more
the distinction is more important so
it's one thing to perform overload
resolution to choose which method is
going to be invoked and later we'll come
back and actually decide what the
inference variables should be
instantiated to so what this means is if
I have an invocation of a method and I
copy and paste it somewhere else it's
still going to invoke the same method
you're still going to get the same
behavior there may be different type in
involved but the method being invoked is
the same and we felt like this was a
good invariant to preserve to avoid
situations where apparent apparently
identical expressions mean completely
different things depending on context
so that's it for target typing you move
on to variable dependencies you will
note that the girl here is very happy
and carefree the reason she feels that
way is because she's using Java 8 and
she's happy about the new inference
enhancements so you too can be happy
like this you're doing your programming
ok
one of the interesting properties of
generics when they were introduced in
Java 5 is that type variables can be
related to other type variables they can
also be related to themselves so on the
third line I have a sort method this
isn't exactly how the sort that you have
in the Java util collections class is
declared but there's different ways to
declare it and this one is useful for my
example so we've got two variables T
extends C and then C extends comparable
of C the reason we might declare it this
way is so that if I have a class
hierarchy like I'm I've got there on the
first two lines it's possible to pass in
a list of Sprague's which are comparable
to widgets and this should be okay if if
I just said T extends comparable of T
Sprague's are not comparable to other
Sprague's and so that that would be less
useful so
immediately from this declaration of
sort we have a couple of bounds one is
that T is a subtype of C the other is
that C is a subtype of comparable of C
notice the question yeah
so so when I declare an interface the
appropriate way to declare it supertype
is with extents when I declare a class
then you would use implements to
implement a class
okay I see what you're saying yeah so
you're talking about the third line the
word extends in the third line right so
the question is why do we use extends in
the third line if these are this is a
class implementing an interface
shouldn't I use implements and the
answer is extends in this context means
something a little different than it
does in the declaration of a class so
that it's general to include both
extending and implementing okay so I
said we've got Tia's subtype of c and c
is a subtype of comparable of c just
just right away we know that for for all
invocations
now this particular invocation where i
pass in a list of Sprague's I also know
that T is a sprog and so what inference
knows just from the the constraint
formula we started with and the declared
bounds of the variables is this set of
bounds at the bottom now what will
happen in Java 7 is resolution we'll
look at that it will resolve T equals
sprog obviously then it won't know what
to do with C and it ends up generating a
new capture variable that that
represents the an arbitrary type that is
comparable to itself that's not very
useful for us because we don't want an
arbitrary type and in particular we get
a type error because T is not a subtype
of that instantiation of C of C so that
doesn't work what Java it will do I
should note by the way I think this is
an area where there's been some bugs and
and patches made so if you try it out on
a Java 6 compiler or something I don't
know what you'll get this is what I got
when I
filed it against Java c7 so what we do
in Java 8 is before we get to resolving
the inference variables we'll do some
extra work we will look at what we know
and see if there are other things that
we can infer so first of all if I know
that T is equal to sprog and T is a
subtype of C that implies this frog is a
subtype of C right and so let's add that
to the set of bounds now if you look at
the last two bounds I have a lower bound
for C and an upper bound for C and so it
should be true that the lower bound is a
subtype of the upper bound if that
weren't true then it would be
inconsistent and we'd get a failure and
so we have a new constraint that gets
generated out of this set of bounds
sprog is a subtype of comparable of c it
doesn't say that anywhere in in the
invocation or in the declared bounds but
by looking at the set of bounds we can
infer that and and the point of going
through all those steps is now we know
that C must be widget because that is
the super type of sprog that comparable
implements sprog is a comparable of
widget so when we get to that point then
when resolution looks at the mountains
it's really easy to see what it should
choose
what I've described generally speaking
as this process we've called
incorporation which is to take a set of
bounds and add some extra information to
it and not only just do a set Union but
also compare the bounds and generate new
things so you don't need to understand
everything here but these are the set of
rules that we will follow which is
basically just straightforward
substitution some transitivity basic
logical principles that we can apply to
subtyping in order to generate
additional constraints
last thing I wanted to mention I'm
talking about variable dependencies I
had the case and the previous portion of
slides talking about how we handle
nested invocations by waiting to
instantiate the inference variables but
what happens when we do that we get
things like limit let me describe this
example so I'm calling a fuel method and
I'm passing in an empty ArrayList that's
newly constructed I don't want to be
bothered to type in the type arguments
for a realist I want that to be inferred
and so the question is how is inference
going to be able to figure out that the
type I want is an ArrayList of string so
we start out like I said we'll just say
we have a write an ArrayList of T I
don't know what T is yet and I know that
that targets see what I get out of that
constraint is the really simple bound or
a list of T is a subtype of seat I also
have an upper bound for C and so putting
those two rules together now I know that
ArrayList of T is a subtype of
collection of string and with that extra
information I know that T must be
strength so what we get from from these
extra enhancements first of all as a
client of some of the the existing API
is maybe you've occasionally run into
cases like with comparable where the the
the existing algorithm really does not
do a very good job with dependencies
between variables the other thing is now
the the the algorithm is powerful enough
that it was sort of dangerous before to
try to declare methods that had too many
interrelated variables
something like this but like this is
it's just sort of convenient to be able
to the point of this film method is that
whatever I give it I'm going to give
that type back so it works for sets and
it works for lists and it behaves
differently by returning either a list
or a set depending on what you pass into
it so something like this can now be
declared and it's actually useful
because inference will complement the
Declaration and and and make it possible
to leave out some of this so typing
information all right the last major
area I wanted to talk about is lambda
expressions and Method references this
is not a talk about lambda expressions
and Method references so if you if you
don't know what I'm talking about here
feel free to just ignore the next few
slides and come back to it when you're
when you're up to speed we have within
the design of lambda expressions two
different kinds for the purposes of
typing on the one hand they can be
explicitly typed where all of the
parameters of the lambda or stated
explicitly and on the other hand you can
leave out the types of the parameters
and let the compiler figure them out
that's kind of a new thing it's sort of
similar to how we saw before with type
arguments where you can leave them off
and let imprints handle them or you can
write them in it creates some unique
problems so
when we have an implicitly implicitly
typed lambda and I invoke something like
this comparing method what is useful
about the comparing method is it's it
works for all sorts of comparators that
the idea of this this method is you pass
in a getter for a key and it will create
a comparator for you that does the right
thing returning negatives or zero or
positive numbers depending on how those
keys compare to each other the
declaration doesn't know anything about
the type string when I invoke it there's
nothing nothing in the invocation that
tells me that I'm operating on strings
and so this is a poly expression
obviously we need to get some context in
addition to that we have no idea what
that lambda expression represents what
is s until we've decided that I'm
operating that ID then I need a function
from streams to something and so the the
way that timing works here is the the
implicitly typed lambda will be ignored
during overload resolution and once
we've looked at the context and we see
that we're assigning to a comparative
string then we'll come back and let that
information push down to the the
parameter type of the lambda what that
means is what if I've got two different
comparing methods one that takes a
generic function and the other one that
takes a special function from T to the
type the primitive type int well now
when I do overload resolution I haven't
looked at context yet remember we have
that rule overload resolution is context
independent and so there's no way to
decide what s is and if I don't know
what s is I can't even begin to look to
the body of this lambda expression and
do type checking now and this
case no no okay in in some cases maybe
it's obvious but in general I don't like
here I don't know what s is so I have no
idea what the length method represents
so this will give you an ambiguity error
on the other hand if I haven't
explicitly typed lambda then I've got
enough information that overload
resolution can look at the body of the
lambda right away and perform well it
can look at that thing it can see that
it's returning an INT and so it will
prefer the joint function version now
that may seem a little bit like voodoo
s is a stream here and s is a string
here and both functions are working on
strings so it's a little weird that
adding the word string is providing
something useful but the key to
understand is by giving explicit types
now overload resolution has the
information it needs to look at the
lambda otherwise it's just completely
ignored yes
so the question is are implicitly typed
lambda expressions worth it couldn't we
have just gotten away with the
explicitly typed variant we have found
that yes that's that's one of those 80%
use cases again where most of the time
it's it's such a small expression and
that the type of the thing is just so
obvious from context for readers that it
doesn't provide useful information for
readers necessarily to write in the type
information so the only reason you would
do it is for the sake of the compiler
yeah
say that again I didn't hear the first
half okay what is the runtime effect of
the inference here at runtime the type
of the lambda expression in this case is
either function or - int function so it
can't affect overload resolution the
ultimately if we're talking about
generics being inferred those will be
thrown away at runtime
okay now method references have a
parallel method references are a
shorthand so the rather than writing out
the lambda that invokes the string get
length method I can just say I want
string Doggett length length treat it
like a function there are exact and
inexact variants and the difference is
the exact version of a method reference
is one that is not overloaded and not
generic so we know just by looking at
string get length exactly what that
refers to
with substring there are multiple
substring methods without context I
don't know what that thing means so
again it's just like the lambda
situation where the meaning of the
expression can be determined from the
bottom up on the left hand side and on
the right hand side we need to know the
parameters that are that are involved in
this expression based on the target type
in order to make decisions about what it
means so again if I pass a inexact
method reference to this comparing
method I'll get an ambiguity on the
other hand if I have an exact one like
string length which it turns out is
actually most methods are not declared
to be overloaded and so again this was a
case where it would be cleaner to just
not do anything special here but it's so
prevalent
that people are going to want to refer
to getters or similar methods that we we
felt like we need to do some extra work
and so in this case I know exactly what
string colon colon length means I know
that it returns an intent so overload
resolution inducing the takeaway of this
two things one if you run into an
ambiguity error it can help to add
explicit types to your lambdas the other
is if you're declaring the methods don't
overload like that because it won't be
very convenient for for your users so in
this case we have a method like
comparing in the api's and java 8 and we
named the second one comparing int we
ran into this problem we observed that
that was going to be inconvenient and so
we gave it a different name generally
you don't want overloads that are meant
to work with lambdas where the choice is
based on the air where the choice is
based on the typing of the lambda
expression being passed if it's just
arity we can handle that so if there if
you have one variant of your overload
that takes in a three argument lambda
and another one that takes in a two
argument lambda that's okay no problem
but when you start to to depend on the
typing of the the lambda expression
itself it's better just to avoid
overloading in that case
okay so so those are the main things let
me give you a grab bag of some other
things that we've done there's been
quite a lot of digging into how
inference works and improving things we
do an analysis of the variables when we
resolve them so that we do that do it in
the right order previously they were all
just resolved at once and now we take a
step by step approach to make sure if
something needs to know what another
variable is resolved to we do some
analysis for that same thing with
lambdas if the return type of one lambda
is going to impact the parameter type of
another one then it doesn't matter what
order they appear in we're going to type
the the one that is depended on first
there's some special logic for variables
that appear in throws clauses so in a
throws Clause you cannot have a generic
type that you can have either the name
of an exception class or a type variable
you can say throws e and in that case
it's often inconvenient to choose the
the upper bound of e which is what Java
7 does because usually the upper bound
is something like exception and then you
have checked exceptions running around
in your code and so we've tweaked that
to prefer runtime exception where
possible we do some extra work with
capture when there's a return type
something like list of question mark
extends team and when there's a return
type assigned to a primitive we do a
little extra work to be more flexible
with unboxing so you can for example t
maybe if it targets the type int one
choice for T might be integer another
choice for 40 might be short because
short can be widened to int and so we're
a little more flexible
all right now I was talking about I said
I talked a little about the migration
experience what you can go out and do
when you get Java eight first thing is
to note that there are probably a lot of
examples of type arguments explicitly in
the code that no longer need to be there
now if with Java seven you might have
done some effort to to look for
constructors that could make use of
Dimond and so there's a similar thing
you can go through and just look for
type arguments that don't need to be
there anymore we saw this example
earlier in the slides that string type
argument we can just get rid of it is
there a benefit to doing that I think it
kind of eliminates noise so it's
everybody first of all I'm not sure
anybody really cares what the return
type of empty list is in this case that
what matters is that it is an empty list
and second even if you do care it's
pretty obvious from context so there's
not much documentation value to the
thing it was just there to satisfy the
compiler and now the compiler doesn't
need it anymore
an easy way to find these things that
just grep for the dot angle bracket and
I think that's the only the only place
you will find that in Java code is where
there are explicit type arguments
is there a warning if you have explicit
type arguments no I'm not sure there
that is the kind of thing where maybe
some day a warning could be added but
I'm not sure that would be the kind of
thing where there's nothing particularly
wrong with having the explicit type
arguments it was just inconvenient to
have to put them there in the first
place okay so the question is about
diamond similar situation as this you
can identify cases of new ArrayList of
angle brackets string being passed to a
method and this is a since the Java 7
feature I we've added the context so so
there's new contexts in which you can do
that that you couldn't do in Java 7 the
the syntactic transformation there is to
remove the type argument that you leave
the angle brackets and that's kind of a
strange-looking wart in the language is
that by design yes it did the
interpretation of new ArrayList without
the angle brackets without the diamond
is to create a raw type and so yeah
that's the way it was designed
on the downside when we start tinkering
with type inference there is some risk
there that you should be aware of this
example invoking the M method we saw a
slide before where the type of arrays
dot as list 1 comma 2 comma 3 used to be
list of integer and in 8 we're flexible
enough to say that can be a list of
number so if I happen to have overloads
where list of number is one of the
possibilities then I've added a
candidate to the list of applicable
methods and what happens when I do that
well it could be that now there's an
ambiguity because there's more methods
applicable for the invocation it could
be that the behavior changes like here
instead of printing out X it will print
out why this is not that there's no
impact here on binaries but if you
recompile your code it's possible that
you'll find situations like this note
that as I say you can't begin to to
improve typing at all in the language of
existing expressions without running
into this once you've changed the type
of an expression or made an expression
more compatible with things than it used
to be there's a risk that there will be
more overloads and so that's just kind
of the nature of the beast and the other
thing to note is that generally speaking
while we do try to be careful to be
pretty stable in the interpretation of
invocations and the overload that they
resolve to it's not really a good idea
to write code like this where it really
matters which of the overloads get
picked especially when one type is a
subtype of another so with those caveats
you should at least be aware that this
is a possibility and watch out for it
and a question here yes
so the changes I've talked about today
was it necessary to do these to make
lambda expressions work it was necessary
to have some of these features in place
in some form in order for the for
example it's very common to want to pass
a lambda expression to a method and so
the fact that a method argument can make
use of context that was just a basic
requirement the fact that we've extended
it to include other kinds of expressions
that was a choice who made just to keep
things consistent and make it feel like
lambda expressions are just part of the
language rather than a weird new thing
that's designed completely differently
and because in addition to that there's
a lot of benefits to being able to make
use of inference in all these other
contexts so it kind of came along for
the right
so so you're making the point that
generally that the direction of the
language is to be a little less strict
require as fewer types being typed out
on the on the keyboard and have the
compiler do more work and there's a risk
there that the compiler is going to make
the wrong choices right so yeah we are
aware of that tension and we've tried to
find a good balance where if you're too
strict and too unwilling to let people
leave things out it becomes extremely
tedious and part part of the whole idea
of lambda expressions was to eliminate
some of the tedium that is involved in
writing out anonymous inner classes and
so there's sort of a general philosophy
of moving a little bit in that direction
well while keeping in mind that there is
a an important part of the language
which asks for the types to be there
yeah and and we don't want to push too
far and the other extreme let me finish
up I've got two last slides but
hopefully the the benefit going forward
as you're coding is new freedom to do
things that you were less willing to do
before that required more of the the
tedious boilerplate then before you can
make heavier use of Dimond everywhere if
you would like to it's no longer
restricted to just the narrow case of
assignment context if you like
conditional expressions there's a lot
more freedom to to use those and and
those no longer interact badly with with
inference generic methods can be nested
and still make use of the context in
which they appear
I mentioned before the the handling of
type variables especially is strong
enough that you can make more
sophisticated generic api's and the
compiler won't choke on them part part
of what motivated these changes also was
the library changes that went on in the
the streams API some things we just
wanted to be able to express in the API
and the language wasn't very good at
handling them and as I mentioned that
lambda expressions are driven by wanting
to eliminate a lot of boilerplate and
the use of target taking there helps a
lot so just a couple of references if
you'd like to learn more you can go to
the open JDK lambda project that's a
good google for that and go to the
landing page for the lambda project
there are some good links good places to
start in the JCP we we are approaching a
public review for jsr 335 so there will
be a full specification that you can
take a look at if you want all the gory
details and always welcome feedback at
the lambda dev address then alright I am
available for questions
first one back here you could be quiet
as you are leaving if you don't want to
hang out for questions thanks
go ahead
yeah I'll take questions if you'd like
to hang out I'll have an open to name
for a few minutes so so you're saying
you have identified bugs in Eclipse that
weren't tightly specified are you're
talking about Java 7 are you talking
about Java 8 in Eclipse okay
okay so so the question is about the
Eclipse had some changes where different
type inference behavior occurred and
because the specification wasn't very
clear about what was supposed to happen
that they weren't going to pursue that
bug and yeah that the Java 5 version of
inference that has been in the language
specification has a number of holes
where it was sort of left to compiler
writers to do their best to come up with
something reasonable and so part of what
we've tried to do is clean up a lot of
that so there is a clear specification
which doesn't help for the past versions
but hopefully going forward there will
be a clearer specification that all
compilers can agree on yes will we have
a VAR keyword so I can say var I equals
something we know that's something some
people would like somebody was asking
earlier I think his opinion would be
something like that would be too much
and so yeah it's something we we know is
out there that we might choose to look
at in the future sometime uh you had a
question
yes so what does it mean for overload
resolution to be context independent
that means that the arguments to the
method can impact what choices made but
I'm sorry okay so I am using that kind
of loosely that the meaning of variable
names in those expressions depends on
some variable declaration right is that
the kind of thing you have in mind once
I know what those expressions mean and
then can determine their types for
example then I'm not going to look
outside of the expression to do the
overload resolution
uh-huh
tell me when to stop
the son
why don't we talk about that mara you
can come up we'll talk more afterwards
okay I thought I saw somebody over here
go ahead and then back right so there's
two ways to disambiguate I talked about
having an explicit type arguments
another thing you can do is just assign
variables declare new variables and you
can write out the type of that variable
it's a stylistic choice sometimes it is
with lambdas with the stream API we've
kind of pushed towards the ability to
have a lot of chained calls in a role
and in a row and if that's the style
you're using then it might make more
sense to put the types right there but
you know if it's convenient to identify
exactly what the type of something is
and pull it out then that's great good
generally on this plastic from this
attack
for lambda expressions
okay I'm not really a UML tool expert I
would expect that those tools are going
to be following after you know that
though they'll catch up probably within
a few months after the release generally
the the kinds of things we're talking
about are changes at a AU site of
something and the declaration picture
like the interface hierarchy and things
like that I wouldn't expect a lot of
that to change for example if you don't
have anonymous inner classes in your UML
then you wouldn't have lambda
expressions if you do then it would
probably look similar okay yes they
cannot we thought about that we didn't
implement it it's something we may add
in the future but for now it becomes
tricky when you look at generic methods
and wanting a way to add type arguments
and things like that so we steered clear
of that right now if there's a problem
your work around is just to use a lambda
which is often it's just as many
characters to type out the lambda as it
is to type out the method signature let
me take these two and then I think we
better wrap up right here first
uh-huh
this is what you're talking about right
the sort method yeah let's see you want
to look at the class declarations so are
you talking about can we change sort or
you talking about can we change the the
declarations of the classes sorry yeah
an easier way to do this in this case is
to say question mark super T list of
question mark super T and then we can
get rid of C I think something like that
we need the comparable to hang around
somewhere there's other ways to express
it but this problem so I sort of tweaked
the signature to make this example work
but you'll you'll run into this in other
situations that are less obvious over
here last question
it's very slow to scroll through okay
this one what happens here what happens
here is it will compile the old behavior
is to choose m of object because that is
the only applicable method the new
behavior would be to choose m of list
because that's more specific than m of
object yeah it would compile and then
you'd get different behavior you can
construct another example where it
wouldn't compile yeah it would be
possible to have a tool that would be
like a migration assistant to identify
times when when the types changed and
that's not something we've implemented
somebody wants to do that and release an
open source checker that'd be awesome
but I think it's also if there are error
messages that are really confusing for
things like this then please report
those either either with bug reports or
send an email to the lambda dev email
address we're always interested in error
messages that are confusing that could
be clarified yeah okay I've got to wrap
up thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>