<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Demystifying Java EE | Coder Coacher - Coaching Coders</title><meta content="Demystifying Java EE - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Demystifying Java EE</b></h2><h5 class="post__date">2015-06-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/zht_qvbm5lU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so welcome to my first secret ninja talk
so if we attempt to record something
that things happen so you see how how
important Java he becomes they
mystification strange so I think it's
misunderstanding so if you yeah but you
will get everything what do you worry
what you you get a slide from me per
email then I get probably some problems
with Larry but right so and I mean still
freelancer a contractor one-man show or
singleton with it singleton a notation
and broking with Java since 1995 and the
strangest thing about me I really
enjoyed still and really appreciate the
more I code the API hey p.m. I am and
try to avoid actually conferences
because travel takes a lot of time and
you lose some time for coding so this is
interesting book instead one of the
recent one I think 2009 or 10
so I described the whole process of
writing a Java 6 application this is the
most recent book about Java 6 patterns
more code centric patterns actually
somehow related to the stock the bad
news is because of my marketing skills I
forgot to bring the books and on hefty
books also not in the store so you
cannot buy them here but the workaround
is Antonio Gonzalez his his book come up
show your book so I buy his book instead
and if you like his book you would like
you would like my book is a my book as
well so you can buy it later so his book
is here and he would even sign it right
yes of course so if you buy his book it
would be signed by me or him right I
could also sign it ok so we this was the
secret part now come to the not so
secret so I your book is a Java EE
related yo comic on stage his book is
even better
yeah come
I don't know your book but I know him
and what is your book very good
is it confidential or oh okay Java EE 7
handbook by Mark pilgrim right Peter
sorry Peter
Mark pilgrim is something with html5
okay and you are the Java guys is even
more important
so I'm three times a year I do a ear
hacks in Munich Airport so this is the
idea of fly high fly and usually I had
t-shirts but I gave all t-shirts away in
the previous talk what are left are
stickers and I bring the t-shirts
tomorrow again so I just exception
happened in a previous talk and now
start with the content so what is Java
EE is the first misunderstanding so and
for me as developer Java is nothing else
than a bundle of api's and Antonio
correct me or mark whatever this is what
actually our collective talk right so
Java is nothing else than an release of
coexisting api's if I started with Java
it wasn't the case so eg bees were came
out I think 1997 1998 1997 was the first
eg b1o spec actually and then came JMS
and and JDBC came with gdb JDBC should
be shady k-11 I think Jane dear and so
forth so at the beginning before Java I
swore a huge mess so we had millions of
application servers like persistent
power tier and gemstone and tight stone
there lots of stones I can remember a
lot of stone application server
persistence palette here and Tenga was
kunos Tenga there wasn't or be a
WebLogic the tanga is a neighbor island
from java so they call it Tenga it ran
on the well this was the previous name
of PA and it's a problem with datas you
had absolutely no chance to find two
application servers with similar api's
no way as j2 we came out I was really
happy
second huge simplification and one year
later everyone it was huge complicated
and the force because you didn't saw it
how it looked like before
so before j2e it was a huge mess
nothing was portable sadness didn't had
even web.xml so there was actually in
nightmare uuuu call it at the time we
realized oh we could even sell it should
be one Oh as an perfect technology right
now because there was no XML and
everything was like I would say the
configuration was just method invocation
so you can just invoke method like DSL
style we could sell it now it should be
for our DSL like implementation without
XML and a Java 1 mm the XML was
introduced as the next big big thing and
everything was XML since then now it's
over but back then was nice right so
Java EE is just and if you get for
instance uh by 7 you can say okay now I
have CDI 1 1 @ JP a 2 1 and it should be
3 2 so you can rely on the existence of
this specs so it's actually like a tag
in get its j2ee or Java ok got it
this is simple so innovation versus
standardization so what I hear a lot we
have lots of frameworks and they are a
lot better than Java EE I would say Java
EE was never about standardization if
you build innovation if you build a
standard you cannot innovate it's just
because there will be no products out
there which implements your standard so
Java EE and j2ee or whatever will always
lag behind
for instance hibernate will be always
always have more features than GPA and a
clinic as well and spring will always
have met more features than CDI because
I mean otherwise it is not the whole
point of abstraction is is this um just
forgetting about some low-level details
and concentrated on 80% so I would say
Java is the 80% which makes all the
products out there and this was never
about innovation if if the expert groups
would start to innovate we could I mean
throw it away there will be no did it
will be impossible to demystify anything
in one session right agreed so far so if
you have questions just feel free to ask
so I would like questions then the more
heretical or offensive they are the
better it is
so really because then is the
conversation between developers yeah
what I hate the management question like
Enzo okay so our eg beats bloated so
here the load we don't use Egypt
we use lightweight programming model and
if I looks look at the lightweight
programming model the last time it was
like a tomcat was lightweight it was
about ten mechs and and the war no
kidding
was 500 mix and the architects said ok
this is lightweight because we have
small server and my who cares about
small service we have we don't have at
least in Germany not no problems with
disk space I mean if you have you know
10 10 makes for Tomcat you save probably
2 cents or $3 or 3 euros it doesn't
matter you know and and everyone is
excited that serve a small I wouldn't
had any problem if the server would
would take I don't know two geeks on the
on the hard disk but should start fast
and be lean and and and and and unusable
so the disk space I don't get the point
at all and what matters to me are small
words the smaller the war the faster
they built and deployment the faster the
build and deployment the more productive
you become this is actually the whole
point of Java EE not putting everything
in the war and you are lightweight
because you know the the Tomcat is or or
jetty are small I would say I would put
as much as possible on the application
server and if nothing in words in fact
most of my wars Java 8 6 in Java 7
projects are very very small like one
one maker or something ok got a point
just the idea the jeebies are bloated
how to prove so the question is it
implies there is some voodoo stuff
behind the scenes right so bloated means
it is not just a Java class it has it is
something somes something behind each
Abi's what which makes eg bees bloated
so what is the easiest thing to do is
what you could do actually there's only
one code snippet that will heck today on
on Thursday I will hack the whole time
but now we have no time because a lot of
stuff what you could do you could create
a very simple web application and say
may even get web application let's say
load at JavaOne and the application
server not JBoss how would you
the GlassFish before so and the easiest
possible thing is to see what happens
behind the scene is is to create a
sublet and egb and then throw an
exception what you can do then you will
see the stack trace and there is no
discussion left if you see this tech
trace you know exactly what happens
behind the scenes period and the whole
discussion do it all because in meetings
and we spent five days to discuss
whether eg bees are a lightweight or not
so now we can say I don't know the
exception Factory
please don't record that this is a
confidential of course so um there's
actually now I can do whatever I want in
the talk because there is a no there is
no records of this so exception throw up
and now start with the bloated egb which
is actually approaches with with one
annotations public void explode with one
method throw new illegal state exception
picture someone to picture so we get an
exception so what you can do you can
inject the EJB to the effect to the
thrower to the factory story exceptions
throw on et it is actually a nice name
and someone in between I just explode so
now run and with a little bit of luck we
should see the exception some does is
hard to provoke exceptions in Java six
so what is the name of the servlet is
exception Factory
perfect
and now there's no news or good news and
you see the oh no pointer yeah you see
no magic right
no no annotation not pointer so now
illegal state exception picture and what
you see is is it should be exception we
have one invoke we have a little bit
strange stuff here and you have see a
security we have here interceptors chain
system intercept or and it's about for
for reflection calls so it means on
GlassFish before the overhead of an eg
be are for reflection calls so the for
reflection calls are very slow in Java
but comparing into a database access is
nothing so like no reflection call takes
I don't know probably 1 milliseconds or
something and I mean if the GB takes 2
milliseconds we don't have really a
performance problem right so what's
funniest eg bees were developed in 1997
in the same year aspect-oriented
programming was developed as well and
this is actually the reason why in eg
bees never the vert aspect is actually
mentioned so what you see here what egb
actually is is a POJO with a couple of
aspects called interceptors and we had
from the beginning of j2ee always
aspects and the aspects were security
transactions state management threading
and pulling these were our aspects and
there's actually the reason why I Opie
never took off in j2ee because we always
had the aspects declarative aspects but
there was no mention of aspects because
at the same time eg B's and AOP were
invented so I was curious the first
paper I found was 1997 about AOP and and
it should be 100 I think there were end
of 1997 was the spec you can still find
it on the web
questions are far so of course it can
differ prep for applications about the
application server but I remember and
JBoss for there was even you can even
see the interceptors you can even
configure the because you will so exact
exactly what happens behind the scenes
right so what eg bees are is like you
know a CD i-beam with aspects and what
see the i-beam erst is just the POJO
with injector whose injection without
the aspects is it bloated or no I don't
know but very similar to all other sort
of frameworks on the planet so it should
be is very similar to spring juice hive
mind whatever every framework I know
works it way so questions are far so and
all attempts I saw to get rid of eg bees
we're like reinvented eg bees in a
project which is absolutely crazy okay
so I'm at least I try to focus on
business logic and not building the
application server also building
application server sometimes more fun
than concentrated on business logic
right so this is the problem what we
have as developers we forget about the
business logic and build application
servers instead and six and five yeah
yeah I get algo eight a lot but do you
think about this travel five came out in
2006 this is ancient seven years at the
same time as Reuben rates
you could argue now Ruby andreas is not
usable because it was not there in 2003
you know what I mean so 2006 rays came
out and Java 5
yeah they were they were okay but this
is more political discussion here if you
what I wanted to say with Oh with with
one thing j21 for the latest one came in
2003 in 2003 there were no annotations
so you can all do magic right since 2000
so from the technological perspective
with jdk 1/5 we could only do the nice
stuff but xml yeah but I know project
who are XML is larger than the source
code really the XML is longer than the
source code and and in j2e I always
generated XML with excellent I never
even attempted to write it by hand I
hate it
XML like hell and the only problem I had
was j2e
extra code was too slow if you look at
gp3 and gyri fibers it is like extra
caboose annotations so the same ideas
extracted okay so you alright so it was
but to do what seven years ago we are
2013 no no but I'm demystifying Java and
not spring but you're right what Johnson
yeah rod Johnson pushed hard hibernate
pushed hard and this is a good thing and
and rails Java e5 was also influenced
heavily by race so in others you will
find mentions configuration by
exceptions our convention of a
configuration but they learned from race
as well which is very good thing ok very
good point you get tomorrow a t-shirt
and today a sticker ok ok but this is
what I like all right stupid j2ee rod
Johnson did it in 1945 and you are
talking about this yeah this is really
this is a developer discussion the next
part is j2 is about transactions and I
don't need any transactions because we
don't need it so we are in 2013
transactions old stuff so I'm asked
always the question is imagine we have a
read-only app it reads just weeds from
the database other databases are other
applications of writing to the same
database
do we need transactions or not all right
very much so yes so our t-shirt of
course and stick it today and t-shirt
tomorrow yeah but why the problem list
annotations annotations transactions are
asset and everything is doesn't matter
only thing that matters is this I its
the isolation if you don't have
transactions you have you run an
unspecified isolation level you mean you
are relying on the isolation levels in
the database and they could be read
uncommitted what it means in a trading
application you would see the current
snapshot of the database which is not
always that what the manager managers
would like to see because you could
really easy take the application you can
just order a lot of stuff and then roll
back and you will have phantom reads in
your application right so what it means
in my projects is there is no
optimizations on transactions nothing
everything is transactional the boundary
between presentation and business logic
is transactional period no optimizations
there and it works well in one case the
architects really optimized this it was
in j2e days and it set the transaction
to not supported which which which
actually means deactivated transactions
and what happened then for each
interaction with the database the
database created a very small
transaction and the performance was
terrible because instead of having one
transaction we had 100,000 times actions
really in this each transaction that
some overhead view milliseconds it was I
remember exactly 40 seconds longer than
with a transaction so don't mock was
transactions and the Nets what I would
like to tell you is just set up a
solution level as high as only possible
everything is transactional and provides
some performance tests so you then will
see dead logs whatever you will see what
happens on a heavy load optimize last
never before premature optimization is
the root of all evil okay and homework
to the to the next year is if you read
about asset no isolation
and read only you will find out that we
have actually there we need more
isolation level for reading there are
not sufficient isolation levels for for
reading and the event database vendors
like experimenting with that so we need
absolutely transactions for reading okay
everyone agreed okay perfect card
the Nexus okay but transaction is very
expensive so what I will usually do we
have had more time I would create an EJB
and make it transactional and then
measure the impact what do you think is
the impact of intersection just an empty
method transactional or not what is
actually the impact of an empty
transaction this is crazy low why
because if you think about this what the
application server does behind the
scenes what happens behind the scenes
and the nice story is almost nothing so
what empty transaction just does is it
marks I think the current threat as
transactional so the point of having a
transaction is like saying to do to the
transaction manager now we have a
transaction so X setting like boolean
flag this is the overt of an transaction
okay so when it gets vs. of course if
you are accessing in the transaction the
entity manager you sending GMS or
something then happen something behind
the scenes but you can you shouldn't
optimize transactions for method which I
don't know just don't talk to
transactional resources so in my eyes it
is easier to be to have to have one way
or more maintainable to have one way of
dealing with transactions and would
admit my projects I am actively
searching for the word keyword
transaction if there is no Kiva
transaction everything works perfectly
because what happens then the first egb
will study transaction is because
reusing to the back end if someone uses
user transaction absolutely forbidden I
have actually found soon a source rules
which which escalate that if someone
uses transaction attribute is also
suspicious that only view cases from
transaction attribute like for instance
writing audits you need a sub
transaction because you would like to
write commits and rollbacks to a
database for instance for audits right
agreed everyone
bookout us as well perfect obvious
everything compatible with your books
otherwise don't buy them right said I
have to reject so yeah but I mean I
would as he the other way around in my
development phase and tests I would set
up the isolation level as high as only
possible and provoke deadlocks and see
where they are and what happens and then
react on that and and change net stress
testing this is my session on the last
day Thursday so come here will I will
heck it on stage so this time is more
formal because of a lot of slides
dependency injection so I get that what
happens behind the scenes and the funny
stories actually very little to
implement here an own injector is
actually not an effort at at all this is
very very simple actually the session
before I showed a Java Xcode with
dependency injection with my own
injector of course so and because
dependency injection is so easy there
are so many dependency injection
frameworks order because the developers
has nothing to do the right first on
login framework then it's a little bit
boring and then the next part is
dependency injection really and these
are very impressive but is nothing
behind so what is out like actually
wanted origin it to hack it on stage but
I brought a screencast so you can look
it up I do it online but if you think
about this what happens we end this
scene so what is dependency injection in
Java 6 so if you think about this what a
container has to do is what a container
has to do is is the following
it has to search for at inject and other
annotations so how to search for at
inject the java code is exception
factory class dot class you have the
class get declared fields you get all
the fields an array of fields a for loop
for control space then ask each field is
a notation present at inject if it is
present you have the type exception
throw up if you have the type you
instance we have the instance field set
and you are done this is actually the
code for dependency injection
and what in my in the bootstrap workshop
I talked about eggs and everyone is okay
what happens actually behind the what is
the what is the at inject a notation and
the @inject annotation is actually if
you look at this it's actually nothing
it's just a marker so annotation have
never behavior annotation just marking
fields and the application server reacts
to the 2d declarations right so this is
actually the whole deal with annotation
there is no magic behind absolute
nothing
it's like marker interface in 2013 if
you think about this I think if Java
would be created right now serializable
wouldn't be an interface it would be an
annotation okay
so it's nothing behind so the
application server at deployment time
scans for annotations and do something
so this delegated to CDI or to eg bees
and eg bees are pulled and CDI not but
the the process of an of dependency
injection is trivially and this is
developers are somehow somehow afraid
about orders to too much magic is no
magic at all
and Java Eve works that way if the
dependencies are ambiguous you get
ambiguous dependency error if there are
no dependency to inject you get
unsatisfied dependency error and that is
actually so there's absolutely no magic
on the whole whole whole dependency
injection is type safe so what it means
even the IDE knows whether the
dependency injection would work or not
so you get helpers in IntelliJ and
NetBeans as well and probably an eclipse
in the next 10 to 15 years as well
just joking they have it already so if
you have to use eclipse use Davos tools
this is a similar experience like
IntelliJ no plug and just download and
go for it yeah so uh in mine point there
is nothing behind dependency injection
and actually as it came out there are
lots of articles book about dependency
injection was completely confused
because there is actually the whole idea
the whole point of dependency injection
is extracting a factory to the framework
period if you instead saying factory get
instance create you do it five times
stupid coat you factor it out to a
framework rename it to assembler and and
and and fancier name assembler wiring
but is actually nothing behind
agreed should I repeat something but
this is trivial so I will just just and
nothing to do with Java is just Java SE
so I would like to do more interesting
stuff yes yeah it does everything with
is web web in flip it depends in Java is
six it scans all the jars but in the
jars you were in the jar you will have
to have a bins XML file if you have the
bin 6ml it scans if there is no bin six
from and doesn't scan in Java 7 is a
little bit different if there is no bin
6 ml inside it just searches for
annotated beans and if there is has been
six ml you can specify where it has to
scan so this is optimized in Java 7 and
in Java 6 was just it worked in Java 7
you can optimize and it works
oh is it is it a question or is a
statement okay yeah this is the answer
so it should be pulling needed and if
you if you if you if you read these the
specifications on VG be it pulling was
introduced because new and garbage
collection the construction was heavy in
1997 and destruction as well but now it
is crazy fast so new for short lift
object is very fast and destruction as
well so actually the pulling is no more
interesting but if you think about this
if you put an EJB as a facet to your
business logic and eg peas are pulled
all the dependency injection happens
only once so it means if you have
millions of beans there is some overhead
for the first time and what you can do
stress this again okay you can measure
the load so all I need I don't know ten
exact 10 parallel transactions then you
say min pull size 10 and all the
dependency injection happen and startup
time and this is the reason why I always
have each B's without a GPS crazy talk
so I could implement everything without
a GPS but sometimes I have also
implemented my business logic okay you
got the idea
the next story with eg be thirst max
full size is great denial of service
attacks
this is prevention of denial of service
attacks let's say we find out in our
stress test that the application server
dies with 500 concurrent transactions
then you can say max pool size 400 and
will never die the clans will get
timeout but the server will work without
an eg be mission impossible I would have
to search you know for WebLogic
WebSphere or olestra specific settings
and and setup you know the set was
whatever with max pool size you are
basically done got it so a GP pooling is
absolutely needed first for your point
to because the injection is actually
what can be pulled and reused not the
creation and monitoring you can see at
real time how many parallel transactions
we have you will see it in real time on
the last day stress testing so surely on
stage
and and max pool size prevention of the
neuro service attacks I would appreciate
actually try to standardize that I was a
bit a little bit lazy at the end of Java
so at the beginning I'd try to propose
that max pool size is a standard but it
was rejected by the by the committee
what I understand because you are also
in GB spec right we are one of the view
external spec leads and we don't have to
implement the spec you know we have lots
of crazy ideas but you know the head the
Oracle guys and the JBoss they have to
implement our idea so absolute okay that
they rejected that okay short story a
tomcat project um cat project and the
developers used spring without knowing
that spring and default is a single team
and then they mark some methods as
synchronized which worked six years and
then do up and then was a heavy
refactoring because they had no
concurrency there if you if you marks if
yeah but in eg be synchronized doesn't
make any sense
actually it's also a question of what I
forgot so why synchronizes forbidden in
eg be it isn't forbidden doesn't work
because there is a single threading
programming model there's only one
thread for instance if you make it
synchronized I mean okay you can do it
but why
right so and singleton egb I say an 8 GB
we if you make it singleton you created
your first bottleneck because singleton
will lock all other threats and only one
thread can execute the instance so if
you make it singleton singleton beads
singleton beans single ed singleton you
were put at singleton egb I'm talking
about the jeebies at singleton there is
just one instance and there is not
concurrency you can do it can do
concurrent concurrency management and
make it how its colony container but a
bean bean managed concurrency then there
is no synchronization but you have
really be careful what we are doing you
have use concurrent hash weapons of
you can do this but this is another
optimization I have to admit I never had
a problem with eg P performance so I
never optimized that because something
can go wrong with Singleton's singles my
kisses just optimization for sometimes
caching you know startup logic pre
parsing XML files stuff like this
questions yes yeah but if you have no
state this is very rarely they'd have no
steady mo applications absolutely yeah
yeah but if you have an entity manager
this is somehow out of state if you put
the entity manager singleton if you have
probably a problem you know there are so
any managers on thread say for instance
you have to know a lot of things so in
my opinion if you just go with stateless
nah nothin but it's not fret safe look
at the spec entity manage is not thread
safe it's not thread safe cannot do this
you what do you do you have to do you
will have to go to how it's called
entity manager factory create entity
manager for each call it's just why I
would like you know the dis is the over
it would be the robot thank you
sticker and Morgan Titian Morgan Morgan
is German tomorrow so you know it's
everything getting more and more
confidential and the end that were just
talk German and no one will understand
so then you can record everything so um
so um this is actually good one yeah you
you are coming with Java EE and
everything has is has to be so so simple
why we have five annotations or four
annotations for injection and I will try
to is actually the explanation is very
simple so I'm at the resource is
everything which is on the application
server which is installed in the
application server and usually is
available through jndi so there is a map
name and name with resource you can
inject everything what is in jndi like
queues topics data sources even entity
managers heck but usually all the stuff
which is administered by the application
server with at inject usually it's
viewer view exceptions and exceptions
are called built-in beans with with at
inject you are injecting your
business code this is at inject 90% of
all all cases and persistence context is
like ant inject except it has more
attributes and inject was empty and
persistence context you can specify the
name persistence unit name you can
specify it's the entity manager
transactional or not so you couldn't do
the same with that inject you would have
to introduce at inject with qualifiers
for instance something like this okay
and EJB is legacy so in my my projects i
inject everything with at inject if it
doesn't work I have to use at eg be when
it doesn't work for instance if you have
remote eg be with strange Corbin Ames
you have to use a TGB because within the
eg be annotations you have more
attributes which you can play with
interface name at JDI name not a map
name not gnm map name and name got it
so at eg be forbidden in Java 6 in Java
7 at inject for business code resource
if you would like the resource which is
installed an application server and
persistence context is just for
injection of anti dementia in my eyes
very simple ok and usually what you have
I would say in 80% of Java 6 project you
only have at inject and persistence
context and you only need at resource
for JMS for instance serving view cases
and if you don't like and add resource
you can you can produce their resources
with it produces and make them
injectable everywhere so you can
actually concentrate everything in one
class and use at inject for everything
outside ok I can make this for you on
Thursday on stage because I will Hector
all the time doing those nice questions
regarding to this everyone understands
dependency - right right very simple
very clean ok so we we talk about that
yarp is not present in in Java EE the
problem is it was always present but
there is no name AOP so this is why
there was in my project we rarely find
something for AOP because the real use
case for AOP would be business logic if
you are able to extract some business
logic it would be a real case for AOP
for technical AOP aspects everything is
solved so everything happens already
behind the scenes
even with convention of a configuration
what convention of a configuration means
is if you if you have just it's
stateless everything is transactional by
default you don't have to specify on
each method transactional transaction
transaction was just transactional so
this is what I like right if an entity
at you put at entity on a class
everything is persistent and this is
actually a huge difference between Java
5 and j2ee this is inversion of
principle in j2ee was not convention of
a configuration but configuration over
convention really you had to specify on
every field you are persistent your
persistence you are persistent and field
which were not persistent to are not
specified which is crazy and in Java 5
de was inverted
so you just configure which is unusual
what it actually means in all mine Java
II projects we have no diplomatic
scripts absolutely nothing so we are not
deployed and not dependent on unless
whichever's or whatever except of course
persistent XML so there's a five lines
of persistence code but notnot EGP char
nor no the hotel is actually no more no
more no more necessary questions so this
is the next topic object relational
mapping I see at the log how we build
our own hibernate they don't call it
having it something else look on our
persistence of think and so ok nice
verts here in unit test 80% code
coverage unit test integration testing
everything and no one tested in
multi-threaded way so it looks like it
works in sonar but in in in real world
it doesn't work if to try to access the
same entity what is the problem if you
think about this what happens behind JP
a like eclipse link or hibernate you
have to to imagine the following imagine
there are two independent requests or
transactions are accessing the same
customer with the same ID what the
hibernate and Eclipse link have to do
they have to very efficiently clone the
customer per transaction if there is no
efficient cloning they would see you
know the state the state will be shared
between transactions so what you will
have to do first to build to build your
own or M is to create very efficient
cloner which can deal with cycles
recognizes the changes and
I think if you do it right you will
spend about two months just doing this
because of this heart no one starts with
that you know rather than a little bit
reflection again result set fields but
no one cares about this right and think
about optimistic locking and all the
stuff is really hard to implement so I
would say you have really no chance to
make something and to build or M during
your project right during your project
which actually works in multi-threaded
environment and it's transactional and
one customer might say we did it so okay
really so yeah and it turned out they
had three developers which work
full-time to maintain the hibernate
pseudo hibernate solution full-time this
is a huge insurance company so there
nothing else than maintaining okay then
you build your own hibernate so now you
know your your your business case is to
be better than hibernate whatever but
you have probably deal with insurances
as well not only with persistence right
so there was us this was as somehow
somehow similar to hibernate but Trench
in all the cases and then the next step
would be to deal with lazy loading eager
loading all the stuff is not that easy
right code manipulation whatever right
so I really believe or M is that so and
the next test is you have within a
transaction if you have an eg be to
pojos and you're injecting the entity
manager to Depot juice so we have one a
GBS boundary to purchase in your reject
identity manages to the poachers so arm
what should happen within a transaction
if you access the customer twice in the
same transaction you will have to get
the reference the same customer then it
works correctly so your persistence
framework has to recognize that it runs
in in in a transaction and return to you
always the same instance and this is
called
identity identity map pattern from
Martin Fowler if it doesn't work you get
copies of the objects this is why most
of the DAO patterns didn't work because
a dowel returns DTO and you in and you
end up to have multiple copies of the
same object in the same transaction so
what do you get lost updates ok so the
nice story is if you do not think just
injecting entity managed to eg bees it
correctly if you try to optimize it
looks a little bit stranger than agreed
agreed
perfect so now with the concurrency man
this is actually the slide what we talk
so actually the concurrency and thread
safety is just avoid singleton this is
what I the singletons Bichette state and
the easiest way in my eyes is just to
avoid single T's all together and then
you can search actively with even grab
for singleton if you find something
which is suspicious just reject you know
the the build or something you can just
break the build just by this so we were
really did we I don't know whether you
know so now source is the open source
tool which with quality matrix is a
maven plug-in actually a great tool
so now sorts out Orcas is free and we
build down on our own plugins to find
for find Singleton's transaction and so
forth so and there is just stateless
with shared state like entity manager
nothing will happen but if there is some
stateless egb or request code see the I
managed bean with a single thing of
course with something happen but the
single things is singleton again okay so
um then what's also nice I always get
the question what's about programming
restrictions in Java EE we are not
allowed to start in threats threats and
this is just strange so the good story
is in Java is six stares at asynchronous
and timers both are great at
asynchronous you can you can start
threads which which are I would say not
transactional because what happens
behind the scenes is this is executed
service and how the execute of service
works you have a queue in a thread pool
what can happen the service overloaded
you know you you you are you are
starting over and over again
asynchronous methods they are queue up
the server dies and your tasks are lost
so the second the second part is timer
there's a quick hack or you can create a
single action timer single action timer
and a single action timer is persistent
so it works like GMS so at the creation
time it is taught in a central database
and and then next millisecond s is read
from the database and executed so with
timers you get something like persistent
queues without GMS
and finally in Java is 7 we have
concurrency concurrent carrots utility
source code concurrency utilities for
Java yeah yeah utilities and what you
can that you can really inject the
executor service directly the name is
manage executor service but it's
actually just inherits from executor
service and the nice story is it can be
configured within the application server
so you can start threads whatever you
want which are managed why we don't like
or why the applications that I don't
like to start threads with new threat
because what I sometimes I'm involved in
task forces and and I get an email head
as we have a memory problem so out of
memory exception and I would say more
than 50% of our cases they don't have a
memory problem they had a thread problem
so they cannot control the amount of
threats every thread consumes a certain
amount of memory so and and everything
blows up because they have did they have
not sufficient memory and this is
actually the problem where they have
because they start uncontrolled threads
and the non obvious thing is on Linux
you don't even see this
so these threats are not visible in the
heap so if you if you if you monitor on
Linux everything looks fine and you get
out of memory exception if you look if
you if you notice the problem are too
many threads ok done so what happens if
you violate programming restrictions
like this and the good good story is
actually nothing except your operation
set up the security policy properly so
what you actually can do you can set up
the security manager and you can prevent
the application to start threat I did it
on glass fish for a customer they wanted
this so if you would attempt to deploy
your application on the glass fish you
would get security exception so and now
also the funny story if you consider
Google Apps Google App Engine on all the
cloud providers they prohibit starting
threads as well exactly because of the
same purposes no one complains everyone
complains in eg bees for non complaints
in Google and Google App Engine so it
look and programming restrictions Google
App Engine very similar to eg bees which
bees we created 1997 and Google App
Engine I don't know five years ago or
something like this ok so no threats in
EJB is a good thing because usually you
won't be able to control the threats the
amount of threats
call it stateless versus stateful so
though and at the beginning of the
projects the mighty architect comes down
and say everything is stateless and goes
away so and and if I ask why because we
have to scale and in some Enterprise
projects we have like you know 30
employees the application server is able
to handle 100k sessions 100,000 sessions
and the itec is aware of scaling so they
define it the most funny experience I
had with that is there was an project in
Europe they they they were they were not
able to use stateful session what he did
is every method of stateless session
bean the first parameter was ID and on
the server they had an singleton with ID
the estate manager was the name and and
the value was the state so and they
built the whole state to state their
session beans and what they would I did
then this was j2e time ID compiled the
proxy and showed them this is actually
exactly this what happens with stateful
session winds just also no I did pass in
back and force the session so yeah but
we are not allowed to use stateful
session bean this is I would say
architect driven design or politics
driven design right so um what do you
sometimes stateful is beneficial what
stateful actually means is what is
actually stateful stateful means the
application server knows you
stateless means it doesn't know you
while we are still state we have JMS
cues we have entity managers of the
state but the state is user independent
stateful means the application server
knows you
if you prohibit to use state what
happens then usually the developers have
to save the state in the database and
now is the question why it's faster
because on each request you have to to
read and write from the base in a view
project we have even problems did and if
you think about this then the next door
is if you have problems in Java EE
usually the problem is the database not
the application server if you put
everything to a database it won't be
better you know it is inverse so in some
projects did the hard disk were too slow
to maintain the load so if you would
like to create
I don't know Twitter or Google stateful
is a bad idea for Enter
as for 700 clients it could work
perfectly and statehood is not easier
because we have a session scope or said
full size should be everything is there
and the state is lot smaller than you
would expect to avoid discussions what I
do in my projects we create out simple
stress tests with a be apache benchmark
or jmeter and we start plenty of
sessions 30,000 100k sessions whatever
until out of memory
shortly before there's a great tool
called Eclipse memory analyzer m80
memory analyzer tool and I think this is
the only Eclipse installation now
without plugins you can download it
really without any plugins just works
beautiful and you can load the the the
heap dump to memory analyzer and you
will see how big your session actually
is and then you can think okay now I
know my session is I don't know 10 10 K
500 K whatever we have 24 gigabyte in
production isn't a problem or not and
the only problem I'm aware of money is
due to another problem because recently
about 24 gigabyte RAM on Amazon it costs
me about 100 euro it's like I don't know
$140 or something like this and the
problem is just the garbage collector so
if you have more than I would say 8
gigabyte of heap you will have to
optimize the garbage collector ok so I
would say stateless or stateful what
works better I don't know we have to
test that but sometimes stateful is
order of magnitude more productive and
not every enterprise application is
Google Twitter or Facebook in my
projects we don't have any problems
because even this is very rarely even if
the whole department you use the
application server then we have I don't
know 300 concurrent users at once ok in
internet different story in enterprise
who cares if there is no number
employees than 300 or something like
this so the next story is what is
actually cluster so how much time do you
actually have 10 minutes right is it
right ok
AJ without clusters they all ask cluster
so in many companies we get classed up a
default and ask the question why they
need a cluster actually what is it right
and cluster does actually three things
and one thing is very useful and all the
other things you can you can
our optional I would say so um then I
think is with a cluster you can deploy
the application at once to different to
to multiple nodes this is nice
so you have one interface you're pushing
to all the notes and and you are done
this is actually nice without a cluster
you will have to have one row been
deployment or something like this so and
what Custer did are two things
clustering of stateful session beans and
clustering of HTTP session and provided
so-called smart stops for stateless
session bean what smart stops were is
they only worked for remote ejbs and
what it meant is you got you had an Java
client which got the stop and they
stopped knew the cluster view and with
some strategy a grow draw round robin
and random or whatever dispatch the load
to different cluster nodes this is
actually dead because no one uses remote
interfaces which are basics java 6 on
Java 7 anymore I would say mostly we
rely on wrestlers over WebSockets rest
in Java 6 and rest and WebSockets in
Java 7 I would say so this is this
doesn't matter so what do we have left
clustering of HTTP session in clustering
of egb state in most application server
they are very similar implementations
there's actually the same mechanism
behind both if you read carefully the
dock off the dock of most application
servers you will find out that something
like in-memory application you will find
the term most are replicated in memory
and what it actually means is they are
replicated asynchronously so so what it
means they are not safe you cannot rely
that a state state is replicated
synchronously because in memory
replication and JBoss WebLogic I think
website as well is always asynchronous
to make it synchronous you will have to
save the state in a central database so
your performance breaks down ok so now
my argument is if I cannot rely on the
session I not do not cluster the session
and I only considered the session as
transient state which is also meant is
just a cache so what it means in my
applications session could be the the
shopping cart and the customer will have
to lift that the shopping cart could die
so the they will have to read rock in
and that from the day one and say to
them okay this is afraid of if say no we
it has to be persistent then this and an
entity this is not this a persistent
entity and not session so if I have the
chance I always deactivate clustering of
stateful session beans edit HTTP session
because of the fact agreed then
I don't need actually cluster I can go
in production with shared nothing
architecture architectures we have
application servers which are not class
that and the only problem I have
provisioning then but usually you would
use puppet or chef to automate
everything perfect audience yeah no no
because no no no what audio you don't
have you have let's say glasses or
Jabba's or Tommy application service and
then you have a hardware load balancer
with session affinity so this is nothing
to do with this is just a network
infrastructure yeah and this is a AJ
yeah yeah but that you have to get it
anyway because it even happens usually
in usual infrastructure you have Apache
service or nginx then you have to load
balancer and then Apache talks to
GlassFish via mo JK or mod cluster so
the whole load balancing happens
actually before perfect yeah what I
meant
we don't need J to eat clusters
shared-memory this is us know for
instance GlassFish cluster could have
shared memory but you have to buy
coherence from from Oracle so their grid
and Jeb was very similar you could use
that but you have to use the infinite
span from J bus for instance there there
was never part of the clusters I'm not
aware of so you have always have to do
something for this and shared memory
have similar problems
tap theorem you know consistency
availability partition tolerance if you
have distributed you are already screwed
I would say right because you can be
even you can either scale or be
consistent everything you cannot be
distributed scale and be consistent at
the same time this is impossible if we
manage to do this homework we get Nobel
Prize right so actually pojos aspects
dependency injection and convention of a
configuration is actually Java EE this
is actually what what is behind and you
will think about this the convention of
the configuration means if you are
running on server we need pooling
transactions so you don't have to
configure anything and if you say j2 is
too complicated or Java is too
complicated you would have to do then
you would have to to implement something
similar with similar concept and call it
differently
lightweight container whatever right so
other any projects out there no because
all containers I know juice spring - are
very similar to Java it's always puja
with interceptors always the same so
also I do it until in five minutes know
if you have questions ask the questions
or we can who can just leverage all my
slides
what are many entities this is also an
concert which is misunderstood by
developers it means what I would I
talked before if you have an entity
manager and you access the entity
manager multiple times in the same
transaction you get the same managed
entity back and if you modify the state
of the entity you don't have to write it
back to the entity manager this is what
I see migration project from j2ee with
Daoist to java 6 how did the developers
operate is like find entity change the
entity and then merge it back it's not
needed the entity is managed it means
how it works in Java 6 find you get
entity back change the state and forget
it
commit me
means the entitymanager will will
compute the dentist for you and push it
back to the database and yeah this how
it works this is the concept of managed
entities and how it works behind the
scenes look 10 eclipsing in hibernate
actually they have they store all the
entities in a collection in a set this
is how it works and the set is called
unit of work okay so it's no magic what
happens during deploy it's trivial
during deployment the applications the
application server scans for annotations
and and searches and here builds the
metadata and that's something about
about this so this is a good one to say
oh now with Java EE everything is great
but j2ee was really slow and we should
do an experiment what I suspect is j2ee
was way faster than Java
the explanation is or at least j2ee 1/3
is faster than Java 1/4 properly
probably not in j2ee 1/3 timeframe -
whose JDK 1 - 0 soon now dynamic proxy
so what all application server did is a
deployment I'm the generated code and
you looked at the aspects there was no
reflection was generated code with the
with the event of of dynamic proxy all
application servers are now switch to
dynamic process means since j2ee 1 for
the dynamic proxies are using reflection
so if you think about this generated
code is always more performant than
reflection
so actually j 2 1 3 was faster than Java
is 6 or Java 7 but it doesn't matter you
know but because the overhead is
negligible this life theoretical talk
because right now we have problems with
IO database but not with 3 3 3 calls by
the way so I'm what is the performance
of an empty GB you can you can achieve
about 7000 transactions per second no
problem on my machine so there's
actually no event with Podger you get
nearly the same that the same the same
result and in worst case the the over is
about 1 millisecond actually recorded
screencast about this you don't believe
it you can watch it so ok so this is
also a good one this was a - GMS scale
and actually i had some fight with sun
engineer so what I did they created an
own Dark Star server it was based on
GlassFish
and they say okay we don't use GMS
because it doesn't scale we have our own
messaging aps like look there is nothing
in JMS which doesn't scale this is just
set of API so you can look on my block
on the comment from the Sun engineer
dark stays a better class which would be
a better Dark Star so this was their
posting through some fights between
their son engineering me and what what
there's our common misunderstanding is
is JMS is know about the protocol the
protocol is not standardized what just
standardized is the interface the cue
you could implement you know JMS with
UDP TCP IP or I don't know some miracle
technology that doesn't matter
and it could scale very very well in
fact at a netbeans day yesterday someone
someone wrapped hazel cars with GMS
would use GMS to communicate by via grid
so it would very good but I get the
question a lot
that's JMS scale is Jam is slow or not
and and the last project and one okay
but JBoss jebel does jabber 7 scale you
cannot say even this because in tables
you can switch the protocols you have a
JVM invocation layer you can use her
HTTP for JMS you can use TCP UDP you
cannot sell okay so JMS the problem with
JMS it isn't it not interoperable
between application servers because the
protocol is not standardized so we would
need something like aim to pure
something to stand out on the wire then
we can say ok that's aim compete scale
there's a different talk but JMS is like
say - GD bc scale who I don't know what
the database is behind the JDBC right ok
I get a lot of this question so you kind
of answer this it's just F the super
bullet also hard we JSF die or not so
I'm what also fancy right as our JSF is
JavaServer faces one of the features is
page flow and I'm asked a lot so we have
a single page application should you use
JSF it's ok
single page application shouldn't have a
page flow right because it will be
something wrong with that
so single page no Pedro it means if
there's no Pedro why to UCSF I mean what
is the benefit okay and also keep in
mind JSF is just a code generator so
what it means we have one tag and it
generates a lot of code
one tank the question is how much
control do you need in your application
in enterprise application if it's shiny
no one cares for consumer apps it has to
be you know the pixel perfect it's a lot
harder with with JSF right because of
code generation so in my eyes JSF is the
most productive tool for simple
applications the more complex the
application gets the more time you will
have to spend to understand the JSF life
cycle and also the generated code so and
for instance what I do in my projects
always we use just F for simple task
administration console always JSF and in
addition we expel expose our services
via rest because the chances are very
high that we get iOS Android or whatever
so you will have to you have to adjust
the rest interface anyway and then you
can also use html5 canvas angularjs or
whatever so okay so in my eyes SF is
perfect but if you need the total
control of the markup or you would like
to have responsive design for instance
almost impossible which SF because
there's nothing semantics in the in the
markup is just look up right but still
four simple pages I always use just F
because it comes out of the box and it's
very very simple to use yeah I mean
Cobra would be great but there's not
maintain anymore but I would always
prefer eremeyeva over soap you know as a
soap is like horrible ASCII I would say
right so um but yeah rest right now you
shouldn't use this because it's not
maintained and the implementation is a
little bit shaky of the application
service most applications that would
require you to deploy the application
server libraries on the client which is
very problematic and RMI doesn't scale
well well because of garbage collection
issues so I would say rest is the way to
go
there are no remote it should be
interfaces we should deprecated them in
Java I ate four it says so this is my
opinion princess right so and the last
one how to unit test Java applications
this I'll get a question a lot and the
answer is like a POJO
no difference unit test in mojito no
embedded application server I see
experiments like this starting
everything in
Maureen say why I'm doing this no no
answer right unit test is unit s single
method test starting application service
is forbidden in in my projects this is a
pointer this is the case of integration
tests which run after unit tests and you
can do it for specific use cases usually
unit tests are just testing of of
isolated piece of code if you would like
to test more I would suggest you to a
spin off the real application server to
script the whole environment GlassFish
jabba's or tummy just possible and just
a use blackbox testing with rest and
test the real application server because
the embedded application server 100% of
the time behaves differently than the
real one we have here now another class
loading you have other thread pool
settings everything is different so
don't rely on that not webdriver I would
not webdriver
I would suggest you to use graphene
graphene with our Killian is a wrapper
of selenium very lean and very simple
why we don't build a best of bits server
from scratch because we did it in 1997
and didn't work out so this was actually
my third so its Java EE only suitable
for the big enterprise actually not and
this is why this enterprise is a little
bit harmful Java is those simples you
can you can write you know guestbook in
five minutes so it's really nothing
behind so there's nothing and get more
and more requests actually for startups
for smaller companies so who would like
to be productive and I strongly believe
that Java is the most productive
platform out there everything guys you
would have to configure do whatever is
needed in Java it just don't go for it
wow I'm on time two minutes late so if
you have question then just ask me a
questions otherwise see you on Thursday
and Friday thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>