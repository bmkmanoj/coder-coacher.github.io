<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CON2960   Intro to Scala for Java Developers | Coder Coacher - Coaching Coders</title><meta content="CON2960   Intro to Scala for Java Developers - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CON2960   Intro to Scala for Java Developers</b></h2><h5 class="post__date">2015-12-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/3zivGwqQ9P8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everyone welcome I'm James Ward I'm a
evangelist at Salesforce so how many
people here have done Scala before okay
so for those of you have done some Scala
there's things in here that I just
learned like yesterday so I think you
will be able to hopefully learn
something even if you've been doing in
Scala for a while so this is an intro to
Scala for Java developers I've been a
Java developer since like 97 been doing
Scala for about the last six years and
still learning Scala so I thought it
would be fun to try to help others along
the way as well so let's start with just
a little bit of background why Scala and
then we're gonna do a lot of live coding
today so first why Scala I kind of look
at it as Java plus plus it kind of takes
the the foundation of Java and it adds a
bunch of new features a whole ton of new
features and we're gonna cover just the
tip of the iceberg today and then also
cleans up some some artifacts from the
past for instance there are no
primitives in Scala and that's actually
pretty nice so it lives on top of the
JVM there is something called Scala GS
where you can cross compile it to run on
a JavaScript VM this is gonna be focused
more on the Java side of things although
probably everything that I'm showing
today could be used in Scala GS but
never tried it so one of the nice things
about living on top of the Java
ecosystem is that you but you can build
on top of all the stuff that we've built
on top of Java in the past so all the
libraries in maven central all of the
stuff that you've built in the past you
can add Scala into that mix and so I
think that's that's a really nice
feature for Scala it's reactive out of
the box and this is something we'll talk
about a little bit later but as we look
around it one of the things that's
happening in our the way that we are
doing computing reactive is a big part
of that
no GS is is a good example of where we
see that really predominant
and then things like rx Java as well
it's a really expressive language so one
of the things that I found doing Scala
is that the code that I am now writing
is a whole lot closer to what I'm
actually trying to express than when I
was writing Java code there's just a lot
of kind of rigmarole to actually get
something done in Java and it's called
it's a lot more concise a lot more down
to what I'm actually trying to do and so
that makes readability a lot easier for
me when I have to go read through and
try to understand what my code is
actually trying to express so that's one
of the things I really liked about
writing in Scala and then the last I
think really important reason for Scala
is that it combines functional and so
there's other languages like closure
that run on the JVM which is a purely
functional language and I think that's
that's great and certainly has its place
I'm from the OU world and hadn't done
anything functional and so Scala was was
this bridge for me into this new
functional world and now I think that
I'm probably writing my code mostly
functional and a little bit of oo but
having them both be first-class citizens
and own language really helped me bridge
from where I was to where I got to and
maybe now I could pick up closure and be
productive with it but now I know and
know and enjoy Scala so so that's where
I am it's a little bit about my journey
into Scala it started with all the cool
kids are doing it
so many of you probably know of dick
wall who was part of the Java posse he
was one of the first guys I know that
picked up Scala and started using it and
I'm like well if dick thinks it's
awesome then I should probably check
this thing out so so I checked it out
and I started writing some Scala and
they call it Java without semicolons so
in Scala the semicolons are optional
usually and so so you can write
basically Java code in Scala and use the
same constructs same types of things in
Scala that you're used to in Java so
that's what I what I went to next and
one thing that really helped me along my
way was this library ecosystem around
Scala
there's sad to say it
but there's not a whole lot of exciting
things happen in the Java specific
travel language library ecosystem and
you look at things like like the Apache
Commons libraries and there's not a
whole lot of interesting things going on
there now don't mean to knock it there's
there's great libraries out there that I
use all the time written in Java but
where a lot of the new and exciting
things are happening is definitely in
Scala realm so some examples of that
play framework is a reactive web
framework for Scala and Java you can
actually use it with Java if you want
akka is an actor library that also has
you can do Java or Scala SPARC has a
really great Scala DSL for using using
spark which is a big data processing
technology you can use that with a Scala
DSL that's really nice so so some of
those languages are really what kind of
help propel me or not languages
libraries help propel me further into my
usage of Scala and allowed me to do some
some interesting things that maybe I
could have done by sticking with Java
but certainly a lot more kind of first
class when I when I moved to Scala and I
think it was about three years into
Scala I was finally like oh I kind of
get it some things actually started to
click some of the functional stuff so so
it I'm I think I'm a pretty slow learner
and also there's not a wealth of
beginner resources out there for Scala
so luckily those are growing and
becoming more prominent we'll talk about
those at the end but it took me a while
to kind of like make the mental shift
from the way I was writing Java to
writing Scala but I still don't get the
Haskell stuff so there's there's this
programming language that I don't think
I had ever even heard of until I got
into the scholar world called Haskell
and I think is a functional language
that does all sorts of crazy things and
there's a there's a contingent of the
Scala community that came from the
Haskell world and so they've tried to
rebuild Haskell and Scala primarily
through a library called Scala Zed and
whenever I see the Haskell stuff in
Scala I'm just like all right this isn't
the Scala I know like this is a whole
nother world of Scala and so there's
there's these kind of dark corners of
the Scala
unity that are the the Haskell folks or
do some really crazy like type level
programming stuff like you hear of
libraries called like shapeless and some
of these and so there's these weird
corners where I'm like I still have I
look at their code and I'm like I don't
have any clue what's going on here
so I'm still on a journey to learn more
about this stuff okay so that's that's
kind of our background I want to dive
into some code and actually write some
code together so that we can see what
Scala actually looks like so to get
started there's a couple different ways
there's something called activator which
comes with some nice templates there's a
whole template library that you can pick
from and so what I'm going to do is
create a new app to start from using
activator so you can just download that
from typesafe typesafe is the company
that backs scala along with EPFL
okay so let's create a new app here I'm
gonna run activator new and go out and
fetch the latest list of templates
there's a giant list of templates that
we could go browse but I'm just gonna
pick this number for one here the
minimal scholar one and it'll give me a
default name for that okay so now I have
a app here and this is a now a project
for SBT which is the a it's kind of the
de-facto build tool for Scala you don't
have to use it you can use maven or
Gradle or whatever you want but but this
allows us to specify dependencies and
run our tests and all that kind of stuff
so so that's our project let's take a
look here at what we have in our source
directory so that's going to use source
tests main Scala and then we have this
hello Scala so let's go take a look at
this file this is our just basic hello
world and this the code may not make
sense to you but you will understand the
this code once we're done today
and a whole lot more but to run this let
me show you how to do that we can say
activate or run and this will now
download the dependencies in this case
there's not a lot of dependencies and
then it will compile that class and then
run that class which is just a basic
static static void main and there we go
and we see our hello world okay we can
also run the test so if we say activator
test there is a test in there written
with Scala test I think and so that will
compile the test and then run the test
and then show us the output of running
our test so so that's that's all great
we can run this this app and and that's
kind of how typically when you're in the
skull world you'll you'll build and run
your applications but certainly not the
only way okay so that's how we get
started what I want to go through first
is is kind of an overview of some
features of Scala that I think are
really important for Java developers to
understand as I said when I started
writing Scala I I would write my Scala
like Java code and then I slowly learned
some of these concepts and they kind of
came painfully they came by kind of
doing it wrong and being told that I was
doing it wrong and and having people
review my code and and tell me yep
you're definitely doing it wrong and so
so this is some stuff that I wish I had
known about when I was getting started
and my I guess my advice to you if
you're trying to learn Scala like you
can write your Scala just like you write
your Java but really try to learn these
concepts and try to do scholar like kind
of the Scala way instead of doing it the
Java way and I think that'll help propel
you a lot faster than I was propelled
because I was just you know doing things
the wrong way for a long time and and so
so this is some of the the right ways I
think to do Scala so we're going to go
through each of these before we do that
I do want to open up the Scala repple
who here knows what a repple repple
stands for anyone
we read evaluate print loop there we go
cool yeah so rebels so Scala comes with
a rebel I think the Java is maybe
getting one in Java nine we can launch
that with this activator command by
running activator console and so now
we're gonna go into this repple the read
evaluate print loop and so now i can
just start writing some scala and it's
going to evaluate that scala and output
the results so so well that's what we're
gonna be using today to to actually go
through some of these ideas so the first
idea i want to talk about is
immutability honestly i didn't even know
what that word meant until her I would
started doing some Scala because I
hadn't really experienced this world of
immutability Intel Scala yeah you can do
it with final in Java but it's not
really a common way of writing code in
the in the Java world and so so
immutability what is it it is not it's
creating values that don't change
obviously we're not able to mutate them
and one of the the like really basic
questions that I had about immutability
was how do I write a program then if I
can't change anything and the way the
difference between the immutability and
mutability is that we change by copying
and that's how we can actually write a
program is that we create a value and
then we create a copy of that value if
we need to mutate it and the benefit of
all this is to really two important
things that i've discovered is one is
that code is a whole lot easier to
understand when you use immutable values
so in when I was in the Java world I
would use hibernate probably like many
of us and I would take a hibernate beam
and this beam would just get passed all
around this application and I had no
idea what was actually changing it where
it just was flowing through the system
and values were being changed on it and
I could if I had a bug that I needed to
track down like where did this value
change how did it change why did it
change like that's really hard in a
mutable system in an immutable system
it's a whole lot easier because the only
place where something can mutate
is when it's copied to a new value and
so whenever I hand a reference to
something and say here you go that thing
can't actually change that value so that
later when I'm when I'm working on that
value it's all of a sudden different
that's just not possible with
immutability so I like the way that
closure puts it they say that mutable
state is the new spaghetti code and I've
really come to understand the value of
immutability after writing code I can
actually look at a program and I can
comprehend the flow of how mutation
happens and with with mutable variables
it just is a whole lot harder to do that
and where it gets a whole lot harder to
do that is when you also factor in
concurrency one of the great things
about the JVM is that we have
concurrency and so so we can actually
have different threads mutating values
at the same time and so we can use
synchronized blocks and all those sorts
of fun ways to go single threaded on
particular mutations but it gets really
hard when you're in the immutable world
you never have to worry about that
because nothing no other thread can
mutate a value out from underneath you
so let's take a look at what this
actually looks like in Scala
so Scala does have the ability to do
mutable variables we do that by saying
VAR so if I say var F equals and then
let's set a type signature on here so F
equals a string you'll notice the type
parameter comes after and then let's set
that to a string so this is a mutable
variable in Scala and now I can change
this thing alright so I can set it to a
new variable that's the way we usually
do things in the Java world and I have
now gotten to the point writing Scala
code where I never use mutable values
any more it took me a while to get there
but because I had to rethink some ways
that I did things but now I never
actually use a bar anymore I probably
haven't used a var in a couple of years
so it certainly is possible to write
very sophisticated applications without
using mutable variables okay so the way
we do it in Scala for
immutable values is we say vow and so
let's call this one C and this will be a
string and let's set it to asdf and now
if I try to set this to a new value then
the compiler actually tells me hey you
can't do that you can't reassign a vow
to a new value that's that would be
mutation and that's not allowed on
values and so so I'd highly recommend as
you're getting in Scala just don't I
don't even use the VAR keyword don't
just totally like take it out of your
Scala vernacular there's there's just
about zero place where you're gonna have
to actually use them in a real system
the one place where I have Houston is
like I needed like for a demo I needed a
a basic cache like an in-memory cache so
I used a bar for that right but it was
just for a demo like any real real app
that I've built I haven't needed a bar
so just just wipe out VARs from your
Scala vernacular and and just write a
mutable code it but it will take some
some rethinking of how you then do
mutation in your programs and so
hopefully as we go through this you'll
see some other ways that you can address
mutation with immutable values okay so
immutable hugely key to to scallop the
next is type inference so one of the
things I really like about Scala is that
you can optionally tell write in your
code the type parameters and most of the
time the compiler can figure them out
and there's some times that it can't and
so you do need to tell it but really the
value of this is that code can be a
whole lot more concise I a lot of times
kind of name my my values I name them
what they are and so they don't
necessarily need to also have the type
signature in there so let's take a look
at back here at this code so I'm going
to say Val C and just set it to the
string and guess what the compiler
figures out that that's a string and so
you can see that the repple has said yep
C is a string
okay and we can do the same thing let's
do a vowel I equals one there we get an
int we could do it long we could do
double we could do a boolean right so so
this is this the Scala compiler is is in
first inferencing the types of these
objects based on their values and this
happens at compile time okay it also
does this on obviously more more complex
structures so if I have a list and I'm
gonna put some some in sin here then
we'll see that it is inference that this
is a list of int right and I would do
that if I put in a string into this list
then there we go we've got a list of
string so it's inferencing those now if
I tell it the wrong type so let's say I
say this is actually a list of int
you'll see the way we specify the type
parameters is with the brackets there
instead of the greater than less lens so
if I try to tell the compiler hey this
is a list of int but it is not a list of
int it's a list of string and the
compiler is gonna say that doesn't work
okay so that's that's really the basics
of type inference one one key thing
about type inference is that oftentimes
when I'm debugging a program the types
aren't what I expect them to be and so
then I start actually putting in the
types into my value assignments or other
places to actually give me a better
understanding of what the types are I
can kind of like set the expectation
like this is what I expect the type to
be and then I can get a better compiler
air out so but then I have to go and
remove those the those type declarations
once I get the code compiling because it
just clutters up the gut question back
here so a question
yeah so there are no primitives in Scala
you the Scala compiler will will turn
these into the right types underneath
the hood but but the actual types that I
use as a Scala developer now I don't use
any primitives but obviously it's
running on the JVM the primitives are
still actually there under the covers
yep yep same yeah as far as I understand
so and this all interoperates with java
with Java generics the same the same if
I had a list of string coming from a
Java library that would be a list of
string in Scala yeah yeah one more
question go
that is a weird naming thing yeah that
they chose to shorten in integer to int
but long and double and all those are
yeah I don't know why they decided to
name that one you know save like four
characters or whatever it is that is
interesting so I don't have an answer
for that okay so we're gonna move on to
functional so the the next really
important part of Scott obviously is
that there it's functional first class
as well as object oriented first class
and this was I think probably one of the
biggest mind shifts that I had to make
in Scala was moving from a world of
object-oriented to a world of functional
and it just took my brain awhile to get
this cuz I had always been an Oprah
grammar and so so let me let me see if I
can kind of walk through some of some of
the functional stuff to give you an idea
of how this looks so I'm gonna create a
function here and let's let's define a
function called F and it's going to take
a single parameter which is going to be
a string and then that that weird little
symbol there is saying this is the
separator between the the parameters of
the function and the body of the
function and so so we've got my
parameters this function takes a string
and now we're going to return something
and let's do like a length or something
right so you'll see that what I get back
what F is is is it tells us it is a
function that takes a string as a
parameter and returns an int so the
compiler actually in for inst those
types saw the s dot length is an int and
so now it knows that's what this
function returns you'll see that it is a
function one that function one means
it's a function that takes one parameter
okay
I think if we remove that parameter then
we should get a function OOP
we don't have an s anymore let's do unit
so you'll see now we get a function zero
because we take zero parameters unit is
it's nothing it's don't don't this is
about empty value basically so it is a
value but an empty value okay so that's
that's our basic function we've defined
a function that takes a parameter and
return something you could kind of at
this point look at this like a static
method it's I haven't attached this
function to an instance of a class so
it's not a method it is just this
function sitting out there but it's
actually something that I can pass
around it's a value it's a it's a value
that now I can pass to other things and
use just like any other value and so
there's another way to also define
functions which I'll show you I can
define a function using the DEF keyword
and then I can say alright let's take a
string and this function returns an int
and the body is going to be able to us
length so this is just another way to
define the same function that I defined
up here okay so now I have a function
that takes a string and returns in there
there is a slight difference in the
actual implementation of the first one
and the DEF one and it has to do with
when they're actually evaluated when the
body is actually evaluated I don't
totally get that I usually for functions
use death
so let's actually try to use this
function so to use it you're probably
familiar familiar with calling functions
so let's just call that that function
with a string and it's just doing that s
dot length and returning that value so
that's how we call that of course it's
all type safe so if I try to pass an int
instead of a string then the compiler is
going to tell me that's not a lot okay
so two different ways to define
functions as I said usually I use death
and these death function definitions can
also go inside a class and that would
make them bet
it's okay so now where it gets
functional so we have functions there
these first-class citizens but where it
actually gets functional is that
functions can take other functions as
parameters and this is where it gets
mind twisty is I have a function that
takes another function as a parameter
and so a really good example of this is
a list so I'm going to create a list
here and there's a function on the list
called map and map is one of the the
kind of fundamental functional
programming pieces because what map does
is it actually takes a function that is
going to go through each element in the
container so in this case our container
is a list the elements are 1 2 &amp;amp; 3 of
type integer and map is going to apply a
provided function to each of those
elements in that and then return a new
list with with the the modified ER the
different values there's probably a
better word for map maybe we could say
like transform each would be a good way
to put map it's it's transforming each
element inside of the container okay so
we need a function I think my function
takes a string so let's go actually
modify this list there we go okay so
we've got my list of some strings and
now we want to apply a function so let's
just use this F function so this F
function takes a string and returns an
int so now I can just specify that
function f there and run that and you'll
see that what I get back out the result
of that is a list of those lengths so
it's applied that function which is up
here it's applied that function to each
element in there so it's taking each of
those run the function on it to turn the
output and then wrap that back into a
list okay so that's that's map and
that's really one of the the key kind of
fundamentals of functional programming
is the but the way that we would do this
in the Java world is we'd like create a
mutable object right and then we do like
a for loop and iterate through these and
inside of our for loop we'd have the
logic to actually mutate and we'd be
building up a new list right and that's
I did that all the time in Java code and
the the what I've found with this
approach is that this is actually a
whole lot more understandable once I
wrap my head around it took a while but
just to say all right apply this
function to each item that's a whole lot
easier than trying to understand a for
loop that could be calling somewhere
else and doing something something else
so so that's really what this is for is
transformations right which a lot of our
code these days is just transforming
from one like Jason thing to another
Jason thing or from a database object to
something else so so it's come I you
when you get into Scala you start using
map these transforms there's actually a
number of different types of transforms
but you start using these functional
transforms a lot yeah question yep
yep
yeah
yeah good question so it's the same
exact concept it is in Java eight
streams it is applying a function to a
to each of the elements inside of a
container and in the case of Java 8 it's
really around streams so streams was
really the first place where Java built
in this functional concept into the core
library what you'll see in a little bit
is that this idea of map is not just on
collections in Scala and not just on
streams which there's different strain
streams and collections so it is all
through the standard library you'll find
math and so it's really for transforming
anything inside of a container so that
container can be a future that container
can be an option that container can be
like really anything and so so in Scala
it's everywhere but the nice thing about
Java 8 is that at least you do have it
now a core this idea core place in one
part of the standard library so once you
understand the concept there you can
apply it anywhere was that helpful
ok ok so we've got our our map now I
want to confuse things so so I provided
this function value there to this map
function and there's actually a few
different ways that we can do this so I
did it by just providing the reference
but we can also now write a function
right here inside of this this map
function so I can actually say alright
let's take my string and let's do s dot
length right here so remember how when I
did that Val I used that that funny
little arrow so this is the same thing
it's saying all right take a string
parameter and then return the string dot
link ok so that's just what we call an
anonymous function and if we run that it
should do the same thing there and so so
that's just putting an anonymous
function there so rather than
referencing an existing value we've put
we've we've just put in a anonymous
function there so then it gets a little
bit
more fun because we can also use this
this little short syntax here where I
can use underscore length and that
expands into this oh and you'll notice
that I didn't have to specify here the
type parameter on s because it actually
inferred it it inferred it based on me
doing a map on a list of string so it
inferred the type and so I didn't have
to specify specify it here okay so a few
different ways to to write and use
functions okay
I'm sure that's I hope that that seems
easy it it just took my brain years to
get my head around that that whole
concept of functions being values and
stuff so so hopefully that's helpful but
we're gonna move on okay so the next
important thing about Scala here is that
it's expression oriented so what this
means is that in Java we have a lot of
statements so for instance at the end of
a method you say return foo semicolon
and in Scala actually everything is
pretty much an expression there's a
couple things that are but but
everything almost everything is an
expression and so that means that almost
everything actually returns a value so
this is this is a bit different than
what we're used to in Java so let me
show you what this looks like so let's
do first a statement I'm gonna do class
foo okay that's a statement that didn't
return a value that was a statement to
the compiler about something now on the
other hand this is an expression you can
see that it's an expression here in the
repple because the repple actually
assigned it a value so res 5 i could
actually access or AZ 5 so that actually
got excited assigned to a value so that
was an expression so when i write a
function so let's go back to writing a
function here
let's not call it s so let's write a
function that takes a string and let's
do like Val I equals s dot length so in
Scala I don't have to say return I
semicolon some colons are optional you
can put them in if you want I don't have
to say return I the reason for that I
could just say I is because I this
expressed every expression gets
evaluated into a value and so now when I
run this this function here is he
obviously it works
I could shorten that by not even
assigning that Val I but but everything
gets every expression gets converted
into a value so you don't have to use
the return statement I think you can put
it in if you want but totally not
necessary so where this where this
really gets used the most often is in if
else if else is statement blocks in Java
and Scala if else is actually an
expression and so what I can do is I can
say Val I equals and then I'm going to
say if and let's use like what's my
example here let's just do if true then
we're gonna return SDF else
let's return yeah okay so that if else
expression actually became a value right
got assigned the result of that got
assigned to a value so if you want to
see it
with false okay
so this this changes the way that we
structure our code so in Java
you typically like have a mutable value
outside of an if/else block and then
you'd go into your if statement and in
the true condition you'd set that thing
outside of it and then in the false
condition you'd set that thing outside
of it and obviously that requires me to
both state you can't use that approach
without mutable state and in Scala
we have if-else as an expression and so
now we can have immutability we can have
that vowel that's actually taking the
the evaluation of this if-else
expression and signing that to a value
so that becomes really important for how
we structure kind of flow in our code is
using these expressions to assign
immutable values rather than doing
mutation inside of logic branching okay
so where this gets crazier is in one of
the really cool features of Scala called
pattern matching and pattern matching is
this this really really massive feature
of Scala like really massive I've only
touched like the surface of pattern
matching I see pattern matching examples
that I'm like that just totally blows my
mind I have no idea what's going on
there so I'm gonna try to focus on it on
the simple use case of pattern matching
where what we're gonna do is first we
need a little bit of setup I'm gonna
create a trait the trait is like an
abstract class and so let's create a
trick called blah and then I'm going to
create a class of foo which extends blah
and then let's do a class bar which
extends blah okay so now I've got these
two classes and let's create a new value
which will be a B and I'm gonna actually
put in the type here because I don't
want it to infer the type I want to
actually be a blah type and then I'm
gonna say let's create a new foo okay so
now B is a blah and
it's a instance of okay so now we're we
can use pattern matching one place where
we can use pattern matching is to
actually have a pattern match so that
when we will match on this B we can
actually have different control logic
depending on the type that's actually in
there so let's do B match and now what
I'm going to do is I'm going to say case
and we'll talk about what this case
means in a second but this is how we
define our pattern so I'm going to say
case let's do B : bar oh man I pick some
bad names for this bar there we go
okay so now you'll see I'm using that
that function a little I don't even know
the name for that thing equals greater
than and now I can can return something
this is my function body so I'm
basically defining a little function in
here and we'll talk about what that
actually is in a second and then let's
do one for foo so let's create foo and
but there okay so you'll see that when I
ran that B match and then gave it those
two cases then it went in and said hey
that that B looks like a foo which it is
a foo and so then it outputted foo now
if we try this on a bar let's let's go
try it let's go Rios on B to a bar okay
now let's go try this again
oh okay then we get bar obviously okay
so that's that's pattern matching based
on the type of the the object that I'm
matching on this is also an expression
so I could assign this to a value so I
could say Val whatever equals B match
right just like the F else but we'll
leave that so one thing that I didn't
understand until pretty recently about
about the match expression I want to
actually go over because I think it's
actually important understanding what
the heck is going on here
so there's something called a partial
function or a partial function there's
something else called the partially
applied function which is totally
different we'll talk about that in a
little bit but there's this thing called
a partial function a partial function is
a function just like you've seen before
but it only works on specific input
types and it doesn't work on other input
types so I'm going to create a partial
function just so you can demystify this
this code here and see what's actually
going on so I'm going to create a
partial function we'll call it P F and
this is going to be a partial function
and then the type is the input is going
to be any meaning I can pass anything in
to this function and then let's make the
output like a string here and then my
partial function let's define the body
I'm gonna say case case is how we
actually define a partial function so
case and now this is where I do my
matching so now I'm gonna say alright
case foo is the foo equals let's so if
we take in a foo parameter into this
partial function then let's return if we
doesn't have any parameter so let's just
return asdf okay so now I've got my
partial function you'll see it's a
function one so it takes one parameter
and now I can use my partial function on
things so let's try to pass in a string
into that partial function you'll see
that now it's the Scala compiler is
telling me hey you can't pass a string
into this function because this partial
function is only for things that
is only for Foose and the the way that
it knows that is that this partial
function actually has a method on it
called is defined at and then I can I
think I could pass in a foo like that
nope wrong way I pass in an instance
which I think I have a few somewhere no
foo equals actually first let's try to
just pass in a string because that's
what I did first okay so I call that
partial function is to find out passing
a string just like I tried to do earlier
and it says hey no that function is not
defined for that input value but if I
create a foo and then I say is this
defined at foo then it says true ok so
now what we can do is we can call PF foo
right and that that works fine so what
that match expression actually is is its
partial functions that are built up with
each other composed together and so
that's what actually is happening
underneath the covers here the reason
why this is important the reason why I
wanted to understand I wanted you to
understand that this match expression is
just a way to apply a partial function
to a value is that we actually use
partial functions in another place so if
I have a list and let's put into this
list a couple different things let's put
in an int a string and let's put in my
foo there's a a function kind of like
map on this list called collect and
collect it doesn't take a function it
takes a partial function so now I can
actually give it that partial function
that I defined earlier and you'll see
that what comes out of this list now is
just that the value that the parcel that
the partial function matched on so
probably picking horrible examples here
but you remember from up in my partial
function that if I found a food then I
returned a string of asdf and that's
actually where what happened there so
this this value it didn't match the
partial function so it didn't end up in
our result list this string didn't
either and so what happened was this foo
did match on our
function and then that partial function
applied to that foo and transformed that
foo into a string asdf and you'll see
you get a list of string out so so
that's that's kind of the
demystification of what that match
expression is doing this is it's taking
up a partial function or a composition
of partial functions and applying them
to a value and you can use those partial
functions anywhere else yeah question
partial it is a function that that only
applies to a subset of the possible
inputs yeah but different than partially
applied function which we'll get to in a
little bit yeah it's one thing I've
realized in the functional world is that
it's this whole other vocabulary that
I'm not gonna even say the words because
it just it scares me when I hear some of
the words used in in functional
programming because I really don't
understand them so it's a whole nother
vocabulary that's that's taken me a long
time to understand okay so that's
pattern matching really really powerful
there's a whole lot more features to it
than what I just showed you but it
becomes this tool as you learn more and
more about how to do it becomes a tool
that you just start using all the time
in your code to control flow through a
system okay the next one I wanna cover
is is the option type so this is also
something that's new in Java eight is
optional and so Scala has something very
similar called an option and so I want
to show you why options are important so
I as a Java programmer there was a lot
of code that would check for null
pointers and I would get null values and
then I would sometimes get no pointers
because I forgot to check for a null
value somewhere and in Scala one thing
that they tried to improve from Java was
to make it so that your code didn't your
code could express where things could be
knowable so wherever something could be
null let's actually put that into the
type system and so the way that we do
that is with what
called an option so I'm gonna create an
option here and I'm gonna prioritize it
with what it's an option of so let's
create an option of a string and then
this can either be a sum which means
it's not null or it can be a none which
is essentially no value or null so I can
assign that to none and then if I say oh
right still none if I can also say sum
and put in a string so sum and none are
extend from from option in it so so this
allows us now to express on the type
system whether or not something is is
optional so I use this all over the
place in my code mostly where it comes
from
input like user input so let's say that
you know I user submits a form on a web
page and there's a bunch of values and
and for some reason you know my
JavaScript check didn't catch it or
whatever but somehow they they sent me
an incomplete data set so I'm actually
parsing the input from a user I'm
actually going to assign those values to
options and then I can have code that
checks all right is this option sum or
is it none and there's and I can also
provide default values so let's check
out how we would do a default value so
right now I have a sum so I can say get
or else and then give it my default
value you'll see that now it returns
asdf because right now it's a sum but if
we change o to be back to be none then
run that again now you'll see that we
get our default value so nice thing
about this is that we have that no
ability expressed in in the type system
which is exactly what Java hate is doing
with what they call the optional type so
this this gets interesting because now
option is a container just like list was
a container and so option actually has a
map function on it as well so I can
actually say oh map
and I can say alright let's let's take
my string and let's just do to upper
case on it okay oh oh is still none so
well that's good to show so Oh was none
so that map function there was nothing
in the container so it couldn't
transform anything so it was still a nun
but if we go back and change Oh back to
a some try that map again now you'll see
that now what comes out of that function
is a sum of the upper case string that I
gave it so that map function just like
we saw on the list is just a function
that's transforming everything inside of
the container in this case it's an
option so there's just just one possible
thing inside that container okay so
that's that's optional values again I
use them all the time incredibly useful
for for avoiding null pointer exceptions
and expressing null ability in the type
system okay next up is case classes case
classes are really concise syntax for
creating value objects comes with a
bunch of features out of the box let's
just go create a case class so let's
define a case class called foo and I'm
gonna set a property on this case class
called name so now I've defined my foo
and now I can actually create instance
is this a couple different ways so I can
say let's create a new foo and give it
that string in the constructor so we now
we have our foo I can also do food apply
and give it that string in Scala one
little shortcut is if you see apply then
you can actually remove it and that's
still just calling the apply function
there and create enough food for us so a
bunch of features here oh one other I
want to show you is let's take our res
24 and there's a copy there's a copy
method on that food that was created as
part of the case class and this allows
me to now set new values so if I've got
this value object and I just want to set
one or a couple values on it I
now change those with the copy function
and now you'll see res 25 this new value
so all immutable but this new value is a
foo that now has that that new name
property in it so I could say res 25
name alright and there we get our R
value there so definitely a really nice
syntax for defining value objects and
working with them
okay that's case classes now I want to
go into one of the more complicated
parts of this is the the for
comprehensions so Scala has all these
little syntactic sugary things that that
are really nice and can help you to
create really concise code but they can
get pretty tricky so to show you the
four comprehension I first need to show
you the next level of functional
programming beyond map which is called
flat map so remember I have my my oh
right which is this option and there's
their memory I showed you that with map
we can transform that string inside of
this to another value well with flat map
we can also transform that thing inside
the difference is that the let's
actually try it let's do to upper case
on this thing so you'll actually see
that that doesn't work and the reason
for that is that flat map doesn't take a
function that that returns the the
returns the thing so in this case when
we did this before with map my function
was returning a string what it's wanting
now is it wants a function that returns
an option of a string in this case it
wants a function that returns the King
inside the container and so to make this
work I now actually need to wrap this up
into an option and so one way to do that
would be to say like let's create a new
some actually we need to assign this so
we're gonna create a new sum and then
we're gonna say oh oh dot to uppercase
okay so now that works and now our
function definition goes from a string
to an option of
right so the difference between map and
flatmap is really just on what does the
function that you're giving it return
does it return the thing or does it
return the thing inside of the container
and and so where this gets important is
when we get to composition functional
composition where things start to get a
little bit trickier but this is all
going to get a whole lot simpler when we
get to the for comprehension so let's
say that I have two options let's call
them o one and this is going to be a sum
with a string and let's do a two which
is going to be sum with another string
okay so now we've got these two two
different optional things and we want to
actually compose them together and what
I want to get is if either of these is
none or both of them are none then I
want to get a none but if both of them
are some I want to compose them together
into a single string and get like asdf z
xcv right so I want to do some some
composition of these two things so let
me show you how we'd write that first
one way we'd write that is we take our
first one and we call flatmap and we'd
assign that to a value and then in the
function body for this one we're going
to take our second one and we're going
to call map I'm gonna assign that to a
value and then we're going to inside of
this function take our oh one plus O 2
and now we're now this is our
composition so the reason why we need
flatmap is because remember this map
function returns the the thing inside of
the container so when I run this o to
map what it's going to do is return an
option of string and I can't run map on
an option of string so that's what I'm
getting back from this function as an
option of string but I can't run map on
an option of string because n I get an
option of an option of map so what I'm
doing instead is I'm climb flat map
which can kind of be thought of is
there's another function called a
flatten and it and then the map so it's
a flattened and a map together it's
actually a map and a flatten so it's
doing the map and then it's doing a
flatten to flatten those those option of
option out into a single option so now
now that should all work and you'll
that we've got our some if I have sign
OH - to none instead and try that again
then we still get a none which is what I
want I'm composing these options
together now yeah question
flatten means take the thing inside of a
container inside of a container and make
that inside of just one container is
what flatten is doing yeah okay so now
let me simplify this by showing you the
really cool syntactic sugar that Scala
has for dealing with this it's called
the for comprehension and the for
comprehension I can say all right let's
assign oh one let's pull that out of the
oh one container let's take you out of
the Oh two container and then let's
yield oh one plus o2 okay and I think oh
two was still none so let's go make that
sum again so we can well you can see it
worked it just wasn't very exciting so
we've got a none let's try this again
with two sums back up to that one
oh no stress again for okay Oh Oh - just
gonna write it plus go to you there we
go
okay so that was doing exactly the same
thing so the Scala compiler is actually
turning that for comprehension into that
flat map and map it actually do flat map
flat if I had more expressions inside of
the for comprehension ever do flat map
flatmap flat map and then on the last
one it does map just so that we can do
that composition that you saw earlier
okay so that's for comprehensions really
really powerful part of the language to
create this really concise syntax around
composition really is what this is for
okay reactive I'm not going to talk a
lot about reactive today because it gets
really deep really quick but let me just
give you a quick little example all the
web applications that I build now they
they make like ten or a hundred web
service requests Jason you know rest
requests out to a bunch of services they
aggregate all the results back and then
they do some transformation on that data
and output something different that's
like almost all web apps that build now
are doing something like that and what
in our typical Java world every time we
make a request we're actually blocking a
thread for the entire duration of the
request in the response and that's
pretty inefficient what we'd like to do
is be able to make a request and then
take the thread that was allocated to
that request D allocate it and then when
the response comes back get a thread
back and then do it so we're just trying
to be more efficient with the resources
that are available in our system so what
I do now I build reactive web
applications I will make as many
requests as I can in parallel that will
use the number of parallel requests that
I can make it once depend on how many
threads I have available but those
threads are only being used when I'm
actually actively using a connection so
instead of just blocking all these
connections up and using a bunch of
threads and using a bunch of extra
memory really what I've done with
reactive where I use it most is with
reactive
a sink and non-blocking i/o where I'm
not blocking threads unless I'm actually
actively transmitting data over that IO
channel a lot of this is built on top of
neti which is a great Java library on
top of Java ni o so lots of different
tools out there for doing reactive rx
Java is a great one in the Java world
for Scala Scala has built-in futures
there's also the akka actor library that
I mentioned Play Framework is a reactive
web framework so lots of different
things if you go to presumes word comm I
have some recordings and slides of
presentations I've done unreactive where
I'll go into a lot more detail so check
that out
okay I didn't want to spend a few
minutes talking about some of the things
that I've stumbled on along the way with
with Scala and then while we'll wrap up
in a couple minutes so the first one is
multiple parameter sets so when I define
a function so let's define a function
that's one parameter set and I could of
course put in additional parameters in
here right
but in Scala you can actually do
multiple parameter sets so I can
actually say put in here two different
parameter sets for this function and
let's return a string and now I'm going
to do s dot substring and give it that
high okay so now I've got a function
with two different parameter sets if I
click try to call this function with
only one of those parameter sets it's
going to tell me hey you can't do that
you need to specify both and you'll see
the really kind of funky syntax there
for specifying the second parameter in
that in that function so now that should
work your substring starting at one so
this is something that just threw me off
forever this idea that I could have
multiple parameter sets where it gets
tricky with this is that I can actually
create a new function that that takes
that partially applied function and uses
it so I can actually say Val F equals s
with that first parameter
and then we do this weird syntax where
we say that and now I have a new
function one that takes an INT and
produces a string so now I can call F
with that parameter so this gets tricky
it really threw me off the whole
multiple parameter sets the place where
you see it most often is with implicit
s-- implicit SAR something that is one
of the more complicated I think are
harder to learn parts of Scala implicit
so let me just show you how they work so
let's say that I have this this function
here that takes that into in the second
parameter set if I if I mark this this
second parameter set is being implicit
now what's going to happen is I can
actually use this function and not
specify that second parameter set
because I can have it filled in by
something in scope that fickt that fits
the type there of that so if I try to
call this with just the first parameter
it's gonna say hey I couldn't find an
implicit value but if I now define an
implicit plus it Val I equals one let's
do 3 this time right so now I have an
implicit Val
now if we try to do that again then
you'll see that yep we just ran our
substring three characters in on that
thing and so what the compiler is doing
is it's looking through all of my scope
to try to find something that matches
the type of that implicit parameter I
can also still specify explicitly if I
want so where this get this gets used
all over the place in Scala definitely
can be can be tricky for figuring out
like where in the world did that thing
get filled in from so it's definitely
one of the more challenging parts of
Scala but the I think the primary reason
why it's there is that you can get this
really concise syntax for that only has
the stuff that's important to you at
that that call point there
in the code so it's kind of a nice thing
but also can be can be tricky okay
here's another tricky thing that threw
me off if I have a list and I put in
here two different types of things
you'll see that what I get out is a list
of any and so the Scala compiler says
hey it goes up the type chain and says
the thing that I could find that was
similar between an int and a string is
any it's at the top of the hierarchy the
type hierarchy and so it just says
alright you must want a list of any and
almost never do you want any it's so
this is where like your composure code
just all just isn't working right or
isn't compiling right and a lot of times
it's because you've tried to use stuff
to different things into a container
like a list and there and it gets up
inference to any and it's almost never
what you want
kind of a bad default in Scala okay so
the one way to avoid this is when we
create our list let's be explicit and
tell it what our type is and then the
compiler is going to tell us instead of
converting it to an any it's gonna say
hey you know you can't put an int in a
list of string okay so that's up
inference to any objects in companion
objects I'm just going to talk about
this real quick you can use this keyword
object to define basically static a
static class or static methods in Scala
the work gets really tricky what really
threw me off is that these objects can
have the same names as classes and then
it depends on the context that you use
them in if you're talking about the
object of the class if you're using an
instance then you're talking about the
class if you're using it if you're just
calling a method without any instance
then you're using the object so that
definitely threw me off and let me let
me show you where this gets exposed in
the Scala doc you'll see that Oh in the
Scala doc and that see that o is for
object and the C is for any they have
different methods on the object and then
on the class and depends on your context
when it uses which so that was
definitely something that was that was
tricky for me
okay operators operators are just
functions but they threw me off for a
long time in fix I'm gonna skip that one
because it's it's tricky and nasty just
look up in fix and arity one it's one of
the trickier parts of Scala that always
throws me off okay learn more there's a
really great Coursera course on
functional programming by Martin or
darsky there's this really good
neophytes guide to Scala the Twitter
Scala school and Bruce heckle wrote a
book called atomic Scala that's really
great introduction to Scala
so that's your further learning
resources sorry I ran out of time I'll
be up front and back if you have
questions so thank you for coming I hope
you have a great job one thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>