<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Serverless at Oracle | Coder Coacher - Coaching Coders</title><meta content="Serverless at Oracle - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Serverless at Oracle</b></h2><h5 class="post__date">2017-10-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/EPhF-__p0Sk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">morning folks welcome thanks for coming
so this morning we're going to talk
about
at Oracle I'm Tom Leggett and this is
Owen Cliff we've been working on a
service platform that you may have seen
announced at the keynote announced and
open sourced at the keynote yesterday
called the FN project and today we're
going to give you an overview of
Oracle's thinking around serverless and
we're going to demo the FN project by
building from the ground up from nothing
a scalable reliable fault tolerant
application that does something that
might be or might not be interesting a
quick show of hands who's heard of the
term service evil you were or the
keynote yesterday right who's actually
used a service platform whether that's
lambda or cloud functions okay so fewer
of you and who has any service
applications in production running okay
one person two people yes before we get
started the standard safe safe harbor
disclaimer we're going to say some
things that are future-looking and don't
make purchasing decisions etcetera
etcetera okay what is service I'll let
you into a secret there are servers lots
of them sometimes storage to networking
gear all of these things the point is we
don't want to have to care about them
anymore a service platform will abstract
the infrastructure from you the beating
heart of a service platform is a
functions as a service this is a
functions as a service and the function
is a simple piece of code that does one
job well it takes some input often on
standard in and it produces some output
usually all standard out and we're not
talking about functions in the
functional programming sense of the word
here these functions can have side
effects and do more interesting things
so these functions are then deployed as
a single unit as code into your
functions as a service platform and this
platform then deals with provisioning
the infrastructure scaling up your
function per request scaling down it
deals with resilience reliability
billing security
and it has to do all of this a huge
scale and in any language or platform
that you that you care to mention a
farce is not the only thing that you
need to write an app in a Cerberus
architecture though you also need at
least somewhere to store your state and
you need a way to stitch together all of
these small nice nicely architected
independent parts that you've got into a
coherent whole into a flow that makes
sense for your users one of the key
attributes of a service architecture is
that it enables you to write code that
scales without having to write code that
scales your your by adopting a server
socket architecture your app will scale
organically per request and not just
seasonal slow seasonal changes in demand
that you might get from might expect
from a retail business but sudden
dramatic changes in demand that you
might see from your app going viral on
social media for example another thing
that the service platform will provide
for you is isolation for your code so by
writing small functions you're keeping
your keeping your code isolated from
each other and your your functions as a
service platform will provide secure
isolation of your functions from each
other and from other people's functions
running on on that code smaller equals
easier to deploy and easier to manage
and easier to secure one of the key
things though about serving us that we
think is the most important is that
serverless is a code centric paradigm
it's all about it's as much about
providing a really great developer
experience and enabling you as
developers to focus on solving business
problems rather than writing loads of
code to handle infrastructure and
scaling and and so on you won't have to
understand about infrastructure at all
anymore that said there are some
economic benefits to to adopting a
server
architecture which we believe are going
to have some fundamental impacts on the
way we develop software over the coming
years so that the two primary drivers
are that you don't pay anything whilst
your codes not running you don't pay for
idle time so you only pay while your
code is executing and secondly when you
do pay you're paying in sub-second
increments typically today this is 100
milliseconds you pay per hundred
milliseconds that your code is running
for RAM consumed by your code and we see
that getting more and more granular as
time goes on the the combination oh
sorry before I move on to the
combination there are some secondary
effects so by by abstracting the
infrastructure you as I mentioned you
can focus on writing code to improve the
lives of customers instead of managing
infrastructure it's lets your developers
be more efficient on on solving the
problems that matter to you secondly
because we're splitting everything up
into nice small composable units you're
fast can pack workloads much more
densely than just using VMs or
containers alone and this enables better
utilization of the underlying hardware
and therefore we can offer a better
price performance and finally complexity
is moved into the platform and handled
for you
for example the auto scaling nature of
affairs removes the need for developers
to write lots of boilerplate scaling
code and understand the infrastructure
we think the combination of sub second
resolution billing seamless scaling and
small reusable functions will change the
way we think about software engineering
as the tools and practices catch up to
working at this fine grained resolution
the financial impact of badly written
badly behaved code will become obvious
to developers immediately and developers
will just stop using those those badly
behaved libraries or work to improve
their performance characteristics we
think there's going to change the way
developers write software in the current
years
okay so what is what is FN the effing
project is an open-source functions as a
service platform it was announced by
Chad yesterday in the Java one in the
Java one keynote you can download and
run this today so I encourage you all to
go to FN project dot IO or our github
organization you can download and run
the code today
it's very easy to get started as we'll
see shortly really open yes really this
isn't a straight up open source project
it's an Apache 2 licensed with
governance influenced by cloud native
foundation a cloud native foundation
governance we're actively seeking
outside collaborators and in fact I
think we've had some external pull
requests already on our on our github
since announcing yesterday that said
Oracle does have engineering teams
committed to working on this we've got a
we've got a really exciting we've got a
really exciting roadmap over the next
few months that we're really we're
looking forward to implementing in the
open and I get hub and this is not an
open core play we're not holding back
anything for ourselves or for Oracle
what you see in the github organization
will be what we're running in our cloud
service when we go live later this year
or early next why are we doing this
we're not doing this out of the goodness
of our hearts it's our belief that by
offering an open source solution we can
offer the best possible developer
experience it unlocks a it are not an
awesome local developer experience which
we're going to show you shortly it
enables you to contribute to the project
if it's if it's not heading in the
direction that you want you can engage
with us directly and
and may take it in the direction you
want but as I said mainly because it
enables an awesome frictionless
developer experience and and we don't
think this is anything that our
competitors can match okay
the that's fine the the the other things
we're announcing as part of the effin
project awesome Java support obviously
we have got unit testing support which
offers a high fidelity simulation of the
environment that your your functions are
going to be running in when you when you
deploy them this is going to let you get
good confidence in your code before you
before you get anywhere also some API is
to help you with pulling in
configuration and secrets and some
really nice default type coercion for
formatting and serializing your input
and output from the input and output
from your your functions but it's not
just Java it's a polygon polyglot
platform out-of-the-box today we have
runtimes for 15 or more languages but
because the f-m platform is based on a
docker layer underneath which we give
you full access to it can run any
platform or any tech stack that you
conceive this is actually a really nice
feature because you can use any docker
containers that exist today and there
are hundreds of thousands of them in
docker hub as a function and call it as
a fast get all of the nice serverless
capabilities we also announced yesterday
F and flow which addresses the work flow
problem that I mentioned earlier on this
framework and server helps you stitch
together these small functions into a
coherent fault tolerant hole that you
can reason about and code in one place
more on that later
alright enough of me talking we are
going to do a demo
and show you some code I just want to
tee up the demo scenario first so we're
on the same page we're going to we're
going to implement a travel agent API we
are a travel agent business we've
partnered with someone who's going to
provide our flights booked our flights
for us someone who's going to book our
hotels for us someone who's going to
book car rentals for us and someone
who's going to send emails on our behalf
now because we wanted to partner with
the best in breed of these providers
across the industry
we've picked we picked the best flight
provider they provide an SDK in Java so
we're going to have to integrate in Java
with our flight provider for our hotel
booking provider they provide an awesome
Ruby SDK so we're gonna have to use Ruby
to integrate with those guys similarly
for the car rental and the email
provider in know Jason Jason so what
we're gonna do in the next few minutes
is we're going to develop some functions
some independent small pieces of code
that book and cancel flights hotels and
cars and send emails respectively and
then we're going to develop a trip
booking function which is going to which
is going to be able to book all of those
three things securely and reliably by
orchestrating work across the other
functions that we've just written
okay so first up we're going to develop
a flight booking function in Java so we
have the FM CLI installed here you can
go to F and Project IO install this
today FM start is going to start up a
local development server this is exactly
the same server that we will be running
in our in our cloud there's there's
nothing there's nothing different or
slimmed down about this this is the
industrial grade server so you've got
two already got a really high fidelity
easy to start local development
experience next we're going to create a
directory to hold on you hold on you
function and then we're going to run F
and in it we're going to specify the
runtime as Java and this is going to
generate some boilerplate for us which
looks like this
it's generated a HelloWorld function a
test for it and this funky ml file you
can see at the top of the screen if we
have a look at the funky animal file we
can see it contains a bit of information
that tells the F and Platform about how
to invoke our function so here the
runtime that the F and platform is going
to use and a fully qualified class name
and method on that class that the
platform will invoke when the function
gets invoked okay so this have a look at
the code the the code the boilerplate
code that's generated is just the Java
that you know and love there's no
there's no new frameworks to learn
there's no libraries to import this is
just this is just plain Java here you
can see the handle request function that
we referred to in the funky amel takes a
string and returns a string and returns
a friendly greeting when it's called we
also have unit testing support so out of
the box for Java today we ship a UHA
unit testing rule which provides a high
fidelity simulation of the effin
environment this is great for a really
rapid local development cycle and for
incorporating into your CI and CD
systems so we can see we can check that
our code before we've gone anywhere near
deploying it we can check that our code
is doing what we expect however it's
also super easy to deploy our code and
the FM platform has before we can deploy
it we need to create an app in the FM
platform an app is simply a collection
of functions that you can use to
organize your your app into one coherent
whole so we've created an app called
travel and now we're going to deploy our
function our booking function our hello
world function to the travel app and
that's done so this is this function is
now deployed to our running FM server
the effing platform incorporates a
lightweight HTTP gateway so each
function has a an HTTP endpoint that you
can use to call it you can you can do
this using the F and call CLI like so
which is just a wrapper around curl so
we can also call our function like so of
course so far so good
we've written our first java function
what have we what have we just seen what
have we just seen can we go back to the
thank you what do we just seen so we've
got we've got an we've got excellent
local development experience that starts
with a J unit testing rule for that
really rapid iteration to make sure that
you don't you don't drop out of the zone
as a developer whilst you're coding then
we've got a local deployment test a
really high fidelity you're running the
same server locally if you want to that
you can run in that we're running in the
cloud environment and then deploy in
testing cloud because we're leveraging
docker underneath and docker layers
we've minimized the amount of data that
we have to transfer in order to deploy
your application so even when you're
deploying to the cloud we've still got a
rapid cycle there so this is all aimed
to make a really awesome developer
experience for Java and other languages
it's just Java right you didn't see any
you didn't see any other imports any new
frameworks to learn any new libraries
this is just the Java that you know and
love today okay let's make this function
do something a bit more interesting in
order to book a flight we're going to
need to have our function its accept
some input and we're going to have we're
going to have we're going to decide
we're going to choose to use JSON 2
input as an input into our function
and point three I think you know one
point two oh here we go
yes so we're going to choose to use it
Jason as an input to our function so
what we're going to do is describe is
create two pojos two plain java objects
here that describe that match the format
of the jason that we want to take so
we've got a flight booking request which
is going to be the input for our
function which contains a departure date
in the flight code in reality we'll need
a lot more information but this will
work for the purposes of the demo and a
flight booking response which is going
to just return a confirmation code back
to our user for for now we're just going
to return a canned confirmation code
okay so if we have a look at so we've
got some we got a sample request that we
can make to this function so you can see
in this jason maps to the pojo that we
defined earlier on and similarly for the
booking response so if we deploy and
call this function
we can't just call it without any we
can't just call it without any input
because it's now expecting a properly
formatted input and in fact it would
return a nicely formatted error if we
were to call it without input but here
we're passing in our sample payload
which we showed you earlier on and we're
getting back our confirmation okay again
again it's just Java we haven't done
anything we haven't done anything
special here or had to learn any new
anything new this is just the Java that
you know and love the default input and
output type coercion z' that you've just
seen try to do the same thing for json
formats this is actually using jackson
behind the scenes so you can use the
full power of the jackson annotations or
programmatic api's to tweak the
formatting to better meet your needs and
that's one of the tenets of our java fdk
function development kit is that it's
unobtrusive where possible but
extensible when needed so you can
customize the behavior of your function
to suit your needs okay let's make our
function do something a bit more
interesting
so what we what we're going to do now is
have our function consume consume
configuration we've created this
configure method and we've annotated it
with the FN configuration annotation
from the FD K this will get called once
at the beginning of a function
invocation and it will get passed to
content I'm context that you can use to
get configuration fraud to your function
configuration or secrets to your
function we're also going to now use our
the SDK that was provided by our airline
provider instantiate that and provide it
with the with the endpoint and the
secret that we need to authenticate with
that URI and we're now going to call our
client to book a flight with our airline
provider and instead of returning a can
response we are going to return the
confirmation that we get from our
airline so that the confirmation code
that we get from our airline provider so
again this is make visit this is making
the point that this is just Java you can
use any third-party libraries that you
want in any way that meets your needs so
when we build and deploy this function
and we now try and book a flight using
it instead of getting the canned
response we will see
that's Oh configuration so that was my
fault before we can call this function
we now need to provide the configuration
to this function and we can do that on
the CLI at the per function level we can
do that on the CLI at the application
level or we can do it in the funky amyl
at the function level so here we're
providing the secret that we need to
authenticate with this with this API at
the via the CLI and the URL via the
functional so now when we call this
function we can see that we get a
confirmation code back from our airline
provider now I let you into a little
secret base we're not really booking
flights because this would get very
expensive otherwise we have we have a
set of fake a api's that that connect to
this dashboard and this dashboard then
returns a response back to our function
so here you can see the request that was
made to our airline partner that
includes the flight code the departure
time and the secret and and the
confirmation that was returned from this
from this provider
okay so what have we seen flexible
configurations still just Java you can
pass config into your functions and
retrieve using a simple API and you can
use third-party libraries as usual
okay so net so we've developed our first
function in Javas you've seen how super
simple it is we haven't had to do
anything unusual or complicated here and
we've leveraged some of the power of the
FN function this this function will now
deploy and scale and run in production
assured you want to what we're going to
do now is demonstrate some of the app
level capabilities of the FN platform by
deploying the rest of our functions in
one go so we've got a bunch of functions
that we've written that do the the
flight that do the hotel and the car
booking for us they're written in Ruby
and Python we're now going to do a f'n
deploy all you don't need the area and F
and deploy all and this is going to scan
the local directory for all of the
functions and it's going to deploy them
all into the app specified in the app
Adama so here we go we're built we're
now building and deploying our other
other eight or so functions we're going
to make sure they've got the right
configuration and secrets if you look at
the effing routes command now we can see
that we have functions deployed and
ready to go for booking car rentals for
booking flights for booking hotels and
the sending an email
okay in the next part of the demo we are
going to as today we've just seen in the
next part of the demo we're now going to
stitch all of these fungal of these
small individual functions that we've
got together into a coherent app for
booking trips what what we'd like to do
what we'd like to do here is book a
flight and a hotel and the car rental
for the user and we'd like to do so
reliably and at scale and handle any
edge cases or error conditions that
occur from our from our various
providers so this has to deal with
downtime in our partner api's it has to
deal with full flights packed hotels and
empty car rental Lots
so this workflow or composition problem
is actually a general one that most
cerberus applications we have once they
reach some level of complexity there are
too naive approaches that we might we
might have a go at the first is to write
a blocking function fir'd for
orchestrating your trip so you'd call
the flight the flight you wait for the
response block on the response and then
you'd call the hotel booking and you'd
wait for the response and you call the
car rental booking and you wait for the
response this might be easy to
understand but you'd lose a lot of the
nice characteristics of running a
service platform first of all this this
function is consuming resources for the
whole time that it's running but most
importantly you it's very difficult to
make this reliable if that main function
were to die or or an encounter an error
you then have to get into the case of
dealing with partially booked trips
through through a separate workflow and
function and cleanup okay so the next
approach we might think the next naive
approach we might think about doing is
chaining one function after the next so
we might have the flight function
directly call the hotel booking function
directly call the car rental booking
function this works okay but it quickly
becomes a maintenance nightmare because
all of your upstream functions have to
know everything about the data required
by your downstream functions
making changes to that can become very
difficult dealing with errors becomes
very complicated in that model and
fan-in or joining on the results of
those functions is very difficult so we
get to the point of needing an external
orchestration or coordination service
that can call your functions pass data
down the call graph and deal with errors
in a sensible way in the past this has
meant people or some other external
workflow DSL and today the answers from
places like Amazon and Microsoft are
step functions which amount to the same
thing in JSON but with a Chinese visual
programming front-end this approach has
several issues that prevented its
adoption the first time around and we
think still apply today so first of all
not every approach Maps well not every
problem Maps well to this state machine
approach and actually mapping your users
workflow into a state machine and
dealing with all of the errors can can
be quite complicated and dealing with
errors in this in this is a nightmare
you quite often end up having to have
steps chained off every function to deal
with errors testing is really difficult
because you're going to an external
system debugging is almost impossible
because these workflow systems are
opaque and not in your control you end
up having to own and run and manage and
operate their service that's doing the
orchestration and workflow for you and
you also end up writing a lot of glue
code that takes that takes the data you
need out of the result of one function
and formats it for consumption by the
next function so you end up with an
explosion of the amount of code that you
have to write and lastly most
importantly it's a whole new set of
tooling and processes and languages to
learn which take you outside of your
what you know and love and quite often
our
XML or Jason so enter effin flow this is
a this is a first-class part of the of
the function of the effing platform
they'd occurred to us that Java already
had a mechanism for composing
asynchronous functions the completion
stage API introduced in Java rate and
improved in Java 9 provides a really
nice type safe promises like API for
composing a graph of asynchronous
functions computations and it gives you
control over concurrency parallelism fan
out fan in error handling and provides
you with a bunch of distributed
programming primitives that you can use
to describe your user flow so we thought
what if we could use this API or
something very like it in our favorite
language which is Java of course to
compose serverless functions so we wrote
a we wrote a service which we call the
completer
which you can check out on our github
today that can store and trigger the
execution of these graphs of functions
it's part of the FM platform it shares
the same scalability and reliability
properties and we open sourced it
yesterday along with the rest of the
rest of the FM platform so there's this
complete a service backs an API in our
Java fdk there's almost exactly like
completion stage that you can use in
your java function today to reliably
compose other functions ok hopefully
I've made the case for why you need
something like this let's take a look at
what it looks like
okay so I'm going to create a new empty
function using F and in it and we're
going to and we're going to and we've
we've emptied it from all the
boilerplate and renamed it something
sensible
so each function executes in the context
of a particular flow you get access to
this flow from flows current flow and
this provides a bunch of methods that
you can use to start doing some work in
this flow we're going to use the invoke
function to call another function on the
plat on the F and platform in this case
our flight booking function and this
function can be in Java or in any other
language that you care to mention we
also have to tell invoke function what
type we expect the result to be the
invoke function returns a flow future
object which represents the future value
of the of this function call once it
completes the flow future object its
that itself then contains some useful
methods for chaining more work after we
onto the result of this function so
we've got things like then then combine
then compose then apply that we can use
to do extra work once we've got the
result back from this function okay so
let's let's invoke and let's deploy and
run this function it's not gonna do it
do anything particularly interesting it
should do exactly what the what the
flight booking function does what we're
showing you here is really the first
step to building a flow so when we call
our trip we have we are providing we are
we as our user we're providing
information about the flight we want to
the hotel we want and the car rental we
want we're going to call that into our
trip and we're going to see that we get
and you a new request to book flight
function as
spected all right so far so boring let's
let's make this do something a bit more
interesting so what we're going to do
here is use the then compose operator on
the float future then compose takes a
lambda which takes a takes the result of
the previous computation and returns a
new future so this lets us chain work
together so what we're going to do is
chain the hotel booking function on to
the end of the flight booking function
and we're going to chain the car booking
function on to the end of the hotel
booking function here's one he made
earlier and then at the end of the flow
we're going to use the when complete
operation which lets us check the which
lets us give us access to the final
result of the computation and an error
that we can check if an error occurred
either one either the result of the
error will be now what's interesting
about this code is that because the
results of all of the previous stages
are still in scope when we get to our
wanting to send our email we can simply
use those results to compose our email
to our users without having to do
anything special to deal with fan-in
okay so when we deploy and run this
function and call it with with the
sample payload that we saw earlier we
will see a call to the flight API a call
to the hotel our hotel provider and a
call to our car provider and finally
we'll send an email to the user which
contains if we have a look at the body
of the email that will contain all of
the confirmation codes from each of our
individual polite providers so here
we've collected the results from those
individual function invitations into
into one result at the end
okay so we said we were going to make
this a fault-tolerant app what if one of
our what if one of our providers is
unable to meet our requests let's say
for example that our car provider has
run out of cars in between our user
searching for the car and pressing the
book button by the time we make the
request and we know this we've already
booked a flight and a hotel and got
confirmations back from those providers
so we need to introduce a compensating
transaction that will then cancel the
hotel and cancel the flight and this is
this is an implementation of the saga
pattern for those of you that are
interested so we're going to use the
exceptionally compose operator on the
flow future and this only gets invoked
when an error has occurred at some point
in your flow and it lets you put it lets
you handle the error in any way that you
like right so you could use that to
retry you could use it to inject a
default value you could use it to alert
operators whatever makes sense for the
for the failure at that point in your
user flow in your user flow we're good
we're going to use it to implement our
compensating transaction which will
delete the delete the other bookings in
the case of a failure so what we're
going to do is configure our car
provider to have an error our car
provider is having a having a bad time
booking a car this time when we run our
function we can see that we successfully
booked a flight we successfully booked a
hotel but we failed to book a car this
causes us to then try and cancel the car
cancel the hotel and cancel the flight
and finally we'll tell it we'll send an
email to our users to tell them that
something went wrong at this point I'd
like to introduce the flow UI so this is
an experimental user interface that we
can use to visualize the different steps
in the flow it's a it's a live user
interface so you can
see the flow evolving as it's happening
time is left to right obviously and top
to bottom is rough dependency order and
you can see in the column on the right
hand side the pending events that the
platform knows those are going to happen
in the future when we encounter a
failure we we get a red bar and we can
see the detailed logs not just for the
stage that failed but we can see all of
the stages that preceded that for that
failure
so we know exactly how we got into that
state this is super useful for debugging
complicated failure scenarios and for
generally finding out what's going on in
your in your flow okay and finally we're
going to implement we're going to show
some retry behavior so what would happen
if our car API were down altogether we
need to need to really make sure that we
cancel that that car so if the car API
were down and we we couldn't cancel the
car we want to retry that so what we
have in the retry class is we've
encapsulated some exponential back-off
behavior what's really interesting about
this is that we're just using the
capabilities of the flow platform
exceptionally compose delay and then
compose there's no there's no special
support on the server side for this by
encapsulating well-tested retry behavior
into into a class we can keep our main
flow code clean and we can implement
complicated higher-order behaviors once
and share them between our different
flows so now we're going to simulate a
complete failure of our car API by
having even the cancel endpoint return
an error too and what we'd like to see
happen at this point is our flow
retry the canceling of the car so we see
successful flight booking a successful
hotel booking a failed car booking which
causes us to try and cancel the car
cancel the hotel and cancel the flight
but we will now Reese we will now see
the car cancelation retrying looking at
this in the flow UI we can see that the
platform is dealing with the with
scheduling the retries no resources are
being consumed whilst we're waiting for
those retries to occur those callbacks
are being implemented by the complete to
service so what we've what we've
developed here in the in the in the trip
function is a is a reliable scalable
function that has got some there's got
some really quite complicated fault
tolerant behavior and we've done this
all without leaving the comfort of our
favorite language and favorite IDE it's
all in one place in Java that means we
can reason about it in one place and
that means we can test about test it in
one place
FM flow in Java has actually got some
really good unit testing support as well
we've run out time to show you that
today unfortunately ok so what have you
seen today you've seen me you've seen
the effin platform you've seen how easy
it is to get started from from nothing
including running at local development
server you've seen how easy it is to
write small reliable functions in Java
and have the platform deal with scale
deployment and infrastructure concerns
you've seen that it's a flexible and
open platform it's not this is not just
Java the Java support is first-class and
awesome obviously but it's a because
it's a flexible and open platform
because we rely on docker you can make
it do what you need it what you need it
to do and finally you've seen F and flow
which provides a bunch of disk
muted programming primitives that let
you build scalable reliable fault
tolerant applications in one place from
the comfort of your favorite language in
your favorite IDE no more programming in
large globs of Jason or Yammer or XML so
stay connected come join us at the
DevOps corner downstairs where we'll be
demoing the FM platform all afternoon
we have hands-on labs tomorrow 8:00 a.m.
and 12:30 p.m. come along and play
give-give the FM platform test drive for
yourselves to see how easy it is to use
and get started follow these links for
more about our sessions this week follow
us on Twitter I'm Tom neji's due to
Lewis come I'm going to be hanging out
in the DevOps lounge downstairs on the
build booth if you if you've got any
more questions come along and come along
and talk to us thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>