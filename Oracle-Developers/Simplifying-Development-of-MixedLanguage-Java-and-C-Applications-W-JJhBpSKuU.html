<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Simplifying Development of Mixed-Language Java and C++ Applications | Coder Coacher - Coaching Coders</title><meta content="Simplifying Development of Mixed-Language Java and C++ Applications - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Simplifying Development of Mixed-Language Java and C++ Applications</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/W-JJhBpSKuU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Mitra Zarkov and my
co-speaker name is Patrick o drafts of V
represent the Oracle Solaris developer
tools organization today we will be
discussing how to simplify development
of mixed language Java and C++
applications during our session you can
interrupt me Orbiter with questions but
I would recommend postponing any lengthy
inquiries until the end of our session
so I will write in mixed language
application which for example call
native code from Java Chris our session
you will learn must know techniques of
mix development you will see that
sometimes it is complicated process we
will demonstrate how the studied Studio
IDE which by the way I did Peter I
develop in that surprise can help in mix
development can help in code creation
and editing and also how easy is to
debug mix language application with our
IDE also I will say just a few words
about the Sagara studio and will
highlight a few most important features
of the ID during the live demo video
debug a real mixed codebase we will try
we will try to find a real error
introduced somewhere and mixed code
intentionally or maybe not intentionally
also we will you will learn of oracle
support for the c++ 11 standard and how
you can leverage some of the powerful
new features in your application so what
is a mix development in real estate
development it might resemble something
like that it's illustrated on the
picture when two different architecture
styles get mixed together in a software
development of course it is a mix of
programming languages in our case it
will be just Java and C or C++ Java Java
objects can be used in native methods in
the same way as Java object or Java uses
them
that the sovereign's can be created in
Java göransson can be created in native
and open the main application is just
Java and native course occurs somewhere
across Java code but of course the
another situation is possible when
native application can call Java simple
data types can be easily made between
Java and C++ there are mapping tables
for simple types for complicated types
like classes some special efforts will
be required
what are you use cases where you might
consider mixed language development for
example if your application can be
written entirely in Java when Java
standard library or Java API can't
provide required portion origin it could
be the case of platform specific
features or even hardware features also
by the way the standard Java library
uses native calls pretty intensively for
example to support sound or file input
output capabilities the next use case
you probably have an existing native
code base which is for some reason
problematic to translate into Java maybe
because of complexity of the native code
maybe because of efforts you can
estimate for this challenge and then it
could be easier just to adopt the native
code base so that it becomes available
from Java also you probably have a
legacy binary like library or an
application which you can translate to
Java maybe you can't even touch it
because of license restrictions or
whatever or again efforts and then you
can try use this native library as is
from Java actually I can give you a real
example from my previous work some time
ago actually very long ago
I was developing mobile applications for
the initial Orion I started from Paul
and Pocket PC devices somebody remembers
those all platforms
okay maybe uh thank you I not only what
they told so we created a set of native
libraries cross-platform doing doing
various stuff for example one was for
sound support where a sound processing
like slow sound and OGG format support
another one was for text output and
supported languages like Arabic and
bi-directional text and whatever else
and three have been polishing those
libraries over years and they worked
quite fine but then when those legacy
platforms disappeared until you've got
Android and iOS devices we realized that
we still needed functionality because
the modern operating system can't
provide to us all features required and
then we started thinking what it would
take to rewrite those native libraries
into Java for Android or maybe into
objective-c for iOS and it turned out it
would be very costly because it's both
poor development that especially for
testing and we eventually decide to use
them using them as is and it worked
quite quite fine in fact still working
fine so I can say it was a wise type of
the decision the final use case when you
might consider mixed application is when
you have to deal with time critical
tasks then you may try callin a native
method accountant on there presumably
better performance sometimes you can
really benefit sometimes not because you
may guess that call a native method
brings its own overhead
and JIT just-in-time compiler is also
pretty fast thing so it's questionable
there are a few techniques used for mix
development we will tell you about the
two of most common j'ni Adrienne a there
are other tools and that your chief
approaches enumerated here but they are
out of the scope of our presentation
maybe later I will just say a couple
words about generator
the first approach you review is Jia ni
Jie Java native interface this is a
programming framework a part of JDK so
you don't need anything else like a site
library to develop is j'ni and now we
will see how to create a very simple
Jana application I have the slide
describing some steps but we think it
will be much more interested to see the
selection in our idea
so Peter will show you ok I'm going to
show you how one can create general
application in the Solaris 2d idea first
of all we obviously need to create a
java application yes I will we'll name
it java application gni because it will
use gen ID technology and yes this is
the simplest java application you can
imagine and in typical scenario i will
write some algorithm in java and in
places where the native code should go
through a coup for some reason i will
introduce new native methods in that
case i the algorithm would consist only
from one function call i will name the
function foo and now i'm going to
introduce it
okay
so now I'm probably should run that
application to ensure that symbol foo is
not dependent yet and yes as you can see
in console
we've got unsatisfied link error which
means that Java machine didn't find the
symbol fool now at that point in most
cases I have to do some steps to create
a special code which is intend to tie
Java and C++ together and then implement
the logic of method foo with an ID I can
just ask it to generate Jen a library
project I can specify project name
project location and full collection
which I would like to use and to compile
my librarian
so that project which idea created for
me is by the way already configured so I
can build it and it can contains two
files one his header file which was
generated with the special tool Java H
which is a part of GDK and an ID also
generated the default implementation of
home methods from that header file as
you can see that this is the
implementation of java method foo and it
is empty so this is the default
implementation now I'm going to switch
back to Java and load that library by
the way I think that in the next release
we will insert that code here tomato
clear but now I have to have to load it
manually at the name of the labor
library is the same as the name of the
project so so it is a CPP general
library and I think it's worth to
mention that my java application the our
project was altered as well in order to
be able to load with library actually
that means that that runtime variable
was added to VM options so now I can run
that application and as you can see
there was no exception so that program
works but of course we cannot be sure
that yet that pool was fault
because you know it did nothing so now
I'm going to add some meaningful
limitation into it and the next feature
of an ID for mix development is
navigation from Java directly to native
code so I can with a simple click jump
to the definition of that method it
works in the same way as you probably
get used to use navigation
in the pure Java or C++ code so now I'm
going to print here for example hello
message so I shouldn't do it well it
find that file and steady
so you note
okay now we need to recompile it library
and rerun the java application and as
you can see in turns all it printed
hello message so everything works as
expected by the way that feature
navigation from Java I suppose was is
can improve significantly to the
development process because you know
when you are discovering the new for the
base which uses Java and C++ you might
be tired of jumping from jail to C++ and
to navigation it is really the simple
process so now I'm going to switch back
to the oh yeah of course the great the
greatest feature of our G is the color
tips so we can see the the color of
those steps is different because yeah
the color mean the color distinguishes a
file with files which are from different
projects so that file has one color and
it is inside my java application gni
project and CPP file has another color
and because it belongs to another
project
okay now I'm why I mentioned coloring
here is because later when a BL debug
the mixed code it could be sometimes
problematic to detect where you are in
Java or negative and these colored tabs
actually can help you to understand
where you are okay
so let's make a short summary about gni
so the ID helps greatly with Jerry night
project creation and makes it actually
easy but anyway you could see some
so-called glue code that does not
contribute any useful functionality and
if I refer to the previous slide you
could see some
range keywords like Draenei expert jane
i call also the native method signature
is strange because it is mangled all
this makes the code unclear hard for
region also it is our problem
imagine if you need to change a native
method signature you have to change both
c or cpp and header files and then a
recompile everything again or you should
run all the process again which could be
especially complicated if you don't use
the ID into that manually by the way it
is in our plans to support this type of
refactoring they mixed code in our IDE
maybe the next version also the downside
of the gni is that it requires some
experience not only with the framework
itself but also is native development
because much will do just at native site
at the same time it gives good
flexibility and control of what is going
on during native calls and actually
developer is responsible for things on
nature side type conversions also occur
and negative side that means good
performance especially if compared with
the next approach we will review also if
your C++ code is complicated like if you
use HDL containers then Drina is very
good option for you in order to get ID
support for gni you should install
special mix development plugin here i
should say that it is a very fresh think
actually I recently developed this
plugin but it is already available on
the NetBeans if you go here and try
search for mix development it will be
the top result but you should install
the development version of NetBeans
oscillator studio because it is it would
work only in development area because it
needs some approval etcetera etcetera so
later it will be available just from the
IDE when you go to the tools plugins you
can just
Nabal it and use also when solaris to do
12.4 will be released in a month or so
it also will be available there okay
the next approach we will review is GNA
the GNA is Java native access it is a
site library available on a github if
you use journey you don't need to write
any gni in your code the wikipedia says
that Jenny is design aims to provide mix
development support in its natural way
with a minimum of effort let's see
whether it's really true again I have
the slide with steps but Peter will show
you this in action yes actually we have
two already prepared projects for
demonstrating GNA because we cannot
still create JN a java project using
your c++ interface because you know you
can use generator for that maybe we will
the great date that tool a little bit
later maybe even in the next release
that depends on priorities but okay so I
have two projects one is the simple
library dynamic library which in fact
introduces only one symbol it is
function sum function and I have a gen a
project Java project which uses
technology GNA and calls that function
from Java code in order to do that you
have to introduce special interface
which will extend which which should
extend library interface which is a part
of GNA library and then you have to load
that native library of course it can be
done in the same way as for J&amp;amp;I but you
have to use special GNA class native and
after that you need to describe symbols
which you are going to use as you can
see in
the simplest cases as I have here that
declare the description of an interface
looks very natural so in fact the
Declaration of symbol some function
looks exactly the same as in c plus plus
that is that should bring convenience
for you in simple cases so now I'm going
to run that application to see what it
would print and as you can see it prints
that answer is 42 we can ensure that the
return value of some function is 42 by
navigating to the definition of some
function it works here as well as for
J&amp;amp;I and now as you can see they turn
value is somewhere inside the Macra
answer which in turn contains of two
other Marcus's base and shift and
finally each should evaluate to 40 plus
2 so in fact the answer should be 42 now
I am switching back to the presentation
okay cool
let's make a short summary about the JMA
so it is really easy think it doesn't
bring much glue code it doesn't require
any development experiment experience
because you don't need change your
native code and this is I think one of
the major advantage of the j'ni so you
can use it with existing binaries and
you don't need to change them so the
question is why we wouldn't always use
GNA jen86 responsibility for giant Java
and C++ code together and for type
conversions too
that means that type conversions occur
just in Java they bring some negative
performance impact also if your C++ code
is complicated like again if you use
some STL containers in your code then it
could be very problematic to support in
GNA so let's finally compare
two approaches we have reviewed so GNA
is easy in theory but you just could see
that is already Jane I approach is also
easy so I'm freaking and now I like this
table much more if you have the existing
vine that is a GNA would be a better
option of course we are all brilliant
developers and we can make so that G and
I also can work for existing binary but
in this case there is a workaround you
should create another native library
which will be between your library which
you can touch and Java so possible but
of course more complicated if to use GNA
which doesn't require that Jana is
faster because of type conversions at
native site also remember about meat and
c++ experience and cases when your
cheapest pass code is complicated then
Jane I is preferable ok that was all
about mix develop in theory I will say
just couple words about the Solaris
studio in Solaris to do ID and why we
would highly recommend to you using
these tools for your development tasks
so the style studio is a development
tool suite delivers the latest in
compiler optimizations multi thread
performance and powerful analysis tools
for best applications performance and
reliability technically salary Studio
consists of the compiler suite which is
a native language compilers debugger at
performance library all also analysis
suite
and finally the IDE this light will
intend to describe a very basics about
the ID I think we should bypass it I
just will mentioned that ok each ID has
its own benefits like better fit for
particular platform
flexibility of science variety of
plugins available integration
capabilities with
our tools etc etc sometimes it might be
just a waste key feature your favorite
which keeps you this particular ID for
many years right but often it is nothing
more than just a matter of habit okay
this slide I will probably stay here for
a bit longer because it is a very very
typical question for us so what is the
difference between NetBeans IDE and
Suresh Studio IDE hopefully it will be
clearer after my explanation so the
NetBeans is an open source platform this
is a generic framework for swing based
application and the Solaris to do ID is
really based on this platform but
NetBeans is also an IDE which is similar
similar visually to the Studio IDE and
we the Solaris to do team contribute to
so-called Sindhi part which is the past
past native development of the NetBeans
technically if you take a look on this
picture there is an evident common part
which is a generic idea that the
saggital itself and told the integration
environment also the version in support
native languages support so this is a
common part NetBeans has some more
programming languages available for
example Java Python or PHP and web Pro
tanto and we just studio in its turn has
its own components like studio compiler
debugger created by studio team it
integrates some work on software like
which I for example is for Oracle client
for a DBMS support also it integrates
advanced tools like katana either
performance analyzer and threatened
eliezer
but in fact you can get all these
NetBeans languages in your IDE in your
studio ide if you simply enable though
them as a plugins so I can say that
Studio IDE is FX tense then happens IDE
but in that means you can get of course
all these to do components also I should
say that studio releases are usually
most stable because they I built only
unstable NetBeans platforms same to
NetBeans you can download studio ID for
free but if you need support it is paid
next slides intend to demonstrate really
briefly a few ID highlights so even
though we designed for Oracle Solaris
Oracle Linux and Red Hat Enterprise
Linux the IDE can also run on other
popular platforms like butta Mac OS or
Windows in fact it can run on any Java
aware platform but you can't use on
those platform the other studio
components like compiler and debugger
and you can use available tool chain for
particular platform so we support for
example new GCC gdb in total chain or
LLVM used by Apple or Google or Adobe I
think one of the most important quality
value for an ID is its capability to
handle really huge code bases at that
the ID should not just work somehow but
provide good response time and require
either the more memory we spent
significant put significant efforts to
address these concerns and new in new
release and succeeded now you can load
in ID the code bases of such huge
projects like oracle database server
code base and mozilla firefox' code base
you can see how large they are because
they have very early thousands of files
and millions of code lines that the ID
requires only one at half of gigabyte
with oracle database server code base
and mozilla fits below a gigabyte of
course the numbers are much more
interested when Ziya compared with the
tool we can compete with so we selected
eclipse and tested it against the
firefox code base and as you can see the
studio ide is about ten six times four
at that it requires about same memory at
its peak load may be the final
outstanding feature I would highlight is
remote development so you can run the ID
on your laptop with any client operating
system we support at that your project
is is local but you debug and track your
software once your operating system
which are Solaris or limits ok now it's
time for demo guitar please the next
feature for mix development is the
debugging capital pop capability of
mixed code to demonstrate that I have a
game it is called minesweepers very
known game I believe and the only
problem is that that game contains a
mistake so the very first uncovering
make me win the game
of course that ruins the whole interest
in the game and I cannot play it on my
workplace and that that makes me upset
so I need to debug that application in
order to find where the bug is it may be
in Java code in C++ code I think that I
can explain briefly the structure of
that application the Java code is used
for UI part and the logic of the game is
implemented in CPP so to interact to
access the native code Java uses special
class it is called it its name is
minesweeper proxy that class introduces
six methods to to access native code and
as the error occurs only after the first
uncovering I think it would be logical
to place breakpoint somewhere inside and
how a method for now that application
uses GN I proxy so I am going to place
breakpoint inside realization of func
our methods
inside gen-i proxy now i'm going to run
that application in debug mode and i'm
clicking on the very first cell and now
we are staying at that line where I
placed breakpoint to ensure that the
code the bug is somewhere inside native
code I can see what what is the status
of the game as you can see in the
tooltip of the statuses win it is
obviously a mistake because you know the
very first and our cannot make me win so
I'm going to hit with breakpoint again
and as you can see the uncover method is
the native gni method so typically at
that point I have to run native debugger
find the java process among other
processes attach the debugger to it run
another one to for observing for
discovering my native code but with an
ID you can just a printer and iron
method don't pay attention to that
warning kids say that IP address is not
configured that's because I'm using
VirtualBox so now we are staying inside
the native me at attempt I believe that
in a 10 G person can even not notice
that this is a native code because you
know the debugging process looks very
similar similar to Java debugging
process you can observe variables you
can do everything you might expect that
debugger allows you to do you can step
over instructions to print instructions
and as you already noticed their process
of switching debugger sees quite
seamless so the problem actually occurs
in that method because it returns game
status and it
yes only three return statements and as
we I think remember the return status
was the wind status so the problem
should be somewhere inside the check
victory method I can ensure that by
using another one useful feature of
debugger it is called expression
evaluation I can ablate here any
expression for example function call as
you can see it returned true which
cannot be plausible because you know we
haven't uncovered the the very first
cell yet because the actual uncovering
happens inside that call so I'm going to
step over that call and step in to
directly check victory method let method
returns the return value of that method
is all uncovered variable which
obviously should be true if all cells
which do not contain minds uncovered and
by default it is true and the this
lambda function which is by the way a
feature of C++ 11 standard should make
it false if there is at least one
uncovered cell I can place breakpoint on
that line and on red line to ensure that
we will not hit that break point yes as
you can see the mistake should be
somewhere inside lambda function but it
is very complex I cannot understand that
if condition so probably I will use I
will use JIT we have some system to to
revert maybe one commit which probably
introduced red bug
okay first of all I can see annotations
and that come it affected on that line
so I can see the comment to that commit
and it says that that committee
introduced the bug I can ensure that it
does not have changed other lines by
giving it to previous commit and as you
can see that's true
there they go on the one change so I can
just rework that commit the only
difference was that false parameter so
now I have to rebuild an application and
library so it always evaluate I told the
expression natural false of course
because it was and now I'm going to
rerun the application again to see that
my change fixed a year and yes as you
can see now the game is fully I can play
the game which is playable I can enjoy
it
so okay that project was intended to
demonstrate debugging capabilities by
the way I my actually I do not I didn't
need to restart the application I could
just apply the change to it but for some
reason I rebuild the pol application and
that was probably the last feature
related closely to the mix development
and as if in our abstract we have bolts
about C++ 11 standard I probably show
you something from C++ 11 and maybe
other useful features of an ID as for
C++ 11 standard I have one sample which
contains some useful features the first
feature is the keyboard out which has
different meanings in different contexts
for instance in that context in the
decorator of the function it means that
the return type would be specified at
the decluttr of the function that might
be useful if you are going to introduce
template method which with the return
type which depend on template parameters
in that case I can use parameters of the
function into type specifier that really
might be useful if you have such
template function in that case such new
style does not have any sense so don't
use it in that cases in other context
outer keyword means that compiler should
deduce the type of an variable by itself
and as you can see the IDE also knows
for example that variable LEM has method
get value so it can deduce the type of a
LAN
in and that outer keyword is inside
there for YouTube it is another one
feature of C++ on insta standard it is
very similar to Java for each loop but
it is called arranged for loop in C++ so
yes another one feature is those two
keywords the first one again has the
same meaning as the final keyword in
Java it means that I cannot rewrite that
get value function in subclasses and
another one has the same meaning has the
annotation have a write in Java so I
read function get well you should have
you write at least one function I mean
exactly one function from the base class
those features are very useful because
in previous standard you actually
compiler didn't check that inheritance
you know inheritance chains for you and
now we can force compiler to do that so
another one very useful by the way at
also notations mean the mean that those
classes or functions have IP rights for
example if I click here I can navigate
to both implementations of that method
in both structures and the same works
for that annotation but it'll only get
me to the classes by pressing on the
green annotation I can get to the super
method another one very useful feature
of C++ 11 is very attic templates
actually not really complete they call
they have another name template
parameter parts if I recall it right and
I think I shouldn't explain what that
means because you have to be familiar
with meta programming in C++ to
understand that but
why I'm mention that feature is that it
is heavily used in the new STL so to
provide decent code resistance for the
programs and IDE should understand that
feature and as you can see our G can do
that for instance I have here a meta
expression which is the similar singular
with that boolean expression as you can
see that expression should evaluate into
true because you know all parameters of
it are true and you can check that met
expression using for example navigation
I can navigate to the value and as you
can see the value of the field value is
true it is not an accident because you
know if I would change some parameter to
false I will see that now it never gets
to false so another one feature another
one feature of an IG but it is not
related to the C++ 11 standard is macro
evaluation it is very useful feature
because you know some projects boost for
example uses markers weary intensively
so to understand what is hidden under
the marker call my mate can be difficult
for you but with an ID you can ask it to
evaluate let Macra and on the bottom of
the scheme you can see the code which is
hidden under that microscope of course
you can navigate to those functions for
example everything works as expected
another one feature is probably which I
use frequently is is so is Cobra if you
have C++ code which uses a lot of calls
you can ask IDE to build Co graph for
you
and you can you know expand some notes
to it another levels to the kold-draft
we can by the way change layout you can
change it manually and of course you can
navigate to some methods if you want so
that might be useful and I use that
feature rather frequently I think that
that is what I'm going to show you and
that's all
okay thank you very much that was cool
I will make some summary of the mix
development support an IT because it is
our waistline of our presentation that
makes development right so again the IG
helps you from a very beginning like
project creation I remember the ID
created the pre-configured native the
library project for you at that it also
tuned the original Java project as well
so that they are compatible also and
yeah it was possible only why a simple
right-click on the Java class that's
really amazing also when you have the
mixed code you can easily navigate from
Java to native just wire clicking on the
methods and it works both for Jana and
ranae and maybe we will add other
approaches and people support them if
there would be a request oh yeah yeah
but for now it's June I Jenna also you
get a very handy editor features which
work both in Java and C or C++ code and
finally when you get an application and
if you need to debug it the ID comma
comes up with a very seamless debugging
process so as Peter just throw it to you
you sometimes couldn't even notice where
you are in Java or a native at that you
get all this usual debugging
functionality like breakpoints step into
it set
by the way as full-stack you in when you
are inside native foot you will see only
a native pole stuck maybe and actually
in the next release we probably will
merge jump and native posters okay this
slide just describes a few highlights of
new 12.4 studio release service the new
release you will get all these nice
things and here you can see the mention
of our ID which is tuned for large
applications this is information about
other sessions of our organization so
for example the next session is going to
be tomorrow I think that is so that
concludes our presentation thank you
very much
now we will open for for questions so
please if you have some yes of course
you can open it the assembly window and
actually if you don't have quote it will
be open automatically and you can debug
the assembly code I know that works only
for native code you probably don't need
to dissemble bytecode please
so the analysis tools are integrated in
the ID unfortunately because of time
limitations we couldn't show them to you
but we have their dedicated sessions for
the analysis tools I'm afraid that one
was already happened yesterday yes oh
yeah well so I'm sorry so yes so we have
all these tools separate and also
integrated in the IDE so you can use
them there sorry yeah yes they are
generated into the IDE and you can see
their warnings in native question the
performance analyzer is another tool
that is that provides good support for
mix development because it just this
tool opens the stack of all calls when
calls I mixed the native and Java and it
is very convenient to see and to
determine which each time you exactly
expand in each particular method with
its native or Java it's really very
convenient tool
you cannot
work that I'm using
assembler method I think that yes you
can do that because you know we can
write not in assembly language the
library which will export the function
and if it meets certain requirements you
probably can do that
I actually but it is not a part never
did it it is better part of the support
memory provide for mix development so so
we support only Java and C or C++ an IDE
maybe it will work and for seven decades
I do ever you can check in some tell us
I think that you can
and the way
question I ever I think you're
addressing
you know there's a fundamental
difference here
you get around that
you're talking about
yes
that
of course you can create a
multi-platform library and you can use
you will provide different versions of
the drivers for patrons by the way the
graphical subsystem of tips it is built
in this internet way as I recall so they
use that technique in Eclipse
all those libraries can be should be
cross-platform originally but then you
don't need to switch
you're writing Java code
that's what
one type of machine
no no no as I said and that means is
cross-platform product product and it
uses the technique and it just provides
the libraries for all platforms seen the
one I don't know resourcebundle white by
the way is for so just a second I will
just say something so if you have some
suggestions about which features you
would like to see in this plugin yes we
told you about right me everyone yeah so
a few days probably yeah so so so yeah I
just will remember that we we are quoted
see in the team of the NetBeans so if
you go to NetBeans and you can write to
the CD team areas the email and we will
get that email entry act so because it
is also our interest to evolve this
plugin so we will be very grateful for
any suggestions you can tell that the
next feature that we would implement
probably is their aggregating the
creating global references for Java
methods fields and other stuff to use it
from C code because some of our users
already asked for it you know it's on
our priorities it was the question
yes we became debug core files I think
that does not have to do anything with
mix development but you can debug the
core file you can observe your native
port you can see in debugger the
variables for example at the moment of
crash so we can debugger files yes so it
relates to the ID but doesn't directly
relate to the mix development because
yeah that's a bit different
please in Linux
so are you talking about the production
system
yes actually did also Solaris also
Solaris not entered head no no no
actually the demo was done on work of
Linux so it supports Linux and actually
I can equal provides and it will work as
well and yourself so many platforms are
at error
salaries to do yes yeah that's true
it's true and that portion is obviously
available on those platforms so all the
studio is all the component support
three official platform Solaris Solaris
Oracle Linux entered head and the IDE
can run everywhere where Java runs any
other questions
I think if your question is about how
can you lose in that case features of a
Yip example navigation from doubt no
okay okay I understand okay
it actually would work you can just open
for example JA approach is mg ni project
and those features would walk in that
case perfectly for example I can open an
open JDK and I can navigate from any
java application in which for example
uses casinos I can you know in question
sees implemented as a check method to in
stick math class and they can navigate
to that method in stick math class and I
will see the implementation in open JDK
so I don't need to create yes actually
yes
maybe we can we can make the scope of
our search little bit less if we would
check the property of both projects you
know the job product should be able to
load library so we can rely on that but
for now it just would search those
symbols in their open projects thank you
all for your time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>