<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Building Reliable Serverless Apps with the Saga Pattern and Fn Flow | Coder Coacher - Coaching Coders</title><meta content="Building Reliable Serverless Apps with the Saga Pattern and Fn Flow - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Building Reliable Serverless Apps with the Saga Pattern and Fn Flow</b></h2><h5 class="post__date">2017-12-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/jrOS_UrIQI0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi folks welcome back to Oracle code
live I'm Tom Leggett I work on Oracle's
contain a native application development
platform and for this session I'm going
to talk about building reliable servers
apps with the saga patent and FN flow
we're going to start off by taking a
quick look at the service application
space and why we think it's important
then we're going to introduce you to the
FN platform which is an open source
service platform that Oracle is
contributing heavily to then we're going
to talk about some of the problems today
with developing serverless applications
and FN projects answer to those problems
FN flow we're going to do this by
developing a sample application and
showing you some real code so what is
serverless development or service
application development well I'll let
you into a secret first of all there are
servers lots of servers lots of
networking gear to storage as well the
point is that as developers of
applications we're trying to solve
problems for your business you don't
have to think about the servers or the
infrastructure level anymore
and as we go on to build our sample
application throughout this session we
hope that we won't have to mention
infrastructure concepts such as
networking load balancers auto scaling
groups or even containers all that much
so the beating heart of a service
platform is a functions as a service or
a fast as it's often called a function
is a simple piece of code that does one
job and does it well it takes some input
usually on standard in and it optionally
writes some output usually to stand it
out we're not talking about functions in
the functional programming sense of the
word here these functions can have side
effects whether we think of functions as
self-contained units of work that can be
independently deployed and tested so
your functions are deployed as a unit to
your functions as a service platform to
your faz
the platform then deals with the
provisioning of the underlying
infrastructure deploying your functions
your functions code scaling up scaling
down resilience reliability billing
security or authentication authorization
isolation all those kinds of things and
it has to do all of this blazingly fast
at huge scale and for any language or
platform that you care to use but a fast
on its own is not sufficient you need
somewhere you need at least somewhere to
store staked and process the state and
you can check out the state service talk
in this Oracle code live for some more
information about that and you also need
a way to stitch together these small
independent functions into a coherent
fault tolerant whole and that's where FM
flow comes in we'll talk more about that
later as we start to develop our
application so your first platform will
enable your app to scale organically per
request without you having to write any
special code to handle it
and we're not talking just about the
Gentiles '''l changes in demand that you
might see in a retail business but we're
also talking about sudden dramatic
changes in demand such as when your app
or your website go viral on social media
another thing that a service platform
and a farz in particular has to do for
you is take care of secure isolation of
your functions here again keeping things
small helps us write better software the
isolated isolate execution contexts can
have secrets that can have injected into
them only the secrets that they require
and this greatly reduces any blast
radius for any software vulnerabilities
more than anything else though a service
is about being a code first or code
centric the primary focus of a service
system or service platform is your code
the fast encourages you to break up your
app into small isolated parts this is
great for development as small isolated
functions are easier to reason about and
manage service changes the economics of
computing - so the two primary
principles here are that you don't pay
for your code whilst it's not running so
you don't pay for idle and that when you
do pay you'll typically pay in
sub-second increments for resources
consumed today this is typically a
hundred millisecond increments over RAM
consumed but there are important
secondary effects that stem from these
as well
developers can focus on writing code to
improve the lives of their customers
instead of managing infrastructure and
software lifecycle more productive
developers equals happier developers
equals more productive developers also
you're fast can pack workloads much more
densely than just using VMs alone this
enables better utilization of hardware
and therefore better price performance
that we can pass on to our customers
finally complexity is moved into the
platform and handled for you for example
the auto scaling nature of the functions
as a service platform removes the need
for developers to write lots of
complicated code to handle scale out and
scale back so we think the combination
of sub second resolution billing
seamless scaling and small reusable
functions will change the way we think
about software engineering as tools and
practices catch up to working at this
fine grained resolution the financial
impact of poorly written or badly
behaved code will become immediately
obvious and developers and companies
will stop using costly libraries and
functions this we think I think has the
potential to have a massive positive
impact
on the maturity of software engineering
as a discipline at this point I'd like
to introduce the FN project the FN
project is an open source service
platform that runs anywhere in the cloud
or on the premise it's simple to use
it's easy to understand and it's
performant Oracle has been working on
this for a few months we open sourced it
back at JavaOne at the end of the summer
and you can download and use this for
real today and where we've committed
resources to this long term go check it
out FN project dot io will take you to
our landing page from where you can find
the code on github which is in the FN
project organization really yes really
it's an Apache 2 license project it's
not under the Oracle brand or the Oracle
github organization we're actively
seeking external collaborators and
contributors we have teams in the UK in
the US who are working in the open in
github and on slack in this project so
this is not just something that we're
open sourcing and abandoning and hoping
other people to pick the work up on this
is a real project that we're committed
to developing in the long term and
neither is this an open core play we're
not keeping any of the good stuff back
for ourselves what you see in github is
what will be running in our cloud
service so why are we doing this it's
not just out of the goodness of our
hearts but we we believe that being open
allows us to provide a much better
developer experience and that's the most
important thing in our minds about a
service development platform so not only
can you get and read the source so you
know exactly what's going on under the
hood should you need to you can also
join in contribute in the open-source
community take the project in the
direction that you think it needs to go
as well as getting help and support on
our slack channel actually really mainly
because it enables an awesome
frictionless local developer experience
that it's difficult or impossible for
closed and proprietary solutions to
achieve by running the exact same code
on your laptop on your local development
environments that will be running in
your cloud service you can get real
genuine dev - prod parity for the first
time so what is the FN project we have
awesome support for Java obviously where
the Java company what does that mean it
means that we have shipped a Java
function development kit or fdk as we
call it this speeds up the development
of Java functions it has unit testing
support in the form of a J unit rule to
accurately simulate the runtime
environment this is great for your fast
iteration either on your laptop or in
your CI environment the fdk also
provides access to configuration and
secrets that can be injected by the FN
platform and a set of type coercion z'
to make parsing and formatting your
input and output as easy and as safe as
possible so once we have awesome Java
support obviously it's also great for
all languages because we're a container
native application development platform
you can run anything in one of our
functions that you can run in docker
today out of the box we ship with high
fidelity F decays for four languages as
well as support for 15 other stacks but
anything that you can run on docker you
can run as a function in F n today this
offers a lot more flexibility and power
than other service offerings today and
finally we're also announcing something
called FN flow so this is this is the
answer to the problem that crops up
quite often when you've developed a
service app of any sufficient complexity
once you've broken your application down
into these lovely small
components and functions how do you then
stitch those together into a coherent
user flow that is reliable and
maintainable okay we're going to get
onto sir showing you some code really
soon now so let's look at the briefly
talk about the demo scenario so we are a
travel agent
we've partnered with four different
third parties one for booking flights on
for booking hotels one for booking car
rentals and one for sending emails on
our behalf
we've selected the best of breed
providers in each of these sectors
unfortunately this means that we have a
heterogeneous tech stack to deal with a
flight provider provides us an SDK in
Java our hotel provider would rather we
integrate with them using their Ruby SDK
the car rental provider only really
keeps their nodejs SDK up-to-date and
the email provider would rather we were
talking to them in Python so what we're
going to do in this first part of the
demo is we're going to write a series of
functions in Java Ruby node and Python
one each for booking and canceling a
flight a hotel and a car and one for
sending an email finally in a later part
of the demo we're going to write a trip
booking function which can reliably book
a flight a hotel and a car on behalf of
the user using one request okay so in
the first part of our demo we're going
to write our first Java function and
this is a function to book a flight so
here we have my development machine it's
a Linux box and I have installed on it
the FN command line the FN CLI I've also
already started a local development of a
server which you can do just by issuing
the FN start command
we are in a folder called book because
we're going to write a function now to
book us a flight first thing I'm going
to do is initialize this function using
FN in it and I'm going to specify a
runtime of Java because we want to
create a Java function this has created
a bunch of boilerplate that you can see
here it's created as a hello world Java
file a world test as well as this
functional file so let's have a look at
func yeah more here we can see is just a
bit of metadata that the FN platform
needs in order to be able to run the
function successfully it's got the entry
point specified as a method on a class
which gets called when the function is
invoked as well as the runtime of Java
and I'll explain the format HTTP later
ok so if we now open up our open up our
project in our favorite IDE in this case
idea we can take a look at what the FN
platform has generated for us so here we
have our boilerplate that FN has
generated for us this is the handle
request method that was mentioned
referred to in the funky Tamil as the
entry point and as you can see it's just
plain old Java that is going to return a
friendly greeting when it's called no
frameworks to import no libraries to use
just plain old Java it's also generated
a test for us here you can see it's
using a J unit testing rule to simulate
the environment that this function will
be running in when it runs in FN and
when we can when we run this function we
can check that it does the right thing
before we've had to do anything like
deploying it or or testing it in an
integration environment here we go as
you can see my test is running and
passing ok so we've got a function and
we've checked as well as we can that it
does what we intend it to do let's think
about how we do
this so in FN there is the notion of an
app all this does really is grouped
together functions into one coherent
place so that you can reason about them
and configure them together we're going
to create an app called flight in which
to store our booking function and then
we're going to deploy it we're going to
deploy it like this we call FN deploy in
the context in the directory of our
booking function then we specify the app
and we also specify the local flag
because we're just doing this locally
for the purposes of this demo as you can
see it's built and deployed this
function to our function server if we
now have a look at the routes on our
flight application we can see that
there's a slash book route we can see
that it is pointing to an image and we
can see that there's an endpoint at
which we can call it so let's try and
let's try and call this endpoint as you
can see and we call that endpoint we get
back a friendly greeting and you can do
the same thing by using the FN call
command like so and this is just a
wrapper around the same functionality
now this is possible because the FN
platform includes a lightweight and
performant HTTP gateway which Maps these
HTTP calls on to function in vacations
let's recap what we've just seen so
there's nothing more productivity
sapping for a developer than having to
wait a long time between writing code
and getting feedback about whether it's
worked as used to be compile time or
waiting for your CI build to pass but
these days is waiting for your code to
deploy to your cloud environment for a
complex app this can be very time
consuming so in the FM project we
focused on providing a
Laird answer to this problem the f
decays include unit testing frameworks
unit testing support for that really
rapid sort of around about one second
feedback then we have a great local
deploy and test story where you can
where you can run a local dev server
that's running exactly the same software
versions as your cloud environment and
this is for your user to five to ten
second cycle feedback and then deploy in
testing cloud which is around about your
thirty second because we can take
advantage of the underlying container
layer and docker this lets us take
advantage of docker layers so the deploy
to the cloud environment is super fast
and speedy too and also it's worth
noting that this is just Java you didn't
see us have to import any libraries or
frameworks in order to get this with
this working we just wrote a plain old
Java function that took a string and
returned a string and FN platform did
the right thing in that case okay so
we're going to make our function do
something a bit more useful to start
with we've renamed the handle request
method into book so it's a bit closer to
our problem domain in our business we've
changed the input type from a string to
this flight booking request object which
is defined above here what the Java fdk
will do in this case is convert this
this class to and from a JSON structure
you can see a sample JSON structure here
and how this corresponds to the Java
class here
we're also instantiating our API client
from our airline partner and we're
calling it down here in the book
function passing it the flight code in
the departure time in order to book a
flight and we're returning the
confirmation number that we get from our
third party flight booking provider
we've also got this method here this is
the first time that we're seeing
something specific to FN in our java
code so up till now just being plain old
Java that you're all used to used to
working with now we've introduced this
FN configuration annotation this this
tells FN to call this configure method
and pass in this context and this can be
used to get configuration information
for the function in this case where are
third-party providers API lives and any
authentication secrets that we need in
order to connect to that API and we
instantiate our our API with those with
that information ok so far so good as
you can see from our functional here
we've got some config specified in the
funky amyl and we've also got some
config that we've loaded up via the CLI
so you can do it in either place we
deploy this application in the this
function in exactly the same way we're
going to deploy it to the travel
application and we're going to deploy it
locally as before once this has built
and deployed we should be able to we
should be able to call our function now
what we going to have to do this time is
because our function is now expecting
some input we're going to have to pass
it some input pass it in some input now
I've already shown you the sample
payload in the IDE which looks like this
so let's try passing that in to our
function once it's built and deployed ok
so our function is built tested and
deployed let's call it so we can do this
just with the F and call we have to
specify the application that we want to
call and the endpoint that we want to
call which now looks like this and we
can pass it the sample payload we can
pass it in the sample payload that we
want to use and as we can see
now we have got a confirmation number
back from our third-party provider doot
amongst you might have wondered where
that confirmation code was coming from
well I'll let you into a little secret
I'm not actually booking a flight every
time I issue one of these calls
otherwise these talks would get very
expensive what we have in fact is a set
of fake api's or fake SDKs which are
controlled by this dashboard here and
this lets us have a little bit of
visibility into what's going on behind
our scene behind the scenes without
actually having to book flights hotels
and cars each time so here you can see
this was the request that we just made
against our API you can see the the
information that was passed in as well
as the confirmation code that was sent
back so if we if we were to make another
request to our flight API we can see the
flight booking you can see this is the
five booking up here down here for
therefore the new request that we just
did similarly then for the hotel car
flight flight booking URLs and the
flight cancel the flight cancellation
Hotel cancellation and car cancellation
api's - as well as sending an email so
for one of the principles that we use
when we've developed our F DK's is that
we apply sensible defaults but we enable
the extensibility when needed and we
apply this across the whole of our
platform so what you saw there was same
defaults for serializing and
deserializing Jason but should you need
to should you need to you can access the
full power of the Jackson API to
customize those serialisation those
serialization and deserialization x' for
you we've also seen that you can pass
configuration and secrets into your
functions and you can do that at the
function or the route level and you can
do that at the application level as well
using a simple API
and it but it's still just Java right we
are able to use any of our third-party
libraries just as you would if you were
writing any other java application what
we're gonna do now is develop all of
those other functions that we talked
about earlier on in the presentation
namely the hotel providers functions to
book and cancel in Ruby and the car
rental providers functions to book and
cancel in node J s as well as the email
sending function in Python what you're
gonna have to do is imagine a rocky
style montage at this point because I've
already done all of that for you and
we're just going to have FN deploy all
of those all of those functions for us
into the travel application we can do
this using the FN deploy - - all command
which is going to find all of the
functions underneath this folder
underneath this directory and deploy
them into the travel application so here
we go if we kick this command off we can
see that FN has gone and found the car
the email and the hotel functions which
we've written in lots of different
languages this is great because we're
able to use the right tool for the job
and to choose the best of breed
providers no matter what tech stack they
use okay so we've completely we've
successfully deployed all of these
functions if we now have a look at the
list of routes in our travel application
we can see that we've got a car booking
and canceling route we've got a flight
booked and cancel route and we've got a
hotel booked and cancel route as well as
something for sending emails now this is
all very well and then we've got lots of
independently useful functions but our
users want to book a trip and this
involves booking a flight a hotel and a
car and it wants to do so reliably and
repeatably how do we go about doing this
in a service space so what we want to do
in this trip booking function is
reliably confirm each reservation or
cancel them all we want an
all-or-nothing semantics for this call
it's got to cope with all sorts of error
conditions it's got to cope with
downtime in our provider api's and it's
got a cope with you know flights that
have filled up since the user searched
for them hotels that are packed out
since the user searched for them or
empty car rental lots and this workflow
composition problem is actually a pretty
general one that most service
applications get to once they reach some
level of complexity there are too naive
approaches that we might take to solving
this problem we might think of writing a
blocking master function that calls the
flight booking function waits for the
result then calls the hotel booking
function wastes there is for the result
then calls the car booking function and
waits for a result and handles any
errors might be easy to understand we we
lose some of the nice characteristics of
a service function because this function
is is now a long-running function and
consuming resources for the whole times
we might lose some of our scalability
this is but the main issue with this
with this kind of approach is that it's
not very reliable if that master
function fails for some reason or if the
node on which that master function is
running fails and you've got no easy way
to recover so all of a sudden you're
looking at building in rely our journal
in recovery all sorts of things into
your master function and you've lost
that lovely simplicity that we're
looking for from our service apps so the
next thing you might think about is
chaining one function from the next so
you might have the flight booking
function call directly call the hotel
booking function and directly call the
car booking function but a little bit of
thinking about that tells us that's no
good either rapidly becomes a
maintenance nightmare because every
function has to know about all of the
subsequent functions so that it can take
and pass on the right bits of data a fan
in or join is really tricky
in this situation and you get a connect
Splosion of complexity when you start to
think about how you deal with errors so
we get to the point of needing an
external coordination service that you
can configure to call your functions
past eight down the graph and deal with
errors those of you who've been around
the block might be might hear alarm
bells ringing at this point haven't we
been here before doesn't this sound an
awful lot like the bear Pole business
process of engineering language stuff or
some other external DSL and if you're if
you're a bit more modern doesn't this
sound a bit like some of the other dsls
like step functions or logic apps that
that other cloud providers used to
stitch together their service functions
I think I think the the step functions
and the peple amount to the same thing
but maybe one in JSON more in XML this
approach has several problems that
prevented series adoption the first time
around with peple and we think will have
the similar issues this time round
so first up not every problem Maps well
to a state machine approach which is
where you were which is where you end up
if you go down this external DSL route
secondly error handling becomes very
tricky and you get an explosion of
complexity when you start to think about
errors and edge cases and it rapidly
becomes very difficult to see the wood
for the trees in your in your user flows
it's very difficult to test because
you're not in your native environment
it's really difficult to debug because
you're relying on an external service
that you have no you have no kind of
knowledge or tooling of tooling to help
you do you also have to manage and run
an orchestration service to be highly
available therefore your workflows are
only as available as your orchestration
service you end up creating a lot of
glue code that
kake's that extracts the right bit of
data from the previous function call and
formats it for consumption by the next
and this can this causes you to have an
explosion of the amount of code that you
need and finally it's a whole new bunch
of language and tooling to use that
takes you out of your favorite place to
be and and into new and into new
languages and tooling sometimes in in
JSON or XML and who wants to be writing
serious programs in JSON or XML so we
thought about this problem and it
occurred to us that Java actually
already has a mechanism for composing
asynchronous functions the completion
stage API that was introduced in Java 8
and improved in Java 9 provides a really
nice type safe promises style API it
lets us compose a graph of asynchronous
computations unless you specify
concurrency fan out fan in and a bunch
of other provides you with a bunch of
other distributed programming primitives
particularly around handling errors
gracefully so we thought what if we
could use this API or something very
like it in our favorite language Java of
course to compose our service functions
so we wrote a service that we call the
flow server that can store and trigger
the execution of these computation
graphs this we open sourced along with
the rest of the f'n platform and shares
the same scalability and reliability
properties as the rest of the f and
platform and this this service that runs
in the FM platform then backs an API
that's almost exactly like Javas
completion stage API that you can use in
Java to reliably compose other functions
this means you don't have any new
tooling to use you're working in your
favorite IDE in your domain to compose
your your user-facing workflows let's
see what it looks like
so you can think of a flow as being a
directed acyclic graph of computations
each function within FN optionally
exists within the context of a flow and
in Java you get access to that flow with
this flows dot current flow static
method call so this flow object has a
bunch of methods for adding work to our
current execution graph to our current
flow so invoke function for invoking
other functions on the platform all of
for doing some fan-out supply for
supplying an already completed value
into our graph of promises and any of
for example for doing a fan in we're
going to use the invoke function call
here and we're going as you can see
there's a there's a few different
variations of it we're going to use this
to call the flight booking function and
we're going to pass it sum of the sum of
the input so we as you can see here we
have we have got a request trip req
input variable which we're referencing
here the trip req is actually just a
structure that maps to Jason in the same
way that we showed you earlier on so
this this structure here contains a
flight a hotel and a car rental and that
corresponds to Jason that looks a bit
like this so what we're going to do here
is we're going to pass out the we're
going to pass in the flight information
to this flight booking function but we
also have to tell the runtime what type
we expect this call to return that looks
a bit like this now this is going to
return a flow future object
okay let's put this into a variable so
that we can have a look at it now this
this flow this flow future oops we're
done there this this flow future so this
flow future represents the future or the
possible future value of this of this
function of this function call and it
itself contains methods for chaining
work on to the result of this
computations and so we've got compose
accept exceptionally methods for dealing
with errors
anyone who's programmed in nodejs will
recognize this style of chaining
promises together so what's going to
happen when we deploy and run this code
well hopefully we will see a call to the
the flight function with just the flight
information passed in so let's let's do
it let's deploy our application again
which we can do like this now we should
be a lot quicker to deploy all of the
other functions that haven't changed and
we should only really need to rebuild
our trip application which is what's
going on here and then we can call our
trip application and pass it the the
sample XML with this hi XML example
Chasen which as we've the sample payload
which as you can see looks like this so
we're going to pass in information about
everything and our flight our function
is just going to extract the flight
information and pass it onto a flight
function hope so our build has succeeded
we've deployed our new trip function we
are going to call the trip endpoint and
we're going to pass hit that sample
payload which contains information about
all of our trip and we're going to
hopefully see that make a call to just
our flight API sometimes it takes a
little bit longer the first time it's
called so here we go we have a
a call now to our flight API so at this
point I'd like to introduce the the flow
UI and this looks a bit like this this
is a left-to-right view of the execution
of our function and here we can see the
execution of the flight the flight book
function as well as something at the end
if we scroll down to the bottom we can
see more precise logs and stats about
about running this flow so if we if we
reload this and run our flight function
again we can see that this is actually a
trip booking function again because this
is actually a live view so this shows a
live view of what the what the system is
doing whilst booking our flights ok so
far so boring so this is doing almost
exactly the same thing as our original
flight booking function a little bit all
that we've really shown so far is the
ability to pick out just a bit of data
that we're interested in from our from
our input request and pass that on to
the function what I want to show you now
is how we chain some work together how
we actually build a workflow what we're
going to do is use the then compose
method off the flow future and this
takes a lambda which takes the result of
the previous stage so in this case this
is the flight booking response and it
returns a new flow future that
represents the rest of the work to be
done in this in this graph so in this
case why don't we add a nother call that
will in fact call the what's next it's
the hotel booking function
and we're going to call us exactly the
same way we're going to chain the input
I'm going to pick the hope just a hotel
information out of the input and again
it's a it's a booking response that
we're expecting from from this function
so here we can see that we're chaining
on some work to the come to the
completion of the flight booking
function the hotel booking function now
what's really interesting about this is
that we now have some we now have some
nested scope so this flight result is
accessible for us to use in here and we
can use that to our advantage later on
so if we were to now take that a bit
further and call up the code that does
the complete booking flow so here we can
see that we've got a then compose that
takes the flight response and runs the
hotel booking function and onto the
result of that we are composing a some
work that takes the result of the hotel
booking function and composes on the car
car booking function and when all of
that's complete we run this stage here
which takes a lambda which takes two
responses to two arguments a response
and an error and either one of these
will be null so we can use this to do
error checking to and here's how we do
our fan-in at the end here so once all
of those are completed we've now got the
results from the previous stages the
flight the hotel and the car still in
scope because we're in an inner scope
here so we can just send these off to
our email provider to let our users know
what their confirmation numbers are for
their very advert for their various
different trip segments okay so let's
see what happens when we deploy and run
this what I'm going to do this time is
well let's let's deploy the deploy the
app again so our new trip booking
function has deployed let's call it and
pass it our sample trip payload and see
what happens
we would expect to see a call now to our
flight booking API our hotel booking API
our car booking API and finally we'd
expect to see an email sent to our users
with the with the results what's
interesting about these requests is that
each of the flight the hotel and the car
requests each only have information that
pertain to the flight hotel in the car
so they are truly independent functions
and the email then collates all of this
information together in in one place for
our users so we've got a we've
demonstrated a sort of a fan out and a
fan in okay so far so good but what
happens when we experience an error in
these in this situation let's say for
example our car provider runs out of
cars in between our user searching for
them and our user making the booking
request well we can use this dashboard
here to configure an error response from
the car booking API and that will show
up as a read request when it's made at
the moment we haven't written any code
to handle the errors and what we're
going to need to introduce at this point
from the saga world is the concept of a
compensating transaction if we get to
the part of the point where we're
booking a car and we get a failure will
already have a flight and a hotel booked
so we're going to need to issue
compensating transactions then to cancel
that flight and that hotel and in fact
because we don't know what the state of
our car reservation is we don't know
whether that booking succeeded or not we
also need to try and cancel our car
reservation so let's see what that looks
like in code
so what we've done here is we're using
the exceptionally compose method on our
flow future to chain on some
compensating transactions these stages
only happen only occur when a an
exception occurs in the stage to which
it's attached and we can use and we can
use this to handle errors in this case
we're using it to implement the saga
pattern compensating transactions you
could use it to inject default values or
to flag to an operator for for attention
whatever really makes sense in your use
case but here it's for compensating
transactions so here we're canceling the
car if we get an error in the in the car
booking function and similarly for the
the hotel and the flight what we're
doing here is we're returning a failed
future from this stage to ensure that
the error bubbles up and we also cancel
any preceding things then right at the
end we're sending an email to our users
to let them know what what was going on
okay so let's take a look at what would
happen we're going to call the function
in exactly the same way that we called
it before but this time we've configured
our car endpoint to return an error to
fake return and error so we'd expect to
see our flight booking request come
through successfully our hotel booking
request come through successfully but we
get an error when we try to book a car
this then causes us to cancel the car to
cancel the hotel and to eventually to
cancel the flight
we'll also at this point send an email
to our users to let them know that
something went wrong and that they need
to try again so what does this look like
in the flow UI let's well let's run it
live and see so when we call our
function we can now have a look at
exactly what's going on as our functions
running the flight function takes a long
time to run sometimes sometimes our
flight provider takes a while to book a
flight
our hotel booking provider who runs a
bit quicker and our car booking provider
returns an error and the stage goes red
we can actually select this stage while
the graph is running and go and have a
look at the go and have a look at the
logs so here we can see the log and this
has actually come from the JavaScript
car booking node.js function and we can
see then the exception handling stages
that have been chained on by a half by
our flow to handle these to handle these
to handle this failure if we if we
scroll the viewport over a bit we can
then see the the cancellation of the
flight and the cancellation of the of
the hotel and the cancellation of the
car as well as the sending of the email
so we get this lets us get a view of
what is going on in our workflow when we
have issues but what happens in the case
where an API is completely unavailable
and we can't even execute the
compensating transaction we'd like to do
in that case is have some kind of a
retry retry functionality built into our
platform
now today FN flow doesn't offer retry
functionality functionality natively
although we're thinking about adding it
down the line but what you can do is
wrap up some of the other primitives
that that FM flow provides you with in
order to produce retry and functionality
so what we have here is a retry class
and we've implemented an exponential
with jitter retry and all we've done is
we've wrapped up our invoke functions in
this in this retry call so the the
actual change between the the last
version that you saw without trial retry
and the version that you saw with retry
here is just this wrap
call what's really interesting when we
look into this class is that all we're
doing here really is encapsulating some
distributed programming best practices
by composing up the primitives that FM
flow provides you so here we're using
exceptionally compose delay and then
compose to implement an exponential
back-off a retry with exponential
back-off this is really cool right
because you can you can do this do this
kind of best practice code once and then
have all of your developers use it in
places as appropriate so let's see what
happens when we when we deploy and run
this code we've deployed the function
and built it as successfully so let's
call it again in exactly the same way
that we've called it before but this
time we've also configured our car
cancellation API to to simulate an error
so that we can simulate the entire car
booking process being down and hopefully
trigger some retry behavior so let's
call our API and have a look at the
behavior that happens in the in the
partner api's we should see a successful
flight booking as usual we should see a
successful hotel booking and then we
should see a failure of our car booking
and we should see then that trigger our
compensating transactions now because
our our car cancellation will also fail
this time this should trigger some retry
behavior and we should see our api's
trying our flow trying to retry this car
cancellation with a an exponentially
increasing delay on that back off so
here we can see the the retry is
occurring on the on the car api
what does this look like in the in the
flow UI well here you can see the the
car can't cancellations coming through
and erroring out and exactly as we had
before we can we can select these nodes
so if we select this node this will then
highlight all of the nodes that cause
this node to be triggered as well as
providing us with the with the logs for
each of those nodes down below this is
super useful for understanding what's
going on in a in any given flow
invocation so what we've seen here is a
flow a user facing flow that has been
implemented using what may be 30 or 40
lines of code that exhibit some really
quite complicated
fault tolerant behavior we haven't had
to mention any kind of infrastructure or
any kind of infrastructural concepts
such as such as API gateways or load
balancers or auto scaling groups we've
done this just in code and in Java code
as well that runs in our IDE and is
testable and is maintainable alongside
the rest of our code we've implemented a
platform an app that is multi-language
that uses four four or four or so
different languages and as you can see
from this UI here we're gettin unified
logging across those different languages
so we're getting our our JavaScript logs
and our Java logs in in the same view
here so even though we're developing a
multilingual Scituate application in
order to take advantage of best-of-breed
providers we're getting a unified view
across those different languages now
those of you familiar with the saga
pattern will be familiar with something
called the saga execution coordinator
which does the the
kind of reliable recovery of
transactions and you might be wondering
where that component exists in this
system now I mentioned earlier on the
flow server which is the component that
deals with storing and invoking these
execution graphs and we can think of
that when we're when we're using flow to
implement saga patterns as equivalent to
the sovereign saga execution coordinator
as actually behind the scenes this is
doing journaling and recovery for you so
we'll be tolerant to node and even data
center failure a whistle-stop tour of
the service space why we think it's
important I've introduced you to the FN
project and we've developed from scratch
an application a sizable service
application that runs in four languages
and demonstrates some quite complex and
intricate fault tolerant behavior all
with using a very small amount of code
so I'm going to open up to questions now
before we do I just want to say come and
check us out FN project I Oh
we hang out on slack or a very friendly
Bunch we'd be interested in your
comments and responses to this talk come
and try it out download it play with it
make something cool with it thank you
for listening thank you for your time
any questions
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>