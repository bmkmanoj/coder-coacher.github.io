<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>RESTful Microservices | Coder Coacher - Coaching Coders</title><meta content="RESTful Microservices - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>RESTful Microservices</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/5XGMuftgnIQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome everybody I really appreciated
that many people show now here I it's
great thank you thank you for your calm
time for coming
my name is yeah Caputo shock I am based
in Prague Czech Republic I work for
Oracle Corporation for the application
forever group partially on project
Jersey I was asked to show you this this
purely technical presentation so don't
take it to the bank
just for informational purposes so with
the goal of the presentation you are
probably not going to learn much much
new about micro services what I'm going
to do is you hope to provide you some
technical information some technical
tips on how to utilize Jersey or jax-rs
or or jax-rs when developing or writing
designing your own micro services okay
so we will start with a short micro
service primer just to establish a
ground where I can build upon and I will
tell you something about
jax-rs and Jersey itself and then I will
try to put things together and to show
some live demonstrations on what
features could be could be utilized
could be handy in writing micro services
I will be showing live demos and I also
have a question prepared for you so the
first one who knows the right answer
will be awarded with a with a t-shirt
with a yellow t-shirt the same I am
wearing now so please pay attention to
the decode I'm going to
be showing here okay so this is the
shortest primer I I could come up with
how many people have seen the
presentation please
so this is a publicly available a
presentation from James Lewis from port
works I think it's a great presentation
or its summarized what what is the micro
services and there are some practical
tips on how we design micro services
what's the reason why you would need to
to go this way you would want to design
design your application using micro
services I'm going to show this tonight
so here is my primer so there is a
common sense in NIT it's nothing new so
if you face a big problem big issue just
try to decompose the problem into small
parts that could be handled separately
this is nothing new in this it's known
as the composition or we have heard
about divide and conquer principle so
the only maybe new thing in in this
respect is that you break the big
problem into small parts and you take
this further so rather than just having
the components as a mental model when
designing a big monolithic application
you turn the small components into new
individual you know separate
applications
that's I think the the key the key thing
because there is nothing new in the
couple decomposition really nothing new
microservices is a is a hype today there
is nothing new on the principle the only
thing is that you take it further so the
components are not deployed as a one big
monolithic block you know put together
they are you know design test it and
deploy it separately
that's I think the the key aspect and
another very important piece is that the
small individual applications could talk
to each other so there is a clear
boundaries between them and they are
accessed from outside why a
clearly-defined
application interface so that's really
important okay so I further said that
it's easier to design small applications
but it is also true that the individual
parts when deployed separately could
evolve in a in a different pace this is
also important imagine it would change
this one piece of a big application and
you are going to deploy to redeploy to
deploy a new version of the application
so I will how would you feel friend of
mine used to work sexually my colleague
at Oracle used to work for a foreign
bank in Czech Republic and they had a
special committee special board when
they wanted to deploy a new application
or a new version of an application they
needed to bring it to the board and ask
for approval and it was a nightmare
nightmare think very long process they
needed to commence the the people at the
committee okay so we need to deploy the
application
need a new version deployed so imagine
you had only a small application with
clearly defined responsibilities and
boundaries and you bring it to the
committee then probably the whole
negotiation would would go much faster
so it is also about only about
technology it's also about the processes
in the in the companies that are made
simpler when when using this approach so
that's one aspect another thing is that
of course for a small application that
has a clearly defined responsibility and
API everything is easier testing
deployment and also maintenance so you
are only only gaining so from the
perspective of a single application you
are only gaining the only disadvantage
maybe is that used to handle single
application and now you need to andro
many of them many of you know smaller
applications but still the number number
matters so there is also a drawback here
and you need to you know judge you know
the problem you are the domain expert so
you have to decide there is also this
trade-off okay so there are some desired
properties that the small applications
these small pieces should have so what
are they I've suggested that this pieces
should be small enough so that they
could fit into one set so there is a
parallel between microservices
and UNIX operating system commands where
we have a lot of lot of utilities and in
the UNIX world
where
each of the utilities does only one
thing but does it really well for
instance sort grep and other commands
and also there is a simple interface to
each of these commands so there is this
input stream output stream file system
pipes and it's really to combine these
these commands together so this is also
also very important in the microservices
world where you can you can combine
combine the micro services one micro
service could depend on another and so
on another thing is that of course given
that every application is always only
small maybe you might want to you know
stop rewriting if somebody is if
something goes wrong you just throw the
whole thing away you keep the interface
and you rewrite from scratch
it's also possible given that the
application is small but almost
impossible if you are talking about a
big monolithic application so really the
key is in my opinion the application
interface the boundaries that are
established so that the outside world
could communicate with the service and
also the micro services could
communicate with each other ok so you
might want to have something better than
file system input output stream we are
in a distributed environment and the
protocol that works probably best in
this environment is HTTP and if I wanted
to generalize the term I would say the
rest is
the approach that allows you to scale
and to really work well in a distributed
environment so that's probably nothing
new if you if you have heard about
microservices already we are coming to
deployment so most often advise and
deployment is that you should select a
small container as possible I don't
think it really matters key aspect is
that you stick with the API with the
interface in the container you select
based on your requirements so you can
you can go with a container less
deployment I will show one or maybe it's
not container less I won't be using a
fully fledged application server in my
demonstrations actually I'm going to
deploy my micro service to this device
Raspberry Pi you can you can of course
use these lightweight containers but you
can also use a fully fledged application
server and it's up to you again what
matters to application consumers is the
boundaries the API but you might have
some to put requirements performance
requirements and other such requirements
that could dictate the container
selection so for instance imagine a
deployment where you have a load
balancer and then either very simple
service that you can you can distribute
distribute among many many host machines
and they work
sort of independently there is a you
know they're only loosely coupled but
the load balancer just you know
distributes the load between that and
then the term auto-scaling means that if
you have a watchdog application or a
budget process can monitor the
individual instances the individual
services then the boat dock could
automatically spawn new instances new
processes to adjust to increasing load
okay so you might want the
micro-services to make some runtime
information publicly available through
the application interface so that such a
scenario is possible so that the budget
application can communicate through a
standard protocol I will be also showing
a live demonstration for this okay so
there's a summary so if you want to go
the micro-services way you're likely
going to end up with many small
applications every application does only
one thing but does it well like in the
UNIX operating system commands word you
are likely to use a rest interface and
again the applications are decoupled
from each other they have a clearly
demarcated
api's and they are deployable testable
maintainable and scalable individually
in this regard they don't depend on each
other okay
well depends and I don't think it is
going to be easy so you know it's always
easier if you if you you know on a green
field you work from scratch so given it
that you have a big monolithic
application already even if the designer
you know the decomposed you know this
design and define some some components
it could be really tricky to do this I'm
sorry okay
there is no silver bullet okay well if
you decided to go with Java EE
application forever you are probably
going to utilize a single instance or a
cluster of you know a single cluster
you're probably not going to start that
many application servers because it
would be really costly in terms of
environment but if you are going with
this approach that a single instance is
a single operating system service then
yeah you are going to spawn as many
processes as you as you need so it's
it's really up to you it's a trade-off
and there is no universal advice on this
yeah well but not not really the fully
fledged application server right I like
Ike for instance AB logic or
yeah exactly
exactly the Trent is yeah yeah so this
is not the way to go
so as you pointed out you would run out
of memory and the resources so what I
meant when I suggested that well a
single operating system service is one
option and you can you can also deploy
it on a on application server I
suggested that you you would have a you
know the big application server occupied
with with many instances of applications
because the mother in turn you know goes
towards high density multi-tenancy and
so on but I'm not going to cover that
okay
this presentation well I will show
something I'm not here to you know sell
you application servers okay remember
the safe harbor statement but at the
same time I worked for a reco and you
know okay so that is the next part
jax-rs Jersey primer so jax-rs is a
well-established java api for building
chrisphillip services it includes api
for the server-side and also the client
api so we can from version 2 which is
part of Java EE 7 you can you can build
your clients as well with jax-rs
in a standard way so that you can switch
to another application server from
another company right Jersey - so it's a
jax-rs reference implementation provides
a production ready reference
implementation but besides that it
provides something more some
non-standard features that
I'm going to demonstrate tonight so why
jax-rs
and Jersey we are at joven so I presume
the vast majority of the of you are
working with Java jax-rs is as I said
well established standard for writing
restful Web Services in Java so question
is why not it's a natural choice so
that's it for the for the application
interface and I'm not really going to to
discuss details okay
okay what's the difference between so
and this I really I would research my
dick the goal of the presentation I'm
going to show you some technical tips
and this is a kind of a you know
political philosophical discussion and I
don't feel in a position to comment on
this maybe it's just a different name
for the same approach I think you know
everybody is interested in in such
discussions on the other hand you need
to deliver some application so maybe you
know okay so these are the features that
I would like to show you tonight
so grizzly HTTP service report I will
show you that you don't need to stick
with application server Joe application
server test framework because you don't
want to deploy anything that's not well
tested and Jersey brings a jersey test
framework that allows you to test your
rest services really in a convenient
fashion I'll show you a live
demonstration of it and then application
monitoring this is related to auto
scaling of course I'm not going to to
show you a solution and 2n solution for
auto scaling but I'm going to show you
how we can utilize Jersey application
monitoring to to get the runtime data
from my running application also if you
don't deploy on a fully fledged
application server which has the
controls which has no the management
tools here with a lightweight container
you don't don't have anything like that
so the monitoring tools
that are brought by Jersey could help
you in this regard
okay so now before I start with a real
demonstration I will just show you what
is the application interface the the
clear boundaries what am I talking about
so the first demo will be using Java EE
container namely GlassFish and I will be
deploying the very same application that
I will then turn into an application
that could be run as a separate JVM
process in a lightweight fashion so let
me switch to the to to NetBeans can you
can you see it from from the rear if not
I can I can maybe adjust the font a
little bit okay thank you so this is
just a made-up service something that I
can I can use for demonstration purposes
so I have a u3 source here which is
available under users slash ID and then
I define a simple HTTP GET operation so
I can get a user representation in JSON
and another method HTTP put where I can
send user records towards the the
service so that's for manipulating the
data then another another service let me
see if I can
oops okay users resource simple it
allows me to retrieve information on the
wall set of users that I I manage and
I'm using a simple static you know plus
property here in order to
and I've purchased the information okay
so now this is a very standard jax-rs
stuff you can package it into a Word
file and deploy on an application server
so let's do that so let me switch to the
command line okay so the application
server should be running I will just
check okay nothing
no no application deployed so I will I
will
it's too small now okay so I'll just
deploy the application using the command
line interface nothing fancy in the war
file takes a while okay
it's fast but I had the application
server started already okay so now I can
I can try to access the service okay so
I'm getting the list of users
I'm getting an empty array there's no
user yet there I can try to add another
user so I will use put methods I need to
signal the content type and finally I'm
feeding some data in so I need an ID and
name that's it so let's call it one
maybe I can try to on
okay
well okay it's not what I want it
content type okay right thanks
so it's application Jason okay here we
go
so I got response from from the
GlassFish application server no content
let's see whether the user is there okay
here we go I can ask single user data
only okay there we go
it works so now what I want to do is I
want to get rid of GlassFish get rid of
the Jie application server and I want to
use the very same jax-rs api the very
same java code in order to deploy on a
lightweight container so what I do let
me stop the application server first
ah okay okay sure
can you see it now okay thanks
okay so that's it so what I'm going to
do the application server is stopped so
now what I have here in my target
subdirectory is a single set jar file
which is all the code that I need so I
will just type Java jar user management
jar with dependencies and start it start
it responds right now I can use the very
same interface in order to talk to that
guy
you don't see any GlassFish here anymore
and talking to the very same interface
and the behavior is quite the same okay
so again I can I can try to add another
user maybe I can I can even another one
clean Java - and I can try to retrieve
the list here we go
and also the individual user records are
now available so I'm not talking to a
Java EE application server and still the
application uses the jax-rs api which is
part of java ee how is it possible
so if i switch back to my NetBeans here
is my application and this is the code
that is only needed it's very simple so
I use this grizzly HTTP server Factory
I'm passing it the URI 30 application
should be deployed and I'm passing it
also standard jax-rs application does
definition of my jax-rs resources and
that's it nothing else I can I can even
simplify this the force means that okay
don't start don't start the server yet I
will I will start it myself but just one
liner would I have a you know larger
screen will be really a one-liner so
that's that easy with Jersey so could
you please show your hands how many of
you knew this feature ok quite a lot of
you and how many of you are actually
using it in maybe production one okay
thank you
ok so let's let's get back to to the
slides so this is again how I how I
start the HTTP server instance here is
maybe a practical tip so grizzly itself
the containers
with a default setup in terms of the
selector threads and work threads here
is some advice on how you can adjust
these thread boots so that you know it
could fit your application needs for
instance if you if you utilize the
synchronous support you might want to
have more work threads and so on so
these are some some details you need to
use this this force parameter so that
the the instance is not started yet and
then you can adjust the third boots
okay so Risley is not the only container
supported so from the lightweight
containers this which are listed are
supported out-of-the-box through simple
HTTP server jet the HTTP container and
java c HTTP server so you don't need to
employ a special third part a container
java standard edition itself as a
lightwei lightweight HTTP container
included already out of the box and if
this offer doesn't fit your needs you
can implement your own support you can
plug-in your your own container or any
other third-party container using this
container provider spi that's present in
Jersey and if you do show please
consider contributing this support back
to to Jersey ok so that's how you can
deploy a jax-rs application outside of
Java EE application server so now the
second feature I promised to demonstrate
is Jersey test framework
before I do that I forgot to deploy the
my micro service on this device so let
me do do this now okay so let me get
back to the command line stop this this
guy and I will just go pay the flat the
fifth jar file over to the Raspberry Pi
device takes a while
hope it's still alive we can start
another session here so that I can
control
dumb with coping this is really Linux
this guy's Mac OS so you see the time
I'm talking to this device and now I can
try to do the very same thing that I I
did before I will start the application
take some time this is not as powerful
as my as my laptop so it might
eventually come out we'll see and I have
a question for you
I will show you the NetBeans code okay
so it started ok there we go and that
one who tells me whether this is going
to work but I can access the the
microservice from my laptop then I have
the t-shirt here
ok so raise your hand
cool okay well I'm binding to a local
host interface well I need to bind to
you know the external one so what's your
size large I got two t-shirts on its
large the other is extra-large okay so
you see how how to fix this I'm
consuming string argument and if present
and I use that your I instead of pretty
fine one okay so I'm going to get back
to this guy do you trust me that it
doesn't work okay
okay I'm going to this yeah that's it
now should hopefully work if it starts
so now instead of talking to localhost
and I don't have any user there yet so
takes a while it's many device it's not
a micro device its mini device so I have
mini service there okay so here we go
again
apart from that I changed the host name
it's again very same interface so this
now I can get a list of fusers okay so
we have seen that without the Java EE
application server I can work with these
devices the throughput won't be that
great but you kind of become by it's
quite cheap you know you can buy a lot
of these things and wire them together
okay so now the testing framework the
the jersey test framework so I don't
have any any tests yet because the
application is really simple but it
doesn't mean that if something is simple
you shouldn't be testing it so I'm I'm
cheating a little bit so I'll be at a
pre-written code so
I'm getting getting the cold and I am a
star with showing you the reload how the
tests look like in Jersey so
there we go so there is it that's
framework if you want to utilize it it's
as simple as just extending extending
the the Jersey test and then you can you
can write your test using using the
standard jax-rs client API so question
for you so how many of you are aware of
the test framework in Jersey Thanks no
not really
many people and you are probably using
it in your daily work I guess right okay
but a few okay so I just inherit from
the from the jersey test then I need to
configure the application so I'm feeding
it with the very same application that I
was using before this is because I I
need to tell there is the the base URI
if I didn't have this java application
server context path I wouldn't need this
but now just to keep the the very same
interface and the user management in
there in the URI I'm using it and now I
can I can start testing so the target
method will give me a target
that I can use and from from red one is
a standard jax-rs client API so
I am trying to access the users path the
user ID is one two three and I will use
a pre-populated user instance so what
I'm going to do is first I will just put
a new record into my simple service so
I'm creating a new request and I put a
new JSON entity there so with the
standard jax-rs API it's nothing nothing
important in in the context of this talk
and I'm just trying to see whether the
code the status code that I got back is
what I expected then I'm just trying to
know is it I'm just trying to request
the data back and see whether I am
getting the same data data that I sent
out previously okay so I can execute the
test from the IDE you see that I'm using
the J unit so it's it's quite easy you
don't need to you know start the
application server grizzly will get
started for you automatically and the
test has passed okay
well it works with Jamie but we added
recently added test energy support so
you can inherit from tests and GE you
know class and then it works similarly
what you get in addition is a parallel
execution support so we can you can test
multiple you know endpoints or resources
in parallel so it's faster no not yet
please
I I'm afraid I I didn't understand so
the question was whether there is a
documentation for this feature
sit up
no no I I'm afraid I think so
okay so 15 minutes left so I can get
back to the slides so we have seen a
lobby demonstration so it's based on
gen8 sng support available as well you
see a list of containers that are
available out of the box and probably
the most interesting part is the
external container support because what
you've seen when I are under test was
that Jersey test framework run its own
grisly instance populated the
application on it and test it against it
excellent this container allows you to
test applications that are already
deployed somewhere to just point to the
to the host the machine where the
application is running
you you tell Jersey which network port
should be used of course you you need to
activate the external test container
factory and no server part will be will
be launched so you can test whatever you
want you are not you know you don't need
to stick with Jersey server site you can
you can test application written in
peril for instance using this Jersey
external test container so I think I can
I can show you quick demonstration so
let me cheat again running out of time
slightly so I'm going to test test the
application that is deployed on the
Raspberry Pi
okay that should be it
so I am running the server at the the
test from this laptop and I'm talking to
the service that is already running on
the on the Raspberry Pi you can see the
URI here that's that's utilize okay so
you can not only test the application
that you are currently developing but
you can also test an application that's
available remotely in a remote fashion
okay and in this in this way you can you
can test also an application that's
deployed on an application server so if
I apply the application on GlassFish I
can run the test in the same way and run
against the GlassFish okay so let's get
back to the presentation here okay so
the last feature I wanted to demonstrate
is the monitoring support it could be
helpful if you need to monitor the
remote application and you want to know
something more than what the operating
system could could tell you about the
application so for that we have a
monitoring support in Jersey it could be
configured why are the server-side
properties that you set on the on the
jax-rs application so you either enable
the more returning statistics meaning
that you can infect an instance of
monitoring statistics you can create a
snapshot and you can ask some data from
it or you can ask Jersey to populate
some and pins for you so we can you can
connect to the to the application by a J
console or visual VM and you will see
some
autistics in there you can register your
own event listeners so what I'm going to
to show you is the the first approach
where I am going to enable monitoring
which is disabled by default I'm going
to enable monitoring and I'm going to
publish a special resource where I will
be publishing the request count so let's
go back to two minor bins
oh well to the command line because I'm
going to cheat again
okay so get back to that means I should
have a starts resource here so I put the
monitoring property on the on the access
application and now I can inject
monitoring statistics which is a jersey
type into my resource it's published
under stats your I it is the trick the
request count and here it's it's kind of
its kind of take a and complex but there
is a documentation for this feature
so I'm asking the the statistics to get
me request statistics and I want a
snapshot because I don't want to talk to
you know instant that is constantly
changing and I'm asking the time window
statistics I'm interested in what
happened in the last 1,000 milliseconds
in the millisecond and I'm interested in
the request count information and I am
returning this information back okay so
I will need to I will need to build the
application and then I will copy it over
to Raspberry Pi and I will show you how
it works there and what throughput you
could you could expect from such a
device so you have any tips how many
requests per second I will be able to
serve from from this no tips
hundreds 300 I'm afraid it you would
need to buy more more devices like that
okay so let me copy the word Raspberry
Pi
okay start this and we'll be waiting
those studs and start it yet start it
okay zero so it was for the for the last
second
I'm going to load this guy a bit okay
I'm going to access the users endpoint
or resource and I'm going to spawn 10
threads 10 connections and I'm going to
run this for 10 seconds to see the
number better I'm going to use a revenue
- okay never mind
ask the resource like this okay and I go
to sleep for two seconds I'm done okay
zero now load it one well it was counted
so now I'm going to load the application
and of course the hot spot isn't burned
up yet and so on but you see so this way
if you want to employ a watchdog service
you can you can easily make a runtime
information available for the outside
world from jersey from an application
running on on top of jersey and then let
me start it again born up a bit but weed
you won't reach even a hundred okay so I
hope you you go to point so we can you
can utilize internal jersey internals to
get this information and get it really
to to your consumers from Jersey okay so
stop this that was the last
demonstration because I don't have the
time for the last one an optional one so
there is a summary so when writing micro
services you can you can select jax-rs
for Jersey there are several
non-standard features that should
support you it should help you to write
your own micro services if seen live
demonstration of lightweight container
support namely the Grizzly and i/o
framework support you've seen test
framework so how to how to write a unit
test for your jax-rs resources and we
have also seen the monitoring features
in Jersey we have seen a simple demo of
the capabilities that are present in
Jersey
so there is more to come in future
Jersey versions the last demo I had
prepared was about CDI support in the
standalone standalone deployments so
that you can you can deploy in a fully
fledged Java EE application server using
CDI and then even such application you
can then take and deploy an efficient
that you have seen tonight so I didn't
manage to get it into Jersey before
jovan but it's it's coming soon I would
like to point you to several other other
sessions that could be helpful in this
regard so a client orchestration or
reactive programming by me holiday dosh
it's another colleague who works on
project jealousy and this is about if
you want to if you want to combine you
know several services or output from
several services and you know provide a
composite service then this could be
quite interesting it comes as a an
experimental feature in the current
Jersey version and I'm quite sure that
it will get into the to the main Frank
so to say there are some more sessions
on the list you can see so I believe we
got maybe two minutes for questions if
you have any okay
okay so regarding versioning and keeping
everything in sync I don't have a any
advice for you it's a hard problem and
I'm sorry for that nothing at the moment
and while we are going to invest some
energy into you know providing better
support for you know micro services I
don't think this is an area where you
are going to bring anything in a near
future I'm sorry okay so make sense to
to have all the services available at
the same time so that I can I don't know
ensure they works better or I test them
individually
okay so I believe in as I as I as I said
clearly defined boundaries so you can
test a single service you know at the
given time and I also believe in binary
integration so maybe just answers the
question but it's my personal point of
view you know yeah oh yeah yeah all the
version all the features that I
presented are available as this at the
moment so the last demo that was
optional was using a feature that is not
in yet but yeah everything else is
available
okay so thank you for your time thank
you for coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>