<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CON5118   Introduction to Modular Development | Coder Coacher - Coaching Coders</title><meta content="CON5118   Introduction to Modular Development - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CON5118   Introduction to Modular Development</b></h2><h5 class="post__date">2015-12-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/a99RmjgG5Eo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay welcome and this session is called
introduction to modular development and
it's it's one of a number of sessions
that we're doing in this room some of
you may be in at the earlier session
today on prepare for JD canine and that
was not dealing with module system but
it was dealing with some of the
implications of the module system in
this session we're going to introduce
the module and introduce some of the
concepts and Alex and I Alex Buckley and
I are going to do an advanced session
later on and after lunch and which
directly follows this one and then later
on today at five thirty and Alex Buckley
is going to do and under the hood for
the very very advanced session and these
first three are going to be repeated as
well so if you missed the first one you
can catch up on it later on in the week
we then up a hack session and in this
room tomorrow morning and just doing
some hands-on and take questions for
people to actually want to try it out so
this session as I say is an introduction
session and it's a it's a very very
intently introduction to two modules oh
and my name is Alan Bateman I work on
the JDK in Oracle we working on the JDK
forever for the last last few years been
mostly focusing on the on the module
system and the modulation of the GDK so
first slide is what is a module now for
this session we're going to be using
pretty dumb module names and in the
advanced session this afternoon we will
have more sensible and more real module
names so just bear with me for the for
the first half of this session where we
use these beasts own module names so I
want to start at the beginning on what
is a module and what is what is a module
well it's basically a self-describing
collection of coded data the important
thing from this slide is to know that it
has a name and we saw marks quino's you
would have picked up on this as well in
this example our module is called come
foo bar not very imaginative
what's in our module well it's it's it
it's a collection of packages all the
code in the module is organized by
packages in this module i'm just showing
the the names of four types there are
two different packages come foo bar
alpha there's an alpha and alpha factory
type in there and then there's a comp
fubar beta package with a couple of
types in that as well some modules will
have native code some modules will have
additional resources configuration files
I'm not going to deal with any of that
in the induction session we're just
going to talk about modules that have
code in this session the modules
description is expressed in source file
and called module info Java so in this
module system there is a file called
module in durant the module in photo
java that is in your source tree and
positioned in the by convention at the
top level directory of the source tree
so it for types in the in my module in
the first slide this is how they might
look in my source tree so this is a java
file a corresponds to each one of those
types module info java is at the top
what is in that module info java there's
the module and the module name and i
haven't said anything about what's in
that module yet so i'm just put curlies
too good to do and i will expand on that
as we go through the through the slides
so the syntax is module module name open
curly brackets and then we'll have
something that will describe the module
so the way I'm going to introduce these
modules is I'm going to start by talking
about dependencies and we move in them
in in the moment to talk about in a few
minutes to talk about encapsulation so
in this module info there's one or one
or more or typically one or more
requires clauses that indicates what
other modules that you depend on this is
very very simple in this example we've
got we've got come through bar we just
think of it as a library and it has a
dependency on another library come few
bars so with two modules now in in in
our slide so far if we had multiple
requires then they would be listed down
there
in there and we'll introduce a few more
modules in a minute that will have more
dependencies now I'm going to just
introduce a third module so we've had
we've had come full bar which is our
library depends on conf Lopez another
library now I'm going to introduce yet
another module come through app this has
a dependency on two modules come through
bar and Java SQL what is this Java SQL
for now just think about it as the
module in the Java platform that has the
JDBC API it's the one for accessing
databases in a module info for this
module I've got I've got to requires in
there that's corresponds to this little
part of the module graph that we're
seeing on the slide now let's expand
this a little bit and I've introduced a
module right down at the bottom in this
little module graph called Java base
java dot base is where the core of the
platform is this is where you find
java.lang.object every module depends on
java base whether you like it or not
because every module avenger if it is
code of course will will will will
somehow extend java.lang.object so these
dotted lines here are just to just to
point out that that there is always a
dependency on java base in this I've
built up my module graph a little bit
here or my dependency graph by including
the three modules that we've introduced
in the in the slide so far now going to
expand this a little bit further and
look at the Java SQL module so the Java
SQL module this might seem strange but
it has a dependency on the java xml
module and the java logging module we'll
see a little bit about the java logging
module in in a few minutes why does the
SQL module have a dependency on on the
xml module that is because there are
types in the in the JDBC API that are
xml types so there is actually an XML
sequel type in the jdbc API so that is
why that dependency is there all of
these modules they of course depend on
java base because as i said every module
depends on on java base so this is this
is this is our module graph now i'm
taking a little subset of that module
graph I've just taken just one little
part of it that was in the right and
they go back over on the right here come
thru Bart is equal to to logging I just
going to look at those three modules and
I want to start looking at what code
might be in in those modules just look
at those a bit more closely okay so
let's look at it let's look at the java
sequel module for starters so our java
sequel module has a class in there
called driver i guess most people
actually know there's a java sequel
driver that's one of the most commonly
used classes in the in the jdbc api it
has a public method in there that
returns a logger ok so the logger is in
this other module down at the bottom
it's in it's in the it's in the package
java.util logging I've now got code in
my application module that is invoking
that that method so it has a reference
to a java sequel driver and is invoking
that method so let me see how this works
so we're calling the gate parent lager
and then I'm going to invoke the log
method on the logger that the driver is
giving me ok so how do I relate to this
in my little dependency graph here well
I I can't see how that's going to work
because I don't have a dependency in my
come through a pipe module on the
logging module maybe I have maybe I'm
forced to introduce that dependency do I
have to do this that would be very
inconvenient for it for me because it
means that I now need to know the
transitive dependencies of any of my
mind modules that I depend on them and
if they've got api's are exposing other
types and other modules then I
gotta know about those that's not that's
not very intuitive and is a little bit
error prone particularly with if they'll
change over time so in this module
system there is this notion of implied
readability so if a module depends on
another module it's said to read that
module in this example what we do is we
have a module come through app that
depends on or reads Java sequel Java
sequel reads logging and the way for the
sequel module to be a good citizen and
let it's the consumers of its module
know that it's it's returning types and
some other are it's got method
signatures that are in some other module
is it declares that dependency in a
special way with call requires public
and what this does for the module system
is it means that the the the application
module here come thru app will read the
Java logging module this is something
called implies readability so the conf
loop reads the sequel module because I
require it and it also now will read the
Java logging module because the sequel
module has essentially we exported that
so now what we will do is we will add
these implied readability edges to our
module graph and and see where where we
get to so the new edges that are added
to that graph so I went from a
dependency graph now I've got my
complete readability graph these new
ages that I've added based on this new
concept of implied readability or these
yellow ages or orange edges in the in
this in this graph so there's one
additional one that haven't shown and
that is the confo app to java XML this
is also because of implied readability
because they because as I said a few
minutes ago that you have a sequel
module M has some types in there in AC
API that our XML types okay so that's
that's that's how we went from
dependencies to readability graph I now
want to actually look at another concept
in the module system which is which is
which is encapsulation
so in our inner inner in a module info
today's we've just been requiring other
modules this is this is this next
keyword that I want to talk about is the
is the exports if I am a library
developer I can essentially partition my
my module into to the API packages that
I want people to be able to use because
they are part of the API that I export
and then I've got my internal types that
are in in packages that I don't want
anybody to use so in this diagram here
I've taken the comm fubar module I've
divided into two I've got my comp foo
bar alpha and beta packages that is the
API that my library exports they're over
on the left my internal packages even
though it contains public types I don't
want anyone using these our own internal
to my to my module and these are not
exported so the module declaration the
way this is done is exports the name of
the package that I want to export so in
this module declaration there are two
two packages exported there are some
internal packages that are not exported
I'm now going to bring the two concepts
that we've talked about together to talk
a little bit about accessibility so
we've got our our application module and
we have our library module or
application module is come through app
our library is kung fu bar our capital
app module reads because it requires the
Kung Fu bar module and what this means
is is that it can access the public
types of in the exported packages of
calm few bar it cannot access anything
that is in the non exported packages so
this big red X arm on the right here is
these are my internal packages even
though this module come through app
reads my module it cannot access any of
the types in that module even if they're
public just to enforce that is legible
that read edged is is removed come
through app does not read kung fu bar
that means that no types within that
module
are accessible if I go back and
reintroduce the read edge they're
accessible again so the important things
to understand about accessible is is a
type is accessible if it's in a module
that you read and it's also a public
type in an exported package you have to
bolt together in order for type to be
accessible the main thing to take away
from this is the notion of public
changes with the module system alex has
for the under the hood presentation for
later on this afternoon and we'll go
into a lot of detail to explain or
essentially the different types of
public but this is a huge big change to
to the platform because there is code
out there that will assume that a tight
if a type is public it must be
accessible the module system changes
that so that's the one thing to take
away from this part of the presentation
around the concepts now I want to switch
gears a little bit and just talk a
little bit about and moving on from
concepts showing you some of the command
lines and star how you compile modules
I'm going to talk about running modules
and I also want to come back to the Java
sequel module and the Java logging
module that we had there to explain what
they are because they are platform
modules anyone that has come to to Java
one over the last couple of years will
have seen spaghetti diagrams this is a
cleaned-up version of the of our module
graph and where we have over time
cleaned up the JDK so that we can have
both standard and JDK modules this is a
nice this this may look complicated but
it is significantly nerd from where we
were a couple of years ago and there's
no cycles in this graph there's clean
dependencies we can build we know and
the the JDK a module at a time and it's
it's taken us a long time to get there
but this is what what we have at the
moment and in jeddah canine and in the
jigsaw bills
for those that have tried the jigsaw
bills you will actually be able to run
the list mods command and see the
complete list of modules that are in the
JDK the modules that start start with
Java dot something are standard modules
their java SE in the examples that we've
had to date have talked about java java
java base we probably see that in that
list it stirred of third or fourth one
down our third one down there on the on
the list if you search you'll be able to
find the java sequel the job xml or the
java logging modules we've been able to
divide the jdk and the standard api's
into the set of modules there are also
modules that are named jdk dot something
in this list here these are JDK specific
api's they're not java SE standard api's
some of these modules are tools some of
these modules or service providers they
don't export any API some of these
modules export jdk specific api's in the
in the presentation this morning where
we talked about internal api's i
introduced the the idea are about java
disturbing standard and then sun death
star being internal there is in the
middle there's a bunch of api's that are
comes on something and there's endless
confusion as to whether they're
supportive EAP is or not module system
fixes all of that by making it by having
a clear that only the supported api's
will be exported by these modules so if
you try out the jigsaw bills you'll be
able to see the full full list of
modules so I want to move on now and
just show some of the the command lines
to we first start compiling some modules
and then we start running and see how
they are comes together okay back to the
example that we had in one of the first
slides I'm going to compile here one of
the the leaf modules which is the comps
on Baz module I'm this is the Java Sea
command to compile this and java sea
takes my java source compiles it and
outputs
a corresponding tree of dark class files
and this is exactly what happens when
you're compiling a module the module
info java gets compiled to a module in
for that class in the build-out put
whatever director you want to call it in
this Java Sea command on the the dash D
here if you're familiar with the Java
Java Sea command line then that's what
the output directory is and by
convention we're using the module name
as the directory and for well both the
source and the output / destination
directory so this is one Java Sea
command to compile one module before I
move on and explain some other Java Sea
commands I need to introduce something
called a module path this is the module
equivalent of a class path if you like
there's in in the module system and in
the jigsaw bills there is a new command
line option called module path there's a
shortened form version of it NP so we've
got class path with a CP the value of
the module path is essentially eight is
a sequence of directories where to find
modules when I want to compile a module
or want to run module and oh where does
come fubar and I have to go and I will
be able to search through the module pad
to find it we later on in the
presentation i'll talk about packaging
and some other details but let's just
assume it's a sequential search through
first directory just like module exists
you know it doesn't second directory
does it exist no doesn't third directory
or degrees that is where the module will
be found so it's it's a familiar concept
of how do you find modules and for those
are familiar with the with the classpath
there's a number of significant
differences between this and the
classpath and and that you cannot have
multiple modules of the same name in the
same directory so if I put two versions
of some module in dear one module system
said no can't do that can't figure out
which one you want and so it avoids
those
kind of errors so now that we know what
a module path is we will introduce it
into the Java Sea command that we had
and we will compile one of the other
modules so remember in earlier module
graph that we had we had come fubar
depends on kung fu baths how am I going
to compile count fubar because it has a
dependency on this other library come
through bass so the way this works is
and i'm going to same Java Sea command
but I give it the module path so that it
can you can look in that module path to
find the modules that I depend on and
exactly the same as the previous example
we go from Java too dark glass same
conventions previous ease the directory
names on both the source and the output
is is the module name now I'm going to
move on I've got I've got my modules
compiled let me see how I'm going to run
them okay here we have a new command
line option dash mne to give it the
mainland main module our initial module
this looks a little bit complicated will
simplify this as we go through the some
of the some of the other slides for now
just bear with me java sea has a module
path option java launcher has a module
path option the main application module
is come through app the main class in
that module is come through at main dash
mne i want i want to run this module and
this is the entry point or the main
class in that module and that's what
this syntax module / main class is as I
said we make this simpler in in a few
minutes
I want to show what happens now when we
run this my mink my initial module are
my main module is calm foo app it has a
dependency on console bar on Java sequel
and of course you have a base because
everything depends on Java base so what
happens is it locates module come
through app it has to look it has it
looks at its module descriptor has
figures out what it depends on then it
has to work compute the transitive
closure to to get the full set of
modules that are in this module graph so
it's essentially generating this module
graph when i run the java dash M so I go
from here to here and this is my my m-my
module graph again that we had earlier
on in the presentation this is all
computed at startup and when I run the
run the main application so the
important things from that is is because
it's located all the dependencies
transitive dependencies we know that
there's there's nothing missing and when
you go to the advanced talk or we go to
the duty to do in their hood we can
actually prove a whole bunch of other
correctness issues around this module
graph I'm not going to get into it in
this presentation and we can ensure that
we're actually starting up with what we
call a reliable configuration if you're
interested to see what really happens at
startup and see more of the detail
there's a diagnostic option so if we're
playing around with the the jigsaw bills
in at the hack session tomorrow morning
this might be one of the things we might
actually try is runners with this X
diagnose ulver option which is
essentially a diagnostic option to get
us to do some true print out some traces
during startup so you can actually see
where it locates the modules and what
depends on what you see a whole bunch of
other details the output that you see
from that tracing option is essentially
how it's actually building up this
little graph that we had on the on the
previous previous slide
okay everything that we've done so far
has been very basic command line compile
got my output directory everything is
exploded on the file system I want to
spend a few minutes just talking about
packaging and my modules because its
packaging packaging is important because
I don't want to be shipping drown a big
tree of class files around the place
okay jar files we're all familiar with
jar files I hope and we can package up a
module as a jar file we call it a
modular jar a modular jar is it's just
like a regular library except it has a
module in for that class in there that
is the compiled form of the the module
in photo java I've got a command here
this is this is an updated version of
the J of the jar tool so the jar to
Allah has been upgraded very
significantly in the jigsaw bills to
support a whole bunch of new options
related to to modular jars so I'm
creating my jar file with this command
so there's a dash dash crash which may
be familiar with GRC this is exactly the
same thing give it the name of the
archive in this case I'm konev I'm going
to and packaged up the application
module into a PR I'm going to use this
option to indicate what the main class
is so as part of of packaging I can add
other information another metadata to to
the module and one of the things i can
add to the module when I package it up
is indicate what its entry point is so
this this example the entry point is
come through ab main so i'm going to
indicate that when i'm creating the jar
file and then I package it up and I've
now got a modular jar let's look at a
modular jar so though there is a print
module descriptor or the shortened
version of that is dash p where i can
look at the jar file and I can
understand what its dependencies are I
can understand what it exports its this
is the because for this example I've
packaged up the main application it
doesn't actually export anything it's
the libraries that it depend
done export some API packages and what
for a main application I can see what
its main class and there's other things
in a more advanced example we might see
being printed out from this so this is
this is really useful because if I've
got a jar file as packages a module I
can see exactly what it depends exactly
what API that it provides now we will go
back to our Java dash mne and see how
this looks our command line has now
shortened a few minutes ago we we had to
go into we had to specify to the Java
launcher what the main what the initial
module is what the main class is because
the the initial module knows what its
main classes I don't need to specify
that so this gives me a shortened
command line which is which is nice so
what our module are modular jars have
have another wonderful property in that
it gives us a story for how you can have
a library that works in eight that works
on the classpath with eight who worked
as a module in nine that is an important
thing to understand about a modular jar
file the module info remember its module
dash info isn't isn't the Java isn't a
valid Java identifier it's not gonna be
recognized as a class file and by older
versions of the platform it will be just
ignored so what this means is is that I
can exploit that to be able to have a
library that works in eight and nine can
you work on the classpath artwork in the
module path so this is all part of the
migration story and we'll be talking a
lot more about migration be in the
advanced talk later on so I'm going to
come back to one of my exact my
libraries which is the Baz library it's
packaged as a modular johar but I'm
going to use it on the classpath and it
just works big now there's an assumption
here that I've compiled that library
targets source target eight I haven't
our dash release age if you're using the
newer version of java sea of course if i
compile it for nine and i put it on the
class path of a jdk 8 installation
it's going to complain that the class
while version will eventually complain
the class while version has been raved
and doesn't recognize it but assuming
I've compiled it for H then I can use it
as a class as a regular jar file on the
classpath now I'm going to take that
same jar file and I'm going to put it on
the module path in nine so all of my
library's now are on are on the module
path in this example so my bass has been
loaded as a library here as is the main
application and the other libraries one
other thing we can do and this is it
requires a little bit of a deep breath
but we can actually mix the class path
and the module path and this is also
important for migration because over
time you would like to see that the
common libraries will get migrated to
modules what the rest of the system
hasn't been migrated to modules and so I
can i can continue to have the rest of
the system on the classpath as before
but anything that has been migrated in
modules I can have that on the module
path now this requires a little bit of
thought because RN I'm not giving it an
initial module remember when I'm in the
previous slides where i showed the
module graph and what happens that start
up there isn't an admission module to
think about here and there could be a
thousand libraries modular jar sitting
in that M Lib directory how do I know
which ones to that I'm supposed to to to
load and this is the reason this example
has an add mods option I need to tell it
that I want to make use of this this
module kung fu bass there's nothing in
in my code on the classpath that tells
me what my dependencies are and
therefore i'm mixing the classpath and
the module world so the dash I'd add
mods is telling me what these modules
that need to be resolved and Tom few
bars if it got all these other
dependencies they will get resolved thin
as part
the this initial startup process that I
talked about okay so that is that is a
little bit of introduction to some of
the possible migrations I next one to
spend a little bit of time just talking
about linking and so for those that were
here at the prepare for JD canine talk
this morning I talked a bit about JEP
220 and the modular runtime image i
mentioned teaser in that that the
possibility that we could actually take
an application a bunch of libraries and
create a custom runtime image that
contains only the parts of the jdk that
that application needs and i can do that
through this process of linking the
linking and a linker is something that
has never really existed in the java
ecosystem we've always had compiled two
classes than we run with the maybe some
packaging in there of course there has
never been a link step in there what the
module system it brings along is an
optional link step where we can actually
link a bunch of modules together to and
the current linker will in the in the
current bills will generate a custom
runtime image with just the modules and
their transitive dependencies that you
need so uh oh I didn't move on and just
sure what it actually looks like so more
slides on this in the previous talk but
essentially just think about it is I've
got a set of modules the transitive
dependencies I'm going to produce a
modular runtime image module runtime
image think of it as like a Jerry but
it's a modular Jerry and it has a bin
directory for launchers it has a
configuration conf directory for a user
editable configuration ignore everything
else in it because it's its
implementation specific this is the way
the JDK 9 bills and are actually been
shipping for the last almost almost a
year now we've moved to this module
runtime image got rid of the RTR tools
that you are everything is in much more
efficient
representation in in the runtime image
and this is the module image and the
module image is not limited to the GRU
jdk it can be any set of of modules okay
I hope this is readable at the back this
is aj link command to create a runtime
image that has one and only one module
java java dot base java dot basis the
core of the system it does not depend on
any other modules what i'm doing here is
i'm running the jailing command that's
the j link is that is the linker and it
has an option to give it the module path
what's that far is to where to find the
modules there's an add mods just like
java add mods which is what modules to
add to this to this when we're creating
this image and i'm giving it an output
directory as to where the create the
image this is the most basic jailing
command that we have and will create a
runtime image and when i run the java
let's mod so you might remember in one
of the early slides editor javed list
mods on the full jdk and i had a screen
full of java dot star and jdk dat star
modules this one runtime image that i
have here is contains only one module in
a bed system this might give me a
runtime images only 10 or 12 megabytes
and that's that that's really nice now
let's move on for a jail in command and
i'm going to create a runtime image with
my thru app module now my come from
app module remember a little module
graph it depends on on come full bar
which depends on conf you bears and
depends on java sequel and xml and
logging we will create a runtime image
with that this module all of its transit
dependencies will be linked in and we
get a small runtime image that only has
eight modules in it but that's really
really nice so we see what we see from
this is that i have created runtime
image that has java modules and our site
JT Kmart or sorry standard modules and
also some of my own
libraries and also my own application
and they had been linkedin linkedin
together okay I've run ahead of myself
and this is where I've ended up on the
on the we had more sessions slides in
here on testing that we thought were a
little bit too advanced we move them to
do we talk about them at maybe at the
hack session to tomorrow but the main
thing to take from this session I
realized was shorter and then you might
have expected is just really wanted to
introduce you to some of the basic
concepts that we've talked about modules
module is a name it his declares its
dependencies it declares his exports and
also introduce you to to some of the
basic commands that we have with Java C
and Java and the fact that they're being
they're being modified to support and to
support modules so we're back in here
again at two thirty Alex Buckley on
myself for doing the the advanced
session and this one is primarily
focused on on migration we go to get get
into a lot more detail on how to move
libraries to modules alex is back here
then again at five thirty again this
room to do an under the hood which is a
more advanced session and then we're
back in here tomorrow morning for some
hands-on and for those people who
actually want to try out chick so we
take questions
more information so two links project
chicks are page in in OpenJDK has a link
to all of the jets and all of the other
material and documents that we have
there's the mailing list chicks are dev
list and there's also a link there to
the early access bills you can just
google for them if you can't read it
from the back and that is early access
bills so that's it so mark you want to
come up for so mark rhino was supposed
to be talking today as well so he's
going to come up and help answer
questions if there's questions okay
there's no microphone so what we did in
the earlier session is is either
repeated our come up and read into the
microphone or shout into the microphone
I was going to ask is the public not
accessible thing at only the runtime are
also on the compile time okay so the
question is is is the if something is
not accessible is it is it is both
non-accessible at runtime are also
compiled and the answer is both yes I
should have made that clear during the
talk yes so you will actually get a
compilation failure if you actually
attempt you've got some reference to
some type that's in a non exporter
packages your code won't compile and
then if you do compile it to some ways
then it'll fail at runtime and that
comes into effect only when you create
the module class right until you create
the module class public still gets
compiled okay I didn't quite catch did
you say clear you have to create the
module class which actually defines the
recurrence and exports yeah you create
that it's still accessible right if it's
if it's exported and it's public and you
have a dependency on that module then
then then your code will compile and run
okay this
speaking to the night please we're on
our videos too okay so there is no more
runtime accapella time dependencies
everything is is both that is okay so
that it's for the recording is the
question again was is what whether these
module boundaries applied to both
compile time and runtime and the answer
is yes and does this make osgi like
redundant maybe are coming this seems
very similar to osgi concepts where you
export and import the the packages could
we get the mic the podium mic thanks
thank you there are some similarities
but this is quite a different module
system in the no SGI osgi does a whole
bunch of other stuff that maybe you need
but often you don't and and os Dre it
doesn't do some of the things that we
need for for modular izing the platform
itself so that's why it's different
thank you so is there any solution for
optional dependencies yes the solution
for optional dependencies of services
yeah we in in earlier prototypes of
jigsaw we actually there was a notion of
optional dependencies but we found out
the working out the semantics of them
got really really hard and I think Alex
I'll ultimately convinced us that was
just a bad idea and at least our
experience in the JDK and some other
other code bases we've looked at is when
something is optional it's it's often
very straightforward to refactor it as a
service and the in fact modules the
things we haven't shown today are you
know models can also declare that they
provide services that they require
services and that's all hooked up with
the existing service letter API so if
you need some some optionality like that
services are generally the way to go
hi to two small questions about j-link
first it creates a build that is
specific to the platform in which you
ran jailing yes you run it online next
you'll get a Linux builds no no option
to if you run evanlynn Excel to generate
a magnificent ok so the yeah so there is
crowded yeah you can you can build it
for other target platforms them the most
obvious is is when you doing cross
compilation to linux arm or something
like that you're not going to run the
tool on the embedded system you'll run
it on some hope system sorry and is
there a way to for instance in NJ link
itself specify the main class to run so
so that you don't have to run that
specific java binary invent specified
the main class i basically solve the
problem of ripe self-executing java
right so in the current version does
actually generate a very basic launcher
that is the name of the application
there's more work would be needed i
think to make to make this a bit more
smarter and integrate properly with the
de need the the new tool chain what it
does actually generate a rapper at the
moment around java for the application
anything that has a main class J like
Jane link is is not is the foundation
for for other tools as well for example
the the Java packager that was
originally originally started out as the
javafx packager is being enhanced their
rebasing that on top of j link so some
of the the additional stuff that you
need to do in order to build you know a
ship abul mac app that you can put in
the in the mac app store is will be done
by a java package or it'll use jailing
to get most of what it needs and then do
the additional really mac OS specific
stuff for that so that there would be a
JEP on jailing soon as it's in the
jigsaw bills but there isn't a big
detail JEP the car that we have to add
that sand to that will detail all of its
capabilities and options thank you
will you be able to version module so
baby so free version he is a versioning
is a fun story and I compaq Amon topic
do you answer this you oh it looks so
very simple attitude two versions if I
see them coming down the street I go to
the other side of the street yes so are
you know in the proposal are the initial
view we've taken on versions and this is
after after again it means experience
with prototypes where we had very deep
support for versions is versions are
different from the perspective of a
module system embedded in the vm and the
language versions are almost
extracurricular right there there there
useful information we have a way to
embed a version string in a module when
you package it we have a way to you know
to query it you can get you get the
version string out you can compare them
so there's at least one only one one way
to order them and compare them but the
view we've taken at least for now is
that versioning is this fantastically
hard problem that other tools like maven
and IV and Gradle have solved maybe not
great but well enough and we don't see a
need to replicate that that kind of
solution or try to do an even more
perfect solution involving a Sat solver
or something really high-tech inside
both the compiler and the vm that seems
like massive overkill so the general
model here is we we're not trying to go
out and replace the existing ecosystem
toolchains we don't we're out trying to
replace maven or IV or Gradle trying to
provide a foundation upon which they can
build so it will still be up to your
build tool to help you select versions
deal with version conflicts and so on
and so forth and make sure you get all
the right modular jars on your module
path once they're there then the module
system at both compile time and runtime
will do the right thing it will be able
to report
version strings as you know
documentation in exception messages and
so forth but it will not simply will not
try to do something clever when it comes
up up to a conflict it'll just say up
not you have a conflict go you know go
fix your palm or whatever you need to
fix to make it work right now is this
the absolutely correct view maybe not
but when we realized that this was a
potential way to simplify what we're
doing we found it incredibly attractive
Oh performance engineer so my
perspective is warped um at any time
good job where's the not your gcng at
the java sea level or the j-link level
look you do cross module optimizations
like inlining or constant propagation or
anything fun like that absolutely that
is that is one of the longer term plans
for J link is it one of the really
attractive things the ability to do
whole program analysis you've got all
the modules both models from the JDK
from your application from libraries you
got from they've been central whatever
you can jalen can look at the mall it
was in fact j link has already has a
basic plug-in architecture so you can
plug in things that will do filtering
like you throwing out debug symbols or
or doing some basic optimizations that's
part of the long term follow-on question
is do you allow dynamic class loading
and it does it ever invalidate any of
those optimizations do we dynamic is
there if so many cons together a class
path to something that wasn't in the
modules does it just throw an error or
oh no the classpath is still fully
supported if you have an application
that spins up custom class loaders URL
class voters you know something else
that that that'll still work the
classpath is still there if you come to
the next session you will learn or is it
the next session er that were under the
hood ah the next year wat sorry um it
was alright is it is it advanced or
under the hood that's right in under the
hood Alex will explain how we deal with
class baptism so the class fat is
treated actually as a very very special
is it an instance of a very special kind
of module it's an unnamed module kind of
like the unnamed package but what if
that melody
some of those optimizations she did in
jail Inc oh you what you would want it
won't it won't invalidate them because
we will we will be able to detect for
conflicts hi your example was good but
it is really particular to one module
what about third-party systems third
wheel we use a lot of third-party
libraries right they may not have
migrated to module ahaha come to come to
the advanced session right we deal
exactly with this took this this
discussion in the in the advanced talk
or 230 yeah we've thought about this a
lot yep it's to tourney here in this
room oh sorry for the fruit for the
recording maybe it wasn't picked up is a
question was what about all these
third-party libraries how can you make
those modules and the shorter answer it
is in many cases you don't have to right
away so how does the module system and
change J&amp;amp;I bootstrapping how does the
module system change J&amp;amp;I bootstrapping
okay so startup is very very different
but if you're using a few me Jay and I
bootstrapping I presume you mean the jni
invitation API it works exactly the same
as before and if you've got your own
native launcher then it can pass in
these these options to specify module
path from them it just works how did the
new visibility rules interact with
introspection there are no new
visibility rules uh okay okay cut cut
come to under the hood right
question suppose I want to have access
to a class in a package that is not
exported from there anything I can do to
override this restriction is there
anything you can do to override the
restriction when a package is not
exported yes you can use a command
command line flag to break encapsulation
yes we use this by the way in the
prepare for JD canine talk this morning
and so you might get the recording you
that or get the repeat later in the week
so then when you define it do you have
to say Amy C or it can be it'll be it'll
be looked up that's all me a tran tran
transitive closure for the win yes out
of curiosity how does the public
non-accessible classes work for javadoc
is that still an be me sorry preferred
generating javadoc so i can be inscribed
the same way so so wait so we are we are
upgrading javadoc so that it understands
what modules are and displays you
displays modules along with packages and
classes and everything else and if a if
a class is in a package that's not
exported then by default javadoc will
not generate any documentation for it
ok I think we're kind of glad it
finisher because one more digger later
okay okay I think we're done thank you
thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>