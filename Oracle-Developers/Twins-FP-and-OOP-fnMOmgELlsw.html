<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Twins: FP and OOP | Coder Coacher - Coaching Coders</title><meta content="Twins: FP and OOP - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Twins: FP and OOP</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/fnMOmgELlsw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">yeah so my name is Richards I'm gonna be
talking a little bit about kind of the
relationship between object-oriented
programming and functional programming
so we've got kind of lambdas in Java so
there's a bit of a move towards
functional programming so let's have a
look at more the kind of big picture
design e architectural bits and bobs so
just a brief overview of the talk
structure first I'm going to cover you
know what's really the motivation what
the heck am I doing here then I'm gonna
have a look through the solid principles
quick hands up who's heard of the solid
principles before fantastic that's most
the room if you didn't have your hand up
that's great you're just gonna learn
more and then we can have a look through
a couple of design patterns and see how
those design patterns kind of relate
between like a an object oriented world
view and a kind of functional world view
and then I've got a section entitled
anthropology by which I actually mean
I'm gonna have loads of pictures of
Arnold Schwarzenegger so that's going to
be fun
so just to kick off like if you look
around kind of you know the programming
community and people on the internet and
possibly co-workers you've got a
relationship between people who are kind
of like more the object oriented
programming side of you more the kind of
Java C++ may be small for Ruby type guys
and the functional programming people
and you sometimes see a kind of level of
disdain and hatred which you know is
epitomize in in this picture or you can
also kind of look at it from a quotes
point of view so here's a kind of more
functional world view here like
object-oriented programming is to
writing a program what going through
airport security is to flying so you
know complaining about the additional
verbosity and the the things that you
are being forced to do which aren't
necessarily relevant and another guy
here talking about static typing TDD
replaces of type check and Ruby in the
same way the strong drink replaces Saro
fantastic you can't get rid of this on
the other toy on the other
of things you kind of get a bit of a
perspective from object-oriented
programmers these human of elitism and
lack of sympathy from the functional
programming community right brain
explosion is like a traditional pastime
in hash haskell referring to the IRC
channel anyone anyone have some kind of
sympathy with these kind of different
perspectives or felt that they've kind
of seen this kind of thing before
a few people yeah yeah and then is it on
the classic quote some people claim
everything is Lisp one time I was eating
some spaghetti and someone came by and
said hey nice Lisp dialects you're
hacking in there
fantastic so I guess my viewpoint on
this whole thing is that things are
actually a little bit more like this
fantastic picture here you know there
are different things that we can take
from both paradigms and different kind
of ideas and concepts we can use in
day-to-day programming and maybe if we
pick the best of both worlds we can come
up with you know cleaner nicer easier to
read code so the other caveat about this
talk is because I'm going through kind
of design patterns and solid principles
although some of the kind of more
traditional interpretations I'm going to
putting more different perspectives or
things on that so it there you might not
get the most classic Orthodox
definitions for some of these things so
let's have a look at the solid
principles they are basic kind of
programming guidelines things which the
overall goal is to make things easier to
maintain and change and kind of go for
these kind of loosely couples but highly
cohesive programs the kind of sentence
that we all talk about a lot but
sometimes when you actually code in
practice it doesn't quite work out the
way you hoped and they're also in some
sense a guideline to remove code smell
so that's like a bad thing and we're
trying to avoid that bad thing the s in
solid is the single responsibility
principle so that says that each class
or method or kind of unit of things
should have a single responsibility and
a responsibility here is not like it's
doing one thing in the sense of its
managing or the program state that's not
a single responsibility that I'm sure
you've all heard co-workers try and
convince you that a class is really
doing one thing when that one thing is
everything or like it's just keeping the
earth continuing to spin that's one
thing no responsibilities are a reason
to change an idea for altering or
improving your program and the other
idea about single responsibility
principle it's not not only should you
only be doing one thing you should be
the only thing that's doing one thing
you should be encapsulating that
responsibility so here's some arbitrary
code that's calculating whether
something a prime in an incredibly
inefficient manner fantastic stuff I'm
sure you're all looking at that code and
making that kind of facial expression
now it's significantly easier to read if
you just lit it up like this and say
you've got some of this checking whether
a number is a prime and another method
which is counting the number of primes
up to a certain number but to my mind
even that code isn't really implementing
kind of single responsibility principle
because this code here is inherently
single threaded okay there's no way you
can take this and paralyze that you
coupled the kind of business logic that
you're doing in this case the business
logic just happens to be counting
Prime's with the threading model of your
application you've got like an
infrastructure concern on one hand an
application concern on the other now if
you flip this around and and rewrite
this counting Prime's to be using
streams API so what's going on here is
you've got some number you've got a
range of integers between that one and
that number you're checking whether
those numbers are primes and then you're
counting up the ones that have the paths
through your filter and your in your is
prime method is checking the number of
that range and then checking that all of
them are in a situation where none of
them are modulo two now this code is the
kind of code which you can easily flip
to be parallel code just by calling
parallel in there
Yuchun you're really only doing business
level concerns and the collection
processing and underlying data
processing concerns are actually being
delegated down to the stream processing
library so that's a bit of a different
perspective now the way that's actually
being implemented is through higher
order functions correct hands up who's
heard of higher-order functions at some
point in time so higher-order function
is a function that takes another method
as an argument or returns one as its
result so in this case we had all those
things like filter and all match and
they were taking lambda expressions as
arguments and then that allowed them to
parameterize themselves over some
behavior that was being controlled by
this function so I'd contend that it's
really hard to write kind of single
responsibility code in a kind of very
purist manner of a for Java rate because
you're kind of discouraged from having
these kind of extreme separations of
concern and actually to do it you really
want the ability to pass around behavior
conveniently and easily which is what
you're getting from lambda expressions
so the open closed principle means you
can talk to people who are in jail
more seriously the more kind of more
formal definition provided here by
Bertram air is software entity should be
open for extension but closed for
modification anyone know what Bertram
mayor was actually referring to
originally when he when he said that
quote something you know sort of
something I for ya Bertram mayor is the
guy who came with the I for programming
language anyone else so you have this
kind of idea which is like a very kind
of like late 80s software engineering
idea but you had a class and you
completed working on that class and then
you never modified it after that point
and the only way you modified it was by
sub-classing it which kind of sounds a
little bit crazy in 2014 right there's
you know
requirements change and agile
methodologies and things have moved on
so what we actually kind of interpret it
as is a little bit differently I'll come
out in a sec so
to explain that let's have a look at
some kind of concept let's consider that
you're graphing some metric data about
your machine so the amount of time that
you're spending with your CPU during can
I use a time system time the amount of
disk IO all sorts of things and the
modern interpretation of the open-closed
principle is that what you're really
doing is polymorphism so in your display
you don't end up hard coding these kind
of specific metrics like what CPU usage
values are or the whether a process is
doing disk write or whatever you depend
upon some kind of abstraction like a
time series of data and then your
graphing display when you want to add it
new time series or new sets of values
you can just implement so you have
something else that just implements your
time series interface and then your you
can use some kind of polymorphic
dispatch on a method and depending upon
what metric is going and getting the
data out you get a different value and
what that means is say you want to add
the amount of time your machine spends
worrying away and swap when all your
servers slow down and you hear a lot of
hard this grinding noises you don't
necessarily need to change the outside
class so it's it's it's open for being
extended by adding new things but closed
for modification now a more kind of
functional programming perspective on
the open closed principle is that
higher-order functions are something
that implements the open closed
principle so co-captain here is anyone
familiar with the simple date format
class in Java does anyone like the
simple VAP format class in Java does
anyone passionately hate the simple date
format class in Java fantastic we're on
the same page one of the reasons why I
personally like it is despite the fact
it's a formatting class it's not thread
safe okay so if you have a date format
and you start formatting a date on one
thread and you use the same object on
another thread you might have the string
that gets output at the end might be
like the the day in the month from one
thread and like the hour in the minute
another threat which is a really very
very confusing bug to see especially
since it's probably not going to happen
in your unit tests so something you can
do is use the the thread-local class
everyone familiar with thread-local in
java most people okay so thread local
value is basically a kind of cache which
says if you get the value out of your
thread local object there's only going
to be one associated with your thread
local so if you're using simple date
format you can put it into a thread
local value and then you can be
guaranteed that you're not going to have
this horrific hours from one thread
months from the other thread kind of
problem so when you got here in Java
right so a higher-order function with
initial defined on the thread local
class that takes in a function that's a
factory so this is basically saying
build me a new instance of whatever so
what that means is that with initial
function is in some sense you know
closed for modification none of us are
going in there and changing the JDK
source code or at least not this method
in particular but you can go and have
your thread loop you can use that fun
you can use that function to produce
values which can do all sorts of things
so here's our one simple date format one
here's a value that's getting you a new
ID for each thread from some atomic
counter so you've got a situation here
where you're close the modification but
you've open you're open for extension
another quite kind of functional
perspective on the on the OTP type stuff
is immutability anyone used immutable
objects on their kind of domain model
regular basis fantastic now you know of
an immutable object is you can't modify
it once it's been created so you know
the one of the big kind of uses and
benefits of immutable classes is they
are well if you use final sonya fields
they are thread safe for publication so
you can create these objects you can
hand them around you can do all sorts of
things
and you know that whatever is happening
on some threads won't break others but
they're also really kind of compelling
tools for doing kind of domain modeling
type stuff and you know something which
you see encouraged a lot in the kind of
functional programming community
the point is that if you've got that
value and you're passing it around you
know that whatever you change with one
consumer of that object on the one side
or whatever you do with it over there
isn't going to break code over here so
again you can add arbitrary numbers of
additional methods and functions to your
immutable class and know that you're
still safe you're not going to break
other things on the other side there's
another way in which it's implementing
OCP
so the Liskov substitution principle
that Q of X be a property provable about
objects X and type T then Q of Y should
be true for objects Y of type X where X
is a subtype of T that's the dictionary
definition and anyone who reads it is
guaranteed to make that face that's a
fact once you read it you have to make
that face what they really mean is if
you've got two classes and one's a
subclass of another one then the
subclass behaves like its parent that's
a slight simplification but that's
basically the point we're going for so
what do I mean by behaves like its
parent we mean that no preconditions are
going to be strengthened so where the
parent worked the child will work no
post conditions are going to be weakened
so if a parent was doing something or
causing some kind of effect then the
child should where the parent always
stuck by something and the child should
so there's maintaining of any invariants
and there's the concept you don't don't
go mess with things that your parent
class wasn't responsible for changing
side note here if you substitute parent
and child for people you'll notice the
relationship with people is actually the
complete opposite way around for a more
functional programming perspective
inheritance isn't that P a factor to
domain modeling with functional
programming is in fact a many functional
programming languages that hard core
inheritance doesn't even exist
and if you don't inherit things very
much then you don't need to worry about
the set of complex properties that you
should be maintaining as part of the
Liskov substitution principle in fact
it's become so popular it's already kind
of moved over into the low realm as the
kind of composite reuse
principal so composed don't inherit
anyone anyone heard of the composed and
inherit type stuff it seems to be
getting a lot more popular something you
know come along as well anyway so the
interface the interface segregation
principle the dependency of one class to
another one should depend upon the
smallest possible interface good old
Uncle Bob he's not really your uncle so
just to explain what the interface
segregation principle means let's go
through a running example now in our
Factory we've got some kind of interface
representing a worker and our workers
going to go home at the end of the day
and during the day they're gonna do some
work and our assembly line is going to
depend upon some kind of worker there's
going to be an assembly worker and a
manager now I know what you're thinking
managers don't do work but for the
purpose of this demo they're going to
implement the interface okay so in a
theoretical example yeah so at some
point in time we get introduced some
robots into our assembly line and the
robots they don't need to go home they
don't have families or and anything like
that it's not the Bicentennial man
and the interesting point about this
here is that most our programming
languages use something called nominal
subtyping quick hands up who's heard the
term nominal subtyping one guy
what about structural subtyping okay
what about duck typing a few more okay
okay cool you'll be your cat only in a
couple of slides it'll be good so normal
subtyping means if you've got these
classes called foo and bar and foo is
going to be a subclass of bar then you
actually need to see somewhere in your
code base like through extends barfoo
implements bar you're going to
explicitly make a relationship between
those classes in code by writing
something down based upon the names of
those types they're going to have a name
and you see the injera c++ a lot of kind
of static types are our languages now
fasten our worked example is we see our
assembly worker implements worker
manager implements worker robot also
implements worker when we add our worker
in in our code we explicitly define that
interface that we're depending upon that
the name of that type and then in our
client code we're adding in the
respective implementations the other
option to normal typing is structural
subtyping which is also the the kind of
dynamically typed version this is called
duck typing so if you're familiar with
duck typing you kind of have a bit of an
idea what's going on here now this means
that the relationship between something
whether it's a sub class or whatever is
implicit you don't explicitly say
extends or implements or anything like
that and it just depends upon the shape
or the structure of its type so what
that means is if you've got a method
where you're calling the get foo on that
object that's not a fool object all it
means is that object these are methods
called get food ok and I've gone for a
somewhat pejorative statement here on my
slide of saying it's common in wacky
programming languages so oh camel go C++
templates and familiar with C++
templates anyone hate themselves for
that period of their lives when they try
to you see purpose right yeah yeah yeah
there's some good ideas here and and
Ruby has the duck typing variant which
is kind of the dynamically typed variant
now in our here's this as a kind of
scholar version so here is our our new
worker class it doesn't need to
explicitly say implements worker it just
defines a method called work that takes
its production step whatever it whatever
role of it
here is our ad worker method which
doesn't need to say it's implementing an
interface it can just say something
about its type here so what this means
basically is it's a class it's got a
method called work on it that takes a
single argument like that and then these
things go on so I mean that's an actual
Scala code now
you don't need to have those types
explicit so in some languages you can do
stuff like this you just plop a worker
into your list and you can do these kind
of things so there's a lot more
flexibility by going down the structural
subtyping routes because you don't have
to worry about this explicit naming
relationship you can pull in things the
Jeff implement that just have these
methods on Java rick has a kind of
interesting spin on things with
functional interfaces so a functional
interface is an interface with a single
abstract method and wherever you see
kind of lambdas in people's code samples
all over the place the method that
they're passing that lamdaur into or the
local variable but they're assigning
that lambda to has a functional
interfaces as its type interface with a
single abstract method and that method
corresponds to the body of the lambda
expression since we started on interface
segregation principle this is by
definition the minimal interface for
whatever you're doing right it's only
got one method and the interesting thing
about the way lambda expressions get
kind of tight checked and typed and the
type inference works in Java rates is
that it uses a structural subtyping to
figure out whether that that language
compression never explicitly says
implements the interface or or whatever
it's just a structural subtype
relationship so a few thoughts on RSB
the structural subtyping concept which a
lot of functional languages kind of go
down that route and have that kind of
idea like imbedded in their community
removes the need for this kind of
interface segregation principle you're
going to worry about depending on the
minimal interface you just already do
that in your code by virtue of not
having how the interface is lying around
functional interfaces in Java right
provide this kind of bridge between the
two worlds where you can get some of the
benefits of structural subtyping but in
a generally nominal world and just in
case any of your co-workers try and pull
this trick on you the interface
decoration principle doesn't mean that
you have to implement 500 interfaces on
the class that's not that's not the goal
anyone seen that anyone seeing a lot of
interfaces quick shout out in the room
what
the most number of interfaces you've
seen any class implement 610 and we're
beating 1015 I've seen like 50 in an
open-source project I won't say where
but um yeah you can you can go there so
um the dependency inversion principle
means that men can have babies more
seriously the more formal definition the
girl on cobalt definition here is
abstraction shouldn't depend on details
details should depend on abstractions
well that means is you make your kind of
business logic your application domain
and you want to decouple it from your
kind of glue code your infrastructure
code and I guess the most common
dependency inversion implementation
people see is like dependency injection
so anyone you use like spring or juice
or CDI or something like that and do
kind of dependency injections part
they're part of their application code
that's really a specific type of the
dependency inversion principle so the
streams library are a kind of another
form of a dependency inversion principle
so what this snippet of code does is it
finds the nationalities of bands on an
album so you've got some kind of
compilation album so you take your album
you get a list of all the musicians on
this compilation album out you filter
each artist on the album you check that
their name contains the word verb
because it's a scientific fact that
every band has to start with the word
vert you map that over to their
nationality and then you collect it to
it to a list of those nationalities and
this is implementing the dependency
inversion principle because even though
this code is doing a whole load of
collections processing none of it's
actually depending upon the details of
that collection nowhere in here are we
worrying about whether that those
musicians are a list or a set or
whatever's going on
we're just depending upon these higher
level of abstractions like filter and
map and collect these these kind of
high-level concepts and passing in code
get schooled by that so that's where the
the dependency inversion comes resource
handling is another kind of example
where you can make quite good use of a
dependency inversion principle in a kind
of functional way functional style so
say we've got some kind of file some
kind of file on your file system a rule
we brought some code that finds the
headings for this file so this code is
going to take bufferedreader wrap it
around a file reader and on the file
itself it's going to use the method
additive bufferedreader in java right
that gets you a stream of strings one
for each line in the file called lines
it's going to filter by some method
that's going to tell you whether it's a
header or not and then it's going to
build your up a list and if there's an
eye exception it's going to do the nice
thing and wrap it in a friendly domain
exception that tells you where and your
application code things going wrong you
know well that's really doing is sorry
well that's really doing is conflating
this kind of business logic was kind of
processing about finding the headers
from something with all this low-level
detail about reading files which we
don't really care about that's not
really part of the thing so what I
really want to do is run a really better
write a method that's purely the
business logic so here's a refactoring
of that previous method that that does
that so I've got a method called with
line solve that I'm going to show you on
the next slide and it's first argument
is the file that we're gonna read the
lines of which is the same file
references on the previous slide the
next one is where your actual callback
handler goes so this is a Lam for
expression that takes the lines in that
file again filters by whether they're a
heading and puts them back into a list
for you to use and here is a method
reference to the constructor for that
the main exception and that's the that's
basically the other function that's
passed in for the you know when the
hits the fan case okay
and the resource handling code the wit
lines of method looks like this so it
takes the file as if the file path was
its first argument it takes a handler
that's got a stream of string so that's
going to be the lines passed in and
return some kind of result which it's
going to return and it takes the the
error handler as well which does some
mapping into a domain exception and here
we've got our bufferedreader wrapping up
we apply the lines of that reader to our
Handler and if there's an exception we
apply the exception to the error handler
so the what that's refactoring is done
is it's put it's pulled away the kind of
the the infrastructure code managing the
files and all the lines and
what-have-you from the actual business
code from the business logic and it's
also is done it by implementing this
dependency inversion principle because
the code that was actually at the top
left while the fine headings hasn't
directly dealt with these things it's
just passed in callbacks as lambda
expressions which then get called back
on in this code down here so quick
summary of the Pennsy inversion
principle again higher-order functions
provides some kind of inversion of
control because you're passing something
in there's an argument which they're
going to then use when people say
abstraction we often immediately think
like abstract class or interface very
kind of our concepts but actually an
abstraction could be just a plain old
method it could be something very simple
that you can use this kind of style of
resource handling that I showed on the
previous refactor that with lines of is
use very commonly in kind of functional
programming languages like Haskell or
whatever they they very rarely have that
function is called with file that they
do a similar thing so I guess the kind
of case that I've been making for the
last kind of bunch of slides is that all
the solid patterns have some kind of
equivalent in the functional programming
world they all have something
conceptually equivalent but it's also a
lot the time the kind of same idea
expressed a different way so when you
hear people saying we don't need the
his design patterns or these principles
or these these arrow things we do our
own blah blah blah it's always worth
noting that there's really a lot of
commonality in these kind of concepts
which are very useful both ways so let's
have a look at a couple of design
patterns now and see how taking a more
kind of functional approach using more
the java great features land of
expressions and method references helps
us write those same underlying design
patterns but in a kind of simple
actually in a way so quick hands up and
familiar with the command pattern quite
a few people cool so the receivers the
guy who's actually performing the work
in the command pattern the thing with
how's she doing doing the underlying
process the command objects the thing
that encapsulates a bunch of information
that we're going to pass on to the
receiver say go go do ships it's a
command the invoker is the thing that's
kind of controlling the sequences of
commands so the reason you build up
these commands as objects that you're
gonna fire around is so that you can
sequence them and alter them we've got
some client code which is going to
create concrete instances and wire
everything up so let's have a look at
that our example for using the command
pattern is a macro and I'm going to find
a macro or something that takes them
it's very strips long and makes it very
short
so our underlying receiver is some kind
of a tiff a very simple editor interface
which you know possible different
limitations is going to be able to save
things open things and enclose things
our command interface is this this
action interface which has a single
method on it called perform we have
multiple different commands which
provide concrete implementations of this
interface here's one that does the
opening so it just takes it editor as an
argument and when perform is called it
delegates to the open we're gonna have
basically the same ones for closed and
save and all the rest of it the code
that actually deals with all the
sequence and everything is our actual
macro class now it's got a list of
actions we can record our action by
adding it into the list and
we run which is gonna call a for each
and perform this method at reference so
say do the perform on each of the
commands and then what we do when we
were actually in our client codes will
write something like this well recorder
and you open a save and a close yeah
well whatever whatever the heck's going
on but actually when you've looked
through this code a lot of those actual
commands were kind of just unnecessary
boilerplate right
we had the huge class doing all sorts of
stuff I know we really wanted to do was
say call the open map that we wanted to
do something really simple so if you
flip this into the kind of java 8 world
view and that command objects really
just a function is just a land for
expression so instead of calling record
and having new object new open editor
you can just pass in this lambda
expression that's calling the methods in
question and this slides kind of just
showing you similar code to the previous
slide but the real win here you don't
have to have those n different
boilerplate classes for however many
different types are come on that you're
using the observer pattern so this is
this is when you look at things and you
get really scared so the observer
pattern has some kind of observer which
is an interface with with with it with a
method on that gets called when an event
happens we have multiple implementations
of that observer and we've got some
subject which we're observing which is
generating these events and calling
methods on the observer so an example of
that might be say erecting a profiler
and you have some interface say a
profile listener that accepts a new
profile so you've update to you you know
you've been monitoring your application
and and you've collected a certain
number of samples or whatever and you
want to pass over to say your UI or
something that's storing a profile or
it's it's going to go and say
everything's going really slowly will
send someone a text message or whatever
what you actually end up doing is is in
your observer you end up implementing
this same kind of boilerplate code all
over the place so you've got your list
of listeners
you'll now have a listener and you can
accept this event and send the outdoor
listeners any programs like swing code
at any point in the time I'm sorry for
having to remind you of that painful
event in your lives well yeah I mean if
you remember swing you kind of end up
writing the same boilerplate pattern all
over the place where you have that that
same concept because there was no way
that you could abstract over these
different these different profiles and
these different types of listeners even
though all they were doing was all just
getting an event passed in yeah but
actually and this is kind of coming back
to the point we made earlier about the
structural subtyping on functional
interfaces we'll see that these are the
same type of thing so there's a consumer
of T which is a new interface added in
Java right that's a generic like a
generic listener interface and that
takes a T as an argument and returns
void there's a profile listener which we
showed you a few slides back and that
takes a profile and returns void and
then you know as everyone has remembers
from swing they had an action this know
which takes an action and returns void
so these all have the same structural
type right they're all taking in a
single argument of something and they're
all returning void which means in
something like Java 8 we can write a
generic observable implementation so our
listener is going to implement this
consumer and it's going to have an ad
for a consumer and we're going to put
the consumers into the list and when we
get our event that we want to pass on to
all our observers we're going to accept
that I'm going to call for each and call
the accept method on every consumer now
I know what you're saying Richard you
just added generics this is nothing new
but the interesting thing is you can
write code like this and what this does
is it takes so these are things that
implemented the profile listener code
earlier on these aren't implementing the
consumer of T interface all they're
doing is wiring up their accept method
as a method reference because it's got
the same structural type it's going to
convert
so what this means is you can write a
kind of generic observable and even if
you have completely unrelated listener
types you can still make use of that
same code removing a whole layer of
boilerplate okay so I guess the point
I'm making in the kind of design pattern
section is that you may have all these
existing design patterns which have good
knowledge good ideas you throw away at
all but as new kind of language features
crop in or you playing around with
different programming languages these
kind of design patterns can be improved
or tweaked upon we've shown a couple
here where we removed boilerplate so all
kind of common repeated patterns and
stuff like that so anthropology an
observation of mine is the programming
language evolution closely follows the
career of Arnold Schwarzenegger okay
bear with me here
bear with me in the 1980s everything was
fantastic and he was on top of the world
he was making comedies they may be awful
films but they were doing fantastically
at the box office in the 1980s in
programming there was huge amounts of
active work there was you know you had
the lot of these kind of strongly
multi-paradigm languages so small talk
eighty is like the kind of purest
object-oriented programming language
land for expressions Common Lisp they
kind of one of the purest functional
programming languages have an object
system loads of people doing kind of
poly got programming there's first our
language research loads of things which
we use today in kind of production and
systems like garbage collection
just-in-time compilers for having that
kind of early implementations a lot of
research work being done there in the
90s
Arnie went and made all four films like
jingle all the way
and this ruined the programming industry
you see this huge market convergence
right all these kind of slightly more
esoteric or interesting things like you
know the lips or the smortest they start
to die off Java has huge huge popularity
as I kind of pure our language
JavaOne in 2001 allegedly had 28
thousand attendees that's crazy huge
massive popularity of things like
servlets java j2ee things like spring
esoteric death and a massive dominance
of kind of just object-oriented
languages and now things are kind of
changing a bit everyone's kind of moving
towards a situation of embracing the
ideas from other from other other
communities and cultures even in our
film and you see an increasingly
multi-paradigm situation as far as
programming languages go so Java has
generics which is a kind of a whole a
whole baggage of ideas coming together
coming in from the functional
programming community and obviously Java
rate as lambda expressions closures
another massive anonymous functions
another massive idea from the functional
programming community C++ in like the
early 2000s added templates which again
structural subtyping bringing the ideas
in from the functional community and C++
2011 also ANDed lambdas shockingly
enough if you look at newer programming
languages that are kind of been ramping
up in popularity more recently a lot of
them take ideas from folks you see
things like f-sharp where it's like a
functional friend of c-sharp it has
loads of oo ideas and a complete arrows
you know type system and maps well you
see things like Ruby Python and groovy
or have kind of functional ideas coming
in and ng multi-paradigm and loads of
the new jvm languages anyone tried Scala
some people sallam no one wow Kotlin
also no one new newer J game languages
with varying degrees of popularity as
we're learning today have these kind of
multi-paradigm ideas so some functional
stuff some oo stuff so that's me wrapped
up if you've got any questions I'm happy
to take some of it in in just a sec if
anyone's interested I run a training
course on Java rig there's some
reference cards over there and you can
go to Java rake training com
for the details I've also written a book
with O'Reilly on lambda expressions in
Java rate and more the lambda streams
stuff there's a link there and there's
also some cards over there which are a
40% off that's me on Twitter and that's
my blog so if anyone had any questions
now's a great time to ask them hi yeah
fighting our worth it's worth noting
that I never said who was our own who is
FP out of our knee in Danny DeVito I've
left that ambiguous the entire time but
yeah yeah that's um Arnie's a valid
interpretation sorry Carol
given that
tinkering with metaclasses we're
cleaning yep
um I think so so all the kind of ones
that the Expando metaclass stuff in
groovy things like that have their place
but I'm not sure I'd necessarily want to
use those in things like modeling your
core domain just because sometimes you
can get situations where a little bit
confusing or harder to understand what's
actually going like I'm not saying
they're bad features to have but I think
it's always worth understanding those
design patterns as alternatives and
thinking well maybe it's a bit more
flexible but is it really worth the
complexity when we could just use the
standard design pattern and if you still
have those kind of things then you can
make an informed trade-off so I
definitely think they're relevant in
that regard
thanks for the question anyone else got
a question
right so I guess big new things in Java
rate lambda expressions so there's not
really much you're gonna do I would say
on that front for Java seven that's
necessarily worth doing streams the new
API on the other hand you can use things
like guava which is the Google
collections library and GS collections
which is I have a talk on earlier today
by Don Raab and those things give you
the same idioms it'll be a bit more of a
boast and a little bit more messy in
Java 7 but if you at least want to kind
of take some of those ideas and begin to
practice them and experiment with them I
think that's a really good way to go on
Java 7 if you're looking at using to the
new date and time library from Java
right you can start using joda-time
which is quite similar and there's also
I believe a back port on maven of the of
the new date and time library from Java
rate is not quite the same but it would
at least ease the transition so that
that's the things that I can think of
Thanks
any other questions Hey that's like a
question so I think default methods give
you a kind of more interesting kind of
domain modeling options right so
previously if you wanted to have any
kind of method you needed to have a
class or an abstract class and you were
restricted to this single inheritance
hierarchy so the thing with default
methods is I think it means interfaces
are a lot more powerful and a lot more
usable as lots of things which can now
be interfaces and you have that multiple
inheritance flexibility and option so
that's a good thing to use and something
to think about but it's worth noting a
couple of things in terms of
restrictions on the default methods you
still don't have instance level State
and interfaces so only use them where
you've got a pure function basically
don't don't necessarily expect to have
that much other stuff or just take
taking some arguments and returning a
value the other thing to note with
default methods which I think
hasn't really been I know talked about
that much in general is they're all
default methods of public so if you've
got anything where you want to have
something like protected mayor third or
maybe it's a more complicated method you
want to have some private methods you
still can't do that an interface so what
I'd say is use them but keep it simple
and try and keep it pure as much as
possible cool
any other questions
let's go
um so traits are people aren't aware so
it's a bit like an interface but you can
also have state and it's it's kind of
moving you more in the it's blurring
lines even more with what an abstract
classes I suspect that there might be an
option to do things like give additional
scopes to default methods so there's
potential for things like making default
methods which were protected or
something like that I'll package scoped
but I don't think they're gonna go much
further than that and I think the reason
that they probably won't go much further
than that is because the further you go
towards conflating the lines the further
you go towards the big multiple
inheritance of everything situation
which I think people concluded with C++
was a bad idea
so default methods on interfaces are
perhaps seen as a as like narrowing the
gap towards that but I don't think
they're gonna go as far as traits and
Scala okay any other questions okay
cool thanks you in a great audience</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>