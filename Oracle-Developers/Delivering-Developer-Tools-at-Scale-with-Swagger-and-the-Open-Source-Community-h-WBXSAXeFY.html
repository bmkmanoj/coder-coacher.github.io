<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Delivering Developer Tools at Scale with Swagger and the Open Source Community | Coder Coacher - Coaching Coders</title><meta content="Delivering Developer Tools at Scale with Swagger and the Open Source Community - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Delivering Developer Tools at Scale with Swagger and the Open Source Community</b></h2><h5 class="post__date">2018-03-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/h-WBXSAXeFY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right thank you guys for being here
today
especially so late in the day I know
it's 5:00 p.m. you're probably dying to
get home so I appreciate you coming out
and hearing our talk today I think it's
an interesting one and hopefully well as
well my name is Joe levy and we are
members of the developer experience team
on Oracle cloud infrastructure and so
before I get into the problem that we're
going to talk about I think it requires
a little context and so I want to make
sure everyone knows about Oracle cloud
infrastructure who here is familiar with
Oracle cloud infrastructure few hands
okay so what Oracle cloud infrastructure
is is a collection of infrastructure as
a service and some platform as a service
offerings delivered by Oracle that's
built by a lot of X cloud folks
Esteban's from Amazon previously I
worked at a tree previously and some
collection of i/o services so compute as
a service virtual networking block
storage database file storage etc all
these infrastructure services where the
thing that makes them a little different
and better their than competitors is we
allow you to bring lower level
networking primitives to the cloud
I believe it's L two primitives and the
price of performance you get is just a
lot better because we also let you spin
up physical bare metal machines in the
cloud and so just to give you a little
taste of what Oracle cloud
infrastructure looks like go into the
the browser experience for OC I here
this is the Oracle cloud infrastructure
we call it the console the browser
experience and so you can see I can go
in here and interact with a lot of
different resources for example
instances I can go and create an
instance and again here's one of our
differentiators as you can go and create
error metal machines in the cloud which
are these very big beefy machines with a
lot of RAM CPU i/o etc to really move
those enterprise workloads and get the
same if not better price to performance
that you get on premises and your own
data centers so I can use a web browser
experience to actually talk to Oracle
cloud infrastructure services which is
what this is showing you know go in and
select the operating system and the the
size of the machine
which we call shape and you know other
config settings but that's just one way
of interacting with the Oracle cloud
infrastructure services and there are a
number of other ways to interact with
them and and that's the area Esteban and
I cover in developer experience our area
is make sure all of our customers can
automate against the Oracle cloud
infrastructure set of services from
whatever languages and tools they're
comfortable with today and it turns out
that's a very hard problem and we'll
talk about why so first of all really
what supporting developers means is
supporting them with what they're
comfortable today making it frictionless
for them to move their applications
which might be written in certain
languages or use certain tools to our
cloud so what that means is supporting
interfaces to our cloud with the
languages they use so this is a graph of
github in March 2015 so three years ago
on the you know plethora fragmentation
and how many languages there are out
there right and this is just March 2015
things have changed a lot since then
there's even more can anyone think of a
language that isn't mentioned on here
but is now pretty popular
I heard go over there go is definitely
when I was thinking of Esteban is
actually a lead developer on the Oracle
cloud infrastructure go SDK so if you're
interested in go please come talk to him
afterwards go is one Scala is another
Kotlin is another right just of this
conference there's been a variety of
languages not even on the map in this
chart that are now pretty widely used
enough that they're in getting
presentations at conferences and getting
a wide audience right so there's a lot
of different places to support there
were in 2015 and there's even more now
and that's only at the language level if
you look at DevOps tooling which is kind
of a level above languages there's many
DevOps tools written in various
languages and we need to support those
too if someone wants to do continuous
integration with our cloud config
management testing monitoring etc
there's a whole bunch of tools for that
and this is just one random chart that
shows you a whole bunch of the different
tools listed right so our team is also
responsible for making sure a lot of
these tools up integrations and oracle
cloud infrastructure
oracles set of bias services
infrastructure-as-a-service
services from all these tools so the
simplest way to talk about what we do is
basically it's it's checking the boxes
so this is a chart of in the rows you
have the various developer tools we need
to support and in the columns you have
various services we need to support in
terms of these are services or cloud
currently supports them we need to make
sure in various developer tools whether
they're SDKs or higher-level tools like
chef or terraform for example we need to
support connecting to our service easily
talking to it and we've done a good job
so far of filling in those boxes in
terms of all the various services we
have compute block storage database etc
and all the developer tools that want to
support so we have a Java stack a a
Python SDK Ruby SDK command-line
interface and then a few other tools as
well and it turns out this actually
isn't even up to date so and I'll get to
that in a second actually so what the
sense of meaning is based on the size of
that chart there's there's a certain
amount of rows and columns you multiply
the rows by the columns the amount of
developer platforms you want to support
by the amount of services in this case
it's 72 boxes are team sizes around six
steps you might say okay that seems like
a surmountable task to you know write
code manually and build SDKs and tooling
that can support these services but I'll
start to explain why it gets harder so
there's more and more rows that we need
to support the list we have on there is
just what we support right now but
there's a whole bunch of other languages
and tools that we need to support which
I mentioned before right now we're
probably not going to add a Fortran SDK
or a logo SDK there's anyone remember
logo turtle that goes around the screen
drawing turtle probably won't have one
of those for Oracle cloud infrastructure
but we will have lots of other developer
tools developer tools coming so for
example since we put the slide together
the go SDK that Esteban's been working
on has been released
that's one more row here and with that
row being added we have to support all
of the columns all of the services and
the functionality of those services so
suddenly our our static equation now has
variables what was just you know
eight dev tools is now a growing set of
dev tools and the team size despite that
hasn't magically started growing at the
same pace
so our smiley face here is probably a
little more stress there's a little more
work to do turns out there's more
because the services we support in our
cloud are growing there's more being
added all the time so while Oracle isn't
going to get into puppies as a service
or haircuts as a service most likely you
never know with Oracle but they will get
into other things so for example since
we put this chart together just the pace
of innovation is so quick we've we've
released file storage as a service email
as a service and DNS as a service so
that's kind of three more columns where
we need to support we need to build
developer tools that support all those
services so our equations getting more
complex there's more variables where the
number of dev tools then the number of
services is growing over time our team
size is still six people writing all the
code manually ours are smiley faces
probably smiling a little yes a little
less then there's the fact that once you
support a service you're not done that
service continually adds features more
and more features over time this is the
list of resources for a virtual
networking service as you can see
there's there's 39 resources on here
each of those at least has a create read
and update and delete and list operation
and the last time we presented I think
this was 30 resources and now it's added
nine more so each service we need a
support continually adds more features
and functionality so each of these boxes
is really a collection of much smaller
boxes where we have to keep checking the
boxes as more and more of these purple
lines features within a service appear
so our equation is growing or smiley
faces getting sadder the pace of
innovation is increasing so Oracle cloud
infrastructure when I joined a year and
a half ago it was 300 people it's now
1200 people which means it's grew by 4x
our team was four devs then our team is
six says now so we have grown a bit but
we haven't been able to keep up with the
pace of the growth of our cloud in terms
of hiring and part of the reason for
that is just naturally when we need to
deliver a service that has zero people
on it it's going to get allocated more
people than an existing team right a
service team needs to have a fairly
large set of people to really deliver a
production so
whereas we're not given the same amount
of resources as a service team coming
into fruition that didn't exist so you
can see this graph here actually shows
that the pace of innovation the growth
of our cloud platform in terms of people
is outpacing the growth of the developer
experience team the SDKs team by a fair
amount equation getting bigger smiley
face getting sadder and there's one more
area that makes it even harder and
that's the fact that we don't just
release developer tools publicly we also
release them internally and and there's
a pipeline between internal and public
so we might have features that are only
available features and features and
services that are only available
internally and then we might have
eventually to be public features but
first they're an internal preview then
when we think that's going well they go
into public preview then we think that's
well they go into full public and so
each of those scopes has a different SDK
with only the features that for example
the public s can only has public
features the preview SDK has the public
and preview features right so it's a
variety of scopes per developer tool
we're delivering and that's one one
thing I actually reminded myself to call
out here which is this this chart here
in terms of the number of services we
support isn't just public services we
have many of those and we'll have more
over time but OCI Oracle cloud
infrastructure the service teams to talk
to other services within the cloud and
just internal services we have there's
probably at least 20 more service teams
that need to build clients to talk to
those services from other service teams
within our cloud what are those teams do
when they have some service teams in
Oracle cloud infrastructure that code in
Java and some of the coding go and some
of the code in Python is each of those
teams going to write clients for each of
those languages to support each service
team in Oracle cloud infrastructure so
that those service teams can easily call
in to them that's another level of how
problematic this is so going back to our
equation there we've talking about
scopes so this is our final equation
there's a growing set of dev tools
growing set of services increasing
features in each service a pace of
innovation that
increasing and multiple release scopes
and guess what our team size still
around six stems we want to grow but
we're not growing as fast as these
variables right so it turns out our
smiley faces
he's very stressed he's very anxious
he's just died of anxiety this is too
much for a small team to do manually to
figure out how all these services work
code to those interfaces make sure they
don't have any bugs in their code do all
the testing work etc that's too much for
a small team but yet somehow our team
does it so what we'll talk about next is
how do we actually solve this so I'd say
the the first part of our solution is
swagger who here is her to use swagger
before most people okay glad to see we
have some fans so in that case this is
probably gonna be a low number of people
how many people thought when the title
of this presentation said swagger they
thought I meant confidence and bravado
no one okay
Pat yourselves on the back swagger is a
real tool and while confidence in
bravado is probably important for doing
this as well
swagger helps a lot more what swagger
lets you do is declaratively say what
your rest interfaces look like in a
declarative format in a file that is you
know like code and can be put in source
control can be dipped can be code
reviewed can be moved through branches
and a deployment pipeline a CI CD
pipeline it's open source software and
so it let us start very easily because
it's open source and it has a lot of
parsers and generators that are open
source already that we could use as a
starting point and it's useful for a lot
of things you're declaring this source
of truth for your service and then you
can generate service scaffolding which
is like the the level of your service
that takes and inputs on certain paths
and HTTP actions you can generate lots
of clients and REST API Doc's as well so
in addition to REST API ox we Esteban
and my team generates our Java SDK or
Ruby SDK our Python SDK our go s DK our
C Line or telephone provider all using
taking a swagger template defines our
service running up through swagger code
gen and spitting out an sdk or other
or tool so it allows us to save a lot of
time so in terms of what an operation
might look like in a swagger spec you
saw the web browser experience at the
beginning I went and I did the steps
that would be for creating a bare-metal
machine in the cloud this is a kind of
slightly simplified version of what our
swagger specification for that same
operation looks like so within the
swagger specification for the compute
service you have slash instances which
is the path of this operation we're
saying it supposed to there you can see
on the top left and since doesn't post
which is the HTTP method we use then we
have the description of the operation in
there the fact that it takes a body and
a reference to the the schema of that
body which you can see on the right here
launch instance details where we're
saying it takes availability domain the
display name the image to use for it and
custom metadata and we say which of
those parameters are required as well
and the type of each of those parameters
whether it's string or a key value
dictionary for example if you look at
metadata there and then we declare the
responses so in this case we're just
showing the the 200 response which is if
this is a successful operation you get
back a 200 they'll be an e-tag header
returned and then there'll be another
body returned and in this example I
don't have the instance model on the
page but it's very similar to the
launched instance details in terms of
the fields that will come back basically
a representation of the machine the
instance will come back and then we take
that source of truth delivered to us by
the service teams the service teams say
this is what our service looks like and
how you should interact with it what you
can send in what you'll get back and we
turn that into REST API documentation
and a variety of SDKs and other dev
tools
so I've pre clicked these links and
pulled up with a map too before I go to
the links so in the CLI it'll it'll
generate an operation as well the maps
of this compute instance Lodge so in
terms of the other dev tools so here is
our REST API documentation for launch
instance you can see again post slash
instances with just a version path in
front
and if I go down to the body you can see
its launch instance details just like
the spec said and then here again you
see the same fields availability domain
whether it's required or not what its
type is right so all this work we would
have had to do to man and we write Docs
we can suddenly generate but not just
for dogs also for SDKs so here's our
Java SDK API reference and you can see
we have the launch instance request
class and in there it has a variety of
fields or it takes a launch instance
details class and this has a variety of
fields you know all those same fields
that we talked about earlier that we're
declared from the spec all generated
into an SDK and then API documentation
API reference generated from that SDK
yes the question was do you have to
provide the version number for the API
is there a default set the answer is
kind of depends on who you is right do
you mean the end customer using our dev
tool
me being the yeah it's a good question
it's it's so when we generate how do we
know what version to use for each of
these operations and right now we
actually because we're dealing with
enterprises so much we really try to
avoid breaking changes and so we we've
actually at the level before this which
is just the service teams themselves
they try really hard to not have
breaking changes and so we haven't had
divergent paths so a new vertol use the
same version if it has like additive
changes we would be switching to a new
version if it had breaking changes like
a parameter was removed or the type
change or something like that we
actually haven't for other reasons we
wanted to invoice oh we don't have
actually a great answer to that yet in
terms of what it would map to in the
SDKs what I would think is that the SDK
would eventually the major version would
Rev and then the PAP would just use the
the new path and and all the server-side
operations would support that new path
even if some of them are exactly the
same as the old
version but it is somewhat a we're still
working on that and we'll see when we
get to that another another way that
we've thought about human without comm
is using some of the tools that the
language is provided to deprecated calls
so if a service was - that was - that
create an operation we can probably
render the deprecated annotations in
Java for example or the deprecated
comments on go to the upper cuticle and
when we decide to take a break intent
would actually remove that from the API
so that's I know they another way that
we have been planning to deal with that
thanks for the question
so that is we got the REST API we got
through that the Java SDK for this same
operation from the swagger spec looks
like here's just quickly with the the go
SDK API reference says again watch
instance details and you can see all
those same parameters are in there shape
is basically the size of the machine in
terms of how many cores and RAM and etc
it should have so you can see all these
same variables come parameters come
through and whether they're mandatory
and what their types are and then just
to show you one more here's Python again
we have a launched instance operation
fully generated that takes and launch
instance details and if I click into
that which I should be able to do you
know here again launch instance details
all the same parameters coming from the
swagger spec so suddenly we've taken one
source instead of writing many many
tools for many many services manually
we've taken one source of truth and put
it through a generation pipeline tsa's
spit out all these things so back to the
the deck we're not back to the deck so
now I'm gonna pass it over to Esteban to
actually show a demo of us doing this
for a new service I think so so what I
want to do is keep a quick glance on how
we put together all this tools to
actually produce running running a code
from a spec so the first thing I want to
show is I want to show a spec that more
or less shows what we're talkin about
whoops yes let's do that again
can people read that that big enough see
not great so this is a spec that Mosley
models the service in this case is
modeling this service we call file
storage service API and this service by
itself has a bunch of operations for
example you can create file systems you
can delete file systems I want to I want
to Center on the creation of a file
system so if I create small system
queues and operations as create file
system it declares input parameters in
the body and it also has some responses
so if we were to jump into the input
parameters that we have in the body
would be a JSON object and this JSON
object would have properties in the
availability domain compartments and
these and so on one thing to point out
is that this service has more than one
operation
I've only shown one so coding this by
hand would take non-trivial amount of
time so what I want to do now is
actually run our generation tool and
this takes a while so I'm going to let
this run and then talk a bit about what
we did to support this stuff so all
right the specs are provided to us from
services team I actually in jar files we
have a maven repository with all the
specs so when services read their
version of the spec they produce an
artifact we go and pull down their
artifact and style pipeline so to
address that we wrote a pom plugin that
actually goes and talks to our artifact
repository pulls down the specs and runs
the generator and different languages
will have different input parameters for
this for example one of the things that
the go SDK needs is the fully qualified
project name for imports if you familiar
with go you'll know that imports are
fully qualified you can't just say get
it from my file system slash dot you
actually have to point to the whole path
so depending on the language we are
doing we actually encode some of those
extinctions as input
to the generator but suffice to say is
that we've hooked up through maven and
some other make files that actually put
this up so let's check back on
degeneration it seems like it's not so
what I'm going to show you next is what
the generator actually created not of
this code was written we what we get is
a bunch of gold files that it's
basically modeled at file so I want to
show really quickly they create files
system requests and response this is a
struct that basically models the input
parameters for the requests and it says
that it has some body and some header so
let's jump into the body and see what
the body has and the body has that it's
not the right call so we are interested
in create file system details create
file system details have some ability in
the domain compliments IDs and display
name pretty much what we saw in this
pack this is great
what I actually want to show is that
this is running code runnable code that
actually does what it needs to do so if
you very quickly if you look at the
difference between what we have before
we added this whole file storage package
so I'm going to check out a repository
that I have some paths that I run
against this package that I created so
really quickly I jump into the file
storage test ok so what I what I have
here is basically a test I runs this
code the code that I just created so I'm
gonna run it really quickly and crossing
fingers everything should just work so
we're gonna this is actually only to
compile the new code that we just
created and it's gonna execute it and
then call our alright so this and it
seems like it works quickly I'm going to
jump into here and show that yep
I created it file system installed a
very brief lis what's happening here is
I'm creating a client for our service
I'm setting up some input parameters and
then I'm actually making the call with
the input parameters as I expected it
then I'm not saying that didn't have any
error my call
and I'm printing out the name of the
file system that I had so we went from a
speck all the way to runnable code to
make and test it that we actually can
execute and run that code I think is
back to you to see where we're at yeah
awesome thanks Esteban so yeah that was
a great example of you know the file
storage team is a fairly new team in
Oracle cloud infrastructure they need to
get out there they need all the
languages we support all the dev tools
we support they have customers using all
of them and they need those people to be
able to easily and very soon after the
service comes out call the file storage
operations and automated ways or some of
the other tools they're using so they
give us the spec we click a button and
boom we have a go Estoque that works
written right saves us a lot of time but
you can't always have good without bad
and there there were some things that we
had to watch out for fix with swagger
one is since its generated code if we go
in and manually change the code to make
things more polished or nicer that gets
overwritten the next time we generate
right so you have to do meta program and
you have to update the templates or the
code gem to support the changes you're
gonna want the generated code if you
want those changes to stick around
another thing we ran into is well
swagger is open source on that swagger
coach and helped us a lot to get started
for certain languages I don't know if
you ran into this for go but for certain
languages the code gen for Java skate
for example the cogent we got we started
with didn't support all of our needs so
for example it wasn't fully backwards
compatible with in the ways we needed it
to be so for example the code gen for
the Java SDK supported parameters as
positional parameters and so the way
that ends up not being backwards
compatible is if I have parameters a and
C passed in position one and two and
then suddenly parameter B appears now
what the user was passing for C will be
best passed for B because b is now going
to be in position two and C is going to
be in position three right we can't have
that for enterprises right developers
anyway I really don't want breaking
changes like that so we moved the code
John the templates to support a builder
pattern for a Java SDK work so that all
the parameters are
by name instead of just by position so
as parameters are added regardless of
where they're putting the list and
Swagger or whether we sort parameters
alphabetically or what it's it's not
about the position it's about the name
and so it's doesn't break that's one
example I'd say another very important
example is the the process to create an
SDK is more complex well it saves a lot
of time once you know it it's more
complex because your meta programming
estaban just showed a pom file I believe
right and so that's because we use maven
and someone who just uses go or just
uses Ruby or just uses Python you know
isn't used to Java style build tooling
or that if they want to update swagger
cogent for our needs they have to code
in Java right and you might say well
swagger can be run as a command-line
tool and you're right but if we make a
change to swagger code again and we want
to run its test suite then you have to
be familiar with the Java test suite
that it uses right so this kind of
encouraged you you kind of need people
who are ok with multiple languages
jumping between them who are polyglots
as we call it another important thing to
call out is we use kind of a shared code
gen for all of our languages and so our
developers we kind of have one person on
each each language our developers have
to be aware of a change they might make
and make sure it doesn't change any of
the other languages in the negative way
since we share a project for the the
cogent piece for all of them even though
the templates are different for each
language so another way we help scale
development is by open sourcing so our
Java SDK or Python SDK go SDK and
terraform provider chef plugin and
command-line interface are all open
source on github right now we're working
on adding the the few remainder dev
tools we have that are I think ruby sdk
and HDFS connector are the other two we
have right now they're all open source
on github and short part of that is to
be a good developer citizen you know
make sure people can look at our code as
a way to learn or use it as a basis for
their projects part of it is so we get
the useful parts of github which is
archived releases it keeps old releases
the ability for customers just
scribe to new releases since they can
watch the project or subscribe to an
atom feed and it gives you metrics as
well you know Forks stars and it
actually will give you page view metrics
on every page of your repository as well
and including source source file source
code files which is kind of awesome but
it's more than just that it's it's about
getting the community as a developer for
your product part of that is one they're
a lot more likely to be an advocate for
you if they're not just a user but a
contributor if it's if they feel part
ownership in the project but the other
part is it helps us scale when we have a
variety of customers on github looking
at a project and identifying issues
contributing solutions to those issues
etc it helps us scale better because
they're doing some of the testing for
example for us they're doing some of the
code contributions for us and there
really helps us scale better and so just
to give you an example here is our
terraform provider who's familiar with
terraform in the audience okay so for
those of you that aren't familiar let me
just pull this up first those of you
aren't familiar terraform is basically a
way of declaring this is how I want my
infrastructure to look like make it so
and it's kind of a cross cloud way of
doing that it supports as you're an AWS
Oracle cloud infrastructure etc so you
declare what you want you hit a button
and it makes it so it spins up all the
resources in the cloud and the right
order etc to make that happen so we have
a plugin so it supports OCI you can see
there's a lot of github traffic on this
115 Forks I go to close pull requests
you can see that's 37 contributors let's
see what close pull request looks like
214 close pull requests right so there's
a lot of traffic on this that's a lot of
people helping out one building
developer advocates but also just a lot
of people helping out and building
identifying issues and responding to
other people's issues when they come up
again some downsides though so it's
checking the time here a few downsides
we've run into here is we actually keep
the source of the the real source the
real source of truth for these developer
tools internally and the reason for that
is sometimes a feature isn't ready to be
visible publicly yet we don't want
people to start consuming it early
because it might be dangerous for them
to consume it in terms of its impacts it
might be a competitive reason it might
be a marketing reason but for whatever
reason we want to home them internally
and so if we want to home them
internally it means we have to deal with
essentially two sources of truth the
public one and the internal one and
merging back and forth between those two
sources of truth the public one and the
internal one so we have ways of doing
that but it ends up being requiring more
work than if we just kind of had one
public github or even just one internal
get repository for this another thing
that kind of fits with that is how do
you keep private things private so we
have some files that we want to have in
our internal source control but we're
not ready to really have the public
community see them so for example test
files that have resource identifiers for
resources we use for testing but really
for security purposes we don't want
people to even know what those resources
are that you know are white listed in
special ways for internal teams at OCI
so a good ignore file doesn't solve it
right because of the internal source of
truth needs to contain it in the source
control and it's the external source of
truth the public one on github where we
don't want those so we have a white list
file mechanism to basically say if it's
not in this white list don't let it go
publicly and we have to keep that white
list up to date and if we forget to what
we put out publicly you know may not
work or may not contain everything and I
think another really big one that kind
of ties into the sack that we're using
swagger is what does it mean if a
customer makes a change a manual change
to code that was generated right so the
answer to that is one there's a lot of
code that isn't generated right if
they're modifying the paginate errs or
the waiters or the signer or the HTTP
client etc there's a lot of pull
requests they can make which we can just
take but if they do make changes to a
generated model generated function we
essentially consider it
a very very specific issue where they've
given us what they want the solution to
be and so what we'll do is we'll leave
that polar quest open until we've made
the same change internally to our code
gen or templates such that it would
produce basically the same thing
then we'll merge in there change so
they're in the commit history they're
seeing as a contributor they feel very
happy about contributing since they did
and then the next time we push out
publicly we won't just be overwriting
their code since our cogent is producing
basically the same the same kind of
thing now it might have small
differences in terms of spacing and
things like that but they're still in
the commit history the the spirit and
most of what they how they chose to
implement that is kept so they really do
become a contributor part owner and in
the history of repository and I think
the third way that's very important is
API consistency so this is things like
if you have list API so make sure you
use the same parameters and headers for
pagination regardless of what services
is right you're not doing pagination
lots of different ways we're a few of
asynchronous functionality we're a
resource is not going to be ready in
this in the time when HTTP requests can
be served right how do you expose
polling on that asynchronous state until
a complete state if you do that
differently in all your services for one
your customers are going to be super
confused because when they write code
using your developer tools or the REST
API they're gonna have to do it in lots
of different ways and other teams like
for example the O's the Oracle cloud
infrastructure browser experience team
is also gonna have to code lots of
different ways but so are we
if you do that right so we enforce
consistency on our services not just for
the customers sake but also because it
helps us scale if we're gonna build
paginate errs if all services do with
stay P is the same way in terms of
pagination we can build a paginate or
once per developer tool and we're done
we support all services now and in the
future as long as they have consistent
api's same for waiting functionality
waiting on asynchronous things to finish
same with semantics for how you would do
or filtering in query strings for
example like I have here cars make equal
super and make locals Toyota
as long as services kind of respect the
same way of implementing semantics and
functionality we can build it once and
it will work for all of our services
instead of having to build a specific
version per service or per operation
which we've enough to test we didn't
have to understand how the service works
and then write it and then test it and
make sure it works in the developer
tools we built so it really helps us
scale a lot it also is actually made
easier through swagger because some
swagger lets you codify your rest
interfaces this is what my API looks
like not only can we manually code
review that but we can put it through a
CI CD pipeline that has a automated
verification tool that knows how to
understand the swagger specification the
format and can do things like look at
your list API s for example and say hey
you don't have the right header we use
for pagination and or hey you don't have
the right query string we use to pass
the pagination token and it allows us to
scale validating that our aps are
consistent to be much much quicker and
much easier for us so with that I'm
going to turn it over to Esteban to talk
about the scope problem I talked about
earlier and how we've decided to solve
that all right so I've Joe was talking
about a few as lights earlier one of the
problems that we had is the different
bellezza scopes and you can think of
this problem as a team decides they want
to release version number one see your
point one but they're not quite ready
for it but they would like to have SDK
support for it so they decide to give a
summit spec you know later on we wanted
this we want to release some public SDK
but we don't want to include this
internal version only so we have to
somehow exclude what they provided to us
and not release it publicly and so in
between there's always there's different
combinations of a feature and a
specification would like to have so we
call this video scopes prom the first
thing that we tried is to first add a
flag to the spec that would tell us what
sort of release this service was so we
would have a future flag size XOM see a
preview only or release only and so on
and the other thing that we did is we
created a granting model that would
match those relays the scopes
and worked well for a while we were able
to keep up with internal changes and
produce the SDKs for what the team's was
asking us for even when there was some
public releases with ties that flag and
exclude those futures from the public
SDK and so on so working well for a
while until we realize that we're
patches and needed to be applied across
the whole branch in modifications and
not only that we'll be they would be
changes that we're going to take a long
time to be merged into the big branch
the public branch so a lot of these
branches can ended up being very long
live branches and the problems that
happens when you have long thin branches
is that you have to keep applying
changes to it and eventually they go out
of sync and merging becomes a mess and
so it started to become a problem also
when teams decided that they don't want
they want to go public they had to
remember to take those flags off so if
you know the Cambria future was ready to
be released somebody had the one beam
and remove that like and oftentimes that
that was the services team
responsibility to do it sometimes they
didn't do it and we wouldn't catch it on
Tommy would forget to release those
things so they had some difficulties
what we're trying next is to actually
enhance the Yama file with if that
statements that plus a file of whitelist
features we call it so each of the
different releases Koch's would have an
ID for each of the futures that were
planning on releasing for data scope for
example if you would want to release
future number one presumably you you
fill a file with all the wit feature
number one in it you know there would be
a pre-processing a step I would go and
either exclude or include the things as
annotated and in the whitelist file and
that gives us the flexibility of
deciding what we're going to
in our hands now the teams don't really
have to go and remove or add flags so
stay ready to move from public releases
that from internally system releases
they can tell us hey we're ready to
leave those things we up we update the
file if we're not changing anything in
the llamo file in the spectral itself
now the downside to this is our llamo
file is no longer llamo file if the
statements are not part of the llamo
specification so if there are tools that
consume ya know they have to now run our
preprocessor that we have then and
that's a con however so far that has
been we okay with that trade off the
trader of allowing us to modify those
specs on the fly without relying on
somebody removing something from the
llamo file outweighs some of the side
effects of having if the statements in
our llamo specs so that would be it for
us Joe I think you have some less yeah
so it's that's pretty much it one thing
I wanted to add is just the best way to
scale for us to grow is to add people to
the team we're interested in this stuff
right so if this is the kind of thing
you're interested in building products
for developers your polyglot who likes
multiple languages you like swagger this
all is really interesting to you you
know come talk to me after send me an
email
we're definitely looking to have people
join the team so and with that thanks
for coming everyone and I will open it
to questions thank you any questions
from the audience all right all right
well we'll hang out for a little bit
over here if you have private questions
thanks for coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>