<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Enhanced Metadata in Java SE 8 | Coder Coacher - Coaching Coders</title><meta content="Enhanced Metadata in Java SE 8 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Enhanced Metadata in Java SE 8</b></h2><h5 class="post__date">2015-06-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/WhXLmwEmX_U" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to enhanced metadata in java SE
8 my name is Alex Buckley I'm the spec
lead for the Java language nvm at Oracle
I'm doing this talk in collaboration
with my colleague in red Joe Darcy also
on the also in the Java platform group
and professor Michael Ernst from the
University of Washington who is my co
spec lead on one of the jrs that we'll
talk about in this presentation he's not
in red a word from our lawyers
essentially nothing I say may be relied
on in a contract so we're gonna in this
presentation we're going to cover quite
a lot of ground and it's ground that
effects quite a different number of
communities it effects job developers
who are applying annotations Java
developers who are writing frameworks
that use reflection api's of various
kinds to read annotations and other
other metadata and it effects API
designers who are designing types that
then get applied throughout your code
and so I will try at various points to
say which perspective I am describing so
I'm going to introduce some of the
features that we're adding in the Java
language and libraries in Java SE 8
professor ants will then show an
application of one of those features
type annotations and there are some very
nice stories about how you can use this
feature then I'll talk about some of the
language design issues in the features
i'm about to show and then Joe will talk
about the deep dive into the API
evolution that comes along with
designing language features so to dive
into some of the features straightaway
suppose you are using the jax-rs API to
define a resource that is to be accessed
over HTTP in Java SE 7 you would define
a resource class you use the path
annotation type to specify the HTTP URL
you can access the resource at and
because parameters of the methods in the
resource class are used
in the HTTP URLs you need to write an
annotation at query parameter Matthew no
jax-rs which basically repeats the name
of the method parameter so that
reflective clients Java frameworks
notably can determine the name of that
parameter and you might say why'd you
need to do that why can't you just get
the name of parameter the answer is it's
never been stored in the class file
before it's something of a hole in the
Java platform and so in Java SE eights
two features repeating annotations and
parameter reflection allow more useful
things to be written and at the same
time less or fewer useless things to be
written so it's possible now depending
on the wishes of the API designer that's
one community it's possible for people
declaring resource classes that's
another community to repeat annotations
of the same type this might seem what
this is a feature this was not possible
when annotations were added in Java SE 5
you can write multiple annotations
somewhere at a at be at sea but you
can't have multiple annotations of the
same type in Java SE five six or seven
you can't do its compile time error now
you can that's it that's the repeating
habitations feature in the language a
restriction that was there has now been
removed so I'm not speaking for the
jax-rs API designers they may or may not
choose to allow this but it can clearly
be useful in general to have multiple
annotations of the same type perhaps
with different value elements at the
same location in source code and you'll
notice there's no a query / am because
we now if if developers desire it store
parameter names into the class file and
so reflective clients like the jax-rs
reference implementation can read
parameter names and use those you know
to build skeletons that are acts that
that have json data pass to them and
build up stacks from
without you having to do this awful
repetition of every method parameter you
have to write a query parameter seen any
of the java e6 tutorials they
immediately dive into these will see
method declarations with every parameter
has an annotation next to it that
repeats the name and it's it's kind of
silly and it's because you couldn't get
parameter names and now you can so you
don't need to write the annotation
anymore that's what you're right in the
source if you repeat the annotation
there's nothing nothing magical looking
about that how does someone retrieve
those annotations well get the class
object my resource class we've added a
new method there's a bunch of new
methods Joe will talk about those
there's a new method get annotations by
type you give it the annotation type you
want Pascal class you get back an array
of annotation instances and then you use
those accent you're calling methods
which are the elements just in the same
way you always would for the parameter
names and actually other parameter
information I'll come on to that if
you've got a class object you call get
method as you always do never the method
object we've added a new method on
capital M method get parameters that
returns an array of objects which are of
a new type
java.lang.reflect.method.invoke an
determine all sorts of all sorts of
other things which will will come back
you later so so again you you these
these metadata features are primarily
not really about completely new kinds of
source constructs and say the way the
lambda expressions are there about
enhancing the metadata features that
came in in java SE 5 notably annotations
to make it easier to use them in
frameworks another feature in java SE 8
in this area is type annotations so this
is developed by jsr 308 which
Michael and I are the clothes Beck leads
for and what this is about is the
following in java SE five six and seven
what annotations really do is express
properties of declarations so here is a
field declaration and on our list of
string f it would surprise no one in
this room to learn that this is an
assertion to be checked by some
framework this is an assertion that this
field is never going to be null it's
always going to be a list object don't
think anyone has a problem with that you
can you can discuss the exact the exact
meaning of non null there is no non i'll
type in in java SE a time simply using
it as an example but when you see an
annotation you can say ok it's clearly
associated with the thing next to it
this is a non null field how would you
express properties of the lists elements
suppose you wanted to say I don't really
mind whether the list itself is null or
not I mean it's nice if it's non now but
I don't really care about that I want to
ensure that the elements of the list are
never null well maybe you could try
declaring a class non null string with
extend string and enforces lots of
invariants and checks that you know
never allows nulls to be passed two
constructors blah blah blah you could do
all that except you know and then you'd
use that type in a in a parameterized
type list of non null string oh ok it's
going to be a list and there's never
going to be a null in it well except you
can't because string is final and
nothing you can still have a null
instance of class non null string right
it's sort of outside the domain of the
non null string class to prevent itself
from being null so you can't do that but
in java SE 8 we're now we now allow
annotations to be written in many more
places than in java SE 7 so one example
of that is on a type argument we have
all these sophisticated types in the
Java language now we have array types we
have parameterised types we have wild
card types with bounds we have nested
Nestor types so these have some
structure to them and it can be very
useful to write annotations right down
inside the structure
of those types for example here's a list
of non Mel strings maybe the list itself
is now not too bothered but if you ever
have a list you would like to guarantee
that none of the strings in it are null
and so we now allow you to write like I
say annotations essentially on any type
wherever it appears in the language on
extends clauses and throws clauses catch
clauses inside expressions like cast an
instance of and new any if you think
about writing new see and you want to
say well this this new object is not
null you can write that new at non-null
see part of adding a feature to the
platform is you add something in source
you have to allow it to be exposed
through core reflection
java.lang.reflect.method.invoke extends
not just a bar but a a non-null bar and
again the exact meaning is is is it's
sort of a higher level concern you'll
see that in Michaels demonstrations just
for now assume that you have wanted to
write an annotation in the location of
the black box so you might say well how
would I retrieve that I could say food
or class get super class that gives me a
class object for bar and you might think
that I can just call get annotation for
non null on that class object you might
think that's what you could do but you
can't because food or class don't get
super class returns the class object for
the declaration of class bar the
declaration of class bar is there at the
bottom there's any one of them that's
what gets super class means most of the
methods in java.lang reflects return
reflection reflective objects for
declarations of things here's a
declaration of a class bar it's got
annotations of its own that would
surprise no one and so when you say get
annotation non-null dot plus the answer
is there aren't any I mean there's an
ABC there's an D
yes but you're not interested in that
declaration you want to know
specifically that use of type bar in
that extends clause in that black box
that's what you want the annotation for
so we've had to go through
java.lang.reflect.method.invoke an
appear in the language extends clauses
throws clauses i set a list of them
before and so food or class right doc
get annotated superclass and that
doesn't give you back a class object cuz
a class object is a declaration of
something it gives you back an annotated
type object and the annotated type
really represents the black box it's a
syntactic location in the language and
then you can say get annotation of
whatever you want and you get the answer
and of course I showed repeating
annotations before these two features
interact you can repeat your annotations
in any of these locations so you could
actually say eighty get annotations by
type the new method I showed earlier
that all works it just it just all works
I showed this field declaration before a
list of at non null string how would i
get the annotation through core
reflection that's that's inside the
parameterised type it's quite
straightforward first get the field in
the usual way now the field itself is a
declaration of course that's what I feel
field exploration is so food or class
get field that's the old method but then
within that the type that happens to be
used in this particular field
declaration let's get that let's get
that black box and again we get an
annotated type which is a specific use
of a type in this field declaration
there's different from all other lists
strings in other field declarations and
then you zoom in you say I have an
annotated type remember this is the core
reflection API
java.lang.reflect.method.invoke
according to modern practices and yet we
have to extend it when there are these
new features and so unfortunately
there's a little bit of you know type
switching going on here if in fact that
black box let me go back on if that
black box is a parameterised type your a
list of something then do a downcast
from annotated type down to annotate to
parameterize type then you can get the
black boxes for all the annotated types
which the type arguments obviously
there's only one here so the 0th
annotated type element represents that
that particular black box and then you
can call get annotation in in the usual
way so those are some of the language
features and I'm going to hand over to
Michael now we're going to have to
switch little bit and he will show an
application of those type annotations
that I think you'll find very
interesting so unplug this
I don't know
okay thanks so Alex and Jo we're going
to be talking a lot about deep design
issues and I've been involved in those
too but today I want to talk to you
about something much higher level how
can people use these things I'm going to
give you one example which is pluggable
type checking that's a one application
of these type annotations so we like the
Java type checker because it prevents
you from making silly errors like
storing trying to store a string into an
int variable the problem with java's
type checkers it doesn't prevent enough
errors even if your code passes the type
checker it could still fail at run time
you get out a nullpointerexception you
could have side effects to something
you'd meant to be immutable you could
have mismatched parenthesis and your
regular expressions lots of other stuff
like that so if you're someone who
doesn't mind runtime exceptions then
maybe you should tune out for the rest
of my talk if you're someone who doesn't
like those then the idea here is take
any exception any error that could
happen to your program at runtime and
let's have the compiler tell you about
it instead compile time so the idea is
to take a more powerful type checker
plug that into the compiler as a
compiler plugin and it's going to tell
you about other sorts of errors so I
want to tell you about two specific
examples one is fake enumerations and
the other is units of measure so fake
enumerations that's just a term for when
you use an int when it would have been
better for you to use in a new so here
here let's take an example from the
Android API Android has this thing
called restriction entry and it has a
bunch of values and you notice that
they're all in and if I look at the set
type method it takes an int argument and
it says parameters the type what is this
int I don't know and this this
documentation it surely doesn't help me
to figure that out either so but let's
look at the source code surely the
source code will tell me but here if I
look at the source code for set type it
just and surely the source code would
also do some input validation so your
code wouldn't
crash horribly later right well no
here's the the implementation it takes
any old int you want to pass in and get
type doesn't do any validation either
this can be bad let me give you an
example of how it can be bad here's a
client that's trying to use these
restriction entries so if i compile this
it compiles just fine no errors at all
but if you look here there's some
nonsensical stuff here we're passing in
five as an integer to set type now this
is actually less than one of the legal
values and more than one of the other
legal values that's between two legal
values and it is not a legal value so if
you were to do this bad things could
happen at runtime well how can i prevent
this kind of error here here's let's
define a new type I'm going to call it
restriction type so here I've declared a
Java annotation you declare that with
that interface and I'm saying two things
about it the first thing I'm saying is
this is a type annotation you can write
down on type uses and type parameters
and the second and that's the syntax of
this thing the second thing I'm saying
is the semantics I'm saying this is a
fake enumeration now let's go back to
our test code and let's compile it using
a pluggable type checker that uses that
tight and it boom it says look you have
an error here you've passed in some
arbitrary integer 5 in a place that
requires a restriction type how did we
know it requires a restriction type well
we know that because I've also annotated
the Android API and I've said type
boolean type choice etc our restriction
types the thing you get back from get
type is not just an int it's a
restriction type int and set type only
takes restriction tie pins it doesn't
take arbitrary ends so up here at the
top what really happened is I made a
goof I shouldn't
passing in five I should have been
passing in the parameter so now this is
surely correct so we'll just run the
type checker and it'll tell us
everything is okay oh so what's
happening here well look i said this
parameter will take it this method will
take as its parameter and int any old
int someone could pass in any int they
wanted here and then i would go setting
it as a restriction type that would not
be legal I want to express that the only
type of integer that should be passed in
here is there's restriction type integer
and now if I compile again I see that
that I didn't have an error here anymore
but now I have one here it's the same
error ahead before but it went through
multiple levels of indirection it shows
that that the analysis is
interprocedural this could have been in
two different classes even and so what I
really wanted to do here was pass in
something legal like type boolean and
when I do that finally the whole thing
type checks so what I've done is I've
improved the documentation 03 Android
SDK and for for my own methods I wrote
this restriction type type here I don't
even have to write that most places here
I've declared something as an int but
because it came from get type the system
knows its restriction type and so this
other call is legal to so a lot of
inside your method bodies you generally
don't have to write anything on method
signatures you wanted to write something
anyway because it improves the
documentation questions on this okay so
let's uh so that was a demo of fake
enumerations that was of course a
trivial example so you could follow it
on the screen let me show you some some
real examples here's some from the jab
ref bibliography manager I don't want to
disappear software but this is an easy
error to make here are three errors they
made the first one is in the constructor
for entry type dialogue they set the
alignment and they set the alignment to
swing constant sot left which whose
value is 2 now they should have been
component right alignment this is in a
completely different class
and its value is different too so that's
not what you want another example is
when they were making a progress bar the
arguments to a progress bar are the
minimum and maximum values but they
instead passed in J progress bar dot
horizontal which tells you the
orientation and the maximum value again
not the desired effect and they had no
way of knowing this is a problem just
from using the Java type checker and the
final example is when they were setting
a jlabel setting it's a vertical
alignment they set it to North which is
not what you're looking for they should
it should have been top so it's an easy
mistake to make so that's that's example
one how to use fake enumerations and how
you can define your own even let me give
you another example which is units of
measure we don't want to mix up things
like meters and yards or kilograms and
pounds or radians and degrees so what
can go wrong here well here's one
example the Mars climate orbiter the
control the software controller used
pound force seconds instead of Newton's
seconds and so it crashed into Mars
losing three years of work ten months of
travel over a hundred million dollars
this left image is an artist's depiction
of what it looked like and that smudge
is what it actually looked like a famous
a failure in aviation is the so-called
Gimli glider where air canada personnel
computed their fuel in pounds instead of
kilograms so they had about forty
percent as much as they needed the
aircraft rang completely out of fuel at
on route and they had to glide onto an
abandoned airfield as a miracle that no
one was killed you can also cause
rampaging turtles so Moorpark College
got a loan from the LA Zoo of a tortoise
and they built an enclosure for a 250
pound tortoise the first night there 250
kilograms Portis pushed over the fence
post and escaped the enclosure and
here's another example ballistics
suppose your test firing a weapon
and you want to figure out how far to
the right of this on this diagram you
want to be so that you don't get smashed
by the projectile let's take a look at
some code for this right so here is some
code and I have a projectile range
method and imagine this is in your
physics library and it tells you the
distance that a projector will go given
its launch velocity and its launch angle
now here's the predicating user code am
i safe and it tells you the launch
velocity it takes the launch velocity
and the launch angle and a distance and
it just asked is the distance greater
than the projectile range and if so then
I'm safe so let's you let's instantiate
this let's assume the muzzle velocity is
100 meters per second the angle is a 45
degree angle and I'm going to stand the
kilometer away so am i safe well if I
look at look here at the bottom and my
safe returns true so that's great maybe
I should stand a good kilogram away
sorry I could kill kilometer away well
not so much projecto range of 145 gives
me back 912 meters but projecto range
tape should be computing in radians not
degrees and if you pass in the radians
you get a thousand twenty meters which
means you're actually going to get
slammed by this so again the Java
compiler doesn't tell you a thing let's
run our type checker for units and it
tells you the air right away it points
out that you have this problem with the
launch angle so what I'm going to do is
change the degrees to radians
and change it here as well and I don't
want 45 i want pi over four and now when
i compile the the type checker the
extended type checker is happy and I'm
actually safe when it says am i safe
which is which may be important to you
as well as the type checker so what did
we see oh so the tool that i was using
here is something called the checker
framework it's a tool for pluggable type
checking and it comes with a couple
dozen type checkers built-in null
pointers incorrect quality tests
synchronization and locking security
string syntax internationalization on
and on but you can also build your own
and you saw a little example of that it
makes it takes advantage of java type
annotations you could also use it today
if you want just writing things can calm
your extra annotations and comments and
then things will still compile with with
java 7 as well so what we saw is that
there are two benefits here one big
benefit is improves the documentation so
you understand what your code is doing
and by the way that documentation is
machine check so it's actually correct
and it also detects and prevents bugs so
if you want to use it this tool is
available for download and now we'll go
back to Alex who'll tell you some more
about design issues
ok
amazing
thank you very much so I'm going to talk
now about some of the design issues in
the repeating annotations and parameter
reflection features so we thought about
jax-rs before let's use an example now
from JP a another EE API so they have an
annotation type join column that they
use to express your right on methods
that you used to express the the way
this method relates to some column in
the database so in general without
getting into the details again of this
particular API we would like all the in
fact the API designers would like people
to be able to take code that just has
the one at join column annotation and
write multiple at joint column
annotations that's or the goal of this
you just write them in doesn't seem too
too difficult right you just should
write whatever is necessary to express
your business logic if we were to
compile those two annotations directly
into the class file so if the class file
was a manager of a class file version of
a method with two annotations on it
which is legal today actually the class
file has no problem representing that if
we were to compile those two source
annotations at join column at drawing
column into a class file that looked
like that then unknown framework code
could get upset because framework code
has always assumed that it will never
see more than one annotation of any
given type and so it may very well be
that there's framework code that says
well on some get him on all the getter
methods called get annotations get
annotations returns all the annotations
that are present in a class file and
it's always assumed that there's been at
most one of each type and so if you go
and add those annotations into a set say
the framework might get a surprise
because well actually who knows which of
the joint column annotations you will
end up with that's just that's just the
way it thats the way it has been in
since 2004 and so the way that
frameworks work today is that they
use the container pattern very widely
used throughout the Java EE ap is and
what those frameworks do is they offer
you to annotation types join column and
join columns and if you want to write
more than one a joint column you have to
write this thing right so going from
just the one annotation to more than one
means you have to write this whole
wrapper thing around it as well and then
what the framework code typically does
is it says get annotation get the joint
columns one get the plural version and
it is not there get the single vert yet
the singular version get the join column
so again if we would just compile the
two annotations at join column a and
column to the class file this code it
would try and get joined columns the
plural version there wouldn't be one it
would go to the second case it will try
and get the join column annotation well
there are two first question which one
would it get would it have to be the
same every time I mean that that's now
we'd have to specify all of that but but
the real issue is that framework code is
assuming there is at most one annotation
of any given type but now there are two
in the class file that the language has
affected could have effectively broken
unknown in variants of unknown
frameworks and so effectively we've had
to embed the container pattern from E in
java SE Brian gets has this great quote
today's problems come from yesterday
solutions the container pattern that at
join columns wrapper thing that was
yesterday solution but it's still with
us because we have all of these
frameworks using the core reflection API
to read annotations and so behavioral
compatibility not sauce or binary or
migration but behavioral compatibility
of these unknown frameworks when they're
using core reflection demands that when
you write repeating annotations we will
wrap them for you in one of those
containers the existing methods like get
annotation and get annotations they
don't change dealt they'll see in the
class file those annotations those
wrappers exactly is if you've written in
my hand today and then the new method I
showed earlier get annotations by type
through it knows how to look through
that container annotation and just give
you back an array of the drawing column
John column John color etc and so what
this means is if you have if you're an
API designer and you have a repeatable
annotation type you have to nominate its
containing type so here are actually
basically in blue the current
definitions of these two annotations we
call the base annotation and the
container and you when you have to
opt-in effectively to your annotation
type being repeatable and when you do
that you have to say who its container
is going to be so we the compiler will
then know what to wrap the multiple
annotations in and then we can guarantee
we can guarantee no change in behavior
for existing clients that use core
reflection because they're using the
existing methods and they'll see exactly
what they used to see when you wrote it
by hand so they're always there have
always been decisions when declaring an
annotation type is it documented part of
the public API is it inherited what's
the retention policy what is the target
for the annotations now additionally you
as the API designer you have the choice
of is my annotation type repeatable you
get to decide that and there's a little
subtle thing as well of where can eat
annotations be repeated so in general
it's possible to have an annotation that
applies to say fields and methods but
it's only repeatable on methods that's
something the Java EE designers asked
for moving quickly on here are some
interesting and brief issues in
parameter reflection parameter names
have never been used by the JVM they're
traditionally seen as debugging symbols
and although it's possible to get them
emitted into the class file if you know
the right flags they've ever been
exposed through core reflection like I
say there is in SE 7 no
java.lang.reflect.method.invoke
and so the question arises should names
of parameters be present in jdk class
files in our tea jar if so is oracle
committed to the long-term stability of
those names and more broadly should when
you compile your own classes should your
parameter names be written into class
files and because of a shortage of time
and out of an abundance of caution the
answers of these things is no in Java SE
8 we are not forcing these parameter
names which it sometimes called things
like secrets and password we're not
forcing those things always to be
written into class files either in our
own class files or yours the world's not
ready for that obviously class file size
would grow as well but the the privacy
concerns that are worrying so then
there's a question of well okay i want
my names included I want someone to
reflect over my methods and their
parameters how can i opt in since the
names aren't included by default we
discussed various approaches we
discussed these are proposed approaches
we discussed an explicit approach where
you simply write at include parameter
names on a class or method and that's
your opt-in mechanism easy we discussed
a semi explicit approach where if there
is any annotation on a class or method
that is itself meta annotated with that
include parameter names so for example
if you have an out web service
annotation on a class and the web
service annotation type is met or
annotated with this @include parameter
names that means all the methods of this
web service class have their parameters
written out that was another proposal
and then there's a sort of this implicit
approach where if there is any runtime
retention annotation anywhere inside the
class that means someone is expected to
reflect over this class and read the
runtime annotations so maybe that's
enough of a trigger to write out the
parameter names then you get into should
you do it for all of the methods in the
class or just the public methods in the
class there are actually there's no
language it's weird there's no language
syntax for this but actually there are a
whole bunch of dimensions here and you
you end up having arguments with people
who have radically different views on
the same thing it's just like having
some tax disc
options there was no consensus in se8
I'm sorry to report so we're not
committing in se8 to any of these things
maybe in se9 we will revisit it but for
now essentially you have to rely on your
tools so Java Sea supports a- parameters
flag that will blast out the parameter
names for everything in your classes in
that compilation I expect ide zwolle for
a checkbox that says include parameter
names for so-and-so classes and
so-and-so packages or just the public
methods there in etc so again an
abundance of caution prevents us from
putting something into the language in
the class file and the reflection
libraries before we're really sure that
it's it's it's supporting use cases that
are widely accepted so with that I'll
hand over to Joe to discuss API
evolution
well thank you stepping back a bit
there's a question of what is the full
set of things you need to do when you're
evolving the java programming language
clearly you have to update the language
specification and the compiler but
that's really only the beginning there's
actually a quite long list and for the
metadata features we've been discussing
today even though they're relatively
small features we still had to do almost
every item on this list besides
expecting compiler updates there are
some updates to the core libraries and
central library support we're not going
to discuss this today but there's
actually a very interesting test
methodology used for many of these
features we wrote programs that generate
programs that test the combination so
sometimes there are regression tests
that will go through thousands of
different combinations to make sure they
work in all cases we've been discussing
today about Java language features but
this these changes actually also involve
the virtual machine there's a new
attributes that are defined that's a
virtual machine change and whenever you
update the virtual machine you also have
specification you also have to update
the consumers of class files those
include virtual machines like hot spot
but they also include other libraries
downstream including other libraries in
the jdk such as pack 200 which
compresses files i'll be talking more
and a slider to about the reflective
api's and even things like Java doc have
to be updated to show the new
information so Mike and Alex talked
about using annotations for type uses
when you declare your annotation type
you can say where it goes and now there
are new enum constants to control that
there's the type use constant as well as
type parameter from java SE 5
annotations couldn't be applied to type
parameters even though type parameters
were declarations that was an admission
from the initial annotations proposal
that's been corrected in SE eight
reflective api's we have Corey flexion
we've spoken about before how many
people have used javax line model the
annotation
processing API a few hands okay that's
good to see that also had to be updated
and there's the annotation processing
API Mike's checkers in part used the
annotation processing API and those have
to be updated along the way so Alex
mentioned already some changes we need
to annotated element this is the
interface that's used to read
annotations at runtime and corey flexion
so essentially two new methods were
added that take a class object now and
you get back an array of annotations
instead of a single annotation and they
differ about whether or not they look
look at inheritance or not and we round
out the methods by again something that
was omitted from the original
annotations proposal we also did a
change to an existing method is
annotation present this is a convenience
method initially original API that was
equivalent to getting the annotation for
that class and seeing whether or not it
was not and we have a new feature as
part of project lambda going into JDK 8
called default method which allow you to
now put code into interfaces so this
method is annotation present that had
duplicated code in all these
implementations in the JDK we thought
great we can take advantage of this
feature that's being added else when the
platform and it'll work just fine that's
what we thought we went through and
implemented it and we always take care
to look at the compatibility aspects of
the changes so changing this existing
method from a normal interface to a
default for java SE 8 is both source and
binary compatible the method is still
there your class files will still link
it's also behavior compatible because
it's doing the same thing as before
unfortunately there was a wrinkle if you
use a dedicate eight java sea to compile
against older source and target versions
without studying the boot class path
then you're in this curious situation
where your java 7 sources will now see
well
like your default method or will they
Java Sea assumed that if you have a
default method and you're using source
seven or earlier that it doesn't exist
so the is annotation present method that
is there in java SE eight because their
compiler artifact artifact if you
compile for an older source version
isn't there anymore now this isn't the
recommended configuration but we know
many people do actually compile in this
way without setting the boot class path
so to avoid up our users having problems
we added back trivial implementations
that call into the default method
defined on the interface so we still get
the code sharing and just a little bit
of bloat in the class files so if you're
looking to update your own interface
hierarchies in this way this is a little
wrinkle to watch out for Alex before
talked about we can now associate
annotations not just with declarations
but with type uses and the api's that
existed before job eight reflected this
you could get back your annotations from
java.lang.class and DoubleLine reflect
and from the language model and the
assuming now that we have type uses we
have to make sure that we have a model
for type uses in the reflective API so
that we can retrieve the annotations
appropriately if you're designing
reflective ap is there's a very
excellent paper by Claude Brock and
David Unger that lays out many of the
properties these api should have and
what happens when these api's don't have
the properties in question luckily for
me as the lead engineer for java XY
model in the early apt project this
paper was written before i started my
work so the api is benefited from the
lessons learned in this paper and
unfortunately a core reflection didn't
could not benefit from these lessons
since the paper was written afterwards
one of the key design decisions in the
java x lying model AP is from the
beginning was a separation between the
type uses and their type declaration in
fact those are in separate
sub packages in this API this API also
has methods for reading annotations as
you'd expect and for consistency I'll we
essentially duplicated the specification
of one of the core reflection API
methods to read annotations into the
Java XY model API so that if you're
going between them that the behavior is
as consistent so given that we had an
API that was designed with the benefits
of hindsight from reflective api's how
could we extend it now to have this new
language feature the extension actually
went fairly simply we had this existing
method to read annotations we pulled
that up into a new super interface we're
defining we added a new method to deal
with the repeating annotations as a
lotta has discussed and that was pretty
much it we then made the element
hierarchy that models declarations
implement the new interface the new
super interface it was defined so in
fact that just adds one method to that
interface hierarchy the new method to
deal with repeating annotations we have
a separate set of interfaces that model
types in separate package so now we just
have that separate type hierarchy
implement the same super interface and
all's fine you use the same API whether
you're reading declarations or reading
types so what happens when we try to do
the same modification to core reflection
will it be as straightforward and in
neat unfortunately the answer is no
corey flexion again very old API back
from 10 or 11 depending on what part you
you look at it did not have a separation
between declarations and types in
particular there is no separation even
between java.util.set and instances of
that type like our instantiation
java.util.set of string versus set of
tea when you call methods on say class
to get back type information about that
like class tell me your
interfaces you get back class objects so
and again as Alex mentioned is this
example this class object you get back
corresponds to the Declaration of the
interface not for the use of the
interface so we have a identity crisis
here we need something that is not
associated with the Declaration of the
type of with its juice so the solution
here was to define a new set of types
that are essentially tuples called
annotated type there are a tuple of the
type use model is a class object and
then the annotations that are present
there so while this preserves the proper
identity you'd want it is a much larger
API footprint and it is a little little
awkward to use annotation processing is
also related to annotations so how
should this API be updated if you've
written an annotation processor you
declare what annotations your processor
supports the annotation infrastructure
will then look over the type annotation
types presence in the program and match
up your processor depending on what
types have been present in terms of
preserving behavioral compatibility
since we've expanded the set of
annotation subtle locations annotations
can occur as well as changed repeating
annotations what updates should occur to
preserve behavioral compatibility we
essentially ignore the new language
features so that old processors continue
to work the same way so if you have a
type type you sanitation that is not
picked up in this discovery process to
use for annotation processing we do see
annotations on type variables because
their declarations but if you use
repeating annotations you don't see the
repetitions instead you see the
container annotation that Alex mentioned
before what happens when you use rapini
annotation in the compiler is that the
compiler will omit the container
annotation into the class file and that
is the annotation that's present as far
as annotation processing is concerned so
the recommendation is if you want to
process a repeatable annotation you
should process the annotation itself
as well as the containing annotation
type and that's exactly the pattern you
probably already be following if you're
using one of the e frameworks Alex
mentioned before that people use apt in
the audience no fans the only one or two
hands going up well it's good then you
won't be upset by being removed from the
platform this was something we added
back in jdk five and we always knew it
was a transitional technology I was the
lead engineer both for apt in the
replacement jsr 269 I can say
wholeheartedly that the apt the Java Sea
implementation 269 is uniformly better
it's the API is better and it's faster
to use and perhaps setting a precedent
for things to come the apt to was
deprecated in seven and then actually
removed an eight so it is actually gone
if you happen to need use of it there is
a Apache project that looks to provide
extra additional API to implement the
old API on top of the new ones so we've
seen before that the java x line model
api is in some ways designed better in
some ways easier to use however a lot of
annotation processing happens at runtime
where core reflection is the api to used
so can we get the best of both of these
worlds can we get the runtime usability
of quarry flexion but have this pure a
PR job x line model and the answer is
yes we can there is a jdk a project to
add this to the platform it's currently
only added a sample code but a design
riders available and at some level this
is a very simple idea it's repeated uses
of the adapter pattern so in particular
say we take a object from corey flexion
such as java.lang.reflect.method.invoke
slime model which is called an
executable and since Java X line models
based on interfaces we can have multiple
implementations in particular instead of
one back by Java Sea compile-time data
structures we can have one back by run
time for reflection
data structures instead in terms of
designing the method we have we got to
play around a little bit and have some
specializations of the API this year is
just the type hierarchy for Java XY
model as it comes out of the box we
created subinterfaces for the versions
that offer runtime types we did this so
you could have specialized return types
so if you have a get foo method that
would return some other kind of element
we'd specialized that to return
reflection element instead so you
wouldn't lose fidelity by calling the
methods on the interface and since it's
the same basic inheritance structure if
you happen to already be familiar with
Java XY model you can very easily
transition to using the specialized API
there are some other benefits we got
from implementing java client model back
like or reflection to the core API on
the platform itself by infinitely this
API it highlighted us that there's a
great similarity between
java.lang.reflect.method.invoke flecked
constructor so they're almost identical
there's only a few methods differ
between them and to capture that we now
added a Java line reflects acute abul as
a superclass to both of those so that's
a bit of common functionality we also
use the Java line parameter type in the
sample code to help validate its use and
it's at least theoretically possible
that we could have this sort of API
provided at runtime in Java SE nine or
later so if you're interested please use
this API and send us feedback to help
guide how that might look and with that
I'll turn it back to Alex so I will just
skip this one slide that says when you
had language features you have to add
lots of other feature support in the
platform as well that's what that slide
says everything interacts with
everything to summarize the repeating
and type annotations features enable
more powerful and more flexible
frameworks and that in turn enables
essentially easier development for you
less boilerplate less
this repetition the parameter reflection
feature fixes a long-standing bug in the
platform and access to the language
model API which you know I would
encourage you all to look at you can do
amazing things with the language model
and annotation processing AP is being
able to use it at runtime again vastly
improves ease of use for reflective
frameworks and again in turn for all of
you and I'm sure many talks this week
we'll be mentioning this but when doing
language and API design compatibility
source binary behavioral migration
sometimes some are more important than
others for differing features but
compatibility essentially always
dominates the design of these features
and so with that thank you for listening
we'll take questions I guess we have
just a few minutes any questions I guess
will you can come up before they I guess
they're going to come in and throw us
out in a minute quickly you will first
one question shout it out please yes I
know the question yes ah yes the
question was if you compile in such a
way that you omit the debugging
attributes which do buried deep down
have the parameter names can you use the
java.lang reflect / ammeter API to
retrieve those names the answer is sadly
not because actually
java.lang.reflect.method.invoke
attributes never has been never would be
so this is it and this is the clean way
to do it so we don't fall back on other
attributes that might not be present
either last question
is that for the idea hotline he made the
path of API and basically use X it seems
like rich office to be a better way was
it okay so the question is why would you
use type annotations to enrich your type
system when you could have created a
real class like unit or like meters
instead of at meters ant and the answer
is if you can do that you should do it
but often times you have legacy code and
there are classes that cannot be
extended like int and string so this and
and there are some features that this
has that you wouldn't necessarily get
without extending the type system as
well so yes if you can do something for
real in the existing type system I
recommend you do it there are many cases
where you need to use annotations great
question so thank you very much have a
great day and come up and talk to us if
you like</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>