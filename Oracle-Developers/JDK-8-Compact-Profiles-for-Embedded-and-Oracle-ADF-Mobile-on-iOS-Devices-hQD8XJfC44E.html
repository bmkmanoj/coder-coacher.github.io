<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JDK 8 Compact Profiles for Embedded and Oracle ADF Mobile on iOS Devices | Coder Coacher - Coaching Coders</title><meta content="JDK 8 Compact Profiles for Embedded and Oracle ADF Mobile on iOS Devices - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>JDK 8 Compact Profiles for Embedded and Oracle ADF Mobile on iOS Devices</b></h2><h5 class="post__date">2015-06-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/hQD8XJfC44E" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning and welcome to the jdk
compact profiles talk my name is Bob
been dead i'm the java SE mobile and
embedded lead i'm going to go through
some of the details of the compact
profile support we have in jdk 8 but
first i have to put the obligatory
notice up here that tells you that you
know don't make any plans based on
anything here because we can change our
mind so what we're going to cover here
i'll give you an overview of what are
the compact profiles what are they good
for how are you going to build them
they're available in OpenJDK so you
could actually build them from sources
yourself and work with them we're
planning on providing a reference
implementation binaries that you can
download and compare your implementation
against and then i'll get into some of
our commercial products and what we're
planning on doing in SE embedded to make
use of compact profiles how you can
create them and what are some of the
typical use cases we plan customers will
be using profiles for and i'll provide a
little bit of eye candy and demos and
and show you some of the new ide support
that we have that make using profiles
really easy so what are compact profiles
they are three new se8 runtimes they're
compatible with the seh specification
that described in the JEP 161 that you
can access on the web today the URL is
here on there there are three compatible
subsets of s ii eight developers can
choose these subsets based on their
application needs or the runtime
resources that they have on their target
hardware we expect profiles to be used
in embedded devices which have you know
limited resources and people don't want
to spend extra money for flash cards and
lots of memory so the benefits are we
provide a smaller runtime for your
application it's a platform for our
embedded specific FX stack that is now
available we're providing a new tool
that lets you customize a runtime an SE
embedded prior to jdk 8 you we had very
fixed sets of of binaries and you had to
use the whole thing
now you can pick between different VMs
and different options to make your we
let you choose what the options are that
you want to deploy and obviously if your
runtime is smaller you get cooker
download for applications and updates of
your of your applications on your
embedded devices and the primary
motivation for us doing the compact
profiles was to do the convergence of
the CDC product line with se CDC is
based on 142 in older API sets we wanted
to modernize CDC and merge it in with
with jdk 8 so going forward all of the
new features that go into JDK 8 would be
available to CDC customers so the
compact profiles are similar to the CDC
foundation profile and the optional
packages that they supported it allows
migration from CDC based applications
that customers have developed to se8 his
kind of a picture contrasting the full
monolithic se that we've provided on in
Prior versions of SC instead of having
to deliver and ship the entire java
runtime for your application you can now
just deliver an application with the
smaller vm that we will be offering with
the compact profiles and one of the
compact profile layers you can deliver
your application if it only requires the
api's that are in compact one you don't
need to deliver any of the binaries that
are in the higher tiers the way the the
compact profiles are built they layer
upon each other so anything that's in
compact two is also includes the
contents in compact one so you can't
just ship the API is in compact to since
compact one provides kind of the basic
language support so here's an overview
of the contents of the comeback profiles
compact one is the smallest API the
smallest API collection it's we did not
admit any classes we have a bunch of API
packages the minimum set that that will
support the Java language specification
without emitting any specific classes
there are a couple of edge cases that
we'll talk about that we had to clean up
but for the most part we did not delete
any classes so if we include a package
everything is in that package
we also decided to add logging and the
security packages since we expect most
application developers will want to use
these and this base compact one provides
the migration path from a CDC foundation
profile application to compact one
compact two is equivalent to the
optional packages that CDC offered for
xml JDBC at our MI and the j srs are
listed here and compact compact two is
if you just application needs database
support for example you would ship a
compact to base runtime compact 3 is
basically everything else other than
desktop and server based api's so it's
kind of like our embedded headless
compact where we add everything else
that that is in the SE specification
this is we kind of refer to it as the
management of serviceability layer since
it adds all of the additional features
that allow you to to run serviceability
agent and jmx and other features we
don't expect every application will want
that so we've relegated those api's to
the higher tiers and we still offer in
our products the full java SE and even
on on arm platforms we have the JD caves
which has the java compiler etc so i
don't expect you to study this diagram
but it's in the slides in case you can
either refer to the JEP 161 which also
contains similar information but here
are the packages that are available at
the various tiers so here come a couple
of the rough edges when we were
designing the compact profiles we don't
as i mentioned subset the java language
spec compact one it basically implements
everything that's needed for JDK 8
language spec including the new streams
api's so we have lambda support in comp
back one and invoke dynamic is supported
we even have units the support for
JavaScript that can run a JavaScript
engine can run on compaq one we also
don't subset that the Java VM
specification so the entire vm spec is
implemented the entire java language
spec is implement
so aside from the few wrinkles that are
that are listed down here beans was
problematic javabeans because it has
dependency on the desktop AP is so we we
decided rather than trying to get rid of
moving the log manager in the pack 200
which is required to unpack applications
we decided just define those few API
cases and we move those out of the
compact profiles so when we generate
during the build a compact one profile
we actually delete these methods in RTR
so the RTI jar we generated is missing
these so don't use these we're going to
deprecate these in jdk 8 and we're going
to get rid of them in jdk 9 so what do
we do how do we build these things since
these this technology is available in
OpenJDK i want to go through a little
bit about the make file system you may
or may not know that we have a new make
file system in jdk 8 and we've leveraged
that new make file system in order to
generate the profile targets there's a
new profiles make target it creates
three new JRE images in the output
directory that's that's built its it is
a Jerry layout it's not a jdk layout
where the JRE is embedded 11 directory
level beneath it so we don't have a
compact jdk profile it's a JRE only
they're not upgradeable you can't kind
of add compaq one image to get a come
back to you basically have these three
distinct images and you use them as is
and each of the different profiles as I
mentioned we had to deal with the
removal of the property change listener
methods so they do have a different
implementation of log manager packer and
unpack classes they're primarily just
missing some methods these beans
references and in order to give
identification of of the runtime we've
modified them son mis virgin version
class which in the build itself was
generated to tell you the exact build
number and version string for the Java
for the Java Runtime anyway so we just
add the
my old information to that so if you
want to build this for yourself grab a
linux x86 box installed mercurial on it
if if you have the force extension do an
hgf clone of this URL and it will
download every one of the repositories
that are available on OpenJDK CD into
the target directory that it puts all
these repositories and need to make
image profiles so the build itself when
you're building profiles you can't just
do make profiles you have to build the
entire JDK it's just the way we designed
the profiles it's what the primary
reason was some of the some of the
slides coming up talk about it we wanted
to make sure that as as you build the
profiles you don't add dependencies in
some of the other classes that break the
profile so you want to go through the
entire build process do the validation
and generate the profiles so the
highlighted target is tells you you know
when you're generating the profiles and
if you change directories into the
images directory you'll see that we will
net we now have three new directories in
addition to the art the j2 re which is
the JRE image and the j2 sdk directory
which is the full jdk with java sea and
all the tools so we have j2 re compact
one two and three and these are images
you can just download and use and you'll
have the api's and and the content of
the job the compact one two or three
profiles so we're all the decisions made
as to what's in during the build we had
to identify the things that are included
the various profile levels there are two
main text files that are a reference
during the build and these are used for
lots of different reasons they're used
to actually generate the proper RT jar
and a proper binary contents but even
Java Sea uses it for features that I'll
talk about in a few slides and and and
it we generate a seated sim file that
has identifying information that tells
tools like knit beans
which profile and API is included in the
first file profiles dash includes covers
everything but the Archie jar contents
it taught it references things like
shared libraries that are needed
resources that are needed fonts and
things of that nature it tells you which
which profile those things are contained
within and the profiles are to jar
includes text is the text file that
defines the API packages that are
included in the different profiles if
you're contributing to OpenJDK you may
need to add some some new package in one
of these files or a new resource file in
one of these files in order to make sure
that compact profiles are properly
maintained during the bill the profiles
build at target runs a dependency
analyzer to make sure that if you're
adding something in the log or API
you're not referencing jmx api's and if
that happens the bill will fail with a
with an error telling you that you've
created a dependency that needs to be
corrected so it checks for references
the types that don't exist it checks the
boot class path for extensions directory
if it's a reference to an unknown type
it'll fail and it yeah does it there's a
exclusion file for some cases that we on
purpose had to add on the references
allowed file for jsse jar so here's an
example of someone breaking the build so
suppose we had a method to
java.lang.thread.run TSA's a thread MX
bean if we do the make profiles target
you'll see that it's doing the analyzing
of the RTR and the various jar files
that are that are in profile number one
and it will tell you that
java.lang.thread.run TSA's the thread MX
being so that's a bad thing go fix it I
mean if it's if it's explicit then that
particular you know package needs to be
changed so that you use reflections in
order to detect whether or not that API
is present so that it's not a hard-coded
dependency that's one way of solving
that problem
let's see so how do you identify what
profile your applications running on
that we explicitly decided not to add an
API that returns on profile compact one
the reason for that is that for you know
compact profiles is just a step in the
ultimate module system that we would
like to do in jdk 9 and we didn't want
to box ourselves in with this API so if
you have a you know random collection of
modules how do you know whether that's
the compact one profile or not so we
decided not to do that from an API point
of view but we do have two different
ways that you can tell what runtime you
are running on first of all you run Java
dash version and we're reporting compact
one as you can see highlighted in the
version string and we do have a release
file that is generated for each of the
compact profiles as you can see compact
one is the Java underscore profile
option there but we highly recommend
that if you want to use api's that may
or may not be in the profile you're
running on that you use a reflection
guard in order to verify that that API
is available before you use it so the
other thing that we've enhanced in jdk 8
to support profiles is a java compiler
we've added a new dash profile option
that will make sure that the code that
you're compiling can actually run on
compact to it uses some of the
information that's in that the profile
are to dodge our contents text file
during the build and it produces a CT
dot sim file with annotations that tell
the Java compiler which api's are
available for at the various profile
levels so as you can see here it's
reporting that thread MX get thread MX
bean is not available in compact two in
addition to the Java compiler the
NetBeans IDE has been enhanced in the
future seven dot for release which will
come out around the JDK time frame will
have real nice support for the compact
profiles in addition to selecting in
netbeans what jdk you want to develop
for whether it's jdk 7 or 8
you can also specify which profile your
application is targeting for and as you
can see in the right corner here if you
try to use a jbutton and you've selected
you know compact profile one it'll tell
you that's not available in that
particular profile so we have checking
at the Java compiler level at the IDE
level in addition if you say you want to
grab a third-party jar file you don't
have the source code necessarily you
didn't build it you don't even know what
API is it needs in order to run so we've
added a new tool in jdk a called J
depths and there's a dash p option in j
depths the telligent that will analyze a
jar file and tell you which api is its
dependent on and if you specify the dash
p it'll actually tell you which witch
profile the api's are referencing i'll
give you a quick example of that say you
wanted to add a json parser to your to
your java application I've got a quickie
command here so they don't want the type
so much if we use the J depth command
and I have jdk 8 build 106 on my this is
on my Mac it's a jdk for mac that i'm
using to run the Jade eps command so the
all of these tools and enhancements are
not just in our embedded specific or a
profile specific set of binaries it's in
every jdk 8 jdk that you'll be able to
download or can download now with their
early accesses are available so if you
run the Jade eps command on this Jason
parser it'll go through all of the
packages and classes within it and tell
you which compact profile those api's
require so as you can see looking on the
right the JSON parser can can run with
compact one profile without any other
dependencies now if i go to you know
this is probably a barely bad example
because the desktop swing awt api's are
up at the full JRE but just to show you
the same kind of command for a
jfreechart which is a swing toolkit for
doing charting
just to show you what kind of output you
would see if it if it told you that it
wouldn't run on compaq one you can see
here that the the first package or
jfreechart requires a WT the event and
the geometry and image classes it does
have some some references to compaq one
full there's a lot of full JRE obviously
do the swing ap eyes that are required
so obviously this wouldn't run on a
compact one profile that there's
actually other other options if you do
find you know one jar file that has
maybe one package that is referencing
compact two or three and you want to try
to home into the actual class reference
you can you can specify a little bit
more another option the verbose level
which I'll cut and paste here and it
gets done to the class level and tells
you which class so in an org free chart
color class it has a reference to
java.awt color if you do Jade app stash
H it'll it'll tell you all the options
but it's dashed for both level class can
blame Allen Bateman and his team with
coming up with these cryptic options so
if you do Jade eps without any arguments
or jjh you can see the verbose level you
can either do package level or class
level and the package level is the
default which is what job jdubs dash p
provides
so also the next sex enhancement as you
can see adding this feature to jdk 8
touches all kinds of things so tools and
new tools and the existing tools the
javadocs that we provide on the web of
profile information in them as well you
can go right now on on the on the web
and download the jdk 8 Java Docs and you
can see that if you click on the
packages on the left for all profiles
and you can click on compact to you can
see it for this this list here these
other packages that are available in
compact too if you click on a particular
class it'll tell you which compaq
profile those classes can be used with
says it's real nice we have full
complete support for it so what are we
doing with these compact profiles so JDK
repositories we we build standard java
SE 8 distributions without profiles
available on the web will be as i
mentioned earlier reference
implementations for linux x86 but we're
also implementing our java SE 8 embedded
fineries exclusively using profiles and
in the future the profiles will be used
for the ADF mobile product and I'll talk
a little bit more about that in upcoming
slides so what's the difference between
the reference implementation that will
be there in our embedded profiles well
the IMP the reference implementation is
is a basic compact profiles only we do
the build all the binaries are there
there are no embedded specific features
and we only target linux x86 it's there
is a reference so that people can
validate any alternate implementations
against it yes
we don't we don't currently have any
plans for windows and mac in kind of the
futures I had a list of what we could
use some help on from the OpenJDK
community the profile support is there
you can see how we've implemented it and
we'd love someone to help us with the
mac and Windows support you know we we
made in future releases do that but we
currently don't have any plans where yep
and we're hoping we're going to get some
help in doing those it's primarily
identifying the specific native
libraries that need to be there and
dependencies and it's just adding
support for those platforms we're I'm
kind of jumping ahead but we I expect
the compact profiles to be really useful
in App Store deployments for mac and
windows and and we'd love someone to
help us to do the compact profile
support there so that we can add
NetBeans support and and be able to
package up a nice smaller download so
that's definitely one of the things I'd
like to see happen but from the embedded
point of view we're primarily interested
in Linux arm x86 and Power PC and that's
what we're focusing at the moment so if
switching to embedded are our commercial
product in addition to the compaq
profiles we have done some size
reductions to provide a smaller minimal
vm so we're not carrying around a six to
nine megabytes server or client vm we've
added a tool called jerry create that
lets you pick and choose various options
so that you can pick the smallest
possible binary that satisfies your
applications needs you can do additional
reductions beyond what the reference
implementation offers I mentioned
already the minimum vm we have a three
megabyte vm on arm some of the arm
platforms it's even less than three it's
like 2.7 or two point five megabytes
depending upon architecture and we
support for embedded the three different
arm architectures to power pcs and an
x86 so the in terms of how you will what
you will see when you download the java
SE eight bundles for a
specific architecture you'll see one
file ejd k which is the e is you know
stands for kind of the embedded of java
development kit it contains all the
profiles in this one bundle and the
jerry create tool that allows you to
customize it pulls some of the binaries
depending upon which profile you select
which vm and other options that i'll get
into and generates a java runtime the
compact profiles will just be a single
binary you download like you do a normal
JRE unzip it and use it so here's an e
JDK expanded we it'll contain a bin
directory with which has our Jerry
create script the actual implementation
of this JRE generation tool is it a jar
file that can it's in the lib directory
the arc will be an architecture specific
sub tree this is so that we could
package you need JDK for all embedded
all supported embedded architectures and
let the tool pick the architecture but
we decided currently to ship them as
individuals to save download time inside
of the each architecture directory will
be the three different compact profiles
and the full jerry and some extensions
these are optional components that are
not part of the JRE that we want to ship
to add value to the embedded product
well as i mentioned we're only packaging
the arm hard flow binaries in one a jdk
file so when we have the eight and
vetted 8 downloads available you'll
download that one architecture so we're
not bundling all three arms and two
power pcs and x86 into one binary we we
could do that the support is there
that's why we we put this down one level
rather than putting compact one two or
three right under a jdk 180 it's just a
packaging decision so the process do you
actually use an embedded binary is to
download this e jdk run this tool jerry
create to build your custom embedded
jerry move that jerry to your target
device and then use it to run your
application
here are some of the options for this
tool that we're offering you obviously
have to specify where you want to put
the Java Runtime that we're going to
create for you whether whether you need
debugging support this is JB MTI level
support you need to this is an optional
if you're not in the EJ DQ directory
itself you have to specify where it is
so that we can find our binaries there's
an option to keep debugging information
by default we stripped all of the
symbols and debugging information out of
all of the jar files in the JRE if
you're using JVM TI and attaching and
debugging remotely you might want to see
a better call stack trace so we give you
the option of leaving all the symbolic
information in the generated by Nuri's
it will obviously generate larger
binaries and you might want to use that
during debugging but then turn it off
when you deploy your application the
dash p option the dry run is basically
go try it but don't do anything the dash
p option specifies which profile you
want to use the dash vm lets you specify
the virtual machine some of our binaries
have both client and server and a
minimal vm this small three megabyte vm
so you can select which one or all of
them if you want them to be generated
into your runtime for example the arm V
67 hard float has both client server and
the minimal vm in in the e jdk download
you don't want to include all three of
them because you're going to add you
know 20 megabytes your binary kind of
defeats the purpose the minimal VMO is
you know two to three megabytes and the
client and server like six and nine so
it's it gets pretty big if you include
them all but we allow you to do that if
space isn't an option isn't a problem
and in terms of extensions there are
some optional components in the jdk and
there are some additional features that
we're providing for embedded the
additional features are an embedded
specific FX stack that i'm going to
demonstrate today the there's a there
are a couple of different security
providers the elliptic cryptography and
the pkc s11 they're all of the
International is a
files can be rather large and if you
don't care about strings or displaying
anything to the user you may not want to
use those character converters and the
national and JavaScript engine if you
want to run JavaScript support within
one of the profiles let me just give you
a quick example of running the GRE great
tool I'll go to an e jdk forearm as you
can see this there's a linux hopefully
this is large enough for everybody i'll
try to get it as big as possible as you
can see here is the architecture
directory this says that you know the
operating system is linux the ARM
architecture we have floating point
support and it's hard float support we
as i mentioned we have arm v5 which is
soft float that means are we don't use
any floating point instructions at all
it's all simulated emulated we have a
vfp soft float architecture which is we
use VIP within the virtual machine
itself but when we call out to the any
native code we use the soft float ABI
which means floating-point arguments are
passed on the stack we don't pass them
in registers that's the biggest
difference between soft float vfp and
hard float hard phone gives you better
performance when you when you have a
floating point intensive application
where your want to pass arguments back
and forth you don't have to roll them
out to memory and read them back from
the stack this is probably the the most
popular and newest kind of flavor of
distribution for linux that's available
on arm and expect this to be become the
standard especially for you know arm
server architectures there they've been
dying for our jdk 7 we just rolled out
that has hard float support so i move
into the bin directory and I've got
myself a little text file so I have to
type all this I've got a few commands
that I can run the JRE create script is
up there we also support Jerry create
this tool in the e jdk i should point
out can we run on any machine on a
windows box mac a linux box it's a job
program so if you have a Java Runtime
jdk 7 or higher you can run this Jerry
create and generate an armed binary set
on a Mac which is what I'm going to
demonstrate here let me first cleanup in
case I have some old junk and the first
example is I'm going to create a compact
one profile and I'm doing the dash K
which is the option to don't compress my
binaries because this will run really
fast the compression takes like 10 or 15
seconds so I'm going to do a quick run
just to show you the size of a compact
one profile without compression oops I
forgot to cut so you run ji recreate
dash K specify the destination and what
profile I want boom and it's done so we
have 11.5 megs of binaries that are
created as you can see it tells you what
options are selected by default it shows
you the defaults because I didn't
specify the vm but it picks the minimal
if you want profile one they figure if
you're picking profile one size is
really important so let's pick the
smallest vm you know you don't get
debugging does that cost space too if
you do need debugging you can't use the
minimal vm because guess what the
debugging support is not in the middle
vm that's one of the things that save
space so you'll be bumped up to the
client vm automatically if you want to
do debugging where we're keeping debug
information so that dash k didn't strip
any symbols out of that binary I'm and
we didn't do compression and we didn't
ever boast and we don't have any
extension so that was eleven eleven
point five so if I turn off the
compression and I generate that to a
different directory the command will
fail if your directory already exists so
as you see this will take a little bit
longer because we open up each jar file
in the JRE read through them and we're
using the pack 200 implementation in the
jdk to compress and get the maximum
compression out of it in addition to
stripping symbolic information so as you
can see a compaq one
while forearm hard float is even less
than 11 megabytes so we say like a
megabyte by just stripping all those
that symbolic information if you want to
go down and look at the generated gres
jerry compact one with the k option and
the one without if i can go to jerry
create compact one and if i look in the
release file as you can see it generated
a compact one we also provide a bill of
material smile a bomb and that shows all
the options that were selected during
the generation so that I des like
NetBeans can decide and and not let you
do certain things because you don't have
debugging support it it also lists every
file that we copied from the from the e
jdk into this directory so you can you
know exactly what you what you've got so
that's the jerry create tool and i
showed you these options so in terms of
what platforms we support i mentioned
linux x86 the three different linux arm
platforms and there are two different
power architectures the primary
difference between the e 500 and the and
the traditional power pc is the floating
point instructions are different so some
of the optional things that we can
provide on top of the embedded download
we have an FX embedded stack which is a
subset of the full desktop it's a
compatible subset that runs on top of
compact one and i'm going to actually
demonstrate that today we also provide
local as i mentioned that dash x or dash
extension option you can select
different localization features security
providers whether you doing debugging
and the Nashorn javascript engine so
even FX has has profiles they're called
components but they're really just
different subsets of api's that are
available in the FX it's available on a
desktop and this table shows you which
features are available on embedded and
and not not currently unavailable on the
desktop so the
the primary features are you know the FX
for embedded it's much smaller we
provide GPU accelerated graphics so we
can take advantage of the Raspberry Pi
GPU to get better performance than the
CPU could offer and it's a common
graphics architecture that we're going
to provide on all across all embedded
and desktop applications it may wonder
what what are the sizes of the of the
various compact profiles if we just take
a look at the hard float across the
center as you saw we had like ten point
five megabytes for the minimal vm adding
going up 15 for compact 224 compact 348
for the full JRE on the right gives you
an idea of what the FX is graphic sizes
are the two profiles that they have
available or components are the base
graphics component which is AD 7.8 Meg's
to a runtime the FX controls if you want
to add buttons and and and other
controls on top of the base graphics
adds two more rigs 2.2 Meg's so that
brings the total on arm to 18 megabytes
you know we have a full graphic stack
available and if you want controls it
brings it up to 20 megabytes that's a
considerable size savings over the
desktop API set here's a comparison of
you know the traditional swing ewt size
and you know how much smaller can we get
by using an FX embedded stack the swing
awt is 52 megabytes of classes and VMS
and native tool kits and libraries as
opposed to our 18 megabytes for an FX
app in addition with X Windows you need
desktop window managers and session
managers and the x server that take
additional memory and buffering so it
gets pretty expensive if we wanted to
use a WT and swing for an embedded
application for embedded our reference
Pratt forms are currently the
beagleboard XM we've where we have
raspberry pi support on our jdk forearm
it's available on the web now we are
looking at implementing free skip
support for free scale IMX boards
and and the Panda board as well and you
know expect this list to grow over the
next year David Hill gave a talk
yesterday on how to port to different
architectures the sources for all of the
FX support is in open JFX so we expect
the community to help us to broaden the
support for the embedded devices and
even for other desktop alternatives so
let's talk about use cases for embedded
so here's just a few different use cases
that we we've either had you know
customer interest in or have been in use
for earlier versions of java SE embedded
and a root that are interested in saving
space using the compact profiles you
know first things like a kiosk for
example where compact one profile
without any controls if you have a kiosk
it's just interested in flashing images
across the screen this is a great use of
the compact one profile a home gateway
with a compact to profile we expect our
java embedded sweet set of application
support for middleware to be able to run
like a home security lighting control or
air conditioning application for home
users a man for an electric electronic
toll booth for instance a compact to
profile because it has JDBC support you
may want to detect vehicles coming
through a tollbooth recording that
information looking up whether they paid
their you know their fee for this month
and sending violations you know to a
back-end server so there are kind of
three different uses but you know the
use cases are unlimited another use case
is we have oracle has an ADF mobile
product which allows developers to
create mobile applications for both iOS
and Android we're currently using
they're currently using the CDC
implementation that's one for two for
this for this product the way the idea
mobile product is is designed they use
html5 and JavaScript for all the native
services and UI components but they're
using Java within that application for
all the back end web services
and local persistence on the device and
we've implemented a an API work on the
vm channel that allows them to
communicate within the same process
between the two worlds the iOS world and
the Java world we are planning on
upgrading that ADF mobile team with a SE
mobile compact to profile they require
JDBC so they can't use compact one so
they'll be using compact to profile with
our minimal vm and the vm channel
support and whatever you know as SE
mobile components are required to
support those profiles so expect that to
be available you know with ADF mobile
sometime within the next year so here's
going back to one of the earlier
questions we currently don't have any
support for Windows or Mac but another
use case is for App Store deployment
where download time and the size of the
binary is critical and we would require
the enhancement of the compact profile
support in jdk 8 it would not require
aspect change or anything so this
definitely can be done even after JD ke
to shipped we can enhance it in an adopt
release we couldn't you know possibly
support windows and mac and windows 8 in
the future we don't currently have any
plans to do that but you know we'd love
to have some help so this could enable
an app store deployment for apple and
windows 8 and obviously you know taking
se8 and going to mobile devices for
headless support for you know gateways
and other things are a potential future
use case ADF mobile is our you know
first and premier entrance into that
mobile device with a jdk a java SE 8
implementation so let's let's do a
little bit of demoing good enough time
which is great so i'd like to show you i
mentioned earlier that NetBeans has
profile support and i want to show you
some NetBeans support integrating the
compact profiles and the raspberry pi
and how easy it is to use profiles on
one of these devices
so let me just fire up netbeans here
this is an early version of NetBeans 74
I've been working with the knit beads
team and they provided this demo version
for me just before javaone so bear with
me if we have some bugs so the first
thing let me just show you so get i have
a small little program get system
properties and first show you one of the
the additions to the property screen for
that particular project if i go to the
sources category within the property
screen you can see on the bottom I've
told it that I want to build a jdk 8
application and I want to use compact
one profile so i can even without
talking about remote devices and
raspberry PI's I'll run this little
application and all it does is pull out
some of the system properties and prints
them on the screen so you can see on the
bottom that we have a 64-bit java
runtime it's little endian x86 Mac OS X
so that's the machine I'm running on I
can now switch to a remote Raspberry Pi
and i'll show you how to configure all
this and hopefully this will work and do
the same thing it rebuilds the this
application pushes the binary to my
raspberry pi asked me for my login
password and runs this application and
prints the results so a lot has happened
here i've compiled locally using java
compiler to targeted a compact profile
I've pushed the application remotely to
a Raspberry Pi and as you can see it's a
32-bit new hard float EAP ABI little
Indian Armed linux box and the user's
home directory is home pie so right from
netbeans i can build an application on
on my mac develop it using compact
profiles and push it so let's get into
more details about how all this magic
happens so if i go to java platforms now
the NetBeans team has added this new
remote capability this screen used to be
used just to pick I want a Java 7 or a
Java 8 java runtime that I want to use
our jdk now i can select a new remote
target platform so i can specify remote
java standard edition and new platform
yes this is this is basically a GUI
version it's i'm going to show you JRE
create where it can actually build you
the runtime push it to the raspberry pi
just from this one screen that i'm going
in so it's let's do Bob's pie as my
platform the host is the only thing you
need to know is the IP address and a
login and there's nothing else on the
Raspberry Pi it'll push the runtime the
application and get it going all without
having to go SSH into it yourself it's
really nice well integrated 192 168 1
110 and my username is pi my password is
pi and so now i click on this create
button and these options should be
fairly familiar since you just looked at
my Jerry creates lies do we want
debugging let's not do debugging and
let's not compress because that takes
too long and let's do a compaq one and I
want to be able to run FX and FX
controls on it and I do create I hope
that that path doesn't exist and it's
going to complain probably should have
given it a unique path so it runs Jerry
create behind the scenes and you can
actually see if I go back to the command
window netbeans is printing the output
of that red command
and now it's updating the new created
JRE and it's done so my remote path is
home pi JRE and I now do finish and now
you can see Bob's pie is now an
available remote platform that I can now
run applications on so if I go back to
my get system properties program we just
show you the sources and everything it's
not much to it and all it does you know
a bunch of system dot out dot print
lines and I can go up to this window
here whoops actually I've got to go to
properties until it I want to run this
application on Bob's pie you can specify
in the run option you know of any vm
options or a different working directory
what your main classes but now I just
click play ask me for my password so now
let's push that home pi JRE it's pushed
this application to the NetBeans project
on the pie in-home pie and as you can
see it ran and we have the output and
I've done the same thing with an FX
application where this FX application
has a bunch of options and it specified
the raspberry pi but let's first show
you what this what this thing looks like
so here's an FX application that runs
with the FX extensions on the compact
one profile using the experimental 3d
api's and and I could spin it around
grabbing the mouse
and go over here and kill it so here's
some eye candy for everybody we kill
that so let's let's go to the raspberry
pi just select I want to run that on the
Raspberry Pi and switch screens let's
just make sure that it connects and runs
everything so it updates the the
NetBeans project using the remote
Raspberry Pi option that I selected and
I switch to hdmi hopefully the screen
doesn't sleep there it is so this is the
same exact FX application that I just
showed you on my Mac using the max
desktop FX but it's running on the FX
base graphics component without the
controls in that 18 megabytes of space
on a compact one profile using 3d FX
api's yes yeah this is all using the GPU
to do all this drawing so that shows you
that you can develop really quickly and
easily on any kind of desktop device and
deploy real easy using NetBeans IDE so
it's we have support from all of the
language tools in jdk 8 and ID tools to
have like seamless easy developer
experience to build embedded apps
so that's basically the end of my
presentation and I'll open up for
questions so everybody's good yeah you
know one of the features that the
NetBeans team is still working on today
if I built that remote JRE and ice click
debugging it will push the JVM TI
support to the remote device and i can
just simply go into netbeans and you
know could toggle the debugging support
on and off I don't recall how I
generated the GRE for the cube I don't
think I added debugging support so the
the one thing that being seen is doing
now is to validate against that bomb to
make sure that debugging support is
there in order to enable debugging
locally on the on the IDE but that will
be that will be completed by the time we
get there
is this like the distal next version
it's not released yet but what companies
like in some cases like that kiosk apps
well j decade is jdk isn't available in
shipping we have an early access program
where we have a how many 20 some-odd
customers that are internally evaluating
it for various use cases in a home
gateway printers and and another devices
but it you know JD Kate will be
available when Jada kate is available
the SE embedded support will be there
everything I mentioned I don't know off
the top of my head the exact net being
scheduled they're not in our
organization so but oh okay is this
support is this in the downloadable bits
now this has been integral great
all right look to no more questions
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>