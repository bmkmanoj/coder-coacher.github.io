<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CON8366   Programming with Lambdas | Coder Coacher - Coaching Coders</title><meta content="CON8366   Programming with Lambdas - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CON8366   Programming with Lambdas</b></h2><h5 class="post__date">2015-12-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/cgW5jElIJRc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright let's get started welcome to the
session on programming with lambdas my
name is Venkat Subramanyam we're going
to talk about what lambdas can do for
you what we can use it for so let's get
started this is one of the best things
that's happened in July in a very long
time if you really look back in time
with Java there's not been such a great
improvement in the language level for a
very long time java 5 had some
questionable features java 6 really then
didn't have any java 7 had a few
features but java 8 is really a game
changer so one of the most interesting
things about Java 8 is lambda
expressions so the first question of
course is what in the world is lambda
expressions well lamb expressions are
anonymous functions they actually are
cute little anonymous functions and they
really make our lives a lot easier by
reducing a lot of ceremony that we have
normally in code and as a result becomes
a lot easier to work with them so this
leads to a different style of
programming than we are used to most of
us are used to an imperative style of
programming but now we can start using
more of a functional style of
programming with java thanks to lambda
expressions so to understand this let's
take a look at a series of examples and
see how this changes the way we do
things so I'm going to start with the
little example the one that we are all
extremely familiar with one we have done
a million times over and then we're
going to redo this as several times
maybe about six or seven times I'm going
to refactor this code and we're going to
see how this is actually going to work
out as you can see i'm not using any
slides here i'm going to just talk about
stuff and code if you are interested in
downloading the code examples you're
most welcome to download them from the
URL up here on the line number five but
you don't have to rush it to write it
down i'll also lose this towards the end
as well so you can note it down if
you're interested later on so let's
start with a little example how does it
feel to work with lambda expressions but
I'm going to first start with something
we're extremely familiar with and then
we'll move forward from there so what
I'm going to do here is start with just
a little example of let's say this stuff
a few numbers so I've got a few numbers
on my hand and I want to iterate loop
through and print these values out so
how would i go about printing them well
this is something we are also used to we
have done a million times over so I'm
going to say int i equal to 0 I less
than numbers start hmm is it
sighs count length is at length are you
sure its length well sighs okay sighs oh
wait is it less than or less than or
equal to is less than other days you
don't think about it is called the I
fell off by one error day right so we
have to go through all of that and then
of course what do we do we say numbers
start get and then of course I and of
course we have the result now people
will tell you this is a simple for loop
but I got the word really mixed up
that's not the word simple that's a word
familiar and there's a very big
difference between the word familiar and
the word simple for example my in Las
very familiar but I would never use the
word you know simple with them so the
point really is that we are confused
between familiar and simple but there's
a very big difference between the two
familiar is something we have looked at
a lot but doesn't mean it's actually
easy to use at all so this is an example
of a familiar code but if you're into
design patterns there's a really good
name for this particular pattern it's
called a self-inflicted wound pattern
because we have done this over over and
we've been hurt by this so many
different times well it works but this
is called an external iterator let's do
this one more time we can simplify this
quite a bit i'm going to say int element
coming from numbers and of course i'm
going to just output the number a lot
easier when we can clearly say this
version is simpler than the previous
version we just saw a minute ago and of
course it removes quite a bit of
ceremony but both of these put together
are called external iterators so what is
an external iterator an external
iterator is like having a rude dog you
say move and it doesn't move you got to
push it every step of the way well in
this case of course rather than using an
external iterator for a change we can
switch over to water call internal
iterators moving forward in java so how
does an internal iterator work it's kind
of like throwing a frisbee and the dog
goes to get it you don't have to do
extra work to really iterate you simply
put the iteration on autopilot it
becomes a lot easier to work with so
let's take a look at an example of how
we could use an internal iterator in
this particular case so the internal it
later in this case internal iterator
simply says in these numbers I'm going
to call a method on this call for each
method so look at the first difference
already rather than passing the numbers
to a for statement over here we are
instead calling a method on an object
well we know what happens when we minute
the minute we call methods on objects we
immediately can start enjoying
polymorphism and polymorphism is the
real core behind a lot of extensibility
and flexibility that we often get so
this has a really good power behind it
already when something is polymorphic
there are certain things we get almost
for free we don't have to worry about
how its implemented we rely upon what we
want and the implementation kind of
falls in place one more thing of course
is if you look at the for loop that's up
here what does it give it gives exactly
what we asked for a sequential iteration
but looking at this for loop though we
don't quite know what kind of iteration
we perform this could be sequential this
could be lazy this could be concurrent
payroll what have you so there's a lot
of flexibility we can get out of it but
of course we want to implement this
internal iterator how do we go about
providing this internal iterator let's
give it a try so for that I'm going to
bring in the first package we're going
to use here a function package that's
the part of Java 8 and the function
package contains a few interesting
functions that we can actually use and
these are called the functional
interfaces so I'm going to say a new
consumer integer right here and then of
course with tildes I'm gonna provide a
method a public let's say in this case
void and i'm going to say except an
integer value and then i'm going to
output the value that we got on hand so
if you notice in this case that produces
the same result as well but this is an
internal iterator compared to the
external iterator we just saw a minute
ago well the good news about this is we
are not focusing on the iteration itself
we simply said what we want per
iteration and it takes care of the rest
for us without having to we having to
put in the effort to manage the looping
itself
know what you're thinking you're
thinking this could be the best thing
ever but if that means I have to write
yet another anonymous inner class heck
no is there anybody here who wakes up in
the morning and says yes I'm going to go
to work today and write anonymous inner
class yet again right okay there's
always these two people will talk about
this afterwards right so the rest of us
of course absolutely not in fact he
would call the boss and say I feel real
sick today and cancel their day right so
that's how it feels about it so what can
we do in this case well if you look at
this court though this is a really good
example of the ceremony that we have
gone through four years and ears about
close to 20 years of programming in Java
and ceremony really damn sus as my good
friend Stuart Holloway Road in this blog
it really becomes extremely hard to work
with ceremony is there anybody here who
really enjoys ceremony I don't think so
right because ceremony is really what
you have to do before you get to do what
you really want to do and then all the
excitement is gone life kind of said get
sucked out when you have to do ceremony
well if you look at this code what's the
most important part of this particular
code there are only two important parts
right here the first one of course is
the parameter that you're passing to
this function clearly you want to know
what you're going to work on and the
second thing in this function is the
body of the function itself other things
in this code are pure ceremony in fact
I'm going to highlight the ceremony
right here and I'm going to delete the
ceremony right there and I'm going to
just replace this with a little arrow
and then remove the rest of the ceremony
from code and we can see the code is
still working so we took the lambda
anonymous inner class and changed it to
a lambda expression right off the bat
and you can see that the lambda
expression has two parts to it the first
part of a lambda expression is the
parameter list to the left of the arrow
and the body of the function is to the
right of the arrow so there is the cute
little anonymous function we are looking
at so we can see that this particular
function does exactly what we wanted but
with a lot less code as well so we could
start right here and celebrate lambda
expressions but thankfully there's a
little bit more we can do with this if
you look at this code for a minute there
is the iteration that's happening which
is really nice but of course there is
something else we did which is a
tradition in Java notice we said the
integer value now take a wildest guess
for a minute if you are iterating over a
collection of integers and if you were
to pull an element out of it what in the
world do you think value would be a dog
real surely not it's going to be an
integer so we clearly know what it's
going to be well you know this and I
know this so why bother seeing this over
and over so for the first time in a long
time Java is finally intelligent so you
don't have to specify what the type is
you can let go of that and you can see
the type inference kicks in and you
don't have to say that type so lambda
expressions also have type inference
with them so very generously you can
leave out the type information quite
easily so that removes the ceremony
quite a bit of course but then comes a
little bit more ceremony why have this
parenthesis after all we can get rid of
it so we can see that we got rid of the
parenthesis in this particular code and
you can see that's really becoming
smaller as well as we speak so for a
single parameter argument you can let go
of the parentheses as well so that
reduces quite a bit of ceremony well
this is pretty much we can stop at
lambda expressions but it is just one
more thing we can actually do if you
look at this particular lambda
expression for a minute we're receiving
a value and we are simply passing the
value to the print line function now
clearly you could have done something
more intelligent with the value for
example you could have added a 12 it or
you could have doubled the value and
printed it whatever it is but the point
is we dint and so all we did here is
it's a garbage in garbage out we simply
receive the value and we passed it down
so if you notice the 15th time you write
this lambda you're going to get pretty
angry about it because it's a lot of
noise to do almost nothing other than
passing it through so as a result this
is going to become really boring after a
while and this becomes really stupid but
one
we have learned over the past several
years is java programmers never write
stupid code instead they invent IDEs to
vomit stupid code so the next thing you
know is people are going to be tweeting
each other hey what's that idea shortcut
you're using to do the stupid code and
they knew this was coming so they
decided to eliminate this kind of
redundancy in passing the parameters and
as a result they said if you're
receiving the value and simply passing
it down you can then remove that value
from the redundancy and you can replace
this with a double colon and that
becomes what's called a method reference
in this particular case and so in this
example we use a method reference rather
than going around and using the lambda
expression itself so we refactored this
code about seven different times as you
can see we started with the most painful
and familiar for loop to begin with we
refactored it to the traditional for
each those two of course our external
iterators and then we said we can trade
this to an internal iterator though that
really really smelled a lot but it gave
us the benefit of the internal iterators
then we got rid of the anonymous inner
classes refactored that into lambda
expressions then we got rid of the type
information and use type inference and
then of course we got rid of the
parenthesis and made that a little bit
more concise and then for simple cases
where it's a simple pass through we
decided to use a method reference rather
than using a lambda expression itself so
as you can see we go from a very Bose
coat to something extremely concise this
can be a very powerful in writing code
because we don't have to n do it a lot
of ceremony in code it gets to the point
where the code becomes very easy to read
very expressive we're going to see a few
more examples of this along the way as
we go through and look at examples so
we'll continue further and take a look
at it as we go through a few more
examples so we saw the benefit of this
but one of the most important things
here is we go from a imperative style of
programming to more of a decorative and
functional style of programming so
what's the biggest difference well the
difference is well let's take a look at
an example to understand what the
difference is let's change the problem
just a little bit
suppose we are given this collection we
are told a total d let's say double of
the values in this collection so that's
basically the problem given to us total
the double of the values in this
collection how would we do this well
first of all we'll start with result
equal to zero and that's our tradition
right we define where we want to store
the result and we will display the
result when we are done and then what do
we normally do we can say for int
element coming from numbers and then
what would we do we would say well the
result is going to be plus equal to e
times two because we want to double the
values and then total them as well well
that is a code that we are all used to I
would assume anybody of a certain code
like this before sure every one of us
right absolutely but the more important
question is how do you feel writing that
code really dirty right in fact you go
home after a very long day children
coming running run to work children come
running towards you you say don't touch
me I got to go take a shower first right
it feels like that actually it's even
worse than that anybody who works from
home here a few of us be very careful
never leave this code on your screen and
walk away because of the children come
and look at this they camp you and say
that's what you do for a living right
and so it gets extremely really hard for
you to convince them to take on to our
field well this is a lot of ceremony
this is called primitive obsession a lot
of code we have to write to get simple
things done but this is a sign of what
is called an imperative style of coding
so this is called imperative style well
what in the world is imperative style
there are two symptoms or smells of
imperative style the first is you say in
this case you say how over and over so
that is the very first sign of
imperative style of coding the second
thing is a mute ability and let's take a
look at both of those for a minute in
terms of how that fields in this but
I'll write a function on decorative
style before I come back to that so
let's write a declarative and functional
style and I will mention the difference
between these two in just a minute so
what I'm going to do now is I'm going to
say out port and
numbers dart stream think of a stream as
a fancy iterator if you will and then
once we get to this iterator i'm going
to say i want to perform a map to end
and give an element i want to perform
the element x 2 and then i want to
perform as some operation on the result
of this particular collection or the
logical collection and return you can
see that it produce the same result as
the other piece of code however take a
look at this code for a minute now if
you look at the top code for a second we
had to write quite a few things to get
the same exact result on the other hand
if you look at the bottom code we said
given the collection of numbers double
the values and total notice how it reads
exactly like what you really want to do
so the very first sign of declarative
style of code is you mostly tell what
and not how and the second thing is no
explicit mutability now let's take a
look at these do for a minute if let's
talk about mutability for a second if
you notice this particular code notice
on line number 11 we repeatedly modified
the result over and over and over if i
turn up the volume of the computer and
run this program you will hear the
variable results say out out out on this
line of code you are constantly mutating
it and that's one sign of imperative
style echoed you do mutation over and
over if you look at this code in the
bottom there's a bit of a good news no
variable was tortured in the making of
this result it's a very humane code as
you can see so we avoid mutability and
what happens when you avoid mutability
the code becomes easier to explain the
code becomes easier to understand we
have fewer errors in the code and it's
also easier to paralyze a code which
doesn't have shared mutability in it as
well so overall this has a lot of things
going for it the second difference is in
the declarative style of code you say
what you want to do rather than saying
how to do it if you look at this code in
the top let's read through this in
English and see what we are doing first
set a variable called result initialized
to 0 please take a value e which is the
first element
numbers go ahead and get that value
double it and then of course add it to
the result value put it back into the
result now get me the second you can
that's very tiring isn't it so in other
words imperative code is like talking to
a toddler now the first day you talk to
a toddler is very cute you are like wow
this was awesome I spoke to the starter
how cute and the next day you meet the
toddler you realize you have to say the
same thing again don't walk slowly
please look where you're going don't
step on the cat still please hold it
with both your hands and then you
realize the third do you have to say the
same thing to toddler and you realize
this is going to continue for the next
18 years and that's the way it feels
right so imperative code is like you
know working with the toddler it becomes
tiring after a while because you go to
do this over and over and over well a
functional style is like talking to an
our dog well actually let me rephrase
that knowing some adults I know it's
like talking to a responsible adult so
it becomes a lot more easier to express
the code as you can see so this is an
example of how the code is very
expressive and that is one of the
symptoms of a declarative style of
programming now of course we keep using
the word decorative and declared is
where you say what and not have and you
don't have explicit mutability but then
what in the world is functional style of
programming well functional style is
also declarative but there is a little
bit more with functional style in
functional style in addition to being
decorated you also use what are called
higher-order functions so a normal
function is a function that receives
objects as parameters on the other hand
a higher-order function can receive
other functions as parameters as well
this is a good example where we actually
see both of those types of coding look
at line number 24 for a minute we are
calling a function called some I would
argue this is a declaration because you
say what to do which is to some and not
how to do it so it is decorative but
notice you're not passing any objects to
this function so as a result that is
really no concept of
higher-order function in this case
you're not passing the function to this
function so this is not really anything
to with functional style of programming
this is simply decorative as you can see
on the other hand if you look at the map
to int function this is more this is
both declarative and functional at
exactly the same time if you notice the
first here you are declared because you
said what you want to do which is to
double all the values in this collection
but on the other hand notice you're
passing a function to this function and
this is actually a functional style in
other words map to int is a higher-order
function in this particular case so that
gives you an idea about the difference
between the two styles of programming
while both give you exactly the same
result one is much more concise and more
expressive than the other one doesn't
have explicit mutability as well so we
saw some of those benefits on our hand
so this gives us an ability to move
forward with the next power here on our
hand which is called composing functions
so in other words think about a question
please go ahead so the question was how
do we debunk I don't quite spend my time
putting bubs in current code I don't
know the answer for it well so a better
question to ask really is why do we
think debugging would be really hard so
let me postpone that question for you
and the reason for that is you can put a
breakpoint and you can step through the
code like you do always that's not a
problem at all and ID's will i love you
to put a breakpoint and step through so
that's not a big deal but there's
something else that's going to make
debugging a little bit of a challenge
but we haven't covered that yet so
lambdas are little intimidating that's
the question one of the reasons is we
are looking at something that's not very
familiar to us and this is a human
nature every one of us goes through this
when you look at something that we are
not familiar with we don't like it as
much and that's very natural and we got
to just get over that kind of you know
fear that we normally have but there are
really good reasons why we should be
concerned about but we haven't gotten to
that yet so stay with me and I'll talk
about that in just a few minutes after
the next topic so given this we want to
talk about composition which is a really
powerful concept here
and I want you to think of the word
pipelining so pipelining is a really
good way to think about this you take a
collection of values and you pipeline
them applying one transformation after
another after another and you keep going
through these transformations through
your code that becomes a lot more easier
and effective to work with it so to
understand this I'm going to take this
collection but I'm going to make a
slight change to this collection I'm
going to say this is going to be a
collection of one two three five and
then four six seven eight nine and ten
so now i'm going to change the problem
on hand i'm going to say given the
collection we have find the first find
the double of the first even number a
greater let's say greater than three so
i want to implement this code in the
imperative style first and then i'm
going to implement this in the
decorative style and see how it goes so
I'm going to say result is equal to zero
output the result the traditional
imperative style and what are we going
to do I'm going to say far int element
coming from numbers and then i'm going
to say here if element is greater than
three and element mod 2 is equal to 0
then i'm going to say result is equal to
element x 2 and i'm going to print the
result out is this correct I hear know
what's missing a break ok I put up awake
is it correct now so so it doesn't
matter given list we don't care about
the sorting at this point it's a given
list as it is so so so that is a correct
notice you went from it's not correct to
I'm not sure anymore that's a sign of
imperative code because imperative court
gets you worried very quickly right and
imperative code so if you look at
imperative code there is usually a sign
of imperative code in fact it's really
wonderful if you can do this give an
imperative code to somebody but sit in
front of them and watch their eyeball
the eyeball does this it goes like this
for a while and then comes to this point
and that point where it shakes is called
the point of confusion right and then
usually you have this like okay we see
this
that's what you go through you're trying
to analyze this cord over and over and
that can be very frustrating in fact if
I run this code notice it gives us the
right result which is eight but
typically here is what happens a few
weeks goes by and you know who walks in
the person called the tester and usually
my tester will walk in announcing hey
Venkat your code sucks and I usually
tell my tester don't tell me the obvious
what I want you to tell me is how does
it suck today because it seems to suck
different every single day so the point
really is this code sucks we don't how
it sucks we'll figure out in a minute
well let's try this again let's say
we're going to write this code this time
though we going to say numbers dart
stream one more time so we brought in
the stream but what am I going to do
this time I'm going to call a function
called a filter and we saw a map earlier
map data transformation but a filter
cherry-picks values for you and drops
off values that don't meet the criteria
so in this case given an element give me
elements greater than three and i'm
going to say filter given an element
element mar 2 is equal to 0 even numbers
then perform the map function obvious
obviously we want a map in this case
given an element element x 2 but then
i'm going to say fine first and ask you
to give me the first element out of this
collection so you can see the beautiful
pipeline that happens right here and
notice the dots being aligned vertically
you take the collection first of all you
filter all the values greater than three
then all the even numbers double them
but only return the first value in the
collection if you run this code the code
not only gives you a result but it also
reveals the problem with the previous
code notice the previous code the
imperative code gave us a result of
eight and my tester didn't really like
it but why because notice the decorative
code now say is not eight but an
optional eight so what does that mean
the code gives me a clue that there are
times there may not be a result at all
how so what if the collection were empty
what if the collection had no number
greater than three what if the
collection had no even number at all for
all those cases the top result was zero
oh but the bottom one would be an
optional dot empty to tell me that I may
not have a result at all so you can see
how the code is more transparent but of
course the question is how in the world
do I get the real result out of this
function I do have to warn you this is
one of the most threatening functions in
the daily k it's called are elves and
then you can specify an alternate value
whatever you want to get and you can get
the value out of it so this gives you an
idea about how to use this code but this
is an example of a code which is again
declarative very highly expressive very
transparent as well and seems to do what
we exactly want it to do but of course
this brings up the question of one other
question we all are often concerned
about but what about performance are we
not going to lose performance in this
case in especially if you're going to be
doing this work over and over and over
well let's understand this for a minute
let's go back to the code in the top for
a minute and we will analyze the
behavior of this code before we go any
further well we know that Java has
wonderful shots of curing and we know
that given collection of numbers in the
sequence and remember lists are always
ordered collections so you have one two
three five or six seven eight nine and
ten so we come in here let's count I
have a value of e e is 1 1 greater than
3 no 2 greater than three no shots are
cute at three greater than three no five
greater than three yes he's five even
know is for greater than three yes for
even yes double the value for break out
so there was eight computations that we
performed in this code and so we can
definitely agree that the imperative
style so imperative or a does eight
units of work not all units the same but
that's roughly what we care about so
that's 8 units of work now clearly i'm
going to tell you this code is so cute
so beautiful so elegant but i want you
to pay five times more you're going to
say get out of here i wish you had told
me this when i came in here either
turned around right left right so
clearly we don't want to pay an extra
price but let's see hypothetically what
this maybe
we take a collection of 10 numbers we
are checking if any of the numbers are
greater than three oh boy thats ten
checks potentially 10 is already greater
than eight dead on arrival but to add
insult to injury let's go further this
would be checking if the numbers are
even that seven numbers checking even
seven plus 10 is 17 and then of course
we're going to double the values for
even numbers 17 plus 4 21 so I want you
to pay 21 units rather than eight units
anybody interested in doing that not at
all right so that wouldn't fly at all
but what is the consequence of using
this code well before I answer that code
let me just do a little bit of a
refactoring so I can get to that point
much more easily so boolean is greater
than 3 i'm going to say number in this
case of course i'm going to return
number is greater than 3 i'm going to
write this code just a couple of times
with different values east even and of
course i'm going to say mod 2 in this
case is equal to 0 and finally let's say
into double leg will call it as double
it and in this case I will say this is
going to return oh let's say x 2 well
I'm going to use these calls up here of
obviously so I'm going to change this to
sample is greater than three you see you
can we can use the method reference and
I'm going to change to sample ease even
and finally I'm going to change this one
to sample will call it double it well
now that we have called it all these
functions it's producing still the same
result however what about the
performance of this code when I forgot
to mention one thing though that the
streams actually share a characteristics
I've actually seen among my children
they both are lazy to the bone and so as
a result the stream is actually
extremely smart if you go to the stream
and say filter filter map it actually
doesn't do any of those things I'll
describe a scenario for this that will
actually make it really easy to
understand because I've actually seen
this happen my wonderful wife you know
Thaksin a teenager she says I want you
to turn off the TV
it's as if no words were spoken because
nothing really happened and then she
would say I want you to get up and clean
up your room and nothing happens I
wanted to finish your homework nothing
happens and then she will say I'm
calling daddy and immediately it's like
everything happens so the point really
is all these calls are kind of
accumulated lazily and that I'm calling
daddy triggers the execution well that's
exactly how Java 8 actually works so if
you go to Java 8 and say hey stream
filter it says yeah whatever filter map
nothing happens find first oh boy let me
get the work done so the point is there
are two types of methods in Java 8 these
are called intermediate functions and
the last one is called the terminal
function well there are two types of
functions just not the last one is a
terminal there are terminal functions
which you normally place at the last so
the point really is there are
intermediate functions that lazily
evaluate and then there are the terminal
functions that trigger the evaluation so
the point really in here is the lazy
evaluation so let's understand what that
really means well if this was done very
naively you would first take the
collection of numbers and create another
collection with only numbers greater
than three then you would create yet
another collection which is even then
you would create yet another collection
which is double and that would not be
very efficient at all so instead this
behaves very differently imagine for a
minute these are your two feet and
you're standing on top of that excuse me
you take the number one and you drop the
what number one and number one says I'm
sorry I'm not cut out for this and it
leaves exits right away so one is not
greater than three we then take two and
two exits so does three we send a value
of 55 clears the first filter but five
exits through the second door it says
I'm not even number then we take 44
clears the first filter for is after all
greater than 34 clears the second filter
for is an even number we double the
value for and then we pass it down to
find first and find forces
Thanks and the shutdown the shop and
goes home so the point really is we
never ever touch value 67 or anything
after we reach the result this is called
lazy evaluation so let's lay take a look
at an example to really see this is
actually happening so if I go up here
and say is greater than 3a plus number
and I'm going to really print that here
all so far is even and I'm going to do
the same thing here for double it as
well and now if you notice in this case
when I run this code you can see that it
is actually calling is greater than
three four one two three five and then
it calls is even for five then it calls
the functions for four and the minute it
hits the bottom for four it says I'm
done and it doesn't evaluate the values
for values later than six so in other
words it doesn't go through a list after
list after list the instant it takes a
one value runs through the functions
vertically and only if needed takes the
next value so the execution order is
very different in the computation it's
not what you look at that matters it's
what you see behind this code that the
execution really sequences such a very
different sequence of execution the word
lazy really means efficiency so when you
say the word lazy you have to pronounce
it a little differently in Java 8 you
pronounce it as efficient because at
what it really gives you an efficiency
in this code so this gives you an idea
about how this efficiency works so these
functions are evaluated as a combined
function this is called a fusion
operation so rather than seeing these as
three separate lines fuse them into one
line that one line a combined operation
is done for every element so it operates
on one first only then if needed on the
second and the third and the fourth and
keeps going lazily rather than having to
create a list after list after list and
that brings an efficiency quite a bit
but this brings up the question how does
this laziness actually pan out well
let's take a look at this one more time
and for understanding this I'm going to
go back
here to the end and I'm going to put the
word done here but I'm going to remove
the very last call from here I'm going
to remove the output from here for a
minute so notice in this case I have
done up to the find first and I'm
stopping at the end of the fine first as
you can see so in this example as you
can see we are using the terminal
operation at the very end of this code
so when I run this code you can see all
that output followed by the done as you
would expect however I'm going to stop
one step before the find the first and
what did I just do I did all the lazy
functions but I never call the terminal
function so what is the code do at this
point well you probably know how this
code works because you've seen some
people at worked like this they come to
work in the morning and they look around
and say hey where's the boss you say the
boss is sick today it's like yes I don't
have to do any work today right so this
code is exactly like that so if you
notice in this case when I run this code
it simply said done and did not do any
work at all as you can see because all
those evaluations are lazy it says I'm
so glad I did not waste my time doing
any of those and because the result was
never requested so that is a lazy
evaluation baked in so the real power in
Java is not just the fact that we have
lambda expressions but the fact that we
can actually use it for greater good
that's where we're really getting the
benefit out of it so we can use lazy
evaluation which is baked in and we can
do pretty nice things with it so this
also brings up the question so if I were
to put a break point within the East
greater than function will it be called
at all in this sequence of code and the
answer is no it will not be called
because it's a lazy evaluation so if
somebody comes to you and says before
Java 8 if somebody comes to you and says
is it really hard to debug Java code
you've probably innocently will say oh
no it's not hard to debug Java code put
a breakpoint and happily step through
and they tell you I'm so glad you're
saying is because saying this because
I've got 700 threads running and you're
going to say get out of here right
so the point really is whether debugging
is easy or not depends on the context of
what we do not the code structure that's
exactly the problem here too lambdas
don't make debugging hard it is the fact
that it's lazy evaluation makes
debugging really difficult again not
because it's difficult it's because
something it's we are unfamiliar with so
when you look at the code you gotta ask
if we're a pair of glasses and say when
will this code actually run so the place
where you have the code is not
necessarily the place where the code
would run you may actually have the code
defined here called here but it may
actually execute at a trigger point
elsewhere that's what makes debugging a
little bit more challenging for us until
we get used to these things but once we
get used to it debugging is not after
all that hard after all debugging
requires understanding the semantics of
the language as well that's the
challenge we have to go through so I
hope that answers the question so that's
basically the issue that we have to deal
with so we saw the beauty and the
benefit of the lazy evaluation yes
please yes the question is what what is
the value that we are getting back
absolutely so the result of this
evaluation that you see right here let's
actually do this I'm glad you were
asking the question so stream let's say
this is going to be integer after all
and i'm going to say stream is equal to
and i'm storing the stream right here of
the bad so obviously in this case i need
the stream so let's bring that n so i'm
going to say this is the stream dart
stream so you can see in this case I've
taken the result and stored it in the
stream however notice what I'm going to
do now i'm going to say stream dot take
the stream that we stored our way in and
i'm going to call fine first now and i'm
going to call done and then find first
and you can see that in this case the
done came first and the evaluation came
next it is that lazy it's you know waits
until you really really call it right so
this is me like me trying to file the
tax return right every April fifteenth
at 11pm have a conversation with the
Lord I say dear lord if we're going to
live for another hour let me know now so
I can file the stupid tax return right
so that's basically how this works as
well so thanks for asking that you
basically storing that away
and then calling that right here so
that's exactly what's happening so we
saw the laziness so let's revisit the
benefits we saw off these things well
the very first benefit is we got cold
clarity on our hand let's take a look at
an example of code clarity for a second
here the code I wrote previously was a
imperative style of code whereas this
code is here you can see is a functional
style of code but what's the biggest
difference between the two well the very
first difference is when you looked at
the code in the in the first place where
we did the looping you have to go
through the loop to try to figure out
what in the world the code actually is
doing and that can take quite a bit of
effort and time as we talked about
earlier and that's going to take a
little bit of explanation to do as well
so the point really is we've been doing
imperative style code for a very long
time and we can say result equal to 0
and then output the result and then of
course we could in a walk through
element is going to be in numbers but
here is the beauty right this is
something we have all done several times
and as a result to you and me this is
something we are very comfortable and
familiar with but it still requires
quite a bit of ceremony so in this case
result is equal to e x 2 and then you
break out of it but every time you look
at this you got to examine the code and
understand what it's doing but on the
other hand if you look at the code in
the bottom it is a lot more explicit
expression the code in the top as you
can see because it follows through very
naturally but here is the question if
you look at the code in the top if i
tell you that i want to change a
condition what would you have to do you
got to step right in between this and
you got to make change to this and
usually that's very unnerving because
you make a change usually and then you
stare at it for a little bit and you ask
yourself is this good on the other hand
if you look at the code in the bottom
notice what's going to happen you got
all these lines tagged up you don't want
the condition you remove a few lines you
want a few more conditions you insert a
few lines it becomes a lot easier to
work with the code so this is a lot more
expressive yes please
that's right so the question is can you
write your own terminal the short answer
is no the long answer is don't go there
and so so the short answer to that is
you can actually do this fairly
effectively with functions like reduce
and stuff like that so we can come close
to it by providing a lambda then
creating our own if you're going to
create your own that's a way too much
effort instead you can just work to the
reduced functions much more easily so I
would rather do that now here's the
beauty about this expressiveness as you
can see right here if you look at the
code in the top I said that this takes a
little bit of time imagine you are
sitting down coding and next to you is
your wonderful business analyst and your
business analyst asks you hey what is
this code do your response normally is
that's what I'm trying to figure out be
quiet on the other hand if you look at
the code in the bottom you can actually
have a conversation with them given that
collection of numbers I'm going to check
if they are greater than three get all
the even numbers double it and get the
first one what do you think and the
person can actually you know I talk to
you so this is a better code it's more
expressive as as you can see that
becomes a lot easier to work with well
we saw how expressive this code really
is but we saw the clarity this code
gives also so that's all really nice but
can we what can we do about with these
kinds of facilities on our hand well
let's talk about this real quick about
some of the things we can benefit from
first is the code is clearer than it was
before we're going to have fewer errors
why are we going to have fewer errors we
are not dealing with mutability as much
that reduces errors the code is easier
to understand easier to explain easier
to work with easier to modify all those
things end up reducing errors as well so
there is quite a bit of benefit for that
but this also leads to yet another
benefit which is it's easier to paralyze
as well but to understand this let's put
this into a context of something else
that we can actually look at and how we
can benefit from that so let's talk
about one other example I want to right
here so we can get a feel for how that
would work
so I'm going to start out with a list of
tickers and i'm going to say ticker
start symbols as some symbols i have
gathered up here into stickers so I got
some pickers and bolts on my hand I want
to make sure I'm connected to the
network here i'm going to use that so
I'll get back to that in a second we
will see how we can get the symbols and
tickers and work through that well I
have to get the internet connection but
I'll do that in a second so how do I
really write the code to get the prices
and work with it let's say I've got
these ticker symbols what I want to do
really is I want to get all the price
values and then once they get the price
values I want only the ticker symbols
ticker symbol that's the first one in
the order given greater than five
hundred dollars so less than five
hundred dollars so the highest price
less than 500 so how do I get the
highest price less than 500 I'm going to
write this code an imperative style
first then we will write it in
functional style compare and contrast
and see where we are going with this so
I'm going to say time it dart code and
I'm going to call a little function
called find imperative and I'm going to
pass to it the curse dot symbols first
and let's go ahead and write the
function find imperative this takes a
list of string symbols to begin with
this function is not doing anything it
shouldn't take time to do anything so
it's a minus 4 that's great but what am
I going to do with in this particular
function well with them dysfunction what
I'm going to do is I'm going to ask it
to provide me the values that we for
these ticker symbols and get the values
let's try it so first of all i'm going
to say list of stock info let's see what
stock info is stock info is just a POJO
it contains a picker name and a price
and you can see the price and symbols
nothing really big so I'm going to say
stocks equal to and I'm going to new
array list of stocks well now that I
have the array list what am I going to
do I'm going to simply say far while
string a symbol that comes from the sim
bolts obviously and then i'm going to
say in this case well Stark's dart add
so I'm going to add stock info and this
is going to come from stock util dot get
price and i'm going to say symbol and
ask
to get the price of the symbol well if
you take a look at the stock util let's
go ahead and look at what it does well
the stock util has a function call get
prize which is going to return a stock
info after getting the price from the
Yahoo Finance web service great now that
I have all the stock symbols what my
next step I'm going to create a list of
stock info in this case i'll say stocks
less than 500 equals two new this is
also going to be an array list obviously
and then i'm going to say for a stock
info and this is going to be a stock
coming from stocks obviously in this
case and what do I want to do with the
stocks after all well i'm going to ask
it if stock util is price let's say less
than 500 well is price less than 500
returns a predicate a predicate is a
functional interface like consumer we
saw earlier it has a test function we
can actually call into so i'm going to
say dot test to these stock if it is
happy with it I want to say stocks less
than 500 AD and add the stock to it as a
very last step what I'm going to do here
is I'm going to say here is a static
variable called stock info will call it
dummy equals new stock info and this one
is going to be just a zero point zero
and i'm going to say here is a stock
info we will call it hi prized we will
set this value to dummy to begin with
then we say a stock info and go through
the loop of stocks less than 500 and
this time though I'm going to say
high-priced is equal to stock util will
call a pic high among stock a high price
and the stock itself if you look at pic
I it takes to stock info but returns the
one with the highest stock price that's
basically what this is doing well given
this the very last step here of course
is to output the high-priced let's go
ahead and run this code and see what
output it provides now clearly you
wouldn't write the code in imperative
style like this I wrote three loops but
nobody would write three loops you would
merge
that into one heck of a loop but of
course if you write one loop nobody can
understand it but who cares about
learning and reading the code we only
care about writing code after all well
here is a response it gave us and you
can see the result it took about 13
seconds and the price was 143 dollars
for IBM stock price let's try this one
more time again though but this time
though I'm going to write this as find a
functional instead of imperative and I
need your help to write this so a public
static void find functional but i'm
going to take something a little
different in this particular code though
i'm going to pass to it a dot stream
after all rather than passing a
collection of you know strings I already
have a stream up here so I'm going to
say this is a stream of string and i'm
going to call this as symbols and now
that I have all the symbols on my hand
what am I going to do I'm going to
output of course but this time i'm going
to say symbol start well help me out
here I've got the stock symbols but I
want the collector that the collection
of stock prices what kind of function
could I used to perform that
transformation a map awesome you guys
are listening that's great so I got a
map function stock util and i'm going to
say get price after all but you see I
don't want all the stocks I only want
those less than 500 a filter I heard
great and this is going to be stocked
util is price less than 500 remember it
was running a predicate filter once
predicate that's awesome and the final
thing i'm going to use here is a
function well let's actually see what
this is i'll give you a little clue salt
is to pepper as map is too i like this
game reduce thats correct so reduce and
i'm going to start with the ha dummy and
then i'm going to say stock util a pic
hi so this gives us the price for us in
reality this is a functional style of
code we wrote I'm going to run this code
but while we run this code let's talk
about what we just did we wrote that
imperative code in the top as you can
see that too quite a while
too right but this one says given the
collection of symbols transformed to
prices get me the ticker symbols and
then give me the high price would you
agree that time is about the same give
or take right so three seconds internet
speed not big deal at all he's price the
same and really sorry apologize just
because you're right functional code you
don't get better stock prices right so
absolutely the same price as well time
is about the same too however looking at
this we wrote a lot less code so which
one would you write the imperative code
or the functional code the imperative
code of course if you're a consultant
getting paid by the number of lines of
code and the hours you work right if you
care to get your work done and go home
obviously this is a better code well
great but having said this is there any
other benefit let's enter it in the
start for a minute let's say you had the
functional code on your hand and you
wrote this functional code and what does
he do it does everything sequential II
remember the last project you were on
where you had all this code sequential
code at work remember the day you came
to work and everybody actually smiled at
each other that was a great job until
one day they told you we gotta improve
performance and as a result what did you
do you decided to use multi threading
and what happened when you use multi
threading on your project the code that
was so nice to work with suddenly turn
into a monster right and it had threads
everywhere and locks everywhere and you
could never recognize the scored anymore
but then something else happened as well
in addition to turning into a monster
what did this core do it started giving
you errors every corner you had to spend
your days and nights debugging remember
that project and after a while you've
had it and one late night while you were
debugging you realize how miserable life
has begun become and while in the middle
of the debugging session you applied for
this other job that's called conquer
that's called concurrency right so
you're like oh my goodness I don't want
that anymore why would I want to do this
kind of job after all well sure we all
been bitten by this over time
so we all hate doing it several times
over but notice that though we use
functional style we did not mutate any
variables explicitly we wrote pure
functions and writing pure functions we
wrote concise code so you can see about
in the ballpark of 10 plus seconds over
and over but somebody comes to you and
says we got to make this really fast or
we got to make this pair love well sure
I can make the spare love all I'm going
to simply say parallel stream and so I
did not change the code structure I
simply made one small change to this
code that's all I did but for doing that
what we got back was exactly the same
result but with a lot less time because
of course we were able to unleash
several threads on it at one point
without having to change a lot of code
so you can see how wonderfully easy it
is normally to write the code and enjoy
lazy evaluation but to get real fairly
good performance as well where it makes
sense to use these kinds of threads we
can employ these threads as well of
course that's not to say we want to take
everything and make it concurrent there
are certain problems where concurrency
makes sense and there are problems where
it doesn't make sense so we still have
to use our judgment and that's why they
didn't make everything concurrent I call
this a master switch it's a switch they
have given you and you have the
responsibility to know whether to flip
it or not and flip it when you shouldn't
you hurt yourselves but on the other
hand if you flip it when it makes sense
you can get a fairly good performance
with it as well and that's one of the
benefits you get out of it so to
summarize what we talked about we can
see the benefits you got out of this
approach which is you are writing a lot
less code the code is a lot more concise
the code is easier to understand easier
to work with easier to maintain you are
able to enjoy the lazy evaluation and
you're also able to paralyze it where it
makes sense well in addition to all of
this it actually makes sense to explain
the behavior of the code and it also
becomes a joy to write code finally in
Java and that is one of the things that
really excites me for a long time I did
not really get excited about writing
code in Java but this kind of code
actually brings back functional style of
programming into Java and as a result
it's a lot more pleasure to work with
as well I sincerely hope you found this
useful thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>