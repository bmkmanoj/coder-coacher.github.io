<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Taming Shared Mutability with Software Transactional Memory | Coder Coacher - Coaching Coders</title><meta content="Taming Shared Mutability with Software Transactional Memory - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Taming Shared Mutability with Software Transactional Memory</b></h2><h5 class="post__date">2015-06-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/F7v077SDwcE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to the session on taming shared
mutability with soccer transactional
memory my name is Venkat Subramanyam
we're going to talk about concurrency
here in this talk I don't take questions
in the end so anytime you have a
question is a great time for questions
comments so don't hesitate don't wait
folder for the end just draw my
attention start you know speaking and
I'll be more than happy to listen to you
so let's get started the first question
on my mind is why talk about concurrency
this is 2013 we've had multithreading
library on the Java Virtual Machine
about the day one java came out so
what's the big deal why should we really
care about talking about multithreading
today well let's give credit where it's
due one thing that Java did really well
if you remember the time before Java we
have to write different api's for
concurrency depending on the platform we
have to program in and the language that
we were programming in well Java gave us
this one API we could write create
threads and use it so it was very
convenient however there's quite a bit
of things that have changed since the
time job of us introduce the first time
this happened was in about two thousand
three timeframe when the engineer walked
up to his boss and he said it ran really
fast before it melted and he was talking
about the chips that couldn't hold up
the heat anymore so the question then is
what's the big deal still we've been
doing multithreading before we do
multithreading now what's the difference
well on a multi on a single processor
multi-threading is more multitasking on
a multi-core processor on the other hand
multiple threads run on steroids and
they run constantly now as a result a
program that pretends to work correctly
but is broken may actually seem to work
on a single processor but may end up
being broken on a multi-core processor
this reminds me of an experience got an
email from a guy who said that they have
had application in production for
several years and his company got him a
new set of multi-core processors he
deployed the product on it and all hell
broke loose so his question was what's
the easiest way to fix this problem I
told him it's very simple walk up and
turn off all the course any problem is
gone so why can't you really solve these
problems so easily and the reason is on
a multi-core processor
things are quite different than a single
processor let's say for a minute each of
us is a thread on a machine and imagine
that we are all concurrently running in
ennis yield for a minute the gentleman
on the first row here are some threads
and then he wants what's your name sir
henry wants a data so he walks up all
the way over here to the wall which is
the memory gets the data and starts
working on it maybe about 10 15 minutes
goes by and your name sir Tyler wants
the same data well Henry being a nice
guy says let's share it well you didn't
really prepare to sit next to each other
it was purely coincidental and that's
kind of what happens to threads as well
that they end up sharing co is
coincidentally but I'd say for a minute
that about 15 minutes goes by and
somebody up over there wants to get the
data they obviously are going to go get
their own copy of their data and not end
up sharing over here in other words a
program may appear to work correctly on
a single processor because of the cash
that they tend to share in a multi-core
system not only do we have multiple
caches but potentially multiple levels
of caches as well so in other words when
we deal with the program we have to make
sure we understand the so-called Java
memory model if you're not familiar with
Java memory model I recommend a
fantastic book it is called the job of
concurrency in practice Brian by Brian
gets it's one of the most scariest books
ever written for programmers and as
you're reading through that book you
realize how could you program in Java
without knowing the deal Java memory
barrier and remember a job memory model
itself so what does it really say it
talks about how the day I would go from
a working memory which is registers in
cash to the main memory back and forth
as the thread execute in fact the data
transfer happens several on several
occasions for example where you can ask
most our programmers what does
synchronize do and they would tell you
synchronize gives you a lock but if you
really look into it synchronize is one
of those cases where the data goes from
the working memory to the main memory
and back and forth and if you really
think about it this way the word
synchronize takes a very different
meaning it's a synchronization
the working memory and the main memory
as the thread is executing similarly
when you access a baller till variable
you cross the memory barrier when you
call thread darts start when you call
thread drawin when you call wait when
you call notify several of these cases
but this happens now the problem is this
if we don't think about memory barrier
and write code and if we don't cross the
memory barrier when be assured then we
have a bug in the code and if we cross
the memory barrier when we shouldn't
then we also have a bug in the code
because we may be violating invariants
for example what would happen if you
cross a memory barrier without knowing
right in the middle of a constructor
well you're going to expose the object
potentially when the obviously has not
been constructed yet and that's not a
very good thing so a lot of you know bad
things can happen if we don't understand
how this is supposed to work in order to
understand this let's look at an example
here let's say for a minute that I have
an account class that I'm going to work
with and and what is an account contain
an account contains a balance as you
would expect and then I have a
constructor over here which contains the
initial balance value and then I have
the value set up I have the deposit
method where I'm going to go ahead and
set the valley of the balance as you
would expect and then I have a
withdrawal method where I'm going to
check if there is enough money in the
account and if there's enough money in
the account i subtract the amount and
then I return are true otherwise I
return of false and then finally the get
balance method the obligatory getter
method to return the current balance
itself now that's my account class I
want to go ahead and use this account
class so here is a sample where a
creator to account objects both of these
accounts have a thousand dollars balance
I'm going to transfer money between
these two accounts of five hundred
dollars and when i am done i'm going to
print out the amount of money that's
left in the two accounts so i'm going to
implement this transfer method i'm going
to implement it so I'm going to say over
here a final account from and then I'm
going to say a final account too and
then finally a final int amount this is
what I would like to transfer between
these two accounts so I'm going to say
to our deposit amount and then I'm also
going to say from dot withdraw amount
also to initiate the trans
of money between these two accounts as
you're looking like this you probably
thinking God let this guy not work for a
bank right because we gave the money to
one of the guys as you running out we
say where's the money the other guy
maybe you want to put some checks and
balances into this well that's good we
can do that certainly so let's say if
there was enough money in the account
then go ahead and deposit the money into
the other account so we definitely can
solve it now we could try to run this to
make sure it's actually working and we
can run this and we can see that the
balance has been transferred and the
money now is 500 and 1500 between these
two accounts but what if there are
multiple threads running at the same
time how do we guarantee thread safety
so we have to make sure the access to
access to the accounts or thread safe so
what do you think I should do in the
account class to make it thread-safe
synchronize I heard so i put
synchronized over here thank you and I'm
gonna put synchronize in the withdrawal
method but I'm not sure should I put
synchronize in the get balance are not
know I heard anybody who fixed to defer
I heard no I heard yes and I heard
depends well here's that we could do
this right we live in a democracy we
could take a vote right well we know
that's not going to be the right way to
solve the problem democracy doesn't work
all the time especially in software so
let's prove by contradiction what if I
don't put synchronize if I don't put
synchronize then it would not cross the
memory barrier unless something else as
the threat to cross of every barrier so
as a result potentially this thread may
not cross a memory barrier it may
continue to report an old balance it may
be at the time when the balance has
changed rapidly maybe the account is
closed maybe even the bank is bankrupt
who knows right so the point really is
it is not about race condition or solely
though it is really about making sure
that the code is crossing the memory
barrier and we are able to get the
updated data otherwise we may get go
very stale now that I put synchronized
over here now the code is thread-safe
and we are done what do you think
I hear no I had a one guy a couple of
weeks ago say heck no I'm like wow
that's pretty resounding how do you know
that and he says been only about five
minutes since you started cannot be over
right yeah absolutely that's a way to
find out so absolutely it's not done we
definitely have to do one more thing as
well we're going to go to the account
service over here and i'm going to say
synchronized over here from and i'm
going to say synchronized over here too
and then i'm going to go ahead and do
the operation within this method now and
our redone is the code thread safe now
now we are thinking a little longer oh
we have a deadlock possibility in fact
there are a couple of different problems
at least in this code there's a problem
of deadlock but there's also a problem
of live lock as well like what well
where could there be a deadlock well if
two threads come in exactly at the same
time and one or transfer money between
exactly the same two accounts but in the
opposite direction one two it wants to
put money from account 12 count 2 and at
the same time another thread wants to
put money from account to account one
they both end up locking two different
accounts and start waiting on each other
potentially causing the deadlock this is
an example of having a boy and a girl at
home and in the morning they run to the
kitchen one grabs milk and waits for the
sugar on the other grabs sugar and waits
for the milk what do you have on your
hand no not I did lock a parent a
nightmare right so absolutely want to
solve it how do you solve it oh no no
spanking the children they're wonderful
so we want to enforce an ordering in the
code so we could do the same thing here
we could say all right from tomorrow you
can only get milk if you already have a
sugar not otherwise so we could say for
example implements a comparable API over
here and then we could say given this
comparable API for an account we could
go ahead and implement for example the
compareto method it doesn't really
matter what we do in this method so I'm
going to leave that unanswered for a
minute because that doesn't matter to us
holy here so far so now that we
implemented that we could come back here
and say well why don't we go ahead and
Korea
an account collection and we will call
it as accounts for a minute and this is
going to be an account collection from
and two are the two objects I want to
work with and then would say arrays dot
sort these two accounts and then once we
sort the accounts we could potentially
say accounts 0 and then we could also
specify accounts one but unfortunately
while this is still true since we have a
synchronized on those two methods
explicitly we got to make sure every
time we call those methods we got to
make sure we put the proper ordering
also so we could go a little further and
see how we can solve the deadlock
problem in the meantime we also have a
live lock problem what is a live lock
live lock is where a thread may wait for
something to happen for a very long time
not a deadlock situation where there is
either a mutual or a cyclic dependency
but you're just waiting on something to
happen now when you call synchronize
you're going to cross the memory barrier
and obtain the lock but if you don't
have the lock right now what's going to
happen to the call to synchronize it
will block how long will it is it going
to block indefinitely until it gets it
how smart is that imagine you're at work
and you want a cup of coffee go to the
coffee machine it's empty and you say
this there's like dude what are you
doing waiting for the coffee to fill up
and how long you're going to wait for
then how does it get filled up I don't
know right not a very productive day at
work right so in other words we have to
make sure there's a time out that
happens but how do you make synchronize
time out unfortunately there's no way to
do that so instead of doing this we
potentially could go back here and say
we're going to provide a little object
here called a lock object will call it a
monitor for lack of better words and we
could say this is a reentrant lock as
the name indicates you can do we enter
the lock that you already have and then
within this if I wanted the lock I could
then say monitor dart lock but that's
kind of not productive instead we could
say drylock and to the trilok we could
even give a time as as a value and try
lockwood either immediately give us a
lock if it exists and return a true or
it will wait for the time out and say
I'm sorry I'm returning
falls to you because I couldn't get the
lock well in this case now that we have
a lock potentially if we do have a lock
then we would then perform this
operation inside of it but unfortunately
if we go this route it's our
responsibility to do the unlock as well
when we are done with this so we'd have
to call unlock but this only increases
more problems because now we have to
worry about potentially exception
happening along the way and we want to
make sure that even in the case of an
exception the problem the the lock is
released properly so we would have to
put a finally block over here and then
we would have to put this over here we
would have to then similarly change the
withdrawal method and the get balance
method and the transfer method and when
we are done with all of that we could
ask ourselves is the code now thread
safe and what would be your answer your
answer is I see the nod over there
saying now it's gotten so complex I
don't even know what this code is doing
in the meantime you hear a knock on the
door you turn around the bosses over
there asking how's it going you say a
great thanks for hiring I don't have a
clue what I'm doing now right because
the code has become sold on complex over
time we cannot maintain this so if we go
this route and create the code what's
going to happen we are going to create a
code that is slowly turned into a
monster and we don't even know if this
code is working anymore or not in other
words the mid because this path of
synchronization it gets very painful now
the other day I was writing a piece of
code I brought a synchronization in the
code so i did put synchronize on the way
home i was thinking about this code now
i know not to do that think about code
while driving and i talked to myself did
I synchronize this right and I ran home
as soon as I go home I run to my
computer turn it on login and I look at
the code and sure enough I had not
synchronized at the right place and once
I fixed it now I'm wondering where else
the code is broken I don't even know
about it so to summarize what we talked
about here so far we could write code
with locks and synchronization and if we
forget to synchronize the code or
synchronize at the wrong place
java compiler will give us a stern
compilation error correct no well okay
it gives you a warning right No then
what does it do well not not what I tell
it to it does whatever it wants to do
depending on the situation how the
memory is organized at the time because
I can't control the way the cash is
managed a given time right and i forgot
to say things the right way and so we it
becomes extremely unpredictable and we
don't even know in what way the code is
going to misbehave the code may run one
certain way and then it fails one day
and you say look that fail then somebody
says really we'd run it and it doesn't
feel the same way anymore so in other
words i realized that programming
concurrency with synchronize he is like
working with the mother-in-law she is
waiting for us to fail and there's no
way to develop enterprise systems with
this kind of friendliness that it
provides for us so i gave a fondly name
for it I call this the synchronize and
suffer model because there's nobody
going to synchronize and sink after that
so we could go this route but are there
other things we could do well there are
two prominent approaches we could
potentially take one is called the
software transactional memory which is
what I'm going to talk about today in
this presentation and the other is actor
based concurrency which I will not even
touch in this presentation and in the
synchronizing suffer model the problem
in Java is not that we have to
synchronize I don't mind doing things
the problem in Java is what happens if
you forget to synchronize or if you
don't synchronize at the right place the
result is unpredictable and that's what
causes problems for us what if this can
become predictable this is where the
software transactional memory comes in
so we can avoid the peril of
synchronization STM came onto the JVM
through a closure language it's been
around for a while but closure ricky
implemented this enclosure and STM is a
very powerful model what does it really
do well let's talk about a little bit
about what closure does before we go
further and use this in java so i'm
going to define a balance over here as 0
oh and i'm going to go ahead and bring
the value of balance right here and you
can see that the value of balance is
zero now you could tell me that say go
change the balance and I have to say I'm
really sorry I cannot do it because
enclosure all the variables are
immutable we cannot modify the variables
once we create them now enclosure they
introduce a nice concept called
separation of state from identity what
does it mean by separation of state from
identity well the answer is really this
if you ask me what's google stock price
at one o'clock you would say that's some
crazy high value that it is and then i
can ask you what is the stock price of 1
10 and you could say that it changed to
another crazy value well that's one way
to look at it but that's not really the
right way to look at it if you really
think about it Google stock price never
ever changes if you come back about 20
years from now and say what was the
google stock price that one o'clock that
afternoon on sep tember the 23rd that
value will never ever change it is
immutable written on stone never to
change again so you can think about this
as this is google stock price that one
o'clock in the afternoon and this is
immutable never going to change well
once it's created a few minutes later he
wants access to this particular stock
value at the same time she wants access
to the stock value i'm going to give it
to both of them I wonder how many locks
I need to hold on this value that's
correct zero because it's immutable why
bother locking what cannot change well
what about a change to the value well
the value cannot change it's immutable
state but I have the identity my
identity is pointing to this value at
110 in the afternoon we create a new
value for the stock price and we didn't
change the existing value now that we
created a new value for the stock price
the old value still remains war where it
is but I'm going to change the identity
from the old value to the new value the
old value can be around if you want
historic values or it can be garbage
collected but I have the new value well
the beauty of this is we no longer have
to worry about the data
itself because that is immutable p but
what about the identity you're modifying
the identity aren't you excuse me and
how are you going to deal with it well
that's the beauty is this is not just a
mutable identity it is a shared managed
immutable identity now why do we really
need something as much as a shared
managed commutable identity the reason
is in Java we've been programming with
mutability all the time so if you ask
most programmers what they think they
say yeah that's life in the big city we
always mutate things what about sharing
well sharing is a good thing remember
what mom told us right mom said share
that's a good habit to develop so
mutability is all right sharing is noble
but shared mutability is purely devil's
work and the minute we bring in shared
mutability we have to worry about
contending with the problem with the
shared managed immutable identity the
identity is mutable but it is well
monitored and managed by SDM software
friends actual memory and so it says you
cannot just walk up to it and change it
well what would happen if I walk up to
it and change it you scream loud and say
he touched this particular object and
you're not allowed to do this right so
let's see how this is going to work
notice what I'm going to do here I'm
going to modify this to a ref object now
when I run this it prints the reference
rather than the original object I can be
referenced this and get the real object
from it if I wanted to so I could say
for example print line balance and say
give me the balance value and you can
see the value is 0 but I'm going to walk
up to this object and say LF said
balance do a thousand and notice now
when I run this it blows up on my face
and say is illegal transaction exception
and it says no transaction running so
it's slapped on my wrist and said how
dare you touch this object because
you're not in a transaction so we went
from something that's not non
deterministic unpredictable I'll hurt
you when you don't expect the least
model to hear we're going to blow up on
your face and tell you this is not
acceptable don't modify this variable
because you have not entered into a
transaction well that's
first good step but what is a
transaction really mean well if I want
to make this change to this object I
would first have to enter into a
transaction so i'm going to say do sink
over here so do sink and what does do
sink mean I'm entering the transaction
and then I'm going to wrap this into a
transaction Oh wrong place so I'm going
to wrap this into a transaction over
here and then now that I've created a
transaction let's call it do sink over
here and this is going to run within the
transaction now notice when I run this
code it no longer complaints but at the
very end of this if I come back and ask
him what is the balance value and be
reference said you can see the value has
been modified to a thousand what does it
really mean well let's talk about what a
transaction is every thread that wants
to modify one or more managed mutable
identity would have to enter into a
transaction a transaction is a cone of
silence so whatever happens within a
transaction is atomic nobody would ever
know about it until the transaction
commits if a transaction were to roll
back then it's as if it never happened
and the result will not be visible
outside so transactions provide a cone
of silence that's great what does it
mean now if the threads enter the
transaction if multiple threats enter
transactions and run if they don't
collide with each other they all
complete on the on their own will and
there's nothing to stop them from
completing just like you saw this code
finish up a way to think about it is
this suppose I decide to get down and
walk out through this door over here now
there's nobody around here I can go to
the door I can open the door and I can
walk out and there's absolutely no
problem in me walking out at the very
same time you somebody can walk out
through the door in the back as well and
there's nobody who's going to stop them
either so we all can exit through
different doors all at the same time
because we're not colliding with each
other but what if two people are
approaching the door exactly at the same
time well in a civilized society what
would we do one of us would step back
and say after you please and let the
other person walk through so one person
will go through and the other person
would we try now potential
Lee if I'm approaching the door and I
see somebody you know walking along with
me i would probably step back and say
after you please and let them and I
would make an attempt to walk through
and if I see another person I know fall
in line right away I might even be
generous to take one more step back and
say after you as well and i would let
both of them walk through and both of
them did not have to wait and i had to
retry the third time to walk out of the
door this is exactly what happens in SDM
if two threads are not colliding and
competing with the same set of data they
both can complete and there's absolutely
no delay for each one of them on the
other hand if two threads are competing
with each other one will complete and
the other will retry in STM closures STM
a thread may potentially retry for a
maximum of a hundred thousand times
without me having to write any code at
all and at the end of hundred thousand
times it may bail out now somebody the
other day was very curious and said what
what do we do after a hundred thousand
times that's called bad karma right it's
not meant to be so don't keep retrying
this go back and redesign the
application it's not meant to work
concurrently this way so we talked about
quite a few things about how this will
work it would be nice to see this in
action but this is enclosure that was
implemented but you said does it mean
that we have to program enclosure well
sure you can if you want to but there's
nothing that stops us from using this
from Java so we said there's a managed
immutable identity called ref take a
wild guess what language did they used
to create this ref class java that is of
course so we're going to use this from
Java but how can we use this from Java
code well let me first of all rolled
back from all this mess we created a few
minutes ago and so no more synchronized
in this code and we completely reverted
back from all of that code similarly in
the accounts service class I'm going to
back out of all this change that we made
and get back to the simple code that we
going to write in just a minute we'll
come back to it and we'll do this in
just a second so going back to this code
we have the sample class doing the
transfer if I run this code right now
there will be no
transfer obviously because we haven't
implemented transfer method but if you
want to make sure we do this correctly
so what are we going to do well I want
to use the ref class over here enclosure
how do I do it it's extremely simple I'm
going to save left over here and quietly
bring in the closure dodge are into my
class path that's all I'm doing I just
brought in closer to our jar and I've
did the import of closure Lang ref you
can either bring enclosure and use it
like this you're only bringing the
closure library you're not programming
enclosure when you do this or you can
use some other library like multiverse
which is a java library written for
supporting SCM as well you can pick and
choose the tool you are interested in
using so now that i created a left
object and i'm going to go ahead and set
this ref object to an initial value of
initial balance and remember initial
balance is an int and when we send it to
an object like this it's going to go
ahead and cast it and as it is certainly
a big I integer object which cannot be
mutated anymore and as a result we came
back to the situation where the identity
is managed mutable but the value that it
points to is immutable you cannot change
an integer how do i modify this
reference if at all i want to so i'm
going to say here is a balance dart set
over here so set over here in java is
the equivalent of left set you saw me
use enclosure a few minutes ago and then
i'm going to say get balance over here
plus the amount that i want to add to
the transaction and similarly here i'm
going to say get balance over here and
then i will say dart set in this case
and I would simply say get balance minus
the amount that I wanted to set over
here in this code and then finally I'm
going to say in here I want to simply
return an integer for the balance and
I'll simply call balance start b-ref and
say get me the amount of the balance
that I have on my hand now while i
implemented the rest properly here i
intentionally forgot to do one more
thing what is it the transaction that's
correct let's see what happens because i
forgot the transaction let's get back to
the transfer method account service
methods transfer and i'm going to say to
dar de passe
it amount so I'm going to take the bold
step and giving the money to this guy
after all everybody trustworthy right
and then from that withdraw and then
then the amount as well and let's go
ahead and run this and see what's going
to happen now in this code so when I run
this code now in Java notice it failed
loudly and if you look at the exception
we got over here it clearly tells us
illegalstateexception no transaction
running so we have a very deterministic
code on our hand that says how dare you
touch that object to mutate it you have
an intro to transaction so now I need to
enter a transaction how do i enter a
transaction well remember enclosure we
use the sweet little method called do
sink well do sink is actually
implemented using what is called a
locking transaction class and that's
what we're going to do use in Java side
so I'm going to go back to the deposit
method and say locking transaction dot
run in transaction and whatever code you
put within this pair of parenthesis is
going to run in a transaction but what
code can I put within a transaction in
older versions of Java this would be an
anonymous inner class the full-blown
ceremony and the noise of anonymous
inner classes we can still use it in
older versions of Java if we wanted to
but on the other hand I'm going to
simply use a lambda expression here
you're not required to use lambda
expressions but it's so sweet and
convenient to really use it and so right
there within this code I'm going to
simply say return and now because I
don't have any objects to return but the
code I want to perform is really this
code that I want to place right here so
at this point Java is complaining that I
have exceptions to handle but has
experience all the programmers you know
exactly how to take care of exceptions
so we took care of that so in this case
I simply said in a given this particular
transactional code this line over here
is going to run within a transaction
nicely well but there's a problem though
what if I don't have you know you know
proper money to deposit we'd have to
handle it will come back to that in a
minute similarly I'm going to go
back over here to the withdrawal method
I'm going to go ahead and write this
code right here run in transaction one
more time I'm going to specify over here
what to do with in this code so in here
I'm gonna say if there is enough money
in the account then go ahead and perform
that operation return a null when you
are done with it I don't have any real
result to return I'm going to just make
this into a boolean into a void method
from Anna want and then once we are done
with this I'm going to simply say go
ahead and perform this operation return
a null when you are done with this and
what if there was an exception there was
not enough money however so I can then
say for example here elves go ahead and
blow up and throw an exception so how
would I say it i'm going to say simply
say throw new runtime exception and
we'll say no lock are no luck but about
the same and then we could tell there
was no lock obtained if there was no
lock or in this case there's not enough
money because we don't deal with locks
anymore we could simply say pray that
morphological error rather than rather
than an infrastructural error we could
simply say not enough money so notice
the focus turns into the domain specific
concerns so it's not enough money in the
account and that's the you know money
and then throw the exception back at the
caller now what happens when the score
throws an exception well the code throws
an exception and it ruptures the
transactional cone a cone of silence so
the data would never go back to the main
memory would not cause the memory
barrier well fortunately the D left
method runs in its own transaction we
don't have to do anything more at this
and finally in the ad service meth
account service method we would have to
take care of this also so I'm going to
put a try block over here where I'm
going to call this method and within
this if there was an exception I'm going
to catch the exception and print their
details of the exception for us to see
so I'm going to say over here oops and
then print out the exception detail so
we can actually see it but I have to run
this within a transaction also now the
question is if I don't do it will i get
an error at runtime no not
in this case because we already have
transaction at lower level so this code
will not give us an error well that is
does it mean the way back to Squire one
of unpredictability and answer is no
we're a lot better off and the reason is
we can set up a nice test over here that
says make the deposit go through make
the withdraw fail and make sure the
balances have not been changed and that
test would fail right now in a very
deterministic way and then we can come
back and fix the code after that so I'm
going to say locking transaction dart
running transaction one more time over
here and within this lambda expression
I'm going to go ahead and simply write
these two lines of code and and
eventually return a null because again I
don't have anything to return back from
this collar Bell which is what this
running transaction actually expects a
callable and I'm simply saying I don't
have anything to send to you well now
that we did all of that let's go ahead
and run this code and see what it does
and you can see that the transaction bit
complete and the balance has been
transferred between these two accounts
is it really doing the job well in order
to understand that let's go ahead and
try this one more time so I go back to
the account class and in the account
class if the deposit went through I'm
going to go ahead and output right here
which is not a good idea generally I'll
say why in a few minutes but i'm going
to say deposited and then i'm going to
say the amount that's being deposited
and then i'm going to say will it stay
and ask that question and now i go back
to the sample run the code and you can
see that it this time it says deposit at
five hundred dollars will it stay and
you're a dead stick but just to prove
that the transaction is run in cone of
silence they provide the so-called as
see property not that be in ass said
because there's no durability because
the data is in memory but they provide
the a/c of the acid it provides a comma
city consistency and isolation so
anything they do is not visible outside
until the transaction comets in order to
prove that I'm going to transfer fight
thousand dollars now take a look at this
code for a second what are we doing we
simply said our transfer
5000 so if you monitor this code a
little bit you will notice that within
the transfer method we have created a
cone of silence a transaction we call
the deposit method the deposit method
says oh I got a five thousand dollars he
says I'm rich and runs out of the
building and then in the meantime we go
out of this transaction into the nesting
transaction we go into the withdrawal
method and say can have you 5,000 please
and he says are your nuts I have only
have a thousand dollars why do you ask
me 5,000 the exception happens the cone
of silence is broken the nested cone of
silence is broken and so this whole
thing should just disappear as if
nothing happened well at least that's
the theory let's see if that actually
worked so let's go ahead and run this
code and see what it does and notice
right there deposit at 5,000 will it
stay followed by not enough money
exception followed by the balance did
not change at all so this shows how the
transaction can be running but the
change is done in a transaction it
disappear from the main memory on unless
a transaction is committed now when
multiple transactions are running like I
mentioned earlier they all can run to
completion independent of each other and
we're not holding any external thread
alox in this code so life becomes a lot
easier to work with however there are a
couple of things we have to be very
mindful of the very first thing is the
code that we put in a transaction has to
be pure pure as in a function which has
no side effect the only thing you should
change within that code or the managed
mutable identities and not any other
data any other object so things you
should not do within a pure
transactional function are you shouldn't
write to the console like I did in this
example not a good idea you shouldn't
write to a database and comment you
should not love to a log file you should
not send emails to customers saying
congratulations we deposit this money
that followed by nevermind that is not
going to win your customers right so in
other words you want these operations to
be pure as much as you can and then make
sure once the comet happens then you go
back and do the side effects and not
before that and so this is a way for us
to implement this code but you may say
wait a second that's all nice so far but
we are talking about concurrency in this
point but you never really showed us
multiple threads running wouldn't that
where the real fun is oh sure enough but
the concept is still the same whether
you are in a single thread entering an
apartment or multiple threads entering
an apartment it doesn't change a whole
lot except for one thing we're going to
see which is the transactions retrying
because it was another transaction in
place already how does this really work
well the way this works in STM is as
soon as you enter a transaction STM
builds up a change graph for your
transaction it America builds a change
graph where it says here are the objects
this thread this transaction is
interested in and it monitors your
change graph with the change graph of
all the other transactions running at
the same time if one of the transactions
modifies a particular object and commits
the data it lets the transaction finish
logically if it can and then runs to
these other transactions running and say
you guys are fine because you're not
dealing with the same objects in memory
but these few transactions you your
change graph has been affected because
one of the objects are more objects you
depend on has been modified by a thread
behind the scenes so you no longer can
succeed no matter how long you continue
to run so it preemptively aborts those
transactions right away and retries
those transactions and when the
transactions retry they enter back into
the transaction one more time and they
could do their logical checking to see
if the data is consistent and good for
it to perform logical operation if not
they can bail out like if there's not
enough money in the account anymore or
if it is logically good then it can go
ahead and finish that a transaction at
this time so in order to understand this
and see how this is working let's go
ahead and set up a little example to see
how this is going to work so what I'm
going to do here is to create two
threads and let them run on the same
account at the same time and see how
they would compete with each
other but they would resolve between
each other now remember what does
concurrency really mean the effect of
multiple concurrent operations should be
as if they all ran in some serial order
in other words if we go to the bank for
example and deposit money and withdraw
money you don't care so much but it's as
if one of them work version the other
work afterward so you want to see the
money come in and the withdraw happen or
the widow happen and the money come in
but in the other hand you would be
really upset if you do this and the bank
says oh sorry we would be supported
concurrency but we lost some money hope
you don't mind right so it's important
to really make sure that the net result
of this operation is consistently what
would have happened if these were
running at two different times so how do
we set up a situation to do some of this
it's actually very simple to try this
out so let's get back to the code over
here let's go ahead and remove this
message because I mentioned that it's
not a good idea to print these kinds of
messages after all so i removed that
message let's get back to the sample
itself run this code one more time to
see that it is actually not transferring
money let's go back and put the five
hundred dollars and make sure it is
transferring the money so that is good
but now what we're going to do here is
create multiple threads but in order for
us to see that the transactions are
running really concurrently I'll just
make in a little message over here for
us to see and I'll simply say
transferring and then i will put the
amount that we are going to use over
here so we can actually see that
happening so what do i expect to see in
this code now what i expect to see in
this code is two transactions will
concurrently come in both will get
started one of them will finish on the
other one says oh my change graph has
been messed with so i'm going to restart
and retry this yet another time without
us having to write a single line of code
so how can we do really that let's take
a look at an example of how triple it is
to try that so i'm going to go back to
this code and i'm going to go ahead and
remove that for a second and simply say
over here executors and let's go ahead
and say new fixed it thread executor let
me get a pool of threads for working
with that
example here so now that I have some
executors on my hand I'm going to first
of all remember to shut down the
executor when I'm done with it and so
I'm going to say shut down so this is
going to finish up the multiple thread
pool that's running and then I'm going
to put a little thread dart sleep over
here to give an opportunity for the
threats to finish let's give about a
two-second delay just in case and then
I'm going to say over here the executor
service dark so let's start with this
guy and I'm going to submit and what are
we going to submit well it can accept a
runnable or it can accept a callable
well in Java in previous versions of
Java we will do the ceremony of new
runnable and then would implement a
public void run method but we don't have
to do that anymore we could simply use a
lambda expression here so I'm going to
simply tell this guy I want to execute
this piece of code but what do I want to
do here account service start transfer
money from account one to account to and
I want to transfer let's say a $300 i'm
also going to say over right here I want
to transfer between exactly those two
accounts also but I want to transfer two
hundred dollars between those two
accounts look at the lack of ceremony I
usually don't show this example because
I go to the room and beep after this
after a four minute because the code
looks so ugly and ceremonious where you
feel dirty after writing it with lambda
expressions it is sweet it doesn't take
a whole lot of effort at all then it can
just drop the lambda expression so easy
nice to do it so right there is an
example of how we created two threads
and launch them and said go run those
two and perform the operation now when I
run the code notice I'm only
transferring to announce one transfer of
301 transfer of 5 a 200 so at the end of
this I would be very unhappy if the
result is not accumulator transfer of
500 right so the change should not be
any different but the problem is
concurrently we are trying to modify to
this is where life becomes really sour
because we end up to threats coming in
and if you're not careful either we saw
the 300 go through or the 200 go through
I know we sit there and say what
happened to the remain
200 or 300 that we ended up losing well
not so here how does it resolve it so
when I go back and run this little code
now and see how this is working notice
from the output we are seeing that it
started the three hundred and two
hundred to begin where and it's so
turned out the two hundred transfer
completed and that 300 was the most
civilized one by the door that said
after you please and then went back
again trying and you can see the
transaction was automatically retried
without us having the right to write the
code now you could run this enough
number of times and possibly two hundred
would repeat one of the times instead of
the three hundred repeating so there you
go so 200 repeated this time rather than
300 which repeated last time pure to say
that in a civilized society we are all
mostly civil about the same way like you
would be more than willing to let me
walk through the door as much as I would
be more than willing to let you walk
through the door right and just exactly
the way a work and notice the final
result of the transaction is as civ they
happened at the entirely different time
and and the collective transfer has been
a five hundred dollars so we saw how we
can use STM to implement this code and
so what it s TM really provide for us
STM really gave us a way to manage this
coalition's of transactions and we are
using the transactions that concurrently
run and if transactions don't collide
with each other they all commit and
finish interchange is visible and the
minute the transactions are colliding
with each other one of them finished and
the others retry and so when does it
make sense to use SDM well before we
talk about when to use STM let's talk
about some ground rules which are
extremely important to follow the very
first ground rule is within the
transaction we should never modify
anything other than the managed
immutable identities so if within the
transaction we quietly sneak around and
start modifying some variables in the
memory bad things can happen and we are
back to square one of the problem
in fact I would argue that closure is
the only language today that makes
concurrency safe because of immutable
variables being the default in the
language every other language use your
api along with a loaded gun with it so
it is important to be careful how we use
it even with enclosure to be fair it is
not really effective the minute you call
third-party libraries because if you're
calling third-party libraries within
your functions then there's absolutely
no way to guarantee that those don't
sneak around starting out causing
mutations please what about Haskell well
it's just mostly referring to JVM
languages because we are in a Java
conference your point well made in fact
this is where it originated in the first
place so thanks for pointing that out
and correcting me well I implicitly
assumed JVM in this context of course
you could try to run a jay a haskell
implementation of the JVM and then the
problem is still there if you ever care
to do interoperability between languages
other than the language itself because
of the ecosystem we are going to face
the problem no matter what so so within
the JVM if only we stick to one language
that fully enforce the immutability and
don't interrupt it with any other
languages then we can which is pretty
impractical for all practical purposes
right so having said that one of the
things we have to make sure is that we
do not cause mutability in this code and
that is something we have evaluated
maybe make sure that we do now given the
caviar and assuming we can be that
careful and only modify managed mutable
identities in this object then what are
the power and limitations of SDM well
the power of sdms we no longer have to
hold external locks by ourselves now
what is it good about not having to
maintain the locks well the first thing
is because we're not maintaining the
logs we're not writing code to maintain
the logs hands down the code we are not
writing has the fewest bugs in it so we
end up having fewer bugs because we're
not writing those code in the first
place the second thing is it saves us a
lot of time and effort because we can
focus on the domain of the problem
rather than infrastructural locking ish
use the third benefit is if you don't
have to provide a lock you don't have to
worry about a deadlock the fourth
advantage is if you don't have to
provide a lock you don't worry about did
you lock the right object did you lock
at the right time did you lock it for
the correct duration all these problems
go away and so we can focus on the
domain problem and focus and get it to
work please yes all right so a man of
caution over there what is the
disadvantage i am going to mention one
disadvantage and that is we got to use a
fine-tooth comb to make sure we're not
causing an immutability in code and that
is my biggest fear to be fair and in
fact i would say that's the only
disadvantage i'm going to mention a few
other disadvantages but none of the
things i'm going to mention from now on
he is such a big disadvantage compared
to that one thing i mentioned already
because that's my biggest fear because
if you if you don't keep care take care
of making sure of this then the result
is again unpredictable we end up losing
things but I having said that one of the
problems in SD mas that you're going to
have to maintain this object change
graph if the transaction is good will be
little long running the chances of it
being slapped silly is high which we
know already because long turning
transactions are also called as bad
ideas in the first place that holds true
here as well so their transaction to be
very short-lived the second thing we
have to be careful about is when
multiple transactions are running
concurrently this heavily favors readers
which is a good thing the readers never
get blog readers rule the worlds in STM
and readers are speeding train they come
in they get their data they are done
they move on and they are never stopped
at all but the writers are a very
different story the minute a writer
comes in a writer would have to come in
and say I need all these no locks on
this internally that is that's being
done behind the scenes and then it can
comment only if nothing else is
colliding with it now if you think of a
situation where multiple writers come in
what's going to happen well it's not
going to be any problem at all as long
as these writers are mutually exclusive
of each other I mean oh you are writing
to your account I am writing to my
account a million
people come in and write to their own
accounts not a problem but what if a
situation is where multiple writers
collide with exactly the same data then
STM will miserably fail at one point it
would be extremely slow because
transactions are retrying and burning up
the spin of a power on the machine but
that slowness can eventually lead to
transactions failing so STM will not
work when there is a huge amount of
contention but I would ask what kind of
application really has that much huge
amount of contention very rarely do we
have that we have contentions all the
time in applications but not an enormous
contention where you know 7080 threads
are colliding to modify exactly one
object exactly at the same time so in
other words this works really well for
large number of readers works really
well for large number of writers that
are not colliding and as long as the
right coalition's are infrequent this
model works really well please
no so if the transaction retries it is
automatically retried without our
intervention at all however if there was
a logical error or it runs out of the
maximum number of retries only then the
caller gets an exception saying that we
have tried hard enough this is not
working time for you to go back and
redesign please and so the readers don't
have a ever get a dhoti reads because it
makes sure that the writers do not
commit the data so well the point really
is this when you have concurrency going
on one of the things we have to
fundamentally keep in mind with and
that's what STM forces to think about is
the model where I say I am going to do
something and so while I'm doing it you
cannot read anything he's really not
concurrency so fundamentally STM says
we've been doing concurrency wrong and
that is to say I'm going to do this
right over here entire world has to stop
and be quiet for the next couple of
seconds until I finish the right so the
model of the story here is readers are
non-blocking potentially they may get a
slightly out-of-date value however the
the reality is the world is just that
right so if you want to say when I am
writing a lock of the entire world that
is really not what concurrency is meant
to be because in a distributed
application you can never be sure when
two things happen exactly at the same
time so the model is slightly skewed for
that for really making that happen but
it's not really a concern to be sweating
about but if you really analyze that the
writers actually are very short-lived as
well so the chance of this really being
enormously outdated he is extremely rare
at 2a to almost non-existent but but in
fact we would make this worse by holding
on locks because then we are saying slow
down slow down and then in the process
we actually increase the contention by
doing so another benefit this gives us
is when multiple transactions can
currently running if two of them come in
still a little bit one after the other
we are not going to be waiting on each
other at all they end up completing
automatically whereas if you're going to
be doing locking and unlocking we
actually increase the chance of
contention because we're saying you log
and only after you get the lock can you
go do other operations and the other
thing that has to either it has to come
and pile up and logically the first
threat may actually bounce and then now
we have made the other thread wait
unnecessarily and those problems to
simply go away yeah it repeat that for
be absolute absolute Lee we have come to
the point where we have evolved and we
should evolve to understand what
concurrency really means that's what I'm
saying we have a lot of misconception
around programming where we think that
consistency is meaning that I've locked
everything in the world and I'm going to
sit around and make sure it doesn't
change that's not what consistency means
we have to really learn what consistency
really means and then program our
designs around it otherwise we will end
up losing come concurrency overall no it
will not so the question is would we
really be getting something incorrectly
the answer is no we should make sure
that when we cross when we enter a
transaction and when a transaction
completes you are crossing the memory
barrier all the time so what's going to
happen in this case is when you have
entered a transaction your your cross
memory barrier you have the data in your
working memory and so you're guaranteed
to get the most updated data if you are
saying I'm going to sneak around and
start reading other data that has not
been in the transaction then we
potentially could be in trouble but that
again goes back to the point I made
earlier is that you should make sure
that the data you're reading are brought
in consistently within a transaction and
used and if you have a stale data you
pulled in and you're trying to use it
then we are violating the code of
conduct of programming here we need to
go through the managed mutable identity
to get the value we are interested in if
we don't cross a memory barrier when we
cause memory barrier if you're not using
the data that we cross then we are in
trouble with that so we got to be
careful using that
um so it please okay so STM itself is
really within a particular JVM itself
and and there are other solutions that
are added on top of this to say I really
want this to go across multiple
processors but that's not within the
scope of STM it self esteem is purely
not not even about machines it's really
a single JVM implementation of single
runtime implementation but there are the
third-party solutions that say hey why
don't we try to take this across for
example there are things that combine
actors with STM's as well and and my
experience has been they can be very
complex in trying to deal with this but
there are some solutions that mix them
together as well so so that is one of
the caveats we had to be very careful
about is that multiple readers have
coming readers always win and end
writers of course there's one other
problem we have to be careful about and
that is there is something called a
reads there's a there's a right skew now
what is the right skew it is quite
possible that there are two transactions
running and both of them are dealing
with two sets of objects however one
object is reading a data and modifying
other one and this is reading this data
and modifying this other one this will
go back to your question also if that
becomes extremely important you can
handle that as well and and what you do
in this case is you say well how does
the right skew actually become a problem
this actually is a broken solution
because if i read this value and update
this and another transaction is reading
this value and updating this but in my
domain there's a requirement that the
value change is based on the value
collectively of these two objects let's
say for a minute i cannot transfer money
between two accounts unless there is a
combined the balance between the two
accounts now we are in deep trouble well
the way to ensure that an STM is you
come in to your code and say I'm not
going to have this in my change graph
because I'm not modifying this first
object but I want to make sure my comet
only happens if that object did not
change so you call a method call ensure
and you add the object or change graph
even though you didn't change
you know in indirect control and as a
result will make sure that you're not
going to be really changing this object
and hold a lock on it so potentially you
could come up with that but I would say
be very careful and implementing it
because the whole idea is really not to
limit concurrency in that regard so it's
a very interesting solution but like I
said we have to really be comfortable
with immutability at the object or the
state level and then deal with the
manage- double identity for this to be
effective so again a frequent reads
frequent rides and infrequent right
collisions is where this makes the most
sense if you're interested in
downloading the code examples you're
most welcome to download it from the
link at the bottom that's all I have
thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>