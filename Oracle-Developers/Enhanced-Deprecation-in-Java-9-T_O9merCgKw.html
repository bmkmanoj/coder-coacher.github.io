<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Enhanced Deprecation in Java 9 | Coder Coacher - Coaching Coders</title><meta content="Enhanced Deprecation in Java 9 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Enhanced Deprecation in Java 9</b></h2><h5 class="post__date">2016-09-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/T_O9merCgKw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello good afternoon welcome thanks for
coming to my talk my name is Stuart
marks I'm also known as dr. deprecated
er I work on the JDK core libraries team
at Oracle so the talk today is about
enhanced deprecation i'm going to give
brief history of the concept and and
history of deprecation but there's been
a lot of work on deprecation and I've
done I've done most of that work in jdk
9v there's a lot of work in progress and
most of that work is understanding how
notification and warnings occur and what
purpose they serve and the policies
around though so I'll speak spending
some time talking about the details of
that and then that's a little odd I'm
last bullets supposed to be future work
so there's a bunch of work going on in
jdk 9 and then there's there's some
future work beyond that so there is a
twitter hashtag for this talk enhanced
deprecation if you have follow-up
questions or comments please please
tweet with that hashtag alright so let's
step back a little bit and look at the
the systems development life cycle so
this is one of these one of these
diagrams with all these different phases
I pulled this off of Wikipedia it's
pretty conventional you start something
you develop it you you know it gets
reviewed it gets it gets goes through
iterations it gets put into productions
and so forth and then there's what
happens to the very end and they call
this phase disposition and extremely
little attention is paid to the end of a
systems lifecycle and that's what
deprecation is about and in Java we are
in the in the JDK group we are really
looking at the Java platform in the long
term and so we are starting to pay more
attention to the end of the life cycle
most of the talks you've probably been
to here at javaone or about something
new something is new and exciting and
different and that's great I think we
all love that stuff but something has to
be done with old stuff and so that's
what this talk is about
so let me talk about the life cycle of
an API as distinct from the life cycle
of a product perhaps many of you
familiar with the idea of a product you
you you put in it production it goes
through some support there bug fixes and
then over time the number of bug fixes
trails off and only critical or
showstopper bugs get fixed then maybe
only security holes of the of the
greatest urgency but at a certain point
then it's it's retired if you're
shipping a commercial software product
what happens is it goes through
end-of-life process like end of support
life after which there are fewer and
fewer bug fix releases after which
there's complete end of support it's not
supported anymore now the lifecycle of
an API is kind of different the same
thing sort of happens over time except
that it occurs in successive releases of
the Java platform and so if you look at
releases of the Java platform you know
JDK 1 2 3 4 5 and up we're working on JD
k9 now life the life cycle of an API
might get introduced at one point in a
jdk release live for several releases
and then be retired but the the jdk
itself and the java platform continue on
successive releases so it's really the
introduction of an api followed by its
life and support and perhaps bug fixes
and then the removal of the feature from
the java platform although the platform
itself continues on ok key concept of
deprecation is the designer and the
maintainer of the API communicating to
you the developers or the consumers of
the API information about what is going
on with that API and in particular when
the API is starting to reach the end of
its lifetime deprecation is a way for
the maintainer to say ok you should
start thinking differently about this
API and your usage of it and so one of
the one of the ways that you should take
action if you're using deprecated API is
is you should start considering
migrating away from it
there might be some several reasons why
we might why we might decide to ramp
down support or even eventually remove
ap is from from the JDK and one is
there's something wrong with it and so
if you're using that API you should you
should be notified of what's going on so
you should understand what's what's
wrong with it or what are the risks of
using it sometimes we've introduced a
new or better API and your programs will
run better faster higher quality more
lively or whatever using this new API
instead of this older one so that's
another form of notification and then
finally if we are intending to remove an
API from the JDK entirely then that's a
very serious step and that will actually
break programs and so there is an even
stronger form of notification that needs
to occur there because we don't want
people to be surprised by the program's
breaking all right so let's let's move
away from the basic concepts here and
talk about some some history so
deprecation was introduced in jdk 1.1
and there were no annotations at that
time annotations didn't come for several
years later and so the way this was
introduced was as a javadoc tag at
deprecated with a with a small initial d
now what's interesting is there's so
much oral history around this so so this
original deprecation work was was done
by John Rose who is now the JVM
architect and he may have seen talks
about him this conference or materials
by him he's doing project Valhalla and
project Panama now anyway so I was at
dinner with him last night and we were
talking about you know so how's your
talks going and I said oh I have a
deprecation talk and of course I knew he
I I've known him for several years he
says oh that's right yeah I remember he
says I remember putting the deprecation
stuff in he was he was the new guy in
Java at the time and the reason
deprecation was put in was james gosling
the orig
of Java had some misgivings about api's
that were in the platform and he was
worried wanted to do something about it
and so they came up with this idea okay
well if there's like if there's a
concern about this API then we need to
say something about it it should be
deprecated and that's that's where this
originated and so anyway so in 1.1 the
deprecation mechanism was introduced
this is Javadoc tag and then there was
an initial massive wave of defecation so
some some api's such as thread destroy
it's impossible to use thread destroy
safely now it's not not actually
implemented but the the intent was that
the that if that if a thread is running
that it be simply stopped in its tracks
no well anyway so it's impossible for
forget if it was ever implemented I
forget whether what it actually did but
it's impossible to use that safely and
so that that was mark deprecated and
then there was a long explanation which
I think John Rose wrote which was theirs
you can still find it in the Javadoc yr
destroy stop and suspend and resume
deprecated but then deprecation was used
for an entirely different reason so the
the guys who were working on the desktop
at the time was a TBT those desktop
api's they decided okay well we had and
we have a component class and you can
show a component and you can hide a
component but in order to make it
compatible with netbeans sorry not that
means javabeans in order to make it
compatible with javabeans the idea was
to set a property and so they said okay
instead of showing hide let's change
change those two setvisible true or
false and so they deprecated show and
hide now there's nothing at all wrong
with showing hi there was not dangerous
at all and in fact people who customize
components / road show and hide so those
those those methods ended up it was
impossible to remove him without
breaking compatibility so the problem
was that a lot of things in the JDK got
deprecated very quickly and it caused a
lot of disruption
and deprecation caused introduced
compiler warnings and so there was
massive concern because people
recompiled the program's got lots of
warnings and they said oh no what's
going on with that so we put the brakes
on everything so don't deprecated
anything else after that and there was
the the rate of deprecation slowed down
considerably and in fact nothing was
ever removed because of the initial
reaction of you know don't get rid of
all that stuff so that situation remain
consistent for a long time until Java
five now the some mechanics of
deprecation were changed in Java five
because the annotation mechanism was
introduced and so instead of having a
javadoc tag in a comment affect the
compilation of program which you think
about is a very strange thing an
annotation is a more formal way that's
part of the language that that allows
you to provide meta information about an
API and so from that standpoint oh ok
this is this is a way to to to provide
meta information about an API that says
it is deprecated so deprecation as an
annotation and since annotations are
classes they begin with a capital D so
we have the lowercase deprecated Javadoc
tag and the uppercase annotation so
those are both present and annotation is
is the formal way to declare an API
deprecated but there was actually no
clarification of this business about
well what's going to happen to these
deprecated api's are they going to be
removed how do we deal with these
compiler warnings and stuff there was a
suppress warnings annotation added as
well that allowed allowing programmers
to control compiler warnings so I want
to take a quick aside to share with you
some some deprecation trivia which at
least I find interesting there's a case
where something was under cated the
there's a method called system get end
which has a particularly tortured
history in in jdk
and in fact it did nothing except throw
and throw an exception unconditionally
and as Java doc said obsolete so it's
kind of interesting to have something
appear in one point oh and be documented
as obsolete and and my belief is I
haven't confirmed this but my belief is
that at the time the people who were
working on Java wanted wanted to make it
impossible to write a program that was
platform specific and the environment is
very OS specific but I think over the
years practical reality intervened and
by Java five an actual get end of
implementation which looked at the
respective platforms environment
variables and return them was introduced
and that method was actually under cated
and so it is now a fully supported part
of the API now Gannon was not introduced
as deprecated because deprecation did
not exist in one point oh so has
anything ever been introduced and
deprecated when it was introduced answer
yes so there's an mbean server in Java X
management that appeared initially in
java SE 5 and it was first deprecated in
java SE 5 so that's that's pretty
strange but but the reason for that is
that the the jmx stuff was a separate
jsr and so it had a separate standalone
set of api's through their evolution
process something's got deprecated and
then those were migrated into java SE as
of java SE 5 but it looks strange from
the java SE standpoint because something
was introduced and deprecated at the
same time all right so I wanted to go
back to what I was saying about this
confusion about what deprecation really
meant and I think that that existed that
existed for many years and up through
and including Java 8 I will still see
comments when people will say this on
internet forums and whatnot somebody
will say hey I use this and it I'm
getting this deprecation warning what
does this mean and there are two flavors
of ants I mean a bunch of answers of
course but they're two flavors of
answers somebody will say all that
deprecation stuff just ignore that it
doesn't make any difference they will
never remove anything but then other
people will say no no deprecation means
they're going to remove it so don't use
that
and and then people would argue about
what deprecation means and the problem
is that you know that you can't say
whether whether either of those
statements is right or wrong because we
as the maintainer of the platform never
clarified it and so that's my job so
that's what we're doing in Java nine
here in particular 11 I'd wanted to you
know finally we're getting to the point
where we're paying attention to this one
of the statements is made it has been
made is oh those guys that Sun and
Oracle have never removed anything from
the platform and they never will wrong
in Java 9 we're actually starting to
remove stuff and so all right all right
round of applause for removals okay that
I didn't expect that thank you so most
of the motivation for these removals
were to remove dependencies across
modules and so you probably heard a lot
of things about modularization and
project jigsaw and you can talk about
modules and interdependencies and stuff
and these ap is created new dependencies
between modules that we did not want to
have and I think Mark Ryan holder might
have actually mentioned that in the
keynote so anyway so these are the
things that were moved in Java 94 for
that purpose there were some other
errors we also corrected so in the awt
API there's a concept of peers and in
fact some of the types that those API is
used were in an API that was not
actually part of java SE so how can you
write a portable application if it has a
type that's not actually defined as part
of java SE so that's really a
long-standing error in the specification
because the specification is not is not
complete by itself it refers to
something outside of itself in in an
uncontrolled way so we we actually and
in fact peers we're never supposed to be
public API anyway so we also remove
those in Java nine all right so now
getting getting up to the present what
what's been done I think the
there's this relatively little software
engineering as part of deprecation it's
not like I wrote thousands of lines of
code for this I did write some code for
this but but relatively not that much
the major work here is the clarification
of semantics and what does deprecation
mean and and most importantly I think
what should developers do if they find
that they are using deprecated API and
so that's where most of the work is
there are some enhancements to the
deprecated annotation itself there are
two they're kind of like parameters
they're formally called elements but
there's a since element which is a
string value which which which records
the release in which the in which that
API became deprecated but more important
i think is this new boolean element for
removal and what that says is if it's
actually cover that on the next slide
okay so so there are some enhancements
to the deprecated annotation I'll get to
those more detail later we're also
introducing a new static analysis tool
called JD purse can I will cover what
that does somewhat later and then there
are some adjustments to the Java
language specification Java C and Java
doc in order to in order to refine their
treatment of the deprecated annotation
all right so here's what here's the
details on on the new deprecation
elements and so I think for removal
really is the main the most important
thing I mean it's all it is as a boolean
but it's it's amazing how much
discussion took place in the background
and all that got added was a boolean but
it's very important because that
discussion improved everybody's
understanding of what deprecation was
but basically that that that that
hypothetical art well not hypothetical
but the kind of prototypical argument I
was talking about they're never going to
remove anything what does deprecation
mean should I be worried about about
removing it or should I be worried that
that I'm using
deprecated API will it be removed or not
that's what this says so if for removal
is true then this means that whoever is
maintaining this API is saying yes this
is going to be removed it doesn't say
when it's going to be removed but in the
JDK what we're trying to say is if
something is deprecated for removal in
this release then it will be removed
from the next release so that's what
we're trying to say so we give one
release warning before we remove
something I'm I'm sorry what was oh yes
major releases yes so okay thank you
yeah so if something is deprecated for
removal in this release the it will be
removed in the next major release or
than in in the JDK at least major
releases are the only releases where we
actually make specification changes okay
and so so adding a deprecation is a
specification change and of course
removing an API is also a specification
change ok so for removal false well what
you know why is something deprecated if
you're not going to remove it well there
are lots of things where it's not
necessary to remove them but still there
are it's still useful for people to know
that that this API has something wrong
with it or there's there's something
else to be used and so in fact there are
many more deprecation 'he's with for
removal false then there are four with
for removal true and so there's some old
AP is that you're better off using
something else but we're leaving them in
the platform just because we don't want
to break people's code and so so there's
a little bit of clumsiness hear about
the wording and so we've cooked up some
some terminology here if something is
deprecated with for removal false that's
an ordinary deprecation but if for
removal is true we're calling that a
terminal deprecation because it implies
you know something is something is going
to end so it makes it a little easier to
talk about it
so basically if something is deprecated
for removal false that is if it has an
ordinary deprecation that means there's
no current intent to remove it doesn't
mean it's going to stay forever but if
we do decide to to remove it in the
future then the the for removal will be
upgraded from false it's true go ahead
question ah yes the default value is
false so all pre-existing deprecation
are by default for removal false their
ordinary deprecation so what we've done
is we've taken I what I did is I went
through all of the old deprecated not
all of the old I went through many of
the old deprecated api's and re-examined
them and said okay these are the ones we
really are going to remove and then I
left old deprecated API is that we have
no intent to remove I left those as
false okay so and then I also mentioned
since having a string value which is the
release in which something became
deprecated i think i want to take I'll
take questions at the end thank you and
mostly this is informational there's no
as far as I know there's no no semantics
attached to what string gets foot there
but it's useful to see when something
was deprecated now quick quick aside any
some of you might have seen previous
proposals of about deprecation where
there was a there was a reason tag and
new value in particular the one that
attracted the most attention was
condemned there were also other values
superseded obsolete dangerous and so
forth and so that was an earlier version
of the of the proposal and it turned out
that having a reason code there is nice
it generated a lot of discussion I think
the semantics were were good but they
were not really well defined so it
didn't make sense for there to be a
specific reason in in the API saying why
this is deprecated or what would happen
to it so in fact the problem was we knew
we wanted to deprecate something we we
actually spent some time trying to
assign a reason code
and it was basically impossible so maybe
that told us there's something wrong
with the API so really condemned is the
only one that is strictly actionable it
has a clear semantic meaning so we just
converted that into so condemned got
converted into the for removal boolean
and then the rest of those concepts are
valid concepts they're simply not in the
API and we're saying well if you have
something that is dangerous then instead
of marking it as dangerous and having
people saying well what does that mean
that belongs in the documentation if
something is dangerous or risky then as
the API designer you or we I mean we're
designing a lot of the api's but anybody
who uses the deprecated annotation and
you know there's a there might be a risk
associated with this API because it
might give the wrong answer in some
cases or or something like that so that
shouldn't that's really that's really
part of the documentation as opposed to
something that belongs in the annotation
all right so what if we what have we
done in Java nine so far so these are
ordinary deprecation for removal false
the boxed primitive constructors new
integer new boolean new short new new
double new floated Sarah all of those
have been deprecated in most cases those
can simply be replaced by the
corresponding value of method
particularly for things like boolean
there are only two boolean value box
boolean values and so there's never a
reason to to create a new instance of a
boolean but people do things like that
in order to in order to lock on it or
something like that it's like really bad
idea we did have one case in the JDK
that used a boolean field as a tri-state
no true and false so I think we got rid
of that too so there's a long story with
Java applet if you've been following
applets in the browser plug-in those
have been on their way out for a very
long time but it turns out that this is
a very slow evolution and so many so so
people are I think are not surprised
that applets are being deprecated but
what they are surprised by is applets
are
marked for removal and I had a
discussion with the the desktop team
about this it's like what what you know
what should the deprecation be are you
intending to move it they also know yeah
we're going to get rid of it okay right
I said okay you're going to get rid of
in the next release um well maybe
actually there are other people oh we
have this customer who's still using
their they going to get up so there's a
bunch of hemming and hawing about it
right and so you know a minute and then
they started you got uncomfortable yeah
I don't think we can move it remove it
the next release so that's the kind of
thing that goes on so so the fact is
applets are on their way out but they're
still around because they still get used
so applets are being deprecated but with
for removal false there's an there's a
vestige of a very old event observation
model in Java util observer and
observable I don't know if anybody uses
these there turns out was it I forget
never mind i did actually hear of some
some some use of these because he
created a bunch of compiler warnings
when this became deprecated but really
these these are there much better
alternatives to using observer and
observable in fact when when i mentioned
this the people you know people that
most people have never heard of these
all right what things are we deprecating
for removal so so now for these things
in java nine they are still going to be
there that are going to be annotated
with at deprecated for removal equals
true which means the plan is in java 10
that these will be gone okay so thread
destroy that's that's that's going away
now there is there are two overloads of
thread dot stop one of them takes a
throwable argument that that causes that
causes the thread to be stopped in its
tracks and a throw to throw the
throwable of the caller's choosing and
in fact that was actually disabled in
Java 8 so that does not work anymore and
so we actually have not heard any
complaints about that so far as i know
so we're going to get rid of that now
the
the thread dot stop overload with no
argument is still deprecated but we are
not going to remove that so that stays
there so there's an interesting story
with this this this other method here
system dot run finalize errs on exit and
so somebody who you know I don't know if
you if you're familiar with finalization
and all that was something that's a that
that's that's been a facility in the
platform for for many years somebody
thought it would be a good idea so that
to have a flag that said when the system
is exiting well we want to do some
cleanup so run all the finalizer
unconditionally unfortunately this means
that finalize errs will get run on live
objects and if a live object has some
native resources associated with it then
quite rightly that finalizar will say oh
okay i can free those native resources
unfortunately there's no control over
the ordering of finalizer calls and so
something else some other finalizer
might say might call back into that that
first class that had a native resource
which has already been freed and so it
makes a native call finds that something
has been freed and causes the vm to
crash and so I think when is the yes in
1999 people discovered this and so there
was a conformance failure because the
system crashes when we call this we have
we have a test program that will crash
the JVM every single time how do we fix
this well the only way to fix it is to
get rid of it so well finally going to
fix this bug by removing the API and in
fact the semantics of run finalized errs
on exit are simply incorrect because the
finalizer should only be run on an
object that is unreachable but this says
oh by the way we're going to run
finalizer zon live object so anyway so
that's that's leaving and then finally
there are a whole pile of methods on
security manager that are going to be
removed those are vestiges of the pre
1.2 security model and so in jdk 1.2 the
permissions based security model came in
but there are all these old check
permissions stuff left on security
manager and we are finally getting rid
of those
alright so I wanted to spend some time
on notifications and warnings because we
there's actually a considerable amount
of subtle issues that that come up here
but as I said in the beginning the main
purpose of deprecation is to communicate
is to provide communication between the
maintainer zuv the API and the consumers
of the API and if they're changes in
status of something then the the users
of the API developers need to be
informed of this so you know if their
problems with the API or if it's going
to go away but but that's that's the
general point here is how to communicate
these information through the API so one
of the problems is we say okay well
write some words in the specification
that says oh there's a problem with this
and therefore we're going to take it
away well I shouldn't say nobody reads
the documentation but there's a large
class of people who who don't read the
documentation but the fact is if some
some note like that is buried in the
documentation you know I know what that
method does all right I don't need to
read the documentation last year I don't
I don't you know I'm not going to it's
unreasonable to expect developers to go
through with fine-tooth comb and say oh
this clause was added here that says
this you know this this method is is
going to be deprecated so we need some
some some stronger more reliable form of
communicating this information to
developers so there's several different
ways of doing this and so the first is
compile time notification this is the
one that we should be familiar with
already if you if you write a program
that uses a deprecated API then the
compiler will issue warning about that
and there are various there are some
wrinkles here about the severity the
morning whether it's on or off by
default and also how to suppress
warnings that you that you know that you
are aware of but that you do not want to
deal with right now but then there are
also two new kinds of notification that
we're working on static analysis is
useful because the fact is you get the
compiler warnings only when you
recompile everything and in fact we we
don't expect people to recompile
the point is the point one of the big
points of Java is binary compatibility
you can take your old binaries and
continue to run them and so this is the
biggest hole in notification and
deprecation because thus far the only
kind of notification is compile time
warnings so if you have an old binary
that is using a deprecated API you never
hear about it unless unless you unless
there's some alternative path so so
we're introducing a static analysis tool
which I'll provide some more details on
later to help with that and then another
idea which is not implemented at this
time is to track usage of deprecated
api's at runtime and then provide
runtime warnings when one of those is
actually called and so for instance you
might have a binary that references a
deprecated API but in fact it might be
in dead code so if it never calls it who
cares but so on the other hand you might
have something that calls that calls an
api reflectively and that will be missed
by static analysis but that could be
potentially picked up by dynamic
analysis so dynamic analysis is feature
work that's not going to be in Java 9
all right quick example of a compiler
warning if you use the deprecated API
the first thing you get if you don't
provide any options other than the
default is a note it says you can read
it there recompile with- excellent
deprecation for further details and so
if you do recompile with- excellent
deprecation that enables detailed
warnings and you get a listing of exact
the exact line in position where the
deprecated API was used all right I
think I explained this already but the
problem is that if you have an old
binary you just use it you don't
recompile it so this old binary might
have uses of deprecated api's in it and
you might like to know that especially
if those deprecated api's are going to
be removed and so if you just keep using
that old binary and then you move on to
the next JDK release something might
have been deprecated deprecated for
removal and then and then finally
removed if you if you run that old
binary it'll simply break and you might
why no such method error well what
happened and then you might have to do
some some you might have to do some
research or investigation and stuff and
so I think that's a that's a nasty
surprise we want to we want to get
information about that out to developers
more in advance of that instead of
having people try things out and then
uncover uncover problems like that when
errors occur in particular it seems like
the the way the ecosystem is evolving is
if i have an application i might go i
might use maven and it pulls down a
bunch of dependent libraries so not only
as as if I were an application developer
I have to be concerned about what my
application is using but also the
dependent libraries and they're
dependent libraries as well and so if
those use deprecated AP is then I'm
going to want to know about that because
either I can get those guys to fix make
fixes upstream or I can remove my
dependencies on those libraries so the
point of this is so that developers can
better manage what's going on with their
dependent libraries without having to
recompile actually this is this is far
too much detail I just went through this
in in a sketch here but but suppose I
have some old class so so that the
central issue here is what happens to
programs as they evolve and as API
you've api's evolve so suppose I have an
application and I compile it against one
release of the JDK and it uses some
api's and everything works fine there
are no warnings now in the next Java
release something I use gets deprecated
but if I don't recompile I never find
out about that and then in the following
JDK release it changes to a terminal
deprecation deprecated for removal true
and I'm if I'm still running the old
binary I never hear about that and so
what I so when I upgrade to the to the
subsequent JDK release after that thing
actually is removed and I run my
application and it says no class def
found error or no such method error or
something like that so that's really an
unpleasant surprise that we're trying to
avoid here all right so i talked about
static analysis there's a tool called j
pepper scan which I developed which is
introduced in jdk 9 and it is also
available in any of the i have a link at
the end with the link to the early
access builds so you can try it out
alright so here's a sample program that
it doesn't do anything interesting all
it does is use ap is that were
deprecated in various jdk releases and
so this list jlist get selected values
was okay so none of these were
deprecated all of these api's existed in
java 6 and earlier and and none of them
were deprecated in java 6 in java 7
jlist get selected values is deprecated
in java 8 the rmi security manager was
deprecated and in java 9 as i mentioned
earlier the boolean constructor was
deprecated so what's the the interesting
point about this example is that
different api's were different were
deprecated different points in time
where what time being measured by JDK
releases so if I took this sample
program and compiled it using jdk six i
would get a class file that has
references to these methods but of
course i compiled that on jdk six and it
compiles great all those api's exist and
there are no warnings because none of
them are deprecated in in jdk six so how
do we find out about that so if i take
jada per scan from a recent jdk nine
build then it tells me Oh class example
deprecation uses type java on my
security manager which is deprecated and
so it runs through the class file does
some analysis and finds out what what ap
is that are deprecated are being
referenced from this class file and
emits messages from that so further
feature of JD per scan is that it can
analyze a binary relative to a
particular JDK release so i can add the
minus minus release option so i minus
minus release 9 that's the default since
it's being introduced in nine so that
gives the same output
but if I say Jade deeper scan minus
minus release eight then it only
analyzes that binary for AP is that were
deprecated in Java 8 and earlier and so
if you notice the difference between
these is that the boolean constructor is
not flagged in the minus release eight
output and in fact we can do this for
not only for really in JD Kane this is a
new feature in jdk nine that it has
information about AP is that existed in
the three prior releases so we can all
we can go all the way back eight seven
and six and we can say essentially we're
asking the question what deprecated AP
is does this binary use relative to jdk
version n and so we can say minus
release seven and in fact if you go all
the way to minors released six none of
these api's were deprecated in six and
so there's no output and so the new
feature here is that the this
information is built into the jdk and
you don't have to carry around old
versions of the GDK in order to do this
yeah quick question here okay so the
question was about the policy of
carrying three versions back so no this
this tool is really built on the same
compiler tool chain and so this follows
the same policy so in jdk 10 the three
back will be nine eight and seven and so
by the time jdk 10 comes around what
we're trying to mean so here here's the
end of life process I think we're saying
okay jdk six in the jdk ten time frame
we don't it we don't expect most people
to be migrating to jdk six at this point
so the point of carrying this old
information around is when jdk 10 comes
out people will still be migrating from
older releases but they won't
necessarily migrate to the very late
just one so when ten is out you might
want to use the latest tool chains but
you might be migrating to eight or nine
and so that's why we keep that
information around for use but but when
something is so old we're just dropping
things off the tail end now I think
we're just we're kind of moving things
through on a per release basis all right
so one of the things there's another
there's another wrinkle here which which
we actually discovered well fairly
recently in this which is there's kind
of a new state transition in the API
evolution so the big state transition
that has been around for a while is from
not deprecated to deprecated but there's
a potential potential additional issue
which is from an ordinary deprecation to
a terminal deprecation and that's when
for removal changes from false to true
and so the problem the problem is with
with an interaction with suppressed
warnings and so I have a scenario of
this on the next slide here okay so
suppose I have suppose this is this is
relative to compiler warnings so suppose
I have an application and it compiles
fine no warnings it uses some AP is that
are not deprecated now in some in the
next JDK release an API becomes
deprecated all right I recompile it and
I get a deprecation warning and I'm very
conscientious so I say okay I am going
to add a suppress warnings annotation to
suppress that to suppress that warning
because i i'm using a deprecated API but
it's not marked for removal but I I want
to continue using it so I so add
suppress warnings there then in the next
JDK release the deprecation is upgraded
to for removal equals true so that means
this API is going to be removed but when
I recompile I already have a suppressed
warnings there so I don't get any
warning when that happens and then when
I recompile on the following JDK release
when the thing is gone it says symbol
not found alright so that's a nasty
surprise because our notification system
has failed us
so this is this is actually work in
progress now this is not integrated in
its jdk nine yet but if you look at the
suppress warnings annotation there's
actually a tag there you can put and so
it's basically a string so right now the
way to suppress deprecation warnings is
at suppress warnings deprecation so what
we're saying is if you're using a
deprecated api with for removal equals
true that is if you are using a
terminally deprecated API that's going
to fall into a different category
warnings and we're calling those removal
warnings so so that means that if you've
already suppress the warning for
ordinary deprecation if that thing
becomes terminally deprecated you're
going to get a warning anyway even
though there's a suppressed warnings
already there and we want that to happen
because since it if it didn't happen you
missed that notification so if you if
you are using something that is
terminally deprecated and you still want
to continue using it at your own risk
because it is going to be removed then
you can suppress that warning using
suppressed warnings removal so that's
that's in progress unfortunately that's
not that's not in the current EA builds
yet but we're working on it also I think
I think it's going to turn out this way
if you you remember earlier on I said if
you use the deprecated API you just got
a note and you had to say excellent
excellent deprecation to enable the
details if you use a terminally
deprecated api you're going to get the
detailed warnings by default instead of
having to go through a second pass and
reenable them so what we're trying to do
is to have a stronger warning for things
that are deprecated for removal because
that's a much more that's much more
serious situation because we really do
intend to remove those all right this is
a this is a little bit of this is a
little bit of old old cleanup work
remember i said earlier on that that the
original deprecation was a javadoc tag
but annotations didn't
just until Java five so how was it
recorded in the class file all the way
back in 1.1 thru 1.4 how was it where
was it recorded that something was
deprecated so so the way annotations
work is when they're compiled they
actually end up in the class file and so
today deprecated api's have a deprecated
annotation that actually ends up in the
class file and the compilers look the
filers and ID's look for that annotation
and may issue warnings when they
discover uses but before annotation is
this that before annotations existed
where was that information recorded well
it turns out if you look in the if you
look in the JVM specification there's
something called the deprecated
attribute that's different from the
deprecated javadoc tag and that's
different from the deprecated annotation
and so that's this little thing in there
in fact it has no information it is
essentially a boolean that says this API
is deprecated and so that is still
around because that's how the original
deprecation mechanism worked all dating
all the way back to 1.1 all right so
here we are Java 5 introduced
annotations annotations are now the
preferred way of marking something
deprecated so what are we going to do
with the deprecated class file attribute
I think we're going to deprecate it so
so this is this is the long term
evolution here I am there's actually no
way to deprecate things from a class
file I think so might be one of these
things where in the next version of the
the JVM class file format it will
actually be removed from the
specification and the semantics of class
file attributes are if you are
processing a class file then you ignore
attributes that that you know nothing
about and so I think we haven't worked
this out entirely and it's probably not
going to occur in jdk 9 so in a future
jdk release their will i suspect we
might end up with a situation where a
future class file version will no longer
have the deprecated attribute in it and
so the deprecation information will
reside solely in annotations
alright so future work I mentioned
earlier that one of the things we want
to do going forward is to develop
runtime analysis tool I think the main
thing there is that there's a lot of
things out there that that do reflective
access to things and those will be
missed by the static analyzer there are
a fair number of AP is in the queue to
be deprecated in particular legacy
collections like vector hash table and
enumeration optional dot get that that
caused a lot of consternation when I
proposed that I believe there are some
issues with that it's actually quite
error-prone in fact I did a survey of
JDK code and found that most uses of
optional get were better rewritten to
avoid using it there's some old things
like timer and timer task which has been
superseded by threats scheduled
threadpool executor it's kind of a
mouthful and then Dayton calendar are
now obsolete because we have the new
Java time API is introduced in eight so
it's time to time to step up the
deprecation for date and calendar one of
the problems though is actually no I
talked about warnings on the next slide
so sorry current work java korba module
and there's a question mark here because
it hasn't happened yet we do we we feel
like we want to deprecate korba and but
it is a fairly recent change to jig saw
in that the module info Java syntax up
until fairly recently has not supported
annotations and so what do you do if you
want to deprecate a module and so the
jigsaw team has been working on some
stuff and they recently have decided to
make a syntactic change to allow
annotations on a module declaration in
module info Java for the express purpose
of using the deprecated annotation so
that made me very happy all right so one
of the stumbling blocks with deprecating
all those api's is that they in fact are
in widespread use and then adding
deprecation 'he's will create compiler
warnings
and that's actually a problem for the
JDK itself because there are lots of
uses of things like vector in the JDK
and so we would have to do a lot more
warnings clean up if we deprecated
vector so on the one hand yeah we want
to deprecate the old stuff and and you
know mark it as old and obsolete at the
same time it's going to create lots and
lots of work for us because we have lots
of warnings cleanup to do so and then a
lot of people on the open JDK mailing
lists complained about this as well and
rightfully so because you know they
don't like nobody likes it when somebody
else creates work for them and so but
what I take away from this is that we
need to provide better mechanisms for
managing warnings so there's a variety
of things like suppress warnings minus
excellent options and so forth that can
help with this but they're not powerful
enough so we have some ideas of maybe
doing API specific warnings management
or something like that that's all it's
all just ideas nothing implemented that
yet all right so the conclusion here is
that oh there's a JEP for deprecation
Jeff is JDK enhancement proposal so Jeff
277 is almost completed basically it
consists of upgraded the upgrade to the
deprecated annotation itself new
depredations for AP is and then the JD
per scan tool so we're slowly cleaning
up the API in the JDK and we're also in
progress is is this new warnings
category suppress warnings removal there
a couple links there for a link to the
JEP and the recent JDK nine builds all
of these have the J diaper scan tool in
them so I encourage you to go download
it and try it out so i'm on twitter i
have a couple twitter handles here i am
dr. deprecated ur on Twitter and my real
name is Stuart marks so you can talk to
me talk to me directly that way so thank
you and I we have a few minutes left for
questions there's a question right here
this gentleman
oh thank you hmm yes okay so the
question was about third-party libraries
excellent question i actually forgot i
was intending to put put something like
this in my presentation but i forgot
about it so so right now the deprecation
stuff is kind of JDK centric which is
maybe what you're what you're thinking
about so in so any third-party library
can use the deprecated annotation but
the scanner tool only supports scanning
for jdk AP is and so what I envision is
to have a more complex mode where the
tool can gather deprecation information
from this library and then with that
information analyze this binary here for
uses of an api of deprecated api's from
that library so yes I mean that's in the
plan but thats future work at this point
question right here so
standard
will it perform that this library is
using that because of deprecation
okay good question question was if
something if an API has been removed
does the scanner tool does the scanner
tool report that because that thing is
is simply gone from the API now and
that's a good question i'll have to
think some more about that case because
i actually have not considered that case
very well because I are you know we
don't have a track record of having
removed stuff so we don't have an
experience of how to cope with something
that's already been removed so good
question okay okay right okay all right
okay so so there's there's there's some
I have a partial answer here which is so
the release option for JD per scan reads
the internal tables from the compiler
toolchain where which which has recorded
all passed well not all the three
releases of past API information so the
way I envisioned J depre scan working
for third-party libraries is certainly
we're not going to ship those in the JDK
right we're not going to maintain
information about past deprecation for
third-party libraries but one of the
modes in fact it sort of there's a
there's a vestige in there right now for
experimental purposes is to scan a
library and record the deprecation
information and so if if your developer
who's using a third-party library then
you can scan that library and simply
record its deprecated information so if
you have multiple versions of that
library you can record separate
databases for that and then when you
want to do analysis you can say well I
want to use I want to use version 3 4
here to see to see what was deprecated
in version 3 vs version 4 version 5
whatever whatever versions that you
recorded from the third party library
now actually this is very interesting
you
you if you've done some thinking about
this I'd like to talk to you afterwards
to see whether that that works or
whether there's an alternative approach
necessary or something like that so
let's move on
so so that the the tool output right now
is I think you must have read the
documentation or something because
because because they thought there is a
line in there which I wrote which said
the the output is for informational
purposes only but what I was referring
to before is kind of this experimental
API or experimental function where it
would the the scan results would be
recorded in some well-defined format
that could be kept around and I think
the idea is that that instead of being
for informational purposes that be kept
in in a a format that is machine
readable and possible so the deprecation
information from some old library can be
kept around indefinitely now if in that
old library you deprecated something for
removal true then I think you need some
kind of project management workflow or
something so that when the next release
comes around you're going to have to say
okay look in that list of things that we
said where we set for removal true and
make sure actually to remove them and so
so so it's not all there yet this is
like the first release of the tool but
in principle yes it should be possible
to to record that information and then
enable a future version of yourself or
your successor to look at that and say
okay these are the things that we now
need to remove because they were
deprecated okay I think this gentleman
has been waiting for long
to force a good program practice what do
you think the effects are good program
practice will be now that there's really
ah so so the question was initially that
that that the ambiguity is good because
it helped further better programming
practices and I I I don't know I mean I
I don't like ambiguity but then since
this is since this is really this is
this is really sort of bridging over
into kind of a non technical aspect
where I mean this is this is maintenance
this is life cycle stuff this is not you
know there's a bug in this program or
there is not a bug in this program so so
it's hard to boil that down to a binary
at the same time it's harder to come up
with a finer gradation or something like
that that's still useful so what effect
is this going to have on on engineering
best practices I don't know my hope is
that it will improve things I think that
my my view is that the ambiguity was was
was damaging because you know like I go
back to this conversation on some
internet forum where people are saying
uh deprecation doesn't mean anything
they'll never remove anything somebody
else's well then they might they might
remove it what if they do right and and
so so I think uncertainty is is doing
some damage there and so so I think by
clarifying this I mean even even though
it's only one boolean but by adding this
literally bit of clarification then that
will that will remove some of these you
know you know how internet arguments
good you can never win an internet
argument they just go on until they
until they decide not to and so I'm
hoping that this will that this will
will will take a certain subset of those
internet arguments and and say this is
the answer it's going to be removed and
then there's going to be a different
argument about well when is it going to
be removed okay I that gentleman back
there
yeah question about whether the text of
the warnings will be different whether
something is for removal true or false
we're working on that yeah I think what
we need to do is make sure that that it
is absolutely clear that if you use a
deprecated API whether it's ordinary or
terminal deprecation that the the text
of the of the output that you get makes
it absolutely clear what you know what
the disposition of that thing is and so
yeah so that's that's something we need
to work on I still need to I have a I
have a bug I need to fix which is
basically you know take a relook at the
Jade a purse can output and make sure
that make sure those messages are right
and i'm working with a compiler team to
make sure that their warnings are
appropriate as well so I think I'm out
of time at this point so thank you for
your interest and attention and I'll be
hanging around a little bit so there are
few more questions all right thanks very
much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>