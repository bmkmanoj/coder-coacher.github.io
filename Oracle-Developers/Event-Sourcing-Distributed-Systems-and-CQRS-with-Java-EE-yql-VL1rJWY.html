<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Event Sourcing, Distributed Systems, and CQRS with Java EE | Coder Coacher - Coaching Coders</title><meta content="Event Sourcing, Distributed Systems, and CQRS with Java EE - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Event Sourcing, Distributed Systems, and CQRS with Java EE</b></h2><h5 class="post__date">2017-10-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/yql-VL1rJWY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right so hi and welcome to my
session my buzzword draft
driven session about CQRS yeah I'm very
happy to be here to be back Java one who
of you has been to Java one before okay
so and who is here for the first time
cool it's awesome yeah so I hope he will
enjoy the conference you will have very
interesting days I always love it to
come back to to San Francisco and to
Java one I just barely arrived because
I'm not busy with a lot of other stuff
besides that so I didn't even have the
chance to enjoy the conference yet by
the way if you have a plan to write a
book I advise you not to do it okay so
yeah hi my name is Sebastian Sebastian -
nah I'm from Germany
I'm from Munich the Oktoberfest City you
know so that's why I'm here I escaped
and went to attend jail one and yeah I'm
Java guy Java consultant trainer
whatever you call it I'm self-employed
and involved with a lot of java ee stuff
so speaking of conferences like this I'm
participating in a JCP helping you to
form the standards in Java EE and you
know a lot of other Java titles involved
so a lot of Java stuff all right
- this password driven session about
CQRS who of you has heard the term
secure as before or even used it okay
okay quite quite a few that's that's
interesting yeah so first of all before
I can show you some code I you know
normally I would love to do live coding
for you and basically live code
everything if you have some seen some
sessions for me in the past but with
this principle I would say it actually
makes sense to talk about the
motivations and well the the theory
first fear before showing you because
I've seen that CQRS is not that common
for enterprise developer ISM and quite
new so basically I will show you the
motivations and what's behind it first
right so
cqs goes back to the way how we build
enterprise systems right so typically
you have an enterprise system and you
have some kind of relate in a relational
database so that means you're storing
your model in a so-called crud based way
right create read update delete that
means you have a current state in your
system write one state and you store
that in your database and once something
happens to your system something is
changed some use Kayson is involved then
you have a new state right and the old
state is first of all forgotten right
and well that's it so far but that comes
certainly with some shortcomings that
approach so first of all in a crop based
way you don't have the reproducibility
right once you change something in your
system and you have a new state in the
system the old state is forgotten and
you lose the tol total history and
context information how you got to that
state right
you can't reproduce how you got there
and also because you're managing this
state in your system you somehow have to
deal with the fact that we are in an
enterprise system and you can change
that state or concurrently from several
points simultaneously right so therefore
you have to somehow deal with that issue
you have to somehow deal with these
competing transactions and that is
basically introducing synchronization
and that is the point
while the crud based model ultimately
won't scale right because you have to
have this synchronization and why well
this is because of the so called cap
theorem and consistency availability
partition tolerance which basically says
you will either scale or you will be
fully consistent all the time but not
both choose one right and a crop based
model and well chooses to be consistent
however now I will talk about two
motivations two different motivations
and aspects that ultimately lead to this
cqs buzzword right and first one is
event sourcing and the second one is
event driven architect
first of all event sourcing who of you
has built an event source system in the
past only really ok because well the ID
system are quite common at least or not
that unfamiliar what are events or
systems well in the events or system you
don't store the current state as you
would do in a crowd based way rather
than you derive occurrence the current
state of the system from atomic events
right prime example are bank accounts
with money transactions right you have a
bank account if you want to have your
current balance of so many dollars well
you take all the transactions plus $100
and minus and so on and so forth you
start from zero and you calculate plus
minus until you end right now at the
current point in time with the current
balance right and that is in the event
source system run example for it so you
have these atomic immediate events anti
derive and calculate the current state
based of it well what does give you now
for free you have the full context and
history information right you have
everything that happens to your system
as part of your system if you want to
somehow reproduce or comprehend why your
system is in its current state well you
just look at all these events since they
are part of your system and you have all
that information if you want to say if
you want to know why I have seven
hundred thirty seven dollars on your
bank account well you look at the last
transactions right and yeah that also
gives you quite nice use cases and
interesting stories to to work with for
example you can do statistics with all
these events you have everything that
happens to your system there you can use
these events for testing if you want to
have some test data for for example end
to end tests well just go to your
production system and take all these
events and then you have all the use
cases what happened to your events and
you can use them for further testing
right and you can also do something
which I would call future proof use
cases so what is that
imagine your manager comes to you well
two years after year system has been
running in production and because
managers tend to do these things asks
you well by the way that system how many
users did sign up on today's Monday on a
Monday and then you say I don't know
fair enough there was never any
requirement we don't have that
information right well you need events
for system you do have this information
because you have you storing everything
that happened to your system in an
atomic way and then you can later on
just go and take all these users signed
up events and just do some calculations
and statistics how many users that sign
up on a Monday and then you have that
information right later on although you
didn't knew it's two years upfront so
that's also quite quite a benefit yes
yes so the question was would I store
all the events forever and good question
yes first of all you would then of
course everybody comes oh that's a lot
of tighter and everything well actually
you could as you said you should ask
yourself how much data that actually is
because a lot of companies who claim we
do big data no you don't and for example
Apache Kefka what I will show later on
can store terabytes of data and and so
on and so forth so sure that will be in
concern and you just have to calculate
how much data you're actually storing
and processing but to answer your
question yes you would store everything
and just keep it because that enables
you to do so any other questions I
forgot to mention questions are good so
the more you ask the more I can tell you
just feel free to interrupt me anytime
and
yep
right um how about having two data
sources in peril well that would be a
problem right because then you would
have to do transactions and distributed
transactions and so on so forth and that
doesn't scale right but how do you put
the data in yeah
yes this would be possible and it
basically goes back to we have this
later on too but basically building your
own events tour whether this we will see
this in a second but yeah you could do
so so you
that means you've basically taken
relational database and store your
events there as this and yes you can do
so definitely it's a very good point and
now well first of all let me let me tell
your story
so that's event sourcing that's well
understood and actually the system have
been there in the past because you don't
have to care about seeker s you don't
have to care about the event of an
architecture so if you don't have to you
can just use event sourcing and build
these system asses but now for the
second principle that leads to CQRS that
goes back to this scalability point
right and being able to scale and being
consistent or not and what that means
first of all let me tell you a story
about the real world that we try to
escape as developers and why the real
wood is not consistent what you would
assume in most of the cases and since
we're building enterprise systems
ultimately for real-world use cases
that's quite an important aspect to
think about for example you go to a
restaurant and you're hungry you want to
order a meal right so you go to what's
famous in San Francisco like Cheesecake
Factory or something like that
ok you go to the Cheesecake Factory and
said I was there once and that's a funny
story and it was way too sweet that and
having that said I normally don't eat
the cakes and sweet stuff yeah that was
an experience anyway you go to the
Cheesecake Factory and say I wouldn't
like to have
I ate fried mac and cheese I would like
to have fried mac and cheese please
you order at the waiter right you sit
down the way it comes out to your table
you tell them that and they say yes sure
and accept your order right now you
would assume that is a consistent
transaction but it's not because a lot
of things can go wrong
before you get your
can cheese right for example the way
that goes to to the kitchen or however
that looks like in the Cheesecake
Factory I have no clue and asked for
that mac and cheese and then the chef
says nope sorry we ran out of macaroni
whatever of cheese it's not possible to
process that to deliver that order and
then even though the way to accept your
order they have to come back and tell
you I know I just accepted your order
but sorry that's not possible and then
what happens exception right you angrily
walk out of the restaurant or the waiter
says well it's such a nice day and we
have I don't know 50 cheesecakes and
in stock would you like to have
something else right and does some kind
of compensating transaction right and
that's what happens and that's what
happens in in the real world so this is
actually how we have an eventual
consistent real word in a lot of cases
and we don't have real consistent use
cases so what that means in the real
world here we have to talk to each other
right we have to collaborate in some
kind of sort so when you know the mac
and cheese is not in stock then we have
to talk you have to talk to the waiter
what else is there or what else you
would like to have and so on so forth
and the waiter is also constantly
trusting on outdated information right
because the mac and cheese is not in
stock right now but later the delivery
truck comes and so on and so forth so
you constantly have to deal with all and
with all these issues so you basically
have to collaborate and well have to
think of compensating use cases if
something goes wrong so hard I would put
it the real world is all about
collaboration you have to talk to each
other good hopefully good intentions
because that's what it is when you want
to order a meal that's first of all in
intention to do so and then eventually
dealing with these issues right and well
we have to do this otherwise it would
not work so for example in other words
how would a consistent fully consistent
restaurant
look like right a fully consistent
restaurant would be like you sit down
you ask for fried mac and cheese and
then the waiter says ok shouts everybody
stop everybody freezes yes I will ask
stop stop
goes to the holds the conversation
you're not allowed to go to the toilet
holds the conversation goes to the
kitchen ask for the fried mac and cheese
the chef says yes I can do this prepares
it waiter waits everybody waits then
finally the fried mac and cheese is done
the waiter comes back to you yes it's
popular it possible to do that dish here
is it that will be accompanied
consistent restaurant right and you
could imagine this would not scale so
that's why we are eventually consistent
yeah this at this point and this is also
then how event-driven architectures work
so first of all we have to have several
systems involved and it's quite
important because well if we if you're
not having a distributed system well
then don't do seeker s you can go home
and just do relational databases because
then we don't need all this right so
this is really about being distributed
and all these distributed systems talk
to each other communicate via these
events right they publish reliably
reliable events what I will show in a
second and Baidu so you split up these
use cases these business use cases of
ordering a meal into several use cases
that are transactional in themselves so
what does it mean well other than
ordering your meal and then just waiting
and waiting until the fully consistent
transaction is executed or not you have
split up transactions where you say can
I have that meal yes
and then you just ordered the meal and
you will basically accepted the order
and then you have to wait a
synchronously and ultimately you will be
notified whether
it was possible or not this will be done
in an asynchronous way there's a
question oh it's it's not an optimistic
luck exception because first of all
we're not talking about databases and if
you look at the whole um use case this
is not what you're doing because you
don't wait for the whole use case what
do you do you sit down at the table you
order the meal and then you wait until
the way to nuts and accepts your order
until they understood you and yes
mac and cheese and that's it and that is
the transaction so what you want to have
you want to make sure that your orders
in the system no matter whether it's
possible or not but first of all they
have to understand you and you want to
be sure that it is in the system so
eventually you will get a response right
the overall use case the overall
business transaction is not completed
yet but you have a small technical
transaction of ordering that meal let me
show you the next thing that makes this
a little bit clearer let's make this
smaller another example let's talk about
coffee almost like in the restaurant we
have a coffee shop a scalable
distributed coffee shop with three
distributed systems involved right so
imagine you had this four barrel or blue
bottle or you know a lot of good coffee
shops here in San Francisco
and you have an order system that is
used to order a coffee you have a bean
system like bean storage so when you
order
Coffee drink with specific beans you
want to be sure that beans are in stock
and you have a barista system the
barista eventually brews your coffee
right so same story you want to order a
coffee you want to show whether it's
possible and I eventually want to get it
right so you ordered a coffee on the top
left at the order system right and then
what happens you know you could take the
order system now the order system ask
the bean system in kind of distributed
transaction whether it's possible to do
that specific coffee order weights
blocks then comes back eventually and
tells well tells the client whether it
was possible or not right
this would not scale so other than this
what you do you communicate by these
events what happens you order a coffee
and that results in order placed that's
it or the place there's an event events
are again immutable and happened in the
past so that is a fact
no matter what happens in the future
your order has been placed it's in the
system and this is the point what now
about transactions this has to be
reliable so you want to be sure that
that order is in the system right it's
kind of fine if they tell you well the
order was not possible and it's also
fine of course if the order is possible
but is what it's not good is that the
weight of forgets about your order that
is actually not in the system right this
will be bad so this is quite important
you have to be assured that all these
events are published reliably so you
still have transactions at that point so
what happens he ordered the coffee and
then the coffee order has been placed
and that's it the client now goes back
returns to something else
a synchronously and then the whole
process starts asynchronously so now
what happens with these event
communication now the bean system the
bean store is interested in all these
place the coffee orders because that
system has to verify whether all these
orders are possible right so now what
happens to bean store consumes that
event calls the command validate bean
and validates that
Coffee order and then what happens while
a new event arises that's called all the
beans validated right that's a yes
that's yes it was valid and it was
possible to do that coffee order so if
it was not possible well then you have
another event something like or the
failed due to insufficient beans right
because that that's what happens you
communicate by these events now the
order system can come back and say oh
great
now the order is accepted now can accept
my or had the order because I know it's
possible that event was there and only
now the barista event comes and says oh
great I'm only interested in accepted
orders now it can actually start that
coffee brewing process then the order
system can come and say oh great now we
can start the order or the system does
that in the case the client comes back
and ask for the current status of the
order so the orders is to know what's
going on what's going on right that of
course happens asynchronously so that's
being eventually consistent right at its
core well then eventually some new event
arises arises the coffee brew has been
finished and it's delivered and so on
and so forth and then finally when it's
delivered the order delivered that's the
definite state there so that's the end
of your overall business use case of
everything yes happened successfully in
the system otherwise you can imagine
right this would not scale right if you
do this all in a synchronous way so
basically what you're doing you're
communicating by these events in these
ping pong way but again these events
have to hand be handled reliably any
questions yes
right yes this in in this case you know
it can't happen why because you're
handling these events reliably what this
happens what this means if you have
several instances I can tell you this in
the second one we talked about the CQRS
but but basically yes the beam system
has to ensure that when it says validate
that there are still beans in stock
right reserve them and something like
that all right now to this buzzwords
CQRS
that stands for command query
responsibility segregation a long word
could almost be german german and it
basically means funny funny name
separate your concerns from writes and
reads from so called commands and
queries in a java world this would be
you have a method signature avoid do
something right change is something in a
system-wide doesn't return or you have a
getter that returns something but has no
side effect right and since we're in an
event-driven architecture because CQRS
again combines event-driven
architectures and event sourcing we have
all these events and we communicate by
these events so that means only commands
change something in the system are
allowed to produce events and since
these command
well commands can't return data they
only can walk through and finish
successfully which means some events
will be published or nothing happens or
of course an error occurs but which will
be visible in a synchronous way and
again query only return data
so now let's see how we build this into
a secure s architecture so more esky art
pictures like my editor slides this is
my way to walk away from from microsoft
powerpoint and stuff like that which I
totally dislike here you have the rough
system architecture you have a command
service in the query service right we
split the responsibilities for writes
and reads and all these instances only
communicate via publishing events that
are published through a so-called events
tour or event hub and all there's these
systems which you see in this DB
database they have well database
instances or any kind of storage could
be eaten in memory storage that is used
to store the current state in the system
so basically what happens once a new
event arrives that will be published
from the command service of course they
get into the event store and then they
will be used to update the internal
representation let's quickly walk
through an example yes
yes but you see in this me yes how do
you manage I will talk about this later
but but so far this goes back to handled
reliably so basically what what that
means once you handle events that means
only one no sorry exactly one instance
at a time will handle these events
reliably so that you don't get into
issues with ordering I will talk about
this in a second once we walk through so
let's do a quick walk through how this
works so you get the idea you want to
order coffee right so you want to place
an order that means you go to the
command services side right the command
service has its internal representation
its database that can be used to do some
basic validation and then finally it
will accept this order it will place
this already event and again this has to
happen reliably so this communication to
the event store has to happen in a
transactional way that's important
then this order placed event is in the
system now the client can go back do
something else
now what happens asynchronously this
event will be published and consumes
from all the query and command service
instances and that will be used to
update the internal representations of
the current state in the databases so
that means then you have some kind of
coffee order instance in all these
databases relational databases for
example and now if the client wants to
come back and say hey what's the status
of the coffee order it can go to the
query service site because that's used
to read right and then this will return
the current state of the coffee order
that has been less updated by some kind
of event
of course again that's eventually
consistent you don't know when the event
will be consumed there but ultimately
the status will be reflected in these
internal representations and of course
equally well because we at some point
want to have a coffee there will be some
kind of event handling mechanism in
place that uses these events to consumes
them and then call some subsequent
action some subsequent command of course
again on the command service site so
there will be some event handling
mechanism in place and then again this
command will result in some new events
and so on and so forth right so now what
we gained well first of all we can scale
our system because all of these database
instances what you see and this is again
the shortcoming of a of a crud based
approach in a crud based way we have a
single relation a database instance
which will not scale now all these
databases are distributed each and every
instance has its own instance right and
all the instances are only coupled by
this event store or event up and that
means we can scale first of all we can
have as many instances as we want and
also we can scale independently from the
read side and the right side that means
we could have more read instances than
right instances why would we want that
well in a typical enterprise application
your number of reads highly outnumber
the number of writes right you
constantly read something a five browser
refresh and once in a while you write
something and change some state in the
system right which comes in very handy
because then you can deploy a lot of
read instances that will all be updated
once a new event arrives and you have a
lot of databases or even in-memory
caches that can handle all these
requests right it comes in quite handy
it also solves the event sourcing scale
problem what does this mean well again
in event sauce
you derived the current state of the
application from all the atomic events
right and now imagine if you would do so
you go to the beginning you calculate
all these money transactions until you
get the and current balance and then
tomorrow you go back go to the beginning
calculate all these money transactions
your system gets slower and slower and
slower because we store all of the
events more and more events will be in
the system
which of course does not does that go
well in the future well what's different
in a secure s approach we don't do this
actually we just use all the events all
the new events to update the internal
representation of that database or that
cache and then we use just that
representation to output it to the
client for example we don't go back to
state zero and calculate everything if
we don't want to right and also what's
nice about the CQRS approach you get
read failover capabilities for free
because what happens in a crowd based
system if your database breaks down well
too bad right darn we can't do anything
we can't read we can't write what
happens in a CQRS system if your event
store goes down you can still read
because you have all of these instances
in place that have their own cache or
database which can be used at least to
return the status you can't write
something because that writing has to
happen in a transactional way that will
fail but at least you can read all right
any questions bless you yes
no at the current state
so in this case for example this coffee
order which would be your domain model
so that is a domain entity like a coffee
order or what you would normally put in
a JP a mapping in the relational
database so everything all you nouns all
your domain entities in your application
which are normally not domain and domain
events supposed to them right right
that's why that's why we restore this
current representation and then we only
use the most recent event that just
arrived to update it but we don't get go
back to two years zero yes yes
they record not for the coffee order but
just for the events yes oh yes that's
the golden source of truth yes
well ultimately every order is stored
any anywhere else but that's only
optimization so your golden source of
truth is the event store or the event of
that you can throw away all these
databases if you want and you can
recalculate them but you can't throw
away your venn store because then you
lose em history all right then we can go
to finally to see some code to see how
we can implement that using a Java EE
and Apache Kafka so what I have here is
I have small IntelliJ and two to low
resolution with three systems barista
beans and orders right and I call this
the scalable coffee shop and I would
love to see it you show you guys the
github repo but well I don't have
internet here the wife I couldn't give
me a DNS lease oh yeah too many
attendees at JavaOne so well I can
provide you the link later but this is
on github it's a scalable coffee shop
that comes in three applications right
for beans orders and barista why three
why not six or more well actually for
simplicity reasons I'm not deploying the
read side and the right side of each and
every system instance in separate
applications I could do so they're
totally not coupled in any way they just
reside in the same application I will
show you this in a second so as I said I
would love to life code for you
everything but as you will see this
approach comes with quite an overhead
so for example introducing all these
events we will see that this as opposed
to a crud based way why you define some
domain entity put some JPA annotation
magic on it and that's it comes with
quite some overhead involved and will
result in a more effort compared to a
crowd based approach so this is
definitely a shortcoming of that
approach and we'll talk about this later
on what we have here jax-rs we have our
oldest system our oldest resource this
is the jax-rs HTTP resource that well is
used to both as I said I deploy both in
the same instance read and write coffee
orders so that is the order the order
system it output outputs everything to
decline using HTTP so I have this orders
resource here and a half the command and
a query service right so let's quickly
walk through it if you have any
questions like any time we are posting
some new some new Jason Girish to this
resource so we want to order a new
coffee right we use HTTP POST to post a
new coffee order and then what happens
we tell the command service because we
want to change something in the system
please place a new order right and then
what happens
well the command service takes this and
says yes new order placed order has been
placed that's the event and that's now
published here you see it again void
place order that's the method signature
that this happens here this will be
invoked and then again it returns and
toss the client response accepted HTTP -
OH - thank you come back later and it
also provides some UI that can be used
later on which is invoked by a random
you have a question yeah yeah in a way
that that I put the HTTP class into the
boundary yes I know and this is normally
what I'm doing ah so that's an
architectural question and BCE pattern I
normally place the into the boundary not
only the beginning of the use case so
for example the EJB that would here be
the command service but also this jax-rs
why because it's the most
straightforward way and that is the also
the boundary in the system and typically
in a java application that's the only
external boundary that you have unless
you do some front-end stuff so this is
why yeah just for simplicity and
straightforwardness thank you for that
question
anything else so then you see well now
it's in the system I can quickly show
you I don't want to go too deeply into
that because sometime how it uses Apache
Kafka so basically what happens well it
has to connect to Kafka now right and
produce that event and this has to
happen in a transactional way so I will
do some transaction magic here
Kafka since version 0 the 11 supports
from the transactional producers and
this is what we need here because I want
to be sure that that event is in the
system otherwise I don't want to tell my
client yes it's in the system if it's
not and that's it then we can come back
later so now if you want to read a
coffee order now that order has been
placed right and now it's in the system
hopefully if you want to read it we of
course use the query service to return
that order and the query service will
use the internal representation to
output it so I have some coffee orders
here and you would use some
relational database right for the sake
of the example I do it even simpler I
say I use a concurrent hash map right I
store my state just in memory why well
because it's the fastest approach so
that means and now this is here you will
see how I integrate all these events in
Java EE you may my know it comes already
with a quite powerful invented mechanism
namely CDI events right so what I'm
doing each time an event will be
consumed by the Apache Kefka cluster
that event will be fired as in CDI
events in my application so even in my
application I can decouple from that
event publishing and say oh I just
defined some event herbs observe methods
some event handler and observe two for
example or the placed right and then
what happens while I use these the main
entity logic to put it into my hash map
and that's it and now what actually
happens to if the client comes back and
reads my current status it will be
returned from that hash map that's it
now I'm just simply the order it comes
Sumer just quickly what happens well you
go to Apache Kafka this is not a
consumer side so the integration with
that what I wanted to do I want to use
Java EE functionality to integrate it as
lean as possible this is why I used to
CCDI eventing mechanism so there is no
tight coupling to the Apache Kefka
technology here I connect to the
kathcart cluster actually and we'll just
fire the event right coffee event will
be fired here that's it let's see Kafka
character integration all right now what
happens if do you have any questions
yeah
sorry I didn't get up yes if that method
is is invoked successfully until the end
it returns that means yes it was
successful otherwise it has to throw an
error sorry the order I did that is
actually provided from the resource here
so basically the client tells the order
ID and the client here is well the HTTP
resource right so thinking we own we are
short on time so let me just quickly
show that example in real life right so
I have three command-line instances here
with my three applications and I have
some script running because I need now
three applications that will be first of
all built and then deployed to
application servers that run in docker
containers so what I do I start with
three docker containers one for the
order system barista and pin system and
then I will just quickly order some
coffee right so all of these connect to
Apache Kafka which is also running on
and actually I see that the power does
not work the power supply boots yeah
we're fine until the end of the session
this is nice when you plug in the cable
and it doesn't work so what happens we
use well the order system to order some
coffee right so I will use curl of
course command line we go to localhost
port 8000 one that's one darker
container for the order system and we
post some Jason to the order system
right let me just quickly go through
that and now what happens to or to
accepted right thank you come back later
the orders in the system and it told me
the location the location HTTP header so
what I can do I can ask the order system
yeah give me the status and now what
happens Oh canceled why is it canceled
swell you know everything in memory so
there are no beans in the system right
so actually we have to put in some beans
into the bean store because
means not being 6ml but this one here I
have to order some beans I want to order
10 beans from Colombia so what I did I
ordered some espresso from Colombia
right and I want to put this into the
system first because now I can go to you
see eight thousand two and that's the
bean system and that also has an HTTP
endpoint now I can ask the bean system
oh how many beans to have and now it has
amount of 10 beans from Colombia so now
I can actually hopefully go back in
order some coffee so that means I can't
take the old order that's already
cancelled but I have to order new coffee
so what happens I asked the order system
again same story as before I want to
post some Colombia coffee some espresso
and now again to to accept it
so it's accepted again although I don't
know the out final outcome it will tell
me well use this your I to come back
later what happens oh it's already
finished so if I look into my command
and output it will tell me I just
posting all these events here order has
been placed and then afterwards oh great
order beans have been validated so
that's a yes right and then all these
things happen and basically the barista
system goes and starts my coffee order
and what the barista is internally well
it's a timer so at some point it will
successfully brew our coffee and oh I
just saw saw the event so now it's
delivered right so that was the whole
processing and just very quickly since
we're running out of time
what I'm doing now I'm killing all these
instances why because well everything is
in memory and now everything is gone
right so too bad and now I want to start
it up again so what happens because I
store everything in memory and probably
you might think that's a bad idea and
you're totally right because I don't
store the events um or at least the
outcome of the event what has been
derived from the events my business
domain objects persistently so what
happens all my applications are
connected to talk to kefka and say oh
please I'm a news
them redistribute everything that
happened since day one all the events
you have that's possible you can do that
and this is why you can fire up the
system the new system and you can return
the same coffee order I just ordered
before that was there in memory with a
randomly generated UUID and you get the
same outcome
why because everything will be
recalculated from kefka from all these
events events again are immutable and
happened in the past so you can use
these and ask the cafe cluster to
redistribute everything so yeah I see
we're running out of time I hope you got
some idea for for the CQRS approach if
you have any further questions on that I
have two scalable coffee shop two
resources for you this is github there's
my github profile as national scale - I
think I spelled it correctly that's less
him that's the open source project where
you can see the scalable coffee shop
thing and you can see you have actually
have to search for that or you search
for CQ s I have a video M course that is
available for free under my block which
you can watch to see all this topic in a
little bit more than 45 minutes so you
can go there and well see everything in
a little bit more detailed and now since
we're running out of time I have a
little last question for you once you
leave the room please make sure you use
the voting machine to tell me whether
you like my session or not so thank you
very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>