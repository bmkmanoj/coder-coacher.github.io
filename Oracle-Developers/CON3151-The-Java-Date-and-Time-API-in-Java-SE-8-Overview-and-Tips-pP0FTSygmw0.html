<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CON3151   The Java Date and Time API in Java SE 8: Overview and Tips | Coder Coacher - Coaching Coders</title><meta content="CON3151   The Java Date and Time API in Java SE 8: Overview and Tips - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CON3151   The Java Date and Time API in Java SE 8: Overview and Tips</b></h2><h5 class="post__date">2015-12-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/pP0FTSygmw0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to this session about the Java
date and time API my name is Reggie
Riggs I work for the Java Products Group
in the core libraries team at at Oracle
the job at a time API was created with
the help of Steve Coburn over many years
he developed the the Jota time API prior
to working on the Java API as part of
jsr 310 and I helped integrate it into
the JDK and get it to be part of JDK 8
so today we'll do an overview of the the
basic core API that supports ISO time
zones will look at count the calendar
neutral API that supports regional
calendars for Japanese and Thai and the
Islamic calendars there's a section on
formatting and localization and then
there's we've got a section at the end
of ticks and trips some of them be
familiar the lot of material is very
similar or identical to last year's but
we've got a new audience so it should be
interesting the presentation is
informational so I hope you take away
something useful and can make use of
what yourself Jeff r310 started actually
now quite numb some number of years ago
by Steve Coburn and it went through a
series of iterations as part of the jsr
process deriving he took a lot of the
basic information and the knowledge
expertise that he'd gained from working
on time api's and Joe to time in
particular to form the new Java time API
it was released as part of JDK 8 last
year and it's been very successful since
then and being a replacement for the
sort of aging and problematic api's of
java.util.date and other util calendar
both of those api's are still present in
the GDK and probably will be
indefinitely but they each have their
problems and many of you probably
experienced them firsthand so there are
five packages as part of the job at a
time API for many uses all you need is
the basic Java time package which
includes classes to support local times
local dates dates and times zone dates
and times what
sort of brings it all together and then
their concept of clocks which can be
system clacks or can be there's some
flex you can use for debugging there are
types for durations a period of time or
durations period zone IDs and then
individual types for day of week and
month etc and we'll see more about that
the second package is dedicated to
formatting there's a new formatting
package that is sort of predictable and
immutable so that it doesn't have some
of the pitfalls that exist in the
current date time the previous date and
time for matter and we'll see more about
that and there's a separate package for
the detailed time zone information if
you want to know when time zones are
going to change or compute things
elsewhere there's access to the times on
database the fourth package is a package
of calendar neutral AP is there's a
framework just be able to create
arbitrary calendars and then we put the
JDK supplies for specific calendars
regional calendars that are sort of the
most useful and widely used globally and
finally there's a package that includes
a lot of the types that are used to
build the framework underlying the Java
time API there's quite a bit of
extensibility possible within the API
and this framework package provides the
basic fields and types you need to do if
you wanted to extend it most users will
just be able to use the the core package
and and be very happy with it here's a
quick summary of the different sort of
the core types for local times and the
the fields that are in each of them that
obviously it's pretty straightforward
there's no real magic to the date and
time in terms of the fields are needed
or or how they're mapped to two strings
there is a distinction between what sort
of human time types the date and time
local date and time etc and machine time
the instant at the bottom is dedicated
to sort of to a particular sort of
machine time it has no its second since
the beginning of since 1970 and
nanoseconds it doesn't know about months
it doesn't know about days years it's
not customized particularly
it really is just an instant in time and
there's ways to map between them to make
it easily easy to use but it is if you
want to put something in a log using an
instant as the way to do it because it
won't shift around based on time zones
or where you are in the world just to
compare sort of the current Java
calendar API data API is versus the new
Java time api's the they had suffered we
picked up sort of some new design
patterns that make the types of beef
immutable fluent so you can string
together a series of method implications
there thread-safe mostly by virtue of
the fact that they're immutable and
there's strong types that are fit for
particular purposes in the java.util
calendar API there's sort of one basic
type that had a lot of state in it it
was mutable you had to worry a lot about
who if somebody else changed it and the
interactions within the type so we'll
see how that all of that plays out in
the new API just to sort of give you a
mapping of the java.util calendar types
to the java time types the ones on the
right are mostly calendar and date
because they only had a few types in
that in that API on the left are things
like instant which maps directly to a
date which is just milliseconds local
date and time the more interesting ones
are down in the middle of where we want
to talk explicitly about time zones zone
offsets and the rules around time zones
maps to the time zone class of the
calendar package a couple of specialized
enumeration types for a month and four
months and days of the week we think we
improve Minh to have to use the ISO 8601
calendar and to map to have the week
start on Monday with the number one
through seven the current java.util
calendar starts at one through seven but
there they start the week on Sunday the
international standards in ISO 8601
seemed to prevail and be a better base
to work to build out of job at that time
similarly the months
run from one to twelve it seen more
natural in terms of what people use them
the 02 11 counting the calendar API so a
sort of basic basic framework for types
one of the big things in any new API
design is naming so there are quite a
number of naming patterns that were
present in Joe to time and as we
iterated through the design for job at a
time it was really valuable to be able
to have a consistent use of these sort
of keywords in every API so for example
in any of the static factories that
creates one of these type the of method
it always takes its arguments and
validates them and produces an instance
there's you know it's consistent
regardless of which package or package
and class you're talking about similarly
you know the from method takes data out
of an existing object and creates a new
one possibly transforming area some of
these are sort of self-evident but they
make the API very usable and in the case
of you're using an IDE it makes method
completion be very very easy and very it
leverages the the tool to show you the
possibilities when you're trying to
write write code to these types so just
a quick example sort of side by side
between the java.util calendar existing
ones on the right and java dot time api
on the left the current calendar API is
is very field based and so there's get
methods with particular fields the
pattern on the Left uses individual
methods for the different different
fields and since they all return a well
this is get so they return the values
that you're interested in most of the
API is that is fluent so the return type
can be passed on and we'll see that in
the next slide where where instead of
sin cell instances are immutable the
mechanism for creating you know for
setting a field really produces a new
instance with the one field that you're
trying to modify or that you want to
modify changed so the width method name
all the methods to start with width
replace some field in the object with
and return a new instance of it so for
example of here in the zone date time
you know whatever you know with second
number one it'll reset the second field
it's fluent in that it returns each of
these methods returns the same it turns
this so it returns the same type and you
can chain them all together there are
usual set of arithmetic operations on
time for adding and subtracting days
months nanoseconds and the calendar the
underlying calendar does all the right
arithmetic is you would expect so the
API is it's a little different but it
has the desired effect we'll come back
to some of the details of related to the
calendars later here we're going to jump
in and talk about the calendar neutral
AP is and the regional calendars besides
the iso 8601 calendar world globally
there are quite a number of other
calendars that aren't used regionally
and for at least four oracle it was very
important that we be able to support the
calendars in the native calendars
anybody has worked with dating time for
very long knows that there's a lot of
different calendars and they have
different rules about some of them are
pretty wacky in terms of you know there
are 13 months in this calendar or you
know the number of there are in one
calendar there 12 months with 30 days
and then there's five or six extra days
that are somewhere in the calendar so
part of the API design was building a
framework that could allow the
introduction of a particular chronology
and then build on top of that chronology
to build an API so the assumptions that
have been showed up in pieces people's
code earlier about you know the number
of months in the year or the number of
days in the week which actually is
pretty constant so that's not less of a
problem but assuming for example if you
want to advance the next year that you
had 12 months that's not really valid
when you're working with a wide variety
of calendars so the calendar neutral API
is focused on it's a slightly different
model of the calendar but it's focused
on making sure that all the primitive
opera
patient's on calendar elements are
handled by the implementations so the
mathematics of the count calendar
mathematics work out correctly and part
of that is introducing this chronology
type which in bit sort of represents all
the particular calendar mathematics
under the covers so here we'll again
we'll compare using the current calendar
API which also does multiple calendars
but it does it based on locale and there
are some subtleties in using it with the
the Java detainment API so both of the
in both cases you can find from the
current locale you can find the
appropriate calendar that you want to
use looking up the chronology on the
left hand side you know from the
chronology you can ask it to get the
current date you know date now and it
returns a chronic rano local date which
is independent of in the current
calendar but it doesn't really tell you
what the calendar is because you've
you've looked it up sort of very
abstract at that sent the access to the
fields in this calendar are more field
access like the current API there was
sort of a deliberate design choice to
make the regional calendars have a
different feel to them partly to get
people to use the ISO calendar
predominantly and not be distracted by
the regional calendars unless they
really had a strong requirement to use
them so at the bottom you know this
example of being able to move from get
from a current date to the next month by
adding setting the day of the month to
one and then adding a month to the to
the value and you get the beginning of
the next month similarly you know on the
right you would have done that by
modifying the by setting the fields in a
calendar object and under the coverage
it will do that do the right math so
even with regional calendars in the
calendar neutral API you don't want to
be able to handle time time zone
differences and be able to handle the
time zone changes so there's a the
the chrono the names get a little bit
long because there's more and more
functionality being layered on the crown
alok 'old 8 is a generic I'd class
parameterised type that embeds a date
with the regional calendars the only the
time elements are the same worldwide
fortunately we're good for 24 hours a
day and 7 days a week but the the date
is parameterised so with the crown of
local date time you get to embed you
have a type which represents a
particular calendar though here it's
wild carded because we don't have any
static type information about what the
particular calendar is you can extract
the local time or the date out of the
out of the kind of local date that sort
of holder of all the pieces you can the
at the at zone is one of these modifier
methods which says I have a date and the
time but I want to associate it with a
different time zone so it returns a kind
of local zone datetime a crown zone date
time they do get a little bit awkward
but the naming was important to be able
to communicate everything that was
buried in the and then finally here the
example shows we're setting the time to
midnight in whatever that date and time
was so all the types had do have to
string methods so they produce some
output in some format as usual with to
string it's not it's sort of for
debugging it's not the official format
for something and it's better that you
use the deliberate for matters for that
as I mentioned both the Java current
java.util calendar and java de time use
sort of a field oriented access to the
values in a particular time element it
just sort of compares the naming between
the two the the types the types are all
disjoint so you won't be you won't
really make any mistakes and mixing them
up here's an example of being able to
look at the regional calendars that are
embedded that are implemented as part of
the JDK you can enumerate all the
chronologies that are
that are supplied it is that the API is
extensible but there are built-in
implementations for the Islamic calendar
of the harwich calendar the thai
buddhist calendar japanese calendar and
in- or the as well as the standard iso
calendar which fits neatly in under the
API of the calendar neutral so there you
can convert easily back and forth
between the regional calendars and the
the iso calendars as needed so in this
example we're going to you know
chronology that of looks up the garage
calendar and then there are two ways to
look it up you can hook it up by sort of
its common name and by its CLD our name
there's sort of this dichotomy of naming
that comes out of all the databases that
come along with the common the common
database locale database the other ways
to select the chronology Archie look
them up using the bcp 47 encoding of
locales there's sort of the current
sisters sort of a lot of ways to get to
the right calendar depending on the
context that you're operating in and all
of them are supported in the new API and
once you've got a chronology you can
create a date at a you know a calendar
neutral date based on the Pearl uptick
calendar which is because based on 1917
is sort of a common thread between all
the calendars there's also support for
the the Japanese date in the eras the
Japanese calendar is a little bit unique
there in that the they started the
calendar over again to match up with
each of the Emperor's so the era the
concept of an era comes into play in the
Japanese calendar most more
significantly than the AP is the here
that shows an example of using the the
bcp 47 syntax to look up the locale and
then deriving the calendar from that you
can also just use the explicit types for
the Japanese day
and Japanese calendars and if you're
writing an application that runs
specifically in that environment using
the most specific concrete types is
preferred because your being is as
specific as you can in the code it'll be
easier to read and easier to maintain
there'll be no sort of confusion about
well which kind of calendar system is
this it's very explicit the there you
know other examples here of just using
how how to build the types from the
basic Japanese date into a local date
and time or a Japanese date and time
with the time or adding a time zone to
it and in this case you can see that it
is that the parameterization of criminal
krennel's own date time can express the
fact that the the date is a Japanese
date as you manipulated and the type
system sort of supports all that the
bottom of the thing the bottom of the
page has an example of the format using
the formatter to take the particular
date and time and construct a which will
see some more formatting a minute you
can construct a formatter from a pattern
than the usual set of pattern letters
and associated with a particular locale
and printed out in sort of locate the
very low cal specific result the code on
the right is just what you would similar
sort of equivalent code if you're using
Java util calendar I'm sure that there's
people who've done this as well find
some of this familiar and they probably
use different slightly different
techniques to get to the similar result
the Islamic calendar is another one that
was important is important in the in the
Middle East for quite a number of sort
of commercial uses the it's a little bit
more innocent cratic than some in places
but it has one significant value that's
global that's worthwhile globally which
is it's a lunar calendar it's based on
the phases of the Moon so if you're ever
curious um computation where
sort of want to know what the phase the
room moon is you can take a date convert
it into the Islamic harwich calendar and
pull out the month and where you are in
the phase of the month so even if you're
not if you just want to get a good fix
on what the moon is doing the Islamic
calendar can can really help out there
without reverting yourself to all the
computations about well where is the
moon today it has the same
characteristics as the other API is
where there are specific types for for
the the harrahs date and the but then
the time of the calendars fit right in
and the chrono zone datetime aggregate
type can express the fact that there's a
hodge date nested inside of it and
obviously all the formatting works in
concert with all the locale information
that's embedded within the JDK and every
runtime so let's move on to the
formatting package which is the other
sort of powerful addition to to the API
there were sort of in reaction to a lot
of the problems with simple date
formatter jodha time also had a lot of
these same capabilities for being able
to create a formatter creating the
formatter is essentially a template for
mapping the fields of an object into how
those should be represented in text
formatters are used the template applies
both for printing and for formatting and
for parsing so you can you'll get you
know you can print something out and
then and parse it right back the
templates the date-time builder can
create can embed obviously literals it
can embed numeric values that are taken
from a field or that when the parsed are
set into a field along with requirements
for is their leading sign are there
leading zeros how wide is the field etc
the the formatting characters also
formatting primitives that are assembled
into this ten
plate also have access to all the
localized formats that come along with
with a locale for example is the you
know is the month a one character to
character month name or the day of the
week what's the you know what are the
actual values that go along with days a
week in a particular locale so there
have been some part of the power of the
formatter is that it's it uses the
lookups of the current locale
information to both parson to print you
get control of fractions and printing
and there's some specialized
functionality for four zones and for
instance now we'll see some examples
after a couple more aspects so you
create a template this template parser
and then while it's actually parsing you
can control whether the strings that are
found are case-insensitive or case
sensitive the you can express the fact
that there may be optional fields in the
input if you're parsing something then
you can express as part of the template
to this part that this part of the input
may not be present and there's some
difficulties to default it and we'll see
details in a minute and then there are
strict rule there's a setting for strict
or lenient parsing that allows the
parser to be well lenient in the case of
if you're trying to read in the month of
a date for the month day of the month
and it's in February and somebody types
in 30 you can tell the parser that well
it's okay we meant he meant the end of
the month so the lenient will sort of
can help pull the data back to what what
the calendar really expects and then
another powerful piece of the for
matters is is that you can since they're
sort of field oriented templates you can
concatenate them and so if you have
really complicated set of parsing you
need to do you can build it up from the
pieces and assemble them so let's see an
example of using the the formatter the
formatter builder to parse a time where
the time is one or two digits and then
there's an optional
pair of minute colon and minutes and
then another optional for colon and
seconds and in this example the so it's
pretty straightforward that you you know
you append the notion that there's a
value that comes from the hour of the
day filled the width is a minimum of 1
and maximum of 2 and in this particular
case you know there's never any sign so
the parser will not accept a sign and
we'll take it into account the optional
start is a trigger into the builder to
say what follows may not it may not
appear in the input if there's any sort
of parsing failure after that it's okay
we'll just sort of skip it and we're
going to first look for the coulomb the
fixed field of literal for colon and
then a parsing the the minute of the
hour so it's it specifies exactly which
filled the value will go into and then
it's two characters wide and then you
know the next little bit is sort of the
optional building the optional piece for
the the seconds filled with a colon an
optional parsing something into the
seconds and then ending the options so
that gets you something that will parse
most of the fields but if the if the
minutes of the seconds isn't present
then what what value does the field have
so there's additional ways to say to
default a particular field if it hasn't
been encountered in the input by that
point to default it the particular
particular value and then at the end of
it since we're in a builder pattern the
last thing is to actually create a film
date time for matter from the builder so
then there a couple examples here at the
bottom that if you have just the you
know if you have just a digit 9 it
parses out the full time since there was
no minutes field in that input it
defaulted it to one and the fault of the
seconds of zeros so that this model of
assembling a template for as part of a
parser is very powerful similarly the
same template is used on output so if
you go to format something a date and
time or a date in this case or time in
this case
it will you know produce the right
output so you can do it's it's symmetric
there are quite a number of sort of
different pattern sort of a lot of
formatting things are based on pattern
letters and there's at least three
different systems of pattern letters
this is sort of an too dense chart of
the mapping between the formatting
characters that are used in Java util
format those used in the simple date
formatter and the ones used by date and
time the date and time for matters but
there's quite a bit of breadth in
options they're part of adopting the
java dev tainment time api was figuring
out the relationship between the the new
API is in the new form matter and the
existing date and time calendar classes
and their form and those four matters
and we wanted to be able to have a bit
of crossover in both directions so the
the java.util formatter was modified so
that it will accept as input the new
date and time types anything that's a
temporal I didn't mention temporal but
all of the date and time types are sort
of have this temporal in from interface
which provides it field access so with
the standard string.format call the form
w2 formatter you can use the new date
and time types you don't have to go back
to calendar so that's you know easy to
use if you've got a bunch of formatting
code that uses these rather cryptic
percent dollar sign strings and you
don't want to change it you can still
use the the new date and time types to
keep track of time and the calendars
effectively there are as part of the
formatter package a set of predefined
templates for parsing dates and times
that have familiar excuse me familiar
names many of them are ice most of them
are iso based but you can any
application can create their own if they
don't if there's one of the predefined
ones doesn't suit it
there are also the sort of the first one
on the list in the upper left fines for
matters based on the current locale
locale so some locales are configured to
have you know short the short form of
the week day of week is one letter and
this particular letters are filled out
there so there's a way to look up all
the locale sensitive format strings and
use them deliberately the formatter as I
mentioned is is very powerful there's
you can this an example here of using
the different formatting predefined
formatting patterns or you know building
your own with the you know from of
pattern you can build for matters that
have both literals and field accesses
and use and so it's very convenient to
find to get the right kind of format
that you need for your application the
other aspect that we wanted to be able
to do was to be able to have the new
date and time for matters be used with
existing calendar and date types the so
that people could get away we've had
problems with simpledateformat and it's
it's state fulness have a place to go so
the the technique here is mostly that
from a calendar instance there's a
method on calendar that will produce a
zone date time so it will convert from
one form of the from the old form of the
API to a new instance which then can be
used with the new with the new formatter
you get the same results but you get to
switch and use the new API a bit a bit
more flexibly about the time we were
developing this javafx was filling out
their their set of controls and we had
some help from the javafx folks to embed
a date picker that uses the Java time
API
and they came up with one that's really
powerful that allows you to pick you
know which which chronology you want to
use and they show you the calendar and
the right the right format and
everything so we're very fortunate
that's now part of it FX built on the
the new date and time API and I haven't
used it since 2013 as you can see from
the slides so that's sort of a little
bit of a lightning overview of things
part of the experience of using the date
and time API is helping people convert
from their existing code to the new code
and to pass on some observations about
the sort of problematic areas that show
up in in applications so here's just a
few tips and tricks a couple of one of
the things about an instant is that the
comparison between a date and instant
there's sort of the equivalent types
they both have just a time as a spot in
time without really any notion of time
zone that's that's really robust so if
you're converting you can convert easily
from a date to an instant but if you
want to convert instance into a zone
date time which has the full sort of
human time you have to remember that an
instant doesn't have a time zone and so
converting from an instant to a zone
datetime requires that you supply a time
zone sometimes it's as easy as saying
well that's gmt or UTC and but it still
needs to be an explicit step that an
instant is converted to sort of human
time with with a specific time zone a
couple of ways to do that you know the
instant axon will method will return as
own date time with a particular offset
in this case or you can create a zone
datetime from an instant with supplying
also the time zone but the one of the
more powerful methods in the API is the
from method it shows up on a lot of a
lot of different types but if you try to
create a zone datetime from an instant
it will valiantly
tempted but when it looks inside the
instant it can't find the time zone so
it throws an exception maybe the
exception message could be a little more
informative but there are some types
that you just can't convert between
because there isn't enough enough
information we saw that if you've got a
Gregorian calendar so general gregorian
calendar actually has a specific
calendar the just a calendar type itself
the static type doesn't doesn't really
tell you what Kellan Lutz working with
but there are methods on Gregorian
calendar to convert to and from the from
zone day time to make it easy to get
back and forth so one of the questions
that came up was well how do i format
durations the the formatting package is
very good for a full date and time or
four pieces of it but it doesn't have a
good model of for duration and the
normal duration according to the the iso
spec for a duration has a sort of
awkward pnt you know a period of time
hours minutes and seconds syntax so this
is just a quick tip to say well if you
take the duration and you add it to
midnight on the day just working with
the time you can get it back into any
time of day which then is easy to format
however you want using the normal
formatting characters and that's maybe
that would be obvious but there's one
question that came up so another problem
that some people had was when they
wanted they've got some input and they
don't actually know it's not sort of
clear exactly what format it is so they
wondered whether the parsing and parsing
mechanisms could deal with you know
disjoint but separate forms of input
with using the just the pattern letters
the square brackets are another way to
say this start optional end optional
piece that I've introduced earlier so
you can actually provide a pattern a
total pattern that consists of us each
of the patterns you might recognize
being optional
and the and then tell it to parse some
string and the parser will valiantly try
to parse each of them according to the
inner pattern and when they when they if
one of them succeeds that it's done the
only sort of wacky thing here is the
patterns have to be disjoint you know
you have to be able to tell from the
input in this case they use you know
hyphens are used in one case slashes in
another case and then just the numbers
in the last case it's a bit of a hack
there may be some room in the API to try
to come up with a more explicit sort of
exclusive or of parse this or this or
this form at school we'll see where that
goes another use of the API is trying to
figure out you know sort of digging
around in the in the time zone database
so here's a quick example of using the
the time zone class will start with the
current time we'll get the zone ID from
it there's a set of rules that are that
come from that our data configured from
the time zone updater format that
defined when all the tribe positions are
in each of the each of the locale of the
time zones you have to look up the set
of rules from the set of rules there's a
method that says next transition which
is really convenient because if you pass
it an instant in an instant it will find
where the right spot is in the current
set of rules and then from that you can
get the duration of the of the time zone
change event and the date on which it
would occur and the rest of the code is
just sort of pretty printing the format
okay so today so this is that this code
uses the same database that's embedded
in every in every JDK so there is a
there is a time zone database TZ DB that
is the data file that's in every every
JDK there is a an application called TZ
updater which is is available I think
for every every version of the JDK that
installs a new version of the times on
database so it's a it's at the moment
it's sort of a manual step right because
we you want to be very careful about in
your application environment when when
the time zone data changed we did spend
in the jsr or when we're talking about
it quite a bit of time and saying well
how live how real time can we make the
updates to the x on database but there
are problems of express ability of you
know in your code with what are the
assumptions around holding a particular
time and if the time zone database
changed underneath you what that means
in terms of the semantics of the API so
at least in the current implementation
we don't deal with that the updating the
time zone database is an explicit apps
action that happens as a management
function yeah ah taught me well so leap
seconds have been a problem and the
through many layers and in sort of
gnashing of teeth it and a lot of other
sort of conventional usage it didn't
seem useful to expose leap seconds in
the api's in particular so the java time
api is built on top of the operating
systems time notion of time which
frequently is built on top of you know
some basis of network time if we were to
go out of our way to try to expose leap
seconds in the java api we could
potentially get out of sync with what
the operating system it thinks the time
is
and so that would pose a problem and you
certainly don't want to applications one
of them running at the operating system
level and then we're running a java to
get different ideas of time so
effectively we dodged we said the
operating system has to produce a
sensible version of time it seems like
the in many cases the sort of adopted
practice is around leap seconds there
there's actually been several protocols
for defining this but you want the
network clock to slowly smush the time
either accelerate it slightly over the
last 20 minutes of the day I think is
one algorithm and then so that it
approaches it's not the true time but
it's close enough to keep applications
from getting all upset about time jumped
right you want to avoid the
discontinuity so I believe like the
Google time server uses an algorithm to
smooth the actual you know wheel time
versus that atomic clock is different
over you know across where a leap second
would occur I don't think I'm not sure
that's an entirely satisfactory answer
and for somebody doing scientific
computation or knowing exactly where you
know the planets are it's not going to
be satisfactory but for most application
uses and systems that all have to sort
of be consistent it's much better model
than trying to say you know this API has
to expose the fact that there will be a
leap second events actually think there
was one in June this year or July first
sorry july first so we ducked but it was
a convenient and i think it makes things
easier for everybody if you don't try to
push that leap second handling into
everybody's app so ok so there's ways to
get visibility into this time zone
database if you need it mostly you won't
it is used under the in the in the
computation of all the time zones and
the zone ids and and mapping back and
forth another important topic is
comparing dates and times the
sort of the normal that they're sort of
three sets of things that come that work
together the object equals method
usually is very simple thing it says
basically the classical definition is
all of the fields of each of the objects
are the same the values are the same the
the compareto interface allows you to
say in ordering but it's based on the
same model where there's some set of
fields in each of the objects and the
fields are compared and if they're you
know there's some sequence of greater
than or less than that makes sense now
with time especially with time zones you
can't just compare the fields because
sometimes actually have it well the two
different kinds of offsets there's a
zone offset which is actually some
number of minutes from gmt and there's
also the zone ID which is more of a
abstraction that's looked up to the time
zone database so the field by field
comparison doesn't really work for time
and the primitives that you really want
are things like is it is this time
before that time or after that time and
effectively those operations those
methods convert everything to an instant
global you know worldwide and compare
the instance so it deals with you know
he's my timezone New York this times in
New York and that would be London and it
will really sort of dig through the the
down to the instant that level to say
whether something is before or after and
it it was another sort of problematic
place in the API we really wanted it to
be that compared to would have the
timeline order however the convention
for the comparable interface is such
that it was really a field by field
comparison so there's two sets of
compare operations and when you're
comparing times you really should use
the is before is equal and is after
methods or use the comparator that's
that's that are supplied sort of a quick
example of where this can bite you in
this example we'll take the zone ID of
New York
we'll find the time now we'll turn it
into his own date time so it's sort of
fully qualified and then we'll pull out
the the timezone offset from that time I
work on the East Coast so New York is a
more familiar city for me so it but it
comes up with a fixed a fixed number if
you create a different zone day time
with that offsets ozone offset and now
run the comparisons you'll find that
object equals says they're not the same
because a zone offset is not the same as
a zone ID the type is even different
compared to also has the same problem
because it zone ID isn't the same as a
zone offset but if you use is equal it
will convert them both to instance and
compare the instances and you'll get the
desired notion that I think when this
was written that's off by for our that
New York is in the with time zone of
American New York it's four hours off it
really is the same time but it's not
always sort of literally equal according
to this and maybe I believe heard that
too much one of the powerful features of
the the framework that underlies all
these times is this notion of temporal
adjusters a lot of the types the
underlying mechanism is called referred
to temporal because it has to do with
time and there's a interface that
provides access so a temporal adjuster
is basically a function that you can be
applied to any date and time to compute
a new date and time so there are a bunch
of them that are supplied as part of the
API as part of the implementation for
example I've got some date and time and
I want to know I wanted to move it to
the end of the month the last day of the
month so there's a predefined temporal
adjuster that looks that it's a piece of
code that looks at the current date and
finds the last day of the month
similarly you know there's a there's one
that says find me the next day of the
week or the last day of the week or
actually in this example it's find me
the last Friday of the month
and apply the function to a date to
either a one of the powerful things is
it can be applied either to just a date
a local date or it can be applied to a
local date and time or as own date and
time so there's the same function that
because it's looking at the underlying
information embedded in the in the
object it can the same function can work
whether it's dealing with just the time
or just a date actually this particular
example of last and month can only work
with dates because the times are
relevant for its function so functions
can be created to go forward or back
there's a previous previous Wednesday
real simple you know it's really simple
for example a compute when thanksgiving
is here because there's a predefined
temporal adjuster that will find you the
fourth thursday in the in in the month
the temporal adjuster framework is
extensible you can write your own and
we'll see here that it's a little more
complicated because you have to delve
into the underlying representation I had
this questions like okay so when do I
get paid next well paydays are the 15th
or the last day of the month unless the
Latin Leslie those days falls on a
saturday or sunday in which case it's
the previous Friday so this temporal
adjuster gets passed in a something
looks like a date it the algorithm it
uses is to advance by at least a day but
skip saturday and sunday so we always
start on a weekday which is a plausible
payday then we're going to look to see
whether we're before or after the 15 to
the month if it's before the 15 to the
months and the paydays of 15th if it's
after then it's the last day of the
month so part of the meta information
that's available for all the types is
this for each of the fields you can ask
you know what's the minimum and the
maximum value for this field so here
just asked what's the last day of the
month in this particular type so now
we've got a date which is you the end of
the month of the
15 and there's a final sequence to go
back and say well if either of those is
saturday or sunday then we need to
subtract a little bit to fudge back to
the friday but you can write this you
know you can write it as a temporal
adjuster it's reusable and there's
probably plenty more possibilities in a
particular application to rebuild chunks
of functionality around dates and times
so probably other time i think is still
pretty widely used it's not like it's
going to go away it's a very good
package very very functional got a lot
of use so we're going to encourage
people to use the Java time API that's
in the JD case or just some notes many
of the existing method or classes in in
joda time also exist in Java time are
pretty directly mapped for local date
local time vocal date and time there's
some other renaming that happen to make
the Java time API is more consistent a
few difference in functionality the the
Jota time period goes all the way from
years down to seconds of the Java time
one is just is just dates and there's
some name changes duration is the same
but Java time is well thanks to Stephen
and the work that we did developing the
API the Java time API is sort of easier
to extend them Joe to time and easier to
customize at least that's an opinion so
just very quickly recap the gutta time
api it's the most of the types are
immutable the design is fluent so it's
easy to string things together and make
it easy to read thread safe the types
that are provided are specifically
designed for particular purposes so
there's no confusion about you know
something that is you know is this here
because it's a date or is this year
because it's a time or you know if I
have a credit card expiration which is a
month and a you know a year in a month
well there's a day thing that I supposed
to ignore but not really so there's
actually is a a month year type
so there's specific types that are
specific to purposes there's
extensibility for both the units in the
fields that are it can be embedded in a
time so we haven't really had an
occasion to use that but if you need
something besides nanoseconds in
milliseconds you can create that and it
will factor into most of the
computations there's a lot about
interoperability between Java util
calendar and date and the the new API is
to make it's easy to transition and to
make it easy to cross use the for
matters and the data types the regional
types are useful a lot of parts in the
world maybe less so here in the US but
there's a lot of value there and in the
calendar neutral API that lets you build
a new calendar that will that will fit
into the same environment and obviously
the core packages the basic that you
need for building a an iso calendar in
the global business community and if
there any questions I'd be happy to
answer there are some reference material
online i think this some of it may be a
little bit dated there is a torial that
i was put together by the the oracle doc
writers the javadoc is in the standard
standard places for for JDK 8 and there
are some additional length to the to jsr
310 there is a I guess it was sort of
called the back port there is a version
of an API very very similar to this
that's usable with jdk 7 I think but
it's not identical because of sort of
various standardization issues
yes
so we didn't it's better in fact I think
it's vastly better the don't think I can
point to specific statistics where we've
done a side by side but nearly all of
the operations that you see operate on
just a couple of fields to do what they
do the you know the things where things
wrap wrap around the comparisons
especially since the core API is not
trying to do every calendar and every
different calendar system the code is
written the ISO calendar has written you
know for I so so there's very little in
directions and and ambiguity the
probably the only downside of this is
because every type is immutable it does
it's likely to produce a bit more
garbage garbage it's not garbage if
you're still using it but it may produce
use more memory yes there'll be some
small things in Corrections in nine but
nothing major there aren't there any new
calendars on the list there you know if
there's some desperate if there's some
need that you think is there let me know
or file a bug it's pretty complete
well there any as many time zones is the
time tho database says there are so
there's at least 24 but I there's more
than that I mean all the name time zones
that are in the times on database are
accessible here so yes
no we haven't we haven't tried to
surface that it's I'm not sure how you
could do that reliably without sitting
on top of it and knowing that it was
changing and end up having some
independent notion of time versus the
system clock you have a particular
application for that in mind or just is
it's a it's a worry
yeah I think in this case you're going
to need to build that into your
infrastructure not now that one of the
things you can that that you could build
pervasively is the notion of clocks so
all of the types that you get it like
that there's a clock the clock is an
abstraction and you potentially could
build an implementation of a clock that
kept track that followed some other time
source then in your application you
would need to consistently use that
clock to create instances of like now
you know time but now so that every
every place where you needed to know
what the current time was you got it
from your clock source so there might be
something there where you could leverage
that within your app to hook your your
abstraction for what the underlying
clock should be to the rest of the
system all right anything else thank you
very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>