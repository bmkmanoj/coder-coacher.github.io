<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Introduction to Modular Development | Coder Coacher - Coaching Coders</title><meta content="Introduction to Modular Development - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Introduction to Modular Development</b></h2><h5 class="post__date">2016-09-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/2Hmrn_r-uJA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good afternoon welcome to this session
on introduction to modular development
I'm Alan Bateman
I'm the JDK this is number two five
sessions that we're doing a java one
this year on on modules and JDK nine and
you did the first one this just before
lunch I'm prepared for JDK nine that's
repeated tomorrow of the other talks
here are repeated as well I'll show a
slide at the end and with with reminders
just a little bit about some of the
background on what we call the
modularity landscape and so that you
have some idea what's going on for Java
C 9 so the module system itself is being
developed and through the Java community
process through jsr 376 and this is
targeted for Java C 9 mark Reinhold
sitting at the table here he leads this
GSR Java C 9 itself it has its own
umbrella GSR and that will own the
overall contents of the Java C 9 release
it will also own the marginalization of
the platform so for the first part of
this talk I just want to spend a few
minutes and talk about what it means to
be on a modular platform so this margin
graph that I'll show you is essentially
something that Java C 9 and we'll have
to standardize within open JDK we're
working on the implementation in project
jigsaw that could be the reference
implementation of the module system
there's a number of Jets or Java
enhancement proposals they're all
numbered if you google for them you'll
find them all that just that document
all of the detailed implementation
choices and command line flags and
everything else related to
implementation you'll find it all listed
in the undocumented in these Jets and
update it as we go along the important
thing to understand is that JDK 9 is not
completed yet it's not intended to ship
until 2017
that's quite a few things that are
undergoing design discussions and so
there would be there would be changes
before it chips no doubt so bear in mind
that as we go through some of the
examples and in this presentation I
split this into two parts I'm going to I
really introduced modules in the second
part but I want to start by talking
about and saying that module development
starts with a modular platform so I'm
going to talk about what it means to be
running on a modular platform this graph
in quotes is where we were with the JDK
back in the sort of JDK seven time frame
this looks pretty horrible there's not a
lot to say about us this is where we
were a couple of years ago before we put
in the effort to actually break up the
JDK into a set of cohesive modules and a
lot of progress has been made on that
the only thing to point out on this this
this this horrible slide with with with
cycles and all sorts of weird
dependencies is even back then in the
early days of marginalizing the JDK we
did identify that there had to be some
core module we called a base at the time
it's now called Java Basin in the
current module graph and this is the
graph that we have now for the standard
modules are the java c modules these are
the modules that are named with a name
starting with java dot something right
down the bottom you'll see Java dot base
that is the core of the system that is
where Java data Lang that objects lives
there's a couple of things to say about
this graph is is when you when you study
it for a few minutes is you will see
that for the most part there is only one
technology in each of the modules
there's a couple of areas that aren't
completely clean but for the most part
one technology per module the graph is
extremely hierarchical and that's partly
because we've got aggregator modules for
profiles in there
and but it's also hierarchical because
we Mabel to do a clean separation of
head folk and headless you can actually
take a subset of these Me's modules and
have a completely headless system
another important thing about this this
graph is there are no cycles this is and
this is this is this is important when
you get to some of the later
presentations I'm on the module system
and Alex's talk tomorrow under the hood
you'll get to hear more about this I've
only shown you here the modules that are
the standard module graph are as in the
Java dot star modules there's also a set
of modules for JDK specific their names
are start with JDK dot something and I'm
not showing them here just to keep the
glass at the graph readable now let's
take a JDK 9 build this is last week's
promoted build so every week there's an
early access build of JDK 9 this build
is build one three six so I'm just doing
Java dash version on it just to show
that it's real
that didn't come out right to this I
just do Java - er to run an existing
application I randomly picked the J
editor text editor it's it's it's a text
that a editor that has been written in
the Java language it's been around for a
long time I have absolutely no idea
whether the maintainer zuv of J edit
have to have tried out JDK 9 bills or
not I tried it out and it just works as
as it did in jdk age there's a few
issues on some platforms but it just
works at least on the Mac without any
issues the important point to take from
this is this is that that an application
and maybe it's using a bunch of
libraries if using supported api's it
should just work exactly as it did him
in jdk age there are a few issues and
they're covered in the prepare for JDK 9
talk that when I talk just before
lunchtime so here I am just looks for
the most part now it looks just like a
regular JDK let's look a little bit
further I'm calling a commute a new
command line option here - - list
- modules what this option does Java -
list modules is it lists down the
modules that are in the runtime image I
showed of a graph a few minutes ago I've
repeated it here on the right side of
the slide and what you're getting here
is just a list of all of the modules
that are in the runtime image and that's
just to show that this that it is the
system is actually made up of these
modules I can go further and I can give
to list modules a module name and it'll
give me more information to describe
those modules I mentioned java-based a
minute ago it's the core of the system
so if you can read this in it it says at
the top Java - list module space Java
dot base so I'm asking this asking the
the runtime to list the Java dot based
module and what you see here is a bunch
of exports and these are expressed in
terms of package names
the core module exports java.lang Java
Oh
Java net and all these other core
packages of the system that's what
java-based does it clearly defines these
are the supported packages and the api's
and the types are in those packages that
you can use which have a base I'm taking
another module here the Java desktop
module the Java desktop module is the
module where we have grouped all the
headful api's the the graphical user
interface not JavaFX more the
traditional in WT and swing api's so
when you look at the list of exports for
Java desktop you see java.awt all the
other there's a whole bunch of other sub
packages in the AWT or java.awt
namespace you'll also see javax.swing
and a bunch of other Ruy ones so it's
got exports exactly as Java base has and
just different set of packages right
down the bottom is the requires each of
the modules in the runtime describes
what its dependencies are the Java
desktop module requires Java base
everything requires Java base we'll see
this as we go through the presentation
it requires java xml there are some some
of the api's and for persisting beings
and things that are based on XML there's
a Java prefs because the jet the there's
part of the use the the api's can store
preferences and there's the data
transfer API that's that's the one that
exports the the DWTS data transfer API
so the important thing to is is that I
could go through every one of the
modules in this graph and I could get
this get specified them to to list
modules and I could see exactly what
api's did they export and what other
modules do they they depend on another
little thing as part of this
introduction I just want to mention the
Java linker mark showed this in the
keynote and where he used the Java
linker to create a small runtime that
only had the Java base module I think it
was it was a 64 bit image and I think it
was
compressed down to 17 megabytes so what
the Java linker is is a tool that links
a set of modules and creates a runtime
image in the in the earlier talk today I
talked about the modules completely blur
the historical distinction between what
we know was the Jerry and the JDK the
Jerry was just the run time in the past
the JDK was the run time plus tools in
the past now we now that everything is
broken into modules you can combine them
in different ways you can even link your
own modules in and I'll show this later
in the presentation
to create your own run time an image
that you can actually distribute that
runtime image and has has a bin
directory where you'll find tools like
the Java launcher it has a comfort
rectory which has the configuration this
is user editable configuration and then
there's other other parts of the runtime
image that are not intended to be edited
so let's run the the linker command just
to just if you have to didn't see this
in the keynote just to show what
actually happens so in this lick Galen
command + J link is the name of the
linker I give it a module path which is
just think of it as the directories on
the file system where it will find the
modules I'm telling it to add that
module named Java desktop I show that
module in the slide a couple of minutes
ago and I'm going to generate us into a
directory called my image and then once
that turns for a couple of seconds I'm
then going to type Java that lists
modules on that generated runtime image
and I see in there that it produced a
runtime image with only five modules if
you remember a few minutes ago I showed
the Java desktop module and at the end
is had this requires Java base required
XML required data transfer and so on
these are the modules that have been
linked together to produce this runtime
image now we go back to our little J
editor example that I used in one of the
first slides I'm going to use Java - gr
j edit and I'm going to run the J editor
and with this small runtime that I've
produced so if I only got platform
in this one time mark in image that I've
created and I can use this to run my
existing application so that is a that
is a huge step forward for distribution
because you can distribute a small
runtime with your application so that's
a quick summary of part one and which is
we've moved from this huge big monolith
that horrible big lots of dependencies
and cycles in the graph we've moved to a
set of mostly cohesive modules each of
the modules has a clear set of exports
we saw two examples and dependencies if
you if you stay on the class path
forever until you retire you will still
be using modules whether you know it or
not because the platform itself is is is
is modular and I've quickly just shown
you the the jailing tool to create your
own runtime image and with a small
subset of the platform modules so that
the tag line from this is modular
development starts with a modular
platform that's part one out of the way
I now want to start right back at the
beginning and introduce what modules are
particularly how you would actually go
and write a module yourself we start
with the concepts and start building up
and writing our own modules so this is a
very intently introduction to modules a
mess assuming that you've never seen
them before so starting with the basics
every module has a name in the previous
slides you shall Java basis on Java
desktop we saw a couple of more Java dot
star modules in this example my module
is gone then I'm going to start with is
called stats dot core assume that it's a
statistics library that fan I'm going to
be making into a module the code in a
module is organized by packages in this
example assume my module has two
packages comm Acme stats core clustering
cluster a sorry clustering and comm
Acme stats core regression these are the
packages that my code is organized in
this module I
just listed out to sample type names
there to give you an idea of types that
might be in this module in addition to
Java code my module may have resources
it may have native code it may have
configuration
it may have commands we're not going to
get into all of this in the introduction
but it your module may have those as
well the modules self description is
expressed in a source file called module
- info Java that is the module
declaration by convention this source
file is placed in the root directory of
your source code for the module so it's
like being right up at the top the
syntax for a module declaration is
module space and then the module name
and then we open curly brackets close
curly brackets we flesh this out in over
the next couple couple of slides we will
assume that our our stats core module
has a dependency on guava for this
presentation assumes guava is a module I
express that dependency with a requires
Clause so in my module declaration it
says requires guava if I start building
up a module graph on the right side of
the office of the the slide as we go
along we see a dependency on guava the
module will add in a second dependency
will assume that it depends on the Java
sequel module so this is a platform
module if you looked at the module graph
ice I showed earlier on Java sequel was
actually in there you just we went
through it quickly we didn't look at all
of the modules assume that the Java
sequel module is the module that exports
the Java sequel API or the JDBC API is
it sometimes known now we start a build
up a module graph here we've got our
we've got our three our three modules
and so we've got we've got our stat
score we've got our guava I'm going to
add one more module to the to the module
graph assume that we have a stats
see ally module command-line interface
assume it's it's a some kind of
command-line tool that makes use of the
stats core module and we assume sorry I
may may have introduced that in the last
slide this is the module that has the
dependency on Java SQL so we've gone a
number of modules that's called append a
service that CLI depends on on stats
core and Java sequel stats core depends
on guava every module depends on Java
base whether they declare it in their
module declaration are not because
everything ultimately is is is a
java.lang object now let's start
fleshing out this out a little bit more
and we start looking at the Java sequel
module if I were to do a list modules
Java sequel I would actually see that it
depends on java xml and a jet depends on
java logging the dependency on java xml
might be a surprise but if you look
closely in the java sequel package
you'll actually find there is the it's
ports and storing and xml in in
databases so therefore it depends on the
XML API when one module depends on
another module then we say that that
module reads the second module so this
is important is is the stats core module
depends on guava we say the stats core
reads guava stat CLI depends on stat
score we say that stat c-like reads m
stat score this readability relationship
which we build up over the next couple
of slides is actually the basis for
reliable configuration that marked
mentioned in the in the keynote so now
let's take a little subset of the module
graph and we'll just look at stat CLI
depends on Java sequel which ultimately
depends on java logging we add a little
bit of code to this so you can get an
idea as to what code might be in those
modules
it may be that let's see so let's start
with Java sequel first so it exports the
Java SQL package there's a type in that
package called driver anyone that sees
JDBC probably has heard of Java SQL
driver there's a method in in there it's
a public method public class that
returns a logger instance it's called
get parent logger let's suppose up in
stat CLI we've got some code that
creates a Java sequel driver and then
invokes its get parent logger and then a
load method so you've got some method
invocation chaining actually going on
here so how is this actually going to
work stat CLI only depends on Java
sequel therefore only reads Java sequel
what's happening with these types in the
in the logging module that stat CLI
doesn't know anything about if there is
nothing there's nothing in the code that
immediately tells you that it's using
the logging module now one way we could
do this is as we could we could change
stats eli's module declaration to have a
dependency direct dependency on java
logging that will work but it would be a
little bit disappointing as a user of
java sequel i do not know about all of
us are as a user of java sequel i don't
know anything about what its
dependencies might be so the module
system helps with this by introducing
and modifier called transitive so in the
jdk 9 public bills this is actually
called public in the early access build
for jigsaw is called transitive I
mentioned earlier on about JDK 9 not
being final but this is what the current
proposal is and what's in the jigsaw
early access bills so in the Java sequel
module and it's module declaration says
requires transitive Java logging what
this means is that anyone that depends
on Java sequel rial will read
Java logging so what so what we build up
now in a few seconds the readability
graph I'm stat CLI I require Java sequel
therefore I read Java sequel Java sequel
doesn't requires transitive and Java
logging therefore stat CLI reads Java
logging in alex is under the hood they
talked tomorrow he will go through a lot
more on this but this is what the
readability graph is so I started the
black the black edges in the graph just
think of it as a dependency graph when I
start adding the arms edges I've built
up here a readability graph that takes
into consideration the requires
transitive or implies readability as as
we call it ok so that's that that's
readability the next thing I want to
look at is is exports and then combine
things together to show how the supports
and accessibility so in addition to a
module having a requires clauses it can
also have exports clauses we saw that
with Java base we saw that with Java
Java desktop our module stats core will
export to packages that suppose it
exports the clustering and the
regression package that I showed in one
of the one of the first slides let's
suppose there is also an internal
package it's not part of the stats cores
API that package is calm acne stats core
internal essentially what we've done is
we've divided the types and the packages
in this library into two those that are
part of its public API and those are
internal nothing outside of that module
is intended to make use direct use of
them that it elects they're over the
comm Acme stats core internal makes it
this is a visual indication on this
slide to say none of the types in that
package are accessible outside of the
module now let's combine it with
readability that we saw a few minutes
ago stat CLI reads stat core remember it
doesn't require so therefore it reads it
if that's chlorines sorry if stat CLI
reads stat score then it can access any
of the public types in packages exported
by stat score it cannot read any it
cannot access any types in the internal
packages because they're not exported so
this is a two-way street
I read the module and the other module
exports some packages and that allows me
to access the public types in those
packages if if the if stat CLI does not
read stat score nothing in that module
is accessible
none of the public types not even in the
exported packages are accessible so this
is important to get if it reads it the
public types and the exported packages
are are accessible if it doesn't read it
they're not accessible so the big take
from this design and is that public no
longer implies accessible this is a
significant significant change to the to
the platform but it's because we're
retrofitting modules and to a mature
platform and this is the this is this is
this is how we do it with minimum
disruption okay there are the basic
concepts I now want to go through some
of the commands or take questions at the
end and as to how we're actually going
to compile modules and how we're going
to package them how we're going to run
them I want to go through some of the
commands to do all of these things we'll
start with our stats core module and we
are going to compile it so there's I've
got a bunch of source code that's
organized in a directory called SRC
stats core
important thing from this directory
structure to understand is I've put the
module name into the file path at the
top level directory of the module source
code I've got the module declaration and
also under stats core I've got all the
other classes that are for for all the
types that are in this module when I
compile it I get a class file for every
one of the Java files it's the familiar
and thing that we see where the output
directory written reflects the the same
structure and the same class files as as
you see in this in the source directory
ignoring additional classes that might
get generated for inner classes and so
on the Java C command that I'm using
here has a couple of options that you
may not have seen before the first is
the is is the - - module path this is
the option to the compiler to tell it
where to find dependencies remember our
stat score depends on guava where's it
going to find the guava module it's
going to find it on the module path so
for the examples as we build up here
assume that we have a directory of
modules in in the directories named EM
lip and we'll work through all of these
as as we go along so I'm just running
one Java C command and I'm compiling all
of the source code for this module and
into an output directory so a couple of
things just to say about module path is
that when I'm resolving dependencies I'm
going to find the these dependencies on
the module path the module path is not
equal to the class path it doesn't
suffer the all of the problems that the
class path that there's no splitting of
packages there's a whole bunch of issues
that the class path had we've learned
from all of those and have come up with
a much more reliable mechanism which is
the module path so when you were finding
modules you search download the module
path as before and they can be packaged
in different form they can be exploded
if there's two modules in the same
directory then
the module system will give up it's not
making a choice as to which which which
module you're looking for you have to
fix those kind of issues so it's not
it's this is actually very simple we
wouldn't go through some of this in the
the hack session on Wednesday I'll give
a link to that later on to show how the
module path is and how it works
the important thing is to understand is
that that's where modules are found and
it doesn't suffer the same problems as a
class path so now we're going to we'll
go and compile another module this time
we'll compile stat CLI so we've already
compiled and the the stats core module
that's compiled into the mods directory
we're now going to compile the stats Eli
stats Eli requires stat score and we're
giving a module path this time with two
directories and because this time we
want to be able to find the stat score
that we've compiled into the mods
directory as before you've gone from a
tree of Java files and you've generated
with the compiler a tree of class files
so the module info gets compiled as
before from from source into its binary
form which is module info dot class now
we've compiled our two modules that's
core and stats CLI let's run see the
stat CLI code as a module so this is our
command to run it now the first thing is
is I pull the trick here we've got a
short form of module path which is - P
so broader and having big long
command-line option I've replaced - -
module - path with - P because that is
the short form what you find in JDK 9 is
the new arc a lot of the new options
have a long form and a short form I've
switched to the short form and in this
slide I'm also using another short
option - M I'm telling it what the main
module is this will initially look a
little bit for both will shorten this as
we move through this through the next
few slides - M tells me tells tells the
runtime what the what the initial module
is and what the main class is so there's
two portions to this where will it find
the stat CLI module it'll find it on the
module path it'll load that module and
it'll locate the entry point
here which is calm acne stat CLI main so
we're actually executing code in the
module with with this command and that
little prompt welcome to stat CLI we'll
just assume that's what the the these
two runs when you restart now let's see
what's actually going on here so when I
type that command what actually went on
so remember this is this is our
dependency graph from a few minutes ago
stat CLI dependent stats course it also
depends on on stats SQL as I said
earlier every module depends on Java
base so therefore you have a edge and
from stat CLI to Java base here's the
full when I compute the transitive
closure this is the full dependency
graph as before this actually happens at
startup when you typed Java - M because
what happens is when it's attempted to
resolve the stat CLI module it's like oh
that depends on stat scored therefore
I've got to resolve that module that
depends on guava and so on so what
you've actually computed at startup when
I type Java - M is I've actually
computed the transitive closure in fact
has actually gone further it's actually
computed to the readability graph
remember the readability graph I've
added these additional engines because
of the requires transitive
so at startup when I did Java - Ian the
the runtime has produced this runtime
graph and resolved all of those modules
to ensure that they're there there they
can all be located on the module path or
in the runtime image so this is actually
what happens at startup so I can't
actually start up if something is
missing if I attempted to startup with
guava missing then I would get an error
at startup if you want to see more as to
what happens at startup there's a
there's a diagnostic option on the java
launcher which would print a little
trace we're gonna have to work on the
trace a bit better in jdk 9 but this is
a subset of what you would actually see
when you attempt to that command that I
did in the in the previous slide except
you get trace information as if locates
modules where does it locate them y and
y as well
right so everything so far I've compiled
and I've run but when I want to compile
things
everything's exploded on the file system
if I looked in the mods directory I see
stat score and I see lots of class files
that's a very inconvenient way to to
distribute an application or a library
as just a bunch of class files I want to
package it up into a jar file and we
have this notion of a modular jar a
modular jar is just a regular jar file
but it has a module in for that in the
top directory the top-level directory
and that that allows it to be to be used
in other ways I'll talk about that in a
few minutes but if you see a jar file it
has a module introduction the top-level
directory it is a modular jar file so
what I'm going to do on this car is I'm
using some of the newer options with the
jar tool to create a modular jar from
what I compiled previously so stats I'm
using this one to come to package up
stat CLI the modular jar I'm going to
create is is I'm going to create it into
the EM Lib directory and I'm going to
name the jar file stats CLI dot jar as
part of packaging up stat CLI I'm going
to specify what the main class is if
you're used to producing a an
application jar then you used to be able
to you're probably familiar with the the
main class attribute this is sort of the
equivalent for modules and I can
configure this with the with the main
class option to the jar tool so what
this does is this is all of the class
files that are in the mods that CLI I'm
going to package them all up create one
jar file stat CLI and that's on the
right the jar tool has a whole bunch of
new options in in JDK 9 I'm going to
just show you one of them here if you
find a jar file you can actually you can
you can give the name of the jar file
for our file patch of the jar tool and
give it the option print module
descriptor what that does is is is
it will give you it will describe the
module that's in that jar file in this
case it's our stat CLI module we can see
what does it depend on and and the stats
Eli has no exports it's just it's a tool
it's got no exports and it has a main
class so the jar tool is able to print
that out so that's that's useful and
when you get a bunch of jar files you
want to figure out what what modules are
in them okay now we've got our our stat
CLI has been packaged up it's in the EM
Lib directory I'm now starting to shrink
down like my my Java command a little
bit by just giving it the name of the
initial module a few minutes ago I had
my I specified - - m2 values the name of
the main module and the main class now
that I've packaged up the module I've
the module now knows what its name class
is I don't need to specify that anymore
so my command shrinks down I can just
tell it what the main module is - M
stats that CLI and it it will load the
main class from that module and
everything will get resolved as as
before
okay I haven't I've talked a little bit
about the module path and we're used to
the class path and one thing to be aware
of is you can mix them it is possible to
have to start or to compiler to run with
some code already as modules and some of
the code on the class path you can
combine them together now the code and
the modules of course can't depend on
anything that's on the class path or
what you might want to do and
particularly for migration is is is run
code on the class path but you're making
use of libraries that have already been
migrated to modules so this is where you
could where comes about where you will
want to combine the module path and the
class path together
so the orange little box here is that's
GUI assume that's that's that's that's a
graphical tool that makes you self this
that's core API that I'm that I'm using
the maintainer of that has not got
around to migrating that code yet to a
module you want to keep it on the class
pad for now because hasn't got around to
this yet all of the other libraries that
are used in this system are already
modules stats core has been migrated by
us in this session it makes use of guava
we've been assuming that's already being
migrated before before this session
starts and we have a couple of platform
modules so how am I gonna run this these
two together and here's a sample command
so I'm using - M I'm sorry - P short
form again of the module path I'm give
me the envelope directory where we've
got all of our modules in there so we've
got our guava we've got our stat score
we've got other modules in there and I'm
using - jar stats GUI jar so this is
where the main class for the stats
uie application is
there is there is nothing in stats goig
are to say that it depends on the module
stat score this is just a jar file it
has no dependency information I have to
I have to tell the system and that's
what this add modules option is here
this this application I'm going to run
is making use of a module stats core so
by combining these two together my main
class is on the class path no dependency
information I have to tell the system
that I need the stats core module to be
resolved so that is the reason for the
stat the add modules stat score if stats
Gy was migrated to a module then its
dependency information means that the
system would know to be able to resolve
stat score but there's nothing when I
keep that code on the command line now
let's get back to linking so ignore what
we wore with the stats GUI library for
now I'm going to start producing a
runtime image that has the stats CLI
module so this is a module that we have
compiled packaged and now I want to go
and create a runtime image for
distribution I could just distribute it
as a modular jar but assume that I want
to be able to distribute a complete
runtime that doesn't have a dependency I
don't want to have to ship a separate
JDK I just want to be able to reduce one
distribution with the jailing command so
I run the jail in command I give the
module path to and that tells it where
to find the modules there's there's two
locations are giving to the module path
one is where'd you find the platform
modules and they actually are in the JDK
download where do I find the other
modules that's the EM Lib directory I'm
giving an ADD add modules to tell which
modules to include in the runtime image
I want to include stats CLI and then I
give it an output directory which is the
location where of the the runtime image
that I want to create
that turns for a couple of seconds and I
get a runtime image that has one two
four seven modules in it at the
beginning of the presentation like I use
J link to create a runtime image with
only platform modules now I'm using the
the jailing tool to create a runtime
image that is a mix of platform modules
and a number of my own modules that that
I have written here so when I run Java -
list modules I get I see the names I see
the Java based logging sequel XML if you
remember the dependency graph that I had
earlier on these are those platform
modules you see there plus I said see my
three of my own my own modules stat CLI
and stats and stat score so that's a
sample
jaelyn command in the advanced slot talk
later on today we will actually go
through will actually have a couple of
examples that have more complicated and
interesting jailing commands and we can
talk about it on Wednesday at hack
session if anyone wants to come up and
talk about that so that's that's that's
it so in this section we've got I've
talked through the basic the the the
basic concepts a module has a name it
expresses its dependencies it may have
some it may have some exports you've
seen how we've turned a dependency graph
into a readability graphs you've seen
the the notion of implied readability or
requires transitive and hope in this
quick introduction you've seen some of
the the tooling and the image and the
updates to the java c command the jar
command the java launcher to be able to
give it a location of modules and so you
can see how to compile package and run
with modules and that's it so so I said
at the beginning that we have five five
sessions and so prepare for JDK 9 is
something we did just before lunch we
were pitting that tomorrow and the
advanced modularity talked Alex and I
are doing that I think in this room
later on today at 5:30 and alex is doing
the services and the underhood talks
tomorrow and we've got a hack session on
Wednesday at 8:30 if you want to bring
along your laptop and try things out or
just come along with questions so for
more information as I said at the
beginning we're working on the
implementation of this in project jigsaw
this is the link to the project page the
mailing list and where we have the the
early access downloads and so if people
have questions then please please come
up by Marc Rhino Liz is at the table
here and I would hope will help answer
questions
hello yes
okay I'm curious about how JDK 9s module
approach compares to OSGi what would be
the advantages over using JD Ches module
approach I - the dawn I might be on this
one hello yes
right no he left okay never mind me oh
you're here so so so OSGi is is is more
than a module so I give you a very brief
answer it's a deep topic Oster has much
more than a module system it's a
security layer and a services layer and
a bunch of other stuff and it doesn't I
never reloading lots of fancy things
which some applications need but many
don't the model system we're designing
for you know to be the standard model
system for Java doesn't have all of
those capabilities but it has a bunch of
additional capabilities namely you can
actually use it to modularize the
platform itself which you couldn't do
with those GIS guys built on top of Java
right and we need to modularize all the
way down into it which is why modules
are a fundamental new program component
in this design rather than loading you
know the class loaders with some fancy
stuff around them so SGI works perfectly
fine on top of nine and and that's is
intended to keep working forever if you
need to use it you know keep keep using
it it's a good solution for some
problems but not for everybody that's
that's the quickie answer I could fire
up JVM and test this myself but it's
easier to ask experts
what happened lazy what happens if an
exported class tries to expose in the
API and internal class that is not
exposed through the module to make sense
yeah your users will be unhappy well
will we will we get an error at compile
time or will that just be at runtime
when the application craters so some of
those cases can be ejected to detect
at compile-time if they're not they will
definitely be detected around them okay
one thing just to keep in mind is is
that it is very normal to have an API
that returns back some internal
implementation that implements something
that is exported so this is it's it's
very normal for me to and I was using
the Java sequel driver there for you to
have a reference to a driver but it's
it's some internal I don't know Oracle
database driver type that's in non
exporter package that that kind of thing
is normal I think what your scenario is
is is what Mark was getting to where's
you make it you make an error in your
signature of your method and you end up
having public driver in pull get driver
or something like that and that's
something that can be detected at
compile time as long as the term as long
as the return type is available to
whoever's using your module way return
type could be defined in some other
module that's fine thank you I'm just
curious about the transitive
requirements how you determine what to
declare as transitive versus not how do
you know what people are gonna need
access to so the the simple answer is
and this actually relates to the
previous question if if you're we if you
have an API that's that's using
basically types from some other module
in in its API you have a you have a
method that returns you know a type food
that came from some to some completely
other module then it's probably helpful
to your users for you to require
transitive that module if not they'll
have to do it themselves right make
sense
I have the questions so we know we are
using Gradle 2 more too much manage the
version right now so looks like modules
company has to replace their Gradle so
my question is I can see now we put
everything into a jar at the module so
is that something overlap when we should
using the module because that we don't
manage jars do either of us know enough
about Gradle to answer that question I
think there's actually one or two Gradle
sessions that which actually talks about
JDK and JDK 9 support Java 1 and so the
module system doesn't replace Gradle and
I I think it'd be better to bring up
some of those questions at the Gradle
sessions ok thanks in in general our our
whole approach is to work it is to
design something that will work well
with existing tools so it's designed to
work well with maven and Gradle and and
everything else we're not trying to
replace those existing systems thank you
thank you does j-link work
cross-platform can I create a yes yeah
yes yes it does and we had a few issues
and what they believe have all been
resolved and does that mean that the
thing I did the final product that gets
produced will run on any platform or
does that mean I have to specify that I
want to export to spark or to armor ok
jaelyn figures out what your target
platform is based on the platform
modules that you're linking in so if
you're on Mac and you're and you give it
a module path to a Windows distribution
then it it will actually link in the
Windows versions of those modules and
produce you a Windows runtime that will
only run on one Windows ok so it really
comes down to which Java base you point
out correct that that's it exactly
ok yeah Bob actually Mandy's her in the
front row is just pointing out that Bob
Vendetta who works on embedded gave a
talk but he actually his talk was this
morning where he actually was actually
doing some demos of compile cross
compiling are so cross-linking to
embedded platforms
I was learning how to hack my toothbrush
thank you so I have a question I related
to immigration
so you said from immigration purpose you
have option to use modular path and
cross paths at the same time and models
will not be able to use libraries from
class bus but libraries from class bus
will be able to use classes from models
right so if it depends on something I
cannot start to use models in my
projects until guys till high school
these libraries will migrate them right
this is a really really good question
and in our in our in our in our talk at
5:30 we will be talking about migration
and particularly Brown automatic modules
that allow you to migrate to modules
without depending without waiting for
everyone else to move to modules first
so come along to 5:30 we have a lot of
session a lot of slides on this exact
topic does the module system solve er
hell we we hope so that is that is one
of the primary goals and how does it do
that
where you are in the room right right
but it didn't say any versioning besides
maybe the at 9:00 to suggest that might
be versioning oh well if if the solution
for jar hell you're looking for is it
involves version numbers then no we're
not solving that problem and that's and
that's related to the answer he gave a
minute ago about fitting in with
existing tools so jerk jerk jar hell
like any pejorative term has many
different meanings right the jar haw
problem that with that we are out to
solve is the one of okay you've got a
zillion jar files on the classpath I
mean you know we've seen new Oracle
internal products with more than a
thousand jars it's like wow does is he
how does it even work you can't figure
out what that you you can't tell when
there are conflicts you can't tell them
said things are missing you can't tell
when it's safe to replace something
that's that's the particular form of jar
hell
we're trying to to giveaway out of and
once you once you once you can get to a
same module graph then you have good
answers to all of those questions and
you don't have the chaos of the class
path now as two versions there there are
are lots of reasons why we're not why
did this module system does not have
versions in terms of it doesn't have
version constraints you can stick a
version on a module as as basically its
documentation and it gets carried around
will be reported in stack stack traces
and and things like that because it's
very useful to know well code came from
you know version of what of what module
but there is no way and this is
intentional in the module declaration to
say that you know this module acts
requires version one you know some
version between 1.2 and 3.9 of why but
but not know but but never to dot 4.1
because I know because I know that
what's broken right the very the very
early prototypes of jigsaw we we
actually were solved we're trying to
solve that problem and we realized wait
a minute maven solves this problem
Gradle solves this problem other system
solve it solve this problem now maybe
they don't those existing systems don't
solve the problem in the theoretically
optimal way but you know what millions
of people use these tools already and to
be and to try to displace that would
just be a fool's errand so this module
system works with the concept of the
module path which is a way to find
modules and we would rely on your build
system whether it's whether it's maven
or Gradle or make files or you know take
your pick to make sure that the correct
versions of things you have are on that
path and just just add just even just
something very very practical is suppose
you have a bunch of jar files on your
underpants path today that are either
different versions of the same library
or the or happen to be using the same
package or whatever it might be
try that with the module system and as
modules on the module path and it will
not allow these it will detect these
kind of split package issues that's you
won't even start up it'll there if
you've got issues there are if you've
got two versions of the same mod
and then it will pick whatever the first
one is and on your module path it will
never it will completely ignore all the
other versions that you might have so
there's an you've got no scenario where
to be trying to load some parts of quani
or example here come Acme stats core
from this jar file and more from it from
this other jar file that just doesn't
happen with modules related to that if
you're mixing a class Pat back with a
modular app so in your example you
pulled in guava
so if I have guava on the class path as
well as embedded within a module okay so
my module wins so if my app is the class
path app right in it it requires guava
then it's pulling the version of guava
from the module so my app is on the
class path so it doesn't require
anything if there's nothing in in your
Maya just say what it depends on so
we're out of the box we assume that when
you're running things on the class path
that you just require any of the modules
in the in the runtime images of export
API okay but but I can also have a
dependency on a local jar file in the
class path that could be a guava version
right yes it could
so if I do that and then guava is also
packaged up in one of the modules then
what happens so in that scenario
nobody requires guava because there's
there's no module that has requires
guava here and the your module path
isn't even being looked at here unless
you give it an ADD modules to tell it
that you want the guava module to be
resolved so you might remember in the in
the in in the slide we had to do enact
modules that's core in order to ensure
that that module was resolved if you do
that modules guava then the guava module
will be used the guava dejar and your
class path will be ignored
to go back a little bit just to be clear
if I had to if I had a module depend on
two different modules and each of those
modules is dependent upon a different
version of a same module it's going to
kill it knock it out and say hey this
isn't even allowed yes okay if they're
you know if you're if you're doing
something sophisticated like record
writing an app server there's some
advanced features of the module system
that let you support that kind of
scenario but in practical use you know
for for for smaller less sophisticated
applications which as most of them hit
that better it's not needed you know in
generally if today you have two
different versions of library on your
class path you're already in trouble you
just might not know yet
so I had a question I had a question in
regard to you had a slide where you made
a very strong statement that public does
not mean accessible what about for like
reflection so can reflections still peek
under the hood and violate all your
system of trying to hide things cleanly
so core reflection has been specified
for 20 years to do the same exactly the
same access tricks as the language and
the VM and that and that continues so
with with strong cops at capsulation
then even your public typed in your non
exported packages can't be broken into
with good core reflection so you have to
explicitly export them in claire as a
tenancy and if they support them to make
them reflect right exactly and there's
also another concept on on the table I
didn't go through in the introduction
talk but Alex will touch on that today
in the advance talk and that is sort of
designed for especially for applications
and other libraries then that are
intended to be deeply reflected on by by
other libraries so Alex will touch on
that this afternoon and the advance talk
the quick teaser is is there's a way
that there's basically a way to export
you can export a package and you can
also say don't not only export a package
but let reflection get into my internals
as well because I you no good because
you're expecting this module to be
supported by you know JPA or something
yep I think we're done here thanks for
attending thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>