<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Oracle's Modern Microservices Strategy: An Opinionated Platform on Kubernetes | Coder Coacher - Coaching Coders</title><meta content="Oracle's Modern Microservices Strategy: An Opinionated Platform on Kubernetes - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Oracle's Modern Microservices Strategy: An Opinionated Platform on Kubernetes</b></h2><h5 class="post__date">2017-10-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/5Jnp9uGx4aA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so let's get started alright so welcome
everybody um there's a session about
Oracle's motor and micro services
strategy so how many of you have heard
about kubernetes come on
how many of you have heard about docker
there you go
so what we going to talk about today
it's basically an opinionated platform
that we build on communities mainly
based out of the CNC at state I'm my
name is Marshall I actually came from
Microsoft about a year ago where I was
working on a micro services platforms
and I'm having with me cloud you build a
dough I'm a long time Microsoft guy that
decided to to do something are different
so I'm working with Boris on the micro
service platform more from a product
strategy point of view all right cool
with that let's get started so from an
agenda perspective thought I'd talk
quickly about the motivation so what
actually drove like the design of the
platform why did we do that
right because there are a lot of
approaches out there then we're going to
talk about our stack so that it get an
idea of what we what components were
using what we added and things like that
and then hopefully we can give you a
demo I'm saying hopefully because we
have some serious Network issues that's
why we have our Handy's here or our cell
phones not because we want to take calls
but we may need to switch to them as a
hotspot so we have a fairly good demo
and then in the end we'll give you a
roadmap of how we think to roll out that
platform sounds good
all right so the motivation as I
mentioned before like having done that
as my Microsoft so spending having spent
like three and a half years with micro
services now this whole container thing
came in and you run containers and
orchestrators like kubernetes dcs or
swarm while there is a huge boss around
micro services what we discovered is
when a lot of people enter the micro
services world they're not really aware
of either and and during a distributed
computing world so there are a lot of
patterns
they need to know in a distributed
computing world that are different and
what they used to have before then use
you you throw like container
Orchestrator in the mix and then you
have another problem to the equation
because most of you have used kubernetes
you use docker raid and you may know
that your service resource right doesn't
represent the service inside your
container right it's just a pointer to
the endpoint so you technically don't
have a direct relation between the code
the actual service code in your
container and the endpoint or the
service resource in proven it is so
that's one of the problems that we that
we discovered so there's still a lot
developers really need to know when they
wanted to when they really want to build
micro services on top of kubernetes wait
so they need to basically understand
certain concept then the lack of focus
on developers or focus for developers on
that makes onboarding expensive because
if he's never what we've seen with
customers if you've never dealt with
containers right or orchestrators it's
quite a hurdle to get there right I give
you one example what I've seen in the
past is like containerization great I'm
gonna put a container I've got to put a
service in a container and then you end
up with like a gigabyte size container
in this raid so you could take a VM
instead of that so there are some
certain things you need to know right
that you use Alpine images and things
like that to make it work because if you
scale out it spins up faster and things
so the onboarding cost for developers
who've never dealt with that is is
really high and is expensive then the
other thing is if you run micro services
increment it is in a cloud environment
it is in a cloud environment like Oracle
cloud or like AWS or Google in any cloud
environment I mean a lot of customers
don't want to build their Redis service
on that kubernetes cluster right because
now you need to deal with persistent
volumes and things like that
and the cloud providers they offer you
those manage services so what that means
is your micro services application at
that point really consists of your micro
services that running in containers but
also you're consuming like managed
services from a cloud provider for
example so - why are those things are to
consume them it's not
just like an endpoint you also need to
configure security and things like that
so that's kind of hard then the other
thing what we've noticed is like
obviously server less and in functions
is gaining a lot of popularity right but
it's not necessarily in evolution you go
you're not going from micro services to
functions it's actually like in like and
better together right you if you think
about a modern hybrid architecture it's
actually a micro service and the
function way because functions are
typically short-lived you fire something
off and you forget it right so they're
very little platforms out there that
currently support running micro services
containerized micro services and
functions on the same thing so that's
another thing then obviously you're in a
distributed system and then like having
a cohesive diagnostic story starting
from like I have Diagnostics tracing in
my code all the way to like network
tracing seeing how the services
communicate with each other it's also
fairly expensive to do that I mean there
are solutions out there but there no not
really like full end-to-end solutions
that work like that and then again
there's some turnkey micro services
platforms and they like openness right
because what we've learned from
customers is that after time wants to
get used to as micro services they want
to do like certain configurations
replace components and things like that
so that's why we things like openness is
good so those were the problems
specifically with kubernetes I
personally think kubernetes is the best
container Orchestrator to run my
container as micro services on top of it
because it gets really close to what the
development right but then again as I
mentioned before you still running into
a lot of things that the developers need
to deal with right so for example
service API discovery I mentioned that
before the other thing is like in
resiliency in general right how many of
you have are using retries and circuit
breakers how many of you know what a
circuit breaker is or retry okay so
those are essential things in a micro
services architecture right because
you're like you're having network
traffic your network may break away you
service that you calling may be super
healthy right so you need to deal with
that and then you cannot just do it over
and over again you need to break so
those are things developers usually need
to implement right because it's not part
of the platform that's a nation the
other thing is Diagnostics as I
mentioned before the good thing is two
good news like in the open source world
there are actually components and a
stack is evolving that addresses all the
all the issues for developers it's
becoming more and more
developer-friendly
so from our perspective what we did is
we put together a stack as we call it
and as I mentioned we used a bunch of
open source packages so the way we're
gonna roll this out and the way we're
gonna start is we will have a set of
curated we call it a curated package of
open source components what we have in
there is for example is do how many of
you have heard about you steel cool few
if you as a service match that helps
with things like retries resiliency
feature is routing complex routing
scenarios diagnostics and things like
that so we added that because by doing
that we can put complexity out then we
also leveraging the open service broker
API that's part of the kubernetes
service catalog and that's good for
consuming external services then we
build our own component and we'll show
you why which we call API catalog or API
registry we haven't fully figured out a
name as you can tell so currently and
that's why we say API catalog I think on
an exponent API registry same thing just
saying that but what that is is it
basically allows you to have a very
developer API first driven approach to
micro services and that's what we're
gonna demo and we built that obviously
not from scratch you may have heard that
we acquired apiary Oracle acquired a
Peary and we're using a lot of their
open source components to actually
implement that API and then we have
diagnostics and operations out of the
box because because of that mesh that I
mentioned East year we get a lot of
diagnostics data for free right and we
just put that into Prometheus and then
we show that in
in a graph on a dashboard and the other
thing we're doing is there's mr. L which
is a Netflix component which is they use
for intuitive computing and basically
shows you the flow will show that in a
second so we put that together nicely as
a stack so the value we are adding here
is really not just that we give you a
bundle of open source components to try
out but we are also changing the
approach we're also thinking about a
different approach and that's really
like an API first approach for
developers to build micro services and
that's what we're trying to demo and
show today so I'm gonna hand it over to
Claudia because we also drew a nice
diagram that actually shows that in more
detail and I have so yeah what Boris
just said is basically what I have here
on my t-shirt there your goal for Boris
and is actually to going after the Nobel
Prize because we want to build a unified
theory of micro service development in
the modern world and this is exactly
what this is about right so we are as
bodies were saying we're based on
kubernetes kubernetes is provide us the
orchestration the ability to is a cue to
deploy containers okay but as Boris was
saying this is not an office is very
infrastructure focus how developers need
to know about the containers they need
to know figuring out how to wire them
together in order to build an end-to-end
solution so on top of that we add the
service mesh so the ability to control
our micro services talk to each other in
a sense without having to do specific
implementation or changes to the
implementation in order to achieve that
specific routing or a policy or
potentially even after the the system is
deployed micro services deployed been
able to change the routing policies on
the flight think about a/b testing this
type of thing canary deployment and so
on these are all things that are very
very common in this in these days and
then on top of that we are basically
with the idea of focusing more about a
developer putting the developer in
charge we basically build these
components one is the service broker so
the ability to onboard the
or external services in such a way that
are easier to use for micro service a
developer that is that wants to run in
the cluster think about for instance the
ability to connect to an external
service and having the service broker to
manage the entire secrets all the
parameters or the configuration that
needs to be used in such a way that as a
developer I just need to know that this
is the secret that I need to use and
everything is taking care for me and
then we we also added the what bodies
were saying basically is not about
service versus micro service is more
about combining them together in a sense
they are a sort of two extreme of a
spectrum right so I have something I
have some code i package it in what in
the old days was a VM now is a docker
container and then on the other far end
of the spectrum you have something like
a simple function so if we can unified
the developer experience in such a way
that the developer can decide if you
know in some cases use a micro service
or container in other cases about a
function event-driven type of thing but
running on the same infrastructure and
using a consistent developer experience
that I think that we can add a lot of
value there right and then on top we
have the API first approach so today
when you look at the micro service
basically you see a micro service as IP
address a name and a port but nobody is
telling you what that micro serve is
actually exposing from an interface from
a communication point of view so what we
want to do is to provide a way for
developers to express the interface side
of a micro service in such a way that we
consume it at Microsoft's know exactly
how to do that right so basically adding
an interface an API layer on top of
micro services and then the clearly the
other two aspect is the integration with
the Diagnostics so provide a way for a
developer that is looking at the complex
network of micro services look at them
as for instance data flowing through
this
services and not always as poor the
containers and VMs right because that is
you might need to go to that level of
details but for a lot of scenarios you
don't need to go that far right so you
just need to speak for instance the
ability to see data flowing through
services maybe I have tracing
information that tells me exactly how
the time is spent right that is probably
what a developer needs right as a way to
diagnose and troubleshoot some of these
problems and then the other final aspect
is the CDI infrastructure so the ability
to really have a full integrated
pipeline that start from you know
checking in some code running some sort
of a pipeline that do some testing
packaging building the containers and
then with our platform also the ability
to for instance do all the configuration
that is required so for instance that I
have a complex system I have multiple
containers at the same time I am I using
you know service brokers maybe a my
sequel external my sequel or Oracle
database externally being able to
express all those components in one
single deployment package that is what
we we achieve right what we want you to
do in such a way that when I say ok
deploy this thing that is going to take
off take care of everything
api's micro services functions and
service brokers ok and then the idea is
also that by building this entire
infrastructure in one single platform
that is kubernetes we can basically
offer a different level of controls
based on what developer needs to do I'm
I want to be more in the eye
productivity really free 100% focus on
quote unquote the business logic I can
use the api's and I focus on that I'm a
developer that needs to have a
fine-grained control over all the micro
services Errani in the cluster you can
still do that because they did is not we
are sort of hiding some of the details
but they are there so a developer can go
and really do a define tuning if if
necessary ok so I think that is pretty
much
what it is and then what if you want to
yeah so we have about 80 more slides
where we talk about that stuff not just
so it's Christmas Lee now what we're
doing right
I don't think so we gonna switch over
we're gonna do a demo like enter and
pretty much like everything we described
we're gonna do a demo now and then we'll
talk about the roadmap this sound good
cool all right let's switch over so
Claudia's gonna start the demo my to
working okay so this is relatively
simple right now we are basically two
two microservices we have really wanted
to work on I'm more of a kind guy so I'm
actually working on the backend side so
we basically have an application I'm I
have a service that is going to connect
to github get some statistics about the
Java communities how the the Java
community is alive you know number of
stars number of who means the number of
events we aggregate all these metrics
together in such a way the boards then
can build a very nice UI on top of it
right so I'm not going to spend time in
actual the code itself so I have here my
my IntelliJ stuff there is some code
that is running right so in a typical
scenario I'm a developer I have the code
I check it in here just to to show you
you build a container can you guys see
sorry can you guys see this in the back
yeah bigger yep a little bigger so dim
the light guys on the back I don't know
if they can do that
yes no you okay so basically typically
you build a container and then you can
imagine that in a pipeline actually you
have you know it's done by Jenkins who
worker or any other sort of a system
then once you have the the container
done the thing that we do you deploy the
container so let me go here and then I
have basically my deployment files this
is what typically you do in kubernetes
so I'm using the command line so create
and then I want to deploy the version
two that is the first one that we're
going to deploy so this what if this is
do is basically if you're familiar with
kubernetes for the people that are not
is basically taking a file that describe
how my service is should look like so
what is the container what are the ports
I want to set it up and he's actually
going and do a deployment okay once I've
done that the next thing that I want to
do is I want to expose that as a service
so this is a something that could be
included in a previous file but I want
to make it an explicit sort of action so
I have a container that is running
somewhere in the cluster the problem is
that the container might be rebooted it
might be running on a different node
over time so what this service does is
to provide a stable endpoint okay and
this is what developers do today
basically give me an IP address and a
port that I can use to connect to one or
more you know docker containers that are
you know running behind it okay so this
is what you do today as a kubernetes
developer right as a standard are what
we are adding on top of that is I want
to make sure that Boris can actually use
my service without actually asking me
anything because I want to go home now
right so the thing is I give you
everything that they know so if you are
familiar with the Boris mention API
this is this company that Oracle
acquired that is quote-unquote in the
business of
managing api's so they have this online
tool that is about four four teams of
people actually designing the api's so
you can see here there is this very
simple markdown format that specifies
the API that I'm actually going to
provide automatically you get you know
the documentation out of it you can
imagine that in the future we will have
a better integration but for now what I
do is I take this part that is the
actual definition of the interfaces and
by using our a UI that is part of our
micro service platform I'm going to
register that API so I'm making the VI a
sort of known within the cluster
actually let's solve this I'm already
here so I take and what I do is I take
that time defile what is AP is v2 that
is the MD file that I just copy from the
apiary website this is the version two
and then now what I do I register this
API so this means that within the
context of the cluster I I specify that
this is an interface that developer can
use next that clearly I have an
interface I need some how to bind it for
service right so what I'm doing here is
I go to and associate to a running
service and there is my github v2 right
and then basically at this point there
is an interface associated with the
running service okay I think this is
there all I need to do so we okay
I was expecting to do anything
so this is our developer console right
and that's what you get and obviously we
have full CLI supports CLI support will
be implemented or is currently
implemented as a plugin into cube CT ah
so you get all the security and stuff
but we just added things to it because
for example registering an API
descriptor and things like that is not
part of proven it is great okay so I
have this nice thing and then I have
this users
- what oh yeah yeah so I have I have our
developer console and what I see is a
user service which is basically just the
service Claudio has deployed velocity
API right so I just want to mention the
deployment of that services kubernetes
standard right for those of you have
used kubernetes there is no special
thing to it really the only special
thing we've done here is associate a
service with an api description ok so
cool I go in here and I say I want to
consume the github stat service and then
if I can do this and the network works
yes so cool I have that one and in this
one here we've done the Associated API
so I can see there is an API associated
with it I go to the API and what I get
in the API is I would get all api's that
are basically registered in that system
okay in that case we only have that API
and so I click on github stats API and I
see it there it's associated with that
service and then I'm going to go a few
API so what's happening now is just to
make this absolutely clear before I
would have had talked to him said okay
what's your service resource which port
is it listening right and what are you
returning what what are the methods I
can call on your service right so right
now I don't need to do that anymore I
have everything there so in here I have
this nice little API description and I
could even take it one step further and
basically start mark services and things
like that but I'm not gonna do this the
cool the cool thing is now what I'm
gonna do is I download a client library
so in our initial release or we support
Java twice and JavaScript twice right so
you gotta make a decision which one you
want no it's a it's about right so in
our initial release we support Java in
JavaScript obviously okay so I'm going
to download that thing and it pulls it
down and if I go to my downloads folder
here I can see
it's here and then I basically unzip it
go back and then just to show you guys
that is this real cannot make this
bigger generated code trust me it's
there it's real right so what I can do
now is I have as cloud you mentioned I'm
a gifted web developer which I'm not I
mean I'm really someone else did that
for me okay so but I have a map that I
want to connect to that back-end service
okay that map code we have already
written in we've written that in react
and it's the project here okay so what
I'm what I'm gonna do now is very simply
I go to my command line and I wrote a
nice little script which basically
copies the content and just adds it as a
node module to my project so that I can
use it right so I'm gonna do this copied
over done oho oh yeah you know what a
problem is so good at Java I generated a
Java thing so I want to obviously I'm
gonna use a Java Script
now I'm gonna download that thing again
go back here and then I have this one
extracted it and now I have my
JavaScript code right now I have my
JavaScript time I'm going back here
trying to run it again and it happened
it copied it over so now I go back to my
project here I have the node modules and
I have a thing here added when I copied
it it's called aura client and here's
all this stuff so all I need to do now
theoretically is I basically go in here
import it right and then further way
down there I go and create an object of
it just to retrieve the data and if I
ever get to that point where I have to
do this it's here right so what the key
point is
I haven't entered anything right have
you noticed that I have it's it's very
dynamic right I basically generate
generate a client library and now me as
like the web developer of that great map
that I'm going to show you I'm able to
use that saying just at the client
library and it will talk to cloud your
service okay so the next step is in here
obviously I'm gonna go there and do a
darker build I don't know if you notice
the difference right between figuring
out you know
okay service name port every standpoint
parts of the data request response type
of thing versus an experience like that
where we encapsulate old the logic that
is needed in order to connect to you
know the service imagine something that
is actually doing that dynamically so by
the time that we call that that client
library we can figure out where the
service is running and potentially if
it's not running right and then
basically make the experience as simple
as basically calling a method on a class
right so that is the type of experience
that we want to enable so while we're
waiting again I think the network is
flaky because what it does I'm I'm just
trying to generate a docker container
build it the good thing is I'm prepared
we already have a prepared docker
container good I mean I assume you know
what's coming right it's building the
docker container i version the container
with version 6 I'm going to update my
deployment kubernetes deployment llamÃ³
file and then I push it out make sense
yes no cool all right I don't know what
let's get out of that so in here of my
map deployment if I go in here I have
map server for I'm gonna go to 6 and
then I'm going to go back to my thing
here and I say cube CTL create dash F
and then I say map and we have version
to dodge a mo and then I'm going to
deploy this thing
divert all right so as you've seen it's
it's very simple now I don't need to
know anything about kubernetes if I
don't want to write I just literally
generated a client library edited to my
project and in this step typically if
you're confused by that it's typically
done by a CI right once I check in my
code the CI step builds the docker image
and the CD step deploys it into
production or into a staging system cool
done that let's look at the application
it's going here you wanna see that and
there is the map and so what the map
does is you may see that it's changing
the color right so what it does right
now is if I click on a state it actually
shows which state has the most Java
projects on github and it see it
basically shows some contribution there
like commit stars and stuff like that
okay cool
was that easy or what are you guys
saying was that cool no I don't know yet
okay all right so we've done that and
now the next step is we want to create a
new version of this make sense right
because what we want to do here is we
want to create a version two where we
actually have the cash data of github
and I can go back in time with the
slider and you wanna do this yes so okay
we follow sort of the same process I
have again my code here I what I want to
do basically the goal is to give the
customers the ability users the ability
to go back in history okay so it is to
have some sort of a slider again you
know you can move back and forth and
Susie are actually out of the map works
so what I need to do is basically to
provide the ability to store the data
while I'm actually query it love github
i real-time so I am basically mice the
same service I add a little bit of code
I'm not going through that same process
I build a docker image and now what I
want to do is to deploy this container
so I will do the exact same thing that
I'm doing that I done before so cube
cattle created a chef and this time I'm
going to release the Version three okay
so if I go in my list of pods that are
running in our cluster we have a lot of
things that works that there's running
but you see that here I have basically
two versions of the innocence the same
service right so what I want to do now
is number one to give Boris the ability
to create to update the service so again
I'm going through the same process again
very quickly I get and I deploy now the
version 3 of the API that is a little
bit different than the previous one v3
and then basically
oh and trust me you don't want to see me
writing that code again so we basically
all I do is I deploy in other words not
the map now right think about we have a
new version of the map of the front end
that it has a slider in there and I've
basically follow the same steps that
I've done before download a client
library put it into that new map the
tube or v3 project and deploy it so the
way I mean I just do this we could
actually skip down yeah I do cute cattle
create their chef and then again before
I said we already prepared that for time
purposes
yamo and I'm going to deployed a new ok
so now if I go back because what's
happened actually now I have two
versions of the same app running right
so how many people of you have dealt
with that like testing and production
canary deployments and things like that
so the next step is ok I have two
versions running if I go in here I'm
still getting my version one right so
now typically I would need to start like
doing the routing stuff
it's typically very complicated to do
this what I'm going to ask Claudia now
is to route traffic to my new version so
you guys can see our new version of the
map how great that is
there we are same pod so just to give
you an idea this is the the two front
ends the two version I have here my two
back ends and now what we can do with
the service mesh infrastructure actually
to start deciding how we want to route
traffic okay
so number one I want to set up the
backend side so I want to all the
traffic and again you can define
different policies if you want to do a/b
testing maybe 50% on one version or or
whatever is the right now I'm going to
move all the traffic from v2 that is
currently right now to v3 in such a way
that the new api's are going to be
available right so I'm going to using
sto mr. CTL and then I do replace
because I already have okay
so what this is doing is basically
changing the traffic Stalag is do
everything or incoming traffic request
that is coming in goes to v3 right and
now I need to do the same thing on the
front end in such a way that we can
actually see the new version so I will
do the same thing I have a different
rule clearly map v3 routing and there
you are now if refresh the should be
able to see so I think the key here is
two things right you've seen a new
command line is your CTL that obviously
is gonna be like we build a wrap around
that so that you don't need to deal with
like those but the key point here is
there is no we didn't mess with any load
balancers whatsoever right we literally
just applied a rule routing rules and
they were typically defined in a in a
JSON file and all claudia has done was
uploading adjacent file and saying okay
route the traffic to versions
that's all it is it's actually really
powerful if you think about you want to
automate like a bee testing and things
like that right so if I go in here now
then I have this so this is my version 3
as you've seen I've just refreshed my
page right and then if I go in here I
still see the commit and then I can
slide and I can actually go back in time
can I actually go back in time that's
it's a cool map right alright so but you
get the idea right very simple because
modern micro services requires you've
run multiple versions of the same
service right you want to do some
routing and things like that and that's
all just implement it right and all you
need to do is basically applies on all
but another key component of micro
services is really Diagnostics right ok
so cool going back to my going back to
my homepage oh I gave it away and need
to give it away so let's go back to my
micro Services Platform homepage so what
we have up here is a nice monitoring and
traffic map right so monitoring if I go
to the monitoring thing which I've just
done
we'll get that graph on a dashboard that
I was mentioning before right and the
cool thing here is it basically we
customized it a little bit really
tailored to the micro services or yeah
micro services that are getting deployed
into that cluster right if I look down
there
I see all the micro services that are
currently deployed I see basically the
activity map
I see the activity map github stats
those are the services that we are using
we have another bunch of services in
here so that's already there and what I
meant before was like saying we're it's
it's a really open platform obviously
you can customize all of them
but the beauty here is we haven't added
any tracing code to our project or to
our services right now right this is the
data I'm getting from the service mesh
from issue which is pretty cool because
as soon as you deploy a kubernetes
service and a part into our into our
platform what's happening under the
covers is we inject a sidecar in the
sidecar like is Android based and it
basically does all that magic for us it
intercepts a traffic
princess so that's kind of cool and then
what
a frequent requirement that I got when I
was working on other micro services
platforms before was like hey I really
want to see the micro services flow
right I want to know how does Hubble
sync flow and if there is back it just
dropped and so on and so forth so then I
went to a meet-up and I saw visceral
which is a component from Netflix and
they call it intuitive computing right
and we said oh cool we gonna we gonna
take this visceral component and make it
work with our platform and the result of
that is actually this so this is now a
snapshot of my cluster my cluster is up
on the left right and I see all the
traffic coming in and the traffic is
really coming in because cloud is
generating a lot of load right now right
so so there's a lot of traffic and you
see like okay my cluster is getting
hammered with requests right be nice to
see what's really going on what I can do
is I drill in there right and I see the
flow it's almost like a you get a micro
services map you see how your micro
services are communicating with each
other which is very nice you see the
flow and then you can even drill into
certain ones and say okay I'm gonna
drill into this warm right you see the
containers like how many how many
containers are being used to see the
dimensions so you get more information
than just the Diagnostics information
and the flow right and that's for
example some customization we have done
that we know what kind of parts you're
running what version that is and then
eventually what we're gonna add to it is
like literally the API versions that you
can actually see okay my serve is a or
let's say my activity map is talking
API version like - on the github stats
man right so that's pretty much it on
that side
all right cool
so overall that was the end-to-end demo
you guys think that's kind of cool hang
on you're like we're obviously not done
I need to go through my 80 slides that I
mentioned good because let's jump to
here just to recap what we've seen is
basically on what we want to do with
this whole thing is as I mentioned
before we want to shift the conversation
right we really want to have developers
focus on what they're good at
right and that's like API definitions
they can work with api's that can
consume it I don't need to know what his
service returns because we have the API
registry right I can just basically
download it also the code that we
generate is very smart because what it
does under the covers it really talks to
our service right and says hey where do
I find that version of that thing where
does it run in my cluster right so so
that's the first thing really API
approach and that takes me to the key
takeaways so what we've built here is
what I call or what we call an
opinionated an open platform right
opinionated because you've seen we have
a certain idea how you work with micro
services in the future right what I
haven't mentioned yet is that everything
that I've shown you with like or claudia
has shown you with the api associations
works exactly the same way with service
if you deploy a service framework we'll
use our function framework deploy it
into the kubernetes cluster you can do
exactly the same thing and by doing that
you get this really great hybrid
architecture right so we have an opinion
on how you do this but and obviously and
I stole that from from docker because I
like to call it batteries included but
replaceable so if you don't like the
graph on a dashboard you want to replace
it with something if you don't like sip
cane and you want to use Jager for for
Diagnostics you can do that okay the
next one is really are focusing on
developer
opportunity so av abstracting
infrastructure and really just
abstracted we not we are not completely
taking it away from you so you can still
access it because of you as you've seen
we use cue cattle commands just as any
kubernetes development right so it's all
accessible but we abstracted in a way
that makes the work easier the other
thing is like resiliency and when I was
asking you guys how many people handle
retries and circuit breakers right
that's something it's it's it's still it
sounds easy but it's really hard right
because if you think about retries you
need to think about idempotency right
because if you retry and retry and you
do the same operation over and over
again you end up in a mess so all that
stuff we can push that into the mash
that I was showing and I thought you
pretty cool because if you build a
polyglot micro service right then you
don't need to have like those different
libraries and things like that because
it's just there the only thing you need
to take care of is literally your
application tracing if you want to put
some code in your application and say
okay print out that trace statement but
the other cool thing is as long as you
use open tracing api's we captured it
out of the box in our in our platform so
there's also nothing you need to wire
the last one on that developer
productivity is really diagnostics and
monitoring pushed into the platform as
you've seen we have a fairly rich
diagnostic story and the monitoring was
that visceral component that stare out
of the box when you deploy if you use
cube cattle and you deploy it into our
platform that's what you've got there
was no magic in there what I was showing
and the last one is development first
and again easy to consume external
services like if you want to use a
managed MongoDB or managed Cassandra
raid you just add that to the system we
wired up for you and you can just
consume it from your containers the
second one is API first approach and
that was really what our demo was about
creating API is associating them with
micro services or functions if you want
we have a function integration and then
we do have support for event-driven
architectures because what you really
want to do in such hybrid scenario is
you have for example in order micro
service right and once the order is
placed you just want to fire a
notification
right that notification email you
probably want to implement a function
short-lived fire-and-forget right so
that that order service micro service
basically registers an event with our
platform and the function can just
consume it and there it is so with that
we where that and the last thing I'm
gonna leave it up to Claudio because we
have actually availability at some point
yes the goal is clearly we were still
building we're fairly close to have
something that is ready for some serious
testing so clearly we're going to
provide again about four weeks from now
this sort of ready to install
infrastructure on top of kubernetes
again and then clearly we are also
looking for we call it a sort of
advisory boards a few customers that can
really go through the process of
deploying and testing this architecture
in such a way that we can find out
clearly if we have any gap that we need
to feel we need to fix a clearly box and
make sure that at the end of the day
when we let's say officially release
this platform is actually going to meet
the key requirements that you know
modern developers will have for anything
there are our emails so feel free to
ping us directly and if you sign up for
like other customer you get a nice
alright
that's it from our side guys I hope you
enjoyed it hope you found it useful and</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>