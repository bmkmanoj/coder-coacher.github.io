<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CON7682   invokedynamic for Mere Mortals | Coder Coacher - Coaching Coders</title><meta content="CON7682   invokedynamic for Mere Mortals - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CON7682   invokedynamic for Mere Mortals</b></h2><h5 class="post__date">2015-12-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/gIffIZnmYBM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so hi my name is David buck I'm on the
Java SE sustaining engineering team
basically I just fix a whole lot of JVM
bugs mostly J rocket for whatever reason
I think I'm sure you've seen this slide
before basically everything I'm gonna
say for the next 50 or so minutes is
just a complete and total fabrication
you can't trust me at all and I'm
basically a horrible person so here's
our agenda apparently I'm gonna cover
pretty much these four things
in some sort of order so this is kind of
gonna be a strange talk I really wasn't
quite sure how to prepare in fact I was
kind of even surprised it got accepted
by the committee because it's a little
odd right it's not quite and under the
hood talk because we're not talking
about implementation details necessarily
we're talking about the specification
specifically we're gonna be talking
about jsr - 9 - but like and under the
hood talk I'm gonna be talking to a
target audience that I'm assuming
doesn't necessarily plan on using
directly invokedynamic
so the idea of this talk is that I'm
going for the people who aren't writing
a language runtime that sits on top of
the JVM and implements some sort of non
Java language this is invokedynamic for
everyone who doesn't spend their
weekends writing compilers but it is
intended for an audience that that's
technically suavi and and curious and
interested in the technology and wants
to learn more and so I'm just kind of
kind of hit you with a firehose of
random facts and hopefully it'll if not
necessarily be useful at least
entertaining and and we'll have to
settle for that so why study this why
learn this if you're not gonna go and
run your write your own language runtime
why are all you here and one really
practical reason is invoke dynamic is
use directly by the java language
implementation in the form of our lambda
implementation so all of a sudden
invokedynamic is no longer this fringe
technology that only applies to people
who are using dynamic languages on the
JVM it applies to your bread-and-butter
Java development as well and I know for
a lot of people they like to see the
Java pea output from their classes and
really understand what the Java compiler
is doing and how that translates into
bytecode and if you're not familiar with
invoke dynamic and jsr to 9/2 it can get
really confusing really quick when you
start using lambdas in JDK 8 now Brian
gets has a fantastic presentation and
it's kind of part of the motivation for
me wanting to do a talk like this called
lambda under the hood and that went in
and and 2 went into some really good
detail about the reasoning behind why
they chose to use invoke dynamic for the
implementation of lambda but the problem
is is that talk is kind of given
assuming that the audience already
understands jsr 292 which at the time at
least was a fairly small subset of the
java community so this is kind of more
of a ramp up for people who aren't
necessarily using non java languages on
the JVM or even if you are up until now
have not had any particular interest or
reason to kind of learn about the jsr to
9/2 technologies and and what they can
do for you another thing is just to
really kind of stress the point to
everybody that the JVM is now I mean
it's been for a very long time home to a
whole bunch of different languages but
but that we are we are seriously a
competitor so to speak in this space and
that the JVM language are that on the
JVM runtime is a fantastic target to use
any language on so if you're going to
experiment with Ruby why not experiment
with it on top of the JVM and you can
leverage all of the existing technology
and skill set and
backgrounds that you have with Java and
apply it to a new language so just going
back for a little bit of history on this
whole started with something way back
about 10 years ago so in 2005 ish there
was a project called The Da Vinci
machine project and the idea was that
Sun was going to start you know kind of
seriously paying attention to the fact
that there were all these other
languages that were running on top of
the JVM so the reason that people
targeted JVM should be fairly obvious
but just to be explicit
you know the JVM has really great
performance we have literally centuries
of engineer hours put into the
performance of hotspot you also have
just fantastic portability I mean Java
really runs on just about everything out
there you have security if we've done
our job if we've done our job right then
then you are safely protected within a
sandbox and you don't need to kind of
worry about malicious code or whatnot to
the extent that you would if you were
just using you know like C Python or
another native implementation of
whatever runtime you needed for a
particular language and of course
there's also the fantastic Java
community that has created an amazing
amount of frameworks and libraries most
non Java jvm languages make accessible
to you through some sort of interface so
you can leverage code that you've
already written that other people have
already write in there there's just a
fantastic amount of resources and
materials that are already there for you
and work right out of the box on day one
so the JVM is a fantastic place to
target a new language or to port an
existing one too so lots of people have
done it right
Wikipedia has its own page for jvm
languages there's literally there's well
over a hundred of them
probably over 200 at this point but just
to give just to call out some really
specific examples we have languages that
were really created more or less from
the start to target the JVM specifically
Scala closure I mean I know some of
these have iterations on net and whatnot
but these are primarily you know jvm
languages only and so we have groovy
Cylon fortress you know there's just a
lot of fantastic stuff that was really
just targeting the JVM and then we have
languages like Python and Ruby and
whatnot that were ported and some of
these people that did this boarding work
did a fantastic job I mean obviously
Charles Nutter who had a lot of
involvement with invokedynamic
has done amazing things with JRuby and
JRuby performance and the fact that
there's a whole bunch of different Ruby
benchmarks that you know JRuby can
outperform Matsumoto's Ruby
implementation that's just kind of
mind-blowing so just to be really clear
when we talk about a language runtime
just for example so if I'm running you
know J JRuby or whatnot the way the
language runtime is traditionally
something that's kind of sitting above
the standard JDK class library in the
JVM and providing some sort of of
runtime environment that hopefully is
similar semantics wise to to what that
language would normally expect from from
its kind of home environment so to speak
and there were a whole lot of different
kind of of areas where there was room
for improvement when the DaVinci project
started things that that different
people wanted to see put into the JVM
that would help implementing languages
either make it easier or make the
current implementations run faster and
so for example some things that people
would really like to see you know JVM
level support for continuations and
dynamic invocation was of course a hot
spot no pun intended
tail recursion is something that we kind
of get reminded of even even now fairly
regularly but you know there's all sorts
of different features and stuff that
because it wasn't necessarily important
to the java language you know hadn't
really made it into the JVM and and all
these are interesting and these are
still things that are are being
considered you know at certain points in
time by certain groups within Oracle but
the real pain point was clear that you
know invocation what was really where
the most bang for the buck was in this
project there were just so many
languages out there you know like groovy
JRuby and Jai thon that just could
benefit so much from having a clearer
and and more performant dynamic
invocation technology built into the JVM
that this was really what the team
focused on very quickly so we take a
little tangent here just just to cover
our bases let's talk about what dynamic
typing really is about because it's
amazing that sometimes this this phrase
can get kind of overloaded with various
meanings by different people at
different points in time so here's a
kind of a clinical example of it you
know I have it on good authority that
this looks similar enough to Ruby to be
readable and you notice here on like
Java of course we don't have any type
annotations so we're taking two pieces
of data and we're adding them together
that's pretty straightforward right but
of course we don't know just by looking
at this what kinds of data we're adding
are these floating-point are these
integers are these some weird like fixed
decimal representation that you know is
implemented by classes that have a plus
method to them you know we don't know
and ideally we shouldn't really care if
this is a dynamic language we just kind
of assumed that it's all going to
magically work and and that could be a
really nifty thing so the key here is
that we've a dynamic language is that
the you know the the types all have you
know are all strongly typed but we don't
really have that information available
to us at compilation time so we do have
it at run time we need to have it at
some point right because especially with
when it's part of your dispatch model if
you don't have type information
you wouldn't know what method to call so
it's not a matter of not having the
information or having it it's when you
have the information so dynamic typing
versus static typing is really a
trade-off of at what point during the
life cycle do you have type information
so the two options and there's actually
a bigger and more complex spectrum than
this but if you want to simplify things
that the big two general camps that most
languages find themselves in is is stat
that we referred to as statically typed
is compilation times so for Java that
would be when you compile from source
code to bytecode we have Java C and then
the other option would be the ones that
the dynamically typed languages
generally choose is some sort of runtime
type checking slash linkage and there's
a trade-off here like most things in
computer science so if you are doing
compile time checking if your statically
typing then you can catch errors very
early you know your code won't even
compile if you're making mistakes with
your usage of types and that's very
appealing to a lot of people but of
course the trade-off there is that
you're losing flexibility in the kind of
code you can write there's a whole lot
of different coding patterns and people
that frequently use dynamic languages
are very are very fond of these patterns
that you just can't do you just can't
effectively do and we reuse code in the
same ways with a statically typed
language so it's a little more of on the
conservative side where you're proactive
about catching errors but you're type
checking little quote-unquote have false
positives where it's code that actually
in reality would run correct but you
know we have no way to mechanically
verify that and improve that it is so we
can't necessarily guarantee that it
would actually work and so the opposite
end of that spectrum is the dynamic
linking choice and that is where we just
kind of assume that the programmer is
getting most things right and with
regards to typing
and we fall back on throwing an error at
runtime so we have to make a lot of more
decisions about how linking works and
things like that during runtime as
opposed to static compilation but of
course the downside to that is you know
in your production environment you can
have you know this methods not defined
or things like that happening that would
just never be possible with a static
language so that's what dynamic typing
is let's be very clear about what it's
not okay it's not type inference type
inference is obviously a very kind of
ambiguous word and there's all sorts of
different types of type inference no pun
intended
but just as a counter example here I've
got some Scala that I kind of
shamelessly copied from their tutorial
to show off what type inference looks
like and Scala is of course a very much
a static language you know it's kind of
this this very fascinating wonderful mix
of I guess Java and an ml or SML and
you know both for the both of which are
very famous for being very statically
typed languages and scale of course also
is as a lovechild between these two
languages is also statically typed and
so that has nothing to do with the fact
that that we do type inference the the
key here is that even if you're not
explicitly writing it in your code the
compiler you know Scala C or whatever
can go and look at this and infer
correctly you know of 100% accuracy
what types are actually at play here
it's also be clear that dynamic typing
is not weak typing like for example ruby
is dynamically typed but it's a strongly
typed language it doesn't let you do
nonsense so weak typing is also a phrase
that kind of gets overridden and has a
bunch of meanings to different people
but generally speaking we weak typing is
used to refer to languages that will
kind of like go out of their way to
implicitly cast stuff and just kind of
make it compile so for example there
there are certainly languages out there
that would just look at this code and
take the two and and assume that that
two must be a string
and concatenate it on to the four so you
get 402 you know which seems horrible
but but someone thought that was a good
idea so dynamic typing is not this it's
not this it's not type inference it's
all about at what point in time during
the development cycle do we have type
information so to kind of summarize what
dynamically type languages are all about
is that you know we are going to allow a
larger range of different programs that
will actually pass the compiler you know
that the compiler will not choke on dirt
during the first phase of it but we have
to do more checking and we have to do
linking we have to delay those processes
until runtime because we don't actually
have perfect type information we don't
know for sure when we have some sort of
object what type it is but for some
people that hear that they might be
thinking oh wait a second we don't have
perfect type information since when do
we have perfect type information for
Java right Java is an object-oriented
language and we we have you know like
like in this method right here you know
we have this object we're being passed
to we have absolutely no idea what the
type of that is you know if I'm just
compiling this as standalone and I don't
know who's calling it I don't know what
I'm being passed so just like with a
dynamic language because the
object-oriented nature of the java
language at runtime we do not have
perfect type information so what what's
the big deal here why why is this such a
hard thing to do on the JVM and the
answer to that to answer that really
satisfactorily kinda have to look at
what the JVM has in terms of support for
the java language so we have kind of our
lineup of the usual suspects here these
are the four different invocation byte
codes that have been around since the
dawn of time apparently and they they
all correspond very clearly to different
kind of use cases within the java
language like if you take the you know
kind of method dispatch logic from the
java language spec and you take the JVM
spec you know you can see a whole lot of
kind of one-to-one correspondence where
you know it's just obvious that one was
written for the other so let's start
with the simplest one invoke static this
is pretty straightforward this is just
we're calling a class method here so
Fu's here we're not going to change that
for too many of these examples and I'm
just calling it so there's no instance
here this is just static and let's look
at what that looks like with actual
bytecode just get an idea how many
people here how like have used Java P
and looked at the output before
excellent okay that that is more than I
expected actually so that's fantastic so
we're gonna do a bit of that so this
should not be too shocking to too many
people so I was the only get that this
is this code right here and can people
see that text very well you know I don't
know how to do that
if I chain yeah you just have to you
know what I might just cut and paste a
little bit here so basically all we're
looking at all I'm trying to show here
is that this is the main method here and
you know we have a static invocation in
the language and that translates
directly and obviously to an invoke
static call so for those of you can't
see it just please take my word it's a
new book static call so nothing really
earth-shattering or shocking going on
there and then invoke virtual and this
is where we start getting to where it
you know we don't necessarily have all
the information that we would need at
compiled time at the Java Sea time to to
really know exactly what code we're
going to be call and we just have to
take it on faith that the JVM magically
does this for us correctly but so here
we have another set of code but because
it's a virtual invocation you know kind
of a standard default idea of calling a
method here we're creating a we're
creating a new instance and then we're
calling it and if we look at the
bytecode for that
you actually see in the main method we
have we actually have two invocations
going on here we have an invoke special
which we'll get to in a second and
that's because we're calling the
constructor for this object so the new
bytecode actually really just kind of
allocates memory but invoke special is
what and and initializes it to zero but
invokes specials what's going to come in
and actually run the the constructor for
us but we're not focused on that with
this particular example we're looking at
the invoke virtual so again nothing
earth-shattering or surprising to anyone
I'm just trying to stress like how
amazingly simple the correspondences and
natural the correspondences between the
bytecode and what you see in your Java
source file so invoke interface and this
is kind of the the most complicated one
in terms of JVM implementation there
there's a whole lot of research that has
gone into efficient implement efficient
dispatch of interface methods because
it's just like multiple inheritance and
in C++ there there's all you can't just
have a simple v table for every class
and call it a day you know you have to
do some some more interesting things so
to make it run fast which thankfully
people have done and hotspot does this
extremely well but this of course also
just has support for it that this
extremely complicated
dispatch logic that's part of the both
the java language specification and the
the JVM specification basically baked
right into sorry baked right into the
bytecode
it cuz helps if you run it on the right
file
sorry
you know I don't new
okay God thank you thank you so much so
you'll just have to take my word that
everything I've been saying up until now
has not been just utter and complete
lies but yeah so it's you know it's it's
really straightforward what are we
looking at here yeah so the fumus method
we don't really care about it's just
kind of doing a hello world type thing
and we have invoked interface so there's
no light like you know all the magic all
the the difficult complicated stuff you
know as much effort and engineering time
has been put into making invoke
interface work really fast
no no that's apparent at the bytecode
level because the bytecode level has the
exact same semantics as Java as the Java
language required requires and then we
have finally the the junk drawer of java
invocation we have invoke special which
kind of handles everything else right so
if you're gonna call a private method
from within a class you're gonna call
its constructor or you're gonna default
to two superclass implementations and
we've already seen an example of invoke
special with that earlier run that none
of you could actually see and so this
one just to keep things just to mix it
up a little bit I made food private as
opposed to public and so now when we
look at it when we look at the actual
bytecode it will be it will help will
actually see two separate implications
of invoke special one for the
constructor and
we'll go up here
and here work what we're calling invoke
special right on it so actually no
that's on the constructor sorry
that's the static initializer so here
we're calling invoking start special so
we've got an invoke special here for the
constructor because constructor is one
of the kind of three main use cases for
invoke special and we have a private
method being invoked and that's one of
the other big three the other the other
one that I'm not showing in this demo is
of course these these superclass
kind of failover so you have that so we
have you know we see this amazing
correspondence between languages and
poor dynamic languages are kind of oh
sorry
you know can I answer after or think but
yeah that that's actually an exact
that's a really great question but um
yeah did a second so yes so why you know
like dynamic languages you know how do
they fit into all this how do we
implement a language that has semantics
for dispatch that's just like completely
different and the answer until
invokedynamic is to use the reflection
api right because the the reflection api
is built to let you just kind of
arbitrarily introspect classes and run
code on them it doesn't matter where
that code or run their code it doesn't
matter where that code comes from it can
be you know pre-existing as part of the
language runtime or it could be
generated on the fly with Assam or
something but but the reflection API was
really the only option for kind of
running this code directly from the
language runtime but the bad part of
that is that reflection can be very very
slow I mean a lot of engineering time
and effort has been put into the
reflection API to make it as fast as
humanly possible but because of the just
basic design of it and the semantics of
it they're they're shortcuts that we
just cannot take and so for example with
reflection api that the big two kind of
bottlenecks are the security checks
every time we do anything in reflection
we actually have to check that the user
is allowed to do that or that that code
is allowed has the permissions to access
whatever field or method that it's
trying to touch and also the the
signatures are basically these really
generic things where you're just passing
around objects and so even if you're
implementing methods that really are
just taking primitives back and forth
and you could just have passed by value
and everything could be very very quick
then you know you're you're forced to
use objects so if you're calling the
same method on an array with 10,000
entries and you know you you're just
going it item by item by item you have
to create with the reflection API 10,000
different objects that are kind of just
these disposable things that exist just
to kind of wrap and then immediately be
thrown away
these otherwise primitive values so
that's extremely wasteful I mean the the
JVM is extremely good at garbage
collection and it's made as an
object-oriented language runtime to be
very efficient at both allocation and
disposal of objects but still creating
objects when there's no need to is
wasteful and it becomes extremely
expensive but it's actually a lot worse
than that those are kind of the two easy
or simpler things to understand for most
people but but the real key is that the
JVM doesn't have visibility into what
the language runtime is doing with
reflection so it from the JVM s point of
view the logic the dispatch logic for
dynamic run language runtime is like
this black box that all it knows is what
the output comes so my caller might get
tied to a collie but there's no way to
say to the JVM and next time we hit this
call site it'll be exactly the same so
don't bother calling me again we always
have to have this up call into the
language runtime to say okay you know
what method do we run and and that's
expensive because we cannot what what
really is the problems we can't in line
through this this this black box to the
JVM is just as soon as it hits that you
know it's not going to go and
proactively say well maybe it'll do this
method next time so I'll inline that
like we just can't really compile it and
inlining is really the mother of all
optimizations I think people very often
don't don't understand how important
inlining is in lining is kind of the
what you need to do before you can
really do any other optimizations I'll
give you an example so unless you're
trolling your colleagues during code
review know no one really writes code
like this right you know basically this
branch is about as necessary is another
fast and furious sequel and
you know no one this is a little more
complicated but no one writes code like
this either right I mean do you ever
have the impression when you're studying
about different compiler optimizations
that it's like how is that useful like
who actually writes code that's so bad
that it would benefit from you know that
kind of constant folding and stuff like
that like of course you know all this
stuff is trivial and no code actually
looks like that and it's true like
you're you're not often gonna come
across the code that looks like this but
you will come across code that looks
like this you will write code that looks
like this if you if you're refactoring
things and and kind of a good developer
and looking to eliminate various code
smells then then you will have code that
you know that in the case where method B
calls method a we can trivially
eliminate this as dead code you know in
that particular invocation but from
other when when it's in lined into other
code that's not necessarily the case and
we might not need to actually check that
value or we might be able to hard code
it to eliminate the branch the other way
but so the idea and this is this is a
really simple trivial example but you
know all the different stuff you know
the unboxing and and constant
propagation and constant folding and all
that stuff really doesn't have an impact
until you in line the basic unit of
optimization for not just the JVM but
for pretty much most compilers is the
method and/or function so if you can't
cram enough code into a function to you
know get some economies of scale going
and then you know give give the
optimizer meat to chew on then your
optimization is not going to help you
because you know all your methods as you
just look at them in your source files
probably don't have too many
opportunities for you to you know like
remove dead code or to do constant
propagation and whatnot so for an
optimizing compiler it's so so important
that we do inlining and do a lot of it
just just and hotspot does especially c2
hotspot will do a boatload of the
lining and that's the linchpin for all
the other optimizations so we can't
inline everything else is pretty much
useless and that's where we end up is
that you know we have we have this
situation where we can't you know we
just hit this wall where there's this
reflection code this logic that's going
on in the runtime and we can't make any
sense out of it so from from the JVM
perspective because it's at a different
level right we're not going to like
trying to analyze the code and determine
what it does so that's where jsr 292
comes in and jsr 292 actually has two
different really important and
interrelated parts I said this was
invokedynamic but that's because I
figured more people would probably show
up to an invoke dynamic talk than if I
said that jsr to nine to talk but really
this this talk is really about both this
talk is about jsr to 92 because
especially you can't have invokedynamic
without the the java dot lang invoke api
they really go hand-in-hand the reverse
is actually not true and we'll talk
about that a little bit in a bit but you
you can actually use the invoke api and
it makes a lot of sense if you you know
without using invoke dynamic and there's
use cases for that but the other way is
not you you can't use invoke dynamic
without the invoke api so let's talk
about what these actually are so invoke
dynamic we usually refer to it
internally as indi so you might hear it
referred to like that and in certain
talks and it's it's kind of difficult
for Java developers to understand
sometimes because unlike all the other
invocation instructions
there's no corresponding Java code that
we can just point to and be like yeah
this does what nd does this shows you on
the Java level way what indi does so you
kind of have to to look at it from
either you know it's used with other
languages or even with lambda but it's
still it's it's hard to kind of wrap
your head around it because it's you
can't really understand it in isolation
you have to also understand the
invocation API and how all the different
puzzles are pieces of the puzzle fit
together but the indie by itself is kind
of an
using milestone for us because it is the
is the first major feature of the JVM
that was added specifically for support
of non Java languages I mean the main
driving use case for in for indie even
though now it's amazingly important for
for nath ORN and for for lambda but but
originally the the killer app for Indy
was non Java languages the killer app
was JRuby the killer app was was Jatin
so that this kind of showed you know a
widening of the scope of you know the
realization of son of what the
importance of non Java languages were to
the runtime and the community and it's
also just the first new up to up code
that we've had in ages really since the
beginning you know we kind of deprecated
out perkupp codes like jsr but we you
know adding stuff has just never been
done you know when people talk about
Java bytecode you know they're they're
literally talking about bytes there's
only 256 up codes you know in our opcode
space that we have so we're extremely
stingy about it it's not like Intel
where we can just be like yep AVX here's
another couple hundred instructions that
you can play with so there there's a
whole lot of kind of thought that goes
into do we really want to add another
opcode to to the instruction set of the
JVM but in this case it was obviously
very very worth it and important so the
other part of jsr 292 is the java dot
lang invoke api and and this is kind of
how you how you in how you plug in to
invoke dynamic from the java level but
that's not its only case use case in a
lot of ways it's actually kind of a
better form of reflection and I'll talk
about that in another slide or two but
basically the the java dot laying in
vogue api has two main main classes that
you should be aware of there's there's
method handles which we'll talk about in
detail in a second
they're kind of like function pointers
although I'm not quite sure I'm allowed
to say that out loud
and there's call sites which are
reification zuv invokedynamic
instructions and if that doesn't sound
like it makes a whole lot of sense to
you just wait for a few slides when we
try to put it all together hopefully
it'll it'll become a cohesive whole in
your mind and then we have these things
called bootstrap methods which aren't
particularly like really you know their
own classes or anything but they're part
of that how you use the java dot lang
invoke api but let's start talking about
specific so maybe some of this will be
clearer so a method handle really is
just for lack of a better term a
function pointer it's a way for us to
point to a particular amount of code and
say yeah yeah run this you know here's a
signature here's here's you know the
types of the arguments and whatnot and
and here's the address where it lives
so we point to a method it's a function
pointer or but but unlike like
reflection it has what we referred to as
a polymorphic signature which is key to
avoiding the boxing because it basically
kind of is a way of telling Java C like
to just just trust me we'll we'll work
this out you know and it allows us to
actually pass and return primitives as
opposed to just objects so right off the
bat method handles have an amazing
advantage over a lot of reflection use
cases because in a situation where you
are passing around primitives you don't
have the overhead of this unnecessary
boxing which is one of kind of the big
three things that reflection was letting
us down law on performance wise okay now
method handle performance is kind of an
interesting issue some people have very
strong opinions about it and part of the
reason for that is when it first you
know came out as part of JDK seven it
was not ideal
and so people were confused because
they're like okay is this a replacement
for reflection like if I'm using
reflection now if I rewrite my code
using method handles work it will get
faster and you know some of the
documentation kind of seemed to imply
that it would be faster but then a lot
of people ran out and did some very
thorough benchmarking and found out that
it actually gets worse in a lot of cases
and there weren't too many cases where
it got faster and so a lot of people
from that initial experience or just
from reading various blogs and whatnot
looked at method handles and went well
you know I can see why they're an
obvious you know integral part of jsr to
9/2 and you know you need to use them
for for indy but you know there's no
stand-alone use case there's no reason
why you would prefer them over the
regular reflection API but that was more
of a problem with the implementation and
the design so the design or the
implementation behind the scenes has
improved dramatically
specifically with something called
lambda forms and I want to just avoid
confusion here lambda forms when we're
talking about method handle
implementations are completely unrelated
to the lambda expressions that were
introduced with JDK eight like yes
they're both based off faith based off
of lambdas and they're both you know
they both kind of entered the the code
base of the around the same time the JDK
a time frame but they're not related
this has nothing directly to do with
lambda expressions in the java language
but lambda forms are basically a
complete rewrite of the method handle
implementation and they got amazingly
faster I won't go into detail about what
lambda forms are but there there's some
fantastic talks from the the JVM
language summit specifically John Rose
who invented lambda forms does it does
some really good sessions on on what
they are and how we implemented them and
then there's some other talks even just
just this year about further
improvements that were made
but the point is that method handle
improvements for a lot of use cases have
improved dramatically the memory
footprint has shrunk the speed
everything has improved and it's really
amazing it's it's almost like a
completely different technology so if
you go and read on a blog that method
handles are not a viable replacement for
reflection that's probably a blog that
that's a few years old and it's not up
to date from seven you forty the
implementation was replaced of lambda
forms and then from eight and then with
some of the major like eight you forty
and I think a you both au 60 there were
significant performance improvements
done for lambda forms so method handles
are now amazingly fast and and you
should really try i yeah yeah you can
you can specify a class
yeahyou
well you can you can look up a method
handle for a particular class and then
it's you know it's it's pointing to that
particular instance and so to speak
instance is probably a poor choice of
words in this case but yes you can be
specific to this method in this class in
fact it has to be but I just on so we
could talk about it after the sessions
over if that's not entirely clear so
what I want to stress here is that
method handles actually have have a lot
of very useful and legitimate use cases
and I see you swimming performance wide
use performance wise useful outside of
invokedynamic so don't think of them as
only being useful for invoke dynamic
invocation okay and that brings us to
the other kind of major component of the
invoke API which is a call site and the
call site is basically a reification of
the invoke dynamic instruction itself so
every invoke dynamic instruction in the
bytecode will basically have zero or one
call sites attached to it so it's kind
of like a lazy initialization scheme
where we don't generate them
automatically but as soon as we need
them we create them they're objects that
live on the heap this is just a regular
Java class and a call sites only reason
for existence is to have has a method
handle so you could think of a call site
almost like a variable and there there's
constant call sites there's mutable call
sites for all different kinds of usage
scenarios but the idea is the only
important thing about a call site is
that it corresponds to exactly one
invokedynamic instruction there there's
one point in the bytecode for every
invokedynamic instruction that exists
and and if there's a call site
associated with it that's the only one
that
it'll be connected to and it holds a
method handle and that's all it does you
could you you know if it's a modifiable
one if it's a mutable one then you can
change the method handle that it holds
but that's its only purpose in life is
to hold this what this means is the
weekends we can switch that if it's
modifiable so if at runtime language
runtime goes okay you were calling foo
but now you're gonna call bar we could
just switch those you know at will and
there's no repercussions to that so
they're really really simple try not to
overthink them they're basically a way
of just at the Java level talking about
a location in bytecode and the location
happens to be a location where a
specific invokedynamic
instruction is and we're saying this
call site is going to have this method
handle so now let's look at how these
are actually initialized so we're going
to go through this kind of like a five
step process this is this is basically
the equivalent of linking I mean this is
linking and so what we're doing is we're
allowing ourselves to programmatically
at the Java level using the invoke API
change the way or or control the way
that the JVM is doing linkage so we
start off here and like I said because I
don't have any corresponding Java code
here we're starting right off with the
bytecode but really the only important
thing to keep in mind here is that we
have the we have a to invoke dynamic
call down there so and it's just making
references to constant pull entries that
you don't need to worry about and what
happens is the first time we invoke that
the first time that we actually execute
that bytecode this one-time linkage
process is run where our bootstrap
method is executed and the bootstrap
method there's nothing special about it
it's just a java method that it conforms
to a particular signature right and
there's an
the constant pool references that the
invokedynamic
thing points to actually specify what
it's bootstrap method is and the
bootstrap method would be part of the
language runtime this is the code that
actually is the brains of the linkage
and says okay so if you're calling me
from this context then you must want
something that adds two integers
together or whatever but it makes some
sort of decision based off the semantics
of that language and it comes up with a
method you know it says okay so you I
want you to run foo that that's what
you're going to run and it creates a
call site and that call site has a
method handle to foo and then it just
very politely disappears forever and it
is never ever run again for that
particular invocation so multiple
invocation multiple invoke dynamic byte
codes can can all share the same
bootstrap method if they want to if for
some reason that works so you can share
it among ones but for each individual
location we only go through this
bootstrapping process months so if we're
doing something at run time where you
know it's kind of like this lazy
initialization thing that's built into
the JVM where we don't know until run
time what we want to do but once we know
we know it until we shut the system down
then this basically becomes free because
we've done this linkage we've done the
heavy lifting and then it's just a
matter of the JVM using that method
handle and because the JVM of course is
aware of method handles and call sites
and knows how all this works it's no
longer a black box so just jump ahead a
little bit here so basically this
situation where we had we had you know
this wall that we would just hit with
inlining where we couldn't inline
through dynamic calls all of a sudden
from the JVMs point of view turns into
this it's just a straight four thing and
it could inline that
and do whatever it wants so let's just
review really quick what that looks like
so the first time we're invoked
basically we call the bootstrap method
again and the bootstrap method is
nothing special but basically it finds a
method to run maybe it you know because
of the language requires it it might
generate that on the fly it might spend
some some inner classes or something
like like the lambda implementation does
or it might use azzam to generate code
on the fly or it might find some
pre-existing thing I mean it's just
based anything you would think that you
could do of a linker you could do with
this if it resolves to a pre-existing
method but it finds a method to run it
sticks that method handle into a new
call site and it returns the call site
and then the call site is this that one
call site is associated with that one
invocation forever until the code is
unloaded so and then all subsequent
calls just immediately jump right
through and so the question is okay so
for a dynamic language the whole point
is that at runtime the situation can
change you know it might you know it's
not just the first time that we call
that we need to do linkage we might
actually need to make it point to
different things at different times and
the point is the JVM doesn't have to
worry about that because because you
know we have this this this application
programming interface that the jv8 that
both JVM and the language runtime are
aware of so if the language runtime
decides like hey okay we need a
different implementation for this method
it can go in and just change that call
site at any time so how did in in
practice what that actually usually ends
up being is that we will have some guard
code on the method that we're calling
and that guard code will say okay well
I'm prepared to handle integers but just
in case if someone calls me with a float
I need to fall back on this slow path
and then I can go and compile a new
method or finds you know resolve some
new pre-existing one you know and we can
go in and build a more complex
implementation that can handle what
argument types or things like that but
you know one of the keys to optimization
actually covered this or ended at this
during my last talk with hotspot locking
is kind of finding cases where the
entire flexibility of the programming
paradigm is not being used so you know
dynamic languages lets you call with all
sorts of different you know arguments
and and they're supposed to handle that
flawlessly but in most cases you're not
calling the same method with 15
different signatures you're calling it
with one and so if you can just cache
that and use it very quickly and inline
it and just treat it like it's a regular
plain vanilla call like all the other
Java calls then you get this huge
performance win so this all means that
the JVM can jump in and all of a sudden
dynamic languages you know it's a it's a
language that it speaks because there
isn't this cloud of reflection between
the method caller and the callee anymore
so just just to really drive this point
home I want to be clear that the key the
key end thing to understand here is that
linkage and invocation are two different
things
and linkage can be very heavy and
expensive but that's okay because we're
not going to do it too often in most
cases we're only gonna do it once the
first time you actually call that and
for a few runtimes yes you might have to
go and then you know like like have some
checks and when those assumptions that
you made when you originally picked a
method are no longer valid you have to
fall back on some slow path and maybe do
something else but it's not something
you have to do continuously whereas an
invocation is something that you're
going to do a bunch of times right
you're going to just constantly be doing
this so the real power of invoke dynamic
is that we make invocation really really
really really fast by taking all the the
you know the security checking
and resolution and stuff like that and
putting all that logic into this one
time step that happens during call site
initialization so anyway so for
takeaways for this talk
the main thing is that invokedynamic is
this way of letting us programmatically
using the invoke api tie-in to the JVM
linkage and basically tell it what to do
tell it you know tell it how to find or
generate at runtime
the method that's going to implement
some particular call but then it gets
out of the way so it seems you know lots
of people's first reaction when they see
all this is they're like that looks so
complicated how on earth could it be
fast but the point is invoke dynamic
after you set up the call site unless
you have a reason to change that call
site it just works like a regular method
invocation it's just as fast as a moment
more like an invoke invoke virtual it's
not as quite as fast as invoke static
but it's pretty darn close to an invoke
virtual call so it's very fast it's very
efficient it can be inlined
and all of a sudden all the
optimizations that we've been barred
from doing on dynamic code suddenly work
another important takeaway from this
talk is that the invoking api is not
dependent on indy and so you can there's
a bunch of use cases where you know if
you're using reflection the invoke api
could be a very performant replacement
for that so definitely consider using it
as always benchmarking is is the
ultimate arbiter of what you should or
shouldn't be doing performance wise and
lastly and finally the JVM is a
fantastic platform for whatever language
you're playing with so if you want to
experiment with other languages you do
it on the JVM it'll very often run as
fast if not sometimes even faster than
native implementations of a lot of these
languages and you immediately get to
leverage all the code out there that you
already know and love and use every day
so finally just some resources 2.24 for
more information if you guys haven't
seen the jvm language summit stuff
definitely check it out it's fantastic
it's held once a year and it's it's a
really small thing that usually goes for
about three days and it's just fantastic
it's all a whole bunch of language
implementers and JVM people all in one
room talking to each other and the
videos are fantastic and hopefully after
today's presentation some of it might be
a little bit more accessible because
especially for the past couple years a
lot of the conversations the language
Summit have been really focused on
invoke dynamic and how to use it so
there's also if you're just stood and
loading and linking loading in general
there's kind of the Bible of that is I
can't remember the author's name but
this guy wrote the book and there's he's
got like a draft version of the PDF
files on his blog that you can read for
free but it's kind of like the best the
absolute most amazing book on
understanding how linking works in any
language and finally John roses blog
John Rose who's a a jvm architect for
hotspot you've probably been fortunate
enough to to see some of his sessions
this or past Java one I think he's doing
some more later this week if you haven't
definitely check him out he's he's a
fantastic speaker and he does really
really cool stuff but he blogs pretty
extensively and invokedynamic
he didn't initiate it but he took it
over very early I think he rebooted it
around 2006 and it's kind of been his
baby ever since and so he's the ultimate
authority on invoke dynamic and and jsr
292 and his blog is a fantastic resource
to learn all sorts of stuff about
running non Java languages on the JVM so
that's all I had prepared
so we do have a little bit of time for
questions but thank you very much so
yeah oh good you say it's a save you
time I the top of my head I don't
remember but I do it's something about
but what do you have time after this
because we'll talk about it because it's
something about whether there's an
actual instance there or not to
reference by it
oh yeah ii like move a constructor and a
private like you have an instance but
it's not your kind of like breaking the
normal rules for yeah you have an
instance that you're passing there's at
this point ER but you're not doing a
virtual lookup like oh yes this is it I
remembered so so the the magic of invoke
special is that in all three of its use
cases constructors superclass and and
pret and private well for private method
private to that class is that though the
only cases where you're calling a method
and usually method invocations fall into
one of two categories either have this
pointer and you're doing a virtual
look-up on it or it's a static
invocation and you don't have at this
pointer but with a constructor call or a
superclass implementation or with
private methods you're in that really
weird situation where you have at this
point or but you don't want to do a
virtual lookup you want just like a
static call you want to say this is the
code I want you to run because with a
constructor right you're not virtually
looking up anything you know with a
private one at the Java C compile time
there's only one implementation that
you're allowed to go that you can't do
virtual lookups on private yes so so
invoke invoke interface yes so in invoke
interface and invoke virtual you have
this pointer and you have to do work you
have to do some sort of funny business
with with
you know object-oriented stuff there's
polymorphism with us invoke static
there's no this pointer because so
you're just point is that we've invoked
special there's a this pointer but
you're not doing virtual lookup you're
you're just pointing right at the code
it's a I totally forgot and I might my
head win like absolutely white when you
ask me because that's like I used to
know that but for now oh I'll be here
pearl
no there was there was actually a really
significant jump in 7u 40 because that's
where I got rewritten kind of from a
scratch but with eight they've they've
continued to just go like leaps and
bounds and do legal stuff okay
is that you're doing static analysis of
the by code yeah
yes
well I mean strictly speaking there's no
way to do it completely fail safe
because you in your bootstrap method you
can have arbitrary code that can do
anything it can generate something on
the fly or can so there's no way to
statically analyze it you know I mean
you're just running against like the
halting problem or something to an
extent yes but there is because as part
of and I didn't go into the details of
the talk because this is more of just
kind of a general overview but the
invoke dynamic invocation does have an
identifier it's saying like this is the
signature and this is the name of the
method I think I'm calling now in
reality the bootstrap method might
return something that has like nothing
to do with that you know with that name
that that names arbitrary and it's just
kind of like a hint to the bootstrap
method of what you want to do so so
there's no guarantees but just by
convention you can say okay so this
method with this name is what this
invoke dynamic thinks it's calling so I
you can't make any guarantees about what
the bootstrap method actually does but
you can if you assume that that's
correct then that could give you you
know valid information for you know if
you're looking for for calls and so it's
just it's just the same problem if
you're trying to find calls that are
being called reflexively you know you
can't guarantee that you're gonna be
able to find those we have a static
analysis tool as well because at runtime
you're deciding what you're calling but
at least we've invoked dynamic you do
have a signature and you do have a
method name that may or may not
correspond to the method that's
ultimately returned or pointed to by the
method handle
nah no I mean normally it's actually
because it looks though the result once
it gets out of the way is just a normal
call so if you're looking at stack
frames and everything it's just like the
other four invocations you know I've
never seen that but I would really doubt
that you would be able to see that from
a debugger unless you actually put you
know a breakpoint into the bootstrap
method because the JVM kind of you know
it's it's synchronous but it just kind
of goes and goes okay I need to do this
to implement this one bytecode yeah I
mean I'd have to look at what our JV MTI
implementation actually is doing for
stepping through that but I somehow
don't think you suddenly find yourself
in the in the bootstrap method unless
you explicitly put a breakpoint into
that but I but I don't know it would
depend on the implementation it's an
interesting question though
so really great talk quick
now lambda expressions to the January
somewhere
II mean lambda form or lei island just
Java language lambda expressions okay I
won't go into too much detail for that
just because Brian gets has done it'll
make so much more sense yeah but but
just generally the idea is that he
didn't want to specify he didn't want to
hard-code you know how we weren't going
to implement lambda expressions and so
invoke dynamic it's a perfect example of
where you know it's not as nothing to do
with dynamic typing but invoke dynamic
clauses to do this kind of lazy
initialization where it's like okay well
you know we got a call a lambda
expression somehow we got to execute the
code that corresponds to this lambda
expression but I'm just gonna let how
that actually all happens I'm just gonna
leave that to the runtime and let it
figure out so Oracle JDK for Java eight
could do it this way and Java 9 could do
it some other way and when the bootstrap
method runs you know it just magically
comes up with here's your implementation
and it plugs it right in and it all gets
in lined and stuff and you know what
like 1/8 what we're actually doing is
we're behind the scenes weren't we're
actually spinning in our classes at
runtime and through some kind of
intelligent reuse of stuff it actually
kind of works a bit better than than a
naive intrument a ssin based off of
inner classes but we can change that at
any point because of invoke dynamic
we're not we're not hard coding what the
bootstrap method does we're just saying
you know this will get called and we
have to come and come up with some sort
of implementation that will meet those
requirements and how we do that is no
one else's business we can just be a
black box</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>