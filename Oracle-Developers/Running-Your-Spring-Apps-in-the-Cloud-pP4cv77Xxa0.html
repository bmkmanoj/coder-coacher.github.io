<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Running Your Spring Apps in the Cloud | Coder Coacher - Coaching Coders</title><meta content="Running Your Spring Apps in the Cloud - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Running Your Spring Apps in the Cloud</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/pP4cv77Xxa0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">how many of you would consider
yourselves I guess I'm going to know I'm
going to be able to appreciate prefetch
the answer on this I have an idea what
the answer is going to be how many of
you would consider yourself the two
choices are going to be more on the
developer side it more on that operation
side how many people are more on the
development side it's what I would have
expected it's bring one operations okay
I spoke at DevOps days in May and it was
as you can imagine exactly the opposite
that wasn't there were no developers
there Saul ops the cool thing is that so
I didn't do this talk I did more the
operations talk but cloud plays in both
places and I'll get all 20 I won't give
away my punchline just yet okay I can't
wait anymore 959 I'm getting started so
good morning everyone thank you so much
for taking time out of your day and I
know there's lots and lots of different
sessions that you can come to and I
really appreciate you coming to this
session my name is Cornelia Davis I'm
the director of platform engineering for
pivotal pivotal is a company that was
created as a spin-off about a year and a
half ago in April from VMware and EMC it
brought together some assets from both
of those companies from EMC it brought
together things like gem green plum the
green plum DB as well as pivotal labs
which is where we picked up our name so
pivotal labs is extreme programming
agile programming consultancy and from
the vmware side it brought together
things like spring spring source of
course a gem fire and cloud foundry now
I came to pivotal from emc where I was
working in the corporate CTO office
doing emerging tech and one of the
emerging tech things that I was working
on was Cloud Foundry when the spin-off
happened and I had a bit of a detour but
ended up in the in the cloud foundry
product team so platform engineering is
an is a group within the cloud foundry
product team
so we were up we're under our under
engineering but what we do is we work
with partners and customers on kind of
extending the envelope of cloud foundry
applying it in ways that we that aren't
well understood or haven't been done and
so case in point a year ago we hadn't
done a lot of migrating of spring apps
into cloud foundry and so that was the
project that we started then and it's
been ongoing over the course of the year
we learned lots of patterns and lots of
things through that exercise I will
mention that we are hiring so in
platform engineering and across pivotal
but if you are a developer and
distributed especially distributed
systems and you like to play with new
technology all the time please come see
me alright enough of that so running
your spring apps in the cloud as I said
just a moment ago this was a project
that started about a year ago we we were
working with SI p so SI p has hana DB so
that's their their competition their
competitor to oracle right in the
database space and they wanted to
partner with cloud foundry and they were
building what's called a service broker
and i won't go into the details of it
except to say that it's a way that you
can bring external services or any types
of services like database or messaging
or index and services and those types of
things into this application development
and application deployment and
production deployment running
environment and sa p approach desam
wanted to integrate with cloud foundry
and we wanted to demonstrate this at
their Tekkit event last december and so
what we wanted to do was show an example
application where we integrated with
with hana DB the application that we
ended up choosing was the application
that i'm going to talk about in this
session it was a spring app that was
built by vmware as a reference
implementation up demonstrating a whole
bunch of things in what was called the v
fabric suite at the time it included tc
Server RabbitMQ gemfire sequel fire
and so on it was a way of that VMware
was bundling up a bunch of these
products and they had this reference
implementation so how many of you are
familiar with either we called it nano
trader or spring trader that reference
implementation just a couple of you so
you'll see what it is here so what was
it it was a spring application
multi-tier application i'll show you the
architecture in just a moment that was
deployed to these various components and
so what we've done now is taken that
application and instead of deploying it
on things that you stand up yourself we
deploy it into the clouds specifically
cloud foundry and it was a very
interesting exercise to go through and
figure out how do you have to change
your application from a traditional
deployment into a cloud-based deployment
and that's what this session is all
about so but before I do before I go
into the main part of the agenda I want
to show you very quickly I think I
always believed that seeing things
concretely is so much more helpful it'll
take a lot of things that perhaps are a
little too abstract and make them a
little bit more real for you so the
first thing that I want to do is I just
want to push an application and by push
an application what I mean by that is
we're just going to deploy an
application into the cloud so in fact
let me start over here in and let me
give you a slightly bigger font I think
that's probably okay so what I'm logged
into here is I'm logged into cloud
foundry this is our up it up in the
internet public internet deployment of
Cloud Foundry so Cloud Foundry is a
platform here we call it platform as a
service so you can go to run pivotal dot
IO and you get a runtime environment for
your applications and you get it as a
service you can register and then you
can start deploying apps and you don't
have to stand anything up on your own we
also provide and by the way Cloud
Foundry is all open source so it's
completely open source core code base
just and our business model is a very
traditional open source business model
we have a commercially licensed
supported version of that open source
which can be installed on premise
well so enough of the commercial but
that's what the product is so its
platform as a service and what i've done
here is i've logged into my console we
have a couple of organizational
structures so here you can see we have
something called an org so I'm in the
platform engineering or gets the org
that I share with my colleagues and you
can see that I've got access to a number
of other orgs as well and org is further
broken down into spaces so you can see
some of these spaces are have the names
of some of my team members but then also
you can see here that there's a space
called development a space called
production at the space called staging
and so on so we just break the
organization down into these these
spaces which allow you to do things like
apply policy so for example if I go into
the development space one of the
policies that you can apply our access
so access control policies so you can
see here in development a whole bunch of
different people can do things in my
development space but if I go into
production you can see that it's a much
smaller list of individuals so there's
only a couple of people that have access
to push things into production so you
can see here I keep emphasizing I've
already said it several times that it's
not just for the developer it's also for
running your production workloads soap
as this is the first if you take nothing
else away from this talk pass is not
just for the developers it's at least as
much for the operators now this is a
developer audience so I'm going to be
talking mostly to the developer benefits
and how you use it from a developer
perspective but there's huge operational
benefits as well you can up then the
next thing you'll notice is that within
a space I see applications and I see
services so I see a list of applications
that I've deployed in this space those
applications are up and running that's
what the hundred percent means here and
I have services that those applications
are leveraging and again by services I
mean things like databases message
queues index services all of those types
of things those things are scoped to a
space so you can see here I've got the
list of applications that are running in
my production space in a list of
services that are instantiated
in my production space and if I go back
over into development you can see that
it's a completely different list and we
will come back to that concept as we go
through some of the the architectural
things throughout the presentation okay
so this is my development space and I'm
going to deploy an application into this
development space so that we're all
developers here we can be propellerhead
so I'm going to do that from the command
line you can also do this from within
your IDE within a spring source tool
suite or eclipse so we have an eclipse
plugin we don't have plugins for other
IDEs but we do have an eclipse plugin
but the first thing that I'll show you
here is that first of all if I do a CF
target so CF is our command line target
you can see that i'm pointing to the
same cloud API rhonda pivotal dot IO and
I've logged in and I'm in the same
organization platform engineering and in
the same space that I was just showing
you on the screen so now i'm going to
deploy this java application so here's
my java application you can see that
I've already built it so if i go into
build / lives you'll see the war file
there's the spring music war and i want
to deploy that so i'm going to do is
simply do a CF push and i'm going to
point to that war file build lieds
spring music build / lives spring music
and I'm going to give it a name so I'm
going to say JA Java one music and i
think that's it we'll go ahead and
deploy it and the first thing that
you'll see happening here on the screen
is that there's this message that says
creating route so what it's doing there
is it's taken by default the name of my
application javaone music and the
default domain that's configured into
the platform which is c of apps do and
it's assigning a URL so if you tried to
push an application to run dot pivotal
dada i wrote right now with the name
javaone music you wouldn't be able to
because i own that URL now that's all
provided for you as a part of the
platform that URL
then we go through what's called the
staging process what we do in that
staging process is that you'll notice
that I just deployed a war file I did
not have to provide a jdk I did not have
to provide a tomcat or any kind of
application server I didn't have to
bundle in some of the dependencies so
some of the dependencies are in my war
file but some of those other
dependencies are in there and what we're
doing here is we've detected that it's a
java application Cloud Foundry is a
polyglot pass so it's not just for java
we also have support for out of the box
Ruby nodejs PHP Python an golang
question oh yes it can it's so the
question was to repeat the questions do
I assume a war file and the answer is no
that was our first use case so we did an
awful lot around war files but you can
run things like standalone java apps so
you don't necessarily have the war and
we're not going to go into the details
of it here but the way that this runtime
environment is encapsulated is through
something called the build pack so build
packs are the way that you basically
specify what your runtime context looks
like now I mentioned that we have
support for a lot of different languages
so we have build packs for Java rubino
j/s PHP Python golang and build packs if
that sounds vaguely familiar it does
come it's exactly the same notion that's
used in Heroku so it's the same
specification as Heroku build packs so
there are Heroku build packs out there
for things like Haskell and our and
yadda yadda yadda those work on Cloud
Foundry usually with zero changes now
the reason that I'm going off on what
seems like a tangent is when we come
back to the question around Java is that
when it comes to things like the Ruby in
the nodejs build pack those build packs
are very close to the Heroku build packs
we have made very little if any changes
to those and we've just bundled those as
a part of our product you might know
we have Java or we have spring pivotal
has spring so we kind of think we know a
little bit about Java so we have created
our own Java build pack and that Java
Java build pack has all sorts of
capabilities so it does web applications
it does standalone applications it does
schedule the applications and so on so
there is all refer you to if you look up
in our github repository which is github
/ cloud foundry look for the Java build
pack and you'll find fabulous
documentation on all the different types
of Java applications that you can deploy
so great question alright so that's the
staging processes we've taken that build
pack we have laid down the runtime
context for that then we've deployed the
war file into that runtime context and
then we did something that says up there
uploaded droplet what we do after we've
laid down that runtime context is we
take a week at our wheat are up and
we've done that all by the way inside of
a container and if you're thinking
docker you're thinking along the right
lines in we are not using docker yet why
because we built our own implementation
we call it warden we built it for years
ago before the company that created
docker even existed so it's based on the
same stuff as docker but we actually
depend on things that docker doesn't
have we are moving in that direction
though but the essence is we create a
container like a docker container we lay
down the runtime context we lay down the
application bits into it then we tar
that up and that's going to and we save
that tar ball so that if we need to
recover that app or scale out that app
we don't have to go through that staging
process again now then we started the
app up and the app is up and running so
let me come back over here
and there is my application and let's
see if there's got to be sort by artist
my goodness there is no Aerosmith in
here how about that so this was written
by a colleague of mine and he must not
have Aerosmith in his catalogue I'm
going to have to I'll see him this
afternoon I'll have to give him a hard
time in fact I wonder if I oh here we go
let's add an album album title uh I
don't know greatest hits they've got to
have a greatest hits Toys in the Attic
Toys in the Attic artist arrows
Aerosmith okay and now we have Aerosmith
in our catalog okay i'm clicking the ok
button what's happening oh I need to
have something in here one was that
released 1973 Wow rock is the genre okay
there we go we have Aerosmith in the
catalogue now now you'll notice what I
deployed this I've been talking about
mentioning services I don't I didn't
bind this to any database and the answer
lies in this little icon up here on the
right hand side and you may not be able
to see it so I'll read it to you it says
profiles these are of course are the
Pring profiles that you're familiar with
but there's a little services thing in
its blank so right now this application
is just running in memory it's just
running in memory so let me show you how
easy it is to add a database to this as
well so let me come back over here in
two pivotal web services I'm going to go
down into my marketplace and show you
all the different services that are
available available in the marketplace
again you can see search services
non-relational databases relational
databases and so on I'm going to go
ahead and create a relational database
here and I'm going to select this plan
which is the free plan
I'm going to name the database come on
waiting for there we go instance name
javaone DB and I'm going to put it in
development and I'm going to bind it to
my java one music app so now I'm binding
that database to the application and I
say add and then I'm going to come back
wait for that to get provisioned this is
by the way in our public offering all of
these services are provided by 3rd
parties through SAS offerings so clear
DB is providing the my sequel database
now if I come back over here into
development I'm going to cycle my
application so I'm going to come to Java
one music and a little i'm gonna hit
restart so i'm going to restart the
application you're going to see it
restart here alive you'll notice here by
the way that it shows me all sorts of
events it'll show me logs for that
application and so on so there's all
sorts of cool things here it appears the
app is back up let me hit refresh up
maybe it's not back up yet it lied to me
oh that's not good that's how you know
it's real right it's a real demo it's
not just a video since it's running
there we go and if I sort by artist
you'll notice that aerosmith has
disappeared and that's because now I've
bound into a database to remember we
just had that in memory but that's as
simple as it is now that's the intro
that I wanted to give you now let's get
into the regularly scheduled programming
so now you've seen what it means to
deploy a nap what it means to create a
service bind that service to an
application and so on and that'll make
everything else that we talked about in
the rest of the session I think a little
bit more real so very briefly what
happened when we did that deployment I
already showed it to you on the screen
a ms we uploaded the application bits
plus some metadata metadata like how
much memory am I going to use what's my
URL those types of things then we
actually did it in a slightly different
order but if I could have done the
creation of that service and the binding
of that service before we deployed it
the first time then I'm going to go
through that staging process remember
the build pack plus the application bits
we upload the droplet into the store we
deploy the application the application
is up and running now and then there's a
cool part that I won't talk about in
this session where I do a demo where I
kill the app and it comes back
instantaneously there's a whole bunch of
health management that is in the
platform for you as well kind of on that
operational benefits side so that's a
topic for another day and then finally
the last thing that I want to tell you
about is I just want to share with you
what it is that motivates us when we
think about how we want to evolve the
platform the features that we want to
put in it things like that what's
motivating us is this notion that
software is eating the world it's this
notion that every single industry and it
doesn't matter what industry you're in
is being disrupted by software and it's
not just that software is being brought
into those areas in some cases
software's been there for a long time
like in financial services but it's that
new players are bringing better software
experiences to those industries and
stealing market share away so for
example square is literally the
financial I work a lot with the customer
with financial services firms in New
York City I've been there many many
times this year they are shivering in
their boots about what's happening with
square and they need to be able to
innovate and bring softer to market in a
different way in different media mediums
mobile those types of things that's what
we're trying to do we're trying to
enable that with our platform to be able
to enable you to get software to market
faster but even more importantly more
frequently
so you need to be able to do continuous
delivery so everything that we put on
our platform is motivated by exactly
this all right so now let's talk about
that application I mentioned it was a
reference application that was built by
VMware and it was called spring trader
it's a stock trading application pretty
simple idea simple concept here there's
a UI and I'll show it to you maybe I'll
show to you will probably probably will
run out of time but there's a you I hear
that you can see I can log in I can see
stock quotes I can see my portfolio I
can buy and sell stocks those types of
things now on the far right hand side of
the slide you see the basic very simple
simple architecture of this application
we have at the front end a multi-tier
application in box a we have a
presentation tier which is a
javascript-based rich Ajax based
application so that's the presentation
tier the web tier inbox be we have a set
of a restful services that the web tier
calls and those two things and that of
course is showing you things like your
portfolio and it so that it's it's
serving the data to the web tier which
is showing you the portfolio now that's
where you can you're using the web tier
to put in a stock trade order and of
course that stock trade order you're all
familiar with this doesn't happen
instantaneously it doesn't happen
synchronously you put in your stock
trade order and sometime later usually
within seconds but sometime later that
stock trade is executed well box d over
there is that back-end fulfillment
application that is fulfilling those
stock trade orders the way that those
two parts communicate is via a message
broker which is box fee and then all of
the stuff that's happening account
profiles with what your what stocks you
have what your stock trading history is
and all of that is stored in a database
so what we have here in the vernacular
now taking what you saw in the demo just
to
going to go what we have are three
different war files box a B and D are
your application pieces those are the
war files and boxes C and E our services
so created a clear DB or we're going to
click create a RabbitMQ a message broker
and we'll create those services and bind
those two Box B and box d okay now this
is where we started this is what the
getting started guide looked like when
you have spring traitor two years ago
against the vSphere architecture now in
all fairness it's only goes to about
here deploy spring traitor and then
there it's repeating some of the
instructions on two different platforms
Linux and Mac but if you take a look at
that we read down there and it says okay
install TC server install sequel fire
install erling because you need that for
rabbitmq install rabbitmq do some
configurations start RabbitMQ start
sequel fire yada yada yada and write
about down here you deploy your
application so when we talk about past
being valuable to the developer it's all
about getting rid of all of this stuff
up here and I'll show you what it looks
like in the end by the way all of this
is available in a github repository and
the URL will be in here and i'll be
posting these slides to SlideShare this
afternoon my SlideShare handles exactly
the same as my twitter handle its see
davis AFC so see davis AFC you'll find
the slides there as well and i'll tweet
about it when it gets up there alright
so I thought the best way to share with
you what we needed to do to migrate this
application from that kind of legacy
deployment model into this new
deployment model is to show you what we
did well how we had to change the
application to make that transition so
this is what you'll find in the github
repository and we're going to talk
through each one of the things that we
had to do in just a moment
I was going to say something I lost my
train of thought github repository oh
yes I know what it was you'll notice
when you go into the github repository
that I changed virtually no code there's
one place where I have to add a little
bit of code I had to add some security
filters other than that it was really
just a matter of changing spring
configurations so that's the good news
is he I didn't have to change my
application code I was just able to
change everything in the spring
configuration files in doing the shift
in the deployment model so let's go
ahead and talk through that so the first
topic the first thing that we had to
address was remember this is the
deployment this is the architecture
diagram so in the old way of this being
deployed you deployed the web tier so
there were three more files you deployed
the web tier there was a war file and
you deployed it to something like spring
trader.com / web and then you deployed
the services tier 2 something like
spring trader.com services so you had
the same base URL but you just had
different things after the slash when we
deploy that into cloud foundry if we
deploy two different war files two
different war files get two different
URLs okay so i get trader webca paps I
oh and trader services CF apps do I'm
immediately facing cross-site scripting
issues because even though the sub
domain the bass part of the domain is
the same because the first part of the
domain is different I have cross-site
scripting that I have to deal with now I
mentioned that we were doing this last
year when we were getting ready for sa
peas tech at event and at the time I
knew that it wasn't that hard to do
these spring security filters but I we
were on a tight timeline and oh by the
way i mentioned pivotal labs and we get
things running first and then we
refactor so the first thing that we did
to get things running was we just
created a single war file I'll come back
to this we ended up
solving the problem the right way and
i'll show you how we did that and just
it just a little bit later in the
presentation but what we did there was
we munch things into a single war file
now all asked the question that some of
you might have in your head that you
might not be raising your hand to ask
yet but the question might be hey can I
deploy multiple war files as a single
thing into cloud foundry and the answer
is today you can't but we're always
thinking about that we hear about that
from from individuals once in a while
for the most part we are leaning away
from that and it has to do with the way
that we want people to start to deploy
things as micro services and really try
to keep things in non monolithic
architectures but we can talk if that's
something that you're really passionate
about so you'll see in the github
repository that the first thing that we
did was we change the build Gradle file
so that we pulled things into 11 war
file there this is definitely a hack and
we get rid of it later on so that's the
first thing that you'll notice and that
was the first thing that I wanted to
teach you about the way that we're
deploying things now the second thing
that we did was that we changed from
this jmd I look up into and if you'll
remember on the right hand side I'll
build that out and I know you can't see
that the text here very clearly but I'll
read it to you so if you remember we did
this service broker we have these
services that we bound to so remember I
was talking about the fact that I've got
war files and they're bound to RabbitMQ
and they're bound to a relational
database okay so that's where that that
service broker comes in what we do and
that you'll also remember that when I
showed you in the UI I showed you that I
had a different set of service instances
in the different spaces so in
development I had one set of services
and in production I had a different set
of services our best practice there is
that you named those services the same
thing in the different spaces so here
we've got trader messaging and trader
sequel over here in the staging space
and in production we have trader
messaging and trader sequel as well
the staging space I'm bound to a
database but there's no personally
identifiable information in that
database there's no PII data it's a
customer database but it's been cleansed
and but it allows me in staging to do
performance testing and all of that
stuff when I deploy to production I'm
binding to the actual database with the
real customer data we have an
abstraction layer there that allows you
to use the same name now you don't have
to and then you might I have some tricks
that I'll show you around how you
configure that but the whole point is
that we have a catalog of service
instances that are available so this
jndi of courses is an aiming service
allows me to look up something by name
and then grab that in in this particular
case injected inject that data source
into another beam into Maya data beans
for my application and instead of doing
jndi in the cloud foundry environment we
use this type of a configuration so
again if you look in the commit in this
particular commit you'll see that we
replace that jndi line was something
that looks like this now we have a
project which back then was called
spring cloud and I should have updated
this slide it's now called spring cloud
connector how many folks were at spring
one in Dallas a a couple of weeks ago Oh
nobody okay bummer so announced there I
don't know if you saw it was the spring
team announced a new umbrella project
called spring cloud which is all about
microservices so they're bringing a
whole bunch of Netflix OSS stuff to
spring and and that's really really cool
so we used to call this spring cloud we
now call it spring cloud connector it's
part of this bigger umbrella but what
spring cloud connector allows you to do
is it allows you to configure a javabean
so the beam here the beam name again is
a datasource the type is a data source
so we define
a namespace here by the way this app was
written two years ago so it's all xml
config still we haven't transitioned it
over to java based configs so you can
see of course that it's xml so my bean
name is data source and my service name
is trade or sequel so I can use this
configuration whether I'm deploying this
and remember this configuration file is
a part of my war file I want to deploy
the same war file into my development by
staging in my production that's all part
of that continuous integration pipeline
is that I don't have to recompile things
as I move through my application
lifecycle so that's what allows me to
declare that beam so you can see that
it's very very similar to jndi it's
basically looking things up by name but
in this particular case it's looking
things up in the cloud catalog not in
some jndi service now I was talking
about the service name you can omit the
service name and if the service name
isn't listed as a part of the
configuration then what we do is we look
to see if there is a data source a
relational database service that's bound
to the application and if there's only
one one and only one then we'll go ahead
and do that binding for you okay if you
have an application that binds to
multiple data sources then you have to
reference them by name okay all right so
then the next thing that you'll see if
you peruse the commit history is you'll
see so we have this is I want to talk
about big a applications and little a
applications we call each one of the
deployments which now is a traitor front
in a traitor back we call each one of
those app instances when I say app I
mean little a app it's not really your
whole application it's just one of those
application components so each one of
those war files is deployed as an app
but you're of course interested in
deploying an entire application
that consists of all five of the boxes
that you saw on the screen or at the
moment there's only four boxes because
we've glued two of them together so how
do we do that well we have what we've
done here again in the chemistry is
you'll see that we've added what we call
a deployment manifests so this is a
declarative manifest that allows me to
say deploy this application deploy this
application point to the various war
files assign the names to them which are
going to result in the URLs being
assigned to those as well and then in
this particular structure we've taken
and we've declared a number of other
pieces of metadata for each of those app
instances globally at the top of the
manifest I'm not a huge fan of these
global variables I am working with the
product manager there but it is what it
is this is the way that you do it what
you can see here is that in each case
each of the war files we've given it
each given each one of those apps a
single instance each one of them gets a
gig of memory and each one of them is
bound to trader sequel and trader
messaging now you'll see a little bit
later when we get further on in the
conversation that I actually had to step
away from this declarative manifest and
I'll explain why when we get to that
point in just a moment but again you can
see now that this is essentially
expressing the topology of your
application okay so it's it's giving me
a nickel it's declaring what that would
this previous picture it's declaring
this and it allows me with a single CF
push to deploy that entire thing all
right let me talk a little bit about
plans when you saw me do the demo I went
into clear DB and I selected the free
plan we of course allow you through this
service broker metaphor to define a
catalog of offerings and if you're doing
if you're deploying cloud foundry in the
enterprise of course you can have your
own catalog of offerings and we allow we
have a way through the service broker
API for you to bring your
Corporate Services into the picture as
well and you can define different
service levels on those so in databases
for example you might have different
amounts of capacity different sizes of
connection pools those types of things
so we offer ibly basically have in place
a structure for SLA s and in different
plant sizes so what we did here was
going back to this configuration that I
showed you just a moment ago where we're
binding two different services one of
the things that we did in here was we
said ah ok I can set the attribute that
defines the size of my pool my
connection pool so I needed to out align
the my configuration the size of my
connection pool with the SLA with with
the plan of the service that I had bound
to so since I used the free plan which
only has four connections and in the
github repository you'll find the
configuration this way because we want
to allow you to deploy things against
the free tier just out of the box and so
this will allow you to deploy this
application we allocate to connections
to the front end and two connections to
the back end ok so that shows you how
you can configure your data source beam
with the connection pool size and
correlate it to what you have available
in the service alright so then let me
talk about auto reconfiguration a little
bit so spring of course is in the in the
business of doing a lot for you so we do
a lot of naturally we do a lot of
configuration so if your auto wiring
stuff we take a look at things and if
it's if there's no question on the way
that things are supposed to be wired so
for example earlier i said if you're
deploying a war file and your binding to
a single database then you don't have to
name that database we will say ah ok if
you provide me a single database I'll
assume that that's the right one and
I'll bind it for you so that is
something that spring does an awful lot
of they do an awful lot of wiring but
the one thing that I
to share with you is this is a little
bit anecdotal because when we were
deploying when we were working on this
application we were under a tight time
frame I had everything up and running I
was deploying it we were binding to the
databases binding to RabbitMQ everything
was working fine and i forget i went to
document something or i went to look for
something and i'm searching through my
code base and i'm looking for the cloud
the spring cloud configuration for my
RabbitMQ and i couldn't find it I'm like
what is wrong with the darn search my
IDE couldn't find it couldn't find it
finally went navigated to the xml config
file and i found this and i had a real
big huh moment well huh moments are one
thing when you're doing a
proof-of-concept hot moments are not
good in production no surprises we want
no surprises but what I wanted to share
with you here is that notice that i
didn't use spring cloud connector this
is just a standard um spring annotation
that says oh i'm going to create a
connection factory beam and i'm going to
bind it to and there were some defaults
in there and it worked and the reason i
was surprised was because I had heard a
whole lot of chatter with in pivotal
about whether we would do auto
reconfiguration and include it in the
Java build pack remember somebody had a
question earlier about job and I talked
about this Java build pack and I was
under the impression that we had not
implemented auto reconfiguration in the
Java build pack and the answer is that
we did in fact implement auto
reconfiguration so that is why this
worked was that the Java build pack
included this inside of the Java build
pack so I actually didn't even need to
change some of these configurations in
the in the xml config files for my
spring trader app because the Java build
pack was going to do some of that magic
for me now
there's a warning at the bottom of this
slide that says just be careful because
you want to know what's happening and
you need you want to know you don't want
any surprises and production so I just
wanted to share with you that that very
surprised moment that we had at the end
alright so at that point that was kind
of the first cut where we went through
we got this thing up and running we had
it connecting to the essay p on a DB it
also works since my sequel and a number
of other databases but we had it all
working and we were able to demo it who
all really great and then we went back
and said okay we implemented a couple of
hacks to meet meet this deadline let's
go back and address some of those so
let's move forward let me go back to
that issue of cross-site scripting so
first of all let me make sure that we're
all on the same page as to what the
cross-site scripting issue is so the way
that things work in these Ajax based
applications is that I'm sitting here at
my browser and I go and I request a web
page from example.com I get back this
html5 I'm sorry this this index this
HTML will html5 document i get back this
HTML document which includes some script
and of course some of that script is
making these xml HTTP requests so it's
Ajax it's very it's a very what's the
word I'm looking for dynamic thank you
brain freeze dynamic APR dynamic you I
so it's making these XML HTTP requests
and it's going to example.com foo but
then there's this script that's
essentially then accessing the result of
what comes back from example.com / foo
so their script on my page that's
accessing that and communicating with
that all fine and good my example.com
site is controlling both parts of this
this relationship it's controlling the
script that's being served here
as well as the content that the script
is acting upon so they're both
controlling the same thing now what
happens if some evil script comes along
so now i'm going to evil sitecom and the
evil sitecom its controlling what's
going on on this web page it's
controlling this script and it's making
a call over to your service the vet the
value comes back from your service and
now this script is accessing stuff in
the in that that part of the document
the Dom right and that could be bad now
of course you should have access control
on this end point so of course you
shouldn't be returning information from
example.com / foo unless somebody has a
valid token but if somebody's been able
to hijack that token or you forgot
forbid you don't have access control on
that you've now open this up and so the
creators of HTML not html5 but hTML
earlier basically said whoa we are going
to protect you from yourself and so when
the URLs are different when the base
URLs are different the request will go
out the response will come back but the
browser will not allow the that response
to be accessible here it will not be
accessible from the script within this
page that is what cross-site scripting
is all about so that's that's the the
challenge that we needed to get around
so we're in different domains that's
what I just talked about so to
accommodate this you basically can say
and of course it's going to stop there
that's what I was talking about so
there's a number of different solutions
the solution that we've implemented
there and because this isn't a talk
about cross-site scripting per se it's
only a small part of it is all to refer
you to the github repository to look at
the details but what we've basically
done is we've implemented a course
filter what the course filter does is it
allows you to configure the
right here it allows you to configure
the service with a list of don't domains
that are allowed to see the responses so
in this particular case what I did was I
went to the traitor services and I said
ah allow traitor web to see that so
trader services sea of apps com trader
web CF apps do allow it to see the
responses and so very very simple
implementation of a course filter so now
we actually have three war files again
so we got rid of that hack alright so
the next thing that I want to talk about
is I got rid of that hack so I took
these two more files and I split them
back apart so if you remember that
diagram I had the web tier in the
services tier now there's separate war
file separate deployments that web tier
if you remember the services tier was
bound to rabbitmq and bound to the
relational database as services and the
way that we do that you saw me do it
through the UI is we actually do a
binding we and if I had done it in the
with the command line you would have
seen me do a CF bind service command so
we do a bind now I've got that web tier
and remember there was an arrow between
the web tier and the services tier so
what we want there is we want that
service which is deployed as an app into
the cloud to act as a real service to
the web tier ok so we've now got this we
have an app that's acting as a service
as well we're starting to move into the
direction of Micra services where we
have all of these little apps that are
bound to each other via these these
deployments so in order to facilitate
that I extended the spring cloud
connector so remember the spring cloud
connectors would allow me to go in and
declare a data source or a rabbit
connection factory just declare those
get those beans and have those bindings
it's a
source java project that of course like
anything in spring is totally extensible
so what we did here out of the box
spring cloud connector has built-in
support for all of these different types
so relational databases non-relational
databases smtp RabbitMQ and so on but
you can extend it so what we did in the
project and again you can go take a look
at the code is we extend it a couple of
classes to be basic HTTP web services
because I want my web tier to bind to
that services tier which is a basic HTTP
web service restful web service so we
created this and we created a couple of
pieces there and there's another piece
there's a little bit of a tricky part it
is documented but it's one of those
areas where the documentation is what I
call very dense it's one sentence that
says here's what you do and it doesn't
explain what you're doing so unless you
already know what you're doing it's
going to be hard to parse that and
understand it but the whole point is
that once you've declared once you've
included these new classes in your
project you need to put a file into a
particular place on your classpath and
and basically put the name of that venom
that class fully qualified with the
package name inside of that file so that
the spring cloud connector can find that
class for you so you need to make sure
to do that so if you ever extend spring
clogged connector and for some reason
you're like it's not picking up the
right type what is it maybe you've
forgotten this so hopefully there'll be
that little thing that little bird in
the back of your mind this is what was
it Cornell you saying there was a file
somewhere that's why that's there
alright so we now have this picture and
this is the part that I was just talking
about this rest HTTP I want this to be a
service binding so let me show you what
that whole binding looks like and now
deploying what deploying the application
looks like so the first thing that I'm
going to do is I'm going to
create those two service instances you
saw me do it through the UI where I went
and I went to the marketplace and I said
create a new database I could have done
that at the command line and that's what
I'm showing you here so create service
I'm going to create a RabbitMQ that's
the second one and create service trader
sequel i'm going to create the data tier
so I've created those two service
instances and now i'm going to deploy a
war file so i'm going to do a CF push
then i'm going to bind that service that
war file i'm going to bind to RabbitMQ
and to the trader trader sequel so the
relational database then I'm going to do
the same thing with the front end that
that a web service tier and then I'm
going to do something interesting here i
am going to take this application and i
want to treat it as a service instance
so the message broker in the data tier
those are already service instances
that's what I did with the CF create
services is I have an instance of a
database an instance of a RabbitMQ I now
want to take this application and treat
it as a service instance I do that with
a command called cups cups is shorthand
for create user provided service or
service instance what that allows me to
do is it allows me to basically insert
things into my naming service remember
when we talked about the transition from
jndi over to the naming that the named
catalog that we have in the cloud what
we're doing here is we are inserting a
name and some key key value pairs into
that catalog ok so create user provided
service instance allows me to say ah my
service name is trader front and here's
some key value pairs and that
effectively changes this into being an
app and a service so the color coding
here is the dark green our services the
turquoise our apps
well this is an app and a service now I
can deploy my web tier by simply pushing
the war file and binding to a service so
the way that I bind to that service at
the web tier is exactly the same as the
way I bound the trader front to the data
tier I just do a bind service very very
simple hopefully what you're what you're
seeing here is that we have some very
very simple abstractions that allow you
to build these things up and then and
that's the state that you'll find the
repository in and in fact let me very
quickly see if I can find there's a
script I don't have it up no I don't
have it up but there's a script you'll
find a script in the repository that has
all of those commands that you just saw
in that build out of slides the CF
pushes the CF create user provided
service instance that's all in a script
now I mentioned earlier that we have a
declarative manifest for this the create
user provided service instance is
something that we don't have support for
with that declarative model there's no
way in the declarative model to say hey
this thing that you're deploying also
make it available as a service instance
in the catalog and that's why I had to
move from a declarative model into an
imperative model so you'll find there's
a deploy script in there that is
sequential it's imperative now I'm very
sad about that because I'm a functional
programmer at heart and I like
declarative stuff all right let me do a
time check here perfect they can eat
about two or three more minutes to
finish up the slides and then we'll have
a few minutes left for questions so this
is the way that you'll find the
repository today so we went back and you
can see that we addressed a number of
other things now there's one thing that
is right there on my to-do list that I
want to add to this application and it
is and part of the reason that I haven't
added it yet is because that it was only
in fact in the traitor
seek I'm sorry the spring trader
reference application in theory before
it's not in fact there but what they had
wanted to do is they wanted to use
remember I said that it was an
application that was demonstrating a
whole bunch of stuff from the V fabric
sweet so what they had wanted to do was
they had wanted to use gemfire to do a
token replication so authentication
token replication and if you have
multiple instances of your traitor front
out there running because you either
need it for capacity or for high
availability or whatever the case may be
if you came in and you logged in when
you logged in you were hitting this
instance of the application then your
token your authentication token is
available here inside of this instance
of trader front but then if your next
request comes along and it happens to
hit this instance of trader front
because we're load balancing across
those things do I need to login again
and of course the answer is no we don't
want you to have to login again so what
we wanted to do in this spring trader
application two years ago was we wanted
to use gemfire is a very rapid way of
replicating that about the set of all
valid authentication tokens across all
of the different nodes here okay I'll be
frank with you that if you look in the
repository you'll find and I have the
scratching my head moment because this
is the way the documentation is written
but it's not actually implemented that
way is that we're currently persisting
those valid authentication tokens in the
relational database as a part of the
account profile don't do that but we're
going to refactor that out I actually
have somebody who's helping me with that
now so but this was the theory was they
wanted to be able to do this gemfire
replication and they were using
peer-to-peer now here's the rub when I
deploy three instances of the traitor
front application into the cloud today
remember i mentioned containers so
you're
application instances in the cloud are
running inside of containers those
containers allow you within a single
virtual machine and DEA stands for if
you remember I said droplet earlier I
said that once the application was
staged we had a droplet that we uploaded
DEA stands for droplet execution agent
so this is a virtual machine that's in
the business of running droplets so
that's what they're doing so it's high
density we we instantiate lots of
containers on once at one of these
virtual machines but in order to make
those virtual machines multi-tenant
those containers are very tightly
controlled they're very firewalled off
and I mentioned that our container
technologies called wardens so this is
like a little jail cell right so each
one of those containers is its own
little jail cell and you're not allowed
to look from one to the other there's no
peer-to-peer messaging between these
things not allowed so how do we deal
with this then I want to do this login
session state cashing I want to do this
login token cashing across those things
well the answer is to use that same
services protocol that we had before now
I'll mention to you that we have built
into the Java build pack that we've
talked about a lot here is that we have
this capability where you we
automatically will do HTTP session
replication for you so if you deploy a
java application and you bind it to a
Redis instance with a specific name I
believe believe its session dash caching
if you have a Redis instance with that
name session caching then we will
automatically take your HTTP session
data and replicate it into Redis so that
if you're going against this one it does
require you using sticky sessions so you
have to do it with Jake we leverage the
jsessionid so if you're hitting this one
and something goes wrong with this guy
and you
redirected to this jsessionid of course
only works if the session is the
instance is up but will redirect you to
somewhere else if that instance is not
up it will be able to retrieve that
session from the from Redis we are
working on doing something similar here
we're going to if you look in the
repository in it in a few weeks time
you'll see that will have something
similar for the for the login tokens
tokens alright so the final punch line
then is remember this install install
configure configure start dadada now the
installation instructions for the new
github repository are you build it you
create the service instances and you
push the application and that's it so
that's where paths is really brilliantly
wonderful for the developer ok all right
I think see somebody taking a picture
before I slide this forward I think
that's my last slide in any case
okay and that is my last slide so are
there any questions yes
yep good question so the question is do
we do any auto scaling so do we scale up
new instances and what about
applications that take a while to start
up so we do have some auto scaling auto
scaling comes through a binding to an
auto scale service so if you bind an
application to the auto scale service
will watch that and we'll do auto
scaling that's experimental at the
moment it's not G ADF but it's available
out in the marketplace in terms of yes
spring apps sometimes take a long time
to start up you do have one of the
things that was in the declarative
manifest at the beginning was you saw
that 180 seconds that was me bumping up
that time out allowing you a longer time
and I can't remember if 180 seconds is
the maximum I think we went all the way
up to five minutes but we do allow that
so yes another question
that's kind of the challenge I don't
want to bring in
right so the question was I want to run
my app in the public cloud but I want to
access things in internally in the data
center so we don't give you any magic
around the firewall rules that you're
going to need to configure we do however
have something that we call application
security groups so application security
groups allow you to one of the things
you'll notice here is the emphasis on
the container and you'll notice if you
remember when I showed you the demo at
the beginning that you never saw the you
never saw infrastructure primitives you
didn't see machines or networks or
storage that kind of stuff so the way
that you've traditionally done things is
you've configured firewall rules at
machine boundaries we have a fee a new
feature called application security
groups that allows you to start to
configure some firewall settings right
at the container level right around the
application currently those are egress
so I believe in this particular scenario
you might be able to say hey I'm going
to deploy applications here that are
only only these applications are going
to be allowed to try to talk to these
particular IP ranges then of course you
still need to deal with your firewall
rules and we don't do any magic there
there's no magic around the network
stuff so okay I'm being asked to wrap up
so I'm going to stop here I will stick
around I can step out into the hallway
so the next speaker can come in and
answer any additional questions so thank
you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>