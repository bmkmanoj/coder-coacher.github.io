<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CON6851   API Design with Java 8 Lambdas and Streams | Coder Coacher - Coaching Coders</title><meta content="CON6851   API Design with Java 8 Lambdas and Streams - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CON6851   API Design with Java 8 Lambdas and Streams</b></h2><h5 class="post__date">2015-12-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/MFzlgAuanU0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning everybody i'm brian gets
this is stuart marks we work on the java
platform at oracle and this talk is api
design with java eight lambdas and
streams so this is a talk about the
considerations for how to use the new
language features that were added in
java 8 in your own api's api design may
sound like a rarefied topic but in
reality we're all API designers whenever
we program if we're programming well we
are you just separating components it's
layers and we're building api is between
them so the considerations that we use
in designing api is in the jdk may be
useful to you in building your own
programs even if you're not building api
is that are published for other people's
consumption so we're gonna talk a little
bit about some lessons that we learned
along the way in building the api is
that were added in java 8 and hopefully
those those may be useful to you
whenever a technology is new it takes a
while to figure out how to use it right
so in the early days you know in the
java 100 days none of us knew how to
build api's for java and you know the
book effective java that josh bloch did
was essentially the lessons learned from
building the collections library in you
know that was added to java in in 1-2
and it took us a while to figure out how
to use the tools that java gave us to
build good api's and then when the
language changed in 5 and we added
generics api's that may have made sense
in a in a more and in a little less
strongly typed world
all of a sudden weren't exactly right
and and again took us a while to learn
how to write good generic api's and when
we added lambda expressions to the
language in java 8 the same thing
happened it's gonna take a little bit a
little bit of time to figure out how
should api is change so api is that
might have been as good as they possibly
could have you know could have been in
java 7 all of a sudden start to look a
little stilted you know when you have
lambdas in the language and you look and
you see things where oh we could have
used a lambda there so invariably
there's you know a rush to go update all
the libraries sometimes we over rotate
takes a while to find the equilibrium so
that's essentially what this talk is
about having you know we believe we
found our equilibrium and
sharing a few of the lessons learned so
we're gonna talk about you know using
the features in Java eight language
feature lambda expressions as well as
some of the library mechanisms that were
added to the library in Java eight
streams and optional and then we'll talk
a little bit about the about default
methods and you know and good ways to
use those near api's as well so for
questions we're gonna try to take all
our questions through Twitter so we have
a hashtag Java API it's on all the
slides if you can't remember it what
we're gonna do is we'll take a few
questions between each section and then
we'll take the majority of questions at
the end so if you have questions you
know tweet them as they come to you and
we'll we'll get to them okay so this
first section is about designing API is
for use with lambda expressions and I'm
gonna give a couple of examples from the
JDK that illustrate some of the wrong
turns we made and some of the
discoveries we made so to recap a lambda
expression is a compact way to express
code as data you have a little chunk of
behavior and you want to pass this into
a library and it's concise which means
that it is not painful to use we've
always been able to express code as data
using inter classes but they were clunky
and people didn't want to use them and
so people didn't build API is that
required that required inner classes
even though they could have built a lot
of the same api's then they just were
too clunky to use and so we didn't do
that being able to pass around behavior
as data means that you can write ap is
that have a sort of more permeable
boundary you can say do this for every
element of a collection do this if an
error happens do this after this event
happens and it allows the the client to
sort of pass more information into the
API so the API can take over control and
do more work on behalf the client so you
know for example like in the regular
expression API without lambdas you you
you have to have this interactive
conversation of giving me the next match
now
I'll do something with it give me the
next match now I'll do something with it
with lambdas you have the ability to say
here's some things here's something to
do when you get a match now go find all
the matches and don't bother me until
you're done so this it tends to lead to
not only more expressive code but less
error-prone code but close you're able
to concisely say here's what I want to
do and then get out of the way so like I
said you know the tool we had before was
in her classes that was clunky
syntactically it was clunky from a
runtime perspective you had to make a
class you had to make an instance of
that and it was one of those problems
one of the solutions that seemed clever
at the time you know and when they were
added in 1:1 they seemed like wow this
is really you know this is much better
than what we had but then of course you
get used to it and you realize gee it's
not as good as we'd like it to be all
right so let me give you an example of
an old API that we migrated to use new
features in Java 8 so how many people
here are familiar with thread-local ok
so the thread local stores the thread
local value and one of the things that
lets you do is choose what the initial
value for that is and to know to do that
if if you if you don't care you get
initial value of null if you do care you
can subclass thread-local and override
the initial value method this is called
the template method pattern and this
works but again it's a little bit clunky
that if you want to have a non-trivial
default value you have to subclass
thread-local so which isn't terrible but
you know in it's it's in some sense it's
a little it's sub classing is a big
hammer to use to solve such a simple
problem and then you know once you know
why the first the first time someone
calls thread-local yet on a given thread
the thread local class calls the initial
value method once uses that to see the
value and then and then gets out of the
way if we were designing thread local
today and we had lambda expressions we
wouldn't do it this way now we have
thread local out there we don't want to
throw it away and rewrite it because it
is useful it's just not exactly the way
we would write it too
but we were able to adapt it in such a
way that new uses of thread-local could
use a more concise
you know mechanism for initialization
without throwing away the old way so
here's how it works so the old way is
you subclass thread-local you override
the initial value method and and and it
returns an initial value on demand what
we did was we added a static factory
method to thread-local called with
initial and the argument of with initial
is lambda expression that when invoked
returns the initial value it does
exactly the same thing the client code
is obviously a lot more compact and it
means that clients don't have to go and
subclass this thing just to customize a
little bit of behavior if we were
designing thread-local you know today we
would do something like pass that lambda
to the constructor of thread-local
because we were retrofitting it the
sensible thing to do was create a
factory and and and do it this way so if
you have existing classes that are using
the template method pattern and you want
to migrate them it's not you don't have
to make an either/or choice you can go
and add additional constructors or add
additional factory methods to those
classes so that they can be initialized
in a more convenient way so there is a
nice migration path you don't have to
throw away your old code you can adapt
it and and gradually migrate your
codebase and in fact you know we haven't
even migrated all the uses of
thread-local of the jdk to use this we
will eventually but you know when it
gets to the top of the priority list all
right so let me let me give another
another example of evolving an API to be
more lambda friendly so imagine you want
to create a multi map which is to say a
map that where the values is a
multivalued set so for example you know
all of the values associated with a
certain key you want to accumulate them
into a list or an array or a set or or
what have you
now it's really easy to simulate this
with a map you can save map from some
key type to a list of some value to
and you know when you want to insert an
element into the you know into a map
like this what do you have to do well
first you have to check if the key is
there if it's not there you have to make
an empty list you've got to put that in
the the map and then you can add the new
element to the map now this isn't hard
right but it turns out that you know it
ends up being a little bit of
boilerplate code that we repeat over and
over and over again so you know here's
an example of this code in action we
have a map from key to list of value and
you want to add an element so the first
thing you do is say get the L get the
value or the list of value associated
with that key if it's no create a new
list stick stick that list in the in the
map and then either way you add the new
element to the list whether it was the
existing list or the old list how many
people here have written this code how
many people who have written this code
more than once many people here have
written this code more than 10 times how
many people are tired of writing this
code alright I think I've made my point
okay so what did we do about this we
added a method to map using default
methods because we can do that now yay
called compute if absence the behavior
of compute if absent is to capture this
little pattern of if the thing is
present then just return it if it's not
present call this lambda that creates an
initial value stick it in the map and
return that and what we get is the
client who wants to add an element to a
multi map can now just call map dot
compute if absent pass a little factory
lambda that that just creates a new
ArrayList and then whatever the result
of that is whether it's the existing
list or the newly created list add an
element to it can everybody read the the
code at the bottom of the slide there so
the bottom code is certainly easier to
read it's less error-prone
it's you know it's just much more
obvious what's going on right and so we
can capture this little pat-pat in a
boilerplate add it as a default method
to map and and then at some point later
we can go back and update all the uses
of you know of this idiom to use the new
more compact idiom
so what's the benefit of this in
addition to reducing some boilerplate
you capture a pattern that you're asking
that you've effectively asked your
clients to use over and over and over
again you've captured in a library well
that's what libraries are for right so
that we don't have to rewrite the same
code all the time so that it can be
centralized in a library and then as a
bonus it means that subclasses you know
can enhance the implementation of this
method in a way that's consistent with
whatever that subclass does so we added
this to map and it does you know the
straightforward thing but then in the
concurrent map implementations like
concurrent hash map or concurrent skip
list map they can be atomic as well and
so not only is it a notational
convenience meaning that the client code
is more compact but it's it also means
that more of the semantics are the
responsibility the library which is
where you want it all right
so switch topics a little bit when we
added lambda expressions one of the
obvious things you know that we wanted
to do was add some methods for sorting
to the collections right so we we
there's an existing collection so that
sort method that sorts a list and it'll
either sort it by the natural order or
by a comparator you pass in and default
methods allow us to add new methods and
lambdas allow us to you know pass around
little snippets of behavior so an
obvious thing to do would be to have a
sort by where the lambda you passed a
sort by extracts a key from whatever it
is a list of right so I have a list of
person I pass in a lambda that that
takes a person and pulls out the
person's last name and then I could say
sort by that little key extractor and
that seemed obvious right and so we're
like oh great we're gonna add these sort
by methods to lists so we started
pulling on that string a little bit and
there were some obvious you know obvious
things like sort by a comparable key
sort by a none comparable key but here's
a comparator how about sort by an
integral key well that seems pretty
reasonable to and dot dot so they were
like four or five of those
well what about sort in reverse order
all right well let's multiply that list
by by two and what happens if we want to
do a composed sort of first sort by last
name then sort my first name well we
could add methods for that too and well
what about nulls nulls are always weird
we might want some special methods for
dealing you can sort of see where this
is going right it's like you know you
could make the list of candidate sort
methods that we might add and hopefully
before you get to the end of this list
you realize whoa I I I took a wrong turn
somewhere I'd better back up and and
explore a different option so we were we
were pretty far down this this road
before we realized that things had
gotten out of control okay
so what what was the mistake we made the
mistake we made was we were working at
the wrong level of abstraction we were
working at the level of abstraction of
Lists where whereas a much cleaner level
of abstraction for sorting would be
comparator right so instead we decided
let's build some tools for making
comparators for modifying comparators
for composing comparators into other
competitors and that turned out to be a
much more fruitful fruitful direction so
a comparator is a very simple function
it takes two elements and it returns a
negative value 0 or a positive value
depending on whether the first one is
less than equal to or greater than the
the second one now how many people here
have written comparators the people who
have written too many comparators all
right you get my point
there's it seems like there should be
some ability to reuse the comparators
we've already written but we never do
every time we have to write a new
comparator we end up just writing a new
one because it's easier to just write
the whole thing out than to build on an
existing one and that seems kind of a
shame and lambda expressions give us an
opportunity to extract a little you know
little bits of a comparator that are
better that are relevant so that we can
compose them so as an example you know
you've got some you know some domain
object like student
and you want to make a comparator for
compare students by last name and here
we've done it with lambda expressions
instead of inter classes which is a
little bit more compact than the inter
class version but it's still not any
more abstract than the inter class
version so we say take the first one get
the last name use its compare to method
compare it to the last name of the
second one and that's fine and we can do
the same thing you know for a a
primitive valued property the structure
is a little bit different but it's it's
pretty straightforward right take the
two scores and then call integer dot
compare that's better than inter classes
but we want to do even better than this
okay so you know one aspect of
commonality here is you're doing
something twice you're saying get last
name get last name you're doing that
twice we should be able to extract that
little bit of commonality so that the
user doesn't have to repeat themselves
so what we did was we added some factory
methods these are static factories that
take a lambda and return a comparator so
these are sometimes called higher-order
functions because they take a function
and return a function you don't have to
be scared by the term higher-order
function you're basically saying take a
little bit of behavior that does
something simple and compose it into
some behavior that does something more
complicated
so the comparing method takes a lambda
or a method reference that extracts a
key from you know for off from your
domain object and then it does the
little extract the key from the first
one extract the key from the second one
compare them for you so that's nice
that's an improvement let's see where
that falls down and whether we can you
know we can patch that so what happens
if one of those keys might be null we
don't want to call compare to because
we'll get a null pointer exception so we
might want you know to in if we know
that nulls might be part of the domain
have special handling that says put all
the nulls at the beginning all the
students whose name is no put them at
the beginning or put them at the end or
do something with them right and we'd
like to be able to specify that behavior
once and not do it again so we've got a
little method here called so sorry we
have we have
to hear that expresses that of here's
how we would handle you know creating
comparator when one of them might be no
but this is kind of clunky right we
would like to be able you know this now
we're back in the doing it all yourself
and and that's not so great similarly
let's say you want to do a two-level
sort of dictionary sort first sort by
first name then sort by age well we can
write this out by hand and we all have
but the we would like to be able to
separate the pattern of do this ordering
first then do that ordering from all the
details of actually calling the
comparators so the cool new methods we
had of you know create a comparator to
sort by last name start to fall apart
when we have these more you know a
complicated sorting and if you try to
put these these two together of sort by
first name then my last name and one of
them is no the code is starting to get
complicated again so we can use lambda
expressions you know to you know to
restore simplicity this so for example
supposing we create a method that takes
a comparator and returns a comparator
the comparator that it takes is just
comparing two non null things and
telling you what their order is and then
what this method does is deal with nulls
so this one is called nulls first so it
looks to see if the the first argument
is no and if it is it just says you know
if the other guys know they're equal
otherwise you know the the left one is
less than the right one and then it
delegates to the comparator you passed
in so this is again a higher-order
function takes some behavior in produces
some more complicated behavior out and
now the benefit of this is at the call
site we're able to express our you know
this idea of sort by first name with
nulls at the front without all of that
goop that we had two slides ago so we're
able to say take the natural order for
comparing apply the put the Noles first
behavior to it use get first name as our
extractor and then and then the null
friendly comparator as the way of
comparing keys and then we say sort the
list sort the list according to that so
that's nice how about the the two-level
sorting can we do the same thing for
that well it turns out we can so we
write another another one of these
methods we call these Combinator's that
am you know a Combinator for comparator
takes a comparator returns a new
comparator so the comparator it takes is
it's it's it's an instance method on a
on a comparator and it takes another
comparator to be used if the two things
are equal right so it says first ask me
what I think of these two things and
then if they're equal I'm gonna delegate
to the other comparator to do a finer
finer degree comparison between the two
of them and then it just converts that
into a comparator as and and returns
that and so if I want to compare two
students by last name then first name
what I do is I say I used the factory
method that I showed the beginning to
make a comparator for by last name and
then I used this Combinator to say and
then turn it into a composed comparator
with this other comparator to do the
tiebreaking and what's the other
comparator it's based on getting the
first name so this is looking a lot
better than the you know than the
previous example and just sort of put it
you know all in one place the code at
the top is the handwritten even with
lambdas it's the handwritten I want to
do a two level you know sorting with
knowles the code at the bottom is the
same thing but all the boilerplates been
moved into the library so this turned
out to be pretty successful rather than
adding 4,000 sort methods to lists we
added like seven or eight methods that
make comparators we added some static
factories make a comparator given a key
extractor we added some combinators take
this comparator and ma
by its behavior you know inject null
handling behavior in composed to
comparators with each other there's one
there's a default method for reverse a
comparator what you say comparator dot
reversed and all it does is take its
compare method and you know and and flip
the flip the sign around so what-what
would have been a large number of
methods in list and also in other
sortable things turn into a much smaller
number of methods on comparator and also
it's an awful lot easier to test these
seven new comparator making methods well
first of all they're so simple that you
can look at them and tell that they're
right but it's it's a lot easier to test
these simple methods than to test four
thousand sorting methods you know so the
lesson here is you know sometimes you
see this combinatorial explosion of
complexity and sometimes that's
essential to your domain but very often
it's a sign that you're dealing with
something at the wrong level of
abstraction you're trying to get you
know the the list to handle something
that is you know may be better expressed
at the level of comparator and you know
so this may manifest itself as lots of
over loads of something it may manifest
itself as big complicated parameter
lists with like nineteen different
options you know and so and this is
often a hint that you can maybe push the
problem to a different layer and solve
it solve it that way
break it down into smaller features that
are more amenable to composition and you
know the the result we got with
comparators was really nice right the
implementation of each of those methods
was trivial they were it was obviously
correct by inspection and there were
only a few of them because the the
combinators like nulls first and then
comparing and reversed composed very
nicely on the base cases created by the
static factories so I think this is sort
of a good point to take a couple
questions have we got some good
questions from Twitter yes we have a
couple couple questions here
one is why wasn't it reasonable to add a
thread-local that takes three local
constructor that takes a supplier
instead of a static static Factory
you know we looked at that and there was
a reason and I don't remember what it
was well yeah I'd have to look at the
API again my my recollection of that is
that since its subclass of all you can
override anything and so if you pass in
a constructor argument but then override
the method that uses it it's sort of
wait this is kind of weird so it just
seemed like to me it seemed like a more
natural fit to say here's a static
factory you get an instance of some
class you remove sub classing and
overriding from the equation and the
behavior of what you get back from the
static factory is is specific and
well-defined
right yeah that was it they would they
were there was some ambiguity of what if
I used that constructor and override
initial value now which one do I call
and with the with the static factory
there was no no chance to do that so it
was clear what you were doing okay
another question here any thoughts or
plans on making consumptions of lambdas
less verbose so it's easy to pass in a
lambda or method reference but but
consuming them is there's no shorthand
for doing that so they don't like the
idea that you have to call the test
method on predicates they want to invoke
it like a function that would have been
a different way to do it in a different
language the path we chose was that
lambda expressions were a concise syntax
for creating instances of interfaces and
I think once you commit to that you've
got to commit to it all the way and so
the answer is we consider that we
decided not to many people asked us to
reconsider it we reconsidered it we
decided not to and where we are yeah I
have a I have another another viewpoint
on that one thing is sort of okay it's
it's great it's great that we have
lambdas and so forth but at the when
you're when you want to call at lambda I
think it's a great advantage that the
the caller could have passed in lambda
or anonymous subclass or an instance of
a concrete named class and and the user
of that doesn't actually care that's
right so in fact I've
I've created api's that took a lambda
and then in some cases had you know I
actually want to pass an instance of a
real class here so the fact that those
are the same is an advantage to collars
yeah absolutely
so shall we switch okay here and now
Stewart all right so let me let me start
talking about streams api's here so when
we were when we were working on java 8
we had lambda expressions well underway
and we had a nice prototype for them
going and so one of the things I looked
at was okay
we have library and we need to figure
out how to use lambda in it and so some
of the output of that was what Brian
talked about the first part but some of
it was looking at a bunch of other
places and figuring out how to lambda
Phi it and so one of the things we ran
into was there are a lot of things in an
API that aren't actually collections but
they're conceptually aggregates of other
objects and the most obvious thing to do
when you have an aggregation of
something is for each on its oh okay oh
we have this thing over here that
represents multiple objects so let's for
each on it and then when we were working
on lambdas we had oh we had these we
could we could do things like predicates
to do testing so that's a nice little
idea for lambda so let's have a filtered
for each as well and then transformation
function you that you can map something
into another value let's have a mapped
for each as well well we might want to
have a map filtered for each and and so
forth so you can start to see wait a
minute we've we've seen this before this
proliferation of things so we don't have
a for each and then a filtered for each
and a map for each and then you know
maybe assorted for each right so so
we're going down the same path here now
at the same time there you know there
have been some other work out there
about composing these functions together
and so what we also had at the beginning
was the precursor of what is now the
streams API and so what very quickly
happened was the idea of adding lambdas
around the library I think that was that
was a you know there was certainly a
good idea but the greater application
came from not just putting lambdas on
things but since we have the streams API
apply streams to everything and so so in
fact we went ahead and did that and
there a variety of places sprinkled
throughout the the JDK libraries where
we where we use streams instead so the
idea is not okay I have this great thing
called the lambda let's apply that
everywhere we have a new library
construct called the stream and let's
see what we can do with that and the
answer is it turns out quite a bit in
fact I just covered that already so oh
no but there is a question which is if
you have something that is conceptually
an aggregate of other things and you
want the caller to be able to look at
those multiple things do you return a
collection or a stream and so the first
order answer is it doesn't actually
matter all that much because if you're
given one it's very easy to get the
other so if you already have stuff that
returns a collection just call stream
and the caller can just call stream on
it and say okay well I have a stream now
have all my nice map filter operations
and so forth now if you write a new API
and the caller can get a stream out of
it but the caller actually wants a
collection so it can look at stuff later
well it can just say collect two lists
or something like that there's a nice
there's a nice collectors API at the end
of streams that that you can easily take
any stream and gather all the elements
into a collection so converting from one
to the other is pretty easy so it
doesn't matter all that much but there
are a few times when you might want to
think harder about do I want doing do I
actually prefer a stream or actually
prefer to return a collection so we'll
talk about a few of those here so one of
those is if creating the collection is
expensive so so if you have an
abstraction of things and you need to do
some IO or do a bunch of computation to
actually compute the elements store them
on a collection which there's there's
the computational cost of creating those
elements and then there's also the
memory footprint of storing them if you
simply return to that to the caller okay
that's what that might be a fine thing
to do well what the caller might do is
say oh I'm gonna pick through take one
way and throw the rest away so you just
wasted a lot of work so in a case like
that you might say hmm well why don't we
return a stream instead of a collection
and
what that does is it lets the caller use
all the stream api's which are laziness
seeking so if the caller wants to say
gee I want to I want to find the first
student whose score is over 90 or
something like that right instead of
doing a bunch of searching and gathering
and creation of student records only to
have the caller throw most of them away
just return a stream of those and then
the caller can do a filter and a fine
first and that does the minimal amount
of work gives the caller as a result and
we save a lot of computation and storage
space now on the flip side there are
times when you really do want to return
a collection and not a stream and there
are some cases where for instance the
elements refer to each other in a
particular way and so you want a
consistent snapshot of the state of
something at a point in time and in that
case you could do a stream and collect
it into a collection but if you have if
you have some computation where you
might want to bounce around within the
collection or you might want to have
like to borrow a term from database
terminology like repeated read
consistency then you don't get that out
of streams necessarily if you get a
stream look at its contents and then get
a get another stream the reason is that
streams are only reversible once so if
you get another stream you might
actually have different elements in that
stream so if the caller wants a
consistent view of things
or if you as the API designer believe
that the caller really needs to have a
consistent view of things then that's
the time to return a collection all
right so we said okay there are a few
times when you want to return a stream
how do you return a stream so so there's
a little bit of a there's a little bit
of an art to creating streams so but
there are there's some nice there's nice
implementation techniques scattered
around the library sometimes you know
you have zero elements there's stream
empty or if you have a fixed number of
elements there's stream dot of that
takes a varargs list those turn out to
be surprisingly useful so don't forget
about those but usually oh sorry
sometimes you have an internal
collection that you might want to do
some pre-processing on or you don't
want to expose directly to the caller
and so the nice thing is if you have an
internal collection and you call stream
on that and hand that back to the caller
the caller only has a stream and the
caller cannot use that stream to modify
your internal collection so that that
sometimes preferable to passing well
certainly if you returned the collection
directly then a malicious or carelessly
coded caller might actually modify your
internal data structures and so to avoid
that you might have to use the
unmodifiable wrappers and that's that's
kind of a pain so an alternative to that
is if you have an internal collection
already just call stream on it and
return that or if you have an array just
call array dot stream so these are real
simple cases now so if you have a class
that is some kind of conceptual
aggregation of other things you probably
already have a way to iterate over it
and so the way to - the way to expose
that is - to write an iterator and so as
wait did I know ok so if you have a
class that already has an iterator it's
pretty easy to take an iterator and turn
it into a stream and so there's a little
bit of legwork there are a couple of
utility methods that you need to
understand one is you first need to take
an iterator and convert it into what we
call a splitter ater and so there's a
splitter aiders utility class that
handles that and then once you have a
splitter ater the splitter ater is the
underpinning of the stream so then you
take the splitter Raider and turn it
into a stream by calling another utility
method on stream support so there are a
couple different variations on this
sometimes you have an iterator and you
really don't know how many elements
there are so if you're doing some IO on
a file or a network connection or
something like that you you don't you
don't know how many elements you're
gonna process all you know is gee I
might want to get the next element oh
gee there isn't one so I'll return false
from hasnext
but you don't know upfront how many
there are so the way to do that the way
to create a splitter out of
an iterator like that is with splitter
eight or unknown size on the other hand
sometimes you do have some kind of
internal data structure that's that
maybe you have to do some processing on
to generate but you might happen to know
how many elements you're going to return
and so in that case there's a different
variation of the splitter aiders class
splitter Raiders call that that takes a
size parameter and so what that does is
it gives the streams framework a little
bit more a little bit more efficiency
because it knows how many there are it
can do some better buffering or
potentially some better splitting
operations for parallelism all right now
sometimes you might not have you might
not have an iterator handy but in order
to get a stream out of something you
might have to write your own splitter
ATAR and there's a big variation in how
much effort and how much difficulty
there is in writing a splitter ater but
fundamentally the simplest way to write
a splitter ATAR only involves writing
one method and so you there's an
abstract splitter ATAR in the library
and you can override that and override a
single method called try advance and
that is kind of a fusion of the hasnext
and next methods of the the iterator
interface that all of you I believe are
familiar with but what that does is it
does both of those things at the same
time what it does is it advances the
stream if possible and returns the next
element and then returns true to
indicate there was an element or it
returns false and that's it so if you
have something that's amenable to that
then you can override abstracts
obliterator sorry subclass abstracts
bool iterator and override try advance
and in fact I find myself doing that
more often than writing new iterators
for things so if you ever ever written
an iterator there's this complicated
dance between hasnext and next where you
they have to share state and cache
something and you have to do some some
some fancy footwork there to make sure
that those methods are communicating
with each other properly so sometimes I
find writing the simplest splitter
aiders actually the
easiest thing to do if you want to
reverse some data structure there are
some other things you can override on
splitter ATAR and so these are these all
have default default methods on them so
you can get away with just implementing
try advanced but if you want more
efficiency you can put in more work and
get that efficiency so the next thing
that you might want to override is for
each remaining and so what that does is
allows you instead of getting the
elements one at a time it says ok just
do all the rest of them and so you can
just write your for loop and and do your
internal checking inside of a loop and
that gets compiled and inlined and gets
all the JIT compilation goodness out of
that and so that gets you a lot of
efficiency and saves you a bunch of
method calls now there's another method
on splitter Eider which is where things
really start to get sophisticated if you
have a data structure that is amenable
to splitting and you're interested in
parallelism then you want to override
the Tri split method so I'm not really
going to go over that right now there
are other talks that cover how to do
parallelism in streams but just to let
you know writing a splitter Eider is not
that big of a deal
there a couple simple methods you can
override and then you can selectively
override more and more and get better
efficiency all right so now on the way
to creating stream once you've created a
splitter Eider then just call stream
support dot stream and then that takes
another that there's another overload
that takes a splitter Raider
argument and then turns that into a
stream and then finally also we're all
concerned about efficiency here
sometimes you're not you you're not
going you're going to want to expose a
stream of primitives we have what we
call primitive specializations for int
long and double and so there are
variations of all of these things all of
the splitter Reiter classes and all the
stream support classes and so forth are
replicated for objects int long and
double and so the variations are pretty
obvious but if you have something that
where you want to return an into stream
instead of a stream of integer then you
just choose the same things with
slightly different names and it's pretty
obvious how that works
all right so there's us a bit of a recap
there's a there's a whole spectrum of
ways to return a stream from some data
structure so if you have a collection
there there's fixed arguments for
there's a fixed argument stream factory
there's an empty one if you have a
collection an array it's really easy to
convert those into a stream and then
there's this progression of starting
with an iterator you can turn that into
a splitter a derp and then to a stream
and then if you want to bypass the
iterator it gets a more efficiency
create your own splitter a derp and
there's a there's a number of variations
you can do and get more and more
efficiency for putting in more effort so
just a quick recap here I talked a
little bit about iterators and then
splitter raters and it's like well why
do we have this extra layer in here so
when we were developing and implementing
the streams framework what we found was
that iterator was really not quite quite
the right thing in particular we needed
a better abstraction for splitting and
parallelism but also like I mentioned a
little while ago iterator has these two
methods that you have to that you have
to coordinate and so there are some some
weird things that can go on in between
them the usual thing is for the caller
to call has next next
has next next but the caller can
actually call those in any order so you
have to defend against that so that
means you have to have extra logic in
fact what it usually my style whenever
I've had to write an iterator is just
call have next call has next first and
then return and then do something else
and then return it and so basically not
only do you have this interaction
between the methods but they call each
other and it actually results in a fair
amount of of complicated code that you
have to think about and so I often have
a problem where the first the first time
I write an iterator there's some bug in
it because I missed some edge case
somewhere so I find that it's easy often
easier to write a splitter Eider but
from a performance standpoint the number
of method calls necessary to get the
next element from an iterator is a
minimum of two and it's often more
because of this complexity that has to
go on underneath with splitter ater
there's a single method try advanced
that
either returns the next element or or
not or there's 4-h remaining which
bypasses the the entire sequence of
method calls for each one so so splitter
Raider exposes a bunch a bunch more
abstractions to the streams framework
even for sequential iterator iterating
even for sequential streams so it turns
out that splitter a derp is actually a
better sequential iterator than iterator
itself and it's also not racy yes
fundamentally racy
okay so we had a couple of couple
relevant questions here on this section
so the first one was do all the Java
library implementations support
parallelism and you know the answer is
the support for parallelism is actually
not in the stream library per se it's in
the splitter rater for the you know for
the source collection so all of the
collections in job util provide splitter
raters that have as good a splitting
capability as they can offer so
ArrayList splits really well tree map
splits pretty well link list
splits really badly but it will try
right it'll it'll it'll do something and
you know if the computation you're doing
per element is high you actually can get
some parallelism out of it but if you're
doing just a little bit of work on each
element you'll get no parallelism at it
but but yes all the collections have
been retrofitted with good splitter
Raiders that have as good a parallel
implementation as we can give it yeah
and even the simplest splitter aiders
the ones that overact override abstract
spill iterator try advance there's a
machinery inside of abstract splitter
ATAR that what it does it gets the
elements one at a time but it'll buffer
some up and then do splitting on that so
it's possible to get some limited
parallelism even if you write a simple
splitter ATAR know you're not gonna get
the best scaling certainly not if you
have an evenly divided array but the
potential is there yeah so uh another
question here is question on lambdas
since lambdas represent code is data why
are they not serializable see this just
follows me around
so the answer is some lambdas are
serializable they can be serializable
with the target type serializable so
that I think the question is really why
didn't you make all lambdas serializable
as by default and there's a really an
easy answer to that serialization
imposes two burdens on a lambda that we
don't necessarily want to impose on all
lambdas one is there's a performance
cost because creating a serializable
lambda is more work than creating a non
serializable lambda and the other is
there's a security cost serializable
data is less secure fundamentally than
non serializable data because it's
easier it has a bigger attack surface
it's easier to inject inject state into
it and so we felt that rather than
exposing the pain of serialization the
risk the performance cost all that to
all users why not have the one or two
percent of users who need serialization
for everything ask for it and have them
pay the cost for it so it can be but
we're not going to impose that cost on
everybody just because some people need
it and that's that's the answer there so
ok takeaways to it ok next section
optional there were a lot of questions
on optional but I figured you were gonna
ask how many ya seem how many I can
answer with this probably not many all
right but basics here all right so
there's there's been a lot of discussion
about optional I don't want to I want to
dive in all discussion but what I do
want to do is make a clear statement
about the primary use of optional and
I'll just read it here I usually don't
read my slides but this is important
optional is intended to provide a
limited mechanism for library method
return types where there's a clear need
to represent no result and we're using
null for that is overwhelmingly likely
to cause errors so that's a fairly
narrow statement and it's it's focused
in on particular set of circumstances
that occurs moderately often in in
writing library api's but it doesn't
occur everywhere and so it turns out
that there are many many places that you
can misuse optional many more than there
are uses for optional there are some
very good uses
or optional and I'll talk about those
before I get to the the counter-examples
all right so a bit of a recap if you
have a method return value quite often
you you might have some kind of
searching method or finding method where
it's entirely reasonable for it to say I
didn't find anything and or or you might
be searching for one thing and it might
say I didn't find that thing and so
that's that I think is the closest model
for when you would use optional because
an optional can contain an element or it
can be empty and so the nice thing about
well the main thing there is that the
usual the usual way you design API is
that can return one or zero things is
I'll just return null and the problem
there is that the caller says oh oh I'm
gonna get that thing and then call some
method on it and that's where null
pointer exceptions come from so that's
really the case that we are focused on
when we've provided optional in the
library and so that's one should be used
so if you have something that can return
zero or one elements use an optional
instead and what the caller can do is
instead of basically doesn't get the
element itself it gets an optional of
that element and so the caller then can
chain methods off of that to either do
things like either get that element or
if the optional is empty then to provide
a default value it's then so they're a
bunch of things you can do there I'm not
really going to go over into the API in
detail I'm just gonna touch on some and
touch on the most common cases here one
very very important rule is if you're
writing an API that returns an optional
never return null as the optional itself
that completely defeats the purpose of
why we added optional always return an
optional with a value or optional empty
never return null and so notice
carefully what I just said there there's
a null reference but I try very hard to
avoid saying optionals containing null
because that's really confusing it's too
easy to confuse with an actual
no no optional itself so what I prefer
to do is stick to saying an optional
that has a value or has a value present
or an optional that is empty or an
optional whose value is absent all right
so if you if you are returning an
optional from a method then what it does
is it allows the caller to take that
take that optional and do some things on
it safely regardless of whether the
optional is present or absent and so a
common thing to do is to say or else and
so that gets the value or it substitutes
a default value in its place if the
optional is empty so that's very
convenient for a lot of things so again
here don't say or else null or at least
try to avoid that because that buys you
back into the whole null thing now the
time to use or else know is if you're if
you're if you're working with a library
that returns optional and then on the
other hand you need to call something
where it says really passed null here
that's the time to say you know maybe
say or else null but I've got to think
about that a little bit so again usually
there's a different way to proceed than
saying or else no a couple variations
here there's or else get which instead
of providing a default value it takes a
supplier of the default value and so you
can pass in a lambda that will
manufacture that develop default value
on demand instead of instead of having
that precomputed sometimes you can delay
a little execution that way or do some
lazy lazy computation and then another
variation is or else throw if the value
is absent and there's and that's a and
that's a problem then you can throw a
custom you can throw a custom exception
if the value is absent no there's also
get which is kind of the most obvious
thing to do but it's actually kind of a
problem because that that buys you ended
pitfall because what it does is it
immediately throws no such element
exception if the optional is empty and
that's probably not what you want so
unfortunately get has the most
attractive name but actually the the
other methods are probably what you
should look at first Mia culpa
my bad so there are times to use get but
you have to be very careful about that
really the only time to use get is if
you can prove that the optional you're
getting back from something is never
empty and that's kind of rare but it
sometimes does occur all right a couple
examples of of what we just talked about
with optional I have a little stream
pipeline here that looks for words that
start with a and so the return value
from that is an optional string so that
gives oh yeah that gives the first word
that starts with a or an empty optional
so we can say you know we want it we can
print out that word or else print not
found or if if I want to go find the
message from somewhere I can say print
out that print out the matching word or
else get the the replacement value from
somewhere else all right so that's the
most straightforward way to use optional
I think the main thing is focus in on
the narrow fairly narrow use case of a
return value that where it's commonly
expected that there is no result
unfortunately there are a lot of places
where where you should not use optional
because it's kind of cool there's a lot
of stuff in there there's some
interesting methods you can do chaining
it's very tempting to use in other
places so I recommend that you I mean
it's it's fun to play around with no
question about that but it's definitely
possible to over use optional so I
recommend that you not try to use
optional as method arguments in object
fields or to put optionals in
collections it's sort of sort of sounds
like it might make sense but if you
start to work with code that does that
it it really adds a lot of clutter
one key point here is that it is not a
goal of optional to eliminate nulls
entirely
unfortunately nulls are pretty pervasive
in java programming what we're trying to
do is attack the most common case which
again I'm repeating myself once again
the most common case of returning a
value that might or might not be present
and the error-prone case where the
caller is tempted to to take some
reference to take the return value and
call a method directly on it that's the
case where null pointer exceptions come
in and that's where this is targeted but
there are a bunch of other places where
you know there knowles flying around and
it actually does not necessarily cause a
problem at all and for those cases i
recommend you not use optional there
couple places for instance if you're
writing a class and it's a reasonably
sized class and null is a useful
sentinel value for private fields so
what you can easily do is examine all
uses of that private field and make sure
that their null safe and you can use
that to me none initialize their absent
or whatever you want it to mean but
within the scope of a single class using
null seems perfectly fine if you have
something that returns a an aggregation
like a collection stream or array don't
return null to indicate that there are
no elements this is a common null object
pattern but it bears bears repeating if
you have no elements to return return an
empty array an empty collection or an
empty stream those are all pretty easy
and the great advantage of that is the
caller doesn't have to check for null
caller just does all processing in fact
ends up processing zero elements and
it's so tempting with optional look at
this we have optional and we can chain
methods on to the end and so what people
do is they say Oh optional that gets
that lets us get rid of nulls right so I
want a hand I want to write something
that handles this this string parameter
that might be nullable so I'm gonna take
an optional and alright so I'm gonna
take this nullable pointer and turn it
into an optional and then oh cool I can
chain a method and I can call lambda on
it as well so I'll say I'll call the
default method and so I've seen people
write code like this and it's it's kind
of cool that you can write it as a
one-liner and we're using all these new
features like optionals
lamb doesn't method chaining and stuff
but come on guys look at the code on the
bottom it's like it's not equal to do
this if it's not equal to no do this
else do that I mean it's really simple
completely straightforward everybody
understands it and it's a lot shorter
and probably more efficient - all right
once again focus on returning optional
for the cases on a method return value
where there might or might not be a
result and resist the option resist the
temptation to overdue optional it's very
easy to do but just just don't and one
of the things we've observed is that
overuse of optional has has turned into
a nice manufacturer of new code smells
so be on the lookout for those ok all
right so getting the signal to move on
so just a few words about default
methods here so so one of the things
that so default methods are a new
feature we added in Java 8 and you know
it's all closely related to lambda and
streams so I figured it's worth dropping
in a few words about this because these
do affect the way you design your api's
all right the primary use case for
adding default methods the language was
adding the ability to evolve interfaces
over time without breaking
implementations and so in the past
before default methods if you added a
method to an interface and you weren't
able to change all of the
implementations that interface there
would be some implementations that would
be missing those methods and if
something called those you'd get an
abstract method error and so in the jdk
at least and certainly in other other
large-scale software software projects
once you created an interface you could
basically never change it and that
turned out to be a real problem because
there's so much pressure built up in
trying to evolve interfaces over time so
that's the primary use case of default
methods and I think they work pretty
well for that and so if you have a case
where you can't update all the all the
implementations you can provide a
default method so
I think an important point is that
default methods can be overridden that
for a subclass the subclass can either
accept the default implementation or it
can override it and there are cases when
you do and do not want to override but
in either case from the caller's point
of view it doesn't matter it just sees a
method on an interface it doesn't care
that it's actually a default interface
or whether it's been overridden or
whatever it's an ordinary virtual method
okay quick example of default method
we've added the for each method to
iterable and it's pretty simple so
iterable
the only thing iterable knows how to do
is to get an iterator and so what this
does is provides a default
implementation that just does our simple
enhanced for loop that iterates over the
the contents of the interval and calls
the calls the consumer method each time
now there are a couple other use cases
where where default methods turn out to
be to be very useful so one is if the
method is actually optional so back to
our friend iterator there's the third
method that that everybody forgets about
which is remove you know I think most
iteration in the world don't allow the
caller to remove things from from
whatever whatever's underlying the
iterator and everybody who has written
an iterator up till today has had to
write this remove method well
so in Java eight we provide to that as a
default method so if you don't want to
support removing you just you just you
know avoid overriding the remove method
entirely the default method throws
unsupported operation exception for you
now of course if you do want to support
removal you just override it and go
ahead and do the removal and then
there's then there's a case where
default methods can also be used as
convenience methods and sometimes the
implementation is is so simple that
there's generally no need for the
subclass to override them and comparator
dot reversed is an example of that so if
you have a comparator how do you reverse
it
just call the arguments in the other
order
hey and we're done so so if you're
writing in comparator I there's really
never any need to override reversed on
it now one of the things that this is
kind of the same same story with
optional here one of the things that we
get into is whenever there's a new
feature people are tempted to say oh let
me use it for this and so well it looks
like we're running out of time but I
I'll just say that default methods are
not a replacement for abstract classes
there are some some important places
where classes are are still are still
useful one classes can contain state and
interfaces cannot and another important
point here is that classes can
communicate with their subclasses using
protected methods and fields distinct
from their callers this is something
that's very easy to forget one common
anti-pattern is people will try to share
implementations by putting them into
default methods on an interface but what
that does is it usually ends up exposing
unnecessary methods to your callers so
sharing implementations among subclasses
is really something that you want to use
classes for not default methods so once
again don't overdo it all right so we
ran through some interesting new
language features and how they affect
API is we took a few questions on inline
and I think we're actually out of time
so thanks for your participation</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>