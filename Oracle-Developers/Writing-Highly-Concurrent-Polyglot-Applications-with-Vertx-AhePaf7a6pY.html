<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Writing Highly Concurrent Polyglot Applications with Vert.x | Coder Coacher - Coaching Coders</title><meta content="Writing Highly Concurrent Polyglot Applications with Vert.x - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Writing Highly Concurrent Polyglot Applications with Vert.x</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/AhePaf7a6pY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">yeah so this talk today is going to be I
think we should keep trying keep it
quite formal so if you want to ask
questions at any time then go ahead you
seem to a reasonable turn out even
though we've kind of drawn the short
straw in the morning after the party so
it's pretty good okay see stragglers
I'll try not to trip over this works is
not why this this one okay so hello
everybody welcome to my talk today it's
sort of called concurrent polyglot
applications for the vertex just as a so
I got an idea of you know you
understanding advertis how many people
know about vertex already a familiar
with vertex okay so quite a lot of
people actually that's pretty cool and
how many people have actually used it
before an anger okay so basically this
talk is going to be a kind of it is sort
of overview talk but I'm also going to
talk what kind of updated it for vertex
3 vs 3 is the current development we're
doing the moment so right now we're kind
of heads down a big development stretch
lots of changes lots of new stuff at
vertex 3 my hoping to get that out
probably January February I hope but
kind of we'll see yeah it's a bit of a
guess at the moment so a little bit
about myself I'm employed by red hat at
the moment I work exclusively an
open-source have done for almost 10
years now the last 10 years of my career
so everything I do is open source some
other projects have been involved with
other than vertex I work with who said
of RabbitMQ okay so I works for a while
it spring sauce with a rabbitmq team
learnt Erlang and all that kind of stuff
and I langa such feelings for up
partially an inspiration for vertex and
I'll talk about that a bit later on
previously it read how I works with the
messaging team at red hair I've led the
messaging teen that red hair and i
created the hornet q messaging system
which is the one basically inside jboss
application server and that's about to
be merged with activemq so active MP is
going to be the come
you basically well the internals about
something clearly are going to become
horny cue the branding is going to be
accident key and a few other projects
okay anyway that's enough fat me so how
many people have already got a really
good understanding of what vertex is
already I think I should pretty go over
these slides anyway just because I want
to kind of explain the motivation behind
it and why we created it and you know
why exists basically so 38 to the
general purpose the very general purpose
thing it's a general-purpose application
framework it's very unappealing a turd
okay we don't say this is how you write
a web application we don't say this is
how you write an enterprise application
the core of virtus is actually pretty
low level and you can do so doesn't
really help much to describe it because
you can pretty much use it for anything
and we see people a lot of people using
it for web app so kind of you know
mobile apps but also when they cut on
the you know server-side kind of
internal integration projects that kind
of stuff one characteristic very obvious
characteristic of vertex is the API
asynchronous their event style api's
okay and I'll get into why that is a bit
later on so why why do we actually
provide why don't we have kind of
synchronous blocking a prize but we
don't have those we have asynchronous
opioids so where is vertex inspired from
I mean sometimes people look at us and
say old vertex that's the node.js for
the JVM project that's kind of common
thing people say and there was a kind of
a bit of truth in there but it's not
really that true especially nowadays are
kind of moving a bit away from that but
certainly certainly when I created it
that was a source of inspiration I kind
of saw what was happening of no Jess
doesn't get pop and I thought this is
kind of cool I mean I think like
everything about it don't like the fact
it's only JavaScript for one thing not
everyone wants the developer JavaScript
and they're very something that didn't
like likely kind of restricts on the
single threaded pneus of it for example
so I thought maybe we can do that better
here and then actually you know take
inspiration from other you know
frameworks platformers for example
Erlang OT
p so there are certain similarities with
OTP as well in vertex in a sense we have
a kind of access style model the way we
kind of the way you architect
applications basically polyglot yes so
really know a very obvious feature of
vertex it's polyglots we support many
different JVM languages so vertex 2
which is the current production version
I think we support she says in the next
slide we support all those languages
I'll get to that in a minute but we
support kind of like almost ten language
that I think so you know we don't force
you let's say you have to use JavaScript
all you have to use Java so you can
choose whatever language you're you know
your teams are using right so that's
kind of a good advantage advantage
really or maybe you can use you don't
want to use language of different
languages for the sake of it but you
maybe you want to use in a certain
application it might be appropriate to
use more than one language maybe you
want to use like a scripting language
for the glue kind of stuff like
JavaScript or whatever and then maybe
you want to use kind of in a statically
typed language like Java or scholar for
your more complicated bits you want to
benefit from the static type checking
what else high-performance like everyone
says hi performance right so but we are
really are very fast you can look at
there are some independent benchmarks
you can look at so I mean never trust a
benchmark that's been put out by the by
the actual team that's saying it's fast
right that's kind of pretty obvious
thing but but there are some independent
benchmarks out there they say one
example is some who's head of tech and
power benchmarks yeah so that's one one
example ladies lady basically compared
pretty much everything that's on the
market out there not just dre vm stuff
but you know like ruby staff and nodejs
and everything else C++ stuff compared
it all together and then it in some very
simple eight and it to be fair the
benchmarks are very simple kind of HTTP
stuff but we came up right at the top of
everything in terms of basic HTTP stuff
say faster than anything else in the
market without exception and another
motivation with with vertex is about
simplicity so
one driving 40 trying to get away from
this whole kind of perceived complexity
of traditional application frameworks so
kind of Java EE is one example right I
know it's kind of it unfair to Joffrey I
know it's changed a lot recently and it
has actually got a lot better a lot
simpler to run stuff but in a sense
vertex is a ribbed kind of rebellion
against that kind of complexity yeah and
the cold kind of application server
model of doing things and i'll talk more
about that later so we want you to be
able to just run stuff directly really
easily without having to do complex xml
configuration and you know all that kind
of stuff yeah lightweight yes so the
core vertex libraries I think it's like
half a megabyte or something and even if
you wrap up all the dependencies of
vertex into a single jar to in a simple
application I think it comes to like
three and a half megabytes or something
so that it's plus its dependencies and
dependencies the vertex are we depend on
bees Nettie who's head of Nettie okay
Nettie of renton up you know we've
worked I work with a neti team from the
very beginning I think I'm the very
first user of Nettie so I work with
trustingly and norman mera quite a lot
and we use for our clustering for a
disgusting discovery we currently use
hazel cast for that it's actually
pluggable so you can actually plug in
different implementations if you want
but the default implementation you just
hazel cast and that's pretty much all of
dependencies now we have one more
dependency which is Jackson for Jason
yeah that's basically it and yeah we won
you know we are kind of in a way as bit
of a low profile project still even
though we're getting we're getting a lot
of attention is certain quarters we're
trying to break into the enterprise
stuff obviously in the enterprise kind
of is a bit slower to catch up but we
weren't for example when the jacks
innovation Ward this year for the most
innovative java project so we're up
against some pretty formidable projects
like spring boot we beat spring boot for
example acha all those the Uniting
League good projects okay so yes I again
as I mentioned a ready polyglot so right
now we support java obviously java a
Java 8 has been a really important thing
for that fact was in Java rate the
introducer
the lambda I'm sure you're aware of
already pretty the major things operate
and this revolutionizes programming
against you know event-driven style
api's because you have to do anonymous
classes in everywhere so that's a huge
win for vertex so it's actually becomes
really feasible to use Java for that
kind of those kind of that kind of
development now yeah so you know Java
JavaScript Ruby groovy pi said Python
music you know see we have to use JVM
implications or on the JV n so he's
jython under the covers for Python ja ja
fans gone the project's a bit I wouldn't
say it's dead but it's kind of got a bit
flat so we're kind of looking at other
implementations for Python in the JVM
the moment and closure we have a fully
working closure implantation Scarlett
kind of scholars kind of thumb it's just
it's just got those just being we
haven't basically had it that long so it
is you're still working it to a certain
extent and PHP believe it or not
somebody wrote actually wrote a book in
the community community right at PHP API
vertex API implementation so I have to
say I'm not a huge fan with PHP but it's
there though and salon and who said a
salon the language too long okay so two
line is a new language JVM language done
by some people at Red Hat yeah and it's
kind of cool language is very strongly
typed so there's quite a flexible type
system it's a pretty cool language right
and I just say yes a where are we what
is the current status vertex 2 12 yep
two and two is the current production
release so that we recommend if you
actually want to do real applications
right now but like I said we're
currently in development x3 and there's
lots of new stuff and check quite a few
significant changes there so if you want
to you know get involved with vertex and
take a look at we're doing I'd strongly
recommend having a look at our new star
for vertex 3 we would it's kind of
usable a lot what to do there's
basically no documentation at the moment
but it is usable you can write you can
write applications you can play with it
basically I wouldn't
in production right now and in this talk
of some of the features i described are
going to be somewhere only available at
vertex 3 so you won't be getting all of
this in the current production release
right and i'm going to show you a few
examples in this in this presentation as
well so it's not just boring slides i
don't really like slides on those people
i don't really if I had it my way
wouldn't have any slides at all i just
talked over few prompts basically but my
slides are kind of boring no pictures of
cats with hats or means or anything that
yes i mentioned before the quit the core
of vertex is very small and static and
we have a set of asynchronous api's and
the kind of bit very basic low-level
stuff and if you've used no Jess before
who's used nodejs if you use no just
four you're going to be familiar with us
already right the same kind of core
stuff you see in the core of no Jess too
so we have no TCP stuff you know writing
TCP servers and clients we have HTTP and
HTTPS WebSocket support built in to the
core of vertex and they have kind of a
synchronous file system staff we have an
event bus you won't find this in no Jess
this is um and it's actually pretty that
I would say the most important feature
of vertex the eventbus the event bus is
like the nervous system by which
everything talks to each other so you
compose your application as a set of
components we call verticals or and I'll
get to that in a bit and they talk to
each other over this event bus and what
else we have we have dns UDP staff and a
new feature in vertex story we have this
distributed data now what this is is I'm
sure mostly you've heard of like you
know distributed map technologies like
Oracle coherence or infinii span that
kind of stuff so the idea is you have a
map and you can put put stuff in it and
get stuff in it anywhere on the cluster
and it kind of just is available across
the cluster so we have support for that
kind of thing in vertex vertex you can
have your different vertex knows you can
put stuff into a map and get it out any
on any node and we also have other
distributed primitives things like a
synchronous locks distributed locks
you can lock you can basically get out a
lot on something across the cluster and
we have a synchronous counters counters
quite a good useful primitive in many
applications you want to count I know
website hits or something or you're just
it's just a useful kind of thing my
building applications so why I sing
Chris so you know arguably especially if
you're not used to programming against
asynchronous API so it can be kind of
hard to reason about although to be
honest these days I'm so used to it it's
not so it's not a huge issue I think a
lot of its getting used to it and having
practice behind it but it certainly can
be certain you know you're new to it
hard to reason about you know control
flow and debugging staff and testing
stuff will be a bit harder so we don't
want to force you to use asynchronous
API so unless there's a good reason for
that yeah so how many people right now
are using already programming against
asynchronous API okay and how many
people are predominantly just still
using synchronous stuff in their
applications so it's all about
concurrency right so if you have an
application that needs an awful lot that
needs needs a high level of concurrency
then and that might be due for because
of many different factors one reason
might be you have it you have a lot of
connections in your application maybe
you're writing a web server even with
you know with keeper live connections
they stay alive maybe five or ten
seconds you may have a lot of concurrent
connections even with a normal web
server or maybe you're writing a
WebSocket server for a game or some sort
of mobile application or maybe doing
internet of things so MQTT for example
connection based protocol okay so lots
maybe you've got millions hundreds of
thousands of sensors yeah so you're
talking about loads of those of
connections and in a blocking IO model
you have a thread per connection yeah so
if you're a million connections that
means a million threads okay that's not
going to work even though threads are
you know friends are a lot more
lightweight than they used to be in say
Linux or not in a modern operating
system still there's over here
with each throws got stack overhead then
you've got context switching overhead
and basically it won't work you can't
have a million connections it's not just
about connection so you might have
concurrency for other reasons maybe you
have a lot of messaging traffic going
through application and you've got to do
stuff with messages and send them off
and combined results and just kind of
stuff again you have a lot a lot of
concurrency so you can't be blocking so
you got a message and then you want to
send it off somewhere else and wait for
a result back you can't block a thread
while you're waiting for that result
coming back because that thread can't do
anything else if that thread can't do
anything else is waiting for results
then you know your application is not
going to scale very well having said
that a lot of applications don't
actually I mean not all applications do
actually you know require a huge amount
of currency and maybe you have a small
website it doesn't get that many hits in
which case you probably don't need and I
think you know anything Chris approach
so it's not a solution necessary for
anyone but I think it's getting more and
more common for even just normal kind of
apps to you to require a lot of
concurrency okay so that's why we do
asynchronous and you probably heard of
the whole cool he's had a callback hell
okay yeah so talk about more about it
later so we need an approach to mitigate
that as well okay so how do you actually
write a vertex application so any vertex
application is composed of a set of
things called vertical so the vertical
is kind of like the the execution unit
vertex and a vertical can be written in
any of the languages that vertex
supports you write in Java JavaScript
whatever Ruby groovy and single threaded
actually there there is an exception to
this but also kind of an education I
won't go into it got one going to it
right now but you can assume right now
verticals are each vertical instance is
single threaded right so we guarantee
actually it's even more than that for a
standard vertical we guarantee not only
is it single threaded ie we never had
you never have more than one thread
executing the vertical code at the same
time we guarantee it's the exact same
thread every time yeah so what does this
bring you so why is this a good thing it
means we have to worry about
synchronizing stuff you have to worry
about volatile now to worry about whole
loads of classes of deadlocks just don't
happen a lot of race conditions just
don't happen yeah so the developer makes
your life a lot easier yeah good I'm
sure your what you know I'm sure all of
you have SAT there late at night
debugging difficult race conditions that
kind of thing well hopefully doesn't
happen it's less of the bar game the
vertex code itself of course but you're
if you're writing your single threaded
verticals that kind of thing just
doesn't really happen so have these
things called verticals each instance is
single threaded and a typical
application may be composed of many of
these verticals I may need to
communicate with each other so how did I
do that they they do it by passing
messages and they passed messages over
the eventbus which I talked about
earlier and I'll show you an example in
a minute so who's heard of the actor
model here yeah I mean it's getting
again I mean it's been around a long
time but it's getting definitely a
resurgence of popularity in the last few
years we've obviously allowing and
you've got a car and various other
frameworks are using the actor model so
the vertex we're not strict actor model
implementation however we do have
similarities when it comes to a
concurrency model okay so the way we
scale is kind of similar to the actor
model so instead of scaling by having a
lump of code and then putting more
threads through it which is kind of
nasty way to scale because then you've
got to worry about synchronizing stuff
and no access to mutable state and all
that kind of stuff instead of in that we
say we you scale by having lots of
instances but we you know you never
actually have each instance is single
threaded yeah so the actor model is cool
like I say we're not a strict act
implementation but we have similarities
so let me actually show you a couple of
verticals right so let's go to the
command prompt can you is that too small
to see or is that ok yeah it's ok that
cool right so where are we
let's get a hello world right in this
directory I have two files hello world
Java hello ljs and unsurprisingly ones
the Java source of fun and one's a
JavaScript source well and what these
are what these are these are two
examples of what we call raw verticals
and rule verticals can be run directly
on the command line so it's kind of
useful for you can approach typing staff
cool thing like virtus you can just
literally you know write it right you
you don't have to use an idea if you
don't one just use a text editor or
whatever and you just run it directly
you don't have to like create a build
using maven or Gradle or whatever you
can just run it directly so let's take a
quick look at hello world java java and
it's gone off the edge of the screen a
bit there because the font size is
pretty big but um now this is this is
all using vertex through so like i said
before we're currently in development
but it's through two things are subject
to change a little bits we've got a few
tweaks to do to the API still so but
it's kind of it will be roughly well be
pretty much like this when it comes out
so this is a vertical very simple hello
world vertical written in Java and I
think you see just a class you extend
abstract vertical and you implement a
start method the start method or bi as
you can imagine gets called when the
vertex when the vertical starts and in
this case what we're going to do we're
going to create a really simple HTTP
server which just returns hello world to
every request if you create vertex
create HTTP server and then we just
scroll across a bit and we just set in
the port to 80 80 and then we're setting
yeah so I could say the font size a bit
big here so we're setting a request
handler on the server and the request
handler it's just a lambda okay the
lambda when a request comes in the land
is gonna be cooled and that point least
in return hello well it's a pretty
trivial stuff okay so how do we actually
run that so you might be thinking okay
so Java source file that means you're
gonna have to compile it to class file
and then maybe create build or something
to run it but what you can do like i
said before vertex you can run that
directly at the command line so i can
say
vertex run I've already I've already
installed the vertex distribution and
there's a vertex command on the path now
okay so i can say vertex run helloworld
dot java okay oh I forgot something
right so this is a new thing of vertex
in vertex 3 you have to prefix its make
this may change actually have the prefix
of the vertical name with the type in
this case it's Java subject about that
that's that we in vertex 2 didn't have
to do that and we may actually go back
to the Vettes to way of doing it right
so that's running now so let's go to a
browser f5 as you can see it's serving
up you know very simple so this is about
the simplicity thing so you can see how
simple that was just two right you know
not something together and write it and
get it running okay let's take a look at
the javascript file now now this is the
same thing that written in JavaScript
okay and it kind of like similar and how
many views know before kind of looks a
bit similar you know creating at HTTP
server setting the port to 80 80 and
then we're specifying a request handler
that's just a function that's going to
be called with the request when the
request comes in and there isn't return
hello world again and we run it in a
similar way but this time we basically
do prefix of jas the prefixes may go
away by the time we get virtus three out
and pretty infer that from the actual
extension saves a little bit of typing
okay vertex 3 we use the who's head of
nazil the nazil javascript engine the
new one yes so we use the new we use
that in vertex 3 inverse that's too we
used primarily is RINO which is
basically it's kind of old nouns it's a
bit slow we're certainly slow compared
to now so on so that's its three
question over
so yeah so right yeah that good point so
the question was is this vertex 3 java 8
own in the answer is yes sir vertex 3 is
Java 8 only okay and this is a conscious
decision for us because we really needed
to take it we need really needed to take
advantage of lambdas so obviously aren't
available in light in Java 7 and we
really wanted to take advantage of NASA
one as well let's put it to rip main
reasons so obviously if you can't use
Java rate yet have a problem but
hopefully I think Java rates means such
a really important release for java
compared to say Java 7 I think more and
more I think people are in adopting a
bit quicker and they did Java 7 because
there are so many that's good stuff in
there much more good stuff and there
wasn't java's have been compared to java
6 so also did actually show you the
browser don't think i did alright so
back to the browser f5 you can see it's
working right ok that's a hello world
dunno how would you have a time ok ok so
I want to talk about the eventbus the
event bus is a really important feature
of vertex like i said before event bus
is the means by which all the verticals
communicate with each other it's a
messaging system and like most messaging
systems we support point-to-point
messaging we support publish-subscribe
messaging a request-response messages
oddly know the common basic messaging
patterns it's a transient messaging
system we don't support persistent
messages although you can write stuff on
top of it which does persistence if you
want but out of the box we don't have to
be persistent messaging so we're not
competing with say you know activemq
hornet cue that kind of thing it's a
peer-to-peer messaging system there's no
master okay so each node in vertex is
equally important yeah there's no master
server you have to install yeah you can
pass pretty much anything you want / the
eventbus that the actual messages you
send are you know there can be simple
primitive types of you want or
rings inverted through each message has
a set of headers to so you can put stuff
in headers as well as the payload one
thing we recommend that o is a
convention people tend to use Jason as
the payload for most eventbus messages
and the reason for that is because of
all the languages you can use the vertex
Jason's very easily understood by all
those languages very easy to create
Jason very easy to part easy to pass it
not a complicated binary protocol you
know so it makes it kind of really easy
to deal with you imagine like
serializing a java object send it to a
ruby vertical what would it do with that
just get like a big blob of bytes and
it'd be so that's why it's basically the
that you know so the different verticals
and different languages can talk to each
other easily having said that it's not a
strict rule and you can use whatever you
want and we find some people they may be
their only using one language of vertex
like Java or whatever in which case they
might want to pass pojos across it they
don't have to worry about you know it
being understood in Ruby or Python or
something question that right so um yeah
so the question was must everything
you'd pass be immutable so the things
you can pass an event boss there must
either be immutable or nasty copyable if
they're not immutable vertex will copy
them so the end result is there's still
no shared access to to state yeah it's
it's important point here and question
bit Fred Topher down
so other need guarantees our own message
delivery though so it's a very much a
transient messaging system yeah so if
you want to do your own guarantees to
layer that on top provide your own
protocol for that and a question here
raisa questions can other system like a
non vertex system yes a vertex 3 we're
working on that we're going to expose a
wire protocol so you can say from low GS
you can talk to the vertexes event
parcel from Ruby or some other
completely different you know nan JVM
you know platform so yeah we want to
have interoperability with other non JVM
stuff as well because we appreciate not
everyone is using a lot of people using
JV and stuff and other stuff especially
these days no Jess getting popular a lot
of enterprises are using node.js but
they're also using JV and stuff and so
we need to play together nicely yep
actually vertex 3 you can provide I just
briefly mentioned you can basically send
provide your own codecs so you can like
define a codec for your own pojos for
example you can send those directly over
the event bus and then just send it and
then you little pop out the other end in
there and the expected format and I'll
show you an example a demo in a second
about the event bus so yeah the eventbus
this is like you know the vaporous
obviously works inside a single JVM
singles vertex instance you may have
many verticals the event bars allows
those verticals commute to communicate
but it also works between JVMs too so
you can have different vertex instances
running in different places in your
network and they using the same event
bus to talk to each other so it's
totally transparent as to where the
stuff is yeah he's exactly the same
message addressing scheme irrespective
of where it actually is yeah so it's
kind of like getting like a micro
services model of application
development right so with moving away
from this kind of application server
model so the classic application server
model you typically have you know this
kind of monolithic application server
which sits some on your network or maybe
get a farm of application servers or
whatever and then you can and then you
deploy stuff into the application server
we don't do that photos and you don't
deploy stuff into anything you just run
stuff wherever you want to run it
directly and then it starts up and then
it looks across the network and see who
sees what else is running in forms of
cluster with them so you can correct
your application as this set of services
running a different place in your
network maybe you have you want to break
stuff
now and it's a different staff have
different teams handling different bits
I'd Hillary large application maybe like
a web front-end you want to do that bit
in JavaScript with one team maybe it'll
sort of back end processing you'll do
that in Java different team yeah no
application server so it's very much a
micro services microsomes is a kind of
overused term right now I'm sure you're
aware of that you know this is
microservices community communicating
over an event bus although you could
actually write http-based microservices
too if you want it with birthdays okay
so you have all these you know bits of
your application on the server side talk
to each other and then we can take it a
step further than that again and
actually put the event bus right into
the browser to into client-side
JavaScript and in client side JavaScript
use the same API for talking over the
event bar says you would do that go same
API as using server side so what we find
this a lot of people are using this
right now it makes verte it's a really
good choice for kind of so-called
real-time mobile applications yeah so
kind of push it when I say real time I
don't mean like the hard computer
science definition of real time that I
learnt you know so there's not about
hard real-time software of time it's
about basically pushing stuff to
browsers right without having to request
stuff so although verse itself is an
opinionated you just write a rest
application you its core makes it very
easy to write kind of have an event bus
style it application right into the
browser question
the question is what protocols we use
from the browser to the yeah to the
server basically and we actually use by
default something called sock j/s right
so sock jess is a toolkit which mate
well it's a library which basically
gives you a WebSocket like API on the
client side even if your browser your
network doesn't actually support web
sockets so we'll try and use web sockets
if that's not available maybe have an
old browser maybe you have a corporate
you know firewall approxi doesn't allow
that kind of stuff and then it will fall
back to like it's got like 10 different
protocols it can use like long polling
or different types of polling and
streaming and stuff it and on the
clients I'm a totally agnostic as to
what tool kit you can use them so people
use with app with angularjs or you know
any of the ember or knock out any of
those kind of modern MVC style jobs you
know JavaScript client side frameworks
so let's have a quick look at the event
bus yeah and see event but okay yep
you meet on the server side right so the
assumptions really avert it on the
server side is a trusted network okay
there's a kind of assumption yeah so
yeah you can do that I mean you can
actually start up separate classes just
by choosing different ports so you can
actually have multiple vertex clusters
in the same network if you want by using
different ports obviously that's not
particularly secure if you have you know
if somebody's compromise the network so
assumption is it is secure having said
that vertex really have somebody working
on encryption for the event for the for
the event bus right now so we are going
to provide encrypted event buff so say
you're running on are not an untrusted
network basically yeah that's not
available yet but yet question that so
the quick yes I how do the nodes find
each other may start up so I legally so
right now we delegate that to our
cluster manager the pluggable cluster
cluster manager and default
implementation of that is hazel cost
having said that we have people who have
already written other cluster managers
and they've used like zookeeper or
something like that so you could write a
different cluster manager didn't want to
use hazel cast yeah right so back to the
eventbus demo let me show you a quick
example so I'm going to I've got a
couple more few more verticals here so
let's take a look at sender at Java and
I send a Java this is again as you know
another vertical written java and this
one you probably guess what it's doing
pretty obvious from from looking at that
it's some basically setting a time out
it's going to run every second every
thousand milliseconds and when that time
of fires it's just going to basically
send a message on the event bus to
publish a message on the event bus and
the message is just a string saying news
from Java
you see a very simple API okay just run
that again vertex run Center java now
this time I'm going to put a flag on the
command line says cluster and what this
dies it says to vertex when you start up
I want you look out for any other
vertexes on the network and if you find
them cluster together with them form
this distributed event bus so it's going
to use a default a minute you can
specify the address of you want as well
very set the rest up various other
parameters you can use but Oh again I
made the same mistake it may before
because I'm saying server toast to I
forget to prefix the vertical may all
right it takes a few seconds 1582 form
the I guess and that's running now it's
ended by itself is not much used so
let's start a something it's going to
receive that as well so got another
vertical here called receiver j/s which
is written in JavaScript very simple
we're getting a reference to the event
bus and we're creating a consumer on
that same address that we're sending to
from the other vertical so the dress is
just a string basically can be anything
and then we're setting a handler on that
address and that handler will be called
when data arrived so it's basically to
doing the subscribe part of
publish-subscribe messaging and we can
run that vertex run j/s co je s again-
Custer so these two virtuals they could
be run this would work doesn't matter
whether right now they're running on my
laptop but they could be running
anywhere in your network yeah and you
can see it's picked up the message that
was sent from the other vertical that
one so that's what that's sending and
that's receiving yeah Oh other way
around but you know so let's take this a
step further and actually put it into
into the client side so what I've got
here we're going to we're going to put
into the browser we need to serve a web
page right so in order to serve a web
page we need
a web server so let's we've got a web
server written here also using vertex so
let's take a look at that it's pretty
simple the the actual web server e part
is just the that bit there okay now
obviously you won't want to put
something like this into production
there's an obvious security problem of
that I can leave that as an exercise but
just for the sake of a quick demo we're
creating an HTTP server we're setting
the host and port and we're setting a
request handler on that server which is
just a function which gets called as a
request comes in and when that request
comes in you can see we're looking at
the path and we're basically if it's go
request from the roots in a survey next
index HTML otherwise we're going to
serve whatever was requested like I said
into that in production because yeah bit
of an issue for that and then once it
works out the actual path we're just
going to say send that file back yes as
a method send file which basically it's
like you know picks the file up and it
actually streams it using the colonel
actually avoids userspace the same file
method so it's very fast so that's the
web so every bit now this kind of weird
bit at the end here I won't go in
turning into a lot of detail but what
this does here it's called j/s bridge so
I mentioned before about how we can put
the event off on the client side this is
the bit that kind of does the the
bridging between the web sockets or
whatever sock jet is using and the
actual event bus yeah and I won't go
into that I'm glad you got time to go
into that in detail but so think about a
little bit of magic for now okay so I'm
going to run that vertex run it's just a
vertical so we can do a JavaScript
vertical minus cluster again so when it
starts up its going to Saudi two other
verticals running they could all be in
different places in your network so
hopefully yeah they were all running now
as we've got three things running right
something sending something publishing
something receiving the server side and
something
implementing a web server so let's go to
our browser f5 as you can see oh I
didn't actually show you index HTML I'll
let me show that first because it'll
make more sense right so let's go back
to the bridge server so what is the page
we're actually going to serve from the
web server and its index HTML and it's
let's take a look at that and it's like
a really trivially simple web page it's
just basically got some javascript in it
and that JavaScript that line the top
line is opening a connection to the
eventbus yeah and then when that
connection is open it's just going to
register a handler I haven't that the
syntax of registering hand is actually
changed between verse let's turn
vegetarian this is using the old syntax
register handler where the server side
we used consumer handler so that's
watching the change but it's the same
principle so registering a handler
against that same address that we're
sending two on the server side and when
we get some get some data we're just
going to do a little bit jquery pretty
much just put it onto the page i'm not a
web designer so I it's not very pretty
page but yep
surely ganya why is a reason because you
don't necessarily use web sockets see
what it may not be using web sockets so
it's not because we have a good stock
jes which is basically an abstraction on
top of web sockets so for example if
advise using an old browser here it
would still work this demo you know
browser of no web sockets because it
would fall back to using long polling or
some other kind of polling or streaming
yeah the actual URL is not a web socket
URL okay let's run that
okay back to the browser and you can see
the browsers picked up that same thing
being published in the server side so
it's completely like flat messaging
space all right so you can in your in
your to worry about doing rest calls and
you know getting synchronous rest calls
all that kind of complicated stuff it's
actually a lot simpler using an event
bus approach have you said that like a
set of several times that versus Vettes
is unappealing ated and actually a lot
people do use vertex for rest because
obviously rest is very popular right now
so you can use it for rest rest style
stuff if you if you prefer that's fine I
just personally it's a bit simpler doing
this way yes yes so once it's been
consumed then that's this gone here yes
transient okay so event bus that's
aventa so that's a really important
feature of vertex so so far in this demo
I've shown you how you run vertical
directly on the command line there's one
way at that's one way of running stuff
right that's kind of bit like the node
way of running out you type node
something type vertex something yeah
similar kind of thing however a lot of
people don't want to run stuff that way
a lot people you know they want to do
use their tools they already using like
maven how many he'll hit right here
right here how many people now actually
use maven in their projects okay so
pretty but yeah unsurprising most of you
so we need to play nicely with this kind
of stuff to you want to completely
reinvent the wheel and force you to use
different processes and all that kind of
stuff so we play nice things maven2 and
many people will want to create maven or
Gradle or whatever vertex applications
so especially especially in vertex 3 you
can it's very very easy to create a
maven project versus a completely
vanilla project noma special magic in
there and vertex itself is is inherently
embeddable so you can just if you don't
want to run stuff in the command line
like that you can just embed vertex in
your mate make create a main method you
know and just start vertex that way
embed it and that's fine and I'll show
you that actually in right now in action
oh and also what you can do
it's kind of becoming quite a popular
way of deploying applications is a so
called fat executable jars so who's head
of fat jars okay so this is like
basically what it means is it's an
executable java jar instead of just
containing your coat your coat your
classes it contains all your
dependencies too so you can deploy that
as a single unit just deploy it on to
machine as long as there's a jdk there
it'll work you don't have to like make
sure you have everything on the class
above okay I'll i can show you that so I
have a simple maven projects here maven
vertex projects I'll just show you the
pom.xml as you can see it's like really
simple okay let's put this that's the
main that's pretty much it right it's
just declaring dependencies divert at
school library we have snapshots the
moment yeah so we don't have any actual
releases we have that usable snapshots
yeah so you can mrs. using a snapshot
here and all we've got here in here is a
simple I'll show you the vertical give a
simple hello well vertical very similar
to what you saw written in Java same
thing as before basically and then if
you want to build that you just yes let
me shut down this event bus demo first
okay so factor right so here we are this
is in the directory the projects like
this build it as normal maven package
okay and what you'll see it's created oh
one thing I didn't show you i'm using
who's heard of the maven shade plugin ok
so we you so i'm in this poem i'm using
the maven shade plugin which basically
just bundles all the dependencies into a
single jar and make sure there's no kind
of clashes so actually generating vichy
look in the target directory you can see
there's a couple of jars there we've got
the normal artifacts and then we've got
this one called fat jar which contains a
little dependency so i can just run that
just with Java minus jar the name of the
jar okay it's running and go back to our
browser and you can see it's running
yeah so you've got very simple
application package to happen to sit in
to us into a single jar you can tell you
that wherever you want deploy it
production or whatever and then he'll
just run Java minus job yes I'm not
we're not actually rather than the JRE
you in ting it yes so yeah yes see we do
require the JDK and the reason for that
if I remember rightly it's because we
use the compiling compiler stuff in
there yeah so you probably wouldn't let
me think so we see it you saw earlier we
you can run java files of the car light
so to do that we use a tool stuff yeah
now if you weren't using that if you're
precompiler you probably get away with
just a JRE I would imagine I don't need
to check though yeah okay so yeah
basically we play nicely with maven and
stuff and virtus is very embeddable so
you don't have to run it kind of you
have to run stuff from a command all of
that like that if you don't want to you
can use your cat that you're familiar
methods of doing stuff all right how
many of time 1233 okay not much time
really so maybe we should fast forward
to I'd say a few i had a demo about a
che but I pretend got time to do that
today but I'll say a few words about it
so vertex comes with high availability
support built in so you can basically i
showed earlier you have different
verticals running different nodes you
can start them with a che enabled and
then what will happen is if one of them
dies another one will take over
responsibility for those verticals that
would deploy them on the failed one
redeploy them and your application will
carry on yeah so that's built in just
pretty cool you have to rely on anything
else for that and we do kind of you know
we use quorum approach and show you
Miller with that for a che so we can say
you know the custard should only
function if there's a minimum of X
number of nodes in the cluster if it
fails to see that many nodes then it
will automatically shut down basically
so you don't so you can avoid network
partition split-brain kind of thing
happening yeah so I'm going to miss that
damn out of them we've got time for it
what I want to kind of talk a bit more
about some of the new features in vertex
3 so one really interesting was not only
a feature but when I one approach that
we're using in vertex 3 we didn't use in
vertex 2 is in vertex 2 we manually
maintained all these different language
api so we manually maintained the
JavaScript API the groovy API the Ruby
API because we didn't want to expose the
Java soft directly in those languages
because want to do stuff in an idiomatic
way for each language it's kind of ugly
just exposing a Java API satyr jruby
it's kind of the naming conventions are
different and the way people do stuff is
just different right so all our API is
idiomatic so we maintain those manually
in vertex to problem is that's a lot of
work and every time you change something
the Java API we then have to filter that
change down to like eight nine different
api's make sure it's tested you notice
and it kind of takes a long time error
prone and it's a lot of work so vertex 3
we are using code generation to generate
all the language api's so all we do we
maintain only the Java API directly we
generate everything else and we
generated idiomatically so it's not like
it's not like a naive you know copy of
the Java API so you try and make it keep
it idiomatic for each language still and
there's kind of been difficult thing to
do and when we start up it started out
people said the unit is no way you're
going to create idiomatic other language
api is from any Java interface that's
kind of a bit of Holy Grail and they're
writing away and then it the only way we
could do it was to make constraints on
the on the on what you're allowed to do
in the Java API save a set of
constraints limitations so any API that
you want to be co-general then what you
want to be able to generate other
language api throw
as a set of rules it has to conform to
like we say you're only allowed these
kind of types and this kind of basically
a set of rules and that makes it a
tractable problem and then we can
generate stuff and that we've already
had this working for Java scripts the
JavaScript API you saw it already is
that's generated and we have it working
for groovy we have it working partially
for Salon if you have fit working
partially to python so by the time but
it's frees up we're going to have it
hopefully working for those languages
used to be support and another really
important thing I kind of alluded to
earlier okay a synchro say P I school
back hell you bully um you're familiar
this term this is one of the major
things that puts people off a synchro's
event-driven api's right and it's a real
problem for you know it's it's it's one
of the major reasons why people don't
move to to these api's you know if
you've got if you've got a complex set
of things to do imagine you're you want
to send off messages to five different
places then correlate the results back
together before you form a response back
to your client if you're just using a
basic call back style API you've got
five different callbacks and you have to
communicate stuff between you know how
do you reassemble staff how do you deal
with errors right how do errors
propagate in that situation it becomes
really complicated if it's more than
trivial example it becomes complicated
and then you have all the nesting I'm
sure you're familiar that horrible kind
of like callback nesting so we need some
way of mitigating this yeah one approach
its use like a promises kind of kind of
promises API I'm sure you're familiar
with promises kind of like in completa
bellucci in Java rates yeah that kind of
thing so that's one way of dealing with
that with completa bellucci available
Java rate you can set handlers on it and
you can compose stuff to a certain
extent yeah how many people have
actually used completa below and Java
rate okay anyway so I'm probably you may
not be familiar with it okay but it's a
new thing in Java right the trouble with
that approach is it's a kind of one-shot
events those are all one shot events now
a lot of time when you're dealing with
streams of data it's not
oneshot event is the whole stream stuff
so what we actually use in vertex 3 is a
project called RX java has anyone heard
of our x java yeah cool so iris java is
a project by netflix and it's based on
react they're called reactive extensions
which originally done in microsoft and
so they basic altered it to java and the
idea is all about composing streams of
asynchronous streams of data an
intuitive ways they and you use kind of
like functional operations on them so
you could like do Matt and flat map and
all that kind of stuff you're probably
familiar if you've done a bit of
functional programming so in vertex 3
this is our kind of chosen path to
mitigate against this whole callback
health so you can use a basic cool about
api's if you want in vertex free but we
also can provide alternative ap is so if
you need a non trivial thing you can use
it like an RX ified version of the API
so we're going to use code generation to
generate that RX ified form from the
callback api's this is kind of useful if
you got more complicated asynchronous
stuff to do a new feature I talked about
it briefly earlier on a new feature in
vertex through this distributed data
stuff so we provide distributed map
technology so you can do like map get
input on different nodes the cluster so
there's different verticals we showed
earlier running on different potentially
on different nodes there could be maybe
have a web application you want to store
your state your session state or
something in your distributed map you
could use it for stuff like that or
there's many other uses we have that you
can see that the small code code example
down there map get if you specify the
key and then you specify a lambda well
or eight you know they see you specify
lambda which will then be called with
the result asynchronously we have a
distribute a asynchronous distributed
lock so you may have maybe it's
something you only want to do in one
place at one time on the network let's
kind of
a tricky problem to solve sometimes how
do you ensure that it's only happening
in one place in your network and you can
use a distributed asynchronous lot for
that so before you do the thing you get
the lock that the call to get lock does
not block nothing blocks on the Vettes
API so that returns immediately and then
some time later you'll be cool back via
the lambda saying here's your lock and
then when you finish the lock you just
say unlock so once you've got that lock
you can do something you know that
you've got exclusive lock across the
cluster for whatever it is so you can
just give it in whatever name you want
yeah question down there yes again we
defer to the cluster manager so with the
default implementation it did the first
a hazel cast we actually use in house of
class for that the semaphore I semaphore
I think they call it yes you still have
the local one if you want to use that so
the same one if you had before you can
still use out if you want but that'll
only work on a single JVM instance as
you already know for sure here and have
a counter to write so acing Chris
counter kind of useful thing and many
applications you want to count stuff
yeah another new thing vertex 3 metrics
people have been asking for this for a
long time so we have a lot of our core
objects produce metrics so you know like
an HTTP server you can request second
and various different lots of different
stuff you can you can find out about the
actual what's actually going on inside
vertex we expose that by jmx if you want
it via jmx so you use it with any tool
that understands jmx we also can expose
that on the event bus so we can publish
that information on the event bus so you
could write a listener maybe somewhere
else in your network that can just tune
in to that and pull off that information
somewhere else and you can do what you
want with it that's kind of a working
progress still it's kind of all it's not
quite there it's almost there
question over there it's somewhat every
instance where every vertex instance
will provide that information yeah so
for instance you could use it with other
natal if you fabricate is a good example
I say pick my red hat hat on for a
second but you know this is this is um
quite a nice tool if you don't manage
like a vertex cluster you can deploy
staff and employ staff and you get all
the jmx staff and a nice console that's
that's pretty cool tool to use with
vertex so I'm another thing we're doing
a vertex 3 in vertex 2 we have like 200
about 200 different modules that most of
them been written by the community they
do all sorts of different things like
database access and also you know many
different things so one thing we
recognize the vet its toes we want to
produce an official stack the basically
so people have trusted functionality
that allows you to do pretty much all
the things pretty much all the things
that you need to do in an average
application so when I provide like
database ax ya verticals of your
database staff authentication
authorization IOT is another big target
area n QT up implementation co-op
messaging integration blah blah blah so
what we work on a registry is we're
basically creating a stack so not so you
as well as the vertex call you're going
to have a set of these pre-made
verticals you can then use in your
application of you one you know so you
have to write everything from scratch so
this is kind of important to okay so I'm
out of time now really
I like to like to like SSH into the
server I collect answer that after the
it's actually possible right now with
something called the crash yeah a crash
basically yeah yeah okay so I need to
finish up i thinks amount of time before
i get shouted to that so where are we
going with this what's a summary here so
when it's a micro services model moving
away from an application server model
right you write your application as a
set of components they can live where
you want on your network you can use
whatever language you want so depending
on the on what you're doing use the
right tool for the right job use the
right tool for your team skills too
we're not forcing you to retrain
everyone to use JavaScript or whatever
I'll see polyglots so will pretty much
cover that ready simple concurrency
model you know everything single
threaded that to worry about these
synchronizing volatile nasty stuff and
we want to provide this stack of Lego
bricks to build your apps with and
that's pretty much where we going you
know verte it to the independent project
I work for red hat it's not owned virtus
is not owned by Red Hat it's actually an
eclipse foundation project in terms
eclipse manages the IP the trademark
that kind of stuff you know read our
employees have to work on it but it's
not it's not governed by Red Hat so red
hat can't determine the direction of it
you know they can't say do it this way
it's all on guitar behind us on open
source so you know have a look on github
and I say you know if you is it
interested in getting involved we've got
very active community where I think
we're like that well used to be the top
10 with one of the top 10 java projects
in the whole of github in terms of stars
and you know whatever so we're really
put with a popular project yes / tits 3
and development right now we've got we
still quite a lot more to do so if
you're interested in particular in may
be doing stuffing something on that
stack i was talking about then yeah get
involved with a google group and we have
an icy channel we kind of
is quite a lot for kind of chatting
between team members because all our
team it's basically very distributed
with many different countries so the
user I see a lot okay that's basically
it so thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>