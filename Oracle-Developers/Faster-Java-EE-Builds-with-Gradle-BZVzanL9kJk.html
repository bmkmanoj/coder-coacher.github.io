<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Faster Java EE Builds with Gradle | Coder Coacher - Coaching Coders</title><meta content="Faster Java EE Builds with Gradle - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Faster Java EE Builds with Gradle</b></h2><h5 class="post__date">2016-09-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/BZVzanL9kJk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">great I'd like to welcome everybody to
faster builds with Java EE and Gradle so
a little about me first
I'm co-author on the EJB 3 in action 2nd
edition book and also the NetBeans
certification guide the EJB one of
course deals with heavily with java
enterprise javabeans and the some of the
eee stuff that we're gonna be talking
about today and how to better build it
faster with Gradle so first introducing
Gradle for those of you that aren't
familiar with it or have just heard
about it from the Android ecosystem it
is an open-source build automation tool
it's under the Apache 200 license it
builds upon the lessons learned in
Apache ant and maven as well see as I go
through the presentation it's actually
almost 10 years old right now it was
first released back in 2007 and has
slowly been growing in popularity ever
since it uses a groovy based DSL not an
XML file format which is the biggest
departure in terms of build tools
because the both maven and ant use use
XML so Gradle is actually uses a
programming language a DSL to write the
build files it uses a directed acyclic
graph to determine the build order
it supports multiple languages not just
Java so it supports C++ C Objective C so
you can do you can develop mobile
applications native applications with
Gradle as well in fact large parts of
the JDK I believe are now built using
Gradle including the JavaFX stuff it has
a rich plug-in architecture making it
easy to extend and extend the build
extend the built-in stuff that comes
with it
if it favors convention over
configuration but is easily customized
and adapted the last point being very
important if you're coming from a legacy
project that may be ant based or even
older than that using shell scripts it
is easy to get it into Gradle because
rail does not force a project structure
upon you you can easily adapt it
what comes out of the box unlike the
other to build systems the build file
can be version two like the dependencies
so for example if you've ever run into
trouble with ant there are actual
changes between ant version 1.6 and 1.9
so that a file written with 1.6 does not
necessarily run with 1.9 so just because
your your stuff is in version control
and you check it out doesn't mean that
you can build it with the current
version of answer if you've got code
from 2004 going against an to check it
out and if it's a complex build build
process it may no longer run you may
actually have to go out and find that
version of ant and hope that that
version of ant still runs on the current
JVMs it features the background daemon
to reduce build time so once you get it
once you invoke it the first time it
leaves a daemon running behind the
scenes so that the next subsequent
builds are faster it supports
incremental builds and this is the
reason why running code out of IntelliJ
and also Eclipse run so fast because
they have they don't recompile the
entire project from scratch every time
you hit build right so we made a change
to one file it just recompiles that file
it doesn't recompile the entire system
so that is one of the benefits of Gradle
is that it supports incremental builds
and tasks that you write and build
processes that you add to it can also
take advantage of that incremental build
logic so that anything that you develop
can also know whether it has to run or
not
it supports built-in profiling
out-of-the-box there's actually a task
that you can run that so that you can
ask for it to profile your building tell
you where it's spending all of its time
it does support building projects in
parallel so if you've got a nested
project structure it will build the sub
projects in parallel and it does have
some limited support for doing task task
parallelization it has got built-in aunt
and maven integration on the ant being
the better better of the two in terms of
support with the ant integration you can
actually use ant tasks in Gradle so you
can real average it you can even use
snippets of ant logic or you know entire
blocks of ant scripts and you're in your
Gradle file to help you move along it
supports several different central
repositories so it supports maven Center
J Center which is quickly becoming the
de facto center and also iev so you can
pull IV artifacts out and down using a
Grail so if we look at the evolution of
the build systems in 2000 we had ant
which we were all excited about because
it freed us from make and from shell
scripts at the time right that was it
was it was like an epiphany the first
time users like this is great then after
a couple of years and 20,000 lines of
XML files during the debug stuff he's a
second yeah you know the dependency
nightmares started you know it's like a
you know a thousand jar files that
you're trying to manage with your ant
file you know then then came along made
meant to try to solve the dependency
management in the project structure so
no longer did you have to try if you
cooked up checked out an Apache project
spend a whole day trying to figure out
how to compile it and figure out how to
locate the dependencies so that it would
actually build maven solve that project
but it could put you in a straitjacket
so if you didn't do things exactly the
way you wanted it to it was painful and
you would have to write a very often
have to write a plug-in to try to get
around the limitations and then on top
of that if you had an existing project
that was substantially large you'd have
to refactor in order to get it to work
right in the get it effectively into
that may have an ecosystem which
depending upon where you work that's not
always possible you can say well just
give me a couple of weeks I have to
switch build systems here nobody nobody
can touch code and so Gradle builds upon
all of them lessons learned from from
the past 20 or so years so Gradle versus
maven which is the primary point of
comparison Gradle has a fully
configurable
dependency graph which maven doesn't I'm
not sure why the green things are
getting cut off on the overhead
projector they're not here it does
support tasks exclusion so you can you
can specify that certain tasks do not
run it supports the concept of dry run
so you can say execute this as a dry run
so you can see what's going to happen
when it actually does the build what
tasks are going to get executed before
you do it so they'll tell you I'm gonna
run this task I'm gonna run that test
want to run this test so you know and
then you can then then dig in and if
there's a problem to try to figure out
why it's not going to run
our desks it has advanced support for
build for task ordering so you can say
you know this task must run after this
other task list so you can construct
complex execution orders between tasks
that depends upon whether or not you
know depends upon how put up in other
tasks etc so we have like things like
should run after must run after
constructs it has it supports custom
distributions so you know with maven
you're outputting a jar file you're
outputting a war file what if you want
to output a war file and a zip file
containing the war file and some
instructions so you can easily do that
with Gradle it does have repository
aware caches so that if you're using two
different caches sorry two different
repositories and they've got two
different versions of a dependency it
can help you resolve issues with this so
that can things like that can lead to a
nasty unreproducible behaviors where you
have you know one one dependency from
one repository overwriting a dependency
from another one version conflict
resolution so you can specify with maven
you're kind of locked into how it
decides to resolve the pendency so if
you've got two things including the same
dependency which one's going to actually
win out
maven has rules with that with Gradle
you can say well I want this one
you know it's further down on the graph
but you know I want this one to win out
you can have file based dependencies
which which is very important if you're
migrating your build system over to
Grail you can have Gradle for part of
the build process so something new
you're building you can use Gradle for
that and you can pull in as a file
dependencies something that's being
output by your existing ant build so you
can say okay you know I've read the you
know this new module that's downstream
it's written using the build system
whose uses in Gradle the dependency that
it's pulling in is not available in a
central repository or publish to any
repository I want to pull it off the
filesystem to integrate it with the
existing build you can do that
it's got the ability to do build
comparison so you can do builds between
two different two different builds and
compare them
it's got custom dependency scopes so you
can specify you can actually add
dependency scope select with maven you
have provided you could add an
additional dependency scope for like a
annotation processor or for some custom
tasks that you've written
it's got replaced by rules so for
example you can say that this you can
specify which version of a dependency
you want replace by in addition with
with how that how Gradle handles
dependency if you have a library that
you're pulling in from like say Google
guava which was previously named
differently the name escapes me which
previously had a different name and
you've got two dependencies once pulling
in the older name of the project and the
other ones pulling in the newer name of
the project with Gradle you can say well
these two are the same project it's just
renamed it will only import at once
right so you don't end up with two
different two versions of Google guava
under different names on your build
process so there's actually huge this is
just a small subset of the differences
between the two of them but Gradle has
got there's quite a few other benefits
to Gradle and quite a few other
differences to it with that now question
is why use Gradle besides just some of
the reasons why I've given with
dependency with the better dependency
management and build system one of the
major ones is that Google has switched
over the Android
I switched Android over to using Gradle
so this is a big commitment and a large
block of developers will now be using
Gradle going forward for doing Android
development so this is definitely going
to push tooling and other things forward
so this is the real shot on the arm for
Gradle so the question is so I'm sitting
here in this presentation you said you
want to go home and go back to work and
use Gradle do you need to learn groovy
in order to use it the answer is no but
it's a good idea you
you can you can write you can write
plug-ins for Gradle using Java and for
many of the common things that you have
to do out there there's either plugins
already or snippets of code that you can
you can paste and so no you don't have
to be next you don't have to go out and
read the thick groovy book in order to
and then read the the Gradle book after
that in order to use Gradle it's got a
much smaller learning curve do you need
to completely refactor your code base no
you can specify where depent where the
source code files are where your test
files are to Gradle and it will build
with them so you do not need to go out
there and stop all development while you
refactor your code base do you need
additional IDE plugins in order to use
Gradle most likely yes unless you're
using IntelliJ you'll need you'll need
plugins for it alternatively Gradle can
generate does have plugins that will
generate IDE native projects for your
project for you so it can generate an
intelligent project that can generate a
Eclipse project for you do you need to
change your build process it depends so
switching over to Gradle it's probably a
good idea to read to re-evaluate how
you're building things in a process
because there's different ways of doing
things do you need to port over your
entire build system no you can port over
pieces of it you can invoke the Gradle
parts of you can do like new modules in
your system and invoke Gradle from han't
or from maven there's ways of doing that
and can you embed custom and logic so if
you have an unhappy investment and some
ant scripts that are doing all kinds of
customized stuff you can embed that in
your Gradle files and you can use that
you don't have to rewrite everything and
try to figure out how something that was
written ten years ago works must all
dependencies originated from a
repository no we can have deposited
dependencies coming off the local file
system etc can artifacts be pushed to a
central repository so if you're using
something like artifactory or nexus yes
you can publish to it and doesn't work
with jenkins it certainly does there's
how to's on how to run it it's basically
you know like using ant or
Mainland so why Gradle for Java EE
projects well Java EE projects are large
and complex and we've got millions of
jar files and complicated build
processes that have to go in there
so for Java EE projects you know we have
to you know we might be doing wisdom we
might be generating code from wisdoms
you know generating wisdom code from
from Java code we might be running Jack
speed logic to import to convert XML
schema files and into objects using
Jack's be running you know complex
integration tests with a container where
we want to fire up a database run some
tests do integration testing stub out
stuff using like our Killian so we've
got all kinds of very complex stuff that
has to be done and for which you know a
cob us build tools is beneficial so in
terms of you know why you know why
Gradle versus ant ant lacks dependency
management being a major one among other
things and large ant files are a
nightmare to debug especially the twenty
thousand line varieties written with all
kinds of you know complex logic ten
years ago maven isn't flexible it wants
its its way or the highway type approach
with things and very often you have it's
you have to end up having to write
custom plug-ins for it which is kind of
a black art and then deal with trying to
version those and get those into your
build process so getting up and running
with Gradle if you haven't done it
already is fairly easy and it's
installation is similar to anther maven
it is not terribly complicated you
download the binaries from Gradle org
you set up your add it to your path you
Radle home it is a command line program
right like anthem Aven so instead of an
through maven or mvn you got Gradle and
the installation structure down below is
fairly straightforward it comes with
excellent documentation instead of web
pages which are handy if you're flying
if you're on a flight and need to get
some documentation but it's fairly
straightforward and on top of that
although I put up here the command line
it does have a GUI interface to it which
I'll demonstrate at towards the end of
the presentation which allows you to
invoke invoke and manage the build from
a GUI myself standalone Google
with it so it's the only build system
that actually comes with its own desktop
GUI so the key Gradle files the build
file is build decorate them so the build
XML and that uses a groovy DSL configure
configuration settings go in settings
decorate the local settings are in your
home directory Gradle that Gradle dot
properties and you'd put like your
database settings you know like if
you're if you're doing integration test
and you put your database settings in
there the local repositories under your
project doc cradles of course you
wouldn't check that in and the build
that Gradle is equivalent to your palm
and build XML except it's a lot shorter
than either of those two so the Gradle
daemon which I mentioned by default
earlier earlier is enabled by default
you should if you're using Gradle you
need to disable it on your continuous
integration environment so by default
out-of-the-box Gradle runs the daemon by
default on a continuous integration box
you do not want that daemon running
behind the scenes you want every build
to be fresh you don't want to do any
Cashion or anything behind the scenes
and so this is a recommended Beck's best
practice from from Gradle
you can display the current status and
find out how many demons are running by
doing Gradle - status you can stop
demons by doing Gradle - stop and then
down below there's a setting that you
can put in your configuration file to
disable the Grail daemon for like a
continuous integration environment okay
I'm getting up and running with Gradle
is fairly straightforward so from the
command line you can in issue Gradle
init which will create a new project can
create the initial set of files for you
with some pre-populated values in them
it will use the pom pile if present so
if you have a pom pile in the directory
it will actually read those dependant
it'll read the file and try to create a
Gradle file based upon that that is
still an incubating feature so it does
not get everything right so I tried on
importing the cargo tracker Java EE demo
application and I got it mostly right so
the only thing I did not get right was
the profiles we should have - which
you'd handle differently with Gradle
anyway you wouldn't take the same
approach that maven has done
just because Grails got more features in
that in that area so it gets it gets
emotionally done it gets the most of the
it gets all the dependencies in it gets
two sub projects done correctly but you
know it's it's a good starting point it
saves you from a lot of repetitive code
editing and copying and pasting but it's
not not the end-all and it can it does
handle multi module project so you can
an aim it at a suitably complex maiden
project with multiple modules and a
little important optionally when you run
the in it you can specify that you're
creating a Java library a Scala library
a groovy library and will set up the
project types based upon that with the
initial default plugin basic basically
does nothing in just creative all oh
sorry it creates a build file in the
settings file but doesn't create any
source directories for you and it sets
up to use by default J Center which is
quickly becoming the default repository
this one I've been reading has evidently
it's it has got some security
enhancements over than the Maeve it's
better security wise than the Maven one
it uses HTTP and in addition it doesn't
have the indexing performance problem
that you have with maven repositories or
so I've read there's a documentation
says that the the reason and reason
Google picked at J Center for Android is
so that they wouldn't have to deal with
the that could reduce the startup time
of the IDE s when reading when indexing
the repository so if we run Gradle in it
you know the type library creates this
directory structure over on the right
with the initial set of files now if
you're starting from an existing source
code project obviously you wouldn't take
this approach you create your you might
still run in it but you would start
editing your build.gradle file and
specifying the paths for your source
directories and where that stuff is
located and we'll see that and see that
in a minute when I actually go through
that the initial Gradle file that gets
created is a zip on screen so it's a
pretty straightforward file we've got it
has apply plug-in which we'll go over in
a minute what the plugins mean the
repositories and
the dependencies down below so it's much
more compact there's there's a ton of
comment it puts in a ton of comments
initially to tell you what's going on
you can strip all of those out but this
is much more compact than the equivalent
pom file and certainly much more compact
than the ant file okay and then from the
command line to actually build it you
run the data Grail and then - queue for
quiet if you want to suppress some of
the output but you can run Gradle to
find out what you can execute because
your first question when you start using
Gradle is you know what tasks do I have
available what can I run and Gradle -
tests will give you basically a dump and
tell you what tasks are available to run
so as you can see her around - tasks and
we've got you know assemble build and
they're grouped in the categories for
you and I'll show you how you can
actually create your own groupings for
your own categories they're pretty close
to the ones that you'd expect so if you
want to do a build of your project you
do Gradle you know build to build your
project and this will go through your
files so there's no more like with ant
having to open up the file and say okay
what tasks are in this file which one do
i execute you know which one generates
the wisdom files so just some more you
know init rapper rapper will generate
rapper files which you include with your
we should check in to version control
and those rapper files are basically a
bootstrap for doing your build process
so this is that that where I mentioned
before that you want to version your
build process so that if you check it
out ten years from now it'll still build
with the same version of Gradle
correctly and then a bunch of other
things for you know working your model
projects etc and then the build output
goes into you have your standard
snapshot that goes into the output so
and as we go through this we'll
eventually get to the very complex Java
EE projects some tasks there but first
question with with with Gradle we have
the concept of projects and within
projects we have tasks this is very
simple as similar to ant and also
doesn't agree with maven we can have
dependencies between projects
dependencies between tasks
and then with the build file that's not
a high level the two things that are
projects and tasks
moving onto it within the build file we
have so the question is when you're
editing a build file what's available
how do you know what to type and what
you can enter so the build file itself
corresponds to the project object right
so the build.gradle file basically the
current context of the project object so
if you pull up the documentation the
actual Java doc for the project object
in Gradle that gives you that that will
show you what methods what variables you
have access to etc so as you can see the
apply apply plugin there's actually an
apply method right for repositories
further down there should be actually a
property so all of these map
- so dependencies gets mapped to the
dependencies so there's a one to one
relationship between the Java classes
and the contents of what goes into the
file and this is the same for tasks as
well so when you implement the tasks
within it you're working off of the task
objects you're dealing with objects okay
and then the same thing with tasks as I
mentioned so here we've got you know as
you'll see one of the some of the code
samples we've got first last you know
enabled the enabled property for
enabling or disabling tasks so in terms
of defining tasks so it looks a little
bit different than and so we're actually
the first one is defining a task and so
the the properties description is a
built in property where we provide a
description it will print that out on
the command line the ext is basically
we're adding a property dynamically to
the task object for this particular
instance of the tack object which is
just an ad hoc property that we can
access down below and as you can see
since we're using groovy we can we have
access to the stream interpolation so
it's actually that ad hoc property is
getting interpreted in there and then do
first as before it executes its dual
asses afterwards and then the next one
is just a different syntax for basically
doing about the same thing we're at
printing some stuff out and then the
third approach where we're using you
know the the closures so this is all the
first three ways of basically defining
tests and then the last one down there
we're actually creating it we're
instantiating a copy task and we're
configuring it to do something right so
we're basically kind of you can kind of
think of it as if we're gonna accentuate
this copy copy task and then we're gonna
pass parameters to have a do something
to copy a file in terms of tasks
dependencies we can have tasks you
specify depends on you know the order
sorry the dependency so the third
depends upon the first and the second
and I've set the default task for the
file up at that top okay I'm one of the
nice features is we get tasks grouping
so you can actually specify define a
task grouping and then we can this can
put the tasks in that group so that when
we do that listing of tasks from the
command line it shows us the it shows us
the tasks nicely grouped so you can
group all of our tasks as we go through
this like all of our dock or tasks in
one block all of our wisdom generation
tasks and another block and so the IDS
like IntelliJ on our the grouping so
here have added my grouping and you can
see it adds it over in the little pop-up
window and displays the tasks underneath
it now one thing that I've kind of
touched on with some of the code samples
thus far are plugins so as you can see
there's a bunch there's some plugins are
very important to the the ecosystem
interactions gonna be using many plots
seeing many plugins as I go through this
presentation today so the default one
that that for Java projects that we have
by default is the Java plugin which
includes you know logic basic tasks for
doing compliation generating a jar file
running Java doc generating Java doc etc
there's also an application plugin and
then there's a maven plugin for being
able to use stuff from maven and the
ones that we're primarily gonna be
interested in with today are the ear
plug-in and a war plugin because that's
what generates our Java EE artifacts for
there's also a idea an eclipse plug-in
for generating the project project's
reach of those IDE s
there is a huge ecosystem of plugins and
very often there's several plugins for
the same type of tasks so there's at
least four or five different at least
four or five different ones for docker
which we'll be seeing so there's a huge
ecosystem of them out there to choose
from and it's easy to write your own so
that being said moving on before we
actually get to the Java EE stuff
there's Gradle supports multi module
projects so there's two different ways
of doing this there is the hierarchical
layout and then the flat layout and the
flat layouts where your different your
modules are all under the same directory
and then you've got a build file with
all the build logic in it whereas a
hierarchical you've got one overarching
build file and then the sub each one of
those sub modules module admin admin web
etc they each have their own Gradle
build file as well so this is kind of if
you're used to the the maven approach
we've got the maven pom file and pom
files in each one of those sub modules
is basically the same thing and this is
the approach I'll be using throughout
the demos today in the presentation so
the hierarchical layout just kind of
driving home the fact that you have a
build that Gradle and a settings that
Gradle and each one of them so we've got
the overarching project with a bill that
Gradle and settings that Gradle and then
Gradle files for each one of them now
one of the nice things with Gradle and
with Java EE projects is that we can
specify up we can specify a common set
of settings for all of the sub modules
so we can say you know all of our sub
modules are going to be Java based
they're all going to use Java 8 we want
them all to have idea project files
they're all going to be version 1
they're all going to pull there's their
dependencies from maven central right so
we can at the high level project we can
define a bunch of things so that we
don't have to paste the same thing over
and over again in each one of the sub
modules and then in the top level so
this is the top level project in the top
level project we specify which
our sub modulus which ones are we
including and so whenever working with
any of the modules great it will look at
the upper project and look at you know
which projects are a part of it to
figure out what needs to be built ok so
then in the sub modules you'll have the
root project name which will be the name
of the the overarching project so in the
case of this example it's C T Java and
then each one of the sub modules in
their settings file says you know my
parent project is basically C T Java and
then we can can declare dependencies in
each one of the modules on another
module by saying compile and then we're
depending upon you know core project
depending upon how far we're drilling
down okay so it's it's very easy to
define dependencies so within a module
you can say this module depends upon
this other module from the upper-level
module you can say all the modules are
using Java eight they're all using this
this set of configuration or tasks so
you can even define tasks for all of the
projects in terms of IDE support this
can be a bit challenging so for for Java
EE projects you will need or I've only
had luck with the Ultimate Edition the
one that you have to pay for other than
that when I've tried to use the
Community Edition
it doesn't recognize like the the tag
the like the JSF tag libraries it
refuses to recognize those so you very
much need to if you're for the
intelligent when you need to use the
paid version it does support Java EE the
NetBeans I've got the NetBeans Gradle
plug-in to work with simple projects
with multi module projects I've had a
trouble where it doesn't actually
recognize it correctly which is very
frustrating and when I have done when I
have loaded just a simple war project in
to NetBeans you lose you don't have all
of those nice context menus where you
know you want to run the project in
GlassFish or and or and Tommy he it
doesn't it doesn't he lose all of that
context stuff so hopefully that plugin
will move along eventually and then for
eclipse you will need the Gradle plugin
Gradle where does provide a plugin for
Eclipse which is fully fully featured so
installing the Eclipse plugin
you have to download and install that it
does not come by default so you just go
to the update Center you can get that
off of their website for the NetBeans
one to add support to NetBeans you need
to go into the plug-in and download it
download the Gradle support via the
plugin dialog so the only IDE
out-of-the-box that supports Gradle is
IntelliJ and if you're doing the EE
stuff you need the Ultimate Edition so
let's look at so the first Java EE
project just kind of try to demonstrate
the power of being able to migrate over
an existing project I'm going to take a
a warf a war file that's created an epic
is created a Java EE project in NetBeans
using the ant build and convert that
over to Gradle right because the this
project structure that NetBeans creates
for examples is is not compliant with
it's not what a grader would what the
Gradle plug-in would generate we're used
by default and that's not what maven
would use so this is just kind of a good
example so here we've got the the file
system view of it so we've got our
source code under source test code under
test or web artifacts under web so it's
not the typical like maven type layout
and then under we've got you know our
java classes configuration files etc
okay so in order to port this over we
create one file melissa's this is what
it took to port that project over and on
top of that there's there's one other
constraint that i added in there for fun
which was a custom library that wasn't
available in a Content repository right
so you know somehow put up some other
project so this is the Gradle file to
pull that over so if you look at the
gigantic Gantt file that NetBeans
generates which you know probably prints
out to like the fibers you know 10 or 15
pages this is the equivalent file so we
have I used the IntelliJ plug-in so I
could open this project and IntelliJ
I've got the Java plug-in I've got the
Java plug-in I specify that
the that we that this is gonna output
that this is going to use the war plugin
I specified my set
central repositories I use a pull in the
Lib director so down down here where is
it so this is the gonna pull in the
libraries from the file system the one
that's not in the central configurations
for the closure compiler I can't why I
pad that there that's from another
project but anyway so down here I
specify the location of the source
directories and the resources so this
this project actually I cut it off I
didn't include the tests in it but this
is all it took to port that NetBeans
project over into Gradle okay it was
very flexible and then for our
dependencies our custom library gets
pulled in right here it looks in the
local directory and appends jar to it to
pull it in and then for the war plugin i
specify you know that the web directory
has the resources the web and you know
and all the HTML files in there so this
is a bare-bones configuration so this is
all it took to port that project over
into Gradle and then the configuration
at endpoints that we have available for
the war plugin we've got you know from
you know the location of our web in the
classpath directory you know where we
want the web data where the web.xml file
is being pulled from etc
so that's moving over a simple file now
let's look at doing something a little
more complex so we have a complex Java
EE project or let's let's look at doing
like minute javascript minification with
it so say this project had some in
addition to having some Java code we
have some JavaScript code and we want to
minify that and we want to use the the
the google closure compiler so here I
include the Google closure compiler I
set up the output directory for where
the minified output is going to go and
then I have a custom job customed task
that I've written which extends the Java
exec tasks so this is a can kind of
think of this this is a Java object
which are basically instantiating and
extending and I can figure it with the
output directory and I make sure that
directory exists and then I specified
the parameters to invoke the the closure
compiler to minify my JavaScript okay
and then finally set up the war tasks to
include the minified javascript and I've
included a flag to indicate whether
minification is enabled or not so that
if I'm in debug mode I'd you know unless
unless otherwise specified it would
would unless this is set to true it
would not minify the files so there of
course would be other tasks in there
because you'd want to you know change
the what actually goes into the faceless
files in terms of what files are
important because you'd also be doing
concatenation etc so that's that's a
basic example more sophisticated example
the next one looking at Java EE if
you're using the criteria API with the
JPA metamodel right you need to generate
the metamodel from your entities so in
case of doing this here you need to
write a custom add a custom plug-in I
haven't found any plug-in in a central
repository that does that but you'd
brought bit rate this basic Java
annotation processor which is going to
use eclipse link and
the challenges in the case in this
example here is using eclipse link which
doesn't work well with the like the Java
8 annotations some of the changes in
Java 8 so it's still it's still like
Java 6 so I can't see any it can't come
it can't process some of the newer some
of the newer CDI code I believe if I
remember right so I actually have to
isolate it when it does the compliation
so this is so up here this is a groovy
class or if extend the default task and
I've written a lot the logic in here
actually invokes the annotation
processor to generate the the JPA
metamodel which i'm then going to
include in the source in a separate
source directory as a part of the build
so that i can then use it in my class
files so then this right here is more of
the plug-in where I set the destination
and the source sets to add add the
generated source code to the build
output of it and then using the in order
to use the the plug-in I need the Gradle
API and local groovy edits at compile
time and then this proc Java which will
run selectively over the idea of the the
data model and generate the JPA meta
model for my project okay so this is
depending upon your project you may or
may not be using the JPA meta model to
build up type save queries if you're not
you don't need that but it is possible
to do it moving on to more to the next I
guess the next level for for Gradle
which would be handling ear projects so
if we have a suitably complex ear prod
fairly simple ear project but one with
an ear EJB a web module etc and we want
the output of course to be you know the
standard you have our EJB jar file or
our web jar file etc then the the
directory with our library directories
we'd use the ear module to accomplish
this this of course is fully
configurable so we configure it where
the differences so we can specify the
deployment descriptors so we specify
under the dependencies the EJB module
the eager lib which project to pull for
that and so that that's that's that's
basically all I mean the documentation
that's online is fairly comprehensive
for the for the settings are available
for this but this is basic this is all
the code that you need to write to get
an ear module up and running with Gradle
so if you compare that compare this to
like the amount of code that you have to
write in ant build file it's much
simpler now if you're if you're working
on something that's the war plugin
provides the provided classes scope so
Gradle by default does not have the
concept of a provided scope which you
have in maven provided being your job
you EE API so you don't want those
bundled up in your in your war file so
if you're not using the the war plug-in
or you're doing a project sub project
and you want to make sure that you do
not accidentally include the other
dependencies you can use you can define
as I mentioned the introduction Gradle
has the ability to add scopes so in this
case here I've added a provided scope
specifying that the class path for
that's going to include the Java EE 7
API right and then I set up the IntelliJ
module to include that provided scope to
match it to its provided scope and then
I've added that to the compiled complies
path for the source sets and so this is
basically adding a provided scope to a
non war based project so for whatever
reason I'm not I'm not using a war plug
and then I needed to add that provided
scope that's that's how it would do that
now one of the other common tasks with
with in Java EE is using Jack's B to do
code generation so in this case I have a
I specify I'm using the the Java plug-in
of course and then I pull them that
there's a third-party plugin that wraps
the jacks B compiler which generates the
Java code from the XML schema files
including my repositories of in this
case here I've included both J Center
maven central and then
the jack speed dependencies and then I
specify for the jacks so this Jack's be
plugin has a configuration point so it
goes under Jack's B in your file and you
specify the configurations for this
plug-in here underneath Jack's B and I
specify my schema directory and when I
run the build it reads in the files that
are in that schema directory and
generates the Jack's B entities for me
so moving on to the jax-ws client so
very often you will have you want to
generate your invoking another web
service you have the wisdom files you
want to dynamically as a part of your
build process generate the client
implementations of those classes so
there's a plug-in for this that's
available the it's the name of is this
ws importer plug-in so the generated
source will end up actually under so
you'll have you place a under your mate
your source directory you'll add a
wisdom directory with the package name
of package containing the wisdom file
and it'll put the this generated source
code in this package for you I'm
actually in a separate location that's
not in your class path so anyway so
that's that's it and this is the actual
Gradle file for generating the for
generating that Java code from the
wisdom code so here I'm applying that
plug-in which is actually going to come
from the grail plugins repository set up
the class path for it so this is setting
up the builds to the dependencies for
the build script dependencies that are
being pulled in for the build script and
that's basically it it scans through the
class path and looks for those wisdom
files and then in under the build output
directory you'll see a generated source
with your source code and that gets
added to the source code source set for
your project so that when you build it
or when you work with it in the IDE
you'll have access to these classes and
you can call these classes and invoke
the service so this is an example of
generating a jax-ws client web service
client for that as well and there's
there's other plugins out there for for
like processing swagger files for like
restful end points so there's a huge as
I mentioned there's a huge ecosystem of
plugins out there that can do just about
anything that you'd want to do so moving
on docker images now there's two
different things that you might do
different to different types of tests
that you might want to do with docker
with Grail so you might want to use
docker to actually build Gradle images
so you might want to have your output
one of the artifacts of your output of
your build being a docker file right so
you you build your app to be deployed
and you also build an image with the
deploy to Tommy or weblogic etc and
upload that to your repository or you
might want to run docker during testing
has to help to aid with the integration
testings so for an example one use that
I've used the the docker execution
during build time is to actually use a
docker container for the for the
integrations test for the database right
so mahat him to set up and maintain the
database for running integration tests
which every time that the tests are
finished running you want to destroy the
database you don't want to kept around
you on every developer having to have a
database we can use a docker instance
for this so as a part of the build
before it runs the test cases it
launches the the the docker runs the
database and docker and once once the
unit tests finish if if the unit tests
were successful it destroys the docker
the docker container so I don't have to
go in there and do any explorations
afterwards so for so for running that or
the easiest one is the planet to docker
plugin which gives you the ability to
which this can also build docker images
although I haven't used it for that it
gives you the ability to run so it's got
this plug docker run plugin which makes
it easier to run just about any docker
container for building docker images
there's two plugins and depending
upon which one you want so this one the
transmode allows you in docker to build
up the docker build up the docker image
basically within the Gradle file where's
the other one will actually use the
remote dock or API and a docker file
that you provide usually I'm working
with an existing docker file so I use
the second one I mean both of them are
suitably powerful enough so for building
a docker image this is a Gradle file
which basically uses an existing docker
file that's in the build to generate a
docker image so I specify my plugins up
above I need to include this class
because it's used down here in the tasks
for building the image so I specify my
plugin for being the remote API the
second one on the previous slide and
then the location of where docker is
running and then it runs it uses the it
finds the docker file in the current
directory build runs build on the docker
file tags it and puts a puts it in a
local repository so this is all the code
that was required for doing that for
integrating building a docker image into
my into my build now the more complex
example so this is just running this is
just how to run a docker container from
a Gradle build so here I'm using that
planetary docker run plugin that I
mentioned earlier
specifying my that I'm pulling it from
the Gradle plug-in repository setting up
my dependencies for that so this is the
dependencies for the build script and
then down here I provide the
configuration for the docker run so I
want to run the Postgres I want the the
image I wanted to be named docker - test
and I want the image to be Postgres at
when it's run as a daemon wait you know
sleep for 100 seconds or 100 I think
that's 100 milliseconds afterwards to
make sure it started up before moving on
to the next task and pass in the
password now I could parameterize that
and you know put it so this this
password here I can then use and
elsewhere in the thing so using running
this file and run running this Gradle
file and typing docker run on the end of
it will actually fire up the PostgreSQL
container for me as a part of that so
that's that's all nice but so let's look
at a example of integrating this into a
bill
integration build we were running our
Kilian tests and we want to fire up
docker with our database before we run
the test then and then tear it down at
the end if the tests were successful so
to do that the first thing we need to do
is to basically register our own test
monitor implement the test listener
interface to keep track of any test
failures so here i'm within the within
the i'm gonna register this as a
listener on the build process so that
when it runs the unit runs the unit
tests they get told after ever it runs
every tests and i can find out the test
results for every test that it runs
where the test was successful or not
right so you could even you could do
something like this type of integration
like if you're doing a build and adding
unit tests for hours and hours you could
have it start sending out you know text
messages you know after the first test
fails if it takes like you know six
hours to run euro regressions so this is
the the docker file right here where i'm
pulling in the test monitor the build
script pulling on the planet or again
and then what i've done down here is
I've added a listener to Gradle so I've
registered a listener on the to listen
for unit tests successes and failures
and I set up the test tests so I'm
actually changing the dependencies of
the test tasks right so I'm saying that
the test depends upon run so that before
tests can be run the Gradle script will
run my doc will run the docker run that
I pulled in from the plugin and then the
test is finalized by I can kind of think
of this is the finally block docker stop
and so it'll run docker stop after it's
done however in my code back here what
I've done is I keep track of the number
of failures so if any of the tests fail
I say disabled the docker stopped tasks
so I said so I get the so I retrieve it
from the project the doctor stopped task
which has been pulled in as a plugin and
I set set the enabled to false which
disables it and so if if any of my unit
tests fail during the during the
execution will leave the database in
place so I can go look at and see what
the data what the status of the data in
the database wasn't know what did it
insert wrong what was the final state
so that's that's that that's looking at
docker integration now a few more things
for Java EE one is working with running
integration tests so very often for your
configuration files for you'd want to
pass in like the database parameter so
if you're not using if you're using
docker like on a continuous integration
machine but the individual developers
are using databases you can actually you
can use the maven plug-in before
actually doing the substitution on your
file so in this case right here I've
templated out my persistence XML file
with the URL and database passwords etc
and then within the build file I am
pulling it in from my these are actually
getting pulled in from the Grail
properties in my home directory like you
would do with maven pulling in the
settings that are then getting blit it
into the persistence that XML so that my
integration tests know where to exit
what database they're supposed to use
this is also demonstrating the the do
first on the test task so right here
I've extended I've changing with adding
behavior to the test task so before it
runs the tests making sure to copy my
beans XML files over so that my
convenience discovery value is correctly
set for running the integration tests so
this is you know if you've ever wrestled
with maven where you didn't have your
beans of XML copied over when you tried
to run your integration test it's very
helpful and then the last part in terms
of getting Gradle up and running with
arquillian it's just a matter of
including the dependencies and your
Gradle tests SR your arquillian tests
will just run so i have a complex set of
integration tests which fire things up
and also run them docker so this all
works out of the box so there's nothing
there's not that hard so it's very easy
continue to use Marc helium and then in
terms of a couple of additional things
for for Grail just some miscellaneous
things that I've added in you can do
so for example we've got a bunch of
anything so free we can do you're on the
Gradle UI first so I mentioned at the
beginning of the presentation this is
the only build system with its own UI I
can run the Gradle UI it's gonna start
up takes a minute because it's actually
analyzing the project
hopefully yep there we go so it's get
built up a tax free so you can actually
invoke Gradle and control it from this
UI so it's the only built system that
has that now there's also dependency so
we can print out the dependency tree and
there are plugins that will allow you to
look for conflicting dependencies and
various other things we're doing
analysis on this but this is going to
print out for this project
so as you can see for this is actually a
fairly basic project but it's pulling in
tons of dependencies so we can actually
look through this to figure out where
various dependencies are getting pulled
in from you can do a dry run
so Gradle build will show you what it's
going to do if I if I ran the build so
as you can see because I've ripped I've
run the build before there's nothing to
do so everything's going to be skipped
so that's one of the other things with
Gradle one of the real benefits is that
with the incremental compile it knows
what it built last time so if you run if
you if you change one module if you
change one source code in your project
you go back to Gradle and say build it
only builds what changed it doesn't
build everything it doesn't recompile
all the source code files for that
module
and there's also a great old profile
I've got a couple of profile reports on
already ports
so this is built integrate all this is
another plugin
so here we can see where the but where
it's spending time on the builds you
know each part of the process so I mean
this is a very simple example in a very
simple project if you scale this up to a
1 if you're a large enterprise project
having this type of thing you know you
figure being able to troubleshoot you
know the build time suddenly went up
today somebody checked in some code
somebody checked in something yesterday
and where where where's it spending all
of its time so Gradle is got so got
built in profiling support so we can
look at configuration dependency
resolution tax execution you know where
did it do the work and how much time
does it spend doing everything so is it
this is very powerful being able to have
this level of insight into what's going
on with your build
and so with that old thank you and if
there's any questions yes
so your so the question was whether to
do top down or yeah
it depends upon how much depends upon
how complex your build process how many
plugins you're using and the the
sophistication with the plugins right so
if you've got a very comp so if it's if
there's just a large project with many
palms and all they're doing is basically
dependencies then running the in it and
having it output stuff but if you're
using profiles you're using custom
plugins all over the place I would
probably take it and go one at a time
for doing it and take that and take that
approach as opposed to trying it as
opposed to trying to tackle the entire
thing at once
I don't know that's usually I decompose
things and for most of the ones I've had
where I've been doing with this trying
to move stuff from hand over to Gradle
not necessarily from maven to to Grail
other questions
yes
okay
mm-hm
yes in fact you saw one of the examples
I used a maven plug-in in my build so
yes it is it'll be dependent upon the
plug-in Oh hopefully yeah I I don't I
have not I've not I've only worked with
simple plugins with that I don't know
what that plug is it'll be dependent
upon what that plug-in is doing in terms
of how easy it will be in order to pull
it it yeah yeah other questions okay
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>