<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Ask Tom Office Hours Java RDBMS | March 14, 2018 | Coder Coacher - Coaching Coders</title><meta content="Ask Tom Office Hours Java RDBMS | March 14, 2018 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Ask Tom Office Hours Java RDBMS | March 14, 2018</b></h2><h5 class="post__date">2018-03-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/u-yywAw0XlY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning or good afternoon everybody
who joined my name is Khoa Samantha and
with me similar lamella hi hi so today
we're gonna talk about spinning up and
scaling up Java applications killing out
whichever application we really hope
that you can ask question you know the
main purpose of this event or ask term
series we were gonna do it every month
is to be available and so you can ask
any question we have to pick a theme for
each session so today's theme is
performance and scalability so we really
hope you have some questions and if you
don't have we have things we hope you
can share with you so for a few minutes
I'm gonna listen and we're gonna listen
to you guys so you can unmute yourself
and you can ask a question and hopefully
Nimr and myself we'd be able to respond
so please speak up
well you can use the chat if you like
no one to speak be discreet you can use
the chat okay any any question anyone
any concern any on scalability and
performance java and oracle database
okay
I suppose question will come when we
start sharing stuff so we have things we
want to share with you and so the the
first is we're gonna discuss a little
bit of how to speed up java applications
with oracle and then we're gonna talk
about how to scale out java workloads
okay so to speed up java application
here are some best practices on
recommendation so the first thing is
database connectivity
as you probably know connecting to the
database is very expensive so the
motivation that the recommendation is
you must have a connection pool you
could use a client-side connection pool
we're calling it UCP it stands for a
universal connection pool or you may use
a server-side connection pool called
database resident condition for DHCP in
short
nema feel free to interject any time you
want
oh I see yeah so DRC PS stands for
universal the database resident
condition for which is on the server
side
it is useful if you have multiple web
tears on you want to share the same pool
by all those meteors for example if you
have thousands of me tears and each has
like their own pool like five or ten if
you multiply by a thousand you end up
with 10,000 or 20,000 connections to the
database so you really want to reduce
that worker so that's the main reason
you want to use the LCP
otherwise you know for the average
workload at the universal condition
poison is good enough you seep is good
it has a lot of knobs so you can size
you can set a lot of timeouts we're not
gonna show you stuff here but just so
you know UCP is our recommendation and
we have fine-tuned it it's a very
performance very very fast okay so
that's the base connection pool you must
have a condition well I think that's
obvious everybody's using the other
mechanism we have to speed up database
connection is the deep prioritization of
failed nodes
this is a new feature the way it works
is when you enable the feature the you
specify a period of time for example you
say if there is a failed note please do
not consider do not attempt to connect
to that node for the next 10 minutes or
30 minutes you know it's up to you the
reason we provide this mechanism is if
you have a a list of nodes to connect to
let's say you have ABC we're talking
about Iraq configuration here where you
have multiple instances and the let's
say B is down if you don't set this new
property the the the the net layer you
know the listener will attempt to
connect to if is not it's busy it's
gonna attempt to be bisby's it's gonna
attempt see that's called client-side
load balancing so during that period if
B is down oh well the listener have to
wait for the timeout to kick in and
which is a waste of your time you know
when you're waiting for a connection you
want to get the condition as quickly as
possible so if you set this new property
it will remove B from the list
temporarily I mean for the duration of
the period that you set this way you
know you you pink a if is too busy with
ping C so B is out of the loop but after
the period of time it's gonna go back
onto the list so it's not a definitive
thing it lets you set a time where you
can have time to do submit nestled you
know that these on the maintenance or on
the reparation so you can see that
and the other thing is a lightweight
Keynesian health check so what is the
usefulness of this feature by default
when you request a connection and we
check out a connection from the pool we
check the health of that connection you
know by pinging the database through
that connection through the circuit so
with this feature
you are telling the driver please do not
check the health of that condition I am
confident that within you know the next
30 minutes all my connections are
healthy so you're saving this ping to
check the health of course if the
connection is I mean virtually invalid
you cannot receive an exception when you
try to use it but you avoid the
systematic check of the health of the
connection anything you want to add me
mail I think was a so I think we have
for two more people so should we just
pause and open it for questions
we wanted this to be conversational so
if you have any performance or
scalability question you want to ask we
prefer to hear from you rather than us
presenting so you have anything you can
unmute yourself or you can use the chat
and ask the question and so I'm posing
the con the presentation to see if the
new people who join have any any
question or any preoccupation they will
want to discuss
you
yeah this is koi I don't have anything
right now continue on for now okay thank
you very much okay so so that was
connection any question on the
connectivity database connectivity have
you experienced any problem or concern
regarding database connectivity with
Oracle from China
okay so the so we just covered the
connectivity
I somebody wants to say something I
guess no okay
so we just covered we just talked a
little bit about connectivity on the
next expensive operation is the
statement processing so as you know you
get a carnation and then your Java code
will ask take the connection object
create the statement object and then run
some sequences on you know whether it's
a query or insert update delete so the
question is how do you process the
sequel statement and as most of you and
everybody on the caller probably know
are you have to pass the statement you
have to bind if it's a query whether
it's a DML or not you need to set some
the value of the bind variables and then
you need to execute and if it's a query
you need to get the resources so those
are steps on those steps the parsing is
very expensive is really really
expensive so that's called hard part's
so you don't want to do that every time
so you pass the first time and when you
go come back on the same statement you
don't want to pass it again so that's
why it is a best practice to always use
preferred statement prepare statements
are passed once
and that's it you the subsequent
execution you use bind variables and you
avoid the past option so we always
recommend the other benefits of
pre-press ticklin is it avoids sequel
injection so nobody can trick your
application and give you some dynamic
sequel that you will execute them it
will harm your system so that's the
other benefit security benefit
okay so prepare statement
mandatory and then caching statement
caching if you don't cache a statement I
mean caching on the client side you know
you ended at the driver level you know
we have an array of statements so let's
say the error is 20 the driver will keep
the 20 misused or the 20 last use I
cannot remember exactly in which order
he does it wait we'll keep that in those
areas so when you execute statement
number one
first time it will send the text of the
statement to the database the next time
you execute that if it's cached in your
array you know of cache the statements
it will just tell the database oh please
execute the statement number one you
know and only to send you the state the
text you already have it because the
database has all the sickles different
that it has been executing for the last
period of time you know there are a lot
of libraries in the database where those
statements are preserved so you just
tell the database execute statement
number one or number two or number five
whatever so that's the benefit of
citroen caching and it should when you
do that you avoid what's called soft
parsing because it's fast okay but you
need to send the text and database will
do a lexical analysis of this depend on
then say hey I have it already so I
don't need to pass so you avoid that um
the other thing in terms of statement
processing is the result set caching so
this is wonderful you have you run your
query you get the result set for the
first time and then the driver will keep
the result set in its memory you also
have the option of caching with change
notification this is a very neat feature
it's been around for a long time it's
called query change notification which
means I am using the result set so I
don't need to go back to the database if
I'm executing the same query I will just
get the result set from the drivers
cache but the benefit of cache your
change notification is if a change
happens
on the database which impacts the
results let's say somebody makes an
update or delete the insert into the
tables and then if you were to execute
your query again the result set will be
different so the database is smart
enough when you register a query a
database is smart enough to to find out
here somebody just makes a lot data
insert delete which changes that the
result set of that query that somebody
has registered with me so I need to send
a notification to the registration you
know you can reduce the frozen for the
driver can register receive the
notification the PLC call package can
register receive the notification anyway
they are making listener for
registration and receiving the
notification so the database will send a
notification the driver will invalidate
the result set and will execute again
the statement to get a fresh resources
so so results at catching live channel
notification is a very good feature if
you want to if you want to cache for
example and static tables you know
tables that don't change so frequently
you know like a price list of things
later and you can share across all the
threads within your DVM you know within
the application so that's a very useful
functionality Oh proxy results at
caching okay so I'm gonna be presenting
in few slides something we're calling
connection manager in traffic director
mode connection manager is been around
for a while
now we've extended it with some
mechanism so I will explain when I get
to this slide but for now just retain
the fact that the the connection manager
in traffic director mode is the proxy
the database proxy which sits between
the database and the application so it's
a middleman and it can cache result set
okay so it caches the result set so a
lot of application not just one Divya
multiple deviance can be sharing the
same result set and the last in terms of
I mean last topic in terms of optimizing
statement processing is array operation
so you can do an array fetch so you
fetch rose by array by specifying number
of rows to fetch for each interaction
with the database so those are network
traffic optimization and DML are a DML
re-insert every update every delete you
people also call them batch insert batch
update budget edit so those are all
array operations or batch operations not
optimized network traffic so instead of
selling each row you prefer and you get
them by jenkins you optimize and
anything you want to add me much amazing
statement processing oh nothing the
quasi I'd like to give up the board or
everything okay so people only call any
question any preoccupation in that space
okay no no question okay moving on this
is a picture of the database resident
connection pool on you can see here this
is the pool on the database side a DBA
can start the pool size the pool stop
the pool whatever it does on the
applications you know those are wet
years you just specify that you want to
use a port connection there is a prefix
pulled
and when the listener sees that it knows
that this is the RCP condition it will
ask the connection broker which is here
to give you a connection from the pool
so the broker gives you a connection and
you have it direct attached to the
connection so you use that condition as
if it was a a dedicated connection you
get from a client side pool so there is
this handoff step you know the the
client makes a request the listener sent
to the broker the broker find the
condition in the pool and then establish
a direct connection with the client it's
unit connect condition so that's how it
works
honey you can see that because it
separates it from the the JVM it can be
shared by multiple media okay we don't
have time to go into the details but if
you can google or search on our website
you know DRC P you can see found on
literature about it but then I'll have a
pointer to a white paper where you can
see everything we're talking about you
can see the some code fragments of how
to do all sorts of things we're talking
about here okay
so continuing with speeding up
applications optimizing the network
traffic we do have some features to help
you in that space the network data
compression and this is something we
have introduced a thing in 12:1 if it's
been around for a while but JDBC started
to support this in 12:1 what it is is
you specify that you want to do
compression and the database I mean the
data the driver will compress data which
it receives from this database so it
will compress the data
and depending on the the possibility of
compression you can see a difference in
a significant difference but it's more
it's more necessary in wide area network
not on local area network
the difference in local area network
might not be that great but in wide area
network maybe in cloud environment it
could be very important to set this
property all the other thing you want to
pay attention to that most people don't
know about is the session data unit or
SDU this is a buffer that the database
it is the size of the perfect that the
database uses to send data to the client
so let's say you make a query the
database gets data from the table and
put that in a buffer a network buffer
the network buffer is shipped to the
crier okay so the SDU
defines the size of the buff network
buffer so let's say you want to retrieve
10 megabyte of JSON document or XML
document by default in in previous
releases the maximum size of the SDU
was 32 K and then I think in 12:1 it got
bumped to 64 K and in 12 - it's now up
to 2 megabyte so if I'm not mistaken on
the releases but so let's say you want
to retreat and megabyte
if you leave this to 64 K which is the
default let's in 12:1 well you couldn't
need multiple interaction with the
database to retrieve 10 Meg whereas if
you set it to 2 Meg or 1 Meg you need 5
or 10
extend with the database to recoup ten
megabytes okay so it's very useful but
then you need to be careful it is per
client per connection so if you have a
lot of user on your database and they
are all doing lot of XML or JSON or
large de large club blob operation you
probably want to set these to a
conservative value otherwise you're
gonna broad memory of the crying machine
because everybody will be allocated you
know allocating the one Meg or the two
mega of Sto so it is important to be
aware about it and be cushions cushions
about how you said it
the alternative to session data unit is
called zero copy so zero copy means it
does with the database we will not use
an entering buffer it will transfer it
directly from the table to the
application to the choir so those are
features such as C key or fine Labs
introduced probably in 12 or perhaps a
little bit before but it's in 12 1 for
sure it's called secure file up so that
you can look at it it's good for large
stuff you can do the duplication you can
do compression it has a lot of
functionality so look at this if you're
in the business of processing large
documents you don't want to pay the
price of copying into the network buffer
before shipping to the client so all
those things happen under the cover you
need to be aware of it the last thing I
want to talk about in the network
traffic optimization is session
multiplexing
it means I have multiple client
connecting to the database so each
connection is discussed as a session you
know you have a session today on the
database side a session is executed
within the database server process so
the session keeps everything you have
all your metadata all your cursor
everything on the database side so
session multiplexing means we're gonna
use one single network okay link network
and then through that link we will
multiplex multiple connection multiple
sessions or multiple connection to
session on the database side so it's a
it's an optimization of network
attachment so if I want to make an
analogy you you channel you know
multiple circuits through one physical
network connection so that is sort of to
give you the mental idea of what it is
so it helps multiplexing so the semen
not the new thing but the old cement the
classic semen or connection manager has
been around for a long time and das de
Sousa Mendes two things session
multiplexing and security it has a lot
of security functionalities you know
denial of attack keeping whitelist
blacklist etc etc and by the way this
email is used in the Oracle cloud to
make sure that a tenant we not access
somebody else's database for example so
it is a very important piece in the
security area it also does multiplexing
and now we have extended that with new
feature but I'll talk about it a little
bit in the next slide so any question on
network traffic optimization
you
okay you can ask questions through the
chat so myself or Nima who also on the
call we can take care of the chat while
we're presenting but we didn't want to
present we wanted to talk for it's okay
the last thing last segment of speeding
up job applications with Oracle is what
I called in-place processing so anyplace
processing is a nice term to qualify
Java stored procedures or PLC code
stored procedures so as you probably
know Oracle have been supporting PLC
core since ages I think probably version
6 of version 7 so it's been around for a
long time and then with the release 8i
in 1990 I think yes 1990 we introduced
Java so Java VM built into the database
I mean a database server can run Java
PLC called sequel in the same memory
space so it's not like you load a row at
runtime it's built into you know when
you install when you you enable it so
Java start Prague or PLC code proc the
beauty of those is you make one call and
you process a lot of stuff on the
database side when I say a lot of stuff
I mean not just the secret statements
but also procedural language you know
like PL sequel procedural language or
Java you can have Java SE host on the
Edition Java so I mean plain Java like a
think about the JDBC code that you plug
into the database so they do is execute
everything on the server side and only
returned
the results so it saves a lot of traffic
and it is faster because you process
data locally no data shipping and so
that's what I'm calling in place
processing and it is a sort of trend in
there in the architecture in the market
look at our big data frameworks what are
they doing they are putting the
processing close to data you know data
is distributed across multiple storages
whether it's the affairs or no sequel or
even Oracle meaning you can use Hadoop
on so whether it's those you put the
processing close to the data so it is
not something coming from database
vendors but the other Big Data
frameworks have also embraced that
because they see this as the performance
optimization now people will say oh well
I don't like you know Java how PLC code
in my application I don't want to break
my application well the problem is the
market is also moving towards
micro-services so you could have a micro
service as Java and you invoke that
micro service from the other services
from your Cooper needs or micro service
framework so it is still valid with the
modern architecture that's what I'm
trying to say ok so here's an example I
mean a picture of Java in the database
and you can replace the same idea with
PLC call if you are more familiar with
PLC go
so one call to execute the entire
procedure which is here the procedure is
here so it's Java with sequel statement
if your Java code in the database does
not have sequel it does not belong to
here to the database unless it's doing
something to enrich the database for
example if you
in a soda for Java API you can do fluent
programming to manipulate JSON documents
in the database or if you plug in I mean
we have done it but we have not
published it
Hadoop code in the database we can had
process Hadoop code mapper reducer
directly in the database without you
know going out and there are tons of
examples of people plugging Java library
in the database whether it's routine to
do search to do indexing at the database
level it's at receipt or I can talk to
you for whole day about Java in the data
list it's my favorite topic okay so what
we saying is you plug the debacle here
and it through some secret operation
with some java code around and you can
invoke from java from PHP node.js a c++
c sharp
Ruby Python any client can invoke Java
because it's wrapped as it PLC code
procedures so that the implementation is
hidden from the client the client does
not is calling channel it's just calling
a wrapper a PLC go wrapper on the
wrapper itself invokes the gonna drop is
not a runtime it's just a a function
wrapper so no overhead okay so it can be
consumed on low network latency in wide
area network or crud and women because
you only make one call one call over
your network and you get everything
executed so that's the beauty of Java in
database if you have the skill or PLC
code if you have skill all here is a
picture of the connection manager in
traffic director mode as I said this is
the middleman this is new its new with
18 C 18 C is available
for Exadata and the cloud it's not yet
available for on-premise on other
platforms so that's why we are not
making lot of noise about it but it is
there so the traffic manager in the
condition managing traffic director mode
is a new extension to the connection
manager also known as Simon so with the
extension we can transparently to
application provide you know we can hide
the plan maintenance and unplanned
outages to support zero application
downturn we can optimize session usage
that's what I was telling that we can
proxy resultset we can also do statement
caching the security is already part of
the Seidman classic so it's not new
something we're looking into is when you
do in shouting we can route the the
traffic to the right shop or right
instance but it also does load balancing
of in rack environment so all the the
key thing is it transparency to the
application so your application will
connect to semen instead of connecting
to the database so you have to change
the service definition in your TNS names
not Ora and that's it so it is
transparent to the application because
you're not explicitly making any there
is no new EP are you just change the
connect the the way you are connecting
if you are using TLS alias in your code
so you not change your code you just
change the definition of the TLS areas
okay in in coming weeks we will make
more noise about the traffic manager did
the cusamano in traffic director mode
but I wanted to show you that this is
also a mechanism that can help you in
terms of speeding up your performance
and that was the the speeding up which
is the performance part of the the tour
the second part is about scalability and
if you have question now you can ask
otherwise namah' do you want to talk
about the scalability things I can share
I can push the slider I can stop sharing
and you can take away I can present it
up to you you can continue a question I
can I can add any comments if I have
okay that's fine um so for our guests do
you have any question on the machine so
far so I just wanted to check if anybody
is using Universal connection pool which
is our connection pool
you could either talk or type
okay okay
you can always interrupt us anytime okay
I will discuss the three things here
before it's a horizontal scaling of a
scaling of Java workload so we'll talk
about the new Java API for sharding then
the share pod for shard database and
then we talk about the multi tenant
support for java application also the
asynchronous database access api which
is not available yet as a product but it
is an api that Oracle is leading and
working with the community with the Java
community to make it happen and then
maybe about the seaman in traffic
director one okay so the idea is you
traditionally have inshaaallah database
and Torico has introduced shouting in
1212 - I believe okay - the idea is
instead of having one big table or one
gigantic table you can split
horizontally your table across multiple
shot so this is not Neil Oracle is not
the first there are a lot of databases
out there that's support sharing so we
come into the this plate down and we
have good support for it so what we have
I mean from Java perspective okay this
is the new API in Java 9 if you go to
Java 9 and you check for sharding API
you will see those are the api's that
Oracle has I mean worked with the
community to make it a stander so it's
not anything proprietary
and the way it works is let's say you
want to connect to a shard that database
you need to get you need to produce a
sharding key and if your application or
your shots are also split by region you
need what is called a super sharing key
so super shining team could be region
for example EMEA AIPAC North America or
Latin America those are super super I
mean super shining key and then the
shining key could be a city or a state
within the US for example California it
would be a shining key or city San
Francisco my professor sorry just
kidding okay so the way it works is you
need to set a value and then you call
you know you create shouting key builder
it's a semi pure here here and then you
specify the value this is a value on
this is the type of the data and then
you build the key you use the built
pattern okay this is Java 8 programmatic
API means fluent programming okay so you
build a super shot in case you need one
but most of the time you will need to
just build a single shot in key by doing
this you know you specify create the key
builder what is the key value and then
invoke the build after that you just
create a connection you ask for
recognition by giving the key you have
created all the super key is super
shining key if needed and invoke the
build as well so it's all about using
the build button okay so that's all you
have to do
in order to access a data which is on
shouted database okay so how does it
work under the color under the cover the
Oracle database shots are just seems
huge regular databases but we have
something called the shot director the
shard director knows the topology of the
shouting kids across all the shard
databases so for example this database
here has shards 1 to 10
I mean shouting key 1 to 10 this one 10
11 to 20 21 to 30 so the the the SHA
generator has this topology has this
mapping so when you ask for a connection
it goes to the GSM listener it will hey
this is the value of the sharing key
okay I know where it is so go here and
then the application will go to that one
no the driver will go here okay so
that's how it works but the problem is
if we do that every time you're gonna
pay the price of going to the shadow
writer every time so that's very good
idea so what we've done is and this is
what it looks like you know this is we
keep the chart topology is the lower key
on the hierarchy for each chunk a shard
is a series of chunk you know so the
chunks have lower key and hierarchy okay
so the user ask and then you get the key
you go to the show okay so in order to
amortize the cost and avoid going
systematically to the shot director we
we mean Oracle the universal condition
pool is capable of learning the topology
so the first time you request a
condition it goes to the shadow actor
because we have no idea it's
by default we don't know we don't have
any topology so we go to the shot
director it says go here I mean we took
the opportunity to dump
if the topology of the shot into the UCP
you can see here you see P we'd say ok
Schottky 1 to 10 belongs to check one in
shot one okay it does the same thing for
the others every time you access a shot
for the first time we dump the topology
so you see okay at this time you see P
has the entire topology the same thing
that the shot director has so which
means in the next request you see P we
just tell directly where to go without
going to the shadow actor so that's why
we say you see P acting at a shard
director the benefit of this is first
you don't pay the price performance and
the second is high availability even if
the shadow 8 is dead I mean it's down
you see P can't continue to work so we
don't care remember those are just
regular databases but your data is split
across them crucial ok so that's how you
see P can learn about topology and act
as saturator so do you have any question
on shouting shouting key and the way you
see P works at the truss it or any
question only might feel free to add
more if you want okay
no question ok so moving on to
multi-channel so this is what tightening
as everybody knows it the way it works
is you have a container database and
then you have the pluggable databases ok
in the
call iterative it is one database
instance capable of managing multiple
databases right zoom article physical
database
those are pluggable databases okay
and the sitibi is just it a database
which only has made a data no user data
and so one instance will manage all this
set so multi-channel has a lot of
functionalities that we are not gonna
cover those today okay what we want to
stress is from the job at the proper
perspective instead of having a sport
per PDB you know called PDD pluggable
database you know so here for example is
a know having one pool for each of them
the solution we have is we have a shared
pool a shared port for all the PD beads
okay so how does it work you have the
connection pool which is the universal
connection pull on the cleanser and we
have the shards I mean the the pdb sorry
TD bees here okay and you can see that
those connections are attached to pdb
one on those free are attached to pdb -
there might be idle or there might be
visible physically they are attached to
some database you know some pluggable
database okay so let's say pdb say
customer wants a connection to pdb three
a tenant well we're gonna repurpose one
idle condition here because it's not
doing anything
we use a new service at the database
level you know I think I cannot remember
it's a set service say new come in under
the cover so UCP will use it on the
caller repurpose that connection for
here and then the user will use it
so that's how we can share one single
pool across all the PD beats and you can
do this by using a single single data
source with multiple services or you can
use one data source per service or
pertinent we document this in our
literature it's for time sake Adam had
time to go into the details but we have
code fragment etc c2 we have 11 minutes
away of the top of the hour I mean this
event okay it's synchronous database API
I'll just give you a summary it is a
standard API we are proposing and the
goal here is scalability you know is
scalability because most of the time
when you are accessing data by using
synchronous API so it has daddy DC if
you have 1,000 connections in the
database and you're doing operations all
those connections are blocked they wait
for the database to respond before they
go back to the end-user so what if we
delegate database operations to another
set of threads and they are always busy
because they are doing all the database
operations and the user Fred returned
immediately the user Fred post the work
let's say if I want to speak at high
level I would say the user Fred posts
database operation in EQ and returns
another group of threads that the
implementation provides will pick up the
work operation the task complete the
tasks and depending on what you have
specified in if you look at a completion
stage in in Java Java 8 or Java 8 comes
within a nice feature called completion
completion feature and compression stage
features they so a work
done by this database
Fred's always complete it complete
normally I complete abnormally that's in
exception anyway it is a task
composition and it allows you to do is
synchronous work reactive programming so
you can schedule some tasks do this do
that and under the depending on the
result do this or do that
so you will have to change the way you
code your application because it's no
longer in a procedural sequential so you
can have you can do multiple operations
you can access multiple databases
simultaneously or you can access you can
have one database operation you fire one
database operation on the other side you
get some data from some JSON or some
JavaScript or whatever and you get some
images from some other place and you
compose all those to create your web
page for example so the user fred is not
sitting there idle it's doing something
else and when the database operation
completes maybe it go back to the user
Fred or maybe it goes continue to some
other friend maybe you fire and forget
okay so that's we provide a lot of
scalability and this is our strong
belief if you go here on this blog we
provide more details including the Java
one presentation and also the mailing
list where you can see the community
discussion about the API and you can ask
questions on the mailing list and our
architect will respond so we're
expecting that with this will make I
don't know they scared it but we hope
it's gonna become a new Java standard
it's not very busy it's not an extension
HTTP see it's a completely new API there
are async api's but those are
proprietary so this will be a standard
rockers drift driving it but it's no it
won't be an Oracle proprietary mechanism
so that's one more sake scalability
feature to consider okay I mean that's I
have we have this white paper that you
can look at we have this so 18c is in
reality 12 - or - you know it's a naming
gimmick so when we say what is new in 12
to release -
most of this stuff are already into have
to release to the dot 1.0 on the 18th is
12 to 0 2 so we have few features but
it's not like it completely brand new
releases I am saying that to you so you
don't listen at those white people are
not obsolete they also have bunch of
features which are in 18 see so we have
our cloud taper our what's new paper and
you have this white paper for the former
scalability at the transit so that's all
we have to share with you but we would
really want to hear from you guys so if
you have any question on everything you
have discussed please speak up now
any more anything you want to add
nothing go ah see we still have six
minutes if you people want to ask
anything on the chat this is the time
okay we assume that you are satisfied
with what we shared with you we're gonna
have another session next month on high
availability anything you want to hear
you want to ask about high availability
I think they might April 14 again yes
any last minute question before we close
the call okay remember ask
Tommy's initiative that we want to get
closer to the developers and we will run
the event every month and we hope people
will join on ask question we will use
the opportunity to share some
information with you so thank you very
much have a good day bye</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>