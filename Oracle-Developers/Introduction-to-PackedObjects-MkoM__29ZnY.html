<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Introduction to PackedObjects | Coder Coacher - Coaching Coders</title><meta content="Introduction to PackedObjects - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Introduction to PackedObjects</b></h2><h5 class="post__date">2015-06-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/MkoM__29ZnY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">let me start you know let me start by
saying that although you know there's an
IBM label here I'm an IBM employee this
is IBM technology that's being worked on
right now this under no circumstance
should be viewed as an IBM special a lot
of what the JCP does now is it says look
don't come with an idea come with a
solution and then we'll worry about
making it a solution in reality and so
this is technology that you know we and
other people are working on there are
different flavors out there this just
happens to be ours so something along
these lines is coming not necessarily
this but this is our interpretation of
it in the end we don't view it as some
IBM special ok ultimately we'd like to
submit this back to OpenJDK and make it
ubiquitous ok this is not something like
you know come to IBM for this it's like
no no we want to give this back to the
communities but right now it's a work in
progress it's rough around the edges but
this is the direction we're headed the
other thing to note about this talk is
that it's a bit nuts and bolts ok this
is probably a bit deeper than the
average javaone talk so again I remind
you in case you're lost for those of you
put your hand up it is 830 in the
morning sit back relax let me take you
for a ride you know we're only trapped
here for an hour it's ok besides if you
try to leave I can pretty much reach out
and grab the person the back of the room
from here it's so small so don't do it
and you know the very least i'll be
entertaining I hope so title lawyers
nerd for the next hour I have a fancy
title that's a Michael you want stick
your hand up there so Michaels my
equivalent at Oracle we both share this
title on opposite sides it means
absolutely nothing the reality is is
that I'm really responsible for core vm
architecture at IBM so that's you know
making a lot of decisions about the how
and and in a lot of ways what as well
what we do I've been doing this game for
18 years that does not make me an expert
at all in anything but what does it does
do as it says ok I've actually been
through a number of wars and battles so
I have some stories to tell all right
doesn't necessarily make me right I can
just kind of tell you things this is how
you can hit me up if you have questions
and I don't know if the exhibition floor
is still open today or not but if it is
there's our booth come see it it's just
basically developers hanging out and you
can come ask them anything including
stuff about packed objects or any other
technology so non marketing types
strictly
developers all right what are we trying
to solve here so why why is this comment
about and there's a number of different
ankles and why we decided that this was
something that might have been important
to look at the first one is is that you
know being a guy who's implemented a vm
from the ground up I can just tell you
that Jay and I sucks okay i just i
absolutely hate it it serves a lot of
really great purposes in terms of hiding
garbage collection in laughs and hiding
garbage collection aspects and so on
makes it really easy from the point of
view of dealing with the Java VM from
the native side except that you've got
to write a rapper so if you want to
access some native function in a library
you've got to write your own native
function to get to the actual native
function because there's no direct call
on her face it's slow it's heavy weight
it assumes the worst possible case when
you call out so it has to do a whole
bunch of coordination with the JVM it's
just really not a high performance or
easy-to-use interface particularly when
there's a sea call that you want to make
to some hardware acceleration you know
aspect or something like that your
platform you want to make that call um
the other thing is you know the locality
sides so in a lot of cases you have
situations in Java where you actually
want two fields closed together two
fields far apart and you literally can't
control that what you type in your
source is just not necessarily what you
get the JVM does a whole bunch of
magical things like reordering fields
and it you can't be certain that where
you've got a field in your object is
going to be where you know you
physically expected other people have
recognized this this is not a unique
problem I mean Jeff 142 is a perfect
example of trying to get you know
contended fields and labeling things
within your jvm to give the vm hints on
what to do so you know this isn't unique
to us other people want to try to do
that and you know on top of that if you
look at stuff like Java and how its
organized I mean Java is memory right
and this is a problem right it it's such
a fundamental statement but it the fact
that everything in Java really
constitutes memory and pointer traveling
and so on we'll get into that in a bit
really causes you problems and we wanted
ways to basically optimize not say look
how do you group clumps of data together
without actually destroying your object
oriented pneus of any of your design so
we had all these different problem oh
yeah legacy
integration I mean in some cases you
know we you know I IBM guy I deal with
z/os mainframes and so on you've got
other aspects like hardware acceleration
and devices that you can plug in
analytics and so on being able to
interface these things and this goes
back to the J and I side really really
difficult okay so we got all these
different problems and they sorta seem
unrelated but it actually turned out
that what we're going to talk about you
know in the coming charts it actually
all comes down to one pretty simple
solution that ends up hitting all of
these points now again this gets a bit
nuts and bolts but like I said just kind
of sit back relax and enjoy the fun so
let's get let's get some pictures right
enough words I hate words let's get some
pictures to kind of really illustrate it
native data access right if you try to
do this it's really cumbersome and
annoying in Java right if I have an
array of int as a tight I just want to
be able to point to it right out from
Java to the native space hey I don't
want have to go through J and all right
I want to be doing the things like
direct byte buffers or or having to to
wrangle unsafe right and stuff like that
I just wanna be able to say look I know
I've got an integer array out here and
use it now there are potentially safety
issues out there right with having to
access that data you don't want to fall
off the end of a point or cause a crash
this is not so you have to know what
you're doing but I don't want it to look
like anything else other than natural
Java code right I just want to say hey
get that pointer yes it's unmanaged it's
not java and fetch slots off of it so to
want to fight the native interface I
want to just you know have it be a
natural occurrence this the other thing
is that let's go back to you know very
simple data structure like say some
hashing data structure this you know is
typically how you might implement it you
got like your hash container object
underneath you got an array and you know
each array has entries with your key and
value pair sort of a very simple
straightforward approach and okay you
look at this and you think yeah okay
this is pretty natural Java but I know
as an internal vm guy and looking at
this from a performance perspective i
think god this drives me nuts and and
you can probably guess why there's a
number of points remember Giada is
memory and that's the problem so the
first thing is that look there's all
this wasted space in your heat right
look at all these headers here that you
don't really need like you know what
this is you know you really don't need
to know yeah
this is an entry yes this is an array
it's always going to be an array it's
always going to be an entry the keys and
values on all likelihood are going to
always be the same things the same types
right these are just getting in the way
this is causing garbage collections
earlier they need to actually like the
important data is the white not the gray
for your purposes so this gets in the
way right and I'm an x GC guys so trust
me right away I'm like ooh the other
thing is that if you actually go to
access this data you end up with some
real problems the performance problems
because you can't guarantee that all of
this data is together I've drawn this
nicely on one chart but one GC and these
objects are probably scattered to the
four winds right on the heap you have no
idea where they are so every time you
have to access a piece of data you have
to chase a pointer all right this is a
performance hit you don't know where
that memory is another performance it
has to be brought into your cash cpu and
so on and all these things that you're
not supposed to care about as a java
developer is impacting you all the time
all right and finally you've got lots of
you know data and this really goes back
to know caching and so on and locality
is you've got all this important data
that you're accessing except that it's
not all together okay that goes back to
the point of chasing right I mean you
really like that all this data to be
together believe me far more performant
on any CPU if you actually have your
data gathered together okay so these are
the kinds of things that were really you
know you you there's performance always
being left on the table and in some
cases you know high frequency access
data structures could really help you
here so finally the third one is you
know we talked about native access we
talked about objects and organization
and so on internally the last thing
again this goes back to Jeff 142 for
example that you know precursor to that
there's other solutions along these
lines sometimes you have you know giant
objects and I see this all the time but
with two of the fields being really high
frequency access fields could be reads
or writes it doesn't matter but one
thread really wants to talk to two
fields you want to guarantee that those
fields are together and not extremely
far apart as a matter what you type in
your source the vm is going to
reorganize things and possibly put them
in different locations you have no
control over that really as a jabber
programmer right but it affects your
performance wouldn't it be great if you
say look I've got lots of data here but
most of it's pretty stale I just want
these two things side by side in the
same cache line nice and performant
let's go right free performance just by
saying what these two fields should be
SAT together okay so that's sort of
established some goals for us all right
we got again all over the map native
data access making sure things are close
together and being able to keep fields
in a nice ordered representation getting
what I asked for you know we kind of
want something that looks a lot like sea
right i mean if you look at this data
structure here and this is expressed in
c struct address truck header and
contains two embedded address types and
so on and this is what you get and see
right and every seat programmer knows
and loves this right they see this i go
yep there's no headers there's no point
or chasing to get to those things or
anything right it's all together it's
all compact nice nice short sweet data
representation yes there's a bit of
padding there but whatever right it's
nice and short nice and small fits all
right less gc's less wasted space etc
etc this is what we'd like to get to and
this is really what packed objects is
alright alright so let's build things
it's actually construct it so again nuts
and bolts II just enjoy it so this is
what a regular if I had a point object X
and Y this is what it would look like in
Java more or less right you got an
object header you got x and y point
we're going to do really simple examples
but you can kind of understand how this
sort of piles on a little bit and we'll
build things more and more but let's
start with a point nice and simple right
x and y you got a header so it typically
looks a pact point under the covers
right is going to look a little bit
different and this is not something that
necessarily is visible to the
application developer but it's important
to understand the concepts to understand
how this actually works so what we're
going to get instead is actually a
header that consists of two extra fields
okay for a pact point type and I'll
explain how to express this syntax and
so on but getting this concept down is
important there's two extra fields
target and offset now this is kind of
counterintuitive because I just said
look I'd like to get rid of headers
shrink them locality make things more
performant and efficient and so on and
I've gone and added two fields okay bear
with me a moment well we'll get there
okay so I've kind of gone backwards a
bit but it's really a step back it's
like it's like dancing right you take
myself out who steps forward right you
just kind of you know just go with me on
this these fields typically point to
this so a target will point to an object
the target says where is my data what
object contains my data alright in this
particular case I point to myself the
offset says we're in the object is the
data so I've got my target great this is
where my data actually is offset here's
where my data is all right we'll pile on
this very simple concept to start point
to the object with your data point to
the get the offset where your data is
will build on this one okay step one
let's take a slightly more complicated
example like a line that consists of two
points right in Java this is what it
would look like in memory right a point
you have to sorry online you have two
points start and end s + E and they
point to two points this is what it
would look like in Java here's what a
pact line would look like
okay so a pact line would actually say
look I know where my line data is points
to itself it says my line data offset
into the myself is right here okay and
you can see here that we actually have
both pack point s impact point E
embedded in the object right so when we
express it we've gotten rid of two
headers and some point you're chasing
now this is what it's going to look like
under the covers but will actually start
to use this and see what it looks like
from a Java perspective so you've got
these two objects to point
representations embedded directly in
your object even though you've actually
expressed it a lot like how we do a line
with two points here we'll get into the
syntax a little bit this actually in
fact this next chart has it this is what
the syntax would look like this looks a
lot like this is Java right this is Java
with just a few annotations now I'm not
going to tell you that this is the
hardcore concrete end of story syntax
but this is the one that we go with
right now it looks a lot like natural
Java right you see it you call you have
a point right you define x and y you
annotate it was packed we call the pack
point here to really differentiate and
beneath it you have a natural
representation of the line which is
getting too packed points but under the
covers the vm actually says no no i'm
not going to create three objects for
this i'm actually going to take the
points because i know they're packed and
embed them right into the line okay
saving space saving time no point yes
yes it does and so we that's a good
question so the question is do we it
extends packed object so couldn't figure
that one out already and not use the
annotation absolutely true at this point
we actually didn't have the
functionality working for that so it
wasn't you know saying okay I'm
underneath this hierarchy but absolutely
absolutely that's an excellent point
that I didn't cover is that all of this
is being done underneath the natural
hierarchy just called packed object ok
so we insist that all pack types must be
under packed object but their regular
types to your question well thank you
you can tell it's still early in the
morning caffeine hasn't quite kicked in
ok so we have these embedded types but
how do I actually access one of the
points ok so this is kind of weird right
because now we've got these embedded
things and great we've gotten rid of the
header and so on and I could have typed
this normally like just by embedding the
you know index you know a sin 2x e and
so on and embedded the man and said fine
I'll just do myself but what if you
actually wanted to treat the points as
actual points if I went and accessed it
well when you go and access say point E
here's what we actually do under the
covers we say yeah here's the object
here's here's here's the end point for
you and we say we actually create a pact
type that has no body but its target
points to the line and its offset for
its data points to where he is okay so
this is actually really interesting
because now what we've said is we said
okay I'm not going to actually recreate
all this extra data and copy it out and
so on I'm just going to create some you
know derived representation to point to
the actual data alright this gets really
interesting because in a lot of cases
when you access things like points it
tends to be fairly short term you don't
actually really hold on to these things
for very long the jit and so on can
actually optimize this to the point that
you don't even actually instantiate this
object it just looks like you do from
your Java code all right but we've been
able to instantiate this or create this
object representation pointing back to
the data without having to instantiate
the body okay so we keep a compact
representation until you actually want
to go after the data and then we will
give you
direct pointers to that data so you
don't have a case of say fetching that
point modifying x and y and it not
actually modifying the pact line you're
actually modifying the direct data if i
said dot x equals something you would
actually go directly to the source data
yes
great question so the question is is
that can I actually do that with a pack
line can actually do things off heap and
so on and the answer short answer is yes
longer answer is please wait a few
slides and will I will elaborate great
question thank you falling into my
writing my trap perfect gotcha so let's
take this a step further not really
answering your question but another
thing to think about and this actually
is where it starts to really show it's
you know shine through is when you
actually have a giant array of types
okay that you actually want to access
this is where the cost the header costs
totally gets amortized you know or
thrown away completely right because
normally if you had an array of points
you would have a giant array points to
object or point and it would point to
each individual object you would have
headers all these points would be all
over the place GC tries to keep them
together but doesn't always succeed
whereas in this case if you actually
have an array of packed points they
really are just X Y and and and when I
say you know at zero at one at two I get
the appropriate one please give me the
point I Drive a pact point say here you
go and from a Java developers
perspective you don't care where the
data is or you will shortly as I'll show
you but what you do care about is the
fact that you've kept things nice small
compact together localized and quick to
access and you know things like if I'm
just accessing a point I'm saying okay
give me that gimme point fifty and I
just want to grab the x and y and add
them together to square them do
something cool with it and then throw it
away I guarantee you any competent chip
this doesn't require a lot of work will
not even bother to instantiate it your
java code will think it has and operate
as if it has but it won't okay and this
is huge right you've got less pressure
on the heap and you can access your data
naturally there's no magic here except
underneath at the vm level yeah
why can't I do that today
so that's a good question so the
question is why can't you do that today
the we'll get into some of the
challenges as to why that would be a
problem I think the simplest one is that
behavior does in fact change a little
bit so when you instantiate when you
actually do get a pact when you get a
point and pull it out say fine I'm you
know somebody's accessed it I want to
pull it out and use it what do you do
right you need some way to say if
somebody goes and modifies the x and y
of the point you need some way to push
that back okay so ultimately regardless
of whether you pick one solution or the
other implicitly you're going to have to
have some mechanism to push back we
would rather in this case say look we're
going to call this out explicitly you've
decided to go down this route we will do
that but yes there's there's technol you
know you could you could believe
technology to say look we will do that
implicitly but i will show you examples
where that actually changes the meaning
of the language a little bit and you
want that called out explicitly okay
right because it's much like how say
lambdas and and every you know every
language change that goes on changes
things a bit so does this okay short
answer long answer later if you if you
still want okay your question natives so
you can sort of see where this is headed
right I want to access for some reason
to have a point data out native space
okay so off the jab a heap and actually
want to point to it from Java but I
don't really want Java to know you know
to have to really explicitly call it out
or anything like that I don't have to do
anything differently I want the type to
be the same I don't want a pact point
native type or something like class you
know I want them both to be the same
thing right I don't want to deal with no
abstract classes or something i want one
type to do both so how would I access
this native data out there right simple
enough same idea okay you've got your
pack point it's got a target in an
offset and what we're going to do in
this case risk was we're going to say
the target is nothing we don't have an
object to point to so it's actually know
and the offset is a direct point or
right out to native space if you're a
tech you know deep techy guy nerd type
this is excellent for the GC it's
basically zero cost because the GC just
says I need to collect all my objects
and find out what's
and what isn't and it looks at the
target for this point and says nothing
to see here and ignores the offset
because the offset is just a number okay
so GC just says Kok fine you're nothing
move on right there's no special checks
or am I this am I that in my own heap
and my off you all the things that
anybody rights of garbage collector
hates because they slow you down and get
in the way simple stuff okay and this is
how you actually get to the native size
and again a reminder this is the same
type right I can access on heap off heap
I can have that packed point with a body
to it doesn't matter okay it's always
the same type it always looks like the
same thing to you can do lots of
different things with it still looks
like an object that you know and love
you can take these things and just stuff
them into object to race right it's an
object all right remind myself this is
time you go out grab some water okay so
let's build something and see right
let's just go back to this this example
I talked about earlier and this is a bit
of rehashing but it's important to sort
of go through to kind of like really
reiterate what we're getting here so if
I built this you know address and header
thing and see this is what I would get
this is the resulting data you know it's
nice and neat you can see the three
points your nested substructures compact
alignment we get all the things I've
talked about no one love let's build the
same something in Java right syntax is
pretty close right i mean this is kind
of natural this is what you would expect
and this is the result and this is no
surprise right we've talked about this
tons lots of different objects lots of
pointers and it's kind of not what we
want right again headers look how the
alignment having to fetch things etc etc
now what I'm about to show you is not
normally shown at a javelin conference
okay i will show you some assembly
language on the next page do not panic
you do not need to have to read this the
whole point here is to be able to say
here's what you get in the natural java
order of things and here's what you'll
get with packed objects the result being
pretty close to the same thing so i
apologize if you're offended up front if
you're not come talk to me later it
doesn't you know either way I you know
somebody said you really shouldn't do
that here and I said
not you know it's eight-thirty nobody's
gonna geez I can I'm sitting right here
I can barely see the charts I'm still
squinting so anyways all right why does
it look like under the covers right so
if i went for header and i went you know
dot desk to get the address and then i
went and fetched the first bite of that
no address within the sub-object and i
checked to see whether it was 192 you
know something that you might actually
do this is what the byte codes look like
all right now it's pretty
straightforward if you know how to read
by code system that's fine but if you
look at the JIT code and this isn't
super optimized but it gives you a
fairly straight forward view on things
this is what would end up happening now
this isn't terrible this is pretty
natural Java code the thing to note if
you you know you can read assembly
language here is there's a lot of in
directions off of registers that's what
the square brackets around ebx is those
are the pointer chasing moments okay
sucks right on Canadian sucks so this is
the kind of thing that you want to get
rid of but the codes pretty compact it's
pretty small it you know it's it's all
right there's nothing wrong with it's
not like we have to do crazy things for
it this is what you'd probably get or
some some version of it what if we did
this impact objects now again we got
some syntax here not suggesting this is
the final version in fact in some cases
it's a lot rougher than what it what I'm
talking about here we have a lot of
helper classes and so on because we're
still kind of fighting that but if we
represented this again as packed objects
with you know packed bites and so on and
embedding these types of things this is
what it would look like on the heap
again much better kind of what we want
right close together no pointer chasing
so on again pretty clean code pretty
clean-looking code and a nice nice
representation the byte codes are
identical the resulting by Cozart
identical the vm is responsible for
figuring a whole bunch of stuff out but
that's a good thing okay you don't want
to have to be thinking about this and I
knew you know different a different
compiler you want the syntax look the
same you want the results to look the
same you want everything to be pretty
close underneath the covers though the
assembly language is slightly different
but it's pretty darn close and pretty
darn good and so what I'm saying here is
that you know the cost of packed objects
underneath the covers I mean it sounds
complicated the whole bunch of extra
steps and so on the whole point of
showing you this is to say actually no
we can do a pretty good job this is
pretty much on optimized code to we can
do a pretty darn good job under the
covers of getting the same thing so from
an instruction point it's not like I've
saved you a bunch of memory but now
you're running 10 X the code no I've
saved you a bunch of memory I've helped
you localize things have helped things
be really easy to use and it's pretty
much the same cost in terms of code okay
I think it's one extra instruction here
but there's a lot less pointer chasing
going through it's a lot of in
directions through so all right yeah no
no that's that's that's not java syntax
right now that's just a a here's a pact
type you know and here's how we
represent we want you know four slots on
the heap sorry within that object for
the for the debris in the road again
that's that's just a you know I'm so
sorry the question is is that the double
brackets is this you know correct and
the answer is we haven't decided yet
right it's like we wanted specially on
these charts I wanted some way to really
you know call it look I'm doing
something different ultimately what I
want to look more like job and just do
bracket possibly okay but that's really
for a specification group to kind of
hammer out really right some days I wake
up and I think yeah other days I wake up
and go what you know it's like no this
is complete absolutely and so the usage
of this makes it non standard Java yes
and as I start to show you other things
you can realize how non-standard this
really gets so and you know anything I
say here that sounds critical is in fact
look you know we're making some
interesting changes here to enable some
stuff but you know the keywords we're
making changes here right so but we want
to be as natural as possible but then
how do you actually kind of fit it you
know how do you feed it back in but how
do you actually call it the differences
because you don't want if it looks too
much like Jabba like too much like Java
you can make mistakes and believe things
are happening that aren't and so we'll
see that kind of with again with some
other examples but you just got to be
careful and you know we're not sure you
know again that's why pushed to the
community specification group I'm not a
language guy specifically like you know
I just you know
I type it as I see it kind of thing but
other people have the better feel for
these types of things the Brian gets is
of the world 10 you know have no they
have better opinions of these right than
I do I freely admit that and we have
discussions with Brian about this all
the time so yeah that's important note
to we do talk to Oracle about this
fairly pre often actually okay so let's
take that same thing and say well how do
we implement this from a native access
point of view yeah we got this on heap
representation that's great compact we
talked about this we said look I want
this to be fairly natural and I want to
be able to say look I've got an object I
want to be able to point out to my
address header thing that's got you know
the address import and so on right how
do I actually implement this normally
what does it normally look in Java but
what does it look like normally in Java
so the J&amp;amp;I implementation and I've
mashed together at you know kind of
squint a little bit it's not really
intended to read the code as much as get
a feel for it there's actually the top
part is Java the bottom part is actually
c code and again this is one of these
problems with J&amp;amp;I right is that you need
to write both ends before you can get
anywhere the key point here is that of
course you know you stash pointers with
long pointers is like the standard trick
of like how do I hide a pointer in Java
there's no void star type in Java so
unfortunately many of us would argue
it's bit of an oversight but you know
stashing these things this is the usual
trick and the J and I costs for this
tend to be high right you want this to
be just like look I'm fetching this
value go fetch it one instruction on the
machine not like let's call see and do a
dance and you know ritual sacrifices to
just get out to native code and come
back right believe it or not this is
like extremely expensive right we're
talking on the order of probably
hundreds of instructions just to do this
just a fetch an int or a bite like one
instruction it's okay Jay and I serves
other purposes but hmm right so okay
fine you don't like Jaina I just use
unsafe because modern jets actually do
optimize on safe you can use unsafe but
you know they'll actually figure out
yeah you really mean this instruction so
on look first of all you shouldn't be
here okay unsafe is not documented not
supposed to be using it but everybody
does or sorry anybody who wants to do
this so ignoring that even if you're
like yeah but everybody uses it the
whole you know the big thing here is
that if you look at ya
use these public static final int types
right to get the offsets you're playing
this offset game who wants to keep track
of that right nobody's error-prone it's
ridiculous right you just don't want to
do these types of things direct
bytebuffer implementation yeah okay sure
better than unsafe I guess but you know
you're still fit you're still faced with
playing the indices game all right the
pact object answer and again you know
you'll notice here I got rid of my at
thing like inconsistencies in my own
site I was room somebody remarked
earlier you know why do I have the
annotation and the subclass I could
think I actually that was a cut and
paste error I just cut the annotation
right out when I was slapping the code
down but you can see the nice this looks
like Jabba this is Java this is job you
just type in you compile it and we go
right it's easy you type it you get it
done easy slick you know you're not busy
fighting mechanics underneath and oh
yeah I implement this thing it's got
nice API on the top on the front hand
but underneath it's like a disaster to
implement no simple easy straightforward
no Jay and I native access without any
native code sign me up all right
Oh same thing same thing so we that
what's the difference between a packed
object and one that refers to make
native memory the answer is nothing
other than potentially it has no body so
what we do is we say look it's the same
type but where the data is the key point
here is that it's the same type but
where the data is is irrelevant or
mostly irrelevant to the java developer
right so what I haven't done here is
I've I haven't actually shown how do you
create one so like yeah you got to need
a pointer how do I say look this is a
packed point yeah I the Fulani slices I
don't have this right now we don't
actually have good syntax for that so I
was just steered clear of that the
reality is right now we have actually
kind of like a static factory right now
that just says look gogo build this
ultimately it's just a syntax problem I
don't have a good answer to show you
right now but you know once we figure
that out it's pretty natural right
here's my pointer done deal it's good
question though sharp people catching me
on stuff I tried to hide I was like you
know I won't talk about that because
it's you know don't have a good
syntactic answer yet some would argue we
don't have what and give good ones now
but again it's the mechanics and the
advantages that you can get so let's
talk a bit more we talk about points and
lines like who's going to use this for
points in lines who cares right let's
talk about something a little bit more
real let's use our imagination right you
can't actually build anything cool
without using your imagination a little
bit so let's talk about transferring
some data so you've got like you know
this this this tree of objects sitting
on your heap okay and I actually want to
send it over the wire to some machine
now let's say that over the wire is some
like our DMA transfer okay so it's like
literally like here's my memory I want
to move that memory like with you know
micro second latency over to some other
machine okay I just want to transfer the
data verbatim boom give it that's the
end of it right you want that to be fast
you don't to be paying marshalling costs
and this net you just won't be able to
go this data go all right so what
happens right now when you want to
transfer data in Java pack a mule folks
we're going on a trip right why are
people laughing it's your pain like it's
you know so what happens right you'll do
something like you know there's
different ways to do this right but
you'll Pollack ate an array giant array
then you'll take all the data
you will kind of splash it into the
array this cost I'm going to cause GCS
is on and you take this array and send
over the wire and then you got to unwrap
the whole thing again right and it ain't
like Christmas unwrapping gifts it's
just a pain okay so okay this is
standard way but you know we probably
could do something better so what if
instead we took this kind of hierarchy
of things and we actually said fine
let's just get rid of that unless use
pact right now what's great we've got
all the data lined up end to end right
ready to go it's perfect you've probably
gotten rid of object pointers so it's
even better like it's easier to transfer
right cuz you're not talking about
pointers stuff it's like just here's the
data where you go prim hopefully just
primitive types that's great if you're
moving one but what if you're moving to
right they could be anywhere on the heat
so again now you're like I move here
move there this kind of move like not
quite there yet right so okay
region-based collection region-based
style heaps and so on being able to
carve the heap up this is known
technology this is not an IBM special I
mean pretty much every vendor right now
does something along these lines you
look at the g1 collector from Oracle you
the balance collector from IBM same idea
we know how to divide heaps up and miss
specialized them in terms of things like
Numa and so on be able to say look this
areas for this specific thing ok
sometimes we don't exploit it as much as
we should but these things are actually
natural and very possible in today's
world with very little invention so why
don't we just take the heat and create a
specialized area and say fine when I
actually create these typed I know
they're all the same size would be
really easy to allocate and manage this
free storage and so on believe me so why
don't I just lay these things end and in
this specialized area and say hey look
this is my our DMA transfer lock the
memory boom send it done that could work
that could work but not quite as
efficient as we could be we look at the
headers there right remember like we
slid gads pack but there's still objects
they still have headers hmm not quite
there last try alright let's try that
again let's lay the data and and in the
specialized area let's used and I've got
the arrows slightly wrong here but again
this is like native pointer style right
then you know nobody's pointing directly
to it let's take the body list packed
types and point to the data in the
specialized area
okay and that way we can actually have
these types floating around in space you
know just like regular objects we can
get rid of the headers in specialized
area and just be able to transfer that
data directly okay so these are kind of
the kind of the weird strange things
that are in fact possible with things
like packed objects things that you
normally don't think about on the
surface and in fact because these are
look like and feel like natural jab
objects if you're using these things you
don't care right ultimately you don't
care where the data is it doesn't matter
if for every object you allocate I put
one field here one field there in one
field over here as long as you can just
treat it like a java object right so
this is what we're talking about in the
end this is just going to where the data
is doesn't matter but because we put the
data in special place and organize it
certain way under the covers unbeknownst
to you we get excellent seamless results
okay so we're kind of combining both
native representation as well as a non
heap representation here but we can
exploit these things right speed
efficiency still natural Java code all
right that's imagination now reality I'm
just going to quickly whip through this
one we have a research lab in Zurich
that actually kind of took a look at
these things and said well look I want
to actually do some RPC stuff some low
latency RPC zero copy and so on but what
we're going to do is instead of you know
we're going to compare just kind of a
natural approach so saying look here's
some data I want to move this across the
wire via smart DMA and instead use
packed objects and see what we can do so
really quickly it's kind of the same
idea right you've got a Java heap and
some off heap stuff so they actually
went straight to an off you prep risen
tation the pact object you have like
basically the header on heap it's really
a byte buffer but they push that off
heap to do native and they just say look
my data is off heap in this case for the
pact object version and when they do the
rtm a transfer they just say well look
that native space transfer that right
away okay so it fairly simple and that
will move into an avi presentation on
the other side for packed object so it's
literally like you know bite copy from
this machine to that machine using our
GMA should be like that right no
marshalling costs because it's basically
direct native to direct native impact
objects handle the access
so calling it out differently this is
how you would traditionally do it lots
of hops don't bother reading everything
but there's a lot of marshaling costs
you have to copy things out to data
buffers and so on then you actually
start to move you know move things
across you go to sockit everything a lot
of stuff goes through down to the
colonel back and getting it you know
moving the data back and forth
heavyweight cost with the pact object
representation it's basically like look
the data is already out there in the
native space I'm just accessing it
normally I've written it out using
natural Java you know syntax and so on
but it's gone out to the native space
directly I just say hey look the data is
there to rents for it right where you go
and we're using J verbs which is
basically if you know infiniband and so
on verbs you know talking through RDMA j
burbs is just a Java interface to be
able to express this type of
functionality so really quickly here's
the relative latency in terms of what
how it worked with j verbs versus niño
there's a combination of performance the
key point here that were saying is that
look we get you get rid of a lot of the
marshalling costs and the J'naii costs
okay that's really the end result is
that the the the the time taken the
latent significantly lower because
you've actually just reduced your path
length completely right it's you know
you've already done all the work but it
still looks like Java code very simply
and there's nothing really overly
complicated about these things we're
transferring native types not objects
simple simple stuff right or base types
i should say pardon me in float along
stuff like that really quickly again so
we went from just transferring an object
to transferring arrays again as you
increase the size of the array you
expect this to cost more especially
because the copying traditional methods
would you know the bigger the array the
more the copying you have to do in this
particular case the copy doesn't happen
you're already operating in native space
so significantly faster of that I can't
remember you know unfortunately when you
start to draw these diagrams little boy
remember the second chart with the
lawyers yeah they get twitchy about
numbers great because it acts like a
commitment so
so but this is like Millicent
milliseconds really this is this is like
in terms of milliseconds and so on this
is not we're not talking seconds or
minutes here or anything like that this
is like literally like you know like
looping like mad kind of thing to move
this data around so it's not a lot of
time yeah Gil hi yep no unfortunately I
don't so the question is is that do I
have kind of an intermediate version
with direct byte buffers and so on using
that and measuring what the cost is in
terms of moving the data in it that way
I do not on this one unfortunately so
it's a good question it's good data
probably should get it but I don't have
that right now you know similarly again
this is you know just examples of things
you can do don't don't don't take this
as gospel as much as here's kind of the
possibilities and one of the ones that
you can do is actually you know
on-demand access so if we start passing
a cash and say look just go get the
objects as I need them and you do kind
of similar fat things as what we just
talked about except that we'll just move
the data when we need to this is a
really nice relative to actually trying
to copy everything all at once or
copying you giant arrays of data and so
on and so you end up with kind of a
different you know it's pretty bogus
example to be honest with you but you
can actually see what you can do because
you literally have to move no data right
it's like look I just know that I have
like an array of you know a thousand
slots or something like that right and
it's like okay I will just get the data
as I need it and if you start to kind of
you know get you don't access all the
data in your access only what you need
and so on it gets really easy to start
to really cut the sort of stuff down
right to size and say look I only go
after the things I need and it because
there's less copying now again is
significantly less you know you can
really derive benefits from that so do
you know what point you're being is that
you're still going out to the native
space in a very natural fashion and you
can derive really nice wins from that
all right now here's where we get into
things where it's like yeah that's nice
you talk about it being Java but you
know where
problems show up right and you know III
just said problems and that's that's
kind of the wrong word really this is
going to be more like okay look there
are things that are now different and we
have to think about them so this
shouldn't prevent you from doing
anything like this this is more okay you
have to think about these things so you
know things that you have to keep in
mind especially as a vm develop you like
well how you know you're typing code
you're like okay how do I go geez how do
I fix that and you know it's almost by
discovery in some cases so the first one
is identity crisis so something like
this can actually happen right if I
actually say please give me the first
point twice from two different things
you might get two different derived
objects especially to native space is
another example but even if this was on
the heap you might actually get two
different thread saying hey give me you
know gimme point start you get two
different derived objects what does
equals equals mean now right if I fetch
that twice and I said equals equals you
would expect that to be true it's not
now maybe right so so you know this is
where things get kind of a little bit
interesting and you start to think more
about the data right it's not really the
object that matters it's the data so
these look a lot I'm very careful to use
the word values in this talk and the
word types in this talk but I'm very
careful not to you though use those two
words side by side okay but really it
starts to turn into something that's a
lot more along the value approach all
right because of the identity you can
tell from the from the title of this one
where we're going how do you synchronize
right now why would you want to
synchronize a point but you know I think
no pun intended you should take my point
on what this what's happening here how
do you synchronize right again this
looks a lot more like you know you're
talking about the data here not about
the header it's really more about the
values and what you're seeing so
synchronization actually doesn't make
sense in these case right so now this
changes things it's like oh well it's
not really an object anymore you start
to talk a little bit more about well you
can't really synchronize on these things
hmm okay maybe that's not important
right maybe we're talking about a
different class of problem here further
on that finalization how does that work
right how when you what if what if these
things have final
what does that mean right or what if you
tried to give it that great so I don't
refer to packed line anymore nobody
refers to that but I'm still holding on
to the pact point which is kind of
referring to the pact wine should that
thing be finalized should pack line be
finalized its not being referred to
anymore I'd say no but you know it might
not be totally apparent to somebody
writing code or even looking at the
source right hmm another interesting one
what about the other point that's not
being referred to at all and probably
can't even be gotten to at this point
could you find why's that should you
mm-hmm good question right and again I
mean you know it gets really hard to
talk about these things right it's like
you know you know if you know if if you
had point ears to native space and you
said okay but I want to you know
finalize concerning this data like if
the pact line had a finalizar I'm not
saying about you know does the native
code run as five errors doesn't have one
but how do you know when nobody's
referring to the native data right it's
off heap it's not a managed pointer
right so how do you even find like what
if you know I got rid of a packed mine
do you finalize that well somebody else
might be referring to it so finalization
doesn't make sense again it's more about
the data it's not you know we talked
about it looking like natural objects
but mmm there there we kind of take away
a lot of the capabilities it's
finalization you shouldn't be using it
anyways but you know right so um nested
data structures are interesting and you
know the top line the syntax is really
interesting when you assign if I sign a
pact point to a pact line I say look at
the start point here's my here's your
values who's your ex why you might want
to be able to do that but it's not the
same thing anymore right you're not
pointing to that pact point you're
actually literally going to take the
values and copy them in right so now
this isn't the same right if I have a
pact point I say look here assign you
know in Java it would be like ah well
now I point to that object in this
particular case you don't really you
just take the values and stuff them in
there and say well there you go here's
your x and y it's not the same now if I
modify a pact point I'm not modifying
the pact line which seems kind of
strange to Java developers so you know
when you would do assignment do you want
something slightly different like this
is like the i'm no xml talker that's a
small talk syntax for assignment and i'm
not suggesting this is what we should do
but if you're going to do assignment you
might want to actually let people know
it's a little bit different than what it
is right now right because it's not
operating in the same fashion so again
things that you sort of have to look at
and okay you know this these are the
changes that you accept but they need to
be expressed and visible to the end user
this one's a little bit weirder
constructors and so on how do you
actually get say the points s an e below
they're actually instantiated with
proper values it's not really a natural
thing right now right you kind of have
these you know do you have to end up
having to butcher your code with things
like in it and so on and having to go
well you know whatever you values you
got we're going to give you something
else instead you know still trying to
work that one out okay but again it's
sort of like i said its natural java but
things are slightly different go back to
that for someone arum taking it to the
next level which sounds like up but I'm
talking more and more about native
representations is really taking to the
next level further down other gotchas
other things that kind of hit you when
you start to think about this right okay
we talked about embedded types and so on
but in the native space what if you had
like a binary tree representation right
it's not all embedded type you can't do
it right because it's could be an
infinite depth right you can't just keep
naturally embedded betting things
there's actually pointers so what
happens when you have an actual point
what does that actually mean like when I
say a binary tree no dot right it isn't
just go to the offset of that thing it's
actually literally follow the pointer
okay this is kind of you know you have
to think about these things now how do
you represent that how do you talk about
this further you know for the more
astute are you talking about 32-bit or
64-bit right just you know it depends
what who depends what platform you've
loaded your code on which could actually
change the size and representation of
your on heap story if you have both
right if you have a field that's like
normally it's just a pointer but what is
it you know does that change things is
that important to you does that you know
where your data actually is are you know
does the size actually matter to you it
might so the simple answer you know you
go back to annotations really it's let's
just take you know something we'll just
annotate with
like a native pointer and say look the
way you follow this is slightly
different you have to actually you don't
go through the offset aspect and find
some a better thing you actually have to
follow the pointer and create a new
drive guide following the pointer you
have two things do things like with
bytecodes get get filled and put field
to recognize this again this is internal
it's a matter of how do you surface it
to the Java user to the java application
developer making it simple as possible
and then push all the complexity down to
have the vm handle it but handle it in a
way that seems natural and correct so
again going back to this if you say you
know dot right you know to get that
thing you'd actually get you know a new
thing that knows how to follow the
pointer and not go internal but how to
actually just take that and to treat it
as a true pointer okay so these things
actually matter if you're going to do
native Native side stuff and you just
need some way to be able to represent it
right right now it's certain you know
through annotations not you know there
could be other ways to do things ok so
we're approaching the end folks so
hopefully I haven't warned you
completely out alignments another one if
I said here look this is how I'm going
to express this right if I these two
embedded types for me this is how I
would expect the body to look that's
what I'd want but not everybody wants
this right another way to think about
this is to say look you know it's just a
short so I should be able to really pack
it you called it packed right shouldn't
it be packed and get rid of all that you
know isn't that what you should do I
would think the first one is better
other people might actually want the
second one it might actually make sense
so how do you actually represent that
again you go back to our you want a
32-bit or 64-bit platform I you know
these these things are like well okay
how do you represent that you don't want
to be doing something like having some
padding alignment field their that's
potentially optional depending on what
size a pointer you are in your system
right like you know you can just imagine
you a first year computer science
student you know hacking and this would
be their solution right I'll just throw
some padding in there and away you go
right but you don't really want that
right you you in some cases want a
platform level alignment to say look
please make this one online so it's sort
of a bit weird here because I've said
that look the natural one for me would
be to naturally align things and then
potentially pack it so it's a question
of you know do we want to force people
to say
a line when they want alignment and make
the default truly pact or is it the
other way around but you know these are
the kind of debates we end up having
this the things you have to think about
so it adds to the complexity the the
last one here last one endian so who
read fika whatever backwards rank who
read this way big endian her little
Indian right who had to think about that
in Java no a one twice Tobias wrong guy
okay don't listen to him it's true but
you know outlier yeah it you know who
read that backwards who read that
forwards hmm depends does that actually
matter right when your stuff and bites
down if if you're doing some you know
you're communicating between two
machines and you're just writing
directly to the native buffer to
communicate data you know are you
talking big endian or little endian are
you on one machine that's big ending the
other one this little endian mmm you
know it does it matter do you want to be
able to force and say look this is big
versus little interesting questions all
right that's the end of it whirlwind
tour now you have the the idea of the
internals not an IBM special we're
looking again you know may not be this
this is coming just may not be this
specifically this should give you a
sense of some of the things that were
talking about Gil asked a question he's
had a recent was a blog post kill that
you had about yeah they've got a
different solution going on Martin
Thompson i think is yeah i know that
pointed out Michael and Oracle at the
back I know that their research group
has done something with interfaces to do
more of a just straight to native space
story Christian Wimmer would be that
there's lots of different solutions
there are discussions going on about
this right this is not this isn't like
look here it is this is the answer live
with it it's this is here's our take on
this be interested to see what you think
I know there are disagreements but their
disagreements headed towards a common
goal and that's really the important
thing if you have opinions you know jump
in shoot a male we're always interested
to talk about it like I pointed out here
we fight a lot of things internally even
in terms of struggling what the right
answer is but you know from a community
point of view weed
make a natural adoption not to be the
you know the Azula specialty Oracle
special the IBM special we just want to
be the OpenJDK answer that everybody
knows and loves okay on that note I am
done you are free to go thank you for
your time yeah so the question is sort
of a related question back there which
is look why I you know I maybe if I can
rephrase your question to say look why
aren't you just using the compiler to be
smart and do the right thing when
appropriate right it's like look we
should pack these types here I think you
know I'm going to say a couple of things
are we still recording could we not
are we done because I will answer this
but can ever be done okay excellent can
we take this outside okay so if anybody
wants to hear my answer is fine and I'm
sure I'm going to get arguments from
from these guys these two guys here but
well so right now you know jab eights
locked and loaded really right that's
not happening but you know personally my
targets java nine so we do I should
point out you know we have a beta
release already it is extremely rough
around the edges the syntax I've
described just does not exist you have
to use a lot of helpers and so on but
the functionalities there you can use it
you know really you know feedback is
important so if you if you are
interested in that and you have your own
comments or views we want to hear them
to be honest with you absolutely device
yes it does sorry so a question is is
that does pack object.extend
java.lang.object the answer is it does
now at one point we actually you know
we're x-small talker type so we're used
to things not being at the root of the
hierarchy on occasion and so we got the
bright idea that that was the right
thing to do and then it just destroys
the capability of doing it you face a
boxing nightmare right you'd rather just
be able to stuff it in as in a say a
generic object slot if you will and you
know be able to kind of you know up cast
type thing and just say look it's an
object and stick it because they're just
objects we want them to at least look
like objects mostly so the whole idea of
putting that in a separate hierarchy
where you can't stick it into an object
array or an object slot disaster it's a
boxing unboxing nightmare so we quickly
scrap that
so right now the implement so don't
quote me on this right now the answer is
no the more important question is can
you cast between the subclasses and
super classes if you could and so the
answer is no because in particular if
you have say packed array right it's the
type you can't start saying a lot said
you know it the size is different right
kind of thing you look at you whether we
want to eventually take that say yeah
you can go you know up but can you you
know do you want to try to cast back
down it's it's a bit of a nightmare
right now we don't allow their
effectively final I believe in the
current implementation but that's where
we're leaning right now but that could
change again you know if people feel
strongly one way or the other we could
you know work something out sure I what
somebody actually had the time what time
is it I'm happy to sit here all day
folks it's this fine with me okay sure
so I want to make let's see how the cash
I've got thousand customers that was
support but only if you know a hundred
of her activated I want to lay out large
memory cache and applying it on pages
such as this stuff to get page now can
operate me java plus virtual memory
isn't that yes yes so so how does this
play with virtual memory and the ants so
you know in terms of alignment making
sure that things get page they would
organizing your data in such a way that
I know this is not commonly used move it
out and so on you know final you'll
gather that together so it's easily
paged out absolutely but I would say
that that is very clearly your problem
we're putting the power to do that in
your hands but we're not the ones that
are going to detect that maybe in some
future you know higher technology vm we
might be able to get to that point but
right now what we're saying is okay
great you want to move your data and put
it in just you know walled off areas off
heap to you know page align it and so on
absolutely but that's your problem
I just want to make sure it's like no
you never want to do that no no no I
know so so I you know in memory object
grids you know key value pairs and so on
this is a very this can be a very
interesting story because you can do on
heat off keep representation move data
off your heap if you want to native
store then you can put it into hot
versus cold areas then move it out
appropriately to storage and again
you're using the same type no matter
what because on heat off heap it doesn't
matter right natural syntax that's the
kind of thing that we're certainly
looking at in terms of application
internally so right to left yeah you
know
yeah okay so so you know swig
integration and so on is the quote the
answer is not yet right we're still this
believe it or not this is still fairly
early days we've been at this for some
period of time but the number of starts
and restarts that we've had has been
there's been a few iterations on this
kind of thing so we're not quite there
yet but well you know look uh you know
fundamentally this is just a one-step
building block moving forward so in
terms of working with other technologies
aspects and so on yeah absolutely but I
mean we're still this is just a kind of
a core building block right now so yes
but
right so can we change we talked about
hot fields getting them aligned is that
possible for JVM to do on the fly
basically the answer is yes it is
possible there's potentially a very high
cost associated with that I would maybe
look at it I think the more obvious
first step is to say look you know you
have your run your if you're going to
stand she ate lots of JVMs do the you
know runtime profiling gather that right
stick it into a cache you run your
second instance of the vm that's going
to pick up the data and go this is what
i really should have done right and go
from there the the extension is then to
actually say okay well can the vm
runtime actually note the modifications
to the class to say look i'm going to
move these fields you have to change all
the instances that's a significantly
harder problem in terms of just
performance it's not a technically hard
problem it's just a you know getting it
done problem really so that one
potentially less interesting but runtime
profiling to basically guide your next
startup configuration significantly
possible i mean that's that's old
compiler technology that's been around
for decades kind of thing so same idea
for heap right yeah sorry I can't hear
oh yeah yeah mm-hmm okay yeah so if
that's a capability that people you know
feels important than yes that so can I
ask for memory to be locked do you start
you mean from paging in paging a point
of view so that's your problem is the
answer right really simply is yeah you
can do what you like it's your memory
right but right now are we looking to
surface that from a job of perspective
like are we looking to surface like the
actual say you know the properties of
the memory you know is it memory mapped
to a file this that and the other we're
that's not what we're after right now
there's certainly we were not opposed to
that but that's not what this is right
at this stage the answer really is look
you it's your memory do what you want
with it really thanks folks appreciate
it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>