<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Using JavaScript/HTML5 Rich Clients with Java EE 7 | Coder Coacher - Coaching Coders</title><meta content="Using JavaScript/HTML5 Rich Clients with Java EE 7 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Using JavaScript/HTML5 Rich Clients with Java EE 7</b></h2><h5 class="post__date">2017-08-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/BkD91ViCWKI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright folks I think we're going to get
ready and get started I'm starting just
a better minute early I don't think
that's going to make that big of a
difference so as you can see I've
changed the title of the of the talk and
love it I'll explain why it's
principally because I'm actually not
going to just be talking about Java 87
but I'll also be talking a little bit
about what's coming in Java 8 as well
that pertains to sort of working working
with Java EE as a back-end and
JavaScript frameworks on the front end
okay so just a tiny bit about my company
I sort of have to do this because
they're sponsoring my travel basically I
work for a end-to-end
full-service IT consulting company we do
have a presence here in the in the
Washington DC area and I'm a senior
architect there I work out of the
Philadelphia offices but certainly the
team here is quite good as well okay so
this is what I intend to do in the next
45 minutes or so roughly speaking just
about a third of my time will be sent in
doing each of these things first and
foremost I'll talk a little bit about
sort of JavaScript frameworks in
perspective a lot of the conference
talks that I go to that discuss this
particular topic
they don't actually bother talking to
you giving you much of a historical
perspective or a broader perspective of
what is actually going on in the
JavaScript framework space so I often
find value in actually putting some of
this in in broader context to sort of
take it step back and say okay what are
what exactly are we dealing with here
what are the pros and cons in briefly
and the roughly 15 minutes that I'll
spend on this then I'll talk about the
job capabilities of Java EE has to offer
if you were to choose Java EE as a
back-end for a JavaScript framework
based fronting and then finally
hopefully a majority of this talk will
be spent actually encode showing you
working code examples and demos as to
how this in sort of medication would
work okay so that's roughly my plan for
your time investment next about five
minutes or so so first let's start with
JavaScript frameworks in perspective and
I have to be honest with you I've been
doing this probably a little too long
but not long enough to see a lot of this
but a lot of this actually is historical
perspective if you talk to folks that
have been in our industry for twenty
thirty years they'll give you sort of
this the same perspective the reality is
this pendulum shift that we're seeing
now the ridge line from sort of thicker
lines that we have now is actually a
very old shift and in fact the pendulum
keeps swinging swinging back and forth
right so we started essentially really
from with very very thin lines back in
the mainframe days those clients were
very very dumb right all they could do
is text render text colour text and
that's it in the 80s we had a full-scale
shift on the other side of things and
where we had things like powerbuilder
and visual basic where you actually did
a lot of UI work you know in the front
end and in fact often the business logic
was also done in the front end and
clients sort of the server side become
became thinner again and then we had
another shift of sort of in the in the
90s forward by browsers right and by and
large this is the world we currently
live in right so in this world
basically you can think of it as sort of
going back to the mainframe days the
reason is we actually in if you're still
in this world of spring jsf or spring
MVC
you actually don't do very much in the
browser right so a lot of the rendering
logic and everything is done on the
server side by your Java framework and
by and large you're using the browser
just as a rendering engine right so it's
just some very simple HTML and CSS that
you're spinning on and by and large I
would say this is still the predominant
type of UI that we're dealing with today
now in the some time in 2000 we started
seeing a slide ship hopefully some of
you remember this sort of buzzword Ajax
right and Ajax was supposed to take over
the world right it was supposed to make
us take us back into sort of the 80s
world where you think of the browser
really as you're a first-class UI
platform right so you do much more than
some simple rendering you would do
things like client-side client-side
logic using Ajax in reality though that
didn't happen
right in reality what happened is the
server-side frameworks things like
spring MVC and GWT they sort of absorb
Ajax as a assembly language a-level
capability a low-level capability that
these frameworks sort of sort of gave
you out of the box a good example of
this is prime cases and I've been using
prime fixes for almost five six years
and I really enjoyed it it really hides
a lot of the ajaxy client-side stuff as
a lower-level implementation detail GWT
certainly does that even to a greater
degree if you're using something like
spring MVC you probably have more of an
exposure to that assume that Ajax is
sort of world you're probably using some
kind of UI toolkit my guess would be
jQuery right but the reality is that the
Ajax shift largely didn't happen right
but there are good reasons why why it
didn't happen then and in fact it is
looks it is looking like it is happening
now right so what are these fundamental
changes one of the biggest ones is
actually the improvement in the
performance of JavaScript engine so if
you back in the day if you try to do the
Ajax sort of stuff the first thing
you'll notice is that the your UI would
feel very heavy the reason is the
JavaScript engines of the day back in
the mid-2000s really weren't that
optimized and thankfully that has
changed a significant bit now so these
are these off script engines are
significantly faster almost to the power
of of a compile time language not quite
but good enough right in terms of its
their performance and that is there is a
big reason to start thinking about
client-side JavaScript development a
little bit more seriously think about it
as a as a first-class UI toolkit the
other big challenge that you have seen
if you ever try to do ajax back in the
day let's say using dojo is you'll run
into issues of browser content
compatibilities left and right so
although in theory these browsers are
all supposed to support Dom the Dom
syntax is very very different from
browser to browser so what helps in that
regard is this sort of if you will
interoperability layer called jQuery
that emerged out of the Ajax pane right
so
that is also a big enabler in fact if
you look at most of these JavaScript
frameworks higher-level JavaScript
frameworks today they are by and large
jQuery base or something very similar to
jQuery that allows for allows you to
sort of normalize those browser cross
browser and crossbows are compatible
issues now even if you did use that
another big enabler is actually the
JavaScript and these are frameworks
themselves and of course that's what
I'll be spending a little bit of time
talking about so what do they what does
this give you in the end so in context
again you could do a lot of this using
just jQuery the program in fact people
have been doing that as I said if you're
using spring MVC you probably are doing
that the problem with that brush is you
quickly approach similar a similar
situation to what you would if you were
to write a server-side java application
with nothing more than JSP and GFDL
right namely because there is no
structure to that code that code really
becomes what's called jQuery su right so
it's unmaintainable code that has no
code structure to it and what these
higher-level frameworks javascript
frameworks actually do is that they
allow for a better structure the same
sort of structure architectural
structures that we have in the
server-side frameworks things like
struts and MVC tering NBC and JSF those
are essentially architectural paradigms
on their own right because they're a
framework so what's happening here is
that these frameworks are actually
bringing those concepts back into the
JavaScript role right so you can
actually write a JavaScript code that is
far more maintainable and looks more
like what an enterprise class
applications should look like and
finally these browsers have also done a
different job these days of gradually
introducing developer code as well right
so if you were doing back in the Ajax
days it was very difficult to even do
basic JavaScript debugging right so all
of those capabilities are also building
up allowing you to do things like
meaningful monitoring and management and
profiling and debugging so all of these
are also important enablers to start
thinking of JavaScript as a first-class
UI tool chain and finally the JavaScript
eco
system in terms of its standards has
also moved forward right so you now have
CSS html5 web socket and even down the
line you will begin to see further
standardization like html5 components
right you haven't seen that yet it's
still in the works of that also will
have will significantly change
essentially the browser UI toolkit so
you can think of JavaScript as
essentially as almost just as powerful
as as job okay so other thing another
thing that I forgot to mention is I
don't usually do Q&amp;amp;A at the end of my
talk so if you have any questions on
anything that I say you know let me know
it raise your hand and we'll discuss
discuss that it's it's it's far easier
for me to do that rather than try to
save time at the end of my talk however
as good as the JavaScript frameworks are
let me also tell you that you shouldn't
think of it as a cure all right I think
that's a stupid thing to do as well
everything in computer science has
trade-offs right and you should be
cognizant of these trade-offs just
because everyone is everyone says you
should be doing a JavaScript framework
that's not necessarily always the case
and in fact in my clients III tell them
look it's not you should be choosing
what is right for you not necessarily
what what somebody else is doing so
there's no doubt that javascript lines
are good for certain things right so
when you have a UI toolkit on the
browser one of the things that it allows
you to do is write very complex dense
interfaces that are dynamically changing
so in fact this is basically think of
this of the desktop application so if
you are if your UI needs to look more
like a desktop application right then
JavaScript is a very very capable way of
doing that in fact it's the only way of
doing that that type of UI another way
of thinking about this is basically
single page applications or if you're
familiar with applets the same sort of
problem domain that applets were trying
to solve right so this is basically UIs
that don't change very much they don't
have page transitions so basic UI looks
essentially the same and you have
various widgets that apply or in I have
a workflow in in that ey so I think of
this again
in terms of your Excel application or
your word application right you have
helper screens you have functionality in
the UI but the basic the main are part
of the UI essentially remains one on the
same your average mobile application is
probably that way as well right so for
these cases javascript frameworks
absolute win right however what I also
tell my clients is do you think about
the other other other way to JavaScript
frameworks are by and large optimized
for this particular case single page
application case but the reality is not
a lot of our applications are
necessarily follow this single single
page application domain in fact I would
argue that most applications are in this
in in the enterprise actually don't
follow this pattern what follow what
pattern do we follow in fact we follow
more like that mainframe pattern of
having workflows and screens so your
screens actually do change right from
one one task to the other right you'll
see rapid transitions of your screen UI
and you don't actually JavaScript
frameworks actually will work against
you when you do that you can do that by
using JavaScript frameworks but we're
really not real everything the best best
case of what JavaScript frameworks are
actually the best at doing so in reality
for these types of you is you should
still consider server-side frameworks
like JSF and spring MVC stem because
they do have some some benefits like
namely maturity right one of the things
I'll talk about is the volatility of
JavaScript frameworks right gen in
general these Java frameworks are far
less volatile right they used to be
volatile back in the day but they're not
anymore they're generally more reliable
it's because you're not dealing with
you're not dependent on the browser
capabilities in not even am dependent
upon the capabilities of the client
machine by and larger you are dependent
upon you know your own server and again
you're just using the browser as a dummy
client they're generally more secure
right not a lot of code is exposed on
the client side most of the your your UI
level code is on the server side they
have better they have better ways of
dealing stablish ways of dealing with
accessibility internationalization inter
lies Asian SEO and the like and believe
me when I deal with sort of folks that
are dealing with these JavaScript
frameworks these are real issues that
they deal with because JavaScript
frameworks are not quite there yet
they're getting there but they're not
quite there yet so do you think about
you know what exactly you want to do in
the end and I won't honestly one of the
big reasons I still have folks using
server-side frameworks is because when
you're dealing with these JavaScript
frameworks you really do have to be a
domain expert in JavaScript right so you
really need to pick up yet another tool
change right let's often very different
from your Java Java tool chain so if you
are developing let's say a departmental
application that's not an inter scale
application and you most of your
developers are Java developers well
that's a good reason not to go this
JavaScript route right but regardless
what I see though is coexistence in the
long run because of these reasons I
don't see JavaScript frameworks
completely taking over I do think
they're a valuable technique you know
they're valuable thing in the toolset
and in fact maybe even more for more
than 50% of applications these days
especially mobile capable applications
but it's not the only thing in the world
right so that's the major point that I
want to make there but let's assume for
a second that you do you are going in
this in this JavaScript route and you're
going to have a JavaScript framework as
your as the front-end of your UI how
does this impact your architecture well
the nice thing is we actually know a lot
about that because we have seen this
sort of architecture quite a while ago
in fact that ATS architecture of having
essentially something like power built
on visual basic in the front-end Maps
extremely well to this world right so in
all of those architecture lessons that
we learned there can be applied here so
in this role basically the client is
responsible for things like UI rendering
obviously the same way you would if you
were using a server-side framework in
addition to that the client is also
responsible for addition additional
things like basic input dilation the UI
logic itself what do I mean by UI logic
will by UI logic what I'm
in is what is displayed right what is
the work what is the workflow of the UI
these are all UI level yeah this is
basically why logic and this also
belongs in the client and also most
importantly stade belongs in the client
right on the other hand when the server
does is essentially a it becomes a
stateless business logic or the services
engine right so on the server side you
will still have things like your core
business logic your domain model
persistence transactions asynchronous
puzzle saying whatever else you need to
do on the server side that's what you're
going to do outside of the JavaScript
world in in the Java world or in this
case in the Java EE world in terms of
communication protocols it's also
relatively straightforward right we know
what basically what our general tool
sets are and what we will wind up using
in a majority of in in these cases so a
majority of cases we will probably wind
up using rest why is this and how do we
know this the reason we know this is
again goes back to the lessons learned
in the 80s right so when we learn these
things by and large what winds up
happening is each of these communication
between the client and the server their
atomic stateless operations right so it
really makes sense to use rest for a
majority of the cases for this type of
architecture however in some cases you
will wind up using needing something
more than that right you will need to
maintain state and actually I'll show
you an example of this or when you would
want to do this so in that case you
actually want a long-running
conversation and state store somewhat
somewhat both on the client and the
server and in those type of cases what
you need is WebSocket and I'll show you
how to use WebSocket on the client side
and and on the server side as well there
is something else in between
rest and WebSocket called server sent
events okay and and what are these these
are dealing with the cases where you
only send events you do need a
persistent connection because you it's
not a one-and-done
conversation but the persistence
connection looks very much like the
server side does much more so that
okay right so basically in this case
what you do is you you open up the
connection and then you keep that
connection open for a period of time but
basically you get events back from the
server over a period of time okay and
that capability also actually exists in
the in the Java platform already and
it's going to be improved further in in
Java EE 8 and I'll talk more about that
in a second as well so the nice thing is
the JavaScript frameworks by and large
actually support the rest case extremely
well right so on the server side you
actually have a support for in the Java
platform we have support for all these
things like you have support for s you
have support for WebSocket and you have
support for SOC on the JavaScript
framework in ironically you actually
have very good support for the majority
use case which is addressed okay you
have weaker support for things like
WebSocket and SOC and I'll show you
hopefully in the code example you will
need to do some stuff on your own when
you're doing that the typical data
interchange format in this world is by
and large going to be JSON okay and the
platform does have a very good support
for JSON as well and by and large
actually a lot of this is is not an
accident okay so the Java in the Java
platform plus we in Java EE 7 and Java 8
we've actually made quite in the expert
group we made quite a bit of effort to
make sure that the platform has
everything that you need from a
server-side standpoint to write these
sorts of applications so to use a sort
of good old architecture block diagram
this is sort of how things look like so
in the on the UI part instead of having
JSF you essentially have a JavaScript
framework of your choice whatever it may
be and then you have the rest of the
capabilities a bill that are built into
into the platform
okay so jax-rs essentially gives you
first class support for rest
the support for WebSocket comes from the
Java API for WebSocket you have two
different API is actually one in Java 7
and one in Java 8 for doing JSON
processing one is a lower-level
processing
API called JSON be similar to XML P so
Dom insects parsers similar to that and
you also have JSON binding which is
which will be included in Java yet and
that is a higher-level declarative
annotation based API okay in addition to
that if you wanted to do XML you can
still do that right so you have Jack's B
for that and in fact in the platform you
also have support for sopia jax-ws if
you wanted to as well although it's
generally by and large we probably won't
be doing that
so SSE support is also coming in Java 8
right if the C support today is
proprietary so if you look at lost fish
or WebLogic it does have a proprietary
API for to do SSE now that's going to be
standardized as for Java 8 in in the
summer will so kamek kamek around the
summer bean validation is another
important API in this world and I'll
explain why basically what it allows you
to do is do a server-side validation in
a declarative way other than a
programmatic way and beyond that you
also have all of them rest of the
middleware capabilities to write your
business logic to write your persistence
logic and the like built into the
platform as well so that's CDI for
dependency injection EJB for
transactions asynchronous processing and
the like JPA for relational and normally
tional access and a whole bunch of other
things
ok so we'll get to hopefully the meat of
the presentation now and start diving
into some code and showing you how these
things actually look like in the java ee
world so the good news is that all of
this code that I'll be showing you is
actually out on the web already it's on
github ok and in fact I have had some of
my clients actually start their their
HTML 5 gy e projects using this exact
code example so I'll show you the code
example real quick it is self-contained
so you can go on to my github account
okay and I actually have instructions on
how there's a description on what this
application is the setup instructions so
you can actually set this code up
yourself and explore it explore it
yourself okay and of course the code is
also there and we will take a look at
the code as well alright so without
further ado let me go ahead and start
the demo so I have a payara a glossary
derivative up up and running I will go
ahead and start my application okay and
this is one of the things I love or Java
II the most this application started in
seven seven hundred and sixty-five
milliseconds okay this is not the kind
of performance you will get pretty much
in any other platform other than Java EE
okay so here's my rest application
there's actually two different
applications that I will show you one
using rest and the other using WebSocket
I'll explain the front end and the back
end application I didn't try to get too
clever with mine with my demo examples I
actually picked examples that are fairly
common when explaining sort of
JavaScript frameworks so for the rest
interface I've actually used a to do a
to do API and you'll see whenever
whatever JavaScript framework you see
out there there will be a 2d API for it
and the canonical example similarly for
WebSocket is yet it's a nice concrete
way of explaining what exactly WebSocket
does and why it does it okay so let's go
ahead and start actually the first thing
I'll do is actually I'll show you how
the API is documented so this is how my
back-end API looks like you'll see it in
action in a second right as I'm going
through this you'll see what is actually
is happening so my rest endpoint is
published on my local host on port 81 81
okay Java JavaScript is the name of my
demo application resources is
essentially my rest prefix to do is it
is a resource endpoint okay and what do
I have here will I have essentially a
very simple API a crowd API okay so I
have first a get call that gives me a
list of to do items in each to-do item
as you see is relatively simple it's got
an ID it's got the actual description
of the task and a completer flag whether
it's done or not okay on the get request
you get a list of these in JSON there's
a post request that allows you to create
a new to-do item okay and then there's
an update item and that goes by user
names so all of these are separated by
user name in the URL okay and you give
it the ID of that particular item and
that that's how you do it that's how you
do an update and of course the delete is
simply following the URL of the ID and
to delete the item okay so that's the
API it's relatively straightforward now
let's take a look at the application
itself here's the to-do interface notice
I have a login okay this is used
basically using basic basic
authentication so I'm logging in let's
say as myself okay so here's my to-do
application let me show you show it to
you in action
and I have typing dyslexia okay not if
this is a very good example of what I
was talking to you before about right
it's a relatively dense API the nature
of the content so isn't changing very
much I'm just acting upon whatever my
base content in and it is changing in
real-time so there is no sort of request
response cycle it the up the API is
updating as I am typing it and there's
definitely no page transition of any
kind okay so that's the a bad case so I
added a bunch of stuff here okay I'll go
ahead and do an update let's say sorry
okay later
that's the modify okay I can also do a
completion I can do a delete that's gone
also you can see as you can see these
are all happening in real time just to
show you that this is actually
persistent okay I will close this out so
the Browse browser is closed now if you
notice the text is really small but
there is a bunch of sequel statements
actually being issued right so this is
actually going in and saving all of this
all of my stick to the to the database I
will go and start this up again okay and
then you can see okay there is there's
my my data back button I could yeah I
probably don't have time for it but if I
have time I will I'll show you but yet
basically Chrome has a debugging
capability the JavaScript give out okay
yeah so as you can see this is basically
the UI okay so what I want to do is
actually start backward and actually
show you the server side first okay
because believe it or not the server
side part is actually the simpler part
of this and then I will bump that that
bump back up and show you how the client
side looks like how does how is this
actually bound to my JavaScript
framework okay so I'll start with the
resource endpoint okay this is actually
my rest endpoint in Java II and it's
super simple right in order to publish I
a is
can anybody see this folks in the back
and you see this font or do I need to
increase it okay excellent
all right so this is how simple it is
you just take your project and you put
some annotations on it you deploy it in
your war file it deploys in less than a
second and that's all right there's no
configuration there's no library to
configure or anything else like that so
in order to publish a rest endpoint you
simply say at path and then you give it
the path okay in this case my path is
actually to do slash user names so the
user name is actually part of my box so
the user name that I logged in in as
myself right that's actually part of my
rescue RL path and I pick that up that
thing in the curly brace is actually a
passed parameter so I can actually use
that parameter in my code as well okay
I'm injecting a back end service called
to do service and I won't show you the
all of the code for the rest
implementation but basically this create
methods I post to do I create edit to do
a put delete to do I get and as deleted
or removed into a delete and get all is
certainly mapped to the get method
so what I'll show you is the put case
it's a relatively representative so in
order to map to an HTTP port request all
you really need to do is annotate with
the add port annotation in jax-rs okay
and what this does is it takes care of
all of the mechanical details for you
right so when you invoke my URL to do
slash Reza and you put you make a put
request
well it'll automatically get resolved
into into this edit method for you
by virtue of saying at put and the rest
of the parameters which is ID so okay so
I want the ID of what is it that you
want me to edit right so that is also
going to be in this case part of my path
so my full path will look like to do
slash rezar slash one two three four
five six right and the other thing you
will see here is that I'm consuming JSON
the axe consumes annotation an
application slash JSON is basically
telling my runtime that I expect the
body of this of this boot request to
include a JSON payload okay and notice
is there any other JSON processing not
not at all right so the runtime is
actually taking care of this for
right so this abusing the json binding
annotation so it knows how to translate
between my to-do item object that i'll
show you in a second and whatever mine
my javascript json rendition was of that
to do object in addition to that I'm
actually also processing a few things
here right so I'm processing essentially
the ID I 1 I 1 the ID and has a path
parameter so I'm getting getting that
back I'm getting the actual username
back as well so there's my username and
I'm also getting though obviously the
the to-do item itself right and notice
all of these other parameters like not
null and sighs okay these are actually
been dilation beam valuation arguments
right so it's not just mapping the from
the JSON r2 to the to Java it is also
going to do the validation for me okay
so I'll show you the validation in
action actually so let's go back to
notice that the that the not the
username but let me see I'll show you
the to-do item for example and navigate
sorry go and click command click OK
alright navigate go to implementation
much better okay so over here for
example in the description field I'm
saying the description must be between 5
and 110 characters right so I have a
bean validation annotation here as well
that's being validated because I have
the add valid annotation okay on on my
rest method so let's go back here and
try to enter okay so that's that's
actually happening from the server side
okay the the error is being generated
from the server side going back to the
client side and this that's where the
rendering is happening okay alright and
the rest of this code is actually fairly
straightforward so I'll show you the
service real quick
the runtime is doing that for me right
so what's happening here is that because
of those be invalidation annotations and
error is generated when you when there's
a validation failure without you having
to write any code for it and the runtime
the Java runtime or by default will
generate a 403 error okay for you so
here's the service implementation it's
extremely simple it's just a POJO with
the ACK stateless conditioner on it and
this is basically giving us the
transactions okay that we're going to
wrap each of these requests with there's
some simple data massaging going on so
in other words I'm taking the username
that I get from the proper ammeter and
setting it as a to-do item doing some
simple logging and then invoking my
repository and the repository is just
simply using JPA I'll show you the JPA
code real quick okay it's some super
simple code I'm just injecting the
entitymanager
okay and in case of in case of let's say
update I simply call entity manager
order to merge my entity itself is also
relatively simple right so here is the
entity it's a JPA entity and all of the
other than that it's simply annotated
produce and again basically the Java
Runtime is doing all of the time on
translation for us behind the scenes to
do all of that alright so any questions
on the on the backend at all back in
code hopefully relatively
straightforward okay I think it couldn't
get any more straightforward from a from
a server-side standpoint so all of my
the code for processor for the
client-side is actually in a single GFC
a page called over here to do dot JSP
okay so let's go through to do jsq here
click ok so I will tell you
unfortunately this code is still written
using angular 1.2 okay so one of my
things that I just don't didn't have the
time to do is upgrade upgrade this to
angular
for okay but generally the concepts are
more or less the same okay so I'll just
talk about the concepts without talking
about necessarily the implementation
details hopefully or if you're writing
an angular application today you'll be
using angular for instead but there are
still the basic concepts hold so in
angular are basically the main thing
that you notice yet you have to notice
here is notice these guys controller
services directives and applications
okay if if I was to write this code in
in let's say jQuery what you would
expect is is a lot of gobbledygook in
this in this application a whole bunch
of JavaScript functions and whatnot or
at least it's some kind of GS file that
also looks like spaghetti code right in
this case that's not going to be the
case it's going to be very similar to
what you would expect on in a
server-side framework so I actually have
all of my code segmented into components
okay so I will have distinct controllers
distinct services distinct directives
and an application that hooks all of
that together I'll show you that real
quick without getting too much into the
in depth of it so similarly the same
thing is true in the markup as well so
in this case I'm actually taking my
entire body and assigning it to a
controller object okay so my backing
controller for this entire page is
actually called to do controller which
I'll show you in a second how that
object looks like and for each of these
each of these guys each of these actions
there's actually a binding so let's talk
about the the one field that I have to
enter the to-do item that's actually
that input field over there okay so the
most important thing there is the
ng-model component what the ng model
says is very similar to what you would
have in in in JSF so this is actually
the variable that the value that you
enter into this input field is bound to
okay and similarly at the very bottom of
this page
when you're sorry I'm not at the bottom
but at the very top when you see NZ
submit that's actually what's handling
the form right so when I hit enter in
that form that is the that is the method
that's actually triggered it's add item
and it's actually a method in the
controller itself
okay so I'll show you the controller
code next okay and if I am show you to
do here's the actual controller okay so
here's where I'm defining the to do
controller object and you'll notice I
have these variables right so these are
the actually the variables that are that
are being bound to so new to do
description okay that's the actual value
that my value of my text field is
actually automatically being bound to by
angular similarly there's a the user
name that I actually entered okay from
on my login is actually within that
scope dot user value variable now let's
see what happens when I say for example
add item and by the way you will see
other other functions here so edit item
remove item these are also all in here
okay so by default actually what happens
is when I do a default get request um
and when I'm initializing this
application I actually do a to do dot
query and this translate winds up being
translated to a get request okay so I
get a list of items that's are also
stored in a variable colitis but if you
look at add item this is really what is
happening here so I create a new domain
object call to do okay give it the the
description that I need and that is
actually a JavaScript object being
created and then I simply call I Tim dot
save and this winds up getting
translated into a a post operation on my
back-end okay and then I get the famous
especially callback handlers in
JavaScript so I have success and failure
in this case right so in the success
case I simply add the data on to my list
of items and they clear the new to-do
item description field whereas if I get
an error I have a growl
growl control okay that you see on
screen and I simply add the error
message there okay so that is actually
not where the actual logic is actual
logic is and the services layer okay so
this is actually my to do service now
this the to do service is actually just
nothing much more than a template
because in angular 1.2 there is actually
a resource class okay there's nothing
but a representation of a rest endpoint
okay so my object in my service object
in this case is actually relatively
simple right so all I need to do is take
that resource templeton and customize it
with whatever it is that I need in this
case I give it the URL
what is the your own pattern that I need
that I need to follow and notice just
like on the server side in the client
side I'm also using essentially
placeholders user ID and item ID okay
those respectively come from essentially
the the variables that I have defined in
my controller so item a user ID is
coming from the principal object and the
item ID is actually coming from the JSON
payload that I've that I've created
right so it is really as simple as that
the back in the backend integration
piece is as simple as that for in this
particular case for rest right let me
show you now the the WebSocket case in
the in the time that I have so let's go
back to
okay and let's take a look at the
canonical example of a check okay so in
this case I'm logged in as myself
alright so I'll enter some information
here okay not terribly interesting yet
okay so what I'll do is I'll copy this
URL and I'll open up another browser
instance let's say in this case let me
see I think I have Firefox installed and
I'll log in as my wife instead so let me
do that okay so I did that there and
let's go back to my chrome instance and
notice that the method that I entered in
the other browser window is now here
okay the same will be true in this case
as well so let me do
okay going back to Firefox there's my
message all right so what is happening
in this case in this case actually a
stateless connection won't do right so
what's happening in this case actually
both of these clients are making a
persistent connection to the single back
in to a single end point on the back end
and essentially exchanging information
back and forth between each other so
there's actually state in three places
right there's a state maintained in this
page state maintained on the server and
also state maintained on beyond the
other in Firefox as well so I'll show
you the back end code only in this case
I won't have time to show you the front
end code I explored you take I encourage
you to take a look at it to yourself
this is the actual jack server okay and
just like in the in the rest case is
actually again very very simple it's
just a small set of annotations and just
photos right so there's my Jack server
the way you create a chat endpoint in
WebSocket is simply using the server
endpoint annotation you give it the URL
called chat that's the URL that I
actually connect you you can specify an
encoder and decoder in this case you
have to do that because it doesn't come
built-in with data type awareness all
right
and other than that I'm really doing not
much more so I have a set of sessions
that are open are one for each client
okay so I create a hash set and then I
have several callbacks so the on open
callback is when a browser window opens
okay so sooner browser as a browser
window opens I actually add this
particular session to my list of open
clients and similarly on browser close I
close that off okay and the real work
happens on the on-message method so
whenever somebody sends me a message
from JavaScript it's a very simple is
similar idea to what you saw in rest
right so you can use essentially all of
that is mapped to your Java objects
directly you can still do validation
right I can show you the validation that
is happening even on the Jack Nasir
users using the Java using the bean
volution API but other than that what
I'm doing here
is essentially iterating over my list of
active sessions and simply logging out
what I received so I'm broadcasting the
message that I received from the rest of
my clients okay and I'll let you take a
look at the client-side code I'll just
show you one part of it okay I will show
you essentially the service layer of
this so let's take a look at services
okay and in this case you will see that
the service has a little bit more going
on all right so in this case because
angular doesn't even now doesn't have
built-in support for WebSocket iMessage
I'm essentially using the lower-level
JavaScript API rights I'm creating a
WebSocket instance okay connecting to my
WebSocket endpoint on the server side
and then I have a few callbacks so on
send I simply do WebSocket dot send and
then I send a JSON payload that I create
myself an on-message I simply get back
whatever a message data that I get i
parse it into JSON and then I put it
into my my message listeners okay so
that that's basically what what's going
on here the message listener code I
believe where do I have that it's
actually in the controller
okay so it's essentially when as you see
here it's when I get a message back I'm
simply adding it to my array okay in
JavaScript and it's getting the U is
getting updated by itself to do that
alright so moving back into my my
presentation here so basically this is
what I give you is the basics of what
you need in order to execute on this on
this architecture so definitely you can
do it writing JavaScript UI is with with
Java ie Java is very well-positioned to
do that it gives you basically all of
the tools more tools than most of the
JavaScript frameworks have namely rest
you know WebSocket SOC is coming as well
certainly JSON support and it gives you
in the simplest way possible in my view
right so hopefully you'll be able to
take a look at the code example and get
started with this sort of development
yourself certainly using my code
examples hopefully as a starter so if
you want to learn a bit more I would say
the best place for angular is using the
official angular tutorial and similarly
for Java EE I actually recommend the
official Java EE 7 tutorial it has or
everything a lot more details about
everything that I talked about today
alright so thank you very much I am
actually over time so I will take some
questions if you have any questions
otherwise feel free to feel free to
essentially move on to your next session</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>