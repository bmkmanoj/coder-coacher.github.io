<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Eclipse and Java 8 | Coder Coacher - Coaching Coders</title><meta content="Eclipse and Java 8 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Eclipse and Java 8</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/_unAhwbZDCA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">morning everyone my name is J well don't
even bother with the last name I'm an
IBM er I work for India software labs
Bangalore okay so today we gonna talk
about eclipse and July we all know that
Java 8 was announced earlier this year
it came out with a lot of interesting
features lot of important and big
features so a new version of a language
is announced what is in store for 90 we
all know that eclipse is one of the Papa
IDE among Java developers so what does
the IDE team go through to support the
new language version that's what we're
going to talk about today and before we
get to that the quotes about myself so
like I said my name is J been the
software development for over 15 years I
have been agility coke emitter for all 5
years and occasionally also contribute
to Oregon which is another hopeless
project it is project on flux alright so
talk about eclipse features for Java 8
what are the new features that we've
added to support Java 8 and what are the
challenges that the team faced along the
way particularly the compiler team some
of our technical challenges and some of
them were process related challenges we
will look at some of the tooling support
you get from eclipse for Java 8 take a
good demo and in the end we'll take some
questions all right just to make sure
that everybody's on the same page I know
pretty much all of you are aware of the
new features that were introduced in
Java 8 just to make sure that
everybody's on the same page
lambda project the jasa 335 that is the
the biggest feature of Java 8 it
includes
lambda expression method references it
also talks about the overload with
Lucian and type inferences and of course
the static and default methods
supporter interfaces now so in Jays in
Java 7 we did have annotations but you
can have annotations only in certain
places of a Java program
you cannot go ahead and put annotations
everywhere well you cannot do that even
in Java 8 but there are a lot more
places in Java program that you can
quantitate a lot of elements like type
arguments you just not support in Java 7
they can be converted in Java 8 and also
in Java 7 you cannot have annotations of
the same type
appearing repeatedly in a particular
element and Java 8 over X that again
method parameter reflections you're not
going to be talking about in details
just to highlight that it is they enjoy
IDE and the pluggable annotation
processor API which is covered by J's
are 269 all right just have a quick poll
how many of you are aware of the fact
that Eclipse has whole compiler that's
not many but I'm not surprised
it gives us an ID right why should it
have its own compiler but it is there
and for really good reasons when I keep
started out more than 10 years back
Apollo 13 is we want to have our own
compiler because in IDE you want to have
incremental compilation right if you use
Java C or ant every time you want to
compile you compile all the programs
that are in your project or in a
workspace but you cannot afford to do
that in an IDE you know just because the
user touches a particular file which is
part of a big project you don't go ahead
and compile all of them in the project
so that is something we had in mind and
of course the compiler the Eclipse
compiler produces the abstract syntax
tree that is consumed by lot of other
components in the eclipse to provide
better tooling support of course we also
try to optimize the class file
generation for certain cases I'd also
like to highlight the fact that accuse
compiler can be
consumed in different forms of course
the obvious one is as part of the ID you
can also download the eclipse compiler
from online systems our file download it
and use it from command line you can
also put it in ant script we have an ask
adapter for that and you can also use it
as part of my own of course if you want
you can invoke the compiler of
programmatically using the
specifications mentioned by J's one
double line so these are the hi-low
features that were either added or
upgraded for Java 8 well these have
always been there most of them so
obviously the compiler and the increment
builder had to undergo major changes to
support Java 8 we did add some new
features code features for code
completion for Java 8 and just take a
look at it I mean these are the standard
pieces that you would expect in an IDE
this is something that you may be
interested in knowing as well type
annotation Bay static static analysis I
don't know how many people have used
this but it's a really cool feature and
useful feature as well we're gonna talk
about it in one of the coming slides oh
okay now before get into the details
here are some interesting tidbits about
the about a Java 8 effort since our
first commit in May 2012 we've made
around 2,300 commits so far this does
not only include the compiler but other
components like the UI the debug the PDA
and all the components again now we had
contributions coming from as many as 31
people I could be wrong but it's at
least 13 people and not all of them are
you know regular Eclipse commits as
contributors and completed around 907
tasks have to ding the official support
for
eight was announced as part of accused
4.4 even though developer bills were
made available even before that this was
weddin officially it was announced we
did include a feature patch for the
previous version which is 14 as part of
our testing effort we took up some of
the big projects available out there
noticeably the JRE 8 and open G of X
which had a lot of Joyride specific code
they had lot of lambda programs lot of
default methods not as I write code and
we were able to build them successfully
that was one of our major goal as far as
testing is concerned of course you know
we should be able to compile our own
code we use our own compiler to build
eclipse SDKs right so again that a
source of water of plan again just to
make sure that everybody's on the same
page we talked about what lambda
expressions are this is again not a
tutorial about lambda I'm not going to
tell you how to write lambdas but
basically the idea was no should be able
to support the paradigm of CODIS data
know even though Java is an
object-oriented language should be able
to take a piece of code and pass it
around we're never able to not
supporting it till Java 7
however Java being Java you have to have
types and objects right so ultimately
even if you even when you write a lambda
what really happens is it is actually an
anonymous method because lambdas
captured the enclosing state
grammatically speaking lambdas can occur
anywhere an expression can you can put
lambdas anywhere in a program but there
are certain rules that a lambda must
stick to lambdas have to have context
type a target type and the compiler is
supposed to reject everywhere else we
have lists of seven contexts that
provide a valid target type I do have
some examples for each of them
so we have the initialization we have
the assignment or dereferences we have
the caste expression it's also being
used as part of method invocation again
as part of nested lambda and return
statements if you look at this the
common thing about all the examples is
that you have to have a target type
right so on either on the left hand side
or as part of method parameter you have
to have a target type that's the only
way the compiler is going to understand
about the lambda so what is a target
type it there are again rules it has to
be a function interface
what is the function interface just just
like any other interface but it can have
just one abstract methods it can have
other methods it can have default and
static methods as they call us know put
carrying interface methods again a
function interface if it wants it can
you know read it lower the methods from
the out lambda object but as far as
abstract methods are concerned there can
be only one so ultimately the the lambda
object implements the functional
interface it provides a subtype for the
function interface it also provides the
implementation for the single abstract
method also called as Sam
so again Java in Java it's another way
of constructing objects you know that in
Java 7 you can construct objects in
different ways you can use constructors
you can use serialization you can use or
reflection so there were certain ways I
so Java 8 provides another way of
creating objects all right so we looked
at the lambda we know what a lambda
looks like right it has to have a target
type obviously and it has a lambda
parameter list on the left
and it has a lambda body separated by an
arrow so obviously Java 8 introduces new
sin taxes it also introduces new tokens
new terminal tokens which is in the air
oh so this grammar changes proved to be
one of the biggest challenges we faced
while implementing the compiler for the
white because the lambda parameter if
you look at it it it contains the know
it can have parentheses and it looks
just like a method parameter list so how
do you differentiate a lambda parameter
list from method parameter list you know
when you look at open parentheses it can
be anything it can be an expression it
can be a type a caste it can also be a
lambda expression but we can never be
sure until we have seen the complete
lambda body or at least until we have
seen with the arrow and because the
genetic compiler is a single token
look-ahead parser it makes it even more
difficult and what is making it even
more difficult is the fact that it is a
table driven parser automatically
generated by the jig's parser generator
you know it's not handwritten we don't
write the parser logic we don't hand
write at all and it's all in the tables
and you know even debugging it's almost
impossible everything storing tables and
the tokens the states like thousands of
stage right so they're all stored in
tables and again this is the fundamental
building block of our compiler and there
are lot of subtypes of the parts are
providing different capabilities so if
you touch the parser and you know
something goes wrong obviously
everything else is affected as part of
the entire IDE of course we didn't want
to fiddle with changing the parts of
technologies you know
you might wonder know what is why don't
we just change it from a single token
look at parser - no - token look at
parser but there's something that we
didn't really want to risk especially at
this point no we didn't have so much
time or didn't really want to take the
chance at all so we try to you know work
around by change in the grammar files we
tried changing the the production rules
but our initial effort didn't really you
produce the results we wanted so they
were resulting in lot of shift reduce or
reduce reduce conflicts or sometimes
both so it obviously at some point you
try it and so that's when she can't is
our compilers but he came for this idea
so what is the idea so instead of
changing the the production rules why
don't why don't I change the language
right the problem is that when you look
at the open parenthesis you don't know
whether you are dealing with the lambda
so why not change the language such that
you know when you're looking at the open
parenthesis you know that you're looking
at a lambda of course you cannot do that
I mean we don't define the language
right
Oracle defines language but again we
have our own grammar files that where we
can actually define what the language
looks like so we did this by injecting
synthetic tokens in the in the grammar
so if you look at it so so lambda
parameters has a begin lambda and a
lambda parameter list right so now we
know lambda parameter this again has
open paranthesis but because we have
this synthetic token we know that it is
lambda parameter lace and not a method
parameter list right but how did we
really do this again now what if the
user actually encodes this synthetic
token
so that JDT infrastructure has a really
nice thing nice feature now we can
create mini or micro parsers and with
specific goals and with specific source
range you know you can just take a
source fragment and create a parser for
that and run the parts on a particular
mission the mission can be anything
usually the mission is you know compile
this Java file that that's what the
deformation is but in this particular
case when we look at the open
parentheses we halt the main parcel it's
put on hold and the scanner then runs
the special parts or we call it as
Vanguard parser you know Vanguard parts
are which is usually at the head of no
military regiment so it prints a special
parser so this special parser has a
specific goal of finding whether or not
we are dealing with a lambda it starts
from the current token which is the open
parenthesis starts you know reading
tokens by token and if it finds the
arrow then we know that we are in a
lambda so if you find lambda it returns
the control to the main parser and how
does it do that it do it does it by
sending back the synthetic token which
is nothing but the big in lambda so now
the main parts are knows that there is a
big in lambda so what I am looking what
I'm what I'm going to get next is a
lambda now you might be wondering right
so there are going to be tons of places
where you have the open parenthesis so
are you going to do this this process
every time you see an open parenthesis
now when I'm going to do that there are
a few places where you do not expect a
lambda like if statement that cannot be
part of your statements or switch blocks
or even wide loops right so those are
obvious cases that we avoid we only do
this place absolutely necessary
like take a look at this code
straightforward lamda example we have a
method go and that takes a lambda as an
argument right so we know that the
method GU provides the target type for
the lambda so it could be a function
interface let's just say function
interface I and we also know that it the
function interface I has one method
whatever it is and it takes one argument
and the method body is going to just
multiply I I and that's going to be the
return value say for isn't it but what
happens if you have multiple versions of
and go what what I wants we have over
order methods go we know that the way
the compiler or we differentiate between
over other methods is by looking at the
argument type right now so how do you
know which go you are invoking you have
to know what type the argument
represents so what is the argument here
the argument is a lambda so what type
does the lambda represents we don't have
the type there in fact in order to
resolve the lambda you need to have the
target type and in order to get the
target type you need to know which
method of dealing with right classic
chicken X storage X situation right so
so like I said basically so the
resolution of the method that you are
invoking and the lambda depend on
another well I would like to say it's
magic but you know there is no magic in
software this is the famous quote from
David wheeler so when we don't have a
target type readily available what we do
is we create a poly type binding it can
store information about potential types
so that capture
all the information we have about the
lambda and the enclosing context and
it's going to be used as a proxy until
we eventually resolve the lambda now the
indexer on search that we use in a cubes
kind of world technology and you spin
around for 15 years and unfortunately
takes base just for example you have a
method and method is being invoked for
somebody the way it is to the index it
works is you know it just looks at the
method name it looks at the method
argument names and stores them in an
index file so whenever somebody wants to
look up or do a search the the search
engine looks for those names or whatever
text you're searching for it looks for
the that string from the index indexed
file and returns the results now for
lambdas we don't have anything to encode
you know we don't I mean if you want you
can put the you know argument type
argument name you can do that but you
don't really have anything we cannot
actually we cannot take the liberty of
assuming that it's going to be there so
in order to do that not to deal with the
lambda the index it has to resolve the
document first only then we will know
what type you're dealing with what are
the things that that have to be stored
in the index file and sometimes in some
situations even in the files that were
not at all modified had to be indexed
all right so we know that job eight
introduced type annotations you can have
types you can have annotations anywhere
a type can occur not just the type
declarations unfortunately for us this
changed the very notion of type so in
you know compiler we have something
called type binding right so you have a
type declaration and that
type is going to be used somewhere in
your program and let's call it type use
now if you want to get more information
about this type views you have to have a
way of finding what the type
declarations type declaration is so that
is type binding so in Java 7 those are
all interned I mean it's like if you
have a string anywhere else it's going
to be a string if the same object we
didn't we never had duplicates we cannot
have more than one type binding for a
string we can now have more than one
type binding for an object for any type
of the matter but some of the type
systems the famous example is the
analysis or even annotation processor
they have a different need they how to
differentiate types based on annotations
that the in code right so that's the
example I mean this again need not be
just normal and null it can be in
annotations right a normal string is not
equals to read only string but most of
the components in compiler they still
look at them as the same object or same
type binding so we had to change our
entire type system to support both the
worlds unfortunately again we had this
check because we assume that a string is
always going to be a string we had this
kind of checks no equals equals and not
equals in terms of places to be precise
we had it around 700 odd places and
every one of them could potentially be
wrong right we'd have to be absolutely
sure that it is a belongs here or here
so we had to revisit every one of them
and take a cloak close look at them and
change accordingly but how did you do
that I mean 700 our places is quite a
challenges in it so again we are the
compiler people right so we modified our
compiler to do that for you for us
so we thought code that would look at
our own code look for the places where
we do the equals equals not equals
operation on type binding and report
them for us once we know where they are
we can just go back to them and again
again it depends on the context right we
cannot arbitrarily change all of them
but again just just like over overloaded
solution right type of friends just look
at an example so we have this function
interface which is again now let's say
this parameter s type and what we have
on the left is an anonymous type again
it has a type argument integer and when
you go to rewrite this to lambda this is
how it looks like and it's nice it's
concise it's crisp but it doesn't have a
lot of information it doesn't have the
functional interface it doesn't even
have the type argument so how do we know
you are dealing with integers right so
how does it solve work again type
inference or type inference engine had
to be completely rewritten to support
this kind of cases we had to collect all
the available information you know not
just the function interface you know if
you have parametric types even if you
have diamond instances all of them had
to be resolved
okay default methods you know that if
you have used in Chaves see if you have
compiled Java see you know you know that
it works even with 1.7 moon but we are
gonna reject that code if you have code
that have default or static methods and
you trying to compile it to 1.7
compliance level you won't be able to
compile for you I mean it said it's an
intentional behavior but Java seed
continue to do that but it really I mean
we cannot do that right what happens in
the you know you 1.8 JVM has method
you're looking for so I mean seven
doesn't define the specification also
doesn't really doesn't really specify
anything about it so again we had lot of
discussion with a lot of discussions and
back-and-forth arguments with the the
Arabic team as well ultimately we
decided to desire it to stick with this
behavior alright so uh back to the
tooling so this is how an example of
code completion looks like what you have
on the top is Java 7 volt you have a
simple method and you're trying to
complete on the string so what happens
when you try to compile do a completion
so when do a completion the code you
have is always broken invariably it's
broken right obviously then you have an
incomplete code it's broken but we have
a recovery mechanism in place that would
you know create the ast in a way where
you can go ahead and resolve and produce
the completion that the user wants so
the completion is going to look like you
know you have the string which is
already there as the method argument and
the type is available and there's no
problem in completing it there is no
problem in you know providing the all
the methods that are part of string
again no for lambdas we not only have to
recover the lambda expression we also
have to recover the enclosing context as
well this there could be a lot of
information from the context that
defines the lambda so in order to
resolve the lambda completely you have
to notice all the contexts as well
normally in Java 7 world we don't you
don't actually look at the body the
record doesn't look at the body whereas
for lambdas we have to look at the body
because that has a lot of information so
this part again had to be rewritten as
well so these are some of the two links
not all of them again so on the left top
is an example right so really what we
had in anonymous types you had whatever
you had in five lines of code now it is
you have made it to one line it's all
nice but it for somebody looking at the
code no you not written the code
somebody is looking at the code how does
one understand that and that's where the
the tool helps you you know just place
your mouse on the arrow and the Hauer
will tell you what functional interface
is dealing with
it also tells you what method you're
dealing with and if you see the example
I use the function interface is a
parametric type with the generic but the
Hauer also tells you that the deduce
type is integer and that the top middle
the method references again you have
code completion support for method
references so basically it just looks at
the type on the left and just offers all
the suggestions we do have debug support
of course I'm going to demonstrate some
of this and we have lot of search later
functionalities as well you know how the
type hierarchy have the quick type
hierarchy you have the you know find
implementing methods
you know this classic search and if you
are moving from Java 7 code if you want
to convert your lambda expressions to if
you want to convert your anonymous code
to lambdas we also have quite a bit of
support for that we will again take a
look at it in the demo again this is
just like Howard you know you can just
just a ctrl click on the arrow it will
take you to the Declaration of the
function interface right now analysis
I'm sure anybody has written in Java
code would have definitely seen or
created a null point exception right and
I mean I I always wanted to know how to
do that I mean simple if it's a simple
code it's fine you know where an object
is created where it's dereferenced you
just go ahead and look at that code and
you fix it in a complex project it's not
always possible right up object is
passed around and you never be sure what
it's going to be is it null is it not
null never be sure so that's where this
null analysis especially the type
annotation based on analysis is going to
come in handy because the annotations of
support in multiple places we can have
collections with parameters types and
the parameters the type parameters can
have the annotations and these are
nothing but APA contacts so just look at
the the second parameter so we have a
list of malleable string what it means
is that the witness list can have null
elements in it and we do have another
example there the local variable Li
right so that is a non null list which
means the list cannot be null and it
also says that the elements cannot be
null and if you so this is again a
contract so you're saying that no the
list cannot
the elements in the list cannot be null
if you're trying to violate them you're
gonna get an error again that it also
depends on your configuration you can
configure it to no emitter warning or
error or just ignore them you want so
there are different types of warnings
there right so the second line we look
at it so we're trying to add another
element to a list that does not take
null elements so you're gonna get an
error for that and in this next line
you're trying to dereference an l1 with
an unknown list so that's the least list
of string but we do not know whether it
is non null string or nullable singh we
do not know so you're gonna get emitter
warning there you know we're trying to
assign unknown list with a non L string
you know we don't know what what it is
it could be normal
it could be null right so we are not
sure so obviously we're going to report
that problem and the next line obviously
we have nulls we have an on a list and
we're trying to differences with
nullable list that's a problem we just
cannot have you know that in that kind
of assignment so again you have another
example so you can all let me just play
around with it there are quite a few
options they can't figure them all and
play around with it I will also just in
the demo we'll talk about how we can
configure it okay
keeping up no I mean I was not surprised
that lot of people thought that it gives
a lot of didn't know that Eclipse had
its one compiler so when whenever we
change the compiler there are a couple
of things that we have to be constantly
updating our cell to obviously the
specifications right that is what
defines our compiler behavior
unfortunately we also have the reference
implementation which is nothing but the
Java C that we should compare to
most people starting out the new
language version in always look up to
Java CSD the correct one right so if
there are differences people always tend
to think that you know Java C works
alright you guys have a problem now
there are quite a few cases where either
of us actually turned out to be wrong
but people always think you know Java C
site that's the advantage of now being a
no reference computation it's not really
a loud playing field but you know that's
the way it is so again we had quite a
few cases where people reported that a
cube size bug turned out to be that Java
C had a bug in some cases the
specifications actually had a bug and
the specification had to be altered to
suit the behavior the new behavior and
so before we started out on the Java 8
project we lost a bunch of experts from
our team they all left the either the
Eclipse project or you know the ARMA
type of organization for different
reasons and really short on resources so
fortunately we had a bunch of people
chipping in and that's the beauty of
open source right so you can reach out
to people and there is always some help
and in fact we have one such person here
is the mauler who also chipped in the
right time to contribute with code
generation for lambda aside here it was
not just the code contribution that we
are really thankful for there were a lot
of people who were early adopters and
they did a lot of testing they
downloaded they bother to download the
developer versions and did a lot of
testing a couple of people actually they
download the Tarapur versions and try to
compile the entire open GFX projects and
they reported quite a few bugs and that
really helped us know especially if
you're changing the compiler and you
know we are dealing with hundreds of
different combinations of code you can
never have enough test cases
right and so that's where we really
appreciate that's perfectly appreciate
that testing effort that came from the
community so again like I said so again
I will also take this opportunity to
request you all to you know see if you
can again contribute to the Atheist
project you can contributions are always
welcome we may not be expert in Java
program or compiler water form you can
just testing like I said it's one great
example here is the team that was
involved in the Java 8 effort this again
is not just the JIT team it so this is
the India team we have people from
different parts of the world I would
like to find a couple of people here
Shrikant Shankaran he's our compiler
expert and he did a lot of heavy lifting
for this project for the compiler
support and Stephan Herrmann is again
our he's been a committer and geodetic
over 400 years he was responsible for
the type reference engine implementation
he so he was solely responsible for
rewriting the type of reference it was
for me which proved to be a really
complex piece all right we'll take it
demo unfortunately some issue with my
computer so well hope it worked all
right
so again this is some of the things that
I talked about in the presentation so uh
so just looking at this code right I
mean it's really impossible for somebody
reading the code to figure out what's
going on here and it might be even more
difficult it is you know if you don't
have what you have on the left hand side
what if you're invoking a method so and
that's where this is handy right so you
just look at it and like I said it not
only finds out the function interface it
also tells you what method you're
dealing with it also tells you what
basically it reduces that the type
parameters while we're here there is
also one format settings that I like to
show
there are some form of the settings that
you can use to write lambdas the way you
want so now if you want to have you know
space before and after the arrow you can
have this and if you want to have the
lambda party either the same line or
next line and how all that
so right now I don't have really space
around this arrow so I'm gonna do a
quick formatting so what happens so that
works well again it's not just the hard
it's also the open declaration you just
place your mouse there and to f3 it
takes you to that single abstract method
so these are the things that people I
mean it's it always work you just said
people expect it to work when there is a
new feature right so this is a new token
and we had to make quite a bit of
changes to accommodate this all right so
you starting with an existing project it
has a lot of anonymous types all over
the place and you want to you think it
would be nice to have them as and us
what do you do so we have some
refactoring options for you just place
the most and do control one and you get
this off nice little option of
converting your lab anonymous tool and
expression alright so there you go and
by default it's always the shortest form
that you get but if you want you know if
you don't like it you want the
expression to be a blog you can do that
as well
or you can again go back to that or for
some reason if you do not like the do
not like to have a lambda what you can
do is just select all of this and you
can extract it to method there you go
again it does all all those things like
no understanding what type of dealing
with and you know that you are in
working from a static method it also
puts the static keyword for the new
method that's all the for you okay so
let's undo whatever changes we did back
to I it was all right what do you have
here we have another lambda and just
looking at we have two oceans of go it
so one takes a number operator and the
other one takes string decorator and if
you're looking at look look at the
method argument they somewhat look
saying with just that
what is the string debated yep it is and
number operators that's a functional
interface too
so again the competitors all this you
know figuring out for you you don't
really have to break your head on that
just however you know that you're
actually dealing with number operator
now I have another lambda I have problem
with this what's wrong here so I have an
AM biggest problem so it's so basically
the compiler just gives up I mean it's
not able to find out what GU I want to
be invoked why is that the the goose the
methods that goo this one and this one
they look identical to what I had in the
previous example but there's a
difference if you look at it this do it
right so it takes the same arguments as
the the number operator so obviously
there is a problem so with the given
information the compiler is not able to
find out what go I'm dealing with
because whatever I have whatever
function interfaces I have whatever
Sam's I have they both have similar
signatures so the compiler this gives up
once a is not throws up its hand you
know you have a problem you deal with it
all right um again the method reference
talked about also provide code
completion for this again the the Hauer
works alright the open declaration works
fine
okay so I do have another lambda which
is well if you don't have a lambda here
but what we have is an anonymous types
but I have two methods here not only the
implementation to the Sam but I also
have another method that I had it coming
it doesn't overwrite anything but
there's nothing stop stopping me from
having another method here right we
looked at it in one of the slides so
this is not a potential lambda candidate
and you're trying to convert it you're
not going to get that option so now okay
so you're going to take a big project
you don't want to convert all the
anonymous one by one you want to convert
all the anonymous types no one go how do
you do that we have a clean up option
for that show you where it is go here
edit so convert so there is the option
convert function interface instances to
either
nanyem class or you can use lambda
wherever possible right so we have quite
a few examples of non-evos right now we
only have a couple of them okay we have
one here we also have another one which
is not quite a lambda so if you right
click on this project and say source
clean up
you know that only one turns up the
other one doesn't because it's not a
lambda I mean it cannot be a lambda
because it has implementation for other
methods as well right but if you have
multiple candidates all of them will be
converted to lambdas you don't really
have to change them one by one all right
so I talked about different versions of
search and type hierarchies right so so
you have the function interphase and you
do want to look at all the types that
are implementing these number interface
right number operator so everything
appear here the lambdas the anonymize
all of them because all of them provide
implementation to that function
interface they appear here all right you
don't have to always use the type
hierarchy you can also use the quick
hierarchy just pretty much the same or
if you want to look at the methods that
are implementing this do it and do it by
just looking at the implementations like
this
or few let's say one search for method
references right how do you do that I
want to look at the look at all the
places where compared to is used and I
can look for with the references
specifically if I want so that brings
out this this
so here is the analysis example he was
pretty much similar to what we had in
the slide but do you know that okay so
how do you set it up so I actually
wanted to show you that as well go to
the project
so this is the option that is
interesting to you right enable an
annotation based net analysis there are
quite a few options you can configure
them to the way you want and how do you
configure the neural specifications know
looked at these annotations right non
null and null this are part of Eclipse
IDE this is one of the plug-in but if
you want you can use your own annotation
there's nothing stopping you from using
your own annotations if you want to
change that just go here to the
configuration and just make sure that it
is in the bill path browse and set to
whatever you want this one right let's
say you do not want your code to be
littered with all this you know none'll
null null everywhere right I just want
to get it up all these things
right so this enables the normal factor
on the entire analysis type if you want
it to be disabled
oops okay so you only have one yep sorry
so once you have this you can get it off
all the things you don't need any of
them
I already have an example here so anyway
so so that will help you get rid of all
the clutter if you really want to use
Malkin Alice's you can start at least
using this in your api's your contracts
very expert your code to be used by your
clients not just to external code so it
will really be handy in those cases
alright that's pretty much what I wanted
to cover you have any questions so how
do we identify how do the lambdas appear
in the debug status they certainly don't
appear like nonnamous types I can
actually show you an example you want
it's kind of interesting
let's go here so I'm going to put a big
point here I already have one fact so
you step into this so here is an
interesting factor so you can look at
all these things and this is what you
see here if if you if you're having an
anonymous you would also see that it has
at this and that is missing here so that
shows that this is the implementation is
again different from nonnamous
yep
there you can see
thanks but I but I believe you can you
know some of the captured information
right justjust let's see what happens
here it's right the lambda of reference
is something outside so in that case you
would actually see that the referenced
the factor right so that would be part
of the implementation it passed as an
argument right yep
now if you look at this one
we have this starts being passing
argument
yep
which was now using I believe it's for
four right so we have fixed the quite a
lot of bugs in this particular area so
we know we knew that this was one of the
problem areas especially in the code
completion part the last two months we
have fixed quite a few bugs I would
encourage you to you know download one
of the recent builds and you should see
most of this problem go away
absolutely right I mean is there any
particular reason why I would want to
use a different compiler
you I mean if you're using the latest
version of a Clio now we hand because
every time you get eclipsed you get the
compiler latest compiler right but if
you are if you for this JDK that you
want to use well that that's no it's not
something really a thought about but
there's a lot of people who use ant and
maven and directly using a JDK to
compile their code and that is something
that you always have that option is
always there with you
you have no questions thank you very
much for coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>