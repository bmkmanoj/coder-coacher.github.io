<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>MongoDB for Hibernate/JPA Developers | Coder Coacher - Coaching Coders</title><meta content="MongoDB for Hibernate/JPA Developers - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>MongoDB for Hibernate/JPA Developers</b></h2><h5 class="post__date">2015-06-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/uIi6vZyhJeg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Justin Lee I'm currently a
member of technical staff at Mungo I
worked on our MongoDB I work on the Java
driver in morphia which we'll be looking
at both today among a few other things
I've been with Mongo for about four
months now
and when I originally wrote this I
actually wrote this at my previous
company and it was a nice community
driven
I like Mongo so much here's and I just
made this leap myself I would wrote it
to help people and now it just feels a
little bit like a corporate shell
pimping the corporate product but I did
write this because I do love Mongo and I
actually do love GPA I spent most of my
career working with Java EE in one form
another I was on the GlassFish team for
a while so Java EE is near and dear to
me but I made this transition a couple
years back and it was an interesting one
for a number of reasons and so I thought
I would share a little bit of what what
I learned in that so just briefly Who I
am and why you should care I've been
doing drama for a long long time
MongoDB I worked on those guys and I've
been doing EE since 98 actually I say
ish because I actually worked for a
company that built their own application
server before Java EE 100 was was
finalized and we actually built our own
ORM so this is actually not my first
time around mapping objects to databases
but I try to forget that experience
happen because it was it was not good it
was way before even hibernate and even
hibernate did it way better than what we
did so anyways with that out of the way
let's talk Mongo how many of you have
used Mongo played with it how many of
you use it at work yeah that's great to
hear
well for those of you new to it Mongo
actually name derives from humongous
which means big for those who don't
speak native earth English or slang
natively I always think of Mongo from
Blazing Saddles personally like Mongo
hungry but it does come from this other
thing which is less interesting in my
mine
but it is a scalable high-performance
open-source no sequel database which is
a little buzz wordy but no we're not a
huge fan of the no sequel label because
no sequel means anything that doesn't
use relational and there's like eight
different popular ways of doing things
without using relational most of which
have no bearing on each other but that's
the segment of the market that were put
in so that's what we're running with the
kernel itself is written in C++ we have
drivers like 30 different languages ish
only a handful of are actually
maintained by MongoDB itself which means
that most of our drivers are community
supported which is awesome because it
communities involved but depending on
the language you might see varying
levels of support it is a document
oriented database and what that means is
that in a relational world you take
apart your data and you put it in a row
so everything looks like a big
spreadsheet you have rows and columns
and each cell on that row is is some
sort of piece of the overall document so
whenever you pull your object out of
your database you have to then put
everything back together in one large
blob whereas Mongo stores them in a kind
of a JSON e format it's not technically
JSON at the shell level because JSON
requires all keys to be string quoted
and we don't so are a little bit more
lenient on that for them but for the
most part if you know JSON you're gonna
be comfortable with what's in what's in
the shell internally it's actually
stored as V song just binary JSON and
there's a spec for that if you're if
you're in that sort of thing but it is
fully indexable suite we support a
number of indexes from your traditional
we want to index your strings we also
support geospatial indexes so you can do
all your geo queries we have a number of
new operations in 2.4 for that we also
support text searching as of 2.4 and I
believe don't quote me please I believe
that in 2.4 it was kind of like here's
something you might want to use and and
in 2.6 which is due out in just a couple
months it'll be here something you want
to use
so the difference is mostly in the tone
of voice and it works in 2.4 I've not
heard anyone complain about it not doing
quite what they need but we also support
replication and high availability and in
um in different ways the most common use
case for most people will just be using
replica sets and it is a master
secondary setup so you write to one
master and you can have I believe up to
12 secondaries for various mathematical
reasons when failover happens if you get
to much larger the algorithm to elect a
new master it gets very very complicated
so um but still 12 replicates 12
replicas set members is it's a pretty
large system and we support H a through
starting which if you used most of them
most of the relational databases support
some form of sharding where you take a
chunk of your data however you define
your shard this chunk lives here and
this chunk lives there and another chunk
lives over there and we support a tag
based starting so you can tag your data
and it goes to certain shards and we can
also we can also start it such so that
your data is geo-located with your users
so if you wanted to char it across all
your Australian data stays in your
Australian data center and all your
American data we can actually do that
that has a few issues if you have a
highly mobile data set if you're
tracking people's information and
suddenly they go from Australia to
America can cause some problems because
shard keys have special constraints on
them such as they can't be changed once
set because it confuses charting but
that's a whole other discussion that you
should have with one of our solution
architects when you go to shard we won't
get that here we also support MapReduce
and as of two four I think it went in
aggregation framework MapReduce if
you're familiar with Hadoop or anything
like that it's that's your typical
MapReduce you can run in Mongo itself
it's not the preferred solution simply
because JavaScript the internal
JavaScript is single threaded and
there's some performance issues but it's
there if you want it and it certainly
works a better solution is the
aggregation framework
which supports a number of different
operations you can project and group and
filter and count and sum and average and
mod and all sorts of things I mean you
can do all that within the database
itself so you can do complex analytics
on top of your data
native to Mongo itself we also have a
grid FS which you may or may not find
interesting but it's actually a file
system built on top of Mongo so that
your data actually lives in a Mongo
collection and you can shard it you can
replicate it you can do all sorts of
interesting things
again I don't I don't know too many
people that actually use grid FS but it
comes up from time to time I've actually
had request to add grid effects or more
grid FS support to morphia I'm not sure
what that's going to look like because
morphia deals with objects and files
aren't typically objects but someone
wanted it so we're looking to it so
document oriented so in JPA you
typically have one object mapped across
the row and if you have embedded objects
for example then you can have whole
chunks of your columns that are just
blank because nothing is there right
because you don't always have those
embedded objects and it gets more
complicated because what if you have an
array of these embedded objects doing
that inside one row is virtually
impossible because then you'd have to
have a whole set of columns for each
possible element in that array and then
of course that gets ridiculous because
you could have a thousand of these
things inside your object um but in
Mongo it's just it's just a JSON array
no big deal so they're stored in JSON
style as I mentioned they're actually
internally it's beasts on which is a
binary kind of a binary encoding of JSON
which makes it simplifies things like
finding where the string ends in JSON
you just kind of have to here's a quote
I'm gonna keep reading until I see the
last quote and that's my string in
beasts on we actually encode the length
of it so when we see this string start
making say oh I'll just jump ahead 48
characters and grab the rest of string
and it makes retrieval much much quicker
there's the spec if you're interested in
how formats are laid out beef on spec
and you may or may not find that
interesting but it's out there so yeah
it adds a little bit of extra data so
what does it document look like this is
a basic query in a user's collection
we're gonna use the find operator and
Mongo supports the dot pretty function
modifier I forget what they call it
otherwise this would all come out on one
line which is fine if it's a short
document but complicated documents
become really hard to read that way so
that's what it looks like you have your
ID your ID is always called underscore
ID this is the primary key it can be
whatever type you want to be it can be
strings I mean numbers it can actually
be nested documents if you want it to be
the default and my preference personally
is to use the object ID the object ID is
something come that comes from the
beasts on library it actually provides
globally unique and distinct always
incrementing monotonically increasing ID
numbers it uses components of the
machine name and the time and a couple
of other things to make sure that if you
create two object IDs at the same time
on two different machines they'll never
be the same so it's kind of like having
a global sequence in a relational
database without happened to actually
set that up so that's what it looks like
addresses as you can see there is an
array we could have a million of those
addresses and we don't have to change
our schema at all
where is as in if you were in a
relational database you would end up
having to have a join table or at least
the next none necessarily joined table
because it could just be an external
table but certainly if that was mini -
meaning you'd have to have a joined
table but in this case there's just one
document because we just store whatever
you give us so replication and high
availability and I believe the the party
line is that it's eventually consistent
I don't want to belabor the point
because it's not really my area of
expertise but I've always considered to
be strongly consistent although there
might be some lag so I suppose that's
technically eventually consistent but we
do whenever you replicate across we do
track the last time and if things get
out of sync it will
catch up to where it was and as I
mentioned this primarily through replica
sets and sharding all right we're gonna
do some examples of queries in the shell
just to kind of give a feel for what the
shell looks like and then we're gonna
take a look at some code so there won't
be too many too many actual slides and
so this is a simple query to find all
the orders and hopefully and I ran the
right test so that we have data who
cannot see that shell everyone can read
that let me put some text so you can
actually see it I can't read that
what can everyone read that I can't see
the side things all right no one's
yelling someone assume you can all right
so we have the product orders collection
we're gonna look to find this says find
me all the documents whose fulfilled
attribute is true and in our case we're
going to do a limit of two and again
we'll call pretty so I can see that
scrolled by pretty quickly there's a lot
of a lot of data in there only four even
with only two objects in this case we're
actually using morphia to serialize
these so there's a there's a couple of
more for one morphia ism in there for
the class name and we'll look at that in
a minute but if we were to do this
without the pretty command what you
would see is that which that can be
useful in some cases but clearly it's a
little bit more difficult to read and so
I almost always do that not pretty so
that's just simple find we also want to
see it's nice you can do multiple
criteria so here we're gonna find we're
gonna find a query again that's
fulfilled but has three items in the
order and in that case even though we
did a limit to there's only one such
document in the database if you if you
just list items like this it's an
implicit and if you wanted to do
let me see if I can do this without
messing up if you wanted to or it you
would do something like this I believe
this is the right syntax I mostly do it
for Morpheus on my shell syntax it's a
little rusty oops uh unexpected token
yeah and then to put it there there we
go so that did an or so now we got back
I guess just the two because we did a
limit the syntax looks a little kind of
wonky it took me a while to get used to
it because I I've done sequel since
since I started using databases it's
actually not so bad it's a little almost
kind of prefix e notation so if you're
used to that and if you think about it
in those terms it it doesn't take long
for just for to start feel natural
although sometimes when you go to set
something it feels strange
so let's say now in an order it has a
list of the products in the order and we
want to find items with the name in one
of those two values that is what an
array search looks like so if we come
here
stop going to the IDE if we come here
and say give me that as you can see we
found one order that had a product quad
Tech and vile ox I actually generated
these names of it there was a webpage of
it generate random names because I
wanted stuff to put my database so they
don't make sense like that last one is
the exam nick's totally random so trying
to try not to read too much into them
but as you can see they all have name
prices and IDs we actually if it when we
look at the code later you'll see that
product is actually its own object and
its own collection but when we created
the order we put those inside the order
object and then stored it so they
actually got stored as new documents
inside this new document inside a
product order so now technically there
are two separate copies of the product
object and that can be handy I'm not
saying as always you should always do
that but it can be handy if you wanted
to
I'm stamp like when we place the order
this was the price and then later that
price can change that's just a little
side effect I'm not really trying to
make a statement one way or another
about what you should or shouldn't do
there you can also do this which is kind
of a variation where we're just looking
for products with any one of quad tech
and in this case you can see it actually
brought back the whole document with all
three it found that first product with
the name of quad tech and said this is
my guy and sent it back so it's very
similar to the query array that we just
did but it did a single match instead
just show that you can you can recur
stem through those document properties
as deeply as you'd want to get and I
think oh we have one more
oh here's the ore which already showed
you so I'm gonna skip that one and so
updates if you wanted to change this I'm
not sure that done that yep okay so if
you wanted to change a product it's not
what I told you that might be fine oh
sorry my script is just messed up I tell
you what it's over here no no no I'm
sorry I know I know what's wrong I
actually wanted to show you before and
after so I am an idiot but for other
reasons alright so moving on don't mind
that so this is the document I wanted to
show you what it looked like before just
so that whenever we do this the actual
update we have something to compare it
to damn what's gonna work so now and of
course it copied everything that I
wanted to yes I did so this actually is
a compound statement we're going to take
we're gonna update everything that has a
size of 3 so update takes two parameters
it takes a query to find out which
documents to an update and then a set of
operations to do
and each one is a separate document so
in this case we're gonna find everything
a size three and we're going to set the
total to 400 and I'm pretty sure that
total is not it is in there okay so I'm
gonna set it to size three all right
total 400 say as you can see at the
bottom in case it's over everyone's
shouldn't be hidden behind anyone's head
now as you can see now the total is for
this particular order is 400 someone
just got a great deal on the exam Nick's
so those are the updates you can do you
can do a lot more than this set you can
do increment you can do this and that
there there are more complicated
examples called find and modify which
will do kind of in object stuff it's a
little bit cleaner syntax if you want to
do that approach in this case there's an
operator called push and this lets us
add elements to a document in this case
we're going to push the color red into
the bobbles array bobbles does not
currently exist but so now if we do find
three you can see up at the top there
there is a new element in the air a new
property in the document called bobbles
with an array of documents with one
element with a color of red so if you
want to add structure to your document
after you write it you can do that way
there's also the the inverse operation
you can pull elements there's also I
forget the name of it put push to set I
think which will maintain if the color
the document color red is already there
it won't duplicate it so you can do some
safe updates in that regard and that's
just the thing okay so that's the brief
run through the shell there's actually
quite a bit to do in the shell the
documentation up on MongoDB de org has
all sorts of interesting things to do
but that's kind of a basic feel for it
and if you're going to be doing much
longer development you're going to be in
the shell quite a bit so now I want to
take a look at a simple application
and this is a JPA application probably
not the best GPA app you'll ever see but
it's simple enough I hope to digest in
just a few minutes so here's our Dao I'm
actually using I think juice to get
everything in here so as you can see I'm
injecting my entitymanager mainly to
save myself some boilerplate and just
amplify the application so we have a
method to clear all the orders and users
in remember I think Postgres is still
installed on this machine if it doesn't
work we'll just look at code and not
actually run it but that's okay so we
have one to clear so we create the query
to delete from product user we can
delete all the orders we can find the
user I want to look at really find user
actual query stuff because that's where
it starts getting interesting anyways so
here we're going to find the user where
the email is whatever and we're gonna
set the parameter when we get back a
single result this is everyone's used to
JPA at least once so it shouldn't be
terribly terribly alien even if my GPA
might be a bit rusty there's probably
already do that so again find product
it's a very simple thing or it gets
really interesting and where things
start to differ with Mongo and we'll
look at it is find orders over because
because relational databases are
relational you can actually do joins and
and the like so here what we're doing is
we're we're doing a join between product
order and products and we're going to
group by having a sum of whatever so
we're basically going to total up all
the prices and find all the orders with
with totals over a certain amount now in
the GPA version unlike what we just saw
in the Mongo version and we'll see why
in a minute
the JPA version actually uses foreign
keys to track the product products which
is probably how you really want to model
it
barring any sort of historical data so
in this case we actually make use of the
join we go in and we sum it and we total
it and we find everything every order
that has something over whatever total
were given and we were turn that
back conversely we find the small orders
where the count of the items in the
order is less than whatever count you
give it so whether we're looking for
orders by total or by you know anything
under three orders for example those are
two different ones now this last one
you'll notice this find by hair color
and if you were observant you'll notice
that we never saw a hair color at least
in the manga versions of it I do that
for kind of illustrative purposes idea
is nice enough to highlight hair color
oh this is right this is on users that
the users have no hair color attribute
and it actually tells you you can't do
that
that might actually compile and run but
I think actually hibernate might flag it
and we'll see why I added that in a
little bit because it's a little bit of
a silly example so the models there's
nothing fancy this is the address it's
you know getter and setter boilerplate
like we've come to expect a few Cascades
on our users product the same thing has
an ID name and a price product order in
this case we have a list of products
which we store down below as many too
many so in this case we do have a join
table
yeah joint able to link between the two
the user first name last name email no
hair color and then list of addresses
because why not you can have home
addresses shipping addresses whatever so
it's a very basic model but it's it's
pretty easy to in JPA the tests should
have a test if we run the test we can
order for Dave Jules and Bruce and then
we can do various we can find the orders
over 10,000 we can find them for first
name for Jules
all very basic GPA stuff shouldn't be
hopefully not terribly alien for you if
you're coming from a GPU background
know where it gets interesting is let's
look at the Mongo version of it it's the
same application the models are almost
the same here's our address it looks
exactly the same as the other one for
the most parts will ignore among entity
that's a base parent class for various
things mainly to make the code for the
demo cleaner the product again name and
price the IDS in the parent class again
but product order is where it gets
different because we don't have the
ability to do a join in Mongo because
Mongo doesn't support joins it's a
document database right our model
changes a little bit and it doesn't have
to change in this particular way but I
did it primarily because it kind of
highlights at least one one choice you
can make to do that and in this case we
list we still have the products but as
you saw earlier they actually get see
realized with our order our document but
then I have to include our choose to
include double and total a size in total
inside the order itself so that whenever
we're creating our order we actually
update those and store those values as
explicit properties on the document and
this makes our query simpler in part
because we can't do a join and yeah and
for any other reason we're good to so
what does our Dao look like look like
now there are there are a few different
options that I that I'm gonna show you
today yeah that's enough
so we're gonna look at some raw driver
queries which I've talked to a friend
who's actually using the raw driver and
doesn't mind it so much so it's doable
but it is it's not my favorite way to
write code we're going to look at
morphia which as i said when i wrote
this presentation wasn't as self-serving
because i was just a user of morphia but
now i'm the maintainer so it's now i'm
responsible for that as well so so we'll
look at the Mongo driver morphia and
there's one called Jango
which is a third party community library
and what I like about jungle and what
we'll see is that if you're familiar
with the query shell syntax if you like
the curly braces and this and that and
you like writing JSON you can actually
write that same query in Django and it
will it will wrap that up and send it
off to the database as it is so it means
it's just one less query language to
learn and for the most part it works you
can do regular expression queries which
is another way we break JSON and that
also happens to break Django because to
do a regular expression query you would
say whatever the property name is so
name colon and then you do in slashes
whatever your regular expression is sort
of like you would in a sed stream but
those slashes are not valid JSON so if
you send that through a JSON parser it
just explodes and stops working and so
will John go if you do regular
expression queries but if you don't do
regular expression queries then you're
gonna be fine they're not terribly
common for complexity and performance
reasons because rate expressions aren't
that great so we'll look at jungle and
then I have a couple of examples
this is totally self-serving I wrote a
layer on top of morphia called critter
which is a play off criteria Mongo or
morphia sells itself as a type safe
library and for the most part it is you
have queries of product he occurs of
users and everything is kind of type
checked but whenever you're doing a
query you would say dot field and you
pass in the field name and whatever my
happen to be but it's a string and we
validated at run time so that when you
try to run your query it'll say you
asked for you know whatever but that's
not an actual map property of user so it
validates it but it does it at runtime
so I like I like to call it unofficially
unofficially type safe-ish and because
there are a few gaps so I wrote critter
to help address some of that and we'll
see why it's a little experimental and
I'm not sure it's quite the right way to
do it but at the moment I think I'm the
only user of it so if I break anybody
it's just me but so far it seems to work
but we'll see we'll see what that in a
sec
so the interesting query if we let's
look at well this is using the Mongo
driver if you wanted to save an object
in this case we have a base class Mongo
entity which is mainly to reduce code
because then I can just pass in whether
it's a user or a product they all extend
Mongo entity and because Mongo entity
gives us the ID basically and that's
really kind of all it gives us
I cheated and I added some stuff like
that to get out of the DB object DB
object is a core driver class it's kind
of map ish
I think it might actually implement map
you can treat it like a map but again
it's string to object and it's not it's
not the nicest way to work in the world
but it works so in this case we're going
to create a DB object of product and not
what that looks like is this we're going
to create a basic DB object which is the
basic subclass DB object is an interface
I believe yep
and in this case I cheated and I wrote a
to map which just creates a map of all
the product properties and then of
course since DB object is a map you can
do a put all on DB object and it just
works so but that's what it would look
like if you see realized here again you
put underscore ID for your ID in the
name and price those properties can be
whatever you feel like they are or
whatever you feel like you want them to
be but in this case that's what we're
doing so so then we save we're going to
get the we have to get the collection to
save it from from the entity class I in
in this demo code I'm actually slowly
building up a subset of morphia which
made me sadder the more this code went
on but it's all for demo purposes so you
want to get the collection from the
database and then once you have the
collection you can tell the collection
we're going to update in and for
products we're specifically doing
updates for a number of reasons
we're going to give it the ID so here's
the query in this particular API no wait
that's gonna give us DB object in this
one so a DB object Q if you can can
anyone read that is that too small I'm
not sure I can make that part bigger I
think it's just the text itself but
anyways you're not you're not meant to
get too familiar with it because I'd
rather you not use it directly but some
do so it takes two DB objects once a
query and that tells it this is the
object I want to go update then there is
the DB object OH which is the properties
which are the operations to perform on
whatever document matches that query in
this case we're doing
they'll just be straight sets because
it's just property value property value
those are implicit sets on the resulting
document and then it takes a few other
parameters we're passing in true and
false the true is an up cert which is a
clever little amalgam of words it says
update the objective it's there or
insert it if it's not so there's not a
whole lot of point in doing this for
objects or for a product directly but it
shows off the upstraight functionality
the the second one is the one you're
really going to want to pay attention to
if you're doing updates
it says multi the default when you do an
update is to update the first object you
find the idea is we don't it was made to
way back and I'm not sure why but the
idea is if you do an update on a very
large collection and your query is
accidentally too large and suddenly you
thought you're updating three documents
and you're bidding three million that
could be expensive because the the
collection or the database right now but
the database the whole database is
locked during a write right now right
now into for every write locks the
database soon the collection will be
locked we're slowly pushing the locks
down into the collection but right now
it's a at the database level for a
number of technical reasons so with this
multi if you don't pass in true it will
only update one document which maybe
that's what you want
when I first started using Mongo it
would always it always come back to bite
me because I would never pass in multi
true and I had to go back and have to
rewrite my query and rescind it because
I really wanted to update everything in
the collection so that's the one that's
probably gonna most important the last
one which is optional the last one of
interest anyways just the right concern
there are a number of write concerns
available in Mongo and what that means
is how interested are you in this data
making it to disk before it returns in
times past the right concern used to be
unacknowledged which means that the
driver would package up your request and
it would stick it it would send it on
the socket off to the server so you can
be sure that your request left the
driver and left your application and
it's on its way to the server but after
that don't care we're moving on that was
the default right concern for whatever
reason it is no longer the default right
concern even though there are a lot of
blog posts that still are all outrage II
that we're doing that the there's a
number of different write concerns
there's you can depending on what your
cluster setup looks like usually what
you're going to want there's a there's a
safe which means that it made it to the
server and I got written to disk or at
least written to the journal there's an
F sync which means I got written to the
journal and to the collection you can
have it make sure that not only did it
write it to my to my master machine but
it also replicated out so if you really
really want to make sure that your data
is safe you can actually have each
operation wait until it makes it to the
server and the replica sets and that has
certain advantages of course but on the
other hand it can also be very very slow
if you're doing a lot of that because
replication can take a while for a
number of reasons so anyways that's a
lot of detail for just updating a
personal object in the collection so
that's what the driver looks like for
that extract collection this is all kind
of maintenance stuff for the demo so to
find a product you create a query this
is a
surely using these are morphia queries
because the driver queries are they're
just too painful so in this case we
morphe has what's called a datastore
which is roughly equivalent to a
database there's a certain metadata
around it that is encapsulated but in
this case we're when we create the data
source we're telling it we want to
create a query with a product class and
if you look at the return type of that
it says it returns a query of type
product so in theory every operation you
do is on a product but as you can see
the very next thing we do is that we say
field name and that name could be
anything that will of course compile and
run because it's a string so this is
where I was saying that it's it's kind
of type safe-ish so and that and that
bugs me and because I'm a I'm a Java guy
and like I said from way back and static
typing and compile checking makes my
life happy so I wrote critter to fix it
and we'll see the difference there but
that aside so here we're saying we're
looking for the field name and there's
this method called equal which is not to
be confused with equals which comes from
object if you call dot equals your query
will not work in fact it will probably
crash it's not my favorite name but it
was named that before I got there so a
lot of the method names actually mirror
what happens in the in the query
language in the in the shell so that's
why we get that and it doesn't quite fit
in Java but it is consistent with the
shortcut shell query so all of this
builds the query and once we're done we
can call get and that returns a single
item product and that is of course type
set type safe because what comes back
actually is a product so that works so
define orders over this is not terribly
much more complicated because we had to
wait to tweak our model right so now we
know exactly what the order price is
because it's explicitly listed on the
document we don't have to do any
operations to do so this query however I
wrote using the
the driver code and I'll show you why I
don't like doing this very much again
you create the basic DB object and we're
looking for the field total and now we
create another basic DB object to give
it the operation in this case it's the
dollar sign GTE dollar sign greater than
or equal and we give it the total and
then again we get the collection this
time we're getting the the collection
from the database because we're talking
to the Java driver directly we give it
the collection name here in this case I
just made a constant called product
orders and we're calling find which is
the exact same method as we saw in the
shell in the shell earlier and then
we're passing in our query which is a DB
object now this this is actually a
little bit more complicated than it
needs to be kind of but find does return
a cursor and then you can iterate it
across it it actually implements
iterable so you can do all your iterator
and I'm sorry so you can actually do all
your iterator like operations on it but
one thing to note is that this cursor
actually holds it literally is a
database cursor so it actually holds
resources open you can think of it as
kind of a result set in in the JDBC
world if you don't close your cursor
which I'm not here and actually it is
implement closable this is Java 7 if you
don't close your cursor either using the
try with resources or calling closed on
it you can leak resources and and that
can be a problem we've hit that a few
times so that's that's the driver
version of that query it's a little
verbose but it works to use it with
morphia this looks familiar
we're creating a query product order and
now we're gonna filter if you're if
you're doing just straight matches you
can actually do you can do this one of
two ways and in the first case here
we're doing total and then we're putting
the operator in the string which feels a
little weird but this should support
right so you can do that line one of two
ways
both those the filter and the field do
the exact same thing some people prefer
the filter method I don't know it might
be an aesthetic thing it looks a little
bit more like the shell so you kind of
get a better feel for what it looks like
it's just it's a weird syntax for me but
both are valid so anyways we're gonna
filter by everything with a total
greater than or equal to whatever total
we give it and then we're going to order
it by the total so that we're going to
get in this case in ascending order and
then we're gonna get back you can call
as list and again this will this will
leak resources potentially or the
biggest problem like this is when you
call at list it will literally slurp
everything into an ArrayList so if you
have a very large result set coming back
from your query you might run out of
memory and I we've had to happen and my
last job we had we had to switch it
there's I think it's a dot fetch dot
fetch returns in iterable and this is
actually kind of worse because that
iterable literally isn't iterable it
there's something else underneath the
covers of course but the type is
iterable so you can't actually close
that iterable and you wind up leaking
things all API works I'm fixing
hopefully so but that's what the morphia
query would look like now for Django
here's the actual query and let me
scroll it up so everyone can see it it
looks just like the shell syntax almost
except for this pound this pound is of
just a placeholder and then once you're
done once with your query string it
takes of varargs of properties it's a
little bit like string dot format where
you have percent desc % 2's % b and you
just give it a list of things to kind of
backfill your string in works exactly
the same way in this case we're going to
sort by total ascending and then we're
going with Django you have to tell it I
want to get everything back as a product
order and then once you do that you
actually get back your iterable of
product order and that's not bad it's
actually kind of nice because it
you like that if you have your query
written in the shell you can kind of cut
and paste it into your java code
dr. up any placeholders for different
values and then everything looks the
same and so that can that can that can
be quite huge especially if you're
working with kind of non-technical
people passing queries back and forth so
this is critter this particular version
of it critter actually generates code at
compile time based upon your class
definition and what's nice about that is
as you can see here we create a criteria
we pass it in the datastore that we want
to use now in this case we're gonna say
criteria dot total and total is a
generated method and it matches the
field name so there's no way you can get
that wrong because if I were to say I
thought I called it totals you can see
it actually doesn't even it won't even
compile anymore
and then like we saw earlier we have a
greater than equal method available to
you and because of the way it's
generated this greater than equal method
in this case it's a number so it's a
little less interesting but it's
actually genera fide there as well so if
he tried to pass in a date that would
actually fail to compile even though if
you use the more fee methods directly it
would compile it would probably just not
really work at one time and that's and
that's what I like about critter like I
said it's experimental
it gets really flaky when your model
changes some of that's the idea because
you want your stuff does not compile
anymore when your model changes you want
your queries to move along with your
model changes but it can get complicated
you know I'm gonna run through these
last few examples because they're just
kind of variations because I want to
have time for questions but here's
remember that hair color question you
can actually find my hair color in
morphia and it works it'll run and at
runtime morphe will print out it's like
a two line message like I'm not sure you
meant hair color but I'm gonna try this
query anyways I hope it works for you
with critter as you can see it actually
like hair color you didn't tell me what
hair color is
and then again here's a fine with the
user all this all this code is up on on
github and I'll have the link later but
I don't know belabor the point because
we're now at 45 minutes and I forget how
much time they let me have here but I
wanted to have time to ask answer any
questions you might have but before
before that here there are some links my
github repository has all that and all
that's that's just straight critter we
don't want that anyways
chop off the critter and the
presentation code is up there all the
demo code all the slides everything you
want you can check it out you can fork
it you can pull requested I don't know
what you want to but it's good hub you
can do that right but I just want to put
that up there and say if you want to
look at it more everything's up there so
you can play with it but I did want to
at least leave some time for questions
in case anyone had anything in
particular so any questions nice yes
there are no transactions in in Mongo at
all although updates are atomic so
whenever you issue an update it will
either work or it won't but there are no
multi document transactions in Mongo
right right eventually we'll have
document level locking and then that
becomes a little bit of an issue but
since since you're typically updating
one document anyways because you're your
debt your data is modeled that way the
need for transactions is less than you
would expect you next absolutely sorry
yeah yes most operations are read
operations and the locks go pretty quick
what's up they will they will serialize
and there there's a couple different
ways around that I've actually I had a
co-worker suggest putting collections in
different databases so that you're
writing to different databases which
helps I suppose if you're doing
concurrent in rise to different
collections but if you're both running
to the same collection it doesn't really
help much so that it is a little bit of
a weak point but when I am my last
company we did a CMS and that did like
millions of page views a day and we
never really had any locking contingent
there's a couple tools there's like a
Mongo stat that looked it's sort of like
top but it gives you statistics about
what's going on inside Mongo and you can
see kind of what your lock contention
looks like and how many current current
connections are it's not generally an
issue although in in theory yes it's
it's less than ideal but I think - not -
Don - had a global lock so the entire
cluster was kind of locked or I'll call
it the entire Mongo d 2.4 pushed that
down to the database and the story I was
given before I joined MongoDB was that
one
the hard work getting that from the
global down to the database and now the
rest is kind of a mechanical kind of
iterative approach to push that lock to
a finer and finer control and I don't
know when that time line is so I'm not
gonna promise anyone anything but I
believe the official answer is soon so
yes it does support text searching I'm
not sure if you quite want to do that
over instead of solar necessarily and
because there are some really high scale
tech searching things but it does it
does support text searching and indexing
for those full text squares yeah if
you're if you're doing well the only
worry would really the only way would
really matter across nodes as if you're
starting because if you're doing replica
sets you can set your it's called a read
preference to say I don't really need to
see the primary I'm okay with any
potential inconsistencies in tight in in
data I want to read from a secondary so
even if you say I'm okay with the
secondary your your search would still
happen only on that secondary unless
your sharding because all the data would
be on that secondary whereas if you
shard it then that query would have to
be distributed across wherever those
shards are so make sense sharding is a
way to tell Mongo I want to take my data
and split it up into vertical chunks is
probably the easiest way to think about
it and then I want to move those shards
to different machines or data centers or
continents or whatever and that is
useful whenever you're doing kind of
when you're when your data is highly
segmented like that you know in in a
meaningful way
you can then distribute right loads
across it for example but you have to be
careful with your shard key uncharted a
collection can be very painful
so you want to make sure you get it
right and you want to make sure that
your shard key has enough variation if
you want to char it on a boolean field
your
have two shards true and false and then
everything's gonna go into two very
large buckets so you didn't really fix
anything you just kind of split it in
half and it doesn't really get you much
so if you can segment your data and
you're having contingent problems
sharding can help but it is certainly
it's not something you just want to go
to write off right off the bat it's
usually better to see performance
characteristics and usage patterns
before you decide I want to start
splitting up my data but yeah that
helped mm hm anyone yes I can't quite
hear you and see if I can this is only
twenty feet long and told but it should
be support limit yes you can limit sort
skip I think that's nothing kind of all
you can do yeah yeah if you want you can
you can do limits yes
there's no way to go from a collection
to a class largely because among Mongo
is schema-less
so you can't guarantee that your
documents are always going to have the
same shape inside the collection but
certainly if you if you build your class
first unis build whatever class it is
and just write it to Mongo and it'll
just it'll whatever you write we'll go
into it
Mongo doesn't really care what you put
into it so if you're if you build your
model class first and then write that's
perfectly fine but there isn't there
isn't a facility at the moment to do
given a collection generate me a class
that would hold that that gets a little
bit harder to do simply because the doc
the documents can vary from from
collection from documented document
I'm not 100% sure that particular answer
I know that we have there are various
options on the the text index when you
create them and there's some
documentation that you can look at on
how to create those indexes and they may
or may not include things like stop
words the text starts to be honest I
have not used directly I just I've kind
of dabbled around it because I had to
update some indexing stuff in morphia so
anyone else let me check the time we're
at 53 minutes are we good a little time
okay right there yeah replication is
handled a little bit differently it
actually there's thing called an op log
that gets generated and replication
watches that op log for inserts and
deletes and updates and whatnot and that
gets replicated to each replica set
member so you're not dealing directly
with collections in the way the that you
normally would as a user
yeah it's a it's a special type of
collection called a captain collection
that is used for that exact purpose that
whenever whenever operations come in it
creates a log of it and then that's used
in various forms to replicate that data
out so it's a little out of band of your
normal operations this right I'm glad
you asked that question I was actually
thinking about that in the keynote
yesterday there is support if you use
eclipse link eclipse link does work on
top and Mongo it's not it doesn't have a
hundred percent coverage because JPA
does really does a lot more than what
that Mongo offers she can't do joins in
that sort of thing but I was talking to
someone over lunch and they've had
they've had decent work success using
Eclipse link on top of Mongo as far as
standardizing it's hard to say because
no sequel is that's a weird term I mean
there's like key value stores like react
and Couchbase that are technically no
sequel like Mongo but it's a very very
different uses model so I don't know it
might be a little too early although I
like to call morphia the hibernate for
Mongo although I suppose it could be a
clip sling from long ago but JPA for
Mongo but it's a very very similar
programming model in fact if you've used
GP at all morphia makes it pretty easy
to jump over for the most part apart for
modeling changes to minutes alright
maybe one more question and let's go
over here
if you have a lot of data that can be
self-contained Mongo is a nice fit a lot
of people will like to say because Mongo
doesn't support transactions so that's
like well you can't really do a banking
application on it because you have to
withdraw money here and with Drummond
and add money there and that all needs
to be transaction alized when in reality
that's not entirely how banking systems
work and in fact a number of banks
actually use Mongo for various things so
if you can do things to an aggregate set
of data that doesn't necessarily require
transactions or external references it
can be a good fit I worked for a company
called Squarespace which I only
mentioned so I can keep stop saying my
last company at Squarespace we built a
CMS so there's a lot of documents
so it's blog post portfolios with photos
and amendments in that so we would
actually store these documents they were
not huge but kind of large ish that
maintain like here's all the blog stuff
so that's paragraph this and layout that
but then we would also store external
references to you need to go load images
and those happen to live off in the file
system so in that case we were able to
model entire domain objects in one giant
document with a few external references
for images which you can't you probably
shouldn't stick into a database anyways
well it's really fast
either way Mongo prefers to keep its
entire data set into memory it doesn't
have to but certainly if you let it
loose on a machine with a lot of memory
and you don't constrain it it will try
to read everything in memory certainly
the indexes it likes to keep in memory
because the less you have to page out to
disk the better so that help kind of
feel like I lost the Train there and
half way through okay I think we're
officially out of time but I'm happy to
answer questions if you want to come up
and I'll get out of the way for the next
group thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>