<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JavaScriptサーバー・スタックの最新動向 | Coder Coacher - Coaching Coders</title><meta content="JavaScriptサーバー・スタックの最新動向 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>JavaScriptサーバー・スタックの最新動向</b></h2><h5 class="post__date">2017-08-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/HSlykVP07ps" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everyone konnichiwa welcome to
this session on the modern JavaScript
server sec my name is Prateek patel i'm
a java champion and I'm also the
president of the Atlanta Java user group
which is funny because I was talking
about JavaScript here but what I want to
talk about this session is the
technology that we use at my company
called trip lingo we're in the travel
software space we build apps for people
coming to foreign countries like Japan
and we have a fairly extensive stack of
different technologies that we use so we
use Java groovy Ruby Android native
Android native iOS and also quite a bit
of JavaScript for web projects and other
things on the server so that's what
we're here to talk about with all the
different tech that we use all the
things that are on the slide for example
it can be a bit challenging wearing a
lot of different hats trying to go from
one technology to another as we're
building out solutions and what I want
to do in this session is discuss how we
bring all these things together and how
we incorporate JavaScript as part of an
overall server strategy okay so when we
think of the Java stack we have this is
an older diagram you can see this is
based on Java EE but when we think of
the Java stack we think of it as
basically middleware between our
database and our front-end and this is a
similar type of thing that we have for
our JavaScript stack all right and also
what I want to talk a little bit about
later is how the JavaScript architecture
internally is different than what it is
on the JVM so you're probably familiar
in the Java Virtual Machine so this is a
model for a servlet instance or what we
would call a web application and the way
Java works and it's threaded models that
you have requests
request gets translated into threads and
are serviced by a servlet instance so
this is different than what we have in
JavaScript as we'll see in a different
diagram in a few minutes so let's talk
about JavaScript first how many people
are JavaScript developers here quick
show of hands okay so a few people we'll
get into some of the more interesting
architecture stuff in a few minutes but
let's talk about some basics first first
of all why are we interested in the
JavaScript on the server we'll get we'll
also talk about the ecosystem and then
have a look at the tools in the
JavaScript server space but first let's
talk about why when we think of
JavaScript or yesterday's JavaScript
JavaScript from five years ago or six or
seven years ago a lot of people would
consider it to be like a toy language or
baby language but that was five or six
years ago today when we think of
JavaScript we think of it as the cool
hip language but I know this is supposed
to be amusing but when we think of
JavaScript today we think of all the
different things that we can do with
JavaScript on the server
of course javascript is in the browser
already with all the different
frameworks for building web applications
but JavaScript on the server is actually
something that is also very popular and
it's used by big companies such as
Amazon and Walmart and Netflix and other
people like that again this is
JavaScript on the server that we're
going to be talking about predominantly
so yes it is cool and it is hip today
but is also an enterprise-grade language
for building solutions on the server and
we'll talk about why in a few minutes in
terms of what's changed in the
JavaScript world to take us from let's
say a baby language to an
enterprise-grade language quite a bit
has changed however the language itself
javascript hasn't changed much in 20
years so javascript is about
20-something years old now right it was
invented in 96 97 language hasn't really
changed much up until very recently with
es6 and es7 the new language specs where
they introduce classes and various
different things for handling
asynchronicity
such as proxies and other things like
that they think await in es7 so but at
the core JavaScript hasn't really
changed much in the last 20 years
what has changed however is the way that
we as developers approach JavaScript now
when we think of building stuff in
JavaScript whether it's for the
front-end or for the server we think of
the different best practices that we use
using a linting tool for example having
unit tests and integration tests around
all of our JavaScript code right to get
good code quality we run things like a
code coverage tool to make sure that our
tests have enough coverage around all
the different parts of our application
code the other thing is the tooling has
gotten much better in the JavaScript
space so now we have great tools for
checking JavaScript syntax right es lint
and J's head for example tools like
Istanbul which allow us to do code
coverage lots of different types of test
tools such as tape and Jasmine and other
things like that so the tooling has got
much better in the JavaScript space but
one of the key things that's really
improved is that JavaScript runtimes are
much better than they used to be if we
look at the JavaScript runtime
specifically for nodejs or what's built
into chrome which is known as v8 the the
v8 one time is almost as fast as the
Java Virtual Machine nowadays because
they do a lot of low-level things that
the JVM does the Java Virtual Machine
does to be able to execute code very
quickly so the runtimes have gotten much
better over the last five to ten years
in the JavaScript world right what
hasn't changed in the JavaScript space
however is that JavaScript still has
some nuances and have some bad parts
that you have to avoid but with tools
like es length and J's hint you can
write rules that enforce a specific
style of code and to also avoid some of
the bad parts of JavaScript
another thing that hasn't changed in the
JavaScript space is that JavaScript is
still very much an asynchronous
event-driven language right so when we
write JavaScript code a lot of times we
have to put things into a callback well
we execute a specific JavaScript
function because that's what that
function expects but that is
asynchronous code and this is one of the
challenging things of JavaScript even
today so but it hasn't changed in terms
of the internal architecture which we'll
talk about in some more detail and of
course every browser still supports
JavaScript alright so there's one main
reasons why we do a lot of JavaScript
for the front end is because every
browser supports JavaScript it supports
it really well but what we want to talk
about is JavaScript on the server so
when we think of JavaScript outside the
browser and we want throwing down the
script on the server what we have is
something called nodejs and that is a
tool built on top of Google's v8
JavaScript runtime it's a super fast
JavaScript runtime probably the fastest
one that's currently available it by
default is included in Chrome web
browser but some clever people about six
seven years ago took the v8 JavaScript
runtime out and added a couple libraries
for accessing the file system and other
things like that so that we can run
JavaScript on the server or from the
command line right and that specific
thing is called nodejs and all no js' is
it is the v8 runtime with some
additional tooling inside of it or some
additional libraries for accessing the
file system and network and things like
that and also a command-line interface
to be able to directly execute
JavaScript code that's what nodejs is
it's basically JavaScript for the server
and underneath the hood it is the v8
JavaScript engine that's executing your
code alright so what about JavaScript on
the Java Virtual Machine
so the java virtual machine has included
javascript for a number of years with an
implementation of a JavaScript runtime
called rhino that's in java 6 and before
in Java 7 they introduced a new
JavaScript runtime called mash horn
which is their next generation engine
which is much faster for running
JavaScript directly inside of the java
virtual machine so you can run
JavaScript inside the JVM if you want
however the one thing that it misses
from the node world is that them as
we'll see in a few minutes the node
world has a huge number of libraries
that can run inside of node or inside of
server-side JavaScript and unfortunately
almost all those libraries are not
capable of running inside of the
JavaScript engine that's in the java
virtual machine all right so you have
this large very large number of modules
or libraries that you can access with
the tool called NPM or the node package
manager and you can run those all in
nodejs for server-side JavaScript
applications or command line JavaScript
applications but you typically cannot
run any of those inside of the java
virtual machine okay so there's a big
limitation there in terms of being able
to run JavaScript inside of the java
virtual machine and the other main
reason that you don't want to run
JavaScript inside of the JVM is that
even though the next generation
Nashville and Java JavaScript engine is
very good it's still not nearly as fast
as v8 and nodejs
so there's a big performance drop if you
try to run the JavaScript on the JVM but
this begs the question why do we want to
run JavaScript on the server there are a
number of different reasons
architectural and otherwise one reason
is that a lot of companies feel that
having JavaScript both on the front-end
in a web-browser single page application
as well as on the server is a good thing
to do because now you only have one
language that all your developers need
to be able to know and write code for
instead of having multiple languages
that they need to know right so that's
one thing but the main reason why
JavaScript on the server is so popular
is because javascript is extremely fast
on the server and it's extremely
scalable on the server and we'll talk
about specifically why JavaScript runs
so fast and it's so scalable in a couple
minutes when we look at the event loop
model inside of nodejs
but from an architectural point of view
one of the main reasons people are
excited about running JavaScript on the
server is because of this new generation
of applications known as isomorphic
applications so what an isomorphic app
is is an app where you can run code the
same JavaScript code you can run either
on the browser as you would normally do
with a library like angular or react or
whatever you have or you can run that
same code on the server and do what's
called server-side rendering of that
same code that you would typically again
run inside of the browser but you can
run on the server so what does that
actually look like in a traditional web
application when you're writing a
servlet based web application what we
have is our application runs over here
in the client and our server here can be
Java or Python or whatever but it's
basically just a restful endpoint or
serving up some data using XML or
whatever right and in the traditional
single page web application you may use
a library like angular or react or view
or whatever to run that code but all
that code javascript code runs here in
the client and it makes calls probably
restful calls down into our server layer
to get data to send to the user or show
to the user up in the view layer running
in the browser alright so in an
isomorphic application the line between
the browser and the server where your
code runs is a little blurred what this
means is if you're using a modern
library like react which supports the
ability to run isomorphic style
applications you could have your code
run either completely in the client ie
in the web browser you can have all your
code actually run again this is
client-side code that would normally run
in the web browser you can also with the
isomorphic library like react and using
nodejs
a JavaScript server you can actually run
the same code on the server
and what happens is once the react
library initializes in the client
instead of going and just pulling data
you can actually ask the server to run
the same react code for example on the
server and it will construct the HTML
and send it up to the browser and the
browser will just plug into HTML so
instead of generating the HTML in the
client in the web browser we can
actually do that same generation or what
we call rendering of components web
components inside of the server so this
is an architectural shift in the web
world that is here today with libraries
like react and newer versions of angular
allow you to run either some of your
application in the server or all of your
application or maybe just a little bit
of it depending on how you wish to
architect that as a developer so again
isomorphic applications is one of the
other reasons while we're interested in
running JavaScript on the server to
architectural shift but to be able to
run that JavaScript code on the server
we obviously need to have a JavaScript
engine on the server like nodejs which
can execute it rather than executing
everything inside of the browser the
reason why we're interested in
isomorphic applications as a developer
is it gives us the developer a great
deal of flexibility and a great deal of
ability to do low-level performance
management of complex or web
applications so you don't typically do
isomorphic applications force or
isomorphic architecture for a simple or
moderately complex app you would use
isomorphic applications when your app
gets complex and becomes very heavy and
maybe it's too heavy to run completely
in the browser or for example say that
you have users coming to your web
application from a mobile device like
this this phone may not be fast enough
for us to be able to run a heavy
or even a medium-sized angular or react
application completely on the device so
you may say instead of rendering
everything inside of the device or in
the users web browser on the user's web
browser on the phone maybe we want to
render all these things on the server so
that the user sees much better
performance okay so there are a couple
of reasons here we'll get into the main
reason in terms of scalability in just a
second again why do we care about nodejs
and server-side JavaScript why is this
important to us as developers so the
first reason on this slide is that there
are a large number of tools for doing
web development which are written as
nodejs
libraries or server-side command lines
library I've mentioned some of them
already some of those are for running
unit tests for linting your code for
packaging a client-side web application
lots and lots of different tools where
all these tools are in the node package
manager or the NPM repository which
we'll talk about in a minute of course
we just talked about isomorphic
applications as another reason for
running server-side JavaScript but the
main reason people have been interested
to date for running server-side
javascript is because you can build
highly scalable server-side applications
using javascript on the server
okay and of course there are number of
different reasons that we would want to
use node even if we don't care about
running server-side JavaScript as I
mentioned source code quality tools all
written is node modules doing bundling
and development of web applications of
course we'll get into server-side
JavaScript in a second but those are
reasons why we're interested in running
JavaScript on the server and there are
lots and lots of different modules to
help you as a developer whether you're
building a server-side application or a
front-end application using angular or
react or any other library tools like
Express grunt and gulp for asbill tools
web pack again as a packaging tool
Jasmine for running tests browser sync
is a tool that you use during
development to get a very rapid
development cycle right cetera lots and
lots of different package
but what we care about here is the
scalability of JavaScript on the server
so let's zoom into this a little bit the
way that the JavaScript runs on the
server is very similar to the way that
it runs in the browser there's something
called a main event loop inside of
nodejs again server-side JavaScript
where when requests come into our nodejs
server running may be expressed as a
server-side JavaScript framework
requests come in and they join this
event loop and the event loop is a
single thread that does the initial
processing of the request so we'll get
some request parameters we'll look at
the URI and other things like that and
then we may need to make a database call
so go get some data I may call an Oracle
database and say hey I need to get all
the items that the user wants to see so
what happens in that case is the request
comes in it joins the event loop for a
very small amount of time and we say hey
we need to go get this database
information what happens in this case is
when we use that database library it
will most likely be an asynchronous
library that will require a callback
once that call has been completed but
request comes in it joins the event loop
and we say okay go get some data that
asynchronous function is then moved over
here into this POSIX basic thread pool
and it gets executed here so here we're
spinning doing this in IO to a database
server or maybe we're reading for the
file system or maybe we're making a
network call but all those slow calls go
into this pool over here and the event
loop is now free to service the next
request because the long or slow
operations are happening here when the
slow operation finishes it rejoins the
event loop that says hey I have that
data that you wanted and then it will go
and send a response after you've
formatted the data as JSON or whatever
over here but the idea with this event
loop is that it's a spinning wheel that
stops very very short amount of time to
service a request and anything that that
is slow
get moved off into this pool right here
of threads which will do the slow or the
long operations of making a database
call or reading from a file system or
whatever and in the main event loop we
just do a small amount of work we set up
a call to go get our data for example
when the data comes back we'll reformat
that or pick out the data specific parts
of the data we want and format that as
JSON and send it back so the request
actually spends a very small amount of
time in the in the event loop and again
it's because it's a single thread we
have to be careful what we put into the
event loop and not put heavy operations
into it but that asynchronous
event-driven style of programming which
is inherit in JavaScript is what makes
JavaScript so hugely scalable right so
let's look at this from a more low-level
thread perspective okay so this is what
we see in a typical let's say Java
servlet example or if you program in
something like Ruby and rails same thing
or if you program in Python and in
Django same thing or if you're
programming PHP same kind of thing
because all those things the java
virtual machine the.net CLR Ruby on
Rails Python and Django they all use a
thread based model as opposed to an
event loop bottle right
so again JavaScript uses an event loop
model these other platforms like the
Java Virtual Machine use a threaded
bottle or thread pool based model so
what happens in the Java Virtual Machine
say you have some java servlets set up
the service HTTP request for your web
application you have a request that
comes in that needs to go get a file
right now that thread is waiting on the
file IO to complete and so that thread
is basically not being used at this
point in time another request comes in
it needs to go and get some data from a
database so now our servlet is making a
call to a Oracle database for example
and while it's waiting on the database
to complete the operation and send the
data back this
thread is red because it's not doing
anything is just waiting on the database
to come back so you see there's a lot of
red in here which means that the thread
is not doing much ie the thread is
blocked and can't really do anything
okay so when we talk about nodejs now it
uses a non-blocking asynchronous event
loop so we have a request comes in to
read something from the file and
remember that operation gets put
somewhere over here on the side in that
other thread pool so the main event loop
can go and immediately service the next
request while that long operation is
happening on the side in the in the
POSIX async thread pool that's on the
side and again when you write this
JavaScript even on the server we make a
database call and we give it a callback
and say when you're done execute this
callback function so that it can rejoin
the main event loops thread come back
here and go and send the response right
so this event links pins we move stuff
onto here so the event loop stays free
to service more requests as opposed to
for using for example just straight java
servlets see there's a lot of red here
but in this diagram we have a lot of
green because again those long
operations are put off to the side in a
separate thread pool because javascript
is inherently an asynchronous is bent
driven type of environment okay so when
we look at this you can see we can
service multiple requests the yellow is
the just the amount of time that
something takes to rejoin the thread for
the event loop to to do some processing
and send a response you can see we have
a lot of green in between here where
that event loop that single thread event
loop is free to service more requests
and this is why javascript is so
scalable compared to a Java servlet type
of environment right or again Ruby on
Rails or Python or whatever any thread
based model all right so let's look at
some performance numbers we'll talk
about some performance numbers all right
so I've said that
JavaScript on the server is extremely
scalable and very fast how fast is it
compared to the Java Virtual Machine
right so if we look at the performance
of a node.js server side a program that
is written using the standard
programming model event loop and we use
a library a server-side web framework
like Express that also follows the event
loop model and builds on top of the
basic JavaScript JavaScript asynchronous
event loop model a single node instance
running on a single core CPU core can
support about 10,000 requests a second
which is a lot of requests this is on
modern hardware with plenty of memory
and things like that so what do you
think is the same performance numbers
for a Java servlet
based web application that does the same
thing and is also running on the same
hardware let's say everything else is
the same we're letting on the same
hardware with the same amount of money
a memory sorry and we have the same
number of cores let's say single core
right how many requests per second can a
Java servlet application that does the
same thing support right what would you
get what do you think right so I said no
it can support about 10,000 requests a
second say you have a really good Java
performance engineer on your team you
can go in and tune the thread model and
set everything up to be as efficient as
possible on the Java Virtual Machine
with your java servlets so the answer to
that question is about eight to nine
hundred so about ten times less note can
service about 10,000 requests a second
whereas a Java servlet container running
on the same hardware and tuned properly
or tuned optimally can support about a
thousand requests a second so it's an
order of magnitude less and this is why
no js' is so popular
because it can service a huge number of
incoming requests because of that event
loop asynchronous based environment
right now you may say at this point I
don't believe you that can't be possibly
that can't possibly be correct all right
how is this how is that possible that
Java is so slow or can't scale nearly as
well as something like JavaScript on the
server and the actual answer to that is
because of the thread base model as we
saw a couple minutes ago right there's a
lot of red here and you know it's where
you're kind of using we're constrained
in this thread based model and there are
lots of things we can do we can get into
a discussion on thread pooling and
context switching and optimizations that
we can do in the java virtual machine or
in our java application to make it run
faster but actually it is possible to
get a huge amount or similar amounts of
performance on the java virtual machine
but it doesn't come for free you can use
a library like vertex or library like rx
Java that supports an asynchronous
event-driven programming model but the
issue with that is you have to rewrite
all of your Java code and wrap it for
example in vertex objects and make all
of your calls
asynchronous by wrapping them inside of
a vertex inside of the vertex library so
if you have an existing HTTP servlet
Java servlet based application
you cannot just drop in the vertex
library and all of a sudden you can have
10,000 requests a second you actually
have to go in and line by line we write
all the code that are long operations
database call reading something off the
file system whatever it may be you have
to rewrite all that code and wrap stuff
inside of vertex async objects and then
you can get a similar scale so if you go
look at performance numbers from the
vertex sample project you can get
approximately eight to nine thousand
requests a second on the Java
environment if you use something like
vertex or rx Java so it's almost almost
the same but again it doesn't come for
free
you have to rewrite all your code to in
Java to be asynchronous and because
JavaScript is inherently an asynchronous
adventure of an environment you're
forced to write in that way to begin
with in the JavaScript world ok that's
one of the key differences all right so
let's talk a little bit about an overall
architecture and how you can implement
and get some of the benefits of running
JavaScript on the server while still
having your existing applications so
this is what our architecture looks like
what we have is we still have our
business and API logic layer so we run
Java on Google compute engine we also
have Ruby on Rails for doing user
administration and then we have some
machine learning code that runs in
Python and again that also runs on in
the cloud on Google compute engine and
then we have a data store our data
stores typically a Postgres database or
a Redis a distributed Redis server so we
still have all this but what we have in
the middle is we have this JavaScript
layer and this JavaScript layer
sometimes just acts as a proxy so we
have our web or our mobile applications
that call into this JavaScript layer and
then they make a restful call down here
they get the data and they may transform
the data we may even do some server-side
isomorphic rendering and then send that
result back up to the web or send it to
our mobile application right sometimes
we'll go from the web into the Java
Script and if we're just making a simple
call to get some data it can also reach
directly into the database and do a read
operation and directly do something but
we try to funnel our transactions or
write operations for example from our
mobile client or web into our node jf
server-side JavaScript layer down into
our movie business logic layer and then
a response comes back that way so this
is what our architecture looks like
and this is what a lot of people are
actually moving towards in terms of an
overall architecture write this
JavaScript layer again gives us the
ability to have huge scalability on the
front so it can also act as a firewall
between lots of clients coming in and
making requests and hitting our back-end
business logic or API or rest layer
right so if we get a huge number of
requests what happens is they get queued
up here where we have that enormous
scalability and acts almost as a buffer
or a firewall and protects our
underlying business logic and API layer
and so we get several benefits out of
that we get the ability to scale have a
huge number of incoming clients here and
we can have some flow control or rate a
rate limitation so that our back-end
layer doesn't get overwhelmed if a large
number of requests come in and it also
gives us the flexibility to do
isomorphic type of rendering and
transforms here in this layer if we want
okay all right so let's talk about the
ecosystem for a few minutes and we've
already discussed no data that's
essentially v8 running on the server
right it's just server-side JavaScript
NPM is the node package manager that's
what we want to talk about so we've
already talked about nodejs
javascript engine but the node package
manager is how you access pre-built
libraries that are available that other
people have created and also inside of
your company you can run your own NPM
server and share javascript code between
your team and other teams by setting up
your own NPM server inside of your
company and sharing code that way rather
than directly through source control
okay so you can just share it directly
through source control inside your
company if you want but you can also set
up an NPM internal repository and have
people publish components or other
libraries that are only only
specifically for your company into your
own library there are lots and lots of
different modules in fact well NPM is a
basic package manager comes with nodejs
allows you to install and update
libraries
right it's kind of like maven or like
Gradle right the probably the best
analogy is NPM is very similar to maven
in a way or the maven repository to be
specific not maven for a building you
would use a tool like grunt or gulp - to
have a build system for your JavaScript
application but NPM is the the library
repository like a maven repository right
it comes with nodejs
right and since I last did this
presentation or since I last put this
slide deck together about a year year
and a half ago the number of packages in
the NPM repository has jumped from about
127 thousand to 300,000 packages in the
NPM repository so at this point in time
you're probably thinking why are there
so many libraries in the node world if
we think of a maven repository maven is
what is used in the Java world to store
a commonly used libraries like Apache
Commons or whatever right there's maybe
10 to 15,000 I'm guessing but there's
maybe 10 to 15,000 libraries in the
maven repository but the JavaScript NPM
repository has 300,000 of modules or
libraries inside of it why are there so
many more like what why there are so
many packages inside of the NPM
repository the reason for that is
actually quite simple that is it is very
easy for anybody to publish a library up
to the NPM central repository if we had
time within a minute I could create a
new node package or a node a basically
application or program I could set a
descriptor and I could publish up to the
node repository within a minute if I
wanted to it's that easy to do ok the
other reason is that the node world
takes a different view on building
systems at a fundamental level
when we think of the Java world
especially when we think of Java EE you
get an app server you get this big app
server that has everything inside of it
that you could possibly need almost
everything that you would possibly need
to build an application right if we
think of Java EE for example it has
everything
JMS JDBC distributed transactions HTTP
servlet with session management and
cookie management etc etc right in the
JavaScript world and however the culture
or the thinking is that what we do is we
build up the solution that we need very
specifically for a problem that we're
trying to solve with the smallest
possible modules that we need right so
if we're building something for example
using Express the Express server-side
framework is a very very basic again
server-side web framework it's so basic
that it doesn't include anything to do
session management so what do you do
when you're well what's we have what
framework and it doesn't do session
management what good is it but again the
idea is that you have something that's
very very small or slender and then you
say oh I need to do session management
so then you'll get an NPM library that
does session management oh I need to
work with cookies you go and get an NPM
library and you put that into your
project and it works with Express and
now you have cookies etc etc so the idea
is that you start off with something
very very small and then you add stuff
to it cookies session management course
protection etc etc so you build up all
these things right I need to access a
database
I'll go get sequel eyes or something
which is a NPM package for accessing
different kinds of databases I need to
access this different kind of server go
add in that specific thing so you don't
get anything inside of Express or inside
of most JavaScript projects the ideas
that you use these small modules that do
very specific things and you build your
own app server in a way okay so that's
one of the reasons why there's so so
many libraries inside
of sorry jump too fast that's why
there's so many libraries and the other
reason is that if you go out into the
npm repository and just do a search for
example for hello world you'll find
about 15,000 different hello world
projects in the npm repository right so
because it's so easy to publish an NPM
library people publish NPM libraries
right even things which are garbage if
you will right not very useful
okay so again Express super scalable but
it builds on top of express it as a
server-side JavaScript framework it
builds on top of the JavaScript
asynchronous event-driven and event loop
model so it fits nicely into the overall
motif of it and this is why I express is
super scalable this is why a lot of
people use Express there are other
options if you want something that's
more like a full server-side web
framework you can use something like
sails or Cola or Getty or there's a
bunch of different options right but
again the mentality in the JavaScript
world is you just build exactly what you
need if you don't need all this other
stuff don't add it to your project right
you build something very super slender
and something that doesn't have a lot of
extra baggage so you get the most
performance out of it as much as
possible
okay so again it's if you're coming from
the Java world or if you're coming from
the Ruby world it's a Ruby on Rails
world or Python and Django or whatever
peeve in PHP it's a different universe
than what you may be used to you kind of
build your own solution with small
building blocks to get exactly what you
need okay so it's very much assemble
your own framework smaller modules
alright one of the frustrating things
about this kind of universe however is
that unfortunately there's no one way to
do things oftentimes if you want to add
cookie management you'll find four or
five different cookie libraries that you
can ask your server-side framework
there's three or four different build
tools that people use so this can be a
challenge in terms of how do you figure
out what to use to build a proper
solution
and there's different tools that do the
same things or different libraries that
to do the same thing so it can be a
little bit of a challenge trying to
figure this out right so this is
fortunately with with all that great
choice it becomes a little bit of a
challenge trying to figure out exactly
what needs to be done all right so for
the last few minutes let's look at some
tools specifically the one tool I want
to talk about in terms of modern
JavaScript server-side architecture is
what's called socket IO socket IO is a
library for doing WebSockets right so if
you're familiar with the HTTP
specification you know that HTTP is a
stateless protocol that means the web
browser makes a request to the server it
doesn't matter what kind of server
whether it's a Java servlet container or
a JavaScript express container or Ruby
on Rails app HTTP is inherently a
stateless protocol so the web browser
makes a connection says I need this file
or I need to go get me to stuff for this
URL the server services the request
sends a response back and then the
connection is broken when the Blood
browser needs something else it opens a
new TCP connection and says okay now I
need this you get the data back
connection is broken so every time the
user does something you have to
construct a new connection or the
browser constructs a new connection gets
a response and the connection is broken
what socket IO and WebSocket allow you
to do it allows you to have a persistent
or a state full connection from the
browser to the server so that means that
you don't have the overhead of opening a
new connection every time the web
browser needs data and also because you
have a persistent connection now the web
server can push data up to all the
connected clients or to a specific
client right so if you think of a stock
ticker example right you have a stock
ticker which is sending data for stock
market values with something like
WebSocket once you set up the WebSocket
connection the server can just send that
data up to whoever it wants to send it
to so I could send it to everyone who's
connected
or just this one web browser that's
connected that's up to you and one of
the great things about note is that
because it's so scalable because of the
asynchronous event loop model it handles
a large number of concurrent connections
very very well so WebSockets runs
especially well in scales really well on
an ojs or a server-side JavaScript
solution and using a library like socket
IO allows it to be very simple in terms
of programming so on the server once
you've set up socket IO you can simply
say a socket IO once it's set up and you
have connected clients Amit on this
channel this JSON data object send this
announcement this is just a variable and
then on the client the browser can say
whenever I receive something on this
channel go and run this callback
function in this case I'm getting that
announcement and then we'll go show some
data for something like that okay so
it's very simple to work with so you
might be thinking why is this worth
talking about the reason why this is
important to know in terms of modern
server-side architecture is that in the
current HTTP specifications there's only
stateless connections but in the new
HTTP spec HTTP to a web browser when it
makes a connection to the server
standard HTTP 1 stateless connection it
can say it can request to upgrade that
stateless connection into a persistent
connection and that is part of the HTTP
2 specification ok so this is why it's
important to talk about it's around the
corner web browsers are already support
HTTP 2 now we're waiting for web servers
like Apache and serve old engines and
and node already supports HTTP 2 as well
right but the HTTP 2 spec is here and
developers are starting to adopt this
new specifications for a number of
different reasons but one of those
reasons is the ability to upgrade a
stateless connection to a state full
connection all right so that's why terms
of modern JavaScript or modern server
architecture while we're interest why we
are interests
in it I tell you if we look at this
diagram if we wanted to upgrade our
environment in this architecture to HDTV
to the only real place that we would
need to make that change is here in our
JavaScript server layer this can speak
HTTP to from a web browser to here and
then these connections can still be HTTP
1:1 or stateless connections or network
connections or whatever it doesn't
matter all right so we're able to have
some flexibility in terms of how we can
adapt the architecture without having to
change our business logic or API layer
alright so some closing thoughts if this
all sounds great in terms of scalability
large number of modules available to do
lots of different things at the NPM
ecosystem however because we are
programming in it sorry wrong button
because we are programming in an
asynchronous event-driven environment
it's not for every kind of application
because if you have some code that needs
to make a database call and then the
next step is to make a call to a network
server to get some pricing data and then
the next step is to read off the file
system we have three asynchronous
functions or calls that we're doing
back-to-back and they all will need to
be wrapped inside of a callback so if we
have three things that that are again a
database call read off filesystem make
call to a network pricing server or
something will have a call back nested
inside of a call back nested inside of a
call back so our code gets very complex
and it's difficult to write and manage
and to test and to get errors out of it
so for simple to it's a moderate
complexity app this works okay it works
good but once you start having complex
business logic that's when it becomes a
little bit challenging to manage and
that's why we still have this kind of
architecture instead of moving
everything here we have a lot of
business logic in the Ruby and Java
layer inside of our
so we still want to keep those because
that's the best way to write that
complex business logic we don't want to
have to have a a set of nested functions
or nested callbacks where our business
logic lives because it makes the code
very complex and also makes it difficult
to maintain over the long term right so
there are solutions coming in es7 or the
new version of javascript called
es 2017 specifically things like async
await that allow us to manage the
asynchronous event-driven type of coding
that we do a little bit better in
JavaScript but that still isn't quite
here yet okay the other thing is that
the other challenge in the JavaScript
world whether you're building front-end
applications or want to write
server-side JavaScript applications is
that the community is moving very
quickly there are new libraries coming
out old libraries are getting updated
very rapidly and this is what's known in
the JavaScript world as JavaScript
fatigue because there's just so much to
keep up with as a developer and if
you're writing production code you know
is this code something that needs to be
refactored a year from now or even six
months from now to be able to stay on
top of the latest version of a library
you're using or something like that all
right so this is one of the other
challenges we face in the JavaScript
world okay so but as I showed in the
architecture diagram you can have some
flexibility by having an intermediate
middleware JavaScript layer that can tie
it in to existing databases and other
infrastructure so you can still get some
of the benefits the scalability and the
other things we talked about in terms of
having JavaScript on the server but
still keep the stuff that you already
have existing or complex business logic
in other types of infrastructure whether
you write it in Java or you write it in
Python or dotnet or whatever it may be
right so you have more flexibility
flexibility architectural II when you
can use some server-side JavaScript in
the appropriate place okay so we have
some references here and I thank you for
coming I apologize for going a few
minutes over but apparently they have
beer here so I apologize for keeping you
from the free beer next door okay thank
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>