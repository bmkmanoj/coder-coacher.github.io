<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Testing the Enterprise Layers: The ABCs of Integration Testing | Coder Coacher - Coaching Coders</title><meta content="Testing the Enterprise Layers: The ABCs of Integration Testing - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Testing the Enterprise Layers: The ABCs of Integration Testing</b></h2><h5 class="post__date">2015-06-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/5P6Ql01vrUg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this talk is is going to be kind of a
new step for us my name is Andrew rube
injure I'm a senior software engineer
with JBoss at Red Hat I'm joined by my
colleague Ashley Gutzon today and we've
done this now for a few years
introducing a project we have called our
Kilian and we kind of realized that we
didn't want to come here anymore and
continue to push our project and wave
our hands around and say hey this is
what we got in it great and have
everyone stand enough pause and and make
ourselves feel good about it so we've
started to align our talks from a more
educational perspective and show you the
utility you can get from the types of
projects that we have the thrust of this
talk is to show you what is possible and
it's intentionally a technical overreach
all right this is a one-hour session and
we don't expect you to walk out of this
room
armed with the knowledge to do exactly
what we're doing we're hoping that you
conceptually gain an understanding for
what we're saying is possible and then
we're going to arm you with the
resources to go and find out how to do
that on your own afterwards so the
motivation here is to kind of whet your
appetite a little bit show you what you
can do and we have a series of cards
here and the cards have links to a
website everything that we're going to
show today is on a public github repo
alongside a book that we're writing that
will be out in November with O'Reilly
the book is called continuous Enterprise
development and just like this session
the book is written in a way to kind of
say hey we don't this is not meant to be
like read passively in bed at night as
you go to sleep the bet the book is
meant to be used side by side with the
repo that runs and you're supposed to
kind of pull it in and run it locally on
your own and deploy it off and see the
runnable thing that we have
public running on open shift and the
cloud so let's consider this kind of an
active learning experience and at the
end of the session we'll give these out
outside and you can kind of take them as
some reference material and check it out
later okay so that's kind of where we
stand
this here is Ike Ike is the arquillian
project logo he is an alien so we say of
course welcome earthlings which is cool
you know go the title of this talk is
testing the enterprise layers when we
set out to write this book we did so for
for one reason we've been writing our
Kilian and showcasing it around at
conferences for a few years now and
we've been always showing examples that
are kind of isolated hey here's how we
test transactions or the UI or whatever
and people that are constantly kind of
coming after us like that's great and
some of these examples are even pretty
complex but what about like a real-world
app where you've got to integrate a
whole bunch of stuff together and we
said okay we'll build a real-world app
and we'll put all the layers together
and see what it looks like to integrate
everything together and separate it on
its own and test at many levels so the
theme of this talk is about testing at
many levels to make sure you have
isolation and modularity but then when
you go and integrate them in together
things are still working and hopefully
reuse some of the same types of tests
and we're going to look at some of the
techniques that we employed to do that
so that is what we'll be covering today
the question of course then is do you
test now you can't just like raise your
hand it's like a if you test then yes
yeah if you're if you're not quite and
how about the people that are but maybe
aren't so how
with the coverage that they're getting
or would like to aspire to do more
everyone should be aspiring to do more
like an ambitious crowd think testing
obviously comes in many flavors you have
your unit test your functional test your
integration tests your system tests
sometimes they overlap there's kind of
maybe a Venn diagram of where these all
intersect and many groups will define
them each differently in the past we've
always kind of said hey a unit test is
something that might reflect like one
small API code that just doesn't
intersect with anything else doesn't
integrate with anything else that is a
unit test and it stands alone and great
and then anything else beyond that in my
opinion is some flavor of an integration
test because you are literally testing
the integration of two or more
components right but there's also you
know all the way down to when you do
your full scale system integration
functional testing what we want to avoid
doing is what we call BIGBANG
integration when you have your entire
web application and you're testing just
the whole fully deployed thing if you're
doing that and only that then very
likely you're going to be catching
errors too late the name of the game is
to fail fast you typically want to be
catching errors as soon as possible
in the compiler is best at runtime and
production is worst and anything in
between you you always want to be able
to catching things about as quickly as
you can which is why we are all here at
8:30 in the morning to learn about
testing so that we're not getting the
call at 4:30 in the morning that says
hey your stuffs broken get up and fix it
so just so everyone is on the same same
level basically we want to just go
through some of this stuff that we have
we have been talking about the last
three years or so and just to get
everyone on the same level and see what
the background for what's underneath all
the stuff that we're gonna show you
later is so the basics is arquillian is
some form of test middleware it's
something that lives inside your tests
and dust magical things - it's a kind of
model the same way as a your average
Joey container for instance it provides
you services it provides you lifecycle
management and so on and our Killian
does the same but for your test
environment so it will provide both
hooks into the actual containers to get
to to get hooks on the actual components
like the HP's or CDI beans but also to
provide you with specific services for
your tests like handling selenium for
you or other similar things like DB
units and of course also maintaining the
lifecycle of the container of the
deployment of the test and all of these
different services so the only thing you
end up with is a tiny skeleton of your
own test code and what you're supposed
to be focusing on not setting up the
whole shebang and knowing every lead
little gritty details about about how to
start a container or how to create the
deployment for a container or how to
startup selenium or how to swamp the
Firefox with chrome or phantom Jas Nolan
so are Killian in its core is modular in
the sense that it's build up by multiple
different layers and you can all
function them together so you can both
have just a test abstraction API or just
a container controller or you can
combine them both into one and that's
where it becomes extensible where you
can add your own test services to it and
just bind them into the existing life
cycles that
that are there so hide away the
complexity of getting things up and
running in the background and let the
test case itself speak for what it's
supposed to test and not all the other
crowd and it's flexible the based on the
two previous parts basically because
it's not there's nothing in core that
ties it to literally anything everything
is SPI so which means we're able to
support CD I need to be spring web
containers e to be containers and all of
the different things depending on how
you kind of put the different things
together both in container and on the
client side and you can communicate
across multiple containers and all of
that kind of just mixes together in a
harmony of alien love right I mean from
an arc alien perspective when we talk
about modularity what we're really
talking about is saying look we have an
R Kilian core right and then there's a
modular component that comes in and
adapts a j-unit lifecycle to our Kilian
there's a component that adapts test ng
lifecycle to our Killian and then in
turn our Killian into any of the other
supported containers be it a wild fly or
a JBoss a yes we're in the AP or a Tommy
or a WebLogic or any of these things
that's where the modularity bit comes in
the extensibility comes from our
extension API which says that we can
plug in two things and provide a whole
bunch of services that maybe we haven't
even thought of yet and our extensions
include things for testing with
transactions testing with persistence
and we'll show you some examples of
these later and again there's those to
make our Kilian flexible in the sense
that we don't have to think of
everything up front by offering these
extension points we can kind of meet new
requirements as they come in or new
frameworks that haven't even been
developed yet so we're a little bit
proud of the approach that we've taken
here when we talk about the modularity
bit this is exactly what we're saying
let me back up just one quick second I'm
sorry like it's morning and I'm
assuming a tremendous amount of like
requisite knowledge upon the audience
and that's really not fair to you guys
at all
how many have used arquillian in the
past or at least familiar conceptually
with what's up okay
so we'll step back just a little bit the
idea behind our Kilian is to provide
full functional and integration testing
in a component model that makes it look
like a unit test it should be as easy to
run as a unit test it should be able to
have services that the component model
of ee provides this is a component model
for testing just as java ee is a
component model for business objects
cool so we go in stages when you launch
an AR Kilian based test the first thing
you'll do in your configuration is to
select a container and this is basically
your target runtime if you're doing an
EJB you'll select an EJB container if
you're testing with CDI you'll test any
type of CDI container if you're just
doing web you might just select any type
of servlet thing and the palme
definition looks a little bit like this
and because it's modular and its design
you can put in a bunch of maven profiles
and say hey we're actually going to run
this test in like three target
environments and we'll make a profile
for each one so we can swap in the
correct container adapter nowhere in the
test does it make any reference to your
containers at all our Kilian is an
abstraction right it abstracts away all
of the other test logic behind I'm sorry
it abstract away all of your container
and vendor-independent your vendor
dependent stuff so you can focus just on
the test itself so that's what the
declaration looks like once you've
selected it then you can either start or
connect to a container our kellian
typically comes in one of two flavors
where you can say look we're gonna run a
container on our machine locally at the
beginning of the work day and throughout
the workday we'll just deploy into it
and under ploy into it at will and we'll
just use the same running instance that
can save you a little bit of time for
startup and stop there's also a managed
mode which will say hey our Kilian is
going to start and stop your container
for you so you don't have to go through
that on your own and that's really good
for you know CI environments
when you don't want to have to have
another process running this makes it
automatic out of your bill
so we'll start or we'll connect to our
container then we will deploy into it
there's a packaging step that's involved
how do we typically do our packaging
anyone Bueller Bueller surely you guys
have run a build before yeah all still
with me
typically you run a build and a build is
great except for that our predominant
build system is not the fastest thing in
the world it provides us a lot of great
things like you can move from project to
project and the commands are always the
same it's kind of a declarative thing we
all kind of know we're all on board I
get it
it takes a little bit of a long time to
run and if when you're doing your
development and you just want to make a
couple changes and then you stop and run
a full build just to get a thing to
deploy again that's a lot of context
switching and we feel really takes away
from the whole development experience so
what we do is we have a packaging step
that kind of skips all of that and it's
provided by a project called shrink wrap
shrink wrap is a Java API for packaging
it's a Java API for archives it's kind
of an API analog to the jar tool and
what you can say is hey shrink wrap make
me an archive call it my web application
dot waar and put this class into it that
class into it and this resource into it
and add a web XML and now you've got an
object that represents all these things
it's kind of a virtual file system of
sorts our Kilian knows how to read this
and all the container adapters will
translate that into something that the
final target environment will understand
the beauty of this is that when we say
add classes X here that'll take an
actual class reference the IDE you are
using Ige's yeah who's still like
warrior ii it out on like vim or
a hewlett-packard typewriter anyone
still doing that because people like do
that is like a badge of honor they're
like no no I type them I do it in vim
I'm hardcore I'm like you're an idiot
don't know why for one reason in one
reason only it and that's because the IE
gives you incremental compilation when
you hit save it's going to then take
that class in that class only and
compile it into your target directory
which means that for every subsequent
run when you do run a test case it's
gonna be picked up from that target
directory immediately without running a
build shrink-wrap is able to pick all
that stuff up and just do the assembly
you've already got the stuff compiled
you don't need to run a full build to
recompile everything and assemble it
into a flat file application servers
don't need a flat file crying out loud
they're just gonna read in the flat file
and do what with it convert it into a
stream of bytes write serializing
something is kind of an unnecessary step
so that's why we have shrink wrap I
don't know why I'm so passionate about
this this morning apparently I'm really
amped up about it when we first started
doing shrink wrap people were like this
is awesome I can make the best hello
world apps ever but dude I got like
external dependencies in my project and
I need to bring those in so what's up
and we said all right chill out we got
you covered we introduced this thing
called what we called it shrink wrap
resolver which it's a shrink wrap API
wrapper atop of aether if anyone knows a
Thor aether is dependency resolution
mechanism that maven uses we use it too
but I don't think anyone wants to like
go in and dig into Mather Mather
internals so we built this API that
looks a little bit like this and it kind
of lets you in like real English say
like hey like configure like the
resolver from my existing pom file if
you want to or not and resolve me this
gap this group ID artifact ID version
and yeah also give me all their
transitive dependency
and represented as a file to me and then
from this you'll get an array of files
that represent those dependencies it'll
go in through the same resolution
network that that maven does so if it's
on the remote repo it'll pull it down
into your local one first or if it's
cached locally you'll just get that but
they'll get the same thing that that
maven will do only this way you'll be
able to get your jars resolve them just
as you should and put them into your Lib
directory or whatever and this
combination of this and the other should
be enough for most people to be able to
create the deployments that they want to
put in to deploy into their test case
there is one further step we can go
which is to say all right some people
don't want to write flat file
descriptors either your web xml's and
your enterprise application archive type
stuff so we have a descriptors API as
well which works pretty similarly to how
the others are in terms of grammar we're
really big on the fluent API type thing
so we'll say like alright let's make us
a web app descriptor we're gonna set the
version and a whole bunch of servlets
and servlet mappings and stuff and now
don't get us a string and then we're
gonna export this thing and that can be
going on into our archive too so you
don't need to actually write a flat file
to represent these either people you
know tend to either do this or it
depends on what you're trying to do
there are many ways of defining your
your archive so with this trifecta of
projects that's how we define our
deployments and shrink-wrap you can
either pull them in from something
that's already been previously built or
you can define them on your own or some
mix and match and once you got all those
then we can package those and send them
off to the Container all of this stuff
is done basically by doing two things
one by annotating your test class with a
run with annotation will show you that
and then with what we call a deployment
method once you've done that that's your
wholes test fixture that's your whole
test setup there's nothing in there that
says containers start or container
connector there's no API for any of that
our Kilian handles all that for you and
now you're free to get onto your test
logic so once we've deployed that all
our Kilian will also by default take the
test and put it you know behind the
scenes into your deployable so when you
deploy
you're deployables bits it'll put the
test in there too so that the test
executes inside of the container by
default you don't have to you can run it
as a client as well on the client VM the
beauty of executing the test inside of
the container is it means and I are in
the same VM and you're also a deployment
unit and it means that the tests can
receive injections for all sorts of
things like an entity manager or user
transaction or an EJB or a CDI reference
locally and you'll be able to make local
reference calls so you label do you're
able to do some really great white box
testing as opposed to just the black box
thing where you've got your container
running here and you're only hitting it
from the outside here we actually let
you get into the internals and basically
do whatever you want when you're on the
inside and report the test results back
so once we run the test in the container
then we just send the results back to
the test runner on the remote VM where
we started it over here and you get your
report just as any other way because our
Kilian was built to be an extension to
like the existing j-unit infrastructure
it requires no separate plugins
it doesn't need a maven plugin it
doesn't need an eclipse plugin it
doesn't need anything anything that runs
a j-unit test will run our Kilian and
we'll show you that too when we're done
there's just the cleanup operations we
need to underplay the test archive that
we've just deployed we need to either
disconnect from or stop the container
that we started and then we're done so
that's kind of like the flow of an arc
alien test probably makes sense I'd like
to show like just the full-scale test so
we made the mistake the other day or
just kind of digging into some heavily
technical stuff without doing just the
basic primer first to show everyone
where we're at and get everyone on board
so we'll do that today
this right here is it's not a very basic
arquillian test in terms of what it's
testing but it does have just the basic
elements at the top you have the run
with annotation that's a standard j-unit
annotation and we pass it the arquillian
test runner this is the thing that's
going to give control over
Kilian to be able to handle all of the
types of steps we talked about before
you've got the app deployment method
there that should look a little bit
familiar if that's where we use shrink
wrap to define at the archive and that's
going to be the thing that we deploy
into our run time because it is now
running inside the container we're able
to use the inject annotation like so and
inject a CD i-beam directly into our
tests so we're not doing any type of a
lookup and yes
where would I put my even resolver Oh
maven resolver so we've built these all
to be decoupled shrink-wrap the archives
bit has absolutely zero external runtime
dependencies resolver isn't related to
shrink-wrap archives at all directly
unless there's an integration bit what
you would do is what do you have
do we have an add as libraries would you
just kind of maybe type in yeah Oh add
as libraries okay so see how we have
like shrink wrap create at is libraries
typically things that you end up
resolving you want to end up adding like
into a Lib directory into your archive
so you'd say add as libraries and then
you'd go maven resolver you know resolve
a bunch of crap as files and then you
have the files to put in right so shrink
wrap deals with files we've we've like
to keep these you could use shrink wrap
resolver outside of our Killian if you
want to if you just want to be able to
like have an API to resolve stuff and
get files go like go right ahead but
that's that's how you do it and again in
the examples we'll show you later
there's like plenty of this stuff all
integrated together you know in a big
thing that works so we inject a
repository reference repository is a CDI
bean into our test and then like from
there everything else is just test logic
you know we're free as you see from the
top to like extend and have our own test
hierarchy you're not extending anything
this is not a simple case but it just
shows you what the anatomy of the full
test is and when you run it oh you even
have yeah that's great so the base
transactional this is part of the test
class this is a superclass right and it
shows that again we're running in the
container and we're actually going to
inject user transaction directly into
the test case so that we can go and muck
around with the transaction support and
make sure that we're testing at all
layers we'll go into this in a little
bit but maybe just for now show you how
to run the test case this is going to be
the whole thing it's going to be the
whole shebang we're going to connect
into the container we're going to deploy
that shrink wrap deployment into it
we'll run all the tests will report all
the results back
and that'll kind of be it you see now
it's deploying it's going through it's
doing a whole bunch of persistent stuff
what's up Oh were you just scrolling
yeah yeah there is an application server
up and running we're using the remote
the remote adapter so we're gonna
connect to that server deploy to it and
run it in that knob start up the whole
container as part of the right that's my
cycle we do that kind of like for speed
purposes especially as you're testing as
the day goes along right now we're using
we're gonna run this on the AP now or on
wildfire I was like this is the AP so
this is gonna be a p6 the enterprise
application for platform at JBoss which
is basically a hardened version of JBoss
as7 oh yeah we're done already I guess
so that didn't take too long actually
one of the thing with unit testing is
that it's ultra quick like the standard
unit testing and we've always said that
there's nothing in the Java EE
specifications that say anything has to
be bulky or slow it just was that way
for some time these are full EE
container tests there's nothing mocked
in here this is just all the real deal
running in the container with your
complete set of services and like in a
matter of seconds from your IDE and as I
mentioned with the incremental
compilation earlier if we were to like
change one of those classes we put into
the deployment to like break it somehow
and hit save and then rerun the tests we
would see immediately that that thing
had broken that's the kind of turnaround
we're trying to give so that's probably
gonna do it for for what we'll do today
I'm sorry if we've glazed over for some
of you the arquillian introduction
something that we used to give like an
hour and a half talked about but today
that the focus really is not on our
Killian the focus is on getting you the
tools you need to run the types of tests
you want
so maybe back to the slides we're going
to talk about layers the layers we'll
discuss today are the domain layer this
is our standard persistence we have
player which is endpoints that follow a
proper domain application protocol that
allow rest aware clients to follow links
and know what the state changes of the
application are and then map them to
resources in a rest compliant fashion
that's a layer atop and we have a UI
layer as well for anyone that's been
following us over the past couple of
years because we've had our Kilian and
because we've been able to do real
integration testing in real containers
we've aligned ourselves with what's come
to be called the no mock movement anyone
using mocks and Wow stop any volunteers
to like let me know what you're getting
out of it and why says it's a pain and
he's using it and I don't know why
you're continuing to hurt yourself
you're stopping you stopping that's why
he's here at 8:30 I like that look they
have their utility but I think have been
over applied let me give you an example
let's say I'm writing a message driven
bean familiar with message driven beings
these are consumers of JCA messages for
all intents and purposes let's just say
that their listeners for queue on a JMS
queue and they take in if you're if you
have an MDB that's listening in on JMS
queue they take in this thing called JMS
message cool let's say an EJB was built
to be kind of Pocho lized so that you
can instantiate the EJB and just make an
object out of it it won't be a real EJB
it'll just be whatever an object you
created and then you can call the method
and like invoke your business logic on
it also cool the problem is when you
receive a message inbound from JMS yeah
it's a message it's a method called on
message and it accepts a JMS message
so you think to yourself cool I'll just
make a JMS message populate with the
fields I want and send it in but you
can't instantiate JMS message because
it's not in the API so the savvy
developer will think oh I know what I'll
do I'll mock it and then you end up with
this thing that was made up by a mocking
framework so that you can test your code
but it's not really testing your code
because it's not really getting the
right input in the first place you
follow like it's better than not I'm
proud of you for making the effort but
in my in my esteemed opinion as I am the
one holding the microphone
maybe that is a bad example of a mock so
we've aligned ourselves with this no
mock movement and be like why do mocks
test the whole thing in container tests
the real stuff stay as close as you want
awesome and that's been our message for
years and then we built a real-world
application and we came to find that
like all right there are some uses maybe
not for mocks but definitely for not
doing the real thing the whole time I
have been talking all week clearly I'm
glad to be going through puberty again
it's nice I haven't felt this awkward in
like 15 years yeah maybe we can do do
some things to help to help ourselves
with the testing so we have the notion
of test doubles right a test double is
to say look if you're thinking about
your testing design while you're
building your application that might
actually inform and influence the design
decisions you make in the runtime
components as well if you make something
to be extensible then maybe you want to
extend it at the test layer so that you
can have finer grained control over your
tests I know I'm being broad I know I'm
being
tract and probably a little bit big
let's show you what we're talking about
we have an interface called a repository
okay repository looks a little bit there
are a lot of classes called repository
ours looks like this okay repository is
going to represent something that does
crud operations
it's our hook into a persistent storage
engine in our application
we've got persistent storage in three
different ways
we've got standard our DB ms SQL type
stuff through JPA we've got a key value
store in the form of the datagrid infini
span and to help us out with our
relationship management we've got a
graph database so what we have is this
repository interface to say hey we want
to be able to like get things store them
and remove them right these are like the
basic crud operations and we can provide
implementations of this so we have an
implementation for instance for JPA
stuff which is based in a persistence
repository and obviously the persistence
repository is going to have its
operations backed by an entity manager
as shown up there we also have this
infinite span key value store and an
unfinished man based repository is going
to look a little like this and instead
of using the enemy manager we have this
thing powered by an advanced cache which
is a interface provided by the
InfiniBand api cool so now anything that
we want to do a storage operation upon
all they're gonna do is swap in the
correct repository that was based in our
design and that's awesome for the
runtime for our test stuff there are
tests that we want to run so let's say
we want to validate
our rest layer and make sure that our
rest endpoints are doing the right thing
but we don't want to go through the
whole process of actually sending things
off to persistent storage anywhere maybe
we just want to shortcut it and say hey
let's stop so what we have is a
repository implementation at the test
level we have a repository at the test
level to shortcut this whole thing and
say okay we don't actually do anything
really we'll store it in a hash set you
know so that it'll kind of in for a test
purposes be able to let yeah we can
we'll store it we'll put it we'll put it
in memory you know this is kind of in
you know like an in-memory database that
we'll use and in this way we can
shortcut the other layer so we can test
our rest layer we can test our UI layer
and we can do these things without going
all the way through to the database and
having to pull in other modules and
other components right this is ultra
important for when you start to do
modular based design you want to be able
to test all of your modules without
having them all be intermixed and
dependent upon one another don't
necessarily want your rest layer to be
dependent upon your domain layer follow
ku so we've got a test case that shows
all this in action this right here is
called create conference and session you
know let's go to the the TX one
okay it's fun watching gosh like starbug
like pull up alright we have so many
tests it's you know I'm proud of that
here we have the conference repository
transactional test case I'm sorry no I
think we'll just show here that we're
like swapping out the so as I said so
like we want to make sure that we're
testing our only the modules that are
appropriate to be testing right there so
as I said for our rest layer we want to
make sure that we're testing our rest
layer and only our rest layer and not
going all the way to the database so we
have a rest based test here this one
here is the conference resource
specification test case and what we do
here is we use the test double approach
and we swap in that test repository here
so when we define the deployment we add
the classes and we add a test repository
in place of the proper like entity
manager based repository and then when
we go to our actual tests we see that
what the types of tests looked like
we're basically testing by a resource
specification test case what we mean by
that is that we're testing basically our
REST API points and making sure that the
expected responses are received for the
request and our mapping is okay when you
expose out a rest layer that's an API so
we've got to have tests in place to make
sure that that API doesn't change that
it does the right thing that people can
depend upon it and we don't want to go
into other layers to do that so we can
run this test too I guess
and again you know this one's now you
know five seconds we're all start up and
running in it like a full-scale
integration test case let's take a look
at just one of the methods so here's
what we do here this one is called
should not return should return not
found on a missing get resource so if we
perform a get operation on a resource
it's not there we want to make sure that
we receive a status of not found when we
do and when we talk about arquillians
extensibility and flexibility this is
kind of what we mean this API here where
it's like given a content type then we
should get the status code right this is
all using a framework called rest
assured it's not our Killians goal to
implement everything it's to integrate
hopefully with everything because we're
not going to think of everything on our
own we want you to be able to be free to
define your own test logic your own test
scenarios and move forward
cool let's just show we got bunch of
other examples for stuff that I really
like to show one yeah okay so our
Killian has an extension called warp
warps pretty awesome in terms of it
being able to execute requests upon
something for the UI layer get out the
response and then using this API right
here say we're going to parse out the
individual pieces of this response
collate it out and invalidate upon it
you can explain a little more if you
want instead of just having either in
container or on the client warp can
combine the two so at any URL former
requests being a rest service or JSF for
just pure HTML or a J's calls for that
matter there's a couple of steps within
warp so you can initiate something on
the client side so anything that does a
URL core call you can inject then the
URL and that URL actually talks to a
proxy but we end up in the same same
location and then you can inspect things
that are happening on the or in the
container while that request is running
so it's not a pure container test but
it's you can validate or it's pre setup
like before service after service or
within the JSF life cycles or within the
rest life cycles and one part of the
having demarked repositories here an
understanding of mark the test doubles
repositories instead we can from the
client side create a domain object
everyone a store and then we say to
Warped it when you're gonna do this your
alcohol to the rest service we want to
ship along the actual domain object that
we want to we want the domain layer to
return to the layer above by simply just
injecting their posture restoring it and
then when the rest the rest
service comes along and injects the
repository and gets the object that's
the actual object that used passed from
the client that avoids you to need to
have a database set up with all the
possible preemie mutations presentation
permutations of different scenarios
where what happens in the rest layer if
name is null or if this is a certain
type of conference or a certain type of
next great we are running low on time so
we're gonna flip through a couple other
examples again remember from the
beginning of the talk our purpose here
is to show you like a wealth of things
that's possible try and relieve yourself
of like looking through these and
understanding and trying to remember
we're going to give your resources to go
find this later and it's explained in a
lot greater detail and you can go at
your own pace the sequential tests maybe
for the story this is a test I like a
lot because this is now coming through
at the the full now once we've like
we've done our layered stuff assuming
we've swapped in the test doubles we've
tested each of the modules at their
layer when we go and we do full
integration and we bring the whole thing
together we want to go through these
like user stories we're gonna say like
hey at the very beginning I want to like
go into my restful layer at the
conference route and get the full list
of operations that are available on the
conference and I'm gonna invoke
operations based upon the results I get
I'm gonna walk through a user story by
nature of this test it means that we
need to go through these things in a set
order and j-unit doesn't permit us the
option to define the order of our tests
because you know they say that like
tests should be like kind of item potent
and it doesn't matter and one shouldn't
affect the other and this and that but
we find that there's some great utility
in writing out a test class and saying
a/b c/d and one follows the other so our
Killians added this in sequence
annotation where you can just give kind
of a lexical ordering to things so yeah
I mean like first will like locate the
conference route
then from there you want to say like oh
well I've located the conference route
and it's given me a link to create a
conference so I'm gonna follow that link
and create a conference and after I
created the conference I should be able
to then now go and get to the conference
I've created and then I should be able
to update it so we follow through like a
story and as proper sequence of actions
in order this is something that we find
has great utility at the full like when
we're done and we're doing the full
integration testing at the end that's
what we want to do I'd like to show that
the drone tests if we can just because
it's when we talk about extensibility
and integrating in other frameworks
especially when it comes to the UI this
is a test I I always like to show
because at least it gives you something
visually to remember in what's possible
in this test here we're going to say
look we want to perform validations on
our conference form when people create a
conference in our application we want
them to make sure that they're putting
the start date and the end date in the
conference so we're going to go through
and get all the action links on the
first page we're gonna find the links to
get the conference click on it make sure
that we get the conference form and then
once we do have the conference form
we've got this nice DSL API it's
typesafe that says for let's set the
name of the conference to test set the
tagline and we're going to keep the
start and end date blank and then we're
gonna hit submit and we want to make
sure that our UI is actually validating
back to like hey you you can't do that
so when we run this test we use
something called the drone extension of
our Killian drone is wrapping selenium
if anyone's familiar with a selenium
project it's awesome it means when we go
run this and we run it just like any
other test case it'll actually launch
our browser for us fill out the stuff
quicker than we'd ever be able to on our
own validate that it got those error
messages let me see it again real quick
if you look really quickly you'll see it
fill out the information see the look
red validation messages appear and then
you know show that we're good if you set
a breakpoint then we can kind of halt it
in place
we now see that it's
there and that we can perform assertions
to make sure we got those UI things at
the end so how much better is that then
maybe hiring someone to click through on
every single version of your application
to make sure and these tests are totally
repeatable and you can do them for
everything the thrust of what we're
saying today is that we don't believe
that any single area of your application
development should be left untouched
unchecked untested if you think about
testing a little bit in terms of the
design of your application moving
forward then you might even end up
changing the design of your app to be
testable and that's not bad believe me
that's a great thing it makes things
extensible for testing it makes things
more maintainable and then once you have
these Suites in place you never have to
worry and that's the whole thing that
drives the continuous integration and
the continuous deployment stuff people
love that you can just oh I commit and I
don't have to do anything and it just
deploys into production for me the only
thing that is protecting you from
problems in that type of a scenario is a
decent test suite and we're just here to
try and show you the types of things
that are possible and here's how we've
arrived at some of those conclusions on
our own so with that in mind the book
that explains all of this stuff is
available for presale it is open source
you can start reading it now 90% of the
material is in an open source repo on
github the links are all here you can
pull in the book content itself the
images the examples run them on your own
read it on your own buy it if you want
if I get like a case of beer out of this
thing I'd be totally psyched this is the
link right here Ashlock and I are
available through the Twitter handle at
continuous dev and today we'll actually
be at the O'Reilly booth in the exhibit
hall from 2 o'clock I think it's a full
hour it's from two o'clock so definitely
2:30 and maybe beyond they they're
giving away some like pre advanced
copies they printed up they took like a
third of the book and made a paper dead
tree type thing and we can sign them or
whatever
would love to meet you and you know if
you have any other ideas to continue to
feed into the community remember
resolvers came from the community saying
you're not doing this well enough and
any of other any number of extensions
for our Killian came from the community
and our QE teams
it's your feedback that makes this stuff
better for us and I know this has been a
little technical I know that we've been
a little dry on the content but never
again do we want to be told that we're
to marketing or hand-wavy and and not
showing you enough material so here it
all is all the resources are online
maybe pull up our Kilian org - for those
of you who maybe aren't quite there yet
at the the level where we are and you're
just this is all looking interesting to
you but you've never tried it out yet we
have our Kilian org and in our Killion
org we have at the top of the page a
link that says guides and then we have
your getting started quick starts and
starting up with a forage project and a
whole user guide on making deployable
archives with shrink wrap and just
deeper and deeper stuff to like get you
bootstrap get started in a much more
simplistic way this was this talk was
everything we had in terms of tech
content so you can start at the
beginning here at our Killian org and
the book will start you off a little bit
and show you the full boat and I know we
hope to see you at the Black Keys and
we're ruined five tonight yeah right
this was our last talk for Java one I'll
be drunk for the rest of the session</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>