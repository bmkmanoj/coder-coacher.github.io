<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Modern JavaScript Server Stack | Coder Coacher - Coaching Coders</title><meta content="Modern JavaScript Server Stack - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Modern JavaScript Server Stack</b></h2><h5 class="post__date">2017-10-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/pROBZ9cjAT0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right good afternoon everyone how's
everyone doing everyone sufficiently in
a food coma by now so after lunch it's
always the best time to give a
presentation anyways welcome to this
session on the modern JavaScript server
stack if you have any questions while
we're going through this you can just
shout them out or you can use the mic in
the middle of the room and we should
have enough time to take a few questions
during and after the session so real
quick about me the CTO of a small tech
company in Atlanta oh and I'm also a
Java champion which is ironic since I'm
giving a talk on JavaScript today but
we'll see how all this comes together
and fits into the overall Java ecosystem
in a bit so at my small company we use a
number of different technologies or
platforms we use some JavaScript we have
some Java we even have some groovy
running in production and Ruby Android
and iOS so that means that I'm this
person that wears a lot of hats right as
the unofficial head code monkey we build
on all these different things and one of
the things that we've learned while
working on I'm gonna step down here I
don't need to actually type anything for
this one one of the things we've learned
is that managing multiple platforms is a
bit of a challenge right even for a
small company like this honestly a large
company it's much more difficult and
what I hope to do in this session do you
view some ideas on how we use JavaScript
and we'll get into some of the technical
details as well so that we can
understand why we want to use JavaScript
on the server side right so we're kind
of forced to use javascript in the
browser because that's the only way to
really write applications in the browser
itself right I mean does anyone still
use flash to write browser-based
applications anybody know okay I didn't
think so it's amazing how quickly flash
went away and JavaScript dominates on
the front-end now but this session is on
server-side JavaScript so something
slightly different and one of the things
we'll do is if you remember this diagram
from days past I think I think it was
called Java EE or j2ee when this diagram
was out but there's some there's some
very distinct things that separate the
way JavaScript runs on the server versus
is how we think of job applications
running on the server right we think in
terms of ejbs
and maybe today you're not using Egypt
bees and you're just using standard
servlets with some of the tooling around
it we'll talk about so in that tooling
as well when we compare server-side web
frameworks but one of the things that we
want to focus on in terms of
understanding why javascript is so
scalable and fast on the server and why
can handle so many concurrent requests
it has to do with the different
threading model that we have in Java
versus JavaScript right so in the Java
or the Java Virtual Machine when we
think of writing server-side web
applications we use servlet so obviously
and we have this thread based model
where we create a thread pool and we
assign some servlets into a thread pool
and that's how we scale it up and we may
have multiple JVMs depending on what our
memory limitations are or how big we
want to set the heap in the java virtual
machine but this is how we scale out a
java application right so this should be
familiar with the folks who are building
java apps right we have servlet
instances we can figure how many several
instances we have and then we create a
thread pool and we scale the threads
like that
the way we do it in JavaScript is
completely different we'll get to that
in a few minutes but I just want to set
the kind of base of comparison as to how
javis works versus JavaScript on the
server all right so when we think of
JavaScript we're gonna go into the why
we've talked about the ecosystem and if
we have some time we'll also talk about
the tools right depending on how quickly
we get through this but one of the key
things that a lot of people who are new
to JavaScript especially on the server
side is they kind of think of it as a
baby language which is not the case
anymore all right JavaScript it yes it
is the cool hip whatever kind of
language that everyone is talking about
nowadays but it has significantly
matured over the last five to six years
especially and the I didn't used to take
JavaScript seriously until a lot of
these things happen to be honest with
you so what's changed in the JavaScript
world that's taking it from a baby
language like this to you know what may
still be a cool hipster language
whatever you want to call it to being
like
real enterprise-grade technology that
you can build stuff on all right what's
changed okay so we want to understand
this before we kind of don't put our bet
on putting a man power into building
large-scale or even medium scale
applications so the language itself has
not actually changed very much in the
last 20 years so in the last maybe two
to three years with the release of es6
and es seven or EF seven is on the way
now the language has some improvements
that help kind of weed out the edge
cases when you're programming in
JavaScript so for example JavaScript
never had a lexical scoping until
recently until es6 and arrow functions
for example so that was a major pain
point for Java developers when writing
asynchronous code is always having to
keep track of the lexical scoping and
having to do it manually but now with
es6 we can use arrow functions and get
lexical scoping so a lot of the things
have been improved in the language right
tip but that's only just recently
javascript still has some edge cases and
some nuances that you have to worry
about but what's really changed is that
we've changed as developers we have much
better best practices today we have much
better runtimes and the tooling is much
better than it used to be right one of
the big keys key points on this bullet
is the much better runtimes part the
JavaScript virtual machines specifically
the one that we use to run JavaScript on
the server which is v8 which we'll talk
about in a minute those runtimes
actually rivaled the java virtual
machine in terms of pure raw performance
so the JVM is still probably the gold
standard in terms of raw performance for
some virtual machine based architecture
right we're not talking about C we're
talking about hosted code but v8 rivals
the JVM in terms of pure speed and that
makes our lives much easier it allows us
to write applications which can run very
fast so what hasn't changed in
JavaScript is as I mentioned before
JavaScript still has bad parts there's
certain things that you need to be
careful of so for example one of the
rules that we have when we're writing
JavaScript code is we always use triples
equal triple equals because double
equals opens up a class of bugs that you
have to make sure to avoid right so it
still has some
bad parts that you have to worry about
and JavaScript is still an asynchronous
event-driven environment that uses a
single thread and called an event loop
which we'll talk about in a few minutes
and look at in the diagram but as you
also know javascript is supported in
every virtual browser and in virtually
every browser has very good JavaScript
support even on mobile device so when we
think of javascript outside the browser
it's relatively straightforward the same
JavaScript engine it's called v8 that
runs inside of Google Chrome has been
taken out it's an open source engine so
a few years ago some folks took the
engine out of the browser and added some
file system and other libraries that you
would typically need in a server-side
environment and that allows us to run
JavaScript on the server or from the
command line or whatever you want to
call it okay super fast JavaScript
runtime v8 so v8 is basically node with
libraries for accessing the file system
and other things that you typically
can't do it in browser ok so it's
actually based on a browser engine that
you probably use every day now one
question that typically comes up in this
session is well what about JavaScript on
the java virtual machine because as you
know the JVM can run a host of other
languages whether it's JRuby J Python
and JavaScript so in the last I think
JDK 6 was the last release that had
Rhino which was the older JavaScript
engine newer versions of the JDK have a
much improved JavaScript engine called
Nash horn that can run JavaScript much
faster however the performance of
JavaScript inside of the JVM is still
not anywhere close to what v8 can run it
ok if you go to a presentation on growl
sometime this week that you can hear
them talk about how growl will support
Java and JavaScript and other things
like that at very very fast speed but
that technology is not here yet and the
other problem with running JavaScript
inside of the JVM is that a lot of the
node libraries not a lot virtually all
the node libraries that you can get that
you would normally use to build an
application
are not something that will run in the
JVM okay so those are the two major
obstacles to just having one place one
host that can run both Java and
JavaScript so today you do have to run
nodejs
to be able to use javascript but let's
back up for a second why do we care
about running JavaScript on the server
we already have all this stuff built
whether it's in Java or Python or Ruby
or whatever it may be right why do we
care about JavaScript on the server
aside from its what all the cool people
are doing right or whatever your friends
tell you about JavaScript so there are a
couple of reasons so there's there's a
school of thought and I don't
necessarily prescribe to this but
there's a school of thought that says
that if you have one language that your
front-end developers use and you have
the same language that your back-end
developers use you can have more of a
flexible team to move resources between
front and back in right so it allows you
to give your teams a little bit more
flexibility if you doing more work on
the front end in this release you can
move people over etc anyways and then it
is what it is but it's the last two
bullets we really care about JavaScript
on the server is extremely scalable and
very fast okay and why is it extremely
scalable and fast all right now let me
go into this first so these are some
basic reasons why we want JavaScript on
the server and there's also a new wave
of a slightly different architecture
than what we're used to when building
front-end applications called isomorphic
apps that is actually here today in at
least one front-end framework but the
idea here is that with an isomorphic
style application you can run the same
JavaScript code that you would normally
run in the browser you can also run that
exact same code with a little bit of
configuration on the server that is
essentially what isomorphic applications
are right and some call them Universal
applications I think that's what more
people use today so when we think of a
traditional web application you have
your app with name your framework
angular react VJ s whatever and all the
code just runs there right and you may
have some you will have some
infrastructure in the back restful
endpoints web services whatever it may
be
and that may be built using Ruby Python
Java PHP whatever I and and your app
loads as the real single page
application up in the browser and then
you just make restful calls to the back
to get data and you do all what we call
rendering inside of the browser and your
server is essentially just serving data
nothing else okay with a isomorphic
application the line between where your
code runs is kind of blurred between the
client I eat the web browser and the
server you do have to be running
JavaScript on the server to do this and
that's why note is important but you as
the developer have the flexibility to
say you know what this app is running
really slowly in the browser we've done
some optimizations it's a very heavy app
maybe we're building a dashboard or
something like that so let's just run
this entire app on the server and we
will emit because this is a isomorphic
style architecture we will emit
fragments of HTML that will then get
shipped up to the browser and plugged in
so the browser has to do less work so
again the idea of rendering ie taking
your code and producing those HTML
fragments that eventually make it into
the browser's Dom is what we care about
and with the isomorphic style
application you can have your entire app
run on the server you can have some of
your app run on the server or you can
have all of your app run in the browser
it's up to use the developer so this is
a new architectural style that is
starting to get some traction now right
it's not for every type of app but it is
important to know about I think right
and the reason why we care about
isomorphic style apps is it it gives us
the developer of doing low-level
performance management of our UI
components we can run them on the
browser or we can run them on the server
or we can say you know what this widget
this one widget we have is very heavy so
instead of rendering that in the browser
doing all the construction right the
framework does all the construction
underneath the hood you just program to
the frameworks API whether it's angular
react or view j/s or whatever let's just
run this one component on the server and
the server will go through you know it
has access close access to all the data
we can produce this very very
large component that's ready to be
plugged in to the running browser app we
ship that up and all the plumbing and
stuff is handled by the framework itself
so this is something that react does
support currently I don't know of newer
versions of angular support isomorphic
style transforms yet okay but it's
something to keep in mind if you care
that deeply about performance so why do
we care about node so the first thing is
is you have to learn node anyways if
you're building front-end applications
because all the tools for building
front-end applications are written as
node modules whether you're talking
about web pack or something even more
elementary like jasmine for writing unit
tests etc etc right so you have to know
a little bit of node just to be
successful in building a browser-based
application and we talked about
isomorphic apps already so I won't
rehash that but what we want to focus on
for the rest of this session is talking
about the scalability story around node
right so of course that I talked about
this all right there's source code
quality modules for that are in node
bundling development web pack and
server-side j/s I mean here's just a
list of some of the things we if we have
time we'll get into some of these and
talk about these different tools that
are available in the the node ecosystem
what we want to focus on however is the
performance aspect and if you remember
the diagram that we had at the top of
this session where we look at the the
thread based servlet model for doing
Java based applications the nodejs
internal diagram looks more like this so
what we have is we have request coming
in right from our browsers or other
places that are making a request in or
our system they come into our
server-side JavaScript environment which
is based on node and it is a single
threaded environment something called an
event loop and what this event loop is
doing is it's spinning the whole time
it's waiting for these requests to come
in and when a request comes in the event
loop stops and goes and grabs the
request data and it does whatever it
needs to do basically what you've coded
it to do whether it's reach into a
database grab some information or just
serve up like some content
I don't know read from the file system
server content whatever it is so the
event loop stops for a very short amount
and services that request and sends the
response so it's a single threaded style
of architecture and at this point you
might be thinking why is this faster
than multi-threading the reason is is
that javascript is again is inherently a
asynchronous single threaded model the
key word there being asynchronous so
what happens when a request comes in and
say the request is go serve up
index.html it comes into here you have
some code or may you're probably using a
library for doing something that's
simple and to do that file i/o that work
has moved over here into POSIX into
basically a it's a pool of threads
waiting to do work that will take
quote/unquote a long time so something
like file IO or reaching to a database
which would be network IO is something
that takes a long amount of time so
request comes in go serve up indexed on
HTML that gets delegated underneath the
hood when you use the file system
library or if you're using a library
that knows how to just serve up HTML
static HTML pages or other assets that
goes in spins over here it goes in grab
stuff from the disk it comes back here
it rejoins it sends a signal into the
main event loop and says here's the file
data that you want it the event loop
picks that up in the form of a callback
and then you may have some extra code
right for serving back a file you won't
have any extra code and then that will
go and get given back to the to the
requester as response ok so say you have
a what I do
ok say you have something a little bit
more elaborate user makes a request and
they want to get all the items in your
database sorry this connector is a
little strange let me plug that back in
hopefully this works
okay there's good talk y'all I guess
it's time to go home
sorry you want come up here real quick I
don't know what happened it just I just
like touch the this HDMI cable and all
of a sudden it just went out there goes
I knew as soon as you'd walk up here it
would start working right Oh
okay just stand here all right I won't
touch this now I'll try to be very
careful not to touch it okay all right
sorry about that
some slight technical difficulties all
right I didn't really mean you have to
stay up here I'll just try not to touch
it okay all right so so say you get
another request come in that is go and
grab all the items in the database
request comes in we hit the event look
we will have some code that goes and
reaches into a database that code to
reach into a database that library that
you use will be an asynchronous style
library so the request comes in you say
okay I'm gonna go get these items with
these whatever this kind of filter
filter do a query whatever it may be
that gets moved over here this will spin
over here go get the stuff from the
database but the main event loop is free
to service more requests and if you
remember how incoming TCP traffic is
handled on any server what happens is
there's a queue in the network layer
where traffic builds up and then you
have threads that pull these pull that
traffic off of it and make a virtual
connection etc etc down into TCP layer
and because we're not doing much or
offloading all the stuff that takes
quote/unquote a long time over here this
event loop is free to service more
requests concurrently so requests will
queue up in the TCP layer our event loop
in our node server picks these up as
quickly as possible we do something very
very small or things that take a long
amount of time get moved over into here
and they spin over here and when they
come back we hit this the look event
loop will probably not be busy again
because we're not doing much real work
in it Aurel the long work is happening
on the side and this is the main reason
why node is so scalable that event loop
is is node forces you to write code
because it's JavaScript in a callback
style ie
an event-driven asynchronous style of
programming so if you've ever coded in
the browser and you make a network call
you know exactly what I mean it's the
exact same thing when you make it Ajax
call in the browser what do you have to
do
you have to give it a callback for
success and a callback for air and that
goes and spins somewhere else in the
browsers whatever JavaScript engine
right doesn't block the main UI thread
of execution in in the web browser and
the same principle applies in a
different way inside of inside of nodejs
on the server okay
so let's move on to the next slide and
let's see what a traditional threaded
model looks like for example in the JVM
or if we don't want to pick on the JVM
we could use PHP or Ruby on Rails or
Django on Python or whatever right
everything else essentially what happens
in the JVM is we get a request go read a
file I need index.html okay yeah I need
to go grab stuff from a database so
underneath the hood will use JDBC or JPA
to go and grab some stuff but you can
see what happens in this thread based
model is that that thread that specific
thread it can can't really service
multiple requests but while it while
these long things are happening go go
reach out over the network and grab
something from the database or go grab
this file from the file system we have a
lot of red here okay so in the the
thread is blocked or if you use a
non-blocking i/o the thread still has to
wait around for the next thing to happen
right so let's compare this again this
is like the JVM if you're writing Java
or JavaScript or you know you could use
PHP or rails or whatever as your example
they all do the same thing so when we
think of what happens when we look at
what happens inside of an ojs instance
it's completely different right we have
requests coming in the request queue up
on the network stack they get picked up
quickly by our event loop inside of our
node.js server and the stuff that we're
doing over here right make going do a
file go grab something from a database
that happens in that thread pool on the
side so our main thing our main thread
pulling requests off the incoming
network queue is free for most of the
time to do stuff so when
wrong button there we go so when we go
and grab something from the file system
when we go and grab something from the
file system for example or we go and
grab something from our database that
goes and runs on the side and that will
rejoin into the event loop when the
callback is fired for that asynchronous
call remember asynchronous style
programming we say go and read this from
the file here's a success callback
here's an error callback that's
basically the hook for that secondary
thread to call back into the main event
loop thread okay so those come back in
right we go in we have that raw data for
those items from the database that we
needed it rejoins the event loop we'll
do some very minimal work in this case
we'll take some raw database results and
we'll format them into JSON and send
them back for example alright so we
spend a very small amount of time in the
main event loop both on the way in and
on the way back
all the long aced all the long tests go
happen on the side somewhere and again
this is why no js' is so scalable
alright let's go on to the next slide
alright so what are some performance
numbers around this alright let's let's
get down to the nitty-gritty what does
this actually mean so a properly tuned
node instance a single node process
running on modern hardware with you know
sufficient memory let's say a gig or two
a memory right nice solid state drives
whatever right modern hardware a single
node instance process can handle nine to
ten 10,000 concurrent requests a second
okay so 9 to 10,000 which is actually
pretty pretty good for the amount of
memory we're using and you know just
it's that's a lot of requests right I
don't know what what scale you write but
that's for me that's a lot of requests
so note about 10,000 requests a second
so here's question for you right
especially for you JVM wizards in here
or Java servlet wizards in here if you
were to run if you're to configure I'd
pick your app server
it could be Tomcat or Tommy
or WebLogic server or WebSphere 4j boss
or whatever if you were to configure one
of those with the same application using
servlets alright let's just do something
easy like servlets you can layer
something on top of it if you want like
spring web or something
how many concurrent requests could have
single JVM instance handled right you
you configured the thread pool you have
the optimal number of server instances
configured etc etc what do you think the
number is what's that one request a
second one Kay okay anybody else no it's
that seems like the consensus that's
about right it's somewhere between a 700
and 1,000 right so you've obviously
looked at some performance numbers so
you know you know what this is since
you're so close and that is true so at
this point usually people are like I
don't believe any of this
right how can a single node process run
so many more concurrent requests handle
so many more concurrent requests than
Java right and this is actually true in
practice if you go look at the numbers
this is what this is what you'll see but
you have to remember that we're writing
in a completely different programming
style when we write JavaScript we are
forced to write in an asynchronous
event-driven environment so it leads us
into the path where we get that
scalability up front we don't have to do
anything about it we can't even sidestep
it we were forced to write in that
paradigm if you will so we can get the
same kind of scale on the JVM if we use
a library like vertex or we use the
asynchronous capabilities of rx Java and
this is one of the reasons why a vertex
and arcs Java are very popular today for
people who care about high performance
because you can get the same amount
close to the same amount of scale I
think vertex and rx Java again running
on the same hardware and stuff like that
will get you up to about six to seven
thousand concurrent requests on the JVM
however you know in life nothing is free
right even the lunch that they gave you
here what happens is if you want to use
vertex it's not like sprinkling magic
on your application and just you know
putting their library on your class path
and like oh my god now I'm running ten
times faster or whatever we're ten times
more scale what you have to do to use
vertex or arc Java is you have to
rewrite all of your critical code of the
code that's on the critical path around
vertex asynchronous wrappers that's what
vertex and arc Java do they essentially
take what would normally be synchronous
Java code right so if we were to just
write some pseudo Java code it would be
line number one get the request get the
request parameters line number two make
a database query with these request
parameters line number three take these
requests take the results from the
database formatted it as JSON line
number four set the response set to JSON
as a response and send it back okay
wait if you use something like vertex or
arc Java you have to rewrite all four of
those steps and you have to wrap them in
a vertex async class
wrapper so your code now is in an
asynchronous style but you have to
rewrite all of it to get the full kind
of potential asynchronous capability out
of it okay so it is possible to do on
the JVM but most people write just kind
of normal Java code and you don't write
everything asynchronously you have to go
back and rewrite all the code on your
critical path to be asynchronous
even one thing is not written in an
async wrapper then you're not going to
reap any performance benefit or
scalability benefit from it okay so any
questions about that before I move on
all right so at this point you you may
or may not be sold but you might be
thinking all right you know this whole
JavaScript on the server thing may be
worth exploring a little bit deeper so
the next question in your mind will be
how does this fit into an overall
architecture and that's what I want to
spend the rest of time talking about so
this is what our architecture diagram
actually looks like we have stuff that
we normally call presentation type stuff
web mobile and I added bots in here now
because if you if you put bots and
machine learning and or machine learning
into your startups
a VC pitch people just throw money at
you today okay so so I had to include
this alright so anyways this is
nominally our presentation layer we have
traffic that comes from web browsers and
also from native iOS and Android apps
and what we do is we have this node
layer in between that sits is kind of
like I don't want to call it a proxy
because it's not just a proxy it does
session management cookie management and
other things it can also access directly
into the datastore for doing reads if
we're just fetching data which is you
know usually what we're doing here at
least in our application but this can
also call down into our restful layers
that we have running on different cloud
platforms in Java Ruby Python all right
so we have this layer up here at the top
that is our gatekeeper we do basic
session management cookie management
here and other things all right things
that are small and simple and when we
need to go get data from our business
logic player we reach down and make a
restful call down and say go get me all
the users that are specifically masters
query or go get me the specific language
translation data that we need to present
up into the browser or whatever it may
be okay so so this what I'll what I've
learned from talking with my friends is
this is a pretty popular initial
approach to to mixing in some note and
getting some of that scalability getting
some of that scalability boost up and up
at the front the other thing that's nice
is that we alleviate a lot of the
pressure on the server's down here
because we have the network stack or the
the incoming network requests get queued
up here so we end up using a lot less
resources down here all right so we're
able to use node for what it's good for
which is handling a large number of
concurrent connections very cheaply and
down here in this layer we make calls
down to go get data when we need it from
one of these three business logic
engines that we have running behind it
okay so kind of sample architecture
around how all this comes together but
let's dig a little deeper into this I
think we have time to talk about the
ecosystem so
for those of you who aren't familiar
with a node there are a few things that
you need to know I think to be
successful if you want to make the jump
into mixing in some server-side
JavaScript into your environment alright
so we'll just go through these very
quickly because I'm sure most of you
know this stuff no js' is v8 the
JavaScript brand engine with additional
hooks we talked about that already
you'll use something called a node
package manager which is how you access
the publicly available libraries that
are available for the node ecosystem
some of the modules that are available
expressed as a server-side JavaScript
framework grunt and gulp or task runners
web pack is used to build bundles for
javascript in the browser jasmine is for
running unit tests both for the browser
and for server side note applications
etc etc lots of stuff NPM comes with
node.js so when you install node you get
the node package manager and one of the
biggest challenges with working in the
node environment in my opinion is that
there are a lot of libraries okay
this number is probably not even correct
anymore all right 300 thousands probably
more than that now so so you have just
lots and lots of libraries when you're
working with node and one of the
challenges that that everybody faces
even if you've been working for node for
years with known for years or you just
started with it is what libraries do I
use to do this thing okay so let's just
jump out of the browser for a second I'm
gonna be very careful not to touch this
HDMI cable right so so I just did a
search here for CSV on the NPM JSL
repository there's 1,200 packages for
doing you don't see SVS alright comma
separated files there's 1,200 packages
for working with CSV I honestly I don't
think we need more than two or three
because if I remember correctly CSV is
not a very complex format is that right
I think it's commas separating things in
a file so anyways with a little bit of
rules for how do you escape commas so
anyways so this is a common issue is how
do we figure out what things to use when
we don't want to write everything
ourselves there's no reason for me to
a CSV library right that that is
probably done by somebody and done well
hopefully so one of the things we do
when we vet libraries is we'll go and
look to see what the most popular
libraries aren't but if we just scroll
through here let's see hold on just a
second let me see if I can find it
there's this react okay there's a
specific library for working with CS
fees in react C's reloader strings okay
it's not showing up at the top hits
anymore unfortunately
but someone actually wrote like a
library called hello CSV which was a
sample application that was written in
express server-side web framework to
just serve up CSV files right so so one
of the one of the things in the note
community is that there's this a concept
of sharing your work right there's a
couple of things here right there's a
couple reasons why there's so many
libraries in the node world the first is
there's this kind of motif of share your
work right you're working on something
and hey this might be useful for
somebody let's go publish it to the NPM
repository and if we had a decent
internet connection we could publish in
NPM library like within a minute we
basically set up a package.json ie a
node.js project file we put it in a
github URL and then we go and submit it
and boom it just shows up more or less
on the NPM j/s repository so it's very
easy for people to add stuff into the
the main NPM repository which is which
is a two-sided double-sided sort it's
great that people are sharing that means
we get more people contributing to open
source that gives us as open source
consumers the ability to have more
access to more stuff other people have
written but on the other side there'll
be silly things in the NPM repository
like hello - CSV right or whatever so
this is one of the challenges that we
have to face and that leads us to a
discussion on I'm gonna skip the Express
Park for now so I apologize for that I
don't want to don't want to go too much
into this well we'll talk a little bit
about this actually this helpfully helps
leads us to
kind of understanding what the node
world looks like so express is a very
basic server-side web framework there
are other more full-featured frameworks
that I've listed here at the bottom but
Express is so minimal that it doesn't
come with session management or cookie
management so what do you do when you
need that obviously you need session
cookie management when you write a real
server-side web application so what you
do is you can probably guess you go to
NPM you find a nice session management
library you go put that into your
project oh I need to use cookies let's
go use that we'll go find a library that
does cookies right so literally Express
comes with very very little and you add
in just the bits you need but this is
the motif in the JavaScript world the
motif is we build something as slender
as possible to get the maximum amount of
performance out of this thing that we're
doing so it's kind of like a build your
own application server type of mentality
okay and Express is written on top of
the standard event loop asynchronous
event-driven environment but the node
world is very different if you're
especially if you're coming from the
Java side the node world is very
different than what you're used to in
the Java world what's historically been
there is you get a big sledgehammer
something like WebLogic server and it
contains almost entirely everything you
need to build any kind of application
right it's a sledgehammer
so no js' is almost the opposite of that
you what you do is you just get the
exact pieces you need even very basic
things like session and cookie
management are not included you go and
you build that you go and assemble your
own app server based on whatever it is
that you're specifically trying to solve
so the node world has much much smaller
modules or libraries and the the ideas
that you assemble your own web framework
ok and this can be both good and bad so
it can be challenging sometimes to get
the right types of libraries to fit to
do exactly what you want you have to be
careful that you use something that is
actually supported and has a bus factor
of more than one you know what bus
factor means so if if if you have if you
if you have a project
and you have one person on that project
and they get hit by a bus you have a bus
factor of one which is very bad
right you want your bus factor to be a
little bit higher than that right so
that if like you know two people get hit
by a bus your project won't die right
anyways so there are a lot of projects
that I have projects in the node world
that have a bus factor of one and you
want to avoid those you find something
find another CSV library that multiple
people have contributed to for example
and maintain actively okay and and this
leads to frustration because there's
also no one way to do things all right
and we're not even talking about
front-end framework like no J I'm sorry
like react or angular or view J s or
Batman J s or Sencha or I could go on
and on and list all the web frameworks
that I've played around with but I'm not
gonna bore you with that so that's kind
of that's in the web world but the same
kind of thing is is also on the server
side there are multiple libraries for
doing session management multiple
libraries for doing cookie management
and there's overlap in these tools and
libraries so this is one of the
challenges you'll face when you jump
into this into the node.js world right
it's not something that is is difficult
to overcome it's just something that you
need to be cognizant of and plan for all
right so we have a few minutes to talk
about some tools I think but what I'm
gonna do is I'm going to spend a few
minutes on talking about socket IO and
I'll tell you why that's important in a
minute
so socket IO is essentially in library
for doing WebSockets
WebSockets are persistent connections it
allows you to have a persistent
connection from the server up to the
browser okay and it's a library that
runs both on the server so you run it on
the server know that provides a way to
do the WebSocket type connection up to
the browser you use the socket IO
library in the browser and you can
create a persistent connection because
everyone in here knows that HTTP 1 dot X
is a stateless protocol right you make a
the browser makes a request there the
server says here's your stuff and then
the connection is broken right I'm
simplifying that a little bit but that's
basically how it works later when the
user wants to get more stuff you have to
open another TCP connection or HTTP
connection and you know the cycle
repeats alright so that can be a little
bit inefficient WebSocket is
what specifically solves that it's a
persistent connection and it's very
simple to use on the front and back but
node handles it really well right
because currently the the reason why
we're able to build scalable HTTP
applications today is because we don't
have persistent connections browser
makes a request we serve a response we
break the connection that thread is
available to do something else now all
right so we don't keep these connections
around for a long time so we can serve
lots and lots of requests because those
connections are just not open however in
the world of WebSockets when we have a
persistent connection now all of a
sudden if our app server can only
nominally handle 500 600 700 thousand
concurrent connections now we have a
problem now we have to add a whole bunch
of app servers to be able to have our
10,000 users have this persistent
WebSocket connection okay but note again
because the event loop model handles it
really well I don't want to go into the
code it's really simple anyways so the
reason why this is important to talk
about is the HTTP 2 spec about a year
ago just got finalized and starting to
get rolled out in the HTTP 2x
specification a standard HTTP connection
a standard stateless HTTP HTTP
connection can be upgraded by the
browser from stateless to stateful so if
you plan on using that part of the HTTP
2 specification now you have to worry
about do I have enough capacity on my
servers to handle all those concurrent
Rican current connections because before
those connections were very short-lived
response sorry request response done
next connection next request let's go on
but now if you use an upgrade to a
persistent connection the HTTP 2 spec
those connections will stick around you
need to be able to handle tens of
thousands of connections if you have
tens of thousands of users right so
that's included and if we go back to
this architecture since we run
JavaScript in the middle we're ready for
this today we can have all our HTTP 2
or WebSocket connections go into our
JavaScript layer and it serves as a
buffer or firewall or whatever you want
to call it for having lots of
connections down here in our business
logic or API layer okay so this makes a
huge difference in terms of some future
proofing for us and when we're ready to
have those types of persistent
connections for new features that we
want to do in the future
for our web or mobile stuff we'll be
ready and we won't have to redo our
architecture that lives here all the way
at the bottom okay all right so some
closing thoughts
so all this sounds great but you're
probably sold down you're ready to go
home go talk to your manager or your
your architecture team or whoever you do
in your organization to make these kinds
of decisions like let's add in some note
right but note is not for every kind of
application it is asynchronous and
event-driven so that means when you
write code it's not as simple as get the
request parameters make a database call
format the results send them back right
now in the middle of that you have a
callback that you have to construct to
make that database call and it rejoins
the event loop at some point in the
future so you don't have a clean stack
in case there's an error somewhere in
there right there are ways to Emily rate
that it with some tools in JavaScript
but that's something you have to be
aware but let's say you have to make a
call to a database you get some results
back and you're like well I ran some
business logic through this I need some
more results from a database or I need
to go reach over here and grab a file
and do something now you have a async
function nested inside of an async
function nested inside of an async
function so you have three callbacks
that you have to weave together so the
new versions of the JavaScript language
es6 and es7 specifically have tried to
address this and I think es7 does a
decent job of addressing it but you're
basically weaving together asynchronous
types of method or function executions
which makes your code inherently more
complex remember nothing in life is free
so yes you can do all this but you're
writing in an asynchronous style you
have to be aware of that all right the
other thing is is that because the
JavaScript space is currently moving so
fast it
a little bit overwhelming to keep up and
you have to decide what kind of project
you want to write are you happy writing
project where you need to go back every
six months to a year and maybe update
libraries maybe refactor some code to
use new versions of libraries or a
different library or are you on a
project where it's difficult to do that
and you think of longevity in terms of
maintenance in terms of three to five
years rather than six months to a year
okay you just have to be aware of this
I'm not saying that this is necessarily
a problem but just be aware that the
space is moving very quickly and you
will need to go back and make
maintenance updates and maybe make some
refactor code updates to to keep up with
you know security patches and you know I
mean if you're still using struts I beg
you to please upgrade to the latest
version of struts you have you heard
about this with the whole equifax thing
right so yeah so you know we have to be
responsible developers and make sure we
you know apply security patches or fix
bugs or whatever it may be okay all
right so it's pretty simple to tie a
node.js instance into an existing build
process as part of a CI CD pipeline and
as you saw from the diagram we use
existing business logic stuff and we put
that business we still write business
logic down in our Java and our Ruby
layer because that's where we feel is
the best place to write that complex
code so we don't have those nested
callbacks to do complex things so we
still do that but we use node where it's
appropriate right on the front end and
for doing simple to medium complexity
operations all right so there are some
links at this and I'm thinking I'm a
minute or two over time so thanks for
staying if you have any questions I'll
be up front and we can chat some more
thank you all
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>