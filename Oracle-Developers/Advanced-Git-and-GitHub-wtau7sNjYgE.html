<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Advanced Git (and GitHub) | Coder Coacher - Coaching Coders</title><meta content="Advanced Git (and GitHub) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Advanced Git (and GitHub)</b></h2><h5 class="post__date">2015-06-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/wtau7sNjYgE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">well thank you for coming and my name is
Mike McQuaid I work at github and based
here in the city
well github is I'm actually based away
over in Scotland so thank you for coming
it's nice to see a relatively busy room
of people and if you have any questions
during the talk and perhaps a little bit
different other talks feel free to just
stick up your hands because I find when
we're dealing in kind of slightly weird
advanced get stuff if you have a
question probably a few other people if
not everyone else in the room has the
same question so stick up your hand and
if it's if I can't give a short winded
answer then I will just perhaps postpone
until a discussion afterwards or till at
the end so if you need to contact me
after the talk presumably I don't want
to try and tweet the wife's ting the
talk at the same time that could get
awkward then you can get me on Twitter
or my personal email or website and and
feel free if you have any questions
about the content of talk or get in
general or get help in general then just
give me a shout and I'll try and help
how I can so um just for a quick
overview let's get people standing up
everyone in the room stand up if that's
okay I know that's a bit weird
there we go so if you consider yourself
an expert already in git please sit down
good so if you use git at work currently
then please sit down
if you would like to be using it at work
please sit down
there we go okay well that's I would
hope that those two groups in comes to
everyone so that's a nice start
so as I'm sure is the reason you're here
kind of get is sprouting more and more
github is spreading more and more I
think it's kind of penetrating some of
their bigger kind of enterprise
organizations are getting more
interested in one what get has to offer
and what ghettoize offer and I'm gonna
be focusing mostly in this talk about
git because obviously anything with with
that is applicable to get hub as well
and some of the corners you may not have
seen before so hopefully everyone in the
room is familiar with kind of the basics
of using git of you know committing and
what branch is and what that means
hopefully a few of you at least will
kind of have some understanding of like
the sha-1 hashes that get uses instead
of say revision numbers like subversion
and will dig a little bit deeper in that
stuff but as I say if you have any
questions please just stick up your
hands and I'll try answer where I can so
as a starting point with git
particularly once you start getting into
some of the more advanced workflows I
find it really helpful because I'm
stupid to try and visualize everything
graphically because get as I'm sure
you've learned
unfortunately it's sometimes so first
rating ly difficult tool to use and can
spit out all sorts of crazy messages
that you have no idea what they mean and
when you can then see a graph say of how
things are represented internally and
get and how commits relates other
commits and branches relate to other
branches then it can make it to some of
these things a little bit easier to
understand so there's these tools get X
and get K which get K is provided with
get get X is a kind of vague clone of
get K which is available in the on Macs
and I use a Mac so I tend to use get X
and that will be the kind of screenshots
I'll be showing through here but get X
kind of looks a bit like this on windows
on Linux that looks vaguely similar
there are other kind of comparative
tools that offer a similar kind of get
history viewing and but I'll kind of
focus on those two today because
they're bundled with get or kind of in
it get access case or become kind of a
standard in itself so if I can point
this out with the mic still working you
basically have this kind of interface
where you have a bunch of commits up at
the top here your branches are
represented like so and then you've got
another branch down here and then when
you have a commit selected then it shows
kind of more information about the
commit down here or just switch now to
get X which is the kind of interface
I'll be kind of working through more and
during this presentation and if you're
using a Mac I would recommend checking
this out so gags provides basically two
features and one is you can use this
staging function which we're not going
to cover really today which allows you
to kind of build up commits
incrementally you can you know making
you commit line by line instead of
committing individual files or like
everything in a single commit so that
can be kind of useful and it's worth
checking out in your own time and but
then this kind of adds a list of
branches and tags and things and then
this kind of part in here is what I find
the most useful this is a really simple
example here we've got a commit a git
repository with two commits that was the
first commit that made here and this
will commit a book and this was the
second commit here made here and we can
see these are kind of drawing with a
little line between the two and the top
one has this master blob which means
that that is the tip of the master
branch at the moment you can also see
the author and the date sorry yeah yeah
so there's a bunch of different UI is
the source tree there's github and you
eyes there's tower I think is one as
well so I find if you have a tool
already that kind of displays stuff in
this sort of format please continue to
use the tool you're already using
because it's probably better and it's
just a matter of having some sort of
tool that lets you view this stuff
visually I find this kind of helpful so
we've got all that kind of meta
information for each commit up there and
then the selector commit this top one we
also have information down here delete
the commit we've got the subject which
is
commits are treated a little bit like
emails I'll expand on that later on in
that the first line of a commit message
is referred to as the subject and then
if there's any other lines they're
referred to as the body in this case
there is no body of them than that we've
got the author which is me it's pulled
gags has pulled that little picture from
my email address using like a service
called Gravatar on the Internet
it's got the date that commit was made
this char one of the commits and the
parent commit as well so the char one of
the commits that's what get hopefully
you've all seen these already that's
what gets using instead of revision
numbers and the sha-1 is the hash of
everything that is in this commit so if
the name was to change the date was to
change if the changes in here diag made
the files were to change then also the
sha-1 would change as well and then down
here you can see we've got the the
changes that have been actually made
this file getting practiced or asciidoc
and then the change that look like so so
don't worry if you can't read on some of
these diagrams the text at the bottom
I'll explain what's going on with these
as well so in more detail you can see
that's kind of a breakdown of what we've
got on these lines which are the main
stuff to concern yourselves with this
char ones are normally 40 characters
they can be shortened down to any length
as long as it uniquely identifies a
commit so in this case if you had six be
four and six five seven you could use
those to uniquely identify commits we've
got our branch as I said before the
subject or third date so this is when it
seems a little bit silly in this example
like why do we need a graphical tool
like we have two commits it's pretty
obvious what's going on there but then
one once you start to have stuff like
this this is a an example of the get
history for a tool called C make which
I'll talk a little bit more about this
what's going on here later so don't
worry about understanding the math
that's quite yet and but you can see
this kind of all this stuff going on
loads different commits loads different
branches they're all being merged
there's all these different people on
different dates and times and it's very
confusing
but hopefully with this tool it will
become a little bit less confusing right
so the most useful thing to get it's
being able to store changes over time
and like any version control system go
back in time at later points and work
out why certain things were done and who
did them and when they were done and all
these type of things getting that
context for changes so I'll start with a
few little tools that get provides which
allow you to kind of navigate history
perhaps a little bit more effectively
there hopefully I'm heard of them all so
the first tool is get blame so this
provides a kind of fairly similar
interface if you used SVN blame in
subversion and I think CVS maybe had
something similar as well in that it
will display your file and show who
changed every single line of a file when
it was changed and what commit that was
changed in so what that allows you to
get is as you can kind of get an
indication from the name it's
particularly useful in those occasions
when you're trying to work out which
idiot changes that particular line and
made this stupid mistake then you fire
up get blame have a look normally
realize it was actually you who made the
mistake and then don't tell anyone about
it so that's the example of some output
here where we see like each line here
we've got again a short sha-1 you'll see
this kind of format being used a lot
because obviously the 40 character 1 is
fairly unwieldy and for each of the
lines of this file so this is the actual
contents the file had cut off some of
the ends of the lines here just to make
it a little bit more readable apologies
if that's too small and so you can see
we've got these lines here we can see
they will all change by me because this
is a repository that I've just used by
myself we've got varying commits and
which they were changed and we've got
varying dates in which they were changed
as well and then this line has a caret
character appended at the beginning and
that just means that this was done in
the first commit in the repository so as
I said this can be kind of a useful
thing for working out I find myself
using this relatively often in trying to
work out you know why a particular
change was made
Sayre alliance or skirt doesn't have a
comment and it really probably should
have one then sometimes the commit
message can you know help you explore
and understand a little bit more about
why that was done so the next one is git
bisect sure what the word blame did you
say
sure
so I guess perhaps the workflow with
blame and tools like it can be what what
I would tend to do is if I was say
working on a source code file I was
trying to work out why particularly a
line in that file was done in a strange
way I would then have a look at it work
out what the line number it was never on
get blame specify the file path on the
command line and then that would print
out this kind of format similar here
where I would have the contents the file
and then on each line said line one two
three four five here on the right find
the line number in blame the corresponds
to the line number in my editor and then
basically going query at that point use
git log or get show on this hash here
and then work out what was changed in
that commit and see if that kind of adds
any lights to why that change was made
does that explain it a little bit great
thanks
yeah I'm sure eclipses and stuff like
that will let you do that with a single
click on a single line and but yeah that
depends bearing what idea and you may
have this support a little bit easier so
yeah so the next tool is git bisect what
git bisect lets us do is scan quickly
through history to find when a
particular thing happened so in the most
common case with git bisect is you're
trying to catch a regression that
happened at some point so say a year ago
you knew that this particular window the
new one ever opens in your app it was
all rendered correctly and now it's
rendered horribly so you know that at
some point between now and then someone
broke that window and in some commit
maybe a refactoring somewhere or
whatever
so what git bisect lets you do is rather
than manually go through and say right
I'm gonna go and check out around the
periods of time what was working or what
wasn't or going like scan through the
history manually by yourself get bisect
let's you if you have a relatively easy
way to reproduce the bug it will let you
go through the history using a binary
search so effectively it's a relatively
efficient way of working out when a
mistake was made and then hopefully
being able to use that commit again the
information there I should hopefully
convey something which would then allow
you to fix it quicker so the first
command you run with git bisect escape
by sex start this won't actually produce
any output and so it may be a bit of a
mystery as to what it's done that's
basically just cleaning up from previous
by sex and get anything is ready for you
to go and then you have these commands
git bisect bad and get bisect good so
what you're saying when you run these
commands is if you run it without
arguments you're referring to the
current commit and if you run it with an
argument you're referring it to a
specific commitment so what we've done
here is we've said okay like in that
example I said before we've started the
bisect we've said the
and commit on the branch I'm on but save
master for easiness is bad it has this
bug in the window that's it's gonna be
ugly the rendering is broken and the
commit a year ago and I know it
definitely wasn't broken on this version
because we released it I'm gonna type in
a show on there so then get bisect will
then say bisecting three regions left to
test after this roughly two steps so
what's that saying is that it has three
revisions in this case you know it's not
a year's worth of code it's like five
revisions but it will then tell you how
many commits it still has left to check
and then how many steps I how many more
times you're gonna have to run git git
bisect bad or git bisect good before
it's gonna work out what the problem was
so then you run git bisect good and get
bisect bad sorry so generally the
workflow for that is either you have say
a released previous version so that
could be that hash is almost anything in
ink it takes that takes a hash takes
what's known as a ref so where anything
takes a hash you could also pass a
branch or a tag or whatever instead what
I would typically do with this is if
because typically you'll get a report
particularly in a regression where
they'll say but in version one point
whatever this is all working so if that
was the case it would say version 1.1
then I would go and pass the tag get by
sight good v 1.1 assuming I'd been a
good get citizen and tagged my releases
correctly and if not if there's not a
kind of clear tag like that then I will
just randomly go through the history in
increasingly bigger jumps like jump back
a year jump back two years down by three
years or whatever like just manually and
then try and see whether in fact we try
and find the first place where I have it
where it actually works
so you go through this good bad good bad
cycle and then eventually it will pop up
with this so this was the say this was
the last git bisect bye bye run and then
it says this is the first bad commit and
it will then spit out this type of it
output which is the output from get show
effectively which just shows the kind of
contents and the changes that were made
in that commit so effectively that can
be a relatively quick way of kind of
navigating through and working things
out you know you could just do the
binary search I growing them on paper
yourself and work out the best way of
traversing through the history but
that's no free time affected that's what
computers are for and the one caveat I
would say we get bisect is when you get
certain bugs that say you have a bug
that was kind of occurring and fixed and
occurring and fixed in the current fix Y
SEC doesn't work particularly well in
those cases because it effectively is
looking for the first time the mistake
was made the first bad commit he could
find so if it's bad get bad commit good
commit following right after each other
then it will just find a bad commit
before a good commit so you really want
to use this in the cases where you have
you know chronologically something was
broken at a single point in time and as
a remain broken since then yep how'd you
tell it that you had a bad commit and it
in the same way as as this so you would
just pass an argument when you run get
bisects bad
so get bisect bad you could pass this
sha-1 has the argument there
i doesn't know what come it wasn't bad
so I already come it was bad so you need
to tailgate for every commit that it
kind of traverses through so when it
when it's doing this perhaps I wasn't
clear that here when it's doing the
bisecting what it that is at the bottom
is it has changed to a new commit so
effectively get will every time you type
good or bad after the first one get will
then check out another commit and jump
to a new location and then it's up to
you to test that work out whether it's
good or bad and then type git bisect
goods that will get bisect bad depending
on the result that's led relatively
nicely into the next thing so again this
is kind of cool but it's a little bit
dole how to type git and bard all the
time so and I'll get to this in a second
brief tangent if you had a look so what
you do at the end this you want to get
by Sacre set to kind of clean everything
up that's when you've kind of found that
the commit you work now but if you
worked in get X before that you would
see that gags creates sorry not get acts
get creates these kind of references to
the bad commits that you point out and
the good commits that you point out in
here as well so again now you can sort
of understand maybe a little bit of how
this tool is like traversing through the
history by running git X and kind of
what get K and viewing how things change
as you run each and get bisect good and
bad so again this is fairly basic stuff
like the performance of a binary search
but you can kind of see it it ends up
really adding up when you've got say
maybe a year's worth of changes say a
thousand commits having to check
nineteen commits rather than checking a
thousand commits or working out your own
little algorithm makes things a lot
easier but the really cool thing to do
is there's this command git bisect run
and what this does is rather than you
having to manually each time work out
whether a commit was good or bad if you
can write a little unit test or say it's
a compilation failure or just generally
any little script that can reproduce
your failure and return a UNIX exit code
zero or one depending on whether it's a
success or whether it's a failure then
you can actually like get its rate
through the history yourself and the
first time you do this it's pretty cool
it feels a bit like magic but in this
case what what I've been testing in this
git bisect example is whether a
particular file exists so this is saying
list this file name here so what is
going on here when I ran git bisect run
LS get in practiced or ASCII dog that's
going to go and return a true status for
when this file exists and return a full
status or a one exit code when it does
not exist so what it's doing here is
rather than you haven't typed it by
sight good and bad each time it's
effectively just running that for you
based on the output of this command so
it's doing bisecting three rooms left to
test off the list it then runs the
command sees the output and then here
the so it sees the output gets the file
so that's a good one goes down here it
runs it it gets no such file at the
rectory so that's a bad one and then it
bisects down the same way and then it
will also print out the kind of full
commit at the end and you get a bisect
run success I've just trimmed the full
commit there for readability this is
particularly useful if if you can again
being a relatively good engineer and you
can write a unit test which reproduces
the bug then if the unit tests you can
run it individually you can then just
leave get to go and iterate through the
history and work out which commit broke
that unit test
yes that yep yep
exactly so if the unit test is checked
then then it will change as well very
good point so what you what I typically
do in that situation is just pull the
unit test get it so it's relatively
self-contained pull it into another
directory and then just have it
somewhere where get is not changing it
there's probably more clever ways of
telling it to not change that file but
that's the way that I find is the
quickest and easiest for me great so now
we're going to do some slightly funky
stuff with branches so I'm sure you've
all at some point if you've been using
git and have um using branches had to
deal with a merge conflict it's you know
those moments in your day when they
haven't and you decide it's time for me
to give for lunch now and delay this
painful process now the only thing more
annoying I find than solving merge
conflicts is having to solve the same
much conflict again and again and again
and again so get actually has this
pretty cool tool called get really read
one of these weird but cool things and
get that I don't quite understand why
it's not in it will by default so what
riri stands for is reused recorded
resolution so what that means in kind of
human speak is if you solve a particular
merge conflict once and get sees the
same words conflict again from the same
input files not necessarily the same
commits then it will say AHA you have
solved this much conflict before I know
you've solved this I'm gonna store this
and then next time you want to resolve
it again then I'm gonna go into fault to
the version that you used before so
let's see a little example so you enable
that you can enable that on all you'll
get repositories by running this command
here I would say if you're have notes
people are feel free to take pictures
and stuff of the slides if that's kind
of easiest but they are up on the oracle
uploader e presentation anything and
they're on like speaker deck as well
like all updated so they're on straight
up to this talk if you're kind of having
a look and they'll be on my website as
well so they should be pretty easy to
find so don't worry you can't get
everything done so if you run this
command then that will add
an entry to your configuration file
which basically just enables riri which
will appear to not do anything until you
start having some most conflicts so when
you have a merge conflict it will say
that it's as I will show you in the next
example because it does it again it will
if I know or look at this first so if
you make a commit and you have to
resolve in most conflicts then it will
say this recorded resolution for this
file name and it will do that every time
you record sorry every time you resolve
a merge conflict that committed the
future so then in future
say you're doing the same March again
you would get this so it you will say
the see the normal painful oh no it's a
conflict in this file but then here it
says resolved this conflict using the
previous resolution so it's not quite
magical enough that it will then just go
and commit and pretend as if there was
never a merge conflict and the reason
for that is in case you didn't want to
resolve this merge conflict in the same
way it would be kind of annoying if it
just automatically did it all for you so
what it does do is it effectively
resolves it or when the files sets the
fast the state that they would be in as
if you would resolve the most conflict
but then you still need to do the usual
gits add of the file and get commit to
actually fully reserve that much
conflict and fully resolve that most
conflicts sorry um and then you can use
I'm not going to detail the exact
commands but if you look at the man page
forget riri you can see there's get
really read clear I think it is and that
what you can use to nuke all of the
existing recorded resolutions you've
made if you just want to get rid of them
yep
so you could do you but it would need to
be in some it's not supported officially
by get effectively that because the file
is stored within the docket subdirectory
and it's kind of treated as part of the
repository metadata and it's not
something that's sent to and from
servers so you could kind of make a sim
link to that directory or whatever and
use that as a way of adding it to your
repository and kind of store it I kind
of out to ban that way and encourage
other people and your team to do the
same and and the file is basically just
looked like there I don't think I've
opened one of the text editor recently
in a car actually remember whether
they're binary or kind of readable text
format but effectively that's what they
are they are just a read a file that
obtains the metadata of like what was
the what state was what the sha-1
effectively was of the conflicting area
and so it can fingerprint that and
detect it in the future and then what
the resolution was when you had this
fingerprint for this particular merge
conflict in my experience I've it's one
of these things where they say you know
use with caution
I've had this enabled my machine for
like six or seven years and I've never
seen it do the wrong thing and like it
always like if anything it seems to
verge on being relatively cautious so
it's only if the merge conflict is
absolutely identical and that it will
reuse the same thing so get described so
again this is one of these things where
depending on what type of software
you're working on this may be usable or
useless way so a relatively common
problem I found like I'm a big sort of
advocate of continuous delivery and use
integration stuff of basically every
time you have every time you commit a
change to your software you should have
a server away and he farm somewhere or
in the cloud and that's going and
building that and producing outputs or
at least running tests and stuff like
that the people can then go and see okay
what these tests have passed when I've
worked on desktop software in the past I
also like to be able to say okay well
not just the unit tests if they're
surpassing and that it compiles but
so let's have an installer somewhere
that I can go and you know provide to my
boss or whoever doesn't have a compiler
installed on the machine so they can go
and download this software and try out
this is pretty useful for kind of move
out as well but a relatively annoying
problem you can sometimes run into is
with subversion you might if you have a
V zero point one of a software you've
released your p zero point one and you
want to say okay well this is V zero
point one plus some changes from
subversion then you could just go and
append on the revision number so V zero
point one - three two one
and the nice thing about that is when
someone makes a new commit in revision
three to two and I did wait I mean make
sure I don't say the numbers there and
so say you had commit 400s and commit
401 you can say Oh hooray
because commit 401 is later than commit
400 so if you're sorting it's using you
know normal tools it will work out that
401 is later than 400 with get you have
a slight problem because sha F a be one
two three is not necessarily easier to
sort if you don't speak it natively then
shot CA be one two three which may be
before or after or at the same time or
whatever so what is a useful tool for
this is get describe so get describe
lets you effectively generate a version
number based on tags so its simplest
level you would run it if you were on
the tag on the commit that was tagged v
zero point one then it will just output
a V zero point one happy days that's
telling you the version number so what's
more interesting is if you have had some
commits since that tag so in this case
we've had one commit since V zero point
one so we have what this is doing here
is saying describe the current commit
based on the tags in the repo so the
last tag that was made on this branch
was V zero point one and this is we've
had one commit since they're on this
branch then the the G bit is just saying
this is a get sha-1 not to be confused
with something else and then there
that's the sha-1 of the revision
in there so I like to kind of have this
type of versioning for you know file
names because they're nicely sortable
but it's also useful for you know
displaying and about dialogue or
whatever in your application because it
means you can identify exactly what
revision was used to build the software
but then you also have something which
is nicely suitable as well but it's
obviously because this number is
afterwards then that's gonna be sortable
nicely as well so get cherry-pick and
allows us to do basically if you may
find we'd get your merging commits
between branches there are some times
you want to just have a single commit
taken from one branch to another you may
well have seen this command before if
you haven't basically what it lets you
do is exactly that you can specify a
single sha-1 or you can specify a branch
name and get the commits that's at the
tip of that branch and then importance
to the current branch so in this case
I've specified get cherry-pick you would
probably normally see this used with a
sha-1 but I've specified the branch name
just to kind of make a point here that
we're taking the commit that sort of tip
of that branch and then work in porting
into the current branch so you will see
the sha-1 change from what it was if you
would specify the show on here that
would not be the same as here because
the parent has changed if you're
importing into your branch it will have
a different parent and and then it will
display the commit message as it is done
you get cherry is not to be confused
with cherry pick it's complete almost
completely unrelated other than it can
be useful in detecting if someone in
your team has gone a bit Mads and over
excited with cherry pick because what it
can do is if you run it if I'm on a non
master branch here and I run get cherry
- - progression master that will display
this alpha here I've cut off the commit
messages here a little bit to me that's
mildly more readable and it has these
minus and plus on each of their commits
so minus means that this is what's known
as a droppable commit so this commit is
in
branch that I'm more currently on and in
the master branch so we don't need to
worry about trying to cherry-pick or
much listen and then this commit with
the plus is a commit that is kept and so
this is a commit that is not already on
the master bunch so one that you might
want to consider cherry-picking into the
master bunch so now for the scary bit so
I'm sure everyone's heard or used with
git rewriting history
so it's praised as being kind of gets
best and worst feature depending on who
you listen to
I would probably agree with both people
and but it can be a bit scary so the
first thing I'd like to tell you and I
will show you this in a second is that
despite allowing history writing in a
gift it is actually very very very very
hard to lose information you've
committed the important bit in there is
information you've committed if you have
a file on on disk and you delete it
yourself or ask it to delete it it will
do that very happily and you will cry if
you have a father you've committed then
it's actually very very hard for get to
lose that information so take that as a
caveat for going into rewriting history
lines so briefly actually who in the
room has done anything has knowingly
rewritten history and gates if you just
raise your hand out of interest okay
cool so the first thing I'll show you is
this is kind of like teaching you how
this safety works before you get to play
with the rest of the gun and get ref log
is you probably will seen get log used
or get log it produces a similar sort of
output on the command line to what get X
does and what kind of source tree and
tower and things do what get ref log
does is rather than tracking how a
branch has changed how the commits on
that point have changed it tracks how
the branch pointer has changed so there
may be a slightly confusing consult
concept but a branch and get similarly
to a tag
similar to a sha-1 they all represent a
single commit and all that branches is a
particular pointer to commit that means
that when you commit when you're on that
branch get will point the branch pointer
to the next commit and the next commit
and the next commit as you continue to
commit on that branch there's also
something that sooner is the head
pointer now the head pointer tracks
whatever your current state in the git
repository is so when you check out a
new branch say you check out master and
you go on a bounce called testing before
the head pointer is moved to point from
master to testing and then tags are also
pointers to commits but then generally
they will always point to the same
commit you can move them but they are
not moved automatically and it generally
is not considered a good practice to
alter tags once you've made them so
that's how we look at a ref log so here
if you type just get RAF log you looking
for the ref log for the head pointer
which as I said is the thing that tracks
what you're doing and get so here we
have it's working chronologically
bottom-up so the first thing we did here
that the ref log showing a second way is
we reverted this commit and then we
checked out another branch we moved from
the master branch to the V zero point
one release punch we then made this
commit on that branch and then we moved
to the master branch again so you can
actually use this pot here head at and
bracket what 0 1 2 3 you can use that to
refer to these commits as well obviously
from the ref log head 0 points the last
thing you did so when you do something
else if you check out another branch
then that will point to another commit
but then you can't use these as I say so
well I encourage you to do with git ref
log kind of like we were saying with get
X or you might do is get log when you're
starting to play with history rewriting
have a look at the ref log and it will
explain what's going on because what
happens when you rewrite history and get
is as the contents of a commit changes
or any of the metadata
so does the sha-1 so if you have two
commits where say the dates have changed
between the two and nothing else then
the sha-1 will be different between the
two and one of the very nice things
about kids is that when that shall want
changes the old commit is still
accessible for 30 days by default so
that's when I say by default basically
unless you are like hacking on gift
itself like you will not accidentally
change that setting fear not
so again to re-emphasize that effect it
means anything where you're rewriting
history
you can type git ref log at some point
in the next 30 days on this as long as
it's on the same machine that you did
the first thing on and you can get back
to where you were before you can recover
that state you can then go and check
that out or make a branch based on that
old commit or whatever so if you're not
so the first example are rather this
simple example of rewriting history will
see as git rebase so rebasing is a bit
like merging it's a way of getting
changes from one branch onto another
branch but the way merging works is
effectively you pull all the changes in
from a branch into another branch and
combine the two rebasing works by
changing the parent of a branch so you
say if I have these commits here and
these commits here I want to go and put
all the commits I have here on top of
the commit so I have here that may
appear to make no sense but I'll
hopefully demonstrate with a diagram so
if we use this check out - B that's a
handy little shortcut certainly you can
create a branch and check it out in a
single command check out that B
inspiration B 0.1 so what I'm doing here
it's saying check out the V zero point
one branch so I check out the visa point
one tag but making you branch from it
pull the inspiration and it says here
it's switched to him so if we run git X
then that's what this looks like so we
have this tag here and V zero point one
and this new branch and you can see the
line joining the two so there's no other
commits other than this one commit here
add chapter one inspiration in on the
inspiration branch
but see we want it to get actually we've
made the inspiration branch from this
tag but what we should have done because
we've got a release branch say we're
preparing a V zero point one one release
we might want to use this release punch
instead so well some what you would do
if you weren't rewriting history is
maybe say you know darn I'm gonna delete
this branch I'm gonna check out based on
this instead and I'm gonna make this
commit again but instead what you can do
is rebase so what we're doing when we
rebase as we're taking this commit and
effectively that line joining that to
this commit so the parent of that commit
we want to no longer be this commit but
instead be this commit so to do that
type git rebase V zero point one release
it says a slightly bizarre thing
rewinding head to replay your work on
top of it what that's saying is that
it's going back to this point first so
at this point here first and then it's
gonna replay I effectively cherry-pick
any changes on the current branch that
aren't on this branch on top of it so
it's then applying this which is again
this can be here and then after that get
X will look like this so instead of you
need to ignore this slightly confusing
fact that what get X does is really
flows things around so although this is
in the same place the important thing to
look at is the lines that are joining
the commits and not the position on the
page but this commit now it's parent
commits is no longer this one but it's
now this one instead so it's now based
off the release branch so now if we want
to merge into the release branch or just
generally use other work that was on the
release branch like headphones
practicing it here then that will now be
in our inspiration branch
yeah so much conflicts are handled in a
similar fashion so instead of one of the
vaguely nice things about rebase is
merge conflicts you still need to
resolve them in the same way what it
will say is you know there's a merge
conflict and then it will stop you and
you need to resolve that and then you
run git rebase - - continue if you look
again through the help page I don't have
time unfortunately today to work through
a really detailed example but that will
kind of work through the workflow of
using continue and abort and skip to
kind of jump through commits you resolve
that arch conflict but one of the nice
things is you then don't see any
evidence for that much conflict
afterwards some people may think that's
a good thing or a bad thing but as we'll
see later on I like to use rebase often
with like open source projects and stuff
like that where or if I'm doing lots of
stuff locally where the fact that I've
made a mess of my get history is not
interesting to the project it's
interesting to the project if we've
merged the branch perhaps but it's not
interesting to the project if I
accidentally merge this branch in here
and edit to this file and I didn't mean
to and you know that stuff is not
important and we shouldn't change that
stuff after the fact we should you know
use this power to go back and say oh
yeah they're definitely stupid a year
ago I'm going to now try and change all
that like that's a bad idea but if
you're doing stuff before you share it
with others
stuff like rebase can be really useful
in terms of just cleaning up your
history as you go along yep
so it has effectively created you're not
gonna see another commit after the merge
conflicts yeah
so in this case even if this have had a
merge conflict here it would still look
like this afterwards whereas if it had a
merge conflict and it was emerged then
you would have the kind of line across
there but again like with cherry picking
you should notice that this sha-1 now ID
4 is not same as it was here and that's
because the parent sha-1 is considered
part of the metadata for the commit and
as the parent shot one has changed
nothing else on that commit has changed
except the parent shot 1 but then that
means that when you rehash the commit as
git does then you get a different show
on here so if we wanted to we could go
and type get check out this or whatever
and we could go and get back our our old
commit without and before it been
rebased
so git rebase - i is a slightly more Oso
yeah
so the only reason it's showed there is
just the weight get X does
it's just reflow effectively to make it
look nicer it's not the the ordering
yeah exactly it's not this isn't
chronological between this commit is not
necessarily before after this one it
basically just tries to orient the
graphs in such a way that they are
readable so yeah so that's a very good
question that's a one caveat with get X
is that that's why it gives you this no
I'm not going to go all the way back
there but that's why it gives you the
date column effectively on the sides
because the dates may not be in any way
chronological like as you go between
branches
yes it can be yeah you can have I'll
show an example later on that will see
that you can have history and get where
the date and time and appear to jump all
over the place because get actually has
two dates and time for commits and
confusingly has two people for commits
as well in that it has a date and time
the commit was originally created and
that never gets modified and then the
date of time that they get that they're
sorry the date and time the commit was
originally authored which never modifies
the date time the get the commit was
committed which does modify as rebased
and cherry pickers and things like that
the char still exists in the repository
so it no longer it's pointed to by the
inspiration branch but it still exists
in the repository for 30 days it's
effectively hidden away and you wouldn't
know it was there by looking at just the
output of get X will get log but it will
shop and get ref log and it will is
still a char that you can access
so get ready better - I and I'm gonna
start flying through things a little bit
quicker just to try and get as I find
with get stuff that because the
conceptually because what this stuff is
so tricky it's like what I'm trying to
do is almost give you stuff in a googler
bull format in future so that you can
kind of say okay I know this is a thing
I can do I can't remember how to do it
at all but you can get enough
information to know that this is
possible so I'm gonna race through some
things just so that we can see that
they're possible so git rebase - i is
kind of a more advanced version tree
base that lets you play around with
things at each stage so here we see we
did a rebase on a particular tag of a
branch and we see all the commits that
are different between that branch that
tag sorry and this branch and then in
these commits what we can do this pops
up in a text editor
so rather than just being out put on a
command line and these lines that start
with a pound or hash or comments so it
explains that here effectively what the
commands are so by default it's got a
pic before each one which means just use
that comment so if you just open up the
text editor and then closed it again
save it and close it then it will do
exactly the same thing is without
interactive but what you can do in the
text editor is you can start doing all
sorts of crazy things I can cut and
paste that line add a release preface
put it above advanced practice technique
and then after the rebase those commits
will have the ordering flipped I can use
reword which lets me when it's a
rebasing it will stop pop up another
editor and say hey you want edit the
commit message on this and you can
change that I can use squash which lets
you combine commits together and combine
the commit messages together fix-up
which is a bit like squash but lets you
combine commits together but just
discards all but the first commit
message and exact which lets you run a
command that around in place but that's
really is so this is as I say something
I'm not going to going through a huge
amount of detail but in my personal kind
of tool belt this is something I use
like constantly so during the day when
I'm committing like I don't write
beautifully ornate commit messages while
I'm working I write like work in
progress test fish fish one fish two
whatever and then what I do is when I'm
wanting to thank go and push that branch
later on remotely I will run git rebase
interactive and then I will go through
all combined commits together or split
them apart I'll give them better commit
messages I'll reorder them in a way that
makes more sense and what I would
encourage you to do particularly is
you're trying to become more advanced
with these type of things is really take
pride in what you're get history looks
like when you push it to the repository
and this tool should allow you to do
that it should allow you before you're
pushing a branch to modify that branch
such that it looks pretty and has things
in nice small commits and in a sensible
order yep what was that's right and what
you can do is you could use edit to stop
them and amend them or you could just
and remove them from here and recreate
them or the two I'm not going to go into
today is get reset that's what I would
use most commonly where you can
effectively undo a commit but leave the
changes that that commit made so if you
do get read if I was after doing this if
I did get reset and then say this one
here I get reset a Papa bar then it
would have the changes he replied and I
could commit them later in smaller
chunks right filter branch really not
going to cover this one much but
effectively this is a tool that lets you
go through your entire history and do
stuff to the entire history so in this
case I'm going to rewrite my entire
master branch to remove this particular
file don't worry about all these flags
this is pretty much directly copied and
pasted from the git filter branch man
page but this is useful for those awful
situations where you realize you've
accidentally committed your AWS
configuration or whatever to version
control and you can then do this to then
go and remove all this stuff from the
entire git repository the only thing is
obviously because of how git works
you're going to need to get people to
reclone the repository after you've done
this if you want to go and remove this
stuff from all the branches as well
otherwise exist on people's local copies
yep
yeah well not before they push but you
could use this after they've pushed to
then remove it because again yeah that's
the classic problem with get is if you
commit 20 Meg file and then you remove
it afterwards that Tony won't file is
still in the repository history
forevermore
so again yeah this is a useful kind of
thing for that scenario it's a bit
drastic but again it's useful in drastic
situations so git config is what you use
for personalizing you get we've seen it
already a little bit with using git riri
to kind of configure this particular
setting I recommend having a look at my
git config online I could talk through
everything but again that would be a
talk in itself because it's like a
couple of pages I have like every line
commented to explain like why I have
been able this configuration setting and
like why my aliases are what they are
and like how things are working and
stuff like that but basically allows you
kind of like your bash configuration or
whatever to make yourself more efficient
when you're using git to shorten things
for example that at the very basic level
you will have a git config file and your
home directory already and which should
have this in it which is basically just
your name and email which get uses for
commit information but then you can add
more stuff to it such as aliases so when
I have in mine is i alias l to get log
data so graph that as one line that's
just decorate and and that basically
gives a nicer kind of log output that's
kind of very information dense quite a
lot like get X on the command line if I
just type to get L which is coming handy
you can also use this as a silly thing
but random interesting thing get also
source any scripts in your path which
are named like this gets - whatever so
if you have this get - GC global you can
run get that GC global without the - and
it will run that script slightly
pointless but still interesting perhaps
so how many people have used or trying
to migrate in any way from subversion to
get okay a reasonable number so again
don't have time to it could be a full
talk by itself checkout get SVN if you
don't already know
gasps Fiona allows get to talk to
subversion repositories allows you to
for one point of view just migrate them
to import the entire contents of a
suppression repository including all the
branches and tags and stuff into a git
repository and but also you can then
commit to a subversion repository from a
local git repository which is pretty
cool and I used that when I was gonna
learn and get for the first kind of few
years back when it wasn't cool and well
it was probably still cool but no one
used it and and I was 42 subversion so
you can use git SVN like to stealthily
use git and learn get in a work place
where maybe everyone's still eating
sober version so some very brief get
best practices so commit messages like
you want to describe obviously Newcomb a
message what you're doing but again a
helpful way of thinking about them it's
like an email so you on the first line
to be kind of roughly 50 characters or
less you want it to think of it as like
the subject of an email and then you can
have a longer commit message after that
which spans a few lines which none of
those lines should be kind of more than
about 76 80 characters so and the reason
for that is because git can turn commits
into so I get can turn commits to and
from emails so in this case we've got an
email that was turning from a commit
down here we've got all the metadata
from the commit and then the contents of
the patch there as well so I'm running a
little bit low on time so I'm not gonna
be able to go into this in much detail
but effectively you can see kind of
different types of history here and see
make has a very merge heavy workflow
here home brew which is a OS X package
manager which I work on has the kind of
very rebased friendly workflow so we can
see as I seen before the dates aren't
necessarily all in order but they are
generally on branches
whereas on home brew it's all over the
place and you have all these dates are
kind of jumping back and forwards and
you can see even though there's not
branches being merged in here you can
see sort of semblance of branches here
from all these ones by the same
committer with ascending commit dates
there have been merged they'll be merged
in here by rebasing first and then
merging afterwards which means that it
will pull them all in without a merge
commit and some very we get hub tips if
you haven't already of your command line
person
check out this gh tool or there's also
the cool tool called hub which you can
use on the command line to do some kind
of get operations so I get hub specific
operations you can run pull request to
get pull requests URLs and actually
create the pull request on github itself
and you can use fork to fork a repo
another one on github which you probably
seen is you can mention people by name
which is a useful way of kind of
ensuring that someone who isn't already
on an issue or a pull request as to see
the stuff in that yep yeah I think it's
only supports Gabe I'm just gonna
basically skip to the end of this so
we've got time for a couple of questions
but yep so you can also a PennDOT patch
on the end of a PR to get this kind of
patch email format that's can be useful
and on the end the commits as well
specify issue numbers and your commits
to close them like so there's also SVN
at github you can this is not very
widely known but you can use SVN to
check out github repositories if you
want to do almost the reverse of ESPN
and interact with a Garib repository
using subversion okay so hopefully that
has kind of it's been a very brief kind
of run through of some of these features
if you want kind of more information
after this talk as well and I feel as
always horribly embarrassing to do stuff
like this but I've just recently I'm not
an author I'm a software engineer I've
just recently finished a book called get
in practice
with this lovely lady on the front and
and I've got a few complimentary copy to
the front for people and if you come up
and talk to me afterwards so if you're
interested there's also you can buy it
from this URL if you want to buy like
the eBook version or whatever and you
can google for it but if you use this
URL which again will be in the slides
and stuff then I get like 1.2 percent
more money and there's like they're
being sold at the bookstore and I'll be
around tomorrow to kind of answer any
questions if you have it at 12:30 and if
you don't want read my book then there's
the get book the official get book is
written by a co-worker of mine who's
very very good and the github help is
also good so worth checking them out and
again feel free to contact me if you
want to I think we're probably running a
little bit late for questions but feel
free to if you're not interested in any
questions and feel free to leave I won't
cry and but if you have questions stick
your hand up and I will hopefully
they'll help yep on get flow again plug
plug I write about in the book but
basically I think it's almost always
overkill like it's a very complex
workflow I've perhaps I've never
personally seen situations where it I
feel it's complexity is necessary but
yeah I mean I think it works for some
people
like I have a kind of slightly modified
version that I use which kind of cuts
down on quite as many branches and
internally at github we used like github
flow which I've done have you seen which
is like basically just everything lives
on master make a branch from master
merge about the master and
yep sure so yeah we I mean even in our
github enterprise product we don't
really use github flow where we have
long lived release branches and again
like effectively we have a slightly
modified version in that we kind of use
github flow but then we also have almost
like a couple of other master branches
that we used for stabilizing releases
which similarly have PRS that come off
and come back but we try and not have
too many ongoing like long-running
branches as maybe like you know one for
each release released version that we're
still kind of maintaining yep
preferred git workflow in terms of what
I get flow or yeah so I mean personally
I I almost don't care that much on the
way the branching is kind of done like I
mean get help we tend to just feature
branch pretty much I mean we just branch
for almost everything and just because
that means we can use pull requests and
do code review that way and but I don't
have massive prophecies like where I do
have provinces that I rewrite history
like crazy like I use git rebase very
very often and git rebase interactive
particularly to try and make sure that
my commit messages are nice and my
commits are nice and small and you know
make sure that what ends up getting
finally merged is something which makes
kind of sense and hopefully each
individual commit works each individual
Macomb it is small enough to be kind of
testable and reversible and that's I
guess that's the big thing for me is
working on homebrew we have lots of kind
of packages and update mechanism is done
through get so if I if I release a new
version of a package and then that's
actually bad I want to revert it it's
very important that that change to that
single
she was done the simple commit if that
was in a you know say we changed 20
packages at once and that was all done
on one commit it would be harder I would
revert that but we require me you know
Phi Alpha text editor whereas if I keep
everything in the single commit I can
use git revert to just undo that single
commit and then push it and then that's
a really quick way of you know getting
around problem so that yep
I basically treat I'm walking to a
github which I think it works really
well it's just you have effectively one
integration branch for each stable
version as I think I was saying before
so if say you have you know version if
you're supporting a version one and
version 2 of a product well let's use
semantic version properly so if you're
supporting version 1.2 and 1.3 or
product there would be a 1.3 sorry a 1.2
release branch at 1.3 really sponge and
stuff would be merged or cherry picked
accordingly to those branches depending
on what release you wanted to go into
and then you then branch later on branch
things out depending on where you know
where you want to pull your new release
from be it master or an existing release
branch or whatever sub modules and
useful in some circumstances for like
dependencies basically I don't I don't
try and use them laws yeah we I'll
continue to answer questions but I'll do
it at the front without the microphone
and stuff so thank you everyone for
coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>