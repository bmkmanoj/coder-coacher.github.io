<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>How Lucidchart Scales with Play, Akka, and Scala | Coder Coacher - Coaching Coders</title><meta content="How Lucidchart Scales with Play, Akka, and Scala - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>How Lucidchart Scales with Play, Akka, and Scala</b></h2><h5 class="post__date">2015-06-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/SpxwoLNROfs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you everyone for coming out I'm
Ryan Knight from type-safe I do training
and consulting for typesafe I do
training consulting around Scala och and
play um typesafe if you not familiar
with it I'd say if it's the company
that's basically driving the Scala play
and akka activator so we're driving all
those products and then we provide
commercial supporting consoli behind
those dead right I'm brain pew I'm from
lucidchart and I'm going to give you a
little more background about lucid chart
because we're going to use loser chart
as a case study of how we move to the
type safe stack and kind of how that
worked out for us so I'm going to dive
in so a little bit about lucid chart
what is lucid chart it's an online
diagramming solution so think of
microsoft visio meets Google Docs it's
all online html5 JavaScript
collaborative and you can do you I
mock-ups flow diagrams floor plans Venn
diagrams or charts any of the type of
diagrams it might be accustomed to all
on the web and a little bit of our
history so we started in 2008 our
founder been dilts was working at a
start-up and they had a couple of visio
licenses a lot more people than they did
vizio licenses he was one of the few who
had a license so when people needed a
big changes to these big healthcare
diagrams it's a health care startup
they'd come talk to him and he would
make the change then email it out to the
couple of other people have had vizio
licenses and then realize if somebody
else had made a change they'd have to
try and rectify the versions and it was
all just really painful and basically
sucked so he kept thinking there's got
to be a better way than this so he
started spending his nights and weekends
trying to figure out how to do find
something better than this he didn't
find anything better so I started
building it himself and by 2010 he had a
basic product that was workable and so
he decided to kind of form a company and
that's where lucidchart began was in
2010 when been for the company to build
an online diagramming solution so
throughout 2010 lucidchart gained a lot
of traction and throughout 2011 we grew
the team a lot and our user base entry
increased by orders of magnitude so by
the end of 2011 lucidchart was well in a
pretty precarious situation
what happened is we had so much growth
so quickly there that we had some
serious problems that threatened us as a
business and I'm going to go over what
those problems were first skeleton so we
had web servers and we could scale
horizontally but the number of web
servers that were being required in
order to serve the user base that we
currently had was way too high and it's
way too expensive so we were concerned
that if we wanted to grow again by
another word magnitude we're going to be
in trouble the second problem related is
scalability was the database we had a
single relational database and with a
single relational database it's very
hard to scale out or horizontally you
can keep throwing more hardware at the
single box more cpus more cores more
memory faster disk but it's very hard to
scale out or horizontally with a single
relational database so this was our
first big problem second was performance
both our minimum and our average
response times were just way too high we
needed to get things quicker just simple
request that really wasn't doing
anything just to get through the
framework we were using PHP at this time
and just to get through the framework
the minimum response time was higher
than what we wanted so that was a
problem and then again not just the
minimum time but our average time was
also way too high and the third thing
was availability so it was a single big
PHP monolithic application so any
functional area of lucidchart could
bring down that whole web server if the
generation of images started eating up
resources state CPU then my user login
functionality could also suffer because
it was all running on the same same box
so we didn't have to doubt the uptime
that we wanted and I mentioned the
database not scaling the inability to
scale the database the way we wanted to
also led to some high availability
issues so here we were at the end of
2011 and we realized that significant
change was needed right we needed to
make some significant changes if we
wanted to grow to where we wanted to be
as a business and to give our users what
we wanted to deliver to them so we got
together and kind of identified eight
architectural goals we had four
lucidchart in order to solve these
problems
through what they are first we wanted to
move to a services oriented architecture
rather than this big monolithic
application we wanted to have lots of
individual service and each each service
knew how to do one thing well and this
will help us with scalability because
you can scale each one of those services
independently as well as availability
because if my image generation service
that I talked about is eating up
resources that doesn't affect my user
service so users can at least still
login so services are in architecture
was one of our goals that we've set out
second little if any server site state I
mentioned that the minimum response time
was way too high even for even if the
controller wasn't doing anything it took
way too long a lot of that had to do
with framework code loading all kinds of
stuff into our session and that just
takes time and we wanted to have as
little of that as possible so that we
could get super fast response times when
we needed and only load what we need
when we need it all data sharted so it's
very hard a single relational database
is very hard to scale and we didn't want
to ever get bit by that again so
everything we do in lucidchart we always
shard all of our data now we look for
sharted data solutions because it gives
you the options to put chunks of data on
different servers so you can scale out
or horizontally in addition to
vertically each one of those a
persistence layer that allowed us to
control queries we're using the cake PHP
framework that has an ORM built into it
and turned out the object relational
mapping constantly was creating queries
that had terrible joins in or they did
acquis readin results exactly the way we
expected so it didn't end up using the
index that we put on the table so that
it would use it so we wanted we wanted a
persistence framework that allowed us to
control those queries and make sure we
were able to get the performance we
wanted out of our database great library
support we set this as a goal because
PHP actually does really well here we
were really happy with whenever we
needed to do something to PHP we could
find a library that would help us out we
didn't want to lose that so this was a
goal to say as we reconsider these
things and different technologies we
wanted to make sure that we still had
great library support good time run good
time monitoring I always felt a little
bit like it was I could get some
information about the run time with the
PHP runtime but it was always hard to
really know what was going on in there
there were some tools but I didn't feel
like it was really up to snuff as I seen
with other other technologies that I'd
used in the past efficient development
environment this is another thing that
we had had with PHP it was PHP you make
a change you hit refresh and it's
immediately there and it's great we
didn't want to lose that so it's another
thing where PHP does quite well however
support for parallel processing is where
PHP falls flat it's terrible when it
comes to parallel processing and again
going back to those issues that we had
performance and scalability not having
any support in our language or framework
for parallel processing was a real
negative and a real problem for us so is
there any all-in-one solution that's
going to give me all these things you
know those are the eight goals that we
had set out as we looked at crossed and
tried to find a solution and we looked
at other PHP frameworks to see if we
couldn't find something that might work
in PHP we looked at Java frameworks
spring MVC some things like that and we
looked at scala lift and play options
that would be available in scala and for
us we decided to go with scala and play
so i'm going to talk through a little
how skull and play played out for us how
they met those architect those eight
architectural goals we had and some pros
and cons that we ran into but before I
do that I'm gonna turn turn it over to a
Ryan to kind of talk through what is
Scala what is play and what is the type
safe stack how many here are familiar
with Scala zune well it's impressive all
right how many are you actually using
Scala like on their day jobs well that's
really cool good to see that adoption so
yeah right so one of the big things I
javaone conference here is you know Java
8 with lambdas and this is something
Scala has built in from day one it's a
it blends into very you know the
auditorium and concepts along with a
great functional nature to it so it
already has you know
and is in a much deeper sense with you
know functions on the other concept that
Scala is an agile lightweight syntax so
you know another thing with Java 8 is
type inference and that's something
that's call already has into it it gives
it the feeling of being a very much like
a kind of a Python or Ruby kind of
language while still being you know
statically typed so y Scarlets just a
couple of reasons I mean there's a lot
of reasons these are some of my
favorites it's really interruptive with
Java so it runs on the JVM you can call
it all your you know existing Java
libraries your legacy Java code you know
another big thing is immutable data
structures for concurrency this is a
huge benefit being able to make all of
your data immutable because it's
functional nature you have strong list
processing you're right MapReduce I'm
you know in high order functions on your
collections and then there's also
pattern matching pattern matching is
really powerful in Scala you can do
pattern matching on a wide variety of
types it's like JavaScript on steroids
basically so the player web framework we
call it a high velocity web framework
through when did the primary focuses is
being very developer friendly so it has
this hit refresh development cycle there
is no needs you know do a you know
redeploy and restart your application
server type of thing the entire play web
frame you just type safe so the routes
file the templating language everything
is typed checked it's a fully compiled
and then it's also event-driven so it's
really kind of a new way of architecting
your application you can make your
application is very much instead of
pulling from the client you can push the
data out to the client so some of the
unique features about how it's built is
that play runs in its own container on
the JVM so it doesn't run in an
application store where you don't worry
about deployment it's fully
self-contained play out of the box
supports the modern web and you're fully
support html5 you know WebSockets comet
server-side events it has fully restful
endpoints you know and then it's like a
rails it has you know you can specify
your routes file with URL so you can
make all your URLs
you know humid friendly very readable
and the other thing that's really
important with place is completely
stateless so it can you know scale out
horizontally so acha so another big
thing I've heard at this conference is
there's a lot of talk about concurrency
being able to leverage multiple
multi-core CPUs you know with javis
streams coming out so there's a lot of
talk of how you can really start to you
know leverage parallel ilysm and the JVM
so this is something that acha is really
strong at so instead of the traditional
model trying to you know figure out how
to concurrency immutability and locks
awk has a really a simple model for
doing concurrency and the other really
big finger talk is it has error handling
and self-healing built in so the way you
write your application it has you know
you can easily do the self-healing the
supervision and also because of the way
it's the model it's very elastic and
decentralized so it gives it a lot of
flexibility for scaling for you know
being able to do it you know handling
varying it loads and scaling up and down
to talk a little bit about how it does
that kind of the core of akasaka actors
is anyone familiar with alka actresses
you and done with actors well I'm glad
to see the popularity that's cool so
actors you can think of actors like a
very lightweight process it's kind of an
alternative to you know this mutable
state instead you what you do is you
write an object and your object
basically encapsulate three things its
behavior state and communication and the
idea with this is you basically take
this you know lightweight process and
you let acha manage it for you and so
now with you've written your actors and
you communicate with it via messaging
and so the idea is that you never
communicate directly with your actor you
always communicate with a message and
that really isolates it from the rest of
the system so you don't have to ever
worry about imagine concurrency yourself
the actor model basically matches the
concurrency for you you know aqus going
to schedule that actor gets run and the
other nice thing about that is let's see
actors are location transparent mean
that your actor could because you're
saying messages to your actually never
between
with it directly that actor could be
running on the same jvm or could be
writing on another node in the cluster
and so that's what allows these actors
to easily scale out is because of this
transparency of you know it doesn't
matter where that actors running on the
other you know we talked about scale up
and scale out for free scale up in terms
of being a leverage multiple cores
because awk is matching these actors for
you it can schedule you know to run in
multiple cores and really leverage the
full advantage of that server really
this is kind of the perfect fabric for
the cloud so the other in a really nice
thing with actors is you build an actor
in typically built with a natural
hierarchy so you have a parent actor and
it creates child children actors and the
nice thing with this is that the parent
actor can supervise your child actors
and these children child actors what
they can do is they can be basically be
used to run dangerous tasks like if you
have a web service that's potentially
going to fail database access anything
like this the child actor is given these
dangerous tasks and the parent
supervised is it saying you know it
watches and says if there's something
that's going to go wrong I know how to
handle this child I can start the chili
can terminate him I can call a different
child so this is you know a very nice
model of being able to you know a
traditional job application you have a
very synchronous you know a single
thread per request that thread dies we
know what do you do how'd you handle a
terror with this model the parent you
know is the the parent can watch this
child and you can easily you know it on
a separate thread be able to manage this
child so it really helps to met for
self-healing type of architectures kind
of the final product that I want to talk
about is type-safe activator we just
released the 10 version of activator
what activator is is it's a tool to help
developers start using and getting
familiar with the types of platform it
contains tutorials templates you know
getting started applications and it's a
really easy way to really learn how to
use the types a platform how the
products integrate together so
I want to talk to Brian now about how
does the types of platform a show to
Lisa's chart skulls so all right so if I
go back to the things they put there
before so service oriented architecture
was the first one great right so you
want it support for rest with XML and
JSON play out of the boxes I mean every
other websites are restful so I think we
ship done around this area yeah so I
mean our take on was this was not the
one that sealed the deal for us because
pretty much all the platforms now have
pretty good support for doing wrists and
points you can do it with spring you can
do it in PHP but play and Scala the type
stave stack was at least as good if not
better than all the other alternatives
and this was really one where we're
gonna have to make significant changes
to our code base regardless of what
technology we went with it was going to
require us to do a huge amount of
rewriting to get to that different
architectural style and play was as good
as all the other ones out there so i
think i should get bonus points so for
JSON support is adjacent support with
especially with it play 22 we now have a
scholar macros that makes you know Jason
conversion really easy so yeah that's
totally true and we do make use of it
and so there are some bonus points for
conciseness and having great libraries
so right so the next thing you want it
was a little of any server side state so
play is completely stateless so there
you know the the quarry architecture of
play has no state built into it so we
should have done well on this or
anything yeah so I'm gonna play fully
embraces this philosophy so we keep a
very small amount of state enough to
identify a user in a cookie but there's
nothing there's no magic going on on
every request that's filling up a whole
session object with all sorts of stuff
as we get to the request that that
little bit of state that's in the cookie
is available to our controllers and if
they need them they can use that to go
get data we use a lot of caching you can
go get from a cash whatever you need or
if there's a cache failure you go to the
database and actually go get the full
data and fill the cash but if it fails
on a cache hit I don't fill the request
and if I have a library request that
doesn't need a whole bunch of this user
data or a count eight or whatever it is
I only get what I need and for us that's
been fantastic for our use cases we're
getting a whole lot better performance
and that minimal response time that I
talk
about has gone way way way down we got a
lot waiting to quicker requests yep so
we do have basic state that's going to
be in the job and so we are a very heavy
JavaScript application we have over
200,000 lines of JavaScript because we
are a full browsing application in the
browser but yet so a lot of it is there
is just going to pass that stayed up and
then get JSON data back to the client
and it's a single page app boosted chart
is and the JavaScript will work with
that and get the data it needs so yeah
so did quite well on this one and
obviously embraces the same philosophy
that we had at lucidchart right so all
david schardt it so play doesn't have
anything specifically for this so how
did you guys solve this problem so for
some of our data we use Mongo and Mongo
pretty much solves this problem for you
you have this Mongo s process that takes
care of the surety for you but for a lot
of our data we aren't we aren't using
long ago where we need full asset
principles we actually use my sequel but
we keep it sharded and we wrote our own
little shardene library it's not
anything too fancy I think it took like
a week or so but play is flexible enough
a norm is the persistence layer we use
with play you can kind of use plugin you
can use different persistence layers
with play a norm is the default and
someone that we've used it was flexible
enough that we could make our own
charting library and Scala as a language
has a lot of features that make it
really nice for creating a pis so we
almost were able to make a fairly simple
almost I wouldn't call a domain-specific
language but a nice feeling API so that
we wrote that once so that we have this
shardene infrastructure there and now
everybody who writes new code they use
it and it's worked out really well so
having the flexibility of Scola as a
language and a norm as a fairly flexible
persistence layer is worked out pretty
well for us do you use Makapuu you
cashing it in it well we do a little bit
use Mongo for some caching but primarily
we use Mongo for analytics analytics
data where I can lose a little bit I'm
Mongo work straight where one a hundred
percent pure pure asset principles we've
been using my sequel and short of my
sequel solution has worked well for us
it gives us those principles and the
ability to scale out right so there's a
new manga driver that just is kind
the reactant mongo drivers fully
non-blocking an asynchronous but works
really well with place that I would be
really good for you guys yep so next you
wanted a persistent layer that allows
controls of queries so we have a lot of
flexibility in terms of you know what
how you your persistence we really don't
dictate any particular persistence there
what do you guys do then so a norm is
kind of the default that comes with
playing and that's what we've used and
we actually been really happy with it
because it does give us full control
over the sequel so our tech has kind of
been you know the industry keeps
inventing these domain-specific
languages for accessing a relational
database but SQL is a domain-specific
language for accessing a relational
database let's just use it it's there so
just to give you a sense of what it
looks like here's some you can see here
this is a norm I say sequel and I put my
query in there and where I have
variables like I just do it like that
and it'll take care of making sure
there's no sequel injection the actual
value of user ID is set by calling on
here where user ID is and this will be
my actual value and then the result will
get mapped here so I get pure a
collection of ID's which were the roles
for this user so you can see I have full
control over the sequel that gets
generated I can make absolutely sure
that it's not doing crazy joins like I
was getting with my ORM mobber before I
can make sure that it's using the
indexes exactly the way I want to for us
we've been really happy with this in
that we get what we it gives us the
control that we want to get the
performance that we need right now he'd
scholar really shines here because call
it makes for a really nice dsl you can
do you know using like in fix operators
and things like that you can get a
really nice dsl which you're going to
get with the plane java so yeah yeah
great library support rights since we
run on the JVM you should have access to
any you know full whole suite of
libraries so yep it's been it's been
great there because you do have all the
libraries available in the JVM I can
call from Scala and for a good portion
of them there's white scholar wrappers
that somebody or other has written to
give it a kind of a scala feeling
interface to the
library so library supports been great
because it is a JVM so good run time
monitoring you know everything you runs
on the JVM so you probably had a wide
range of choices for that what you end
up using for your monitoring so I mean
one thing is just so nice having again
been in the PHP world just some of the
simple things that you're used to on the
JVM just be able to take a heap dump or
a thread dump visualvm jmx just the JVM
was built for this it was built for
runtime monitoring and for enterprise
use so that's been super nice we've also
made use of New Relic which is a third
party tool it's a SAS offering that
helps with monitoring as well and is
it's it's not free it's that you pay for
that but it's been also very useful so
great here we feel like we're in a much
better place than we were two years ago
having moved to the JVM and now just yes
New Relic yes six months ago New Relic
couldn't handle play applications and
did awful things it actually works great
now and we've been really we've been
using it for about two months and it's
been great the places where it's really
strong and we have a pretty good
partnership with them so it's been great
so efficient development environment
coming from PHP this probably is a
little tough to match yeah so like I
said PHP a you make a change I hit
refresh immediately there play so we do
get auto reloading so play by default
you make a change and it will recompile
and then eventually reload it back into
your browser it's definitely not where
PHP was so this is where we'd love to
see type-safe makes some improvements if
you change things like your routes file
and play sometimes play gets really
aggressive about like recompiling the
entire world and the Scala compiler
itself has some room for improvement as
well in terms of compile times so I'd
you know a lot of other ones we gave it
really good marks this one be CB it's
there's room for improvement here right
so that's something that we're we are
really aware of both the playing the
Scala team together been working a lot
on that and there's a lot of work being
done in the incremental compiler with
Java 7 and the invoke dynamic
instructions were able to actually do a
lot so there's a lot of tricks that
we're doing underneath the covers and
make out a lot faster so yep
alright so support for parallel
processing I think this is probably one
of our strongest areas right with you
know Scala up through you know aachen
yeah we have a lot of support for
parallel processing so like I says there
we love all the options it's big gray
for parallel processing I'm going to go
through a couple examples here in a
minute of how we're making use of that
actors and how that's helped us but yeah
it's been fantastic in that sense so
what I want to do so that kind of goes
through those eight goals that we'd set
for ourselves about two years ago so
we've been using Scala play and akka in
production for about a year and a half
so it's going to kind of go over what
are the big benefits that we've seen in
the last year and a half as we've
adopted the type-safe stack and also
maybe a few of the gotchas that haven't
worked out as well as we'd hoped
deputies you never used no we were
straight to play too yep that's right in
fact we play too we started developing
on play too well it was still in beta
and luckily hit production before we had
to release the production it was very
close it was only like him about a month
after play 2 was released we actually
put it into production so one of the
huge benefits is concise code and this
is because of Scala I'm just going to do
two quick examples that give you a feel
for what Scala code looks like if you
come from a Java background case classes
in the functional style of programming
so case classes here's an example of if
I wanted to make an immutable person
class and suppose either person consists
of a name and an IQ so if I want to do
that in Java you create the member
variables there I create a constructor
two equals the hashcode the two string
and then I make my gaiters and then I
have your basic immutable person class
here if I want to omit basically the
same bike code in Scala it looks like
this I say case class person and then I
say okay I want to have a name and an IQ
and I'm done those are essentially the
same byte code that will be generated
between these two things that 30 lines
of code or so and that so this is super
nice because well it's obviously way
more concise right it's a single line of
code but also the cognitive overhead to
understand what's really going on is a
lot higher here so it's not
it's not concise and unreadable it's
concise and easier to comprehend because
this I have to go through a whole bunch
of stuff to figure out is this actually
immutable or is it immutable are there
setters you know you have to go look
through it where is here when you see
case class you immediately know what
that means it means I've got an
immutable javabean like thing and these
are the member variables that it has if
I need to override the getter for these
I can do that that's an option but for
the default case the common case that's
all it takes as a single line of code
another example where we see much more
concise code is a using functions as
first-class citizens so one example here
there's partner code where we have a
whole bunch of user IDs and I need to
filter those out based on some
subscriptions and some account
information that code was about 70 71
lines of code in PHP and it turned into
these 10 lines of code in Scala so let
me do a simpler example of kind of what
that looks like why that is suppose in
Java I want to have it I want I've got a
strain here called name and I want to
know if there's any uppercase characters
in that string so I can declare a
boolean is set defaults then with this
iterative approach i iterate through
that string and for each character I ask
the question is it uppercase if it is
set my variable to true and break out of
my loop so at the end has uppercase will
either be true or false if it's got an
uppercase in the string or not so again
how would I do the same thing with a
functional approach in Scala again it
comes down to a single line so i say
valve has upper case this is declaring
my variable this is going to be a
boolean because this method returns a
boolean and scholar will do type
inference for me so i don't have to
rewrite that name is a string and string
as a collection of characters so the
methods that are available on the
collections api are available to me so i
can just say exists which is one of the
methods in the collections api and what
i have here this is kind of where you to
the functional idea the parameter to the
exist method is a function and that
function the exist method will go
through every element of this collection
and for every element it will call this
function and if this function returns
true it will return true from the exist
method if none of the elements of this
collection returned true then it will
return false from the exist method so
this thing right here that is an actual
function it's this anonymous function in
here the underscore means the current
element that I'm iterating on so again
name is a collection of characters the
current element that I'm iterating on is
represented by the underscore and I'm
just asking the question is this an
uppercase character so overall I get
some one line of code and again I would
say the cognitive overhead is higher
here I've got to kind of go through and
understand that i'm doing iteration and
what i'm looking forward to read through
whereas if you just read here Val has
uppercase name exists underscores upper
if this is your first time seeing Scala
this might look a little bit weird but
as you get comfortable with the idea
that this means the current element I'm
iterated over this becomes very easy to
read it's much less code yet not it's
not much less code at the cost of
readability it's still easy to read and
understand so concise code is one of the
big benefits that we've seen over the
last year and a half as we've moved from
PHP to scala parallel processing and i
mentioned this before but i wanted to go
over into more detail because this is
significant this is one of the biggest
benefits that we've gotten so the
functional style really encourages
mutability which is great the actors and
futures they'll also provide a kind of a
different mental model for how you do
concurrency with traditional shared
state shared memory concurrency it's
really difficult to get it right you've
got to make sure you have to synchronize
keywords right and use a volatile
keyword where you need so that if you
have multiple cores that doesn't end up
cashing the wrong thing and I get stale
values in my mutable memory with actors
and futures it's a much simpler model
and we went from in the example of how
you take a lucid chart diagram and from
that generate a PDF from it that was
done completely serially previously now
we do it in parallel we use a huge
amount of parallelism and we didn't
really have any bugs related to the
concurrency that we introduced into the
system there may be bugs related to
porting it or whatever
but typically my experience has been
when you introduce when you take an area
of code and you introduce a whole bunch
of concurrency you almost always find
some bugs related to that concurrency
that you introduced either you're
mutating state in the wrong way or
you're reading still values or you get
deadlock or something like that that
wasn't our experience at all how I did
that though was using actors not shared
mutable memory so just to kind of go
through that what that looks like we
start with a diagram actor and we'll
send a message to this actor which is
the lucid chart diagram full all the
pages of a lucid chart diagram we will
send that to this actor and this action
will parse through that and say okay I
want to find each of the pages from this
diagram and once it parses out that page
it'll send a message to each one of
these page actors with one individual
page from the diagram then the page
actor will parse the individual page and
look for drop shadows and for images
that the user may have put from that
maybe they download from Google Images
put an image in there or it's from some
URL we need to actually go download that
image so it'll find those things and
send those two different actors one that
knows how to do drop shadows one that
knows how to do images ok so the
messages are getting passed down
eventually the drop shadow actor he got
this message of the drop shadow that
he's supposed to generate he generates
it and sends a message back an immutable
message back to the page actor and maybe
the image actor he gets the image he
sends the bites back in an immutable
message back to this page actor the page
actor combines all those drop shadows
all those images and everything else is
on that page and sends a message back to
the diagram actor the diagram actor
collects all these different pages and
makes the final PDF so there's no shared
state there it's just sending messages
down down the hierarchy and responding
back with the data then we got back so I
want to just go into talk about this a
little bit so this is the beauty of the
actor pattern with acha all these actors
are managed by awka right and so when
you want to do three page actors and you
want to spin them off you know in
parallel you don't have to worry about
managing you know the thread pulls of
these actors are run on or you know the
concurrence of these actors
acha manses all that for you you just
create these actors and so you know it
send them the message and the aqua
automatically you'll match when these
actors get run the other night seeing
with these this kind of a architecture
is you know if your diagram actor is
your supervisor and one of the page
actors dies the diagram actual can
restart that actor so instead of having
it being on a single thread you know
where your processing your diagram that
thread dies the whole processing dice in
this type of architecture you know
you're processing your one part of your
page you can just restart that actor and
all the rest of the processing is not
lost so that's really kind of power you
know the self-healing their recovery you
get with acha built in so so just to
give a sense of kind of what that looks
like in code the next level down just as
it just as a couple snippets to kind of
give you a feel for it so here we have
pages which is a collection of all the
pages in your loser chart diagram we're
going to call a map method on it and
maps going to iterate through all the
elements of this collection and for each
one it'll put into this variable the
individual page the elements of this
collection and then it'll execute this
function okay this function is an ask
this is the way i said i'm going to send
a message to an actor and in this case
i'm doing an ask which means i'd like to
get a response back so i will get a
future so that i can get the response
back i could just send a message and do
fire-and-forget in our case that we
actually want to get a response back so
we're doing an ask ok so we're iterating
through all the pages and we're sending
these messages to the different page
generator actors the page generator he
has this received method and Ryan
mentioned earlier about a pattern
matching in Scala it's kind of like
switch on steroids here we're matching
on the type so if the page generator
actor receives a message and the type of
the message it received is page
generator message which is what we send
up here then it will send back to the
person sent me this message that's what
the sender bang means send back to my
sender the results of generate page and
then I pass into the generate page
method the actual page that got passed
in here on the message
okay so all my pages are sending
messages down here these guys are
picking it up generating the page and
then doing whatever work they need to do
and then they all get put back into
these futures and then the futures I do
another map and basically this will just
ensure that every one of them finishes
when all of them finish I will have all
my PDF pages here in my variable that I
can then go and generate my final PDF
from it right I think when I see your
notes for this code is there's no code
in there for you know dealing with
synchronization of you know trying to
figure out when to schedule things you
know the bottom where you create the
actor you know that's all you have to do
is to create an actor and a knock it
makes it a synchronous for you so you
really can the nice thing with this is
it you can easily see the business logic
there's not a lot of concurrency or
looping or anything else it's really
just focusing on the business logic and
it's a lot easier to understand this way
and all of the plumbing happens
underneath with acha so right so this is
just be trying to show that the page
actor may have sent a message to the
drop shadow and send another message of
the image actor it's just that this
particular actor sent some messages to
quite a few other actors as well to do
all the work that it needs to get done
they have their separate very hierarchy
absolutely absolutely another question
is maybe this is stupid question but I
think of there should be some sort of
flow through the pages so how would you
know that what you start this it will be
divided in exile
so it's not exactly 3 again this is just
me trying to show the concept this is a
whole pool of actors this guy will send
as many messages and my actor pool be
configured to have a max and certain
number of threads assigned to it that's
all kind of abstract and I was just
trying to show the idea of how actors go
and the idea that you absolutely that's
very astute really just did where a key
diagram would under each patty ejector
to have a drop shadow after an image
actor would be a more accurate way to
diagram the system probably so well
there could be multiple to one page
might have 15 drop shadows and they'll
all can currently be generated at the
same time so so another benefit that we
noticed in the last year and a half
we've loved having the type safety so
again from having been in the PHP world
before and we had a fairly large code
base and people coming into that code
base we like the Popeye thing right our
variables I am what I am and that's all
that I am a little bit of like Popeye we
don't be coming in right here and then
I'm a string over here and then I'm a
person over here one thing and one thing
only no duck typing yeah so there's a
class of errors it's just guaranteed not
to exist when you get that type safety
doesn't mean i can stop writing unit
tests or anything but it doesn't mean
that there is a certain class of errors
that i no longer have to be concerned
with and we found that to be beneficial
but you still have to type inference so
you don't have to specify your types all
over the place like you would with
lately especially with generics and
things like that we have a lot of extra
type information that's all gone Scala
so right more confident refactoring this
is also significant for us we really did
feel like in the big code base that we
had of PHP we were really little
reluctant to reflect or anything so we
just didn't know what we were going to
break and we just didn't feel really
comfortable in that code base with a
type safety the compiler we feel a lot
more the tools are a lot better and we
feel a lot more comfortable that you
know if we really screwed this up the
compiler would let us know it's also
helpful when you come into a large code
base to have have the types there for
readability so that and somebody new to
the code base can get a sense quicker as
to what's going on
but in fact in many cases i find that
you don't have the parks there for
readability so sometimes type inference
I think basically three
where it's not there explicitly in the
code a lot of times if you have a good
IDE you can ask the IDE and it can help
to tell you what the type is as well
because it can at least be deduced from
the code right and a good idea can help
there but yeah I know what you mean if
you just got a text editor if I'm
looking at MDI it can be hard because of
the type inference but so use a good
idea right and that's like I mean we
recommend like we need to find like a
public API that you specify the types in
the public API so that people looking at
your API can see those sites because
there is definitely a problem with the
type inference and not you know the tail
so is there a question over here yes
we use specs too so the play framework
kind of sets up specs to as the unit
testing framework and that's what we've
used him it's worked well so and for ide
we use IntelliJ but I know Eclipse works
as well I personally haven't used two
Clips much because i love IntelliJ but
each is a performance I just want to
reiterate it was significant for us a
performance benefits we got were
significant this image generation so
I've talked about generating that PDF
that's also how we generate the same
process for generating an image we
actually generate a PDF and from the PDF
generate a JPEG or PNG that service the
average response time decreased by fifty
three percent and the median response
time by thirty-seven percent so that
there's a lot of things that went into
that one we reported in a code base and
there were things that we did that were
better but the primary reason is instead
of just being a serial process going
straight through which we had in PHP we
made use of concurrency and these actors
and futures and it made substantial
difference for us scalability so I
talked about how we move to a services
oriented architecture so now each one of
these services can scale independently
if that image generation service is
getting hit really hard because a lot of
people start printing and wanting to
create create images that particular
service will scale up but my
functionality related to how users login
doesn't need to scale up it can say you
know it may be serving traffic just fine
so instead of having this monolithic
thing where everything has to scale or
nothing scales we have individual pieces
that can each scale independently and
that's been great availability the
services can also fell independently
like I said before if that image
generation service if it's eating up all
my memory or all my cpu my users can
still log in because my user services
there are all in this their own their
own skill book group over here they're
not affected by by this other functional
area so each functional area and fell
independently without taking the entire
application offline that's been great
for us our general failure rate for the
image generation service decreased by
eighty-five percent a lot of thats
related back to the performance because
we have timeouts
and when it was all serial it would just
hit in our time out limits but some of
it has to do with bugs that we found as
we move to a compiled language and kind
of a rewrite to anytime you do a rewrite
there were some architectural things
that we could do differently as we
rewrote that code faster diagnosis of
production issues is also relevant so it
used to be again all the functionality
of lucidchart was on a single server so
if the CPU was ridiculously high for
some reason it was hard to know is this
because something changed about the way
we do user look up or is this because of
the way we're generating images or the
way we're rendering fonts or or why is
it they're all in the same server now if
I see a high load I know it was on my
image generation server or my font
rendering server or whatever it is so I
can narrow it narrows it down very
quickly which helps finally a continuous
integration has also been nice because
it runs on the JVM which means it works
with a lot of the JVM ecosystem we run
continuous integration with Jenkins play
supports the stage target which
basically creates a distribution for you
it creates a folder that has a directory
that has basically everything you need
to run in production in our case we then
package that up into a Debian package
and stick it in an apt repository and we
use chef to actually install that at
runtime bin so we have continuous
integration going running our tests
creating doing the stage creating a Deb
putting that in the repository and then
chef comes in and actually installs
whatever debs we want to install in our
production environment in play 22
actually added the support for on
creating packages for you so so we can
read together about our own scripts yeah
using that we took the idea from
lucidchart again so a couple of
drawbacks first it took much longer than
we expected so we were trying to do not
just poor PHP over to scala play ananka
but actually do a rewrite and make it a
better architecture using the
concurrency and parallel processing but
we it's an understatement to say that we
underestimate the time it took us to
port so there is it does it does take
time to make a big change like this a
big architectural change we still feel
good about how
done it because we don't think there's
any way we could serve the load that we
have today had we not done that well we
could but it would be very very very
costly we'd be spending orders of
magnitude more in hard for our hardware
costs if we hadn't made the change yeah
I mean actually let me so one of the
other drawbacks is training so PHP or
java programmer you come on day one and
you're there pretty much effective right
that's another cost is that you do have
to treat we haven't found anybody that
we hired the already knew Scala and they
knew play in the new maka and they were
familiar with actors that hasn't yet
happened so we try to shoot for people
who we think are really bright you're
going to be able to learn quickly but we
have to do some retraining and we've
used the Coursera course that Martin or
jerski has functional programming
principles and Scala he's got his book
as well that's been pretty good there's
a new course you can maybe talk to this
one Ryan it's a new course that's coming
out called principles of reactive
programming right yeah so you know Tyson
is really pushing the reactive
architecture and so we're doing another
Coursera course this fall around
reactive programming it'll actually show
examples from you know not just play but
from other things as well I believe I
was also going to say it is my
experience I've trained a number PHP
developers now that is a hard jump to go
from PHP to any kind of object oriented
language I think java or scala because
it's a different way of thinking and
working so that is a tough jump so so
it's there but I mean our experience I
mean everybody likes to think they have
great developers we think we have great
developers after a month or so and we
usually pair a little bit when we bring
somebody new on will pair with them for
that first month more than we might
later and after a month or so they're
pretty effective and then there's kind
of that long tail as they learn more and
more about Scala but there's kind of
that steep learning curve for about the
first month so yeah that's certainly a
concern when things that we have run
into another thing that we've seen is we
now have more moving parts right before
I had one type of server it was a web
server and it did everything under the
Sun now I've got a server that knows how
to kind of paint the UI server that
knows how to do users
service type of things a server that
knows how to do image generation server
that knows how to do font rendering so
there's a lot more different moving
parts to understand about my production
environment that being said each service
itself is simpler because it only does
this one thing and it does it well so
this kind of pros and cons there but
there are more moving parts if you just
look at the complexity of the production
environment there's more pieces there
instead of just one cookie cutter that
does everything under the Sun so
adoption right so this is running
challenges we deal with a lot is trying
to help companies adopt a scholar play
into the organization it definitely is
you know Scala is a new program model
especially if you're using a lot of the
functional features of it and so what we
tell a lot of people is you know it's ok
to use college this is a better Java you
know you can use it just as it more of
an object-oriented sand just not have to
worry about semicolons and then slowly
transition to use it more and more for
the functional aspects we definitely
recommend you know leveraging the
existing samples there's a lot of
samples in activator a lot of templates
and we're getting a lot of community
contributions to activator so it's
growing it's also reported I think to
understand how Java and Scala interact
you know within scala there's a lot of
tools to convert to and from Java
collections and you know there's
definitely some things in Scala it can't
be you know called from Java so if you
have to build an interoperability layer
you need to be careful so right so some
things we've seen that help you know be
if your organization is you know
resistant to change you know it's really
good to start building internal tools
our test Suites you can actually you
know do all of your J unit tests or test
ng in Scala it actually makes it for a
much better way of testing or you can
you know start using Scala tests on a
legacy Java code base another big thing
with adoption is community participation
there's a lot of Scala user groups I was
just in Toronto they had about 50 people
at escala meet up out here in the Bay
Area there's about 400 people to come to
this caalamiga so there's a really large
community around scala in most cities
refining
and the other important thing is don't
reinvent the wheel so this is something
you know there's a lot of existing
libraries a lot of people you know
wonder whether they should rewrite it in
Scala and oftentimes all you really need
to do is put a lightweight layer on top
of it and then you can build new things
with your Scala so right so the summary
yeah so every language every framework
they have their strengths and their
weaknesses and there's not a silver
bullet that has is perfect for everybody
and everything but our experience you
know we've been on this platform for
about a year and a half as I mentioned
we've been really happy with the results
so far for our use cases and for what
our needs are we're pretty pleased with
Scala as a language there are a few
costs like probably one of the bigger
ones being the training as was mentioned
earlier but generally we feel like we're
in a position now where lucidchart can
continue to grow we wouldn't have been
able to take the low that we have today
how do we not made this change and we
feel pretty good about skull and at acha
and play as our way forward so I think
we've got a few minutes if there's any
questions yep
yeah so I mean at a high level we don't
release all of our numbers and I can
give you some numbers to give you kind
of a sense we have about 800,000 people
who have installed our Chrome web app we
just released a chrome packaged app and
in two weeks we had 25,000 people
install our chrome packaged app since it
was released in two weeks two weeks ago
we do over so I'll just say well over a
million document saves of diagrams a day
so you can imagine I mean it gives you a
sense of kind of kind of where we're at
in terms of the load and we continue to
see growth significant growth so where
we are now you assume it's going to be
significantly higher even four months
from now so our the rate of growth is
also very steep that's kind of a sort of
hedging because I can't release all the
numbers but hopefully that always gives
you a sense right and I I'd say I mean
you probably do a lot more processing
with all of your like PDF the page
generation and I mean it's a lot heavier
than a normal like web application for
processing I'd imagine because if
there's two things that make it a little
bit unique one is that we do autosave in
the browser so we're saving you make a
change we're always saving so new new
changes are constantly being streamed up
we also do real-time collaboration so if
anybody makes a change 15 other people
who may have that same document open
they need to immediately see that change
I guess I would so each session has a
lot more traffic going on than a normal
application and writing and then the
third thing I guess if I is going to add
a third as we do you a few things that
are pretty processor intensive like
generating images that not necessarily
every website has to be able to generate
an image from their output could you say
something about migration
keep the same database schema no we ate
completely as we took a functional area
we pulled it out and we'd reread it in
skull and play and the PHP kind of
remained our front door doing the UI but
then we start making rest calls over to
this new service and that new service
had its own database which was shard it
I mentioned that we did sharding for
everything so as we made the changes we
change not just the code but the data
would migrate over as well to a new
shorter database and that's been again
that's another key thing for us is to
really be able to scale that data tier
where we have so many documents being
created all the time and be able to have
a sharted data tier has been crucial for
our scalability yeah in fact it's not
actually totally done I still have some
PHP in the stack we're probably eighty
percent skull and play right now in
about twenty percent PHP and it was more
just pick a service look at the
application find a crucial service
that's one of our biggest problems take
that pull it over here rewrite it get it
strong and insert a lot of times we
actually use both and we kind of do
twenty percent to the new service eighty
percent of the old and then gradually
over a month move one hundred percent
over to the new service there are things
like image generation we could do that
fairly easy because it's so stateless
right if I go here here to generate the
image it doesn't really matter so we
that's exactly how we rolled out for
example the image generation or PDF
generation
yes so in some cases we did have to do
migrations and a lot of times what we
did the way we pulled that off is we did
a migration on the fly so the first time
you would come in for example the user
service was the hardest one we had to do
is migrating from this kind of modeling
thing around users to ass brand new user
service and SOA architecture with users
so what we did is the first time a
request came into this new user service
if it couldn't find that ID that was
requested in this new service it would
go back to the old service migrated it
on the fly and then from then on it had
the new one and then in the background
we were running something that was
constantly migrating them all the time
so as soon as we released immediately
there was no downtime the first time
somebody logged in after we released
this service they would see about a
one-second delay well this migration
happened we paid a one-time cost there
but even most the users didn't even see
that because we did it on a Saturday
morning and by Monday night everything
had been migrated over because we knew
Brandon the background processes that
were hidden every single one of the
users and doing the migration itself
over that weekend so we managed to do it
with low impact to the users but that
required a lot of planning and being
very careful that you do have to be very
very careful of the way you do that or
it can be disastrous
and we are not fortunate did you say
we haven't done that we do code reviews
so before anybody commits we always do
code reviews and there are certain
things that just kind of has a culture
in the company we've said we don't like
the way this is I mean everyone example
the dispatch library for those who are
kind of familiar with the scholar world
we got really in million with how many
symbols that used in I mean for a ctp
put instead of pu t they did like colon
colon greater than colon or something
like that which no reason to do that
don't don't abuse symbols I mean we kind
of have a culture of trying to make it
as readable as possible and we always do
code reviews but we don't have a
specific set of never used this feature
or a smaller organization we are still a
start-up so I don't have if I had 150
engineers I might have to do that but at
least where I'm at right now where it's
you know 20 10 to 20 engineers it's been
we've been able to keep sanity with just
kind of a culture within the company of
make sure we keep our code readable so
right yeah I just going to say we have a
lot of organizations that discourage
kind of you know golfing or in your code
with Scott like you can definitely do
this golfing I'm trying to see how
little of code you can ruin you know it
get something done with and a lot of
organizations discourage that type of
behavior so I think it's important to do
go ahead there's another question
the in terms of total lines of code in
Scala why I'm my name sure you know off
the top of your head Derek I actually
have not looked since we migrated the
user stuff which is a substantial piece
but yeah I at least five hundred
thousand lines of Scala and I don't know
exact I mean beyond that but so there
would be at least five hundred thousand
lines of Scala every scholar developers
to you is open so we just lost a bunch
of interns because they all went back to
school but we're about 13 right now
about 12 or 13 of us full-time so Randy
yes I know that so I mean that's a
really good point because we couldn't
just stop our business to change our
architecture right and that's why it's
taken as I told you we're not done yet
we still have PHP code we've slowly done
this over time because we had to keep
adding features that we had to keep
adding business value to our users or we
cease to exist as a start-up and so it's
irrelevant what our architecture looks
like so that that's been a challenge
that where we keep going back and forth
on the other hand the amount of down
time we have on the system now is
significantly lower the performance is
significantly better and we feel like
we're able to scale and continue to
market and do the marketing team can do
what they need to do to get more users
on the system because I'm confident that
the system is not going to go down if we
add another user so i don't know if i
have a syllable answer to that other
than it's something you just have to
balance and make sure that you don't
we're not getting so much technical debt
that we're going to sink the company
because of technical debt or that you're
not so obsessed with your technical debt
that you're going to sink the company
because you don't add any business value
and that's just a fine line that you
have to kind of figure out with your
business team and how to how to walk
that line I know if that answers the
question or not it's yeah okay
yep parallelism you seem to have but and
that was the average so it's
significantly better for our outliers as
well we had outliers where it would just
we could not generate pdfs that just
would never come back right it would
always timeout and it was bit sensually
a failure I mean you really have to go
back to that the before I said we do
grease the failure rate dramatically it
did help on the median for sure in that
that helps but the biggest advantage was
the outliers we're now now I can
generate anything I mean we don't get
failures because of timeouts because I
can parallel eyes out the slow things
and get enough there that I can actually
generate it at all that's actually where
the strongest benefit came yep the load
is increased dramatically at this point
significantly I mean we're yes it's we
have more than twice as many users as we
had when we started this whole process
and significantly more than twice as
much load as we had a year and a half
ago or two years ago when we first
started thinking about redoing our
servers so hip
why don't you stick with something that
already gives you
so I'm really glad we didn't do that to
be honest because we use MongoDB and I
have yet to see Mongo l ever fella fell
over correctly ever and I was funny I
was in another session earlier this
morning with a.j clarity guys and they
were mentioning they've had the same
problem they have yet to ever see Mongo
fell over correctly so we're using Mongo
for analytics in a few other places
where we didn't need the full acid
principles but for a lot of our data I
can't lose any of it and what I've we've
seen is that Mongo doesn't give me one
hundred percent guarantee and while in
theory it should be very highly
available in practice it's not doing
that for us and it seems to be that
we're not alone in this the other thing
that Mongo has is you don't get ssl I
need if I'm going to excel to
enterprises I need an encryption in
flight I need to know that I need to go
to say that everything's encrypt it all
the way down and unless you want to pay
10gen a bunch of money you don't get ssl
to the database and so that's another
concern we had in practice so it's a
little bit of a not invented here right
to kind of write your own sharding
library that being said we spent
literally a week week and a half and
it's pretty much just worked and we felt
really good about it we use master
master replication so we have shards if
you shard has two sides with master
master replication and it just worked
quite well for us to use my sequel
sharted that way if we see another
solution they could give us that and I'm
not if it became a problem right now
it's not a problem for us it's sort of a
solid problem for us we have sharding
and we have what we need if it becomes a
problem I would certainly go out and
look again and see if we could find some
other solution maybe Mongols nut or
maybe Mongo becomes mature enough that
it can solve that for us but that was
just our experience yep
so when the great thing just play tries
to be very stateless right and that that
makes it very easy to just add more
service so we run on ec2 on Amazon and
all of these services that I've talked
about every one of them's in a scale
group so every night we scaled down a
little bit depending on the service some
scale down more some scale down less
every morning we scale back up so new
services come back come up online every
morning and so we're growing and
shrinking constantly and it's worked
pretty well like at the end of the day
from our perspective these are stateless
services they install as Deb's so it's
just as easy as apt-get install this Deb
and the service is ready to go and they
are stateless services so it just gets
put into the load balancer and we're
good to go we better reread a wrap up
its past four o'clock but you're welcome
to come up and talk about us yeah and
I'm more than I'm really interested to
hear how people are using Scala play
acha so please come talk to me and I'd
love to hear what you guys are doing so
thank you so much for coming out</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>