<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Rapid Modernization of Java Applications to JDK 8 | Coder Coacher - Coaching Coders</title><meta content="Rapid Modernization of Java Applications to JDK 8 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Rapid Modernization of Java Applications to JDK 8</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/RWBgeymPVpU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning everybody so I think people
are still waking up this morning slowly
making their way in so how many of you
are from from out of state wow wow so a
lot of different time zones and how many
of you from out of the country it's
quite a few well that explains you know
why it's been a little slow and so you
know work so today the talk is about
Java modernization so thank you all very
much for being here that definitely and
I did see a lot of pre-registrations so
how many of you did not pre-register
okay whew so majority of you guys
pre-registered event okay so that's
that's fantastic so so the topic you
know the the title was you know rapid
modernization to jdk 8 but i get
simplified it and you know i saw looked
at the cross-section of people that were
attending this this session and i
figured you know it is not just
something like you just get technically
down and then just show the code but
there's a lot more to modernization so
looking at the broad cross-section of
people that are here in the room i
decided to spend a little bit more time
on things that are really central to
modernization so what that might
actually do is put some of you to sleep
if you're not really interested in that
aspect of modernization so what I've
done is so constructed the agenda in
such a way to accommodate that so the
first part of the modernization story is
going to be targeted towards more the
business folks and the managers so the
developers please feel free to take a
nap and then somewhere halfway through
you're going to start getting more
technical and then you know maybe the
others can take turns napping especially
given the fact that you're all from
different time zones and different
countries so really appreciate you guys
being here and this is what we're going
to cover i'm going to start off you know
with some introductions address the
question what is modernization because
modernization today means many things to
many people so let's try to at least
decide you know what we are in a calling
modernization get into some details on
why do we want a modern
then that's when it starts to get a
little more technical and then we're
going to look at a way to do this rapid
modernization what's the process what's
the approach what does that involve and
then we're going to get into some of the
details behind it I'm calling it the
ultimate solution that's because we
think it's cool but you know you might
have a different take on it but there's
no one way to really approach it on the
technology side you can build the
tooling and the platforms how you choose
fit we're going to show you one way to
do it and then finally if the time
permits we can have some we have a
demonstration planned for you my
colleague here would show that and then
we can have Q&amp;amp;A so my name is Venkat I'm
the SVP of technology at nogaro and my
handle is java space 71 and quite active
on Twitter so if you know you want to
interact with me on Twitter please feel
free and not just about Java you know
interact on a variety of topics cloud
computing big data other technologies
and other not just technology other
things so please feel free and cool deep
is a principal architect with my guru
and I've his handle there and please you
know feel free to you know also look us
up we have a booth and you know feel
free to stop by and it's a kiosk where
we can show more detailed demonstrations
or if you just want to have a
conversation please feel free to reach
out and just you know 30 seconds about
nogaro we are we are the software
services division of a global german
company called Alkire we have publicly
traded on the frankfurt exchange and we
are about 6,000 people globally with
development centers in sweden in germany
in romania and in gurgaon india so we
are global we have a large global client
base we also are heavily into product
engineering we have several clients who
are actually product companies where we
build their soft you know we software
engineer and build their products for
them so some names are you know really
large companies also we do that for them
so that's just a little bit of blurb
about the company so without further ado
you know let's jump into this and start
looking at what some of the trends are
right because when we modernize we are
starting somewhere modernized
asian assumes the fact that you already
have made some investments in technology
you have some systems whether they be
legacy bell javas almost 20 years old
Java's considered legacy now 10 years
ago when we said legacy it was just
laying frames but today pretty much you
know java as legacy code so there are a
lot of trends that are happening today
of course you know the the most popular
it depends on the day what the analysts
feel like what the hype is so it's IOT
is the flavor of the day but back in 98
I don't know how many of you showed up
for java one and 98 any hands here
anybody came here so you would remember
the Java ring and that was distributed
and where it was you know we did
massively parallel distributed
computation believe it or not on rings
that were given to 10,000 attendees and
they computed parts of a fractal and you
know we were walking around we had our
drink preferences stored on the ring so
to me you know at that time that was IOT
just that term was not coined so a lot
of the things that we see today and we
take virtualization you know mainframes
where the the epitome of a virtualized
environment where you had VMs and you
had these you know and how it was shared
so a lot of these concepts you know it
is just that of course they be made
major advancements but a lot of the
trends are still rooted in a lot of the
fundamental technologies that have just
evolved so we should not lose sight of
that fact and we say modernization you
know even though we have big data and
gave cloud and we have IOT and all these
new things coming along modernization is
still very much about you know your
current investments what you have and
adopting these technologies and at the
end of the day to meet business needs
because there's no fun or I should say
there's a lot of fun and hacking stuff
but unless it makes business sense you
won't go beyond the proof of concept
stage running on your laptop or running
on a couple of boxes so that's the other
important thing to keep in mind when we
talk about transformation so if you look
at modernization with that view and on
these trends what are some of the trends
that we see collectively across the
enterprise's at least what we see first
and foremost looking at the portfolio
looking at your entire portfolio of
applications
and trying to make decisions on their
portfolio not just individual
applications or components the other
thing is you know being able to redeploy
your funds that you have how can you
balance between maintaining stuff that
you have and bringing in some new
functionality or new technology so and
then the operations aspects of it so
those are some of the things that we see
as trends or mega trends sitting on top
of this but you cannot really do
mobility or bring in big data without
the funds and without taking into
consideration your existing systems so
that's to me those are mega trends at
the you know at the high level that kind
of drive the adoption or the speed of
adoption of some of these trends within
the enterprise's error they don't come
without challenges although we may look
at a lot of different challenges like
time to market scalability integration
security and so on two things really
stand out when you think of
modernization they're all valid
challenges but specifically you know
with respect to modernization there is a
reduction of your total cost of
ownership so when you modernize the idea
is that you would be able to reduce
whatever new systems you're bringing in
whatever new you know techniques you're
bringing in is going to help you reduce
that cost of ownership again so that
over a 45 year period you you you'd be
able to redeploy those funds to other
aspects of your enterprise to other you
know lines of business or other systems
the other thing is everybody talks about
being adaptive and agile so we have seen
the movement of DevOps taking root in a
lot of organizations where you want to
click a button seamlessly go from
development to operations and so on but
again that's easier said than done in
order to become that agile and adaptive
I've seen a lot of product companies
being able to embrace DevOps as a
culture put you know put the processes
in place and then finally enable those
processes for the right set of tools but
if you just think that bringing in the
tools is going to make you adaptive and
agile it's you know usually you'll be
disappointed so and then larger the
organization there are other challenges
in terms of the culture established
culture of
doing things other you know dynamics at
play so then it gets really difficult to
turn the ship around and say I'm going
to become adaptive and agile so there
are a lot of challenges those kinds of
challenges as well to keep in mind
because when you want to modernize you
will encounter some of those challenges
so it's not just about tools so although
we claim that rapid modernization we
click a button and everything is going
to move there are a lot of other
challenges beyond just the tools and
technology so I also before I jumped in
and really started talking about the
details guts of the presentation I want
also let us you know I you know get
nostalgic for a moment and look at how
Java has come along it's been a winding
road right you know how many of you here
started with the 95 beta release as I
had a few hands right and in there was
not even a name given to it and then it
was oak right in fact oak was the
previous name of Java but the JDK wonder
was also called oak confusing a lot of
people then of course we had one dot to
the playground you know they that's when
the Java one happened the first java one
happened one doc three there was a huge
gap you know and then the one doc tree
was there for several years there was
Kestrel then one dot for introduced a
lot of one dot for two was one of my
favorites at that time some people still
use it today believe it or not I've been
talking to folks here and some people
are still using it today unable to get
out of one dot for that too that's crazy
niño and so on that's Merlin right then
we had tiger generics all the cool stuff
you know which made JDK one doc aid
would not have happened but for a lot of
things that were introduced in Tiger
Mustang which introduced the concept of
scripting the scripting engine i
remember i think it was a rhino a lot of
JVM improvements so this was you know
Mustang was amazing one got one at six
and a majority of people today are at
one dot 61 not five in one ducks exactly
a lot of people are there on one of six
as well so this is kind of the you know
the history this was the winding road so
in 2006 to 2013
again five years I mean there was no
method to this madness right how things
were being introduced how you know the
versions what frequency they had even
what you would get I mean things even
though we had the JCP process that in
some sense you know also can affected
other way it was structured then kind of
affected how things got introduced to
the language you see you know how till
2013 it was all one dot 6 2013 was end
of life for one not six actually then
now hopefully we are like on a bullet
train I'm hoping that it's not the
winding road and then I'm just kind of
showing you here the snapshot of the
last few years so they're setting us up
for the modernization discussion so of
course son was acquired and then Java 7
dolphin invoke dynamic which made a lot
of other cool things possible some small
changes in the language Android you know
takes off mobile becomes priority of
course 2013 jdk six updates were
publicly stopped so you can still pay a
lot of money and get custom support
they'll probably stop that also very
soon and you know this kind of shows you
the future also what's going on you know
what's what we anticipate you know but
to me you know what the saddest part was
of all this I realized JDK 8 was never
given a name you know nobody realized
that but we had cool names till then and
even the intermediate releases but after
dolphin Oracle I'm going to tweet about
it today and you know if you want a
retweet or let's have oracle go back and
at least give it a name you know that
then makes it easy to discuss and then
jdk nine ten there is no name in sight
so there we have lost the i mean i hope
you don't lose the coolness factor so
hopefully you'll get some new names you
know a sign for the others but JD canine
is going to be huge and when they do
that i think the current plan is to
kinda make it end of life at least the
public updates would be shut off at the
end of quarter 1 2015 4 jdk 7 so even
though jdk 7 well jdk 7 has been around
for a while we don't realize that and
jdk 8 has already been around for seven
eight months at six seven months now it
was released in march so we're almost
getting at the end of the year so and
now oracle is kind of putting it on a
track where every couple of years they
would be releasing which means that has
an impact on how
want to do modernization if you want the
new features if you want to you know
interoperate you know technologies and
so on there is going to be an impact to
how we design modernization it's not
that we're going to run the same thing
for 56 years so it's going to be a
two-year window hopefully we'll think
through this and put in a lot of
automation in place so you can kind of
automatically migrate your code base and
libraries and adopt but that's kind of
why I wanted to set this and show you
how the future looks like it came nine
ten they're all coming down the pike
with much more regularity and much more
definition around it right so now what's
modernization I wanted to take a little
different take on modernization show you
visually what I mean with modernization
maybe you you can read pages on it right
but I want to show you a very different
viewer very out-of-the-box way to look
at modernization so imagine this is your
portfolio of applications again you know
I'm assuming that we are all not having
you know have just one java application
and we all I'm assuming that we all have
a few other applications more than a few
which is what makes this difficult
problem you just start one it's really
trivial right you can go and modify the
code yourself but and you think of these
different dots different sizes whatever
you want you no one is more expensive or
one is more complex or I just wanted to
illustrate visually that each of these
dots represents an application and you
can pretty much imagine the size to be
whatever complexity constraint that you
want it to be right now taking this kind
of a beast that has all kinds of
constraints on risk on cost on
integration on the actual third party
I've known folks that are stuck to a
vendor who in a third party vendor they
have used and then there is a close
source and there's no way now to get out
of it so there are such cases also you
find there are some cases where you know
you find that the jar file is there but
the source code is not there and I won't
name it but a very large bank I don't
think any of us have accounts there so
but it's a very large bank somewhere on
planet earth and they don't have source
code for some of the Java applications
scary but that's the reality when you
have a portfolio that's of all over 18
19 years and
so when we talk about what is
modernization remember that's the
question we are trying to address that
what is modernization in your
organization will mean different things
to different people so if you are a CX 0
it means you mean it it's a whole bunch
of things but you would probably place
importance and a couple of different
aspects compared to somebody else that's
a developer my fears would be hey you
know how can I automate how can I
actually modify the code I'm thinking
about MJ Takeda lambda expressions how
can I put the minster of the inner
classes I'm thinking along those
tangents whereas if you're the CT or the
CIO trying to get budgets then you're
trying to justify why do I need to give
you a million dollars to just everything
is working fine the users are happy why
do you want to keep you know why do you
change it no come back after three more
years so it's a different set of
challenges right so there could be
financial implications of trying to get
to modernizing the portfolio there could
be operational implications I mean users
could be very happy I mean even though
you're telling them they're gonna get
something better they don't know that
they're like no I'm happy with this if
you do something else and they could
ever had a bad experience maybe somebody
modified something and it blew up and
they're like no don't touch it you know
till I'm gone from here you know so
operational you know that could be
windows in which you may not be able to
touch the portfolio it could be so
intricate I mean in fact a few years ago
not a few years so many years ago I was
you know advising a company in logistics
and they had basically there's a parent
company that was global very huge one of
the largest in the world and there you
know they were so they were they wanted
to spin off the rail aspects of it from
the shipping aspects of it and both
these divisions that they wanted to spin
off and they publicly traded they were
intertwined the applications were
intertwined and there is no way even if
you get if you throw as much money as it
as you want and you can bring in the
best technology experts it was so
intertwined the processes that it was a
nightmare but then based because they
were being spun off and they're going to
be publicly traded they have to figure
out how to do it so you will face some
of these situations where there's no
real answer to it but there would be
operational nightmares the functionality
itself in another case you know there
was a portfolio where they had 12
different reporting systems how did that
happen how did they have 12 different
reporting
systems and all the money that's being
spent on the licensing can you imagine I
mean it happens and that's you know at
technology component level but then
there are also applications the same
functionality like an insurance
companies this happens a lot where you
know they have introduced systems over
the last 30 or 40 years different
systems assuming that that's going to
replace the older system but they end up
having the same system so it's a
nightmare for the agents also but then
you have like five applications all
doing the same thing you know they want
to take your application process it and
whatever they do but then you get stuck
with redundant functionality in your
portfolio then of course the technology
which we are going to take a deep lay on
and see today because those other things
I'll be happy to talk to you outside
about it give you a lot of examples but
then the purpose is we want to get into
the technology today okay so now imagine
what is modernization right that's what
we're trying to answer imagine that
portfolio is somehow magically
transformed to this lot more order a lot
more structure you know what's going on
you have the right metrics you have the
right governance in place you can
upgrade seamlessly you have really
visibility and control of your portfolio
right so that is what modernization is
about if you really look at it as a
broad definition and then of course
there are different views of that
elephant right finance operations
functionality in technology so now one
more you know thing to look at you know
if you were to modernize this has
technology implications right the
technical quality I just call it broadly
but then if you look at what you want to
do with the portfolio overarching when
you modernize yes we want to upgrade to
the latest java latest everything but
remember this gives you an opportunity
if you're going to spend a couple of
weeks to look at your portfolio with
this kind of a viewpoint you could
eliminate certain applications in your
portfolio tolerate some you could
maintain an evolved some which means you
put additional investment and
re-engineer on modernize really that
modernize that modernize there is
basically you know a more my new
definition of model ice right and then
if you look at this you know risk and
cost and business value and technical
quality I've simplified the framework
but this is you know now blow this up
this is the kind of thinking you want to
bring you know and at the end of the day
decide if it even what you
modernize why you want to modernize you
got to be able to justify this and
that's when it starts to make sense okay
so then I thought I'd of playing with it
so this looked cool so I just said ok
fine but basically you know
modernization there is a definitely a
lot of importance to modernization today
that's one of the top trends today
actually it's been one of the top three
trends in the last three years
consistently in all the analysts at
least Gartner reports and stuff most
organizations are looking at
modernization they don't know how to go
about it how to do it or what to do with
it but they are saying here we wanted to
modernization we are doing organization
it's very important as far as IT the
impact is going to be you know
multi-level impact to the organization
the scale so here is where we look at
applications deewana so product
companies are structured differently
from you know from large enterprises so
are you going to modernize certain
applications I want to modernize from a
product standpoint are you go to
modernize certain components in your
product or you go to modernize certain
product lines or are you going to from
an enterprise standpoint are you going
to modernize your entire portfolio or
the portfolio for a line of business so
all those things happen today in fact
I've done modernization engagements for
just a few applications or maybe twenty
thirty to one insurance company that's
like an 80 billion company we looked at
1500 applications across four lines of
business and we actually came up with
the roadmap to modernize me not all of
them would be modified or but basically
applying a framework to decide where it
made sense which applications make sense
to modernize now there are also
situations where it may not make sense
to modernize you always have to ask the
question do I need to modernize if you
have unlimited you know coffers you no
money to pay great you know we all want
to be on the best technology but there
have been situations where customers
have come and we have looked at it and
said you know for you to modernize this
realistically is going to take you a
million dollars but your support on this
is only like whatever seventy thousand
dollars or whatever then do you really
want imani there's no return on that
investment then you are modernizing for
a different purpose you are modernizing
only because you just don't like this
technology you know just get rid of it I
don't want it I know I don't like the
sound of
for you know oak so let's get rid of it
and put something else so it's a totally
different emotional attachment to
technology why you modernize like that
happens but typically business sense
prevails and that's the first thing I
tell is why do you want to modernize is
everything are the users happy are you
happy why do you want to make your life
more complicated because you could
introduce issues right so don't
modernize there are challenges a lot of
challenges but regardless if you do
decide to modernize you got to start
with an assessment you got to know what
you have a lot of things you don't have
documentation you don't have source code
you don't have a lot of things you don't
have people that wrote it so that is the
challenge and when you do the assessment
today it takes you eight to ten weeks I
mean you can go to any outsourcing any
consulting company they'll send you four
or five architects and you know people
and they'll interview everybody several
times over documented we lost it in the
room but guys that's not the way to do
the assessment so that's where we differ
right when you want to do the assessment
why can't we do the assessment by
clicking a button at least the majority
of stuff is there you have built the
application there's information there
nobody is doing assessment that way so
that's the perspective I want to bring
to modernization and say what can we
automate here where yeah it's great
sitting around the room and interviewing
people and talking and taking ten weeks
and talking about it and generating
power points that probably look better
than this but the point is lot of things
can be automated and a lot of things can
be now tied to the DevOps culture that
many of us are talking about so that's
what we need to look at how can you
bring in that automation and make their
assessment not a 10-week exercise but a
more objective predictable couple of
days exercise can we do that and can we
still get better results then having
spent the 10 weeks interviewing
everybody you could still do that you
could go have a couple of workshops and
interview people nobody stopping you but
there's a lot of rich information that
would be missed if we just did that at
the people level and not actually
automate a look at the source code so
that's something that I want to talk
about or see how we are doing on time
because someday our way plenty of time
okay so and why modernize you know this
is actually i could probably talk about
this for the whole day but i'm going to
limit it to five minutes i'm going to
hit up on some key points it's going to
start getting technical so you know if
anybody was not interested till now
because i was drawing
not about business stuff let's now it's
going to get technical can anybody tell
me what these two numbers mean I give
hints actually so this up this is the
end of life for one dot six that's the
end of life for one dot seven the public
updates if we saw that in the history
right does anybody want to guess what
this is this is where I get to wake up
the people they were sleep in earlier
okay actually I'm telling you there was
no coincidence I think because what you
saw over there were actually
vulnerabilities security stuff and
somebody took me out so that's actually
the the patches that were released um
that's a fast review
ok so those were the what are the
updates where those were the
vulnerabilities that were fixed the ?
2014 what's gonna happen but you see the
big jump between 68 vulnerable pees in
2012 to 208 in 2013 remember that
because i'm going to show you something
else and you're going to say wow that's
why that looks that way this is 2014 so
far we have patched you know close to
100 so hopefully it's not going to be
208 it's going to be something less in
2014 so in 2012 remember the 68
vulnerabilities well you know when
people exploited those vulnerabilities
adobe acrobat was at the top forty
percent of all exploit vulnerabilities
are adobe acrobat java was not a close
second it was a far second at twenty-six
percent now remember the 2013 208 java
is number one in terms of exploitation
fifty percent so if we are not
modernized and we are not on some of the
newer java editions which have hopefully
patched these vulnerabilities we don't
know what could happen if you're a
financial institution that doesn't have
source code we really don't know what's
happening and there are sources for this
but this is the reality in 2013 I don't
have the I tried to research for 2014 so
far but I don't have the data hopefully
will you know the year winds down we'll
get more but 2013 or scary here for java
if you didn't have it patched up so jdk
one dot eight gives us a lot of security
enhancements stronger algorithms the
jssc has been enhanced enhanced
cryptography the SN i support is
something really interesting if your
code is not taking advantage of it yes
there are a lot that our browser based
but there are a lot than a server-based
to if you have offline we can you know
look at some numbers but those were
broad Java but yes there are a lot of
server-based vulnerabilities as well not
just browser-based there's good question
so the SMI support where you can
actually name the server so when in GD k
1 dot 7 they introduce this feature
where the client could actually named
the server you know that is connecting
to and from one dot eight the server
applications can do the same a TLS now
one dot 112 TLS is in by default before
it was not as in by default random
numbers now they have actually there was
the concept of strong random numbers for
you know security and you know for the
cryptography side of things but believe
it or not some of the cryptography
classes were not really implementing or
taking advantage of it now they've gone
ahead and fix some of that so you get a
better higher entropy on the random
numbers it cannot be replicated even if
you know where it started so this is a
bunch of security enhancements sha 224
so which allows you to use the 256 kind
of thing but you can truncate it so it's
a it's a little difficult to crack than
256 so there are a lot of interesting
you know security enhancements that
automatically come out of the box even
with one dot seven it's way better than
one dot 6 and 1 dot five and then of
course from if you want to talk on the
performance as g1 was introduced but
there has been a lot of confusion about
the g1 garbage collector right we have
so that's been the pain of Java's
existence right everybody comes and says
Java is slow compared to c c++ you pause
and you collect your garbage but it's
all in how you design your system you
need to know and you know a lot of folks
that I come across when I when they say
it's slow if I ask have you really
looked at the flags to the garbage
collector have you really play around
with it have you tweaked it have you
architected it what does your heap size
we don't so most people don't pay
attention to that but g one kind of g
ones um you know what g1's focuses they
want to hit large heaps like you have a
six gigabyte heap they want to be able
to support that and the latency they
wanted to be less than point five
seconds in terms of causes this garbage
collectors are notorious for pauses and
it's very useful when you have a
variable optic allocation rate which
means so
more objects allocated and reclaimed
again I don't want to go into g1 itself
right now what I'll be happy to talk
about how to use g1 correctly is it
appropriate for you I'd be more than
happy to talk about that and this is
just you know something from Oracle so I
don't believe this completely myself
because I've seen all kinds of things
but g one is supposed to blow CMS and
parallel collection out of the water it
happens sometimes if you're lucky
performance and productivity
improvements so I'll go through a little
fast of course lambdas you know is a
very interesting addition you know those
of us who are from the sea function
pointers you know we appreciate this but
typically if you wrote code where you
added anonymous inner classes or you
know more often in swing it's more
easily you can appreciate that right
because you add these action listeners
to buttons but the concept right when
you have a lot of anonymous inner
classes adapters or interfaces with one
methods and stuff like that lambdas are
very useful there hashmap the
performance has gone through the roof
literally because before the previous
hashmap implementations did not really
defensively you know have coalition key
collisions in mind so what happened you
didn't know that right your hat your
application could be running really well
for six months and then based on other
factors and you know maybe your number
of customers were in a groove or your
number of transactions grew when you're
using hash maps everywhere you would
suddenly run into collisions you never
knew that happened and your application
slows down or some of the denial of
service attacks that actually end up
creating a lot of hash maps lots of hash
maps if that happens in the DRS attack
you could get collisions and then your
performance degrades to order n it's
like a linked list it becomes like a
linked list literally because because of
collisions what happens when two keys
collide they just put in a linked list
for that bucket and then later on if you
want to locate it it has to traverse the
entire linked list so where's the key
value retrieval that has never supposed
to promise you that's how it was before
so now what they have done is the way
they've implemented it is when those
coalition's start to happen they
actually use a binary tree so they use
the tree map you know internal
representation so they are able to
distribute the keys that collide based
on whether it's a higher value or not on
the bind
three and so there are and they use
comparators inside so basically the
performance of hash maps have gone up
you will see it when you use large
number of hash maps you will definitely
see a performance thing and we can show
you some numbers again if you stop by
what we have seen streams is another
interesting concept how many of us have
not used Java collections we all have
used the our collections so how many of
you have used Java collections in the
early days when we had just had vector
and we had hash set Wow so at that time
in fact I remember I use something
called JGL and how many of you use JGL
you know what I'm talking about they had
the best set of data structures
available at the time but of course Java
collections were introduced and then it
came with its own set of challenges
which is why you still had Apache had
its own collections there a couple of
other companies that provide its own
collections but if your application was
really impacted then you knew how to go
find those specific collections or write
your own but now with streams that's
again a very nice feature where first of
all you don't you know the collections
you know the the way we use iterators
and collections really was if you are a
large collection you would know what I'm
talking about so it streams the concept
is that you don't have to load it's lazy
loading so it's just you put it's a
consumable type operation you consume
only one time and it's a stream so you
don't get the whole set it kind of so
you can really tackle infinite
collections but you can limit it also
it's not that you want to go and
infinite loop but you can be literally
tackle underlying data store can be
large and it doesn't have to come from a
collection in a collection itself it can
come from I oh it can come from other
data sources and then you just use the
stream interface so it's a very
functional interface then you can do a
lot of these lazy operations filtering
mapping comparing a lot of these things
can happen and then you can do some
terminal operation so these are
intermediate operations you can chain
streams so almost like a pipeline right
and then you can do terminal operations
you can aggregate you can do interesting
stuff so steams again steams streams
combined with lambdas give us a lot of
additional you know improvements
definitely something we should take a
look at date time I mean that's you know
date was in milliseconds and then you
converted that you got time zone and you
got this nice big
string right didn't even make sense so
now then we use the Jota time and other
things that we use before now that's all
in fact they use the guy that built Yoda
time as the lead to define this so now
you know really it's immutable you know
it's more thread-safe all kinds of
things a date time and also local gate
time so you do not worry about before we
developers we had to worry about offsets
you not worry about that anymore and
diagnostics you can do remote
diagnostics they have extended jmx with
the JC md before to adjust the JC md
tool that was local now you can actually
use the jmx api and do remote
diagnostics they have provided in a
platform mbean for that this performance
I'll really run through the tools you
know this this jjs this engine is far
better than the previous javascript
engine you can invoke j effects javafx
through java j depths for developers
they can find the dependencies in a jar
signer you can have a central authority
to sign and so on now do you know what
this is these numbers this is what
people I will tell you what this is so
this is what you know people are saying
they're going to be no eight percent of
thing we're not going to leave java 6 or
we will go to java 6 47% will go to java
7 at some point forty four percent will
go to java 8 at some point and one
percent will not even do anything for
the java nine they are not there yet
maybe see the but they are intending to
do that at some point so everybody is
intending to modernize so basically why
modernize I think I've given a lot of
you know interesting views and of course
let's not forget the business views of
cost standards mergers whatever
consolidations a lot of business
viewpoints as well to modernizing so
let's get to the rapid modernization
process how would you go about now
building this tool set if you are
interested now to build the actual
technology to do this to automate this
you have your code repository you have
documents you have you know so that's a
discovery process I told you like you
know typically they do interviews and
stuff like that but we want to hit the
code repository and hopefully you have
code so that we can analyze it with
tools in literally minutes or hour
and then you you also need to have a set
of rules that you can apply against the
analysis and that's also all automated
so and then you can also have people
look at those reports and do expert
analysis if you want but automated
analysis is the key saves you all the
time and effort and then you can also
generate recommendations based on your
knowledge base and we actually have
built a set of over 2,000 rules that
allows us to do this and the metrics you
can even estimate based on the
complexity that you discover in the code
you can estimate what the refere it is
going to be and we have algorithms that
can be put together for that and let's
let's see so basically when you do that
automated tool analysis you're going to
come across you go to figure out a lot
of things right on this code itself on a
complexity on where those migration
points are in a code these can be
automated you can really automatically
find out exactly in your million lines
of code which line number where needs to
be modified and what needs to be put
there so all that can be done
automatically and you can look at
violations compliance to you know
certain rules you can also you should be
able to specify all the rules for your
organization right then of course the
estimation process so if you look at the
you know if you have been doing this for
a long time you probably will be able to
codify this into what is complex what is
not and also take into consideration
your own organizations you know
efficiencies and productivity and be
able to so technically if you put the
source code and create the analysis and
then you say okay this is what I want to
do and then you apply an estimation
model you should be able to come up with
it so here what I'm showing you here is
just a schematic of how this process
works right in in a minute so
essentially ultimately you should be
able to say I have ten migration points
in my 2700 Java files for me to go from
whatever jdk 7 to jdk 8 and it's going
to take me 58 hours to do it this can be
automated how do we automate it then I'm
going to skip this because you can build
a lot of other tools to support so the
ultimate solution so let's come to this
so you design the platform create the
knowledge base build a UI so you can
drive that and then the estimate how do
you design the platform so designing the
platform
first involves you getting hold of the
abstract syntax tree for the class files
that you have so what you can do is you
and you don't have to do this by hand
right so we have looked at a lot of
tools out there one of the tools that
would help you do this as PMD so all the
PMD is used as a static analysis code
you can actually use the internals the
libraries of PMD to get you the ast tree
so that's the first step really is you
want to be able to for your source code
you want to be able to get the ast 3 so
that actually understands so in the
process of generating that you know the
you would understand each line of and
this is a common vocabulary that you
know so whatever be your source code and
whatever be the business aspects mean
whatever you're implementing whatever
doesn't matter what API what library
this is the the lowest common
denominator so all that source code can
be compiled into a common vocabulary
which is the ast tree now you only have
a finite set of vocabulary to deal with
and what do you do now so this is B this
is the basis of the platform to be able
to convert everything to this ast3 then
you have parallely you create a
knowledge base so you have to analyze
what libraries here for example you have
spring and hibernate and you're using a
set of apache libraries you are at a
certain version you want to go to this
version that is documented all the you
know what happened between the two
versions you have to convert or codify
each of that into a rule we just took
you know we came up with the schema for
the rule and we stored those rules in
you know in progress in a sari post
crease equal so you have a persistent
store what this does is no you can apply
these rules over and over then you come
up with your new API sore libraries that
you're using you can now write new rules
for that so when JDK 1 dot 9 comes
because I have this in place is very
easy for me to add the additional rules
for that or you have some other
third-party API you can just create
those rules and plugin now these rules
are you know our own definition of it
now again PMD as a tool what it does is
it is able to you know the AST tree it
provides some hooks by which you can
traverse that tree so now what you do is
you decide you don't want to apply so if
let's say your rules you know you can
decide what all API
you want to support and create the rules
for all those AP ice and then the UI
kind of lets you select because if you
have source code that never even does
are my or Java applets or whatever you
don't need to put you know you don't
need to scan your ast trees for all
those rules so you can pretty much you
know it's up to you how selective you
want to make it and then you want to be
able to create an analysis and generate
all the stuff out of it so we can show
you a demo maybe that will be you know
you can appreciate this can you see if
you want to show that demo we have time
yeah go ahead so you actually see this
in action a little bit so I think that's
much better way to understand and then
I'll show you some ace that the trees
and how it converts the rules this is an
interface that you know it's up to you
how we want to build the interface but
essentially whatever process I walked us
through we basically built that process
and it's going to take 30 seconds
literally to analyze we have a small
file the startup cost is there that's
why but if you're analyzing we analyzed
all the Hadoop source code of 1.6
million files and literally in 20
minutes so you you know what the
migration points are and if you come
down you'll see the AP is that you know
we analyzed it against jdbc and I oh
where where we found the
incompatibilities here so what we did
exactly we created the ast tree from the
source code we had the rules already
defined and we found some rules matched
so can you go and can you show the
assessment details yeah so if you see
for example the two URL method is not a
safe method because it doesn't escape
the characters and that has to be if you
have that as be immediately replaced
that's not a good one same thing with
the commit on except changes on your you
know this your jdbc row set so the you
ever use the commit method or
stringbuffer input stream as issues you
ever use a string reader so there are
some automation you know you have to
these are all introduced in different
you know java instances so so basically
now you can go in and see
where where the issue is in the class
and so this is exactly what you need to
find you know this cannot be automated
we are just taking snapshots to show you
guys but this can all be completely
automated in fact for some of the lower
complex in a lower complexity stuff we
can also go ahead and actually put in
the changes right because you already
found the changes you know what the fix
is you can actually go and put the the
actual change you can also revert it
back means up to you if you want to put
those hooks for very complex situations
maybe you want to do it manually but at
least you've identified in your source
code where the incompatibility is and
then you can go and manually fix it but
the idea is step one as you wanna
identify all the incompatibilities in
your source code okay and if you don't
have all the rules I'm sure you're going
to miss some incompatibilities but
what's the other option manually go and
fix the code you're still going to miss
some right so but here at least you know
for the rules that you have defined that
you're aware of you've caught those
incompatibilities and you don't have to
go scan the source code again because
remember we have the ast tree now which
is an intermediate output it's a
compiler output so now what you can do
is you can actually go if you have new
rules you just go and scan the ast tree
as long as you didn't do anything new to
your source code right you didn't go
crazy on the source code the ast tree is
valid you could add rules so you don't
have to go through scanning the source
code okay then you want to show them
this is just you know an illustration
again our metrics are for our
organization so your metrics could
differ we feel those migration points
will fix in 22 hours but I will go and
ask who the yd need 22 hours i think is
like maybe five hours but depends on you
know the organization and one other
impact it could have right so you define
your metrics so that you can actually
estimate get a good idea so that
actually this is really good because I
find from you know being able to justify
to stakeholders we say it is going to
cost so many hours you know they are
much more open to knowing that oh it's
more predictable okay no I want to show
let me show a couple of other we can
switch if you want to switch
I'll give you a little bit of the inside
story right we saw the demo so I'm just
blowing this up this is the kind of
rules we defined okay what what this is
and we have analyzed all the differences
between all these libraries and API is
between different versions you know so
we have done an extensive analysis we
feel I'm sure we missed a couple of
rules possibly but I'm pretty confident
we got all the major ones and that is
the intermediate I mean that's just to
show you an illustration how we capture
that same rule how we convert it to an
XML okay and that's then again this is
not a file that we save this is all in
memory but i want to show you we can
also save that you know as an xml the
rule as an xml but that's kind of how we
know we convert because this is what we
use and there are XPath expressions in
the XML which is what we used to go and
analyze against the ast tree to find out
where in the ACE is whether that
particular incompatibility occurs on
that ast tree or not so for example that
you know getting that Unicode stream
this example we did find it on this AST
tree so if you we applied this rule
because we were looking at this we named
the rule whatever get Unicode stream
basically this method should not be used
because you will not get this all this
all it's all messed up with the encoding
right so you want to be very careful
when you use some of these bites to
character conversions in Java be very
careful so that's so this is what so
this is the actual source code where
this was where they are trying to do a
reader and they're doing a resource
result they're greeting the gate Unicode
stream and we wanted to make sure that
that's an incompatibility we want to
make sure that that is modernized we
didn't want that to lie around and we
did find that in this particular ast
tree so because we analyzed the source
code we found it now like I said the ast
tree we use PMD to to get that you know
generated and when you apply that you
basically this is the result the result
basically captures exactly where in the
source code which file
line number what's the priority of this
and is there any message along with it
again so this is a snippet so if you
analyze so this is a good way to capture
that's how we are able to show the nice
visuals because every violation that we
find in across all the source code we
capture them in these snippets and then
now we are able to even if you have like
1000 of them we can now whatever we want
we can categorize them show them in nice
visual ways but this is really the guts
of it right you need to have a rules
defined you need to convert your source
code to an ast tree and then you need to
be able to look through the all the AST
trees that you have for all the source
code so you have thousand files you'll
have so many like lots of AST trees and
then you have to apply your rules
against all your rules against all the
trees right and then you get a
consolidated view of it that's why it
will take 20-30 minutes to run depending
on how many rules you have in the
situation and you what we call as
migration points you get and if you also
if you want to automatically fix it you
can put that in as well again those are
a different set of rules we have defined
for some of these where you click a
button and you can actually put the put
the new source code in its place and all
this is important great but I hope that
everybody has all the automated tests
written as well because very any time
you modify the code you want to do
regression testing and what we find is
lot of organizations are not really up
to date on testing in which case you
know if you're going to do this you want
to make sure you also are able to test
it because that's important you don't
know you can assume that just because we
did the fix you know what if something
happened right so and if any unit tests
need to be augmented we are right some
unit tests but then it's really possible
to to get you know whatever dashboard
you want you can create out of out of
the underlying you know xml guerra so I
so basically you know these these are
the kind of source code you know what he
showed in the demo so it had one dot
five source code you know we've
highlighted it that to URL the commit on
except changes string with these are all
may
issues that can blow up so the the top
one is really scared because if you have
escaped characters in your file URLs
you're done for and these are the three
you know i AST snippets for those three
violations so you see that you can walk
the tree now and so that's the actual
java file java lime and that's the AST
tree this gives you a just a blown up
you know representation and the good
thing is a st vocabulary is finite so
you know how to walk that tree it's not
so that's something that's good and
these are the rules basically that we
had that were applicable to those
situations so you can see the XPath
expressions and stuff that would you
know match the ast tree and I will be
available you know we want to talk more
in depth that's fine and you saw the
demo really quick Queen so it's fine so
we found the four incompatibilities and
we could actually go ahead and fix it
also so then you don't need oh and I
just want to tell you that I'm going to
be you know Oracle and mcgraw-hill have
asked me to write a book about it so I'm
working on it with them which is going
to go into a fair amount of detail on
this this is not slated till next summer
but I've started working on this project
this doesn't this type of cool tooling
doesn't exist and i also have been
talking to people at Google who have
interest in this area and hopefully you
know we'll be a beat awka more to them
but especially some of the automation on
the migration site can you conclusively
also click a button and make sure that
you migrate the code and it's not going
to blow up and how do you do that but of
course those things can happen unless
you have strong test cases written
because you gotta that's where we get
into the DevOps and the whole continuous
integration right so you want to modify
and release and test over and over and
over without any impact that can happen
only if you have all those tests in
place but that's you know possible as
well so again thank you very much I'm
open to any questions I think we have a
few more minutes
yeah we have five five six minutes left
so I'm happy to answer any questions or
you want to go back to the demo we can
do that yes sir what's you please please
announce your name and then yes so the
only thing you're going to get is if you
really look at netbeans or eclipse or
all these things the way they highlight
the code changes and say but those are
really targeted at an individual snippet
of code and there are more static code
analyzers same thing with PFD PMD has
about 150 or 200 rules but they are all
for this type of you know you're as
you're coding they are not large scale
tackling applications million lines of
code and they don't have the rules so we
built all these rules ourselves yes
absolutely yes that's an excellent
question because I've also done a lot of
synthetic proxies and generated code on
the fly you know custom class loaders
all that kind of stuff so the key is
this if you have a lot of thats kind of
situation what you need to do is at some
point put in a hook there where you can
spit out an AST tree so it is very well
possible so the key to this approach
that we are outlining is that as long as
you are able to generate an ast 3 you
can create a really scalable platform
you know you can write 5,000 rules for
all kinds of things as you know if there
is you know the same solution can be
applied to scala and javascript anything
as long as you can create a finite
vocabulary that can be analyzed you can
go and write the rules for it so that's
exactly you know the great question but
that's exactly the way to think is to
say how can I boil this down to just two
things i have an AST tree doesn't care
where it came from which language it
came from and i have the rules for me to
automatically apply and then
migraine so if you think of it that way
you'd be able to solve it but yes you
should be able to create a hook in where
you create those bytecode and then get
that to an ast tree yes one of the yeah
yeah so anonymous so there are clearly
you know situations so there are a lot
of common situations right your
anonymous inner classes in a way do
using generics where you're using all
the collection interfaces so there are a
lot of that's why I said you know we
have 2,000 rules I'm sure we missed one
or two rules but as long as we have aced
it reads easy for us to add those rules
we don't need the source code anymore
you can go in yeah it's not definitely
not a simple analysis but that's what
I'm basically saying as we have built
you know using the principles outlined
we have built a very scalable platform
with over 2,000 rules so I don't know if
it takes into account every situation it
would inquire a to encounter in lambdas
and streams and other things but I'm
pretty confident that you know we
address a lot of those jdk 8 changes we
actually really looked at all the new
features in jdk 8 and made a conscious
effort to say if you are at one dot five
or one at six how can we move you to
quantitate we looked at formulating the
rules to address that yeah but there is
no easy answer you don't have an
alternative if you have a million lines
of code imagine hadoo if they want to go
to one date and then at one dot seven so
1.6 million lines of code what they
going to do and we are going to we
already did run this and guard the
reports for some of the common big open
source projects we are going to run it
against eclipse the Eclipse platform I
have talked to the Eclipse Foundation
that's four million lines of code so
it's better than nothing you know and
there is no such do we research this you
know we said if we have a solution will
just take their extended you know
there's nothing out there Red Hat and
jboss the jboss site they started off
but it didn't go anywhere really so if
you go and even download what they have
like five percent ten percent of what
you saw here so it's not anything at all
yes I mean that's we wrote our all our
own rules can you write them yeah
absolutely you can write your own rules
in fact that's exactly what will happen
because a lot of organizations will also
have their own proprietary libraries
there are different versions that they
have the support so you have to write
your rules for that and plug it in
absolutely or third-party products that
you use if you want upgrade you can
write rules for that and plug it in so
that's how I see the scaling like you
can you know and we can support one got
nine you know the Java ten whatever
comes just adding the rules for that so
that we can address them become scalable
any other questions I hope you know this
was informational and I hope you guys
enjoyed it yeah sorry you have a
question ma'am did you have a question
you know okay so then you know we are
available here i'm available in or
answer any questions i had also balance
the audience you know instead of getting
so deep into the just the code and
modifying code i had to balance the the
the the you know all the attendees but
we are available you know to talk after
this thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>