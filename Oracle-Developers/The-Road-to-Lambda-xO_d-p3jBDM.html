<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Road to Lambda | Coder Coacher - Coaching Coders</title><meta content="The Road to Lambda - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Road to Lambda</b></h2><h5 class="post__date">2015-06-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/xO_d-p3jBDM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Brian gets I'm the Java
language architect Oracle for the last
3-4 years I've been working on the
problem of integrating lambda into the
Java language and libraries and I am
happy to say that it's nice to be
looking at this from the other end of
the road so I'm going to talk a little
bit about the history of the problem of
the the issue of bringing lambda to Java
is one that started a lot longer ago
than three years I'm going to talk a
little bit the history a little bit
about the process and some of the things
that we learned along the way the new
language features the new library
features and a few thoughts about where
things might go next so of course just
to prove that I work in Oracle I have to
show you this slide so now you know I'm
not an imposter the real thing okay so
Java SE 8 which we'll be shipping first
quarter of next year is a huge step
forward it's a huge step forward for the
language it's a huge step forward for
the libraries the if you look at the
feature set it can be actually a little
bit deceptive the number of new features
that we're adding is actually fewer from
a language perspective than in Java 7
Java 7 we added a larger number of
smaller features in Java 8 we're adding
a smaller number of features that are
going to have much more significant
impact on the way we program so the big
two features of course lambda
expressions and default methods and I'll
be talking about those in this talk to
go with those we've made significant
additions to the the Java class
libraries as well because language
features are they're just an enabler if
we added new language features but we
didn't integrate them into our libraries
you wouldn't be able to to use them
effectively on day one so a huge step
forward for the language huge step
forward for the libraries and you know I
think this is not really an exaggeration
to say this is gonna be the biggest
upgrade to the Java programming model
ever this is bigger than generics
hopefully it's better than generics time
will tell
so I'll talk a little bit about how we
chose the features we did why we
rejected some of the features we did and
some thoughts on how one
goes about evolving an already mature
language so I'll start with since since
we're you know using the phrase lambda
expression let's talk about what a
lambda expression is it's a very simple
concept it is a anonymous method so it's
a method that doesn't have a name but it
has everything else a method has it has
an argument list it has a body it has a
return type that has a set of exceptions
that it might throw but we describe it
sitting in a syntactically more compact
way we don't have all of the boilerplate
of public void foo blah throws blah etc
so here's an example of a lambda
expression the argument list has one
argument its type is object its name is
o its body is evaluate this expression o
two string and return that okay that's
all a lambda expression is okay so
lambda expressions like inner classes
can also refer in their bodies to values
that come from the enclosing scope so
here's another example of a lambda
expression person P so that's the
argument list one argument of type
person the body evaluate speed get name
equals and then this identifier name
which is defined in the scope outside of
the lambda expression so we call that
capturing a value so that's all that's
all it is very simple concept but very
powerful there's also a shorthand form
called a method reference and the idea
here is if you look at that first lambda
expression all it's doing is taking its
arguments of which there are none and
turn around passing them to an existing
method a method reference says alright
let's just refer to that method by name
instead of by building an expression
that calls it so this method reference
of object colon colon 2 string is
identical to that lambda up top okay
sometimes one is more readable sometimes
the other is more readable that's why we
have both forms the whole point of this
is it allows you to express code or
behavior as data so I have a little bit
of the behavior I want to stick it in a
variable I want to pass it to a method I
want to say hey do
for every element of the collection do
this when you get an error do this when
you start do this when you end etc and I
can pass this into a library so that the
library can can sort of take over the
control of a computation all right so
that's the basic concept we'll see a lot
more examples okay so why are we doing
this well the reality is times change if
you look back to 1995 when the java
language was being designed most popular
languages did not support closures
Fortran didn't see didn't pascal didn't
so it wasn't viewed as something that
was a necessary feature for languages
even though there were many languages at
the time that did support closures they
weren't in popular industrial use it
wasn't seen as an essential feature fast
forward to today basically every major
language does have closures Java has
really kind of last holdout you know to
to jump on the train
C++ just added them you know about two
years ago C sharp added them about five
or six years ago any language being
designed today would you know would have
a mechanism for abstracting over
behavior so things change Java is
changing with the times maybe a little
behind the times but you know we do get
there so this is a long road so in you
know the topic of closures in Java you
know started in 1997 there were a number
of competing efforts that went on at the
time so phil Wadler and Martin Oh Turkey
had an experimental project called Pizza
which added among many other things
closures to Java in 1997 in Java 1.1 we
added inner classes which were a very
weak attempt at solving the same problem
which suffers from a great deal of
complexity a lot of syntactic
boilerplate very complicated name lookup
rules but it was the same motivation
some of you may have remembered may
remember there was a vigorous debate in
the community
in the 2006 to 2008 timeframe about
adding closures to Java there were
multiple competing proposals there was
the GGA proposal there was the CICE
proposal and these were all different
sort of views of the elephants different
eye different ways of how
one would integrate closures into Java
and they each had kind of different
motivations the vgg a proposal took as
its you know primary goal we want to be
able to write control abstraction in
libraries whereas the CICE proposal was
much more about reducing the syntactic
pain and people remember these times
anybody all right these were kind of
ugly times you know the the the vitriol
and the community was you know was
really quite high so it was kind of a
good thing that things settled down and
we were able to synthesize the ideas
from these different proposals into
something that was you know uh kind of a
blending of the best features of each so
you know this topic you know sat until
about 2010 when we decided okay we're
finally going to do this now the the
road to lambda expression started long
before 2006 this gentleman on the left
is a lung Alonzo Church who coined the
expression coined the phrase lambda
expression in 1932 in his book the
calculi of lambda conversion so people
ask you know what why do you use this
this funny sounding name for you know a
basic concept well we've been using this
name for since many years before silicon
based computing came around so this name
predates almost all of us so it was a
long road so this particular effort we
started in 2009 file of jsr in 2010 this
has been what I've been working on since
then and so we are at the point now
where we're ready to go to public review
that should be coming out sometime next
month is a Developer Preview that you
can get at open JDK right now of course
it's going to be in you know in Java SE
8 and like I said small number of
features that make a big difference
lambda expressions interface evolution
and bulk operations on collections so
I'd I'll talk about all this okay before
I jump into the details sort of an
undercurrent of what we're thinking
about as we're evolving the language
there's forces pushing us in both
directions about how much to change and
how fast and how
we should think about change on the one
hand there are forces pushing us towards
change you know that you should change
the language because the world is
changing around us the hardware
underneath us is changing developer
attitudes are changing demographics are
changing the problems we're facing or
changing and of course you know over the
last 17 18 years we've made a few
mistakes that we might want to fix as we
go so these are things that's there that
pushed us towards change on the other
hand there are things that push us away
from changing as well we place an
extremely high value on compatibility
and I don't think Java would be as
popular as it is if we hadn't you know
continued to deliver on the promise of
you know code from you know class files
from Java 100 will still run and they
still do run you know so if you have
existing class files you know we're not
going to break those we have very low
tolerance for changes that will break
your existing code and if you know if
there are nine million developers who
are happily programming in Java there
must be something they like about it so
if we change too quickly we run the risk
of alienating them so there's a very
difficult tension here and there are
some people who say we should be
changing faster and some people are
saying we're changing too fast and we're
caught in the middle making everybody
equally unhappy that's about the best we
can we can aim for so you know so this
is sort of the background under which
these decisions get made just to give
you an idea of how much things have
changed in 20 years so in 1995 the whole
world was sequential everyone believed
the world was sequential and it was
embodied in the semantics of our
programming languages so you look at the
semantics of the for loop the for loop
is inherently sequential you do the
first iteration then you do the second
iteration then you do the third
iteration in exactly that order within
one thread one after another
sequentially right there's no wiggle
room for for getting better performance
out of parallelism and you know in 1995
that made perfect sense right
concurrency involved non determinism why
would we invite non determinism into our
programs if it wasn't giving us a
benefit so you know determinism is nice
if it's not costing you anything and
then as we designed our libraries this
sequential view you know came along
where you know we
our abstraction for getting elements out
of a collection is iterator iterator is
fundamentally sequential all you can do
with iterator is get the next element so
this pervasive sequentiality we didn't
even know that we were thinking
sequentially twenty years ago we just
thought we were thinking and only you
know in in hindsight do we realize that
we had made assumptions that might be
inconvenient we made the same you know
same choices / mistakes with mutability
Java's default is everything's mutable
and then if you're very careful you you
know you can design things so that
things are immutable and this again was
a consequence of the fact that mutation
was cheap at the time and you didn't
have a high degree of concurrency so it
wasn't all that dangerous so why not in
today's world if we were designing a new
language these are the wrong defaults
unfortunately we can't say okay let's
take those trillions of lines of java
code out there and to clear them all
bogus because we've changed our minds in
the last twenty years that's not that's
not okay we can't just outlaw for loops
can't just outlaw a mutability the only
thing we can do to evolve the the
language and the the ecosystem is to
give people a gentle push towards hey
here's something better and hope that
people accept that push so lambda
expressions are are part of that so
let's take a look at you know one of the
key aspects of what what are lambdas
enable and that is this inversion of
control between who's in control of a
computation between the client and the
library so here's a little snippet of
code typical Java code I've got a
collection of shapes I loop through them
and I colored the red ones blue so this
is using the for loop again this loop is
inherently sequential the other thing
that's going on here is that the client
is in control of the iteration this is
external iteration the the syntax the
for loop kind of hides this a little bit
but what's happening is the client says
to the collection give me an iterator
and then for every element it says give
me the next element give me the next
element give me the next element so we
have this sequential abstraction
iterator and we have the client pulling
elements from the iterator sequentially
and the interaction between the client
in the library is made more complicated
by this because since the client is
repeatedly calling to the iterator the
integrator has to be defensively coded
in such a way that it's okay if you call
hasnext too many times or you call next
without calling has next you know or any
any of these things so there's a lot of
complexity that that comes as a result
of the client being in control of the
computation so you know the the way I
like to describe this is this code mixes
up the how and the watt and ideally we
would like the client to be in control
of the watt let me tell you the results
I want and let the library take care of
the gritty details of how but right now
the client is in control of both and and
that you know it's something that's like
so second nature to us we don't even
notice that it's bad until it's taken
away from you and you say oh wow that's
that's easier so here's the equivalent
thing with a lambda expression if you
blinked you might have missed the
transition because it's syntactically so
similar but it's actually a world apart
semantically so here imagine our
collection has a foreach method that
takes a lambda expression that's going
to get called for every element and the
body is exactly the same it looks very
much like the other version but what
we've switched to is internal iteration
where we're saying to the library here
here's a little bit of behavior run this
behavior for every element of the
collection we are now no longer
constrained to run sequentially we're no
longer constrained to run an order from
zero to n the library can decide what
its iteration semantics are going to be
but what we've done is we've handed over
control to the library and now the
library has the possibility to use all
kinds of tools
parallelism out of order execution
laziness whatever it's gone it's toolbox
to to optimize the execution of this so
this is one of the really subtle things
that lambda expressions enable it's not
just a better inner class although it is
it's making it easier to build api's
that let the library be in control and
that opens
doors to much more powerful more
expressive api's okay so we'll see lots
of examples of that one thing to note by
the way that I've omitted the type of
the the argument to the lambda
expression I've just called it ass I
didn't say shape s this is not dynamic
typing this is full static typing what
Java has always had its just the
compiler has figured it out for you and
doesn't make it make us type it out by
hand so it infers the fits in shape
shapes is a list of shape and the for
each method takes a consumer of shape
the compiler says oh as much it must be
a shape okay
so we've introduced a new kind of
expression expressions have types so
what is the type of a lambda expression
so most languages that were built with
lambdas from day one have a notion in
their type system of a function type
sometimes they're called arrow types you
know and it's a function from int along
you know is is is a type just like
spraying or a list of lists of integer
so we actually went a bit of a ways down
the road to see what would it take to
add function types to Java and it seemed
like a good idea in fact it seems like
an obvious idea until we started to look
at what was involved in pushing this
down into the VM and how this would
affect the signatures of methods that
the compiler generates and it turned out
that this would have exposed a lot more
situations to the pain of erasure and so
we after a while we retreated from this
path and we went for something simpler
which is we did what we would people do
in Java libraries you know from from day
one to represent functions Java
libraries are full of interfaces that
have one method runnable comparator and
you know since Java 11.0 we've had
libraries where youth passed in an
instance of a comparator or an instance
of a runnable or an instance of an event
listener and we've modeled these with
one method interfaces so this is a
pretty good trick it's been working for
eighteen years
we've got libraries that use this trick
already so rather than invent new
machinery which involves a lot of new
complexity
new corner cases let's just do what
we've been doing and give it a name
right well make it real by giving it a
name the new name is functional
interfaces so you've all been
programming the functional interfaces
for 18 years you just didn't know it
because we just invented that name last
year okay so the type of a lambda
expression is a functional interface the
compiler looks at the type on the left
hand side and says and when you're
assigning a lambda to something and it
says alright I've got this this
interface predicate of string which is
morally a function from T the boolean
and I've got this lambda that has one
argument so that's gonna be a T and then
I'll type check it make sure the body
type checks to boolean and if everything
works out right the compiler says okay
that's good this lambda is an instance
of predicate of string so this is not a
totally new thing to have have the type
of an expression be dependent on its
assignment context this showed up in
Java 100 in array initializers and it
showed up in Java 7 and diamond it's
something we're building on doing a lot
more of we call it target typing so the
type that you're assigning to affects
the type of an expression so you know at
the bottom we have an example of a
runnable it has an argument list with no
elements and a body that has a statement
you can have more than one statement at
a lambda expression just by enclosing
them in braces and separating them by
semicolons okay
so we're using functional interfaces to
represent the type of a lambda
expression and the interesting thing
here is when we started doing this it
was just completely obvious that we
should have added function types Java
turns out it was obvious it was also
wrong there's a lot of things that are
obvious and wrong so when you start
digging about what is it really gonna
mean to do something like add function
types to Java it turns out that you know
there there could be a lot of complexity
under the surface so this is something
that would have interacted badly with
erasure people don't like erasure so
more erasure probably worse it would
have would have had this a subtle effect
of bifurcating the world of Java
libraries into old libraries and new
library
and you know you remember when we did
generics how much churn there was of
people updating their libraries to
generics it took like another five years
so what we didn't want to do was wait
another five years before people could
start using this stuff so by saying
we've got this idiom Java developers
have been using for eighteen years let's
use that as our lambda typing idiom all
of a sudden all these old libraries just
all work with lambda from day one so you
know this is that you know preserve the
core argument that I was making before
something works you stick with it
there's value in doing that and like I
said these existing libraries as a bonus
but come automatically forward
compatible with this language feature
that they never anticipated was coming
but all of a sudden work beautifully
with so you know this is you know more
efficient maintains our investment in
existing code fewer concepts to learn
etc okay
so the more subtle thing that happens
here is when you have lambda expressions
in your language it enables thinner
api's so the reason is the boundary
between the client and the library
becomes more permeable you're not just
passing in you know in some strings you
can pass in behavior you can say do this
for every element do this if you get an
error consult this strategy if you get
lost etc and it allows us to build api's
that you know that are more flexible
more permeable where the library can
take control of a larger calculation and
it moves us towards this world where the
client is in control of the watt and the
libraries and control of the how and
that's really how it should be libraries
are supposed to encapsulate knowledge
about how to do things and a lot of the
libraries that we use are written by
domain experts who understand that
domain far better than we ever would and
we would like to get all the benefit of
their expertise so the more work we can
let the library do the more the library
you know the notion of using libraries
in the first place makes sense it also
by you know by structuring API is this
way it exposes a lot more opportunities
for optimization and we'll see a few
examples of that okay so let's take an
example of just sort of
how we actually use this in code so how
much done a lot of code yet if you want
to sort a list this is how we do it
right you say make a comparator you make
it with inner class instance lots of
ugly horrible boilerplate and you know
and then you pass that to a method like
collection dot sort so there's a lot of
things that are wrong with this code we
don't like to talk about the things that
are wrong with this code if we don't
have an alternative to writing this code
right just cognitive dissonance keeps us
from from talking about what's wrong but
now that we have an alternative we can
talk about all the things that are wrong
and try to make things better the first
thing to notice is of course we could
get rid of some of the syntactic
boilerplate by replacing the inner class
with lambda but I actually don't think
that's the interesting part here it
would be syntactically more compact but
we'd still be committing all sorts of
sins of abstraction one of the things
that this this this implementation here
does is it violates that don't repeat
yourself principle I'm conflating two
separate things the extraction of a key
and the comparison of that key and those
are really orthogonal and there's some
duplication going on here in my
comparator where I'm saying X doc yet
last name Y dot get last name I'm
extracting the key twice my code for key
extractions duplicated now in a little
snippet of code like this it might not
seem so bad but conceptually I'm
completely i'm conflating two different
things so one of the things that you can
do when you when you have lambdas in the
language is you can build we're called
higher-order functions these are
function these are methods that take as
input functions and return as output
functions so ignore the generics that's
the hardest part about this example the
idea here is we've added to the
comparator interface by the way you can
have static methods and interfaces now
yay
we've added a method called comparing
and it takes a function so that extracts
a sort key so the idea here is I've
encapsulated the comparison logic by
saying I'm gonna give you a function
that extracts a sort key person dot get
last name and you'll hand me back a
comparator of person that compares on
that sort key okay
and so now if you look at the code on
the bottom and I see all the you know
the groundhogs are popping their head up
too to see the code on the last last
slide the the code that the user writes
gets much simpler you're saying give me
a comparator comparing by last name
right the code is starting to read more
like the problem statement so that
method reference is a function that
takes as input a person and returns
their last name the comparing method
which is just one line of code this is
the whole thing the generics are are
more difficult than the actual code take
statics that key extractor function
hands you back a comparator
okay so you know instead of having this
horrible inner class that duplicates the
you know duplicates the extraction we've
sliced it into we've got something that
encapsulates the comparison as long as
you give me a comparable sort cake and
then I can just say you know sort list
comparing person last name okay much
simpler and that's what I mean that by
Lam does enable better ap is that
comparing method is one we could have
written with inner classes but there was
no points it wouldn't have made the
resulting code any prettier it would
have been just as ugly to use but once
we have a way of modeling a function
it's very easy to build up functionality
by taking little functions and composing
them so we take a key extractor function
and we wrap some logic around that to
make a comparator function out of it
and this way we factored apart these two
separate things key extraction in
comparison we've eliminated a lot of
boilerplate code from the user code and
you know so the effect that this has on
our API is is it becomes a lot more
practical to build API is out of
composing a little bits of functionality
right so I'll just go back to this this
example that comparing method is one I
had to write once it was trivial to
write and now no one ever has to you
know write out by longhand the full
nasty comparator again and you know the
resulting code that you get saying
comparing by person last name is much
more pleasant and without lambdas we
couldn't have done that
so you know if you have lambdas in the
language we can write better libraries
if we have better libraries we get more
readable less error-prone user code and
that's what the whole story is about
okay now ideally we'd like to evolve the
programming model through libraries and
not through language changes because
libraries are easier to write they're
easier to distribute they're easier to
update there's more people who can
deliver libraries so sometimes we hit
the limits of what libraries can do and
they need a little help from the
language and so the goal here is little
help from the language to enable the
whole ecosystem to deliver better
libraries it's pretty good deal ok so
let's look at a problem that we ran into
along the way and that motivated another
another feature so we had an example
earlier a collection dot for each well
that method doesn't exist so we could
add it but you can't add methods to
interfaces without breaking existing
implementations of that interface if I
went and added a collection dot for each
method in Java eight without doing
anything else anybody else who's
implemented collection would never be
able to recompile their collection
because the compiler would say you don't
provide an implementation of foreach you
must not be a real collection so
interfaces are this double-edged sword
on the one hand they give you very
powerful you know strict interface
contracts on the other hand they're very
rigid and the reality is API age and the
world changes and an API that might have
been perfect in 1997 is unlikely to
still be perfect in 2013 even if it was
perfect back then so you know we're
still using these collection api's that
are 15 years old and as we add you know
cool new language features it makes our
existing libraries look even older
because you say well but but I can't use
lambdas with that library that library
sucks right so aging api's are a problem
and there's a you know we've we've not
had a lot of good good options until now
for how to deal with this problem
we could just let it stagnate that's not
very good we could try to replace it
every few years let's get rid of
collections and write
elections two collections three eight
collections four we're looking at
probably a five-year adoption lag each
time we try to do that a lot of churn a
lot of annoyance or we could do what
we've been doing which is nail bags on
the side like well we can't add
something to collection so we'll add a
static method to collections collections
dot sort and do that and that doesn't
scale very well it's not object oriented
so we've had these bad choices and we
finally decided we need to tackle the
problem of interface evolution so we
added this feature called default
methods a default method very simple
it's a it's a interface method that has
a default implementation so the idea is
it becomes okay to add a new method to
an interface yay as long as you provide
some implementation so that classes that
don't have an implementation get the
defaults but they're virtual so if the
if you have an implementation that
overrides it great they provide a better
implementation so you can think of
default as like the opposite of abstract
you know in classes most methods have
bodies except these special ones called
abstract methods that don't have bodies
in interfaces most methods don't have
bodies except the special ones called
default methods that do what this gives
us is an ability to evolve libraries
over time which we desperately need and
from the clients perspective default
methods are just methods they're just
virtual interface methods you don't have
to know that it was a default adding a
method with a default is both sort
compatible and binary compatible adding
a default to an existing method is
binary compatible you know it's it works
pretty nicely so here's here's the
actual code for the for each method that
I use before I had collection dot for
each the implementation is really
trivial you say this is a default method
you have a signature you have a body
this is an instance method so there's a
receiver there's a this variable it's
type is the interface collection here so
it can call the iterator method here's
the implementation of collection freeze
now ArrayList off for each uses a better
implementation doesn't need an iterator
it just does for I equal one to two
sighs so
very straightforward so I say it's
straightforward but of course there's
there's some details to understand a lot
of people look at this and say oh my god
you've added multiple hair nice Java I
think I look somebody up there you know
and to which I cleverly respond well
Java has always had multiple inheritance
of types what we're adding is multiple
inheritance of behavior what we're not
adding as multiple inheritance of state
and this is where all the trouble comes
from our intention our primary
motivating intention here is to provide
interface evolution clever observers
will notice that this gives you a lot
more than interface of evolution this is
not unlike not unlike a trait in fact
forretress traits were stateless these
are almost identical to fortresses
straight traits so you could put default
methods and interfaces from day one you
don't have to wait until you're evolving
the interface you could just decide that
the interface is the right place to put
this code and it actually becomes a very
convenient way to you know to program
there are other other mechanisms out
there in other languages that are
similar c-sharp has a concept called
extension methods
there's extension methods or static and
their declaration site which means
they're injected from outside the class
are verage our default methods are
virtual and they're sorry they're their
central methods are used cite ours our
declarations site in other words ours
come from within the class being
extended not from outside different
Design Center like I said these are also
similar to traits and fortress there are
a few simple rules for how to resolve
conflicts because if you can inherit
behavior from multiple sources you have
to deal with what happens if you try to
inherit the same behavior from more than
one source there's three simple rules
rule one is if the class if the
superclass hierarchy has anything to say
about it that's the end of the story so
if you can find a an implementation in a
superclass or you find an abstract
declaration in a superclass you're done
don't bother searching the interfaces
you've got the answer
this gives us absolute compatibility
with anything that worked before Java
eight is gonna work exactly the same way
okay so the default only come into play
if you can't find an implementation in
the superclass chain and like I said
this is true for both concrete and for
abstract methods so okay you haven't
found anything in the superclass you
look at Rule two you look at all of the
interfaces that provide a declaration of
this method if there's one
yay if there's more than one if one is a
subtype of another if you have a default
for for each that you inherit from both
collection and from list list as a
subtype of collection it's more specific
so that we don't consider the collection
one if there's a unique most specific
default we take that and it doesn't
matter who inherited who first it
doesn't matter whether you're directly
extending list or you're indirectly
extending list nine times removed it
doesn't matter whether you redundant
leary declare it's strictly a matter of
you look at your super types you take
all the declarations you remove the ones
that are overridden by other you know
more specific types if there's one left
you win otherwise you go to rule three
which is there is no rule three and it's
as if the method we're abstract and you
have to implement it yourself okay so so
here's an example here where you have a
real conflict between a and B they both
have a default method M C implements and
B there's no rule to resolve this
conflict so C must provide an
implementation or a reaction of M so in
this case we say we provide an
implementation it just delegates to a is
implementation okay so this is actually
very straightforward now of course the
clever guy and the audience says well
what about diamonds because diamonds are
hard in other languages that have
multiple inheritance or at least with
multiple inheritance of state turns out
they're trivial in Java if you have a
diamond inheritance where some type at
the top provides a default and then two
classes extend that and then you extend
both of those classes no problem because
you're everyone's inheriting the same
implementation there's no there's no
separate state
this the same thing interfaces have
always done if you have two identical
and interface methods than you inherit
they just get merged so this is actually
you know it's easy to get scared about
multiple inheritance but it's actually
pretty straightforward so let's look at
why this is actually useful
so default methods are their instance
methods so they can use other methods of
the of the interface so for example if
we wanted to add a method to collection
called remove if where you pass in a
criteria we you know here's a reasonable
implementation of this it grabs an
iterator that's an instance method it's
calling this dot iterator which is fine
because collection has an iterator and
it goes through the goes through the
elements and applies the the test to
each element and removes the one that
you know the ones that match okay so
this gives us a path to adding you know
new lambda friendly methods to our
collections and like I said adding a
method with the default is you know
fully fully compatible so this is a
pretty straightforward thing we've done
quite a few of these we've added a bunch
of new methods to collection to map
things that we wished we had but you
know forgot to do in 1997 finally we can
add them in things that make sense with
lambda that didn't make sense before
lambda you know we can do the same thing
here's another one that makes people
surprisingly happy how many people here
have written an iterator how many people
here we're annoyed that you had to
implement the remove method even though
all you were doing was throwing an
exception that's even more people than
wrote an iterator so we can take this
existing method on iterator remove and
say we're gonna add a body to it and the
default body throws an exception right
effectively we can call that an optional
method here's a method on an interface
that you it exists you don't have to
implement it if you don't implement it
the implementation you get is throws on
supported operation exception so if
you've got existing interfaces that have
methods that you think no one's really
ever going to override
now you can give them empty defaults and
your users won't have to override them
all that's kind of nice
so another thing that you can do with
default methods is it becomes a very
natural place to add combinators on on a
type so for example let's go back to
comparator a common thing you might want
to do with comparator is reverse its
order so what we did was we added a
method called reversed on comparator and
this is a default method we don't expect
anyone's actually gonna override this
method because the default is good
enough but they could if they wanted to
and all it does is call compare in the
opposite order
it could call compare and negate it yeah
it's the same same thing so now if you
have a comparator for let's say person
by last name and you want a comparator
for person by last name descending you
just say comparator dot reversed and
sort on that okay same thing with
predicate dot and you know all of these
things that represent your function dot
compose same same thing so you know
we've added actually a bunch of nice
tools to comparator you know that use
this mechanism all right so let's sort
of like put together the things that
we've sort of talked about so far on
some examples so we're talking about
sorting where we were in the last
example was we said we want to sort the
people by last name so we use you know
comparator doc comparing we pass it in
the function that takes a person and
returns their last name and that returns
a comparator a person and we sort the
people by that okay this is already
better than you know where we were in
Java 7 but we can do better than that
right because all of this is so much
less wordy we actually probably don't
even need the intermediate variable we
can just code it in line and and the
whole point of this is we want the code
to read like the problem statement sort
the people comparing last name that's
the essence of what we're trying to do
we don't want to wrap it in a lot of
garbage about iterators and comparators
and all that's all accidental complexity
right but we can do better remember we
talked about
how we can add now methods to interfaces
we can add a sort method to lists and so
instead of using this outboard method
collections dot sort we can say people
dot sort
comparing last name all right we're
getting better now I showed you the
shorthand form of method references
which are in this particular case not
that much syntactically shorter than the
equivalent lambda expression but I think
they're a little bits a little bit more
clear what's going on you have the
function that is get the person's last
name that's the function we're comparing
by so people that sort comparing person
get last name okay
and you know that like I said now the
code is reading a lot more like the
problem statement if we want to sort in
the reverse direction we can use the
reverse Combinator we just showed you
sort comparing last name reversed okay
instead of having to make a whole new
comparator like we would have if we want
to sort by last name and then by first
name for people who have the same last
name we can say comparing by last name
then comparing by first name okay none
of this is magic if you go into the
comparator source code and you look at
the source for methods like comparing
and then comparing they're two lines
each right there's more generics than
there are code okay so it's really
simple to build these little combinators
and it makes your code so much prettier
okay so there was a little bit of a API
design lesson that we learned as a
result of this so originally when we
were you know thinking about what are we
gonna do to support lambda in the API is
we thought okay well we definitely want
to have a sort method on you know on
list and probably on array is and
probably on stream and and then we
thought like well how about a sort by
where you pass it you know a key
extracting function and then we realized
well we actually have to have a couple
of versions of those one for int and one
for long and one for comparable and then
what about sorting and reverse I we need
a reverse sort and this thing ballooned
up into like twenty different variants
for something that would seem so simple
and obvious I've just add a sort method
and then what we realized was that we
were banging our head
the wrong level of abstraction by adding
just a handful of Combinator forms into
comparator we only had to add the
comparing is sort by comparator method
and all of the various combinations like
reversing work compositing all came from
the combinators that we've already seen
that's a much smaller number so you know
the as you use lambdas in your libraries
you'll probably run into the same thing
where it'll be like the obvious thing is
you know add this at this level and then
you'll discover that there's kind of a
combinatorial explosion usually what
that means is there's a level beneath
which is the right place to add things
so watch out for that okay so let's talk
about the really fun stuff the bulk
operations on collections so we had this
example of you know take the red shapes
and color them blue we can actually
decompose this a little bit further
really what this is is compositing a
filtering operation with a with a
foreach so we can write this using we've
added this new abstraction called stream
which I'll talk about where you can you
can apply these bulk operations like
filtering and mapping and aggregation
and such and we can you know break apart
this sort of still somewhat imperative
version into something a lot more
declarative take the streams select the
ones that are red and then for each that
are remaining color than blue okay
now this particular example might not
make a big difference to decompose it
this way but as the examples get more
complicated I think you'll see that this
is a really nice way to slice and dice
collections so for example if you won't
have a you know a bunch of shapes and
you want to collect all the blue ones
into a list you can say take my shapes
select the blue ones using filter now I
have a stream of blue shapes and collect
them into a list
alright that's you know that's a little
bit more compact than the way that we
might have written it otherwise this is
good I'm going through these examples
very quickly I've got a whole talk on
this on Wednesday Tuesday Wednesday
Wednesday Wednesday morning called
streams and top gear that Paul and I
will be
so I'm gonna blow through the examples
pretty quickly but just give you a
flavor of what you can do with this new
library let's say each shape was
contained inside a box and you wanted to
find not the blue shapes but the boxes
that contain the blue shape same thing
take your shapes filter the ones that
are blue so now you have a stream of
blue shapes map each one to its
containing box so now you have a stream
of boxes and collect them into a set
okay if you were writing this by hand
again you'd have to you'd have to do a
lot more you know there'll be a lot more
details if you want to add up the sum of
the weights of the blue shapes take your
shapes filter them for the blue ones map
each one to their weight add up the
weights okay so this is what I mean by
bulk operations instead of operating on
each element in time give me an iterator
give me the next element is that element
hat doesn't have the characters that I
want I'm operating on the collection as
a whole take the shapes take the ones
that are blue transform them all into
something else there wait add those
weights up these are bulk operations
aggregate operations and it's a lot
often a lot easier way to specify the
kind of things that we do every day the
nice thing is they're very expressive
they're very composable you have each
stage does one thing and it again moves
us towards this goal of the code reads
like the problem statement now one of
the things that you know that often
happens is you've got some code that
implements something and then the
problem changes a little bit and if your
code is all ad-hoc very often this
ripples into a very large change in your
code whereas if your code is cleanly
factored of where each stage is doing
exactly one thing a small change in the
problem is likely to end up being a
small change in the in the resulting
code and all of the intermediate results
they just go away they're not present
they're just internally details in the
library so the way we did this is we
added a new abstraction to the libraries
called stream it represents a stream of
values it doesn't store any values it's
just an abstraction for the sequence of
values so the data is stored somewhere
else in a collection and an array maybe
it's coming from an
a channel and you know the operations
like filter and map these produce a new
stream so we start out with a collection
of elements we filter them that produces
a collection of filtered elements we map
them that produces a stream of mapped
elements and only when we get to the
last operation which might be collect
them into a list or do something for
each one of them or add them up do we
actually do the work and so this turns
out to be really efficient because
instead of having to make three passes
on the data first for filtering then for
mapping then for aggregation we collapse
them into a single pass on the data so
the code is very clear it's very clean
it's very readable and it actually turns
out to be quite efficient as well and as
an example of why this is so important
here's a slightly more complicated
example of code that like messes around
with a collection don't even bother
trying to read it it's gonna take longer
for you to figure out what it does then
it will for me to get to the next slide
and that's the problem you know you're
probably you're probably I can see
you're trying to read it you're like ok
I've got a collection and you have to
read all of it right you have to read
all of it to figure out what it does
because there's so much accidental
detail of I've got this side collection
called sellers and that's just for
intermediate results and I don't even
know what this thing does
right if I rewrite this problem using
the streams library if you can actually
see it from the back because it's the
bottom of the screen the code reads like
the problem statement take the
transactions select the ones where the
buyer is over 65 for each one of those
get the seller get rid of duplicates
sort by name print them much more
readable and you can actually like
figure out what this code does in five
seconds whereas you have no chance of
figuring out what that code doesn't five
seconds and if you can't figure out what
the code does what's gonna happen you're
gonna make a mistake where do bugs come
from you're in a hurry you've got some
code that you've been looking at for
five minutes you think you know what it
does and you know you do something and
you've messed up so the harder code is
to read the more likely that's going to
happen the easier code is to read the
less likely that's gonna happen code
should be so obvious what it does that
you can't possibly mistake it right
that's
you know cuz that's code that's always
gonna work so just sort of compare these
approaches the imperative approach deals
with things one element at a time the
streams approach deals with it a whole
group at a time
the imperative approach is very caught
up in the details of how and off the
watt it doesn't read like the problem
statement the steps are all mashed
together there's all these extraneous
details like intermediate variables
which I like to call garbage variables
because they're not they're just
side-effects of the computation and also
the imperative approach is inherently
sequential because it's always based on
a for loop whereas the streams approach
can be fully parallel okay
now by default it's not parallel we're
not forcing parallelism on people who
haven't asked for it because that would
be mean but what we're trying to do is
make it easier to take sequential code
and make it parallel without having to
completely rewrite it which is what you
have to do you know until now okay so
parallelism used to be if you wanted to
take some existing code and make it
parallel you basically had to explode it
and rewrite it and that was hard it was
error-prone we're all lazy so we
probably wouldn't do it the easier it is
to take your working sequential code and
go to working parallel code with less
work on your part the more likely you
will use parallelism when you need it
okay so we added this fork/join
framework in Java 7 it's great but it's
not enough because it was too hard to
use so the idea is we want to make it
easy to go from sequential to parallel
but not so not you know uh not so easy
that you don't notice that you've done
it okay I'm gonna skip forward to the
the example here with fork/join
the basic concept is I've got a big
problem I want to solve it in parallel
so I whack it into two smaller problems
and I solve the subproblems in parallel
and if the subproblems are still big I
do that recursively so I take the half
and I whack that into two quarters and I
whack that into eighths until the
problems are small enough that I can
solve them sequentially and then I merge
the results very straightforward
this is what the code looks like in 4th
join the red code is like the actual
business logic and the black code is
boilerplate and obviously we don't want
to inflict that on you so I'll skip to
the punchline which is if you want to do
the sum of late examples with streams
you just swap out shaped stream for
shapes parallel stream stream and
parallel stream or default methods we
add it's a collection so you can say
give me a stream
give me a feral off stream you ask for
parallel stream you get that same exact
fork joined decomposition without having
to write all that fork join code step
forward now parallelism isn't a magic
bullet so that's not to say that just
because you can do everything in
parallel that you will want to but at
least now you have the choice without
having to do you know a whole load of
work and again when you execute this in
parallel it all gets fused into a single
parallel pass on the data there's no
filtering pass mapping pass summing pass
it's just one pass on the data filter
Map Reduce
ok so summing up why are we doing lambda
in Java
well first reason it's about time isn't
it a lot of other languages have already
figured this out what was a radical idea
10 years ago is that what took you so
long today make it easier to deliver
parallel libraries we have multi-core
hardware we want to make it easier to
write code that runs on them in order to
do that you need a mechanism for
internal iteration here's the behavior
to do to each element just do it don't
bother me
and we want to help people write more
effective libraries and lambdas do that
they make for you know libraries that
allow clients and library to cooperate
at a finer degree and that results in
cleaner more expressive easier to read
easier to write less error-prone code so
places to go for more information you
can get the Developer Preview at
java.net you can know download that
tried
right now there's a public review in the
JCP coming of course this will be part
of Java SE 8 and there are quite a few
other lambda talks at JavaOne
this year I haven't listed them all but
there are several a day so you know you
certainly certainly have ample
opportunities to learn about this some
more
so having done that all in one breath
that leaves us like 6 minutes left for
questions so do we have any questions
we'll start here and then here ok ok so
the question is how does this compare
with the VL 300 lambdas so they use a
very similar syntax e-l doesn't have a
notion of capturing values from you know
closing contexts they don't have a
static type system so that they're not
able to use the target type so they're
kind of like basically untyped function
literals any l so this is much more
integrated into the into the post
languages type system but same basic
concept so we have a question back here
okay so 6/10 stand up with you
so the question is what is the impact on
debuggers so there's definitely
definitely some consequences for
debuggers here so what the compiler does
is it associates line numbers with
lambda expressions and D triggers them
into methods so when you step into a
method it should be able to take you
back fairly easily to the source
not all debuggers are fully up on the
translation of the names of values that
have been captured from the local
environment too so that you may not
necessarily in the current version of
you know ideas be able to inspect the
names of things that have been captured
so there's there's a little bit of extra
work that has to happen there but you
should you shouldn't have any problem
stepping through them in the debugger
but the fact that said a lot of
debuggers are line oriented if you have
three lambdas on the same line that
could be a problem
so the question is because Matt Matt
filter and a poor lazy and you're not
doing the filtering and mapping until
you get to the reduced step is that
gonna be a problem actually that's not a
problem because what's happening is it's
doing the filtering of the mapping and
the producing all at once it's gonna
call them you know each of them as they
need as long as you have good line
number information you should be able to
set a breakpoint on them the problem is
if you write them all in one line it's
hard to say set a breakpoint on this
lambda expression the IDS are gonna need
a little bit finer control in order to
do that there's no reason why they can't
they just need that finer control okay
question over here
okay so a great question thank you so
the question is alright I understand why
we can't have function types because
function types can flip with eraser but
maybe in some glorious future soon to be
obtained we will get rid of erasure will
we then have an opportunity to have
function types so yes but okay let me
just correct the misconception we're not
gonna have reification in java 9 we are
starting on the research now that may
enable us to have reification sometime
later from now looking at the schedule
there's no way in hell that that's gonna
happen for nyan but the we are working
on it you know I mean we started working
on lambda long before Java 7 shift
language features take more than 2 years
to to make a baked right so we were very
careful to to not foreclose on the
possibility of function types in the
future we concluded that they weren't
right for today in particular because
there was no way to represent them in
the VM and a nun erased way if we can
get rid of that absolutely it could be
it could happen ok last question
yeah so the question is I heard that
there's a library that lets me use
lambda expressions in six and seven so
not from Oracle this is this was a hobby
project someone did very much in the
style of retro Weaver or retro
translator where it goes and mangles the
byte code to instead of used
invokedynamic which is how we implement
lambdas to to generate inter class as
statically as far as I can tell his
thing seems to work it's not a very
difficult you know concept we kind of
anticipated that some runtimes might
want to do that when we were designing
it it's not something that will ever be
supported by Oracle but if that's
something that you want to do have at it
it should work all right thank you very
much everybody</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>