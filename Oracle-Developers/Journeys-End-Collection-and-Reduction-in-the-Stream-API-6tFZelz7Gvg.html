<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Journey’s End: Collection and Reduction in the Stream API | Coder Coacher - Coaching Coders</title><meta content="Journey’s End: Collection and Reduction in the Stream API - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Journey’s End: Collection and Reduction in the Stream API</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/6tFZelz7Gvg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning thank you for coming to to
this talk I'd like to thank the
organizers of Java one fo for a comment
for accommodating me here you will have
noticed I know like as they say in the
on the airline's we know you have a
choice of who to fly with so I know you
have a choice of what Java what lambda
talks to go to this Java one because it
seems like every second talk is about
lambdas so I so I'm going to hope this
one there's different enough to to make
it worth your while to be here what I'm
going to talk about of course as you
know from that from the title is one
particular specialized part of the
stream API can I ask how many people
feel like they're already fairly
familiar with how lambdas work it will
have streams work in particular okay so
it's not that many people write and have
another and of those people how many
people feel like their reason reasonably
comfortable with the collector with the
idea of collection and reduction has
anybody gonna dare to put their hands up
I won't pick on you right now I will
pick on you because there's only one of
you it's just a little fire effect that
worked up so I'm hoping then this this
talk is going to be this tall it's gonna
be quite specialized and I'm not going
to spend very much time talking about
streams in general I'm going to I'm
going to introduce it and I'm gonna
place the situation of collection and
reduction in the overall life cycle of a
stream but I'm not going to talk very
much about streams so I'm hoping the I'm
hoping that if you're not that familiar
with the idea you won't you won't get
too lost I'm happy to take questions
during the talk so if so if you feel
that something you really don't
understand please please be certain to
ask me about it okay so Who am I
everyone always starts off with these
slides but I never know what to put on
them so I put this kind of thing on them
which means my view it's another way of
saying I don't have a real job this
slide actually is the one that I exactly
the same as the one that I used at
JavaOne last year and I've put it on
because I felt nostalgic about it's
about this is this is my main claim to
fame if I have won in the Java world I'm
co-author of what I always like to call
the
book on Java generics and I can say that
with a lot of confidence because of
course it's the only one my current
projects are now something rather now a
rather dusty and neglected lambda FAQ
because I got distracted into into this
project which is a book on which is a
book on lambdas and this slide is
exactly the same as the slide I showed
last year and last year I had to say
well you know I've been showing this
slide already for some time and it was
due for publication on the 8th of April
2014 and it was in the Amazon catalog
already and I was feeling like this is
this is really a bit nervous so this
time I actually I've got something
different to say same side but I've
actually got the book so I got I got
this book first first copy from the
bookshop yesterday the first time I'd
seen it and you can all do that too
needless to say I shall be shall be
mentioning it now and again so that
wasn't what I meant to do how do I do it
how do I get this started again right
not I hope this thing's got too many
buttons on it so so why am i talking
about why am i bothering to talk about
collectors and reduction it's kind of I
mean it really is it really is that kind
of specialized topic streams have a
streams have a beginning a middle and an
end and why am i particularly focused on
the end well we're gonna we're gonna see
about that I mean I got interested in
the in the subject of collectors while I
was while I was writing a book what are
the biggest chapters in the book
certainly one one that took me the most
time was the one was the one on
collectors and what I discovered then
was that I thought I already knew
something about reduction because I have
a bit of a background as a functional
programmer and every functional programs
all know what reduction is but what I
discovered was they actually told me
this but I took me along took a long
time for the message to sink in
they'd actually invented something
relatively new in the form of collection
which is particularly suited to parallel
processing in Java and it's quite it's
quite an interesting idea and I think it
will probably get there probably get
more traction and all it'll actually
appear in there in the world of academic
conferences as well
so I'm going to talk is in three parts
and the first part I'm going to explain
why we want collectors what that's about
and then then there's a part about using
predefined collectors because you'll see
that building a collectors not difficult
but it's not trivial either so you
wouldn't want to do it every day and
actually the library comes with a huge
number of predefined collectors and and
in fact once you've understood the way
the collectors work your biggest job is
in fact to get your head around the
variety are the ones that are offered by
the the ones that that are offered by
the by the libraries there's two at the
front here two seats at the front you
can also you can also write your own and
I shall briefly I shall talk about that
of it I'll be using an example domain I
chose I hope a reasonably simple domain
for the for the examples of the slides
so we've got a so we've got the domain
object is a person and they they live in
a city and they have a name and they
have an age and I don't like talks that
make me and force me to understand too
much that's specific to the talk so I
hope that wasn't too that wasn't too bad
and I made up a list of a list of these
people and that's what that's what we're
going to be using for the for the
examples on the sides okay so question
is then why I collect us what's what's
that what's the big deal about them well
collectors are the journeys n for a
stream the life of a stream element is
it's born as a splitter ater something
I'm not going to talk about at all today
but hey there's another chapter in you
can guess where it's the stream isn't
transformed by intermediate operations
and maybe the values may be changed some
of them may be dropped out new ones can
be introduced the type can be changed or
kind of thing and then eventually it's
collected by a by a terminal operation
and those are what we're going to be
talking about today and only specific
kinds of those I always think this
sounds a bit collection sounds a bit
like a euphemism in the days when when
computers had terminals you know you had
a computer in has a separate terminal
turn I knew someone whose job title was
terminal operations manager he didn't
most like that job title nobody sat next
to him at lunch for some reason
so I I don't know I always feel like
this adds up for more fights these poor
little stream elements they don't live
very long they're born they're
transformed and then they are collected
so so the the diagram the the only
diagram I'm going to show of an entire
stream today is this one is this one
here and now this is this has come quite
peculiar this is mine this is my picture
of a splitter a tur so it just very
roughly conveys the idea that you're
gonna take a whole bunch of data I mean
a good way of thinking about it is an
array or an ArrayList something like
that and gets split up into the for
joint framework I'm not going to talk
about that either and then each one of
the then then each thread and the
thought join pool is given a chunk of
work to do and then and the chunk of
work involves taking all the elements
from that section of the that section of
the data and feeding them through a
pipeline so these things here are
actually the write that the writing on
them has got very small but they're
actually pipeline operations they're
called intermediate operations these are
the intermediate operations and and this
is a picture of this is a very crude
picture of a parallel and a parallel
stream I mean you it's a good picture to
have in your mind and this is this an
important aspect of what I'm going to be
talking about and something you really
need to get used to with streams it's a
good picture to have in your mind even
if you're not using parallel execution
most of the time you won't want to use
parallel execution of streams the the
the idea of lambdas and streams are a
new programming idiom for java and
pushing us in the direction of
functional programming and there are all
kinds of reasons for adopting it besides
getting parallel speed-up so a lot of
the time you actually won't you'll
actually choose not to to go parallel as
we're tending to say nowadays but it's a
good idea to form to form a picture in
your mind of parallel processing because
the the idioms of the stream API are
very firmly based around the idea that
the same code should be usable for
sequential as for parallel processing in
the book I've called this parallel ready
code and the idea is that we should be
writing parallel ready code code
could be executed in parallel if the
conditions accommodated that is if it
was right for the conditions there are
many reasons why you wouldn't want to go
parallel you don't have enough
processors that the intermediate
operations aren't heavy don't don't use
enough processor power there may be
maybe you've got a soft that doesn't
split very well there are many reasons
and most of the time you won't be
interested in doing it it only it you
really need to have quite a lot of up
you need to have quite a lot of data and
you need to be doing quite a lot of
processing on it before it's more
efficient to get parallel but the
difference between sequential and
parallel processing in the in the stream
API is one single call on the street
you're right parallel stream is sort of
stream and that's the only difference it
makes and the rest of the code should be
identical so the idea the idea of
parallel ready code is we'll be writing
code that could be executed in parallel
if the conditions demanded it so that's
that so this is what that's my reason
for saying this is a good picture to
have even if you're not planning to
execute in parallel and the obviously
there's something at the end there which
it's what we're going to be talking
about and that's the and that is the the
terminal operation so we've got the
splitter a so we've got the intermediate
operations and we've got the terminal
operation and that's and that's about
all really that I'm going to be saying
about streams as a whole because I now
want to get on to talking about terminal
operations so terminal operations fall
into three kinds and I'm not even going
to talk about very many of them either
there are search operations there are
operations which work by side effect and
there are and there are reductions and
amusing reductions in a general term
that includes I includes collection as
well
collections sometimes called mutable
reduction and you'll see you'll see wise
as the talk goes on so briefly to look
at search operations they're there
they're made up of all match in any
match which take a predicate and find
any and fine first which just find an
element you notice that the idea of a
find any differentiating didn't find any
and find first indeed between
differentiating when you find any and
find first is not it's not a meaningful
difference if you are processing
sequentially it only makes sense for a
parallel the idea is a difference there
I only make sense for a parallel stream
because what's happening is that the
whole lot of elements are being produced
from the splitter ater they're being
filtered by the intermediate operations
and this is going on in an uncoordinated
way right so different threads are
processing different data and find any
will find and find any just gets one of
them whereas fine first determines that
it's going to get the first one and that
may require the coat that the results of
the the results of the processing of the
different threads to be coordinated with
one another so it's liable to be much
less efficient liable to be much much
more expensive on a parallel stream so
here's a very simple example of using
one of these one of these things I just
put it there because it's horrible just
to list operations and no put any code
in so are all adults here I've taken the
list of people I've pulled it into a
stream I'm certainly not the my list of
people for the code I was developing for
this talk had three had three elements
in it so I certainly wasn't gonna write
parallel stream there and then I and
then I want to check do they all match
this predicate and the predicate takes a
P and test the age to make sure that
it's greater than or equal to 21 have a
question okay so that's a really good
question thank you so the question is if
you have a parallel stream and find any
one thread determines that it's found
that it's found an element will the
other with the will the rest of the
processing on the stream stop and these
operations are called short-circuit
operations for exactly the reason that
it that it will stop there's no product
there's no undertaking that no further
work will be done but in general yeah it
will stop so these operations these
shots so called short-circuit operations
are the ones that make it possible now
to process parallel stream of infinite
streams so we can generate infinite
streams and keep on processing until we
find till we get some condition that
we're satisfied with so that's that
search operations and that's all I'm
going to say about them and now we can
decide affecting operations which are
more interesting in a negative kind of
way because these look like they
actually rather
contravene the the the recommendation
that I did that I just made which we
should write vocoder so it's going to be
executed always as though it's going to
be executed in parallel even if it isn't
necessarily so sometimes you can do
fairly harmless things with with for
each for each is the way that for each
works is it takes over each element that
comes off the stream and it does
something with it use it applies what's
called a consumer which is which in the
the java.util functions library is a
function which takes an object and
returns nothing like system have print
line does for example this is the method
reference to system.out.print line so
what this is going to do is it's going
to deliver each element from the each
element from the stream to the to this
consent to this consumer so it looks
like we could do things like for example
probe
accumulation style processing or the
kind that we really used to in the past
suppose we wanted to add up the ages of
all the people in the in my list then
the way that you would have done that in
the way that you'd do that now is you
would iterate over them so this looks
like a model of iteration in fact so it
looks like you could write in sum equals
zero and then stream the people and then
I have to map them into have to to get
the ages from them so this is this is a
map operation it extracts the age from
each person and then and then what I'm
going to do is I'm for each a I'm going
to increment some by the by that value
by the value of age so that's that
really feels like that translation into
the stream API of the accumulation idiom
yes
well yes it does actually so this won't
work even as it sounds it but you're
absolutely right that it won't work I
could make it I could actually make it
work very easily if some was a field of
the of the class that this is in then
they're not they're not would then that
would work in the you would evade the
effectively final restriction but it
would still be a really bad idea yes I
want that's the reason that's a very
good argument for why it's a really bad
idea because the first thing you would
have to do if you're gonna make it
parallel ready then you can have to
synchronize on they are on the operation
on the operation on some and then if you
did do that it's still a horrible
operation because then if you're running
in parallel every thread that is that is
that it wants to operate on some it's
going to have to get the lock and
therefore the lock is going to get
really hot in fact you're not going to
get any advantage from parallel speed-up
at all doing that so so there really are
all kinds of reasons as to why we
shouldn't calculate total ages like this
and I should have put a big red cross
over it in the next transition but I
didn't I think don't do this so let's
look just a little bit more of that the
question of how the of how that lock
would get so hot using an accumulator
and here what I've done is I've just
translated into the ordinary code that
we were used to seeing I've just set up
an array with a hundred values in it and
I just set each each value to the same
as its index just for the sake of
something to do and now I'm iterating
over them and adding them up and this is
what this is what it looks like as
iteration and if you plot it and if you
look at the execution graph of this it's
going to look something like this so
first of all we're going to get zero and
I'm going to add one to it then we can
add 2 to it then we're going to add 2 3
2 and so on some so you can see this
this hopper at this operation because
it's obviously focused on the on the
variable sum it's going to it's not
really it's just not at all suitable for
multi-threaded execution so if we kind
of so that's how what happens when we
use an accumulator and a huge amount of
the code that we write nowadays it uses
accumulators I mean actually really
virtually all of it it's so this is a
really really common idiom in Java and
I'm sure you've seen lots of keynotes
from
Brian gets and and all the other people
who are involved with lunders and that's
really as Brian isn't it who speaks
about it and he says we got to stop
writing the code in that way and we've
got to start instead using we've got to
start instead avoiding accumulators
transition why okay so avoiding an
accumulator involves using using an
reduce operation so so this is and this
is what I really want to talk about
today so this is the signature of reduce
operations on instream which is the one
that which is the one that we were
looking at a moment ago and the one I'm
really interested in right now is this
one which takes an in binary operator
which is like addition for example this
had just a an operator that takes two
intz and returns an int that's the
that's the definition in Java util
function of an in binary operator and
roots and reducing it returns an
optional in because what if the stream
was empty so you can't be absolutely
certainly you're going to get one so the
the execution graph for this looks it
looks very different I've changed this
now to saying read you want to reduce
over I don't want to reduce a and B I
want to reduce every pair of elements to
the added to this to the sum of those
two elements and now the execution graph
can look like this and there isn't any
single place where we're accumulation
has to rest I mean in practice what's
actually going to happen is that in an
individual thread we'll get some number
of elements possibly hundreds of
elements I mean it's possibly more in
fact at the moment the way that the way
that it works is that the for join pool
will divide up your data structure if
it's suitable for splitting it'll divide
up your data structure into as many
segments as it has threads and it has as
many threads as it has effectively
processors so so in practice you could
be getting a picture like this would
like this one was it going this one you
could be adding a picture like this one
for many hundreds of elements but they
would be operating in parallel
I've got diagrams it should I've got
diagrams that show that more clearly
later on so so in principle the picture
of reduce is like this so it allows
allows any any pair of elements to be to
be to be combined
and I'll finish the sentence and of
course if we are not if threads are
proceeding at different speeds and we
don't know we have no way of no way of
coordinating that happened that they're
there but we could coordinate their
behavior but if coordinating their
behavior means again losing efficiency
we don't actually know that this is
going to be the pattern of execution in
fact the badenov execution could be
different it could look like this maybe
maybe maybe one thread get more would
get more of these elements and so this
is a constraint that we have to place on
the on the they are on the operator
that's the argument for reduced and that
is that those two have to produce the
same result since we don't know which of
the two we're going to get we'd better
we better make sure that we'll settle
for either of them it could be that one
and it could be that one I hate these
things
right you have the question no it's okay
there are there are generic operations
on the seat here there are generic
operations on reference streams but
besides reference streams we've also got
stream streams of primitives so this is
there are streams of Long's intz and
doubles so so this operations going a
bit so reduce is going to be better for
for parallel execution provides it
provided we can make sure that they have
a binary operator that is associative
and we've always going to be very
careful about these operations
associative means that grouping doesn't
matter that a plus B plus C is going to
be the same as a plus B plus C and that
obviously is true for addition and it's
true for lots of other useful operations
and this and this actually is good
enough I've been - I've been talking
about collection how important
collection is but actually reductions
very important I mean functional
programmers have got by on it for a very
long time and they never thought that
they needed anything else
and in fact it's fine for us as well but
it's fine for us with with primitives
and with immutable objects and we got to
see that mutation introduces a different
a different problem so the picture I was
trying I was referring to earlier on
which I didn't make such a great job of
explaining was the fact that even though
you might have a single thread doing
something like this all the same the
idea is that we're going to get multiple
threads that each each of them so we
have different patterns here here's a
thread here's a thread that's actually
behaving as though it was as though it
was really at the execution path for
this thread is like the one for
accumulation the execution path for this
thread is is use users reduce reduce
will work for either of these and for
either of these two execution pictures
so the so these are the so this is two
different threads executing on this I
mean typically it's not going to be
worthwhile doing this unless you have
many more and it's also not going to be
worthwhile doing it really unless you've
got a pretty heavy intermediate workload
because it's here that it's in it's in
making these operations these
intermediate operations are
parallelizing them executing them in
parallel you get the real gain from
going parallel all this stuff at the end
is overhead from that recombining
recombining the parallel streams is
overhead splitting them splitting them
up at the beginning its overhead the the
gain you get is from the is by and large
from the parallelizing they are the
intermediate operations so reduction
works on primitives fine you've seen
that you've seen in the example there
and reduction also works on immutable
values as well so here's the here's what
reduced looks like now come back to your
question I showed you reduce on in
streams before and his reduce on on
reference streams so we've got actually
got four kinds of streams in the in the
API reference streams which is like
Daiya obviously any kind of object and
then for efficiency and and because it
would also gives us some useful
specialized operations like summation we
have specialized streams of intz of
Long's and of doubles so this is what
the
what the reduce operation looks like on
on reference streams and the one that
the one that I'm interested in here is
this one which is obviously just like
the one that we looked at four four four
in sir moment ago it just did instead of
it instead of taking an inbound operator
it takes a binary operator of T and it
returns an optional T just as that
returned an option lint and here's a
piece of code that that uses this I
chose bigdecimal because it's one of the
very few immutable classes in the
platform API there really aren't there
really aren't very many of them and if
you make an array of big decimals you
can add them up by by reducing over the
over the add operation on big decimal
that again that's a that's a short
that's shorthand for a lambda
it's a lambda that says take an A and
and the B and call the add method of a
on B and so so that's that's the
reduction and the same kind of pictures
we had before and that's and that works
absolutely fine
but most of the time what we're
interested in doing in of course in the
enjoy and Java programming is we're not
working with immutable objects and this
is a difference between the way that
reduction works for functional
programmers for all time as it were and
for us because we because Java is a
language which depends on mutability a
lot of the time so option optional here
is the idea of optional is that what we
get back from this operation may be a
big decimal or you may not be because
there may be nothing if the stream was
empty then then then you want to then
you want to allow for the possibility
that there's nothing present so what
about collections can you use this kind
of thing with collections and the answer
to that question actually is you sort of
can what you what you have to do if you
want to do the if you want to use the
the overloaded reduction that we just
looked at because you can see there are
several of them then what then for each
element client if client code creates a
new empty collection and then it takes a
single element this would have to be an
intermediate operation and we take a
single it would take it would take a
single element and it would add that to
the
you empty collection and now it's got
its got a populated collection that it
can deliver into the reduction process
and then the reduce operation would take
to collections and it would add all the
contents of one of them to the other one
alright I haven't written the code up
here you can actually do this I haven't
in the code here because it's really
it's really pretty horrible we'll see an
example of we'll see an example of it
later on because actually I think it's
quite useful to compare reduction with
collection I'm particularly interested
in doing this because maybe it's just my
personal standpoint but I always thought
hey you know like I know about reduction
I did some functional programming once
and I know about reduction so why are
you telling me this new thing I don't
need it and that cost me that cost me
quite a lot of time before it before
people were able to persuade me that was
wrong
Thank You Stuart so so that was the so
you can you can but you can do it in
fact you can use this form the the the
binary form of reduction that I just
showed you you can use that for to
create two combined collections but it's
not very nice so maybe there's maybe
there's another possibility we can do
but we will be able to do better than
that there's another possibility that we
ought to be there we might consider is
an it's a second overload of reduce now
you've actually seen both of the reduce
both of the the you've seen reduce on in
streams and you've seen reduce on
reference streams but I didn't talk I
didn't point out the the second overload
on each one now this one takes an
identity in this in the case of the in
the case of int it will be for addition
the identity will be 0 for
multiplication the identity will be 1
and so on and it reduces and it reduces
over that so here we've got here I'm
doing the same thing I mean
perhaps.perhaps tediously and maybe I
should have been more inventive I'm
adding up all the all the values in this
and the big decimal array but this time
I'm reducing them over over 0 so what
that means is that there will always be
a starting point the instead of instead
of and and the result of that is that
instead of having to return an optional
big decimals I had to in the past I can
are now going to return a and now can
return a big decimal because I know it's
even if the stream is empty the starting
value will be that can be returned is
the ID identity and and this and this
one and this works that fine for
immutable objects this is the picture
now and as you can see this is what this
is we've got we have an identity which
will be used by each of the threads so
I've split the have used the the the
diagram which showed different threads
executing and just copied it over but in
this case each of them is started each
of them is starting with an identity and
you're going to end up what you'd know
that you're going to end up with a value
regardless of regardless of whether the
stream is completely empty so my initial
thought and I want to persuade you this
is a really bad idea was that you might
be able to use this for reducing over
collections but reduction over
collections doesn't work with that
reduction over an identity doesn't work
with collections at all and the reason
is that the reduction reuses that
identity element and it's got it
therefore it's got to be a constant if
one thread has started to stuff values
into a collection and you're using
apparently the same what you think is
the same collection for a starting point
for another thread then they'll get
added twice and so it's a mess and it
just absolutely doesn't work I think a
lot of people made I I don't know I mean
maybe maybe it's just me but I I fell
into this trap really easily I suspect
other people may do as well yeah sorry
you the reduction I'm not sure I
understand the question a skip this set
I'm sorry every thread if you if you if
you'd give it if you get if you supply
an identity and that would that would
include a that would include a
collection if you supply an identity as
the father for the reduction operation
every thread that is that is executing
that reduce will use that collection as
its identity as its so-called identity
it's not really an identity because what
it will be doing is it'll take the value
as it finds it and it will add elements
to it so it could have been added thread
in a thread safe way which you can
currently skip this set would do
certainly it can be added in a in a
thread safe way but it would still have
now something in it that and your and
your thread that was doing the they that
were doing a reduction it's going to
have assumed that it wouldn't have I
mean you had the correction the
correctness of your algorithm the
correctness of reduce will depend on it
having been empty so what we actually
need is to fix that problem and that's
what collection does so we've really got
we've got to do better than that so the
answer so the way that collection fixes
this and it's not really it doesn't look
on the face of it to be a very big
change is it instead of using an
identity element it uses a supplier
function so this actually really does
look quite like one of the overloads on
the on the on the reduce the reduce has
for reference streams it's an overload
which actually does have an accumulator
and a combiner but it's not very much
used for anything reduction on reference
objects really isn't very much used and
this is the reason why it's because what
we really want to do is instead of
having a constant identity element here
what we want is a supplier and every
time
a thread wants to execute some reduction
it starts off it's starting point is not
a constant but it's but it's a function
that it can call that that usually will
supply an empty collection and that's
the key to understanding how how
collection works so then what happens is
that the way the way that the way the
collection works is that a supplier is
called it provides an empty collection
then individual elements can be
accumulated so so I've written a for
accumulator there and typically
accumulation to mutable collections is
much more efficient than than using a
doll a doll is a combination operation
so we so we have a combiner of four
collections which we'll use when we have
two where we've got to combine two big
collections but a lot of the time
individual threads will be doing
accumulation so we need a supplier to
get this to the together to get the
empty collection individual elements can
be added using that using the using the
accumulator function and then finally to
two mutable collections can be added
together using the combiner so that
makes it look as though in order to
write a collector we're going to need to
provide a supplier an accumulator and a
combiner that sounds really hard and it
sounds like that sounds like a lot like
a lot of problems so I was in writing in
writing the book Brian gets was very
very keen to tell me that I shouldn't
tell you to tell my readers what I've
just told you because he's saying that's
gonna make it sound really difficult and
it'll put people off and they won't want
to do it tell them the easy stuff first
but hi I've got you here for two hours
or you're sorry you you have you out
here for two hours so so I thought why
don't why don't I don't explain it the
way I understood it and how I came to
understand that the collectors were
really we're really what we needed but
the good news is that you don't very
often have to write a supplier
accumulator and the combiner and
actually a fourth function as well a
finisher which I haven't even spoken
about yet we don't have to do that
because the because the library comes
with a huge number of predefined
lettuce for us so we don't have to do it
I've said too often I mean maybe maybe
sometimes we do have to enough I shall
show you the end an example of when it
is useful to do it okay so now I'm now
what I'm going to go on to the second
the second part of this of this talk is
about I motivated why we want characters
and now in the second part I'm going to
talk about the collectors API which is
actually really in practice that by far
the biggest part of what you need to
know when you use it collectors you need
to remember what I've just told you and
you need to maybe have in mind a little
bit of what I'm going to say at the end
about writing your own collector but
most of the time Brian is right what
you'll be doing is using the predefined
collectors from the library of from the
collectors API these are these come from
factory methods in the collectors class
and there are a lot of them and to begin
with they're actually really quite
confusing if you don't if you don't get
with her about the the project they
produce they produce standalone
collectors of feed what I've classified
into two different kinds not everybody
agrees and they also also collectors are
designed to be composable so you know a
lot of extra power from from composing
them together so let's have a quick look
at the well let's look first of all at
the predefined standalone standalone
collectors and these are these all these
methods from now on I'm not usually
going to write collectors doc because it
doesn't fit on the slide very easily so
if you see if you see a method and you
don't know where it's come from the
chances are very high it's a it's a
static factory method in the collectors
in the collectors class so so the first
ones are relatively relatively
straightforward to list to map to set
and joining these these in this case the
I've said that the user that provides
the supplier but I don't mean that I
mean that the framework supplies
provides the supplier I've got I've got
these two I've got these two bubbles the
wrong way around so the first ones the
framework provides provides the supplier
and in these you can you can you can
accumulate two custom collections by sub
by providing a supplier of your own
and the third lot our producer
classification map and I'm going to talk
about classification maps and what their
uses so these things are a bit difficult
to understand I think well I found them
a bit difficult to understand start off
with so I'm so I'm relying on on
animations to to demonstrate what they
do the first animation you're going to
think well why do I bother to do that
supposing I want to but you'll see the
the the idea will be idea will come on
here here what I'm doing is I'm just
going to collect all of the elements of
the stream into a set this this is this
is the idiom if you all of these to make
use of a collector you have to call the
collect method on stream and it expects
to get a collector I'll talk about the
type of I will talk about the type of
collectors later on but this is a result
of called this is this a collector that
is the result of calling the two set
method of collectors and so my animation
of this is is it's kind of its kind of
not it and I'm bit embarrassed about it
but they get they get more exciting
later on so here comes a person and this
is the this is the supplier provides the
supplier is actually it's a new hash set
in the current implementation we have no
guarantee of that that's just what's
going to it actually that is just you
all you notice it's an implementation of
set that's what the API says and the and
the accumulation operation ads the ads
ads the an incoming element to to the to
the collector to the accumulator to the
collection that is being being created
and there comes another one and that
goes in as well and here comes a third
one that will come in as well and so on
and then at the end of it what we get is
in an operation which in this case is
identity this affinity can be a
finishing stage applied and what we get
is the output from it is what was
collected and you think that that was
really a bit too simple to talk about in
this the black box is the collect
operation the blue box is the collector
itself that has supplied by the
if this if the stream is infinite then
this then then then for sure this is
not-- this is never going to stop ah
well that's different that's a different
question as a different question here
we're talking about here what we're
talking about is the key is collection
of finite streams we're only talking
about collection of finite streams if
you wanted to if you wanted to arrange
that the stream should say I'm done
that's quite a vexed question in the
stream API because that's actually
surprisingly difficult to do as a
parallel operation and although it's
possible they have an actually it's not
actually implemented you can find ways
around it
yes subito subito it does assume you're
working on a finite stream here ok so
here's that here's the the type of the
the type of the collector this has got a
bit chopped off here this is this is a
collector and the the type of the
collector is parameterized on three
types the type that is coming that is
coming in on the stream the type that is
going to be accumulated in which should
be a set of person here obviously and a
type here which you normally don't have
to worry about but this is the type of
the intermediate or the intermediate
values which the finishing operation may
be applied to in there most of the time
I think in this talk I'm not going to be
talking about finishes at all so all
we'll ever see here is a question mark
but a very occasionally you have to do
it is usually more important for you if
you're writing your own collections to
worry about about that time collector to
repair to worry about that type ok so to
sit that's the way to set works and I'm
not going to insult you by showing you
how to list works because it's obviously
the same kind of thing but maybe
something slightly more interesting is
how to map works so to map it's going to
going to create a it's going to create a
map and it's got to it requires two
functions one of them which is going to
extract a key for the map and one of
them which is going to extract a value
for the map so this is going to create a
map for the for the people that are that
are in this for the personal objects are
in this stream
it's going to create a map from city to
name so this one's slightly more
exciting animation to map there is
obviously shorthand for the for the
collector produced by the factory method
of of collectors to map and here what
here what we see is that we've got dope
with it that the the blue box here is
our collector from person ignoring the
intermediate type here to a map this is
what we're gonna get out of it as a map
from city map from city to string and
this is and the way it works is I guess
kind of obvious certainly I don't know I
don't know whether I'm just gonna
getting used to it being obvious so here
comes bill and the and the the get city
method has applied to him too he lives
in London so that's so that it's going
to be the key element of this that the
key of this map entry and he'll and his
name is his name this actually is billed
surprisingly enough and so so that's
going to be the value element and we
have an association an association
between London bill and the same will be
the same will work for the others so he
come saying me she lives in Athens and
here comes John and he lives in
somewhere else I can't remember Tulsa
right and at the end of that what we get
is is a map from the map some cities are
string and that's what that's what's
output so so that's so that that's
that's a kind of simple way of creating
a map of course you might actually get a
problem with this it's not necessarily
gonna wait and not smooth away maybe the
elements aren't quite cooperative is
this and then and it's possibility that
John actually moves to Athens now if he
does that then obviously we can't have
two and map empties with the same key
that you and so the we've got to decide
what we're going to do in that situation
the default behavior is to call that an
illegal state exception so you'll only
use that you only use this overload this
overload if you're in a situation that
you know you very confident that you're
not going to have incoming elements that
will have the same that will produce the
same result from the key mapper this is
another overload and I'm working through
these because some when you see them
start off without it
well me anything so the difference
between this overload and the last one
they said that there's a merge function
now apply it and that does a kind of
pretty obvious thing I hope that think
it'll probably be fairly obvious now
what's gonna happen so oh yeah did I
jump over that yes so I've got emergent
the merge operation I'm choosing here is
that I'm going to take the two value two
values that are in that are in the
conflicting map entries and I'm going to
innate one of them to the other just for
the sake of just for the sake of the
operation and now things will now things
will go better because what will happen
is that nothing
there'll be no change to its behavior
until that until that clash happens but
now in but now the the merge operation
is going to be applied John's name is
John so now we've got two possible
values for for the value of two possible
strings for the value of Athens and we
apply the merge function between them so
that and I said I said I wanted to
concatenate them that's not what I meant
to say might say a conk at B and you
would get and that's what you get and
that's what would be the that's what be
the output in this case right so that
those are the simple collections that
that that collect to framework supplied
containers what if you want to use
Europe what if you want to use your own
container so you can supply you can
choose factories for the for the for
this for the supplier yeah so I did skip
over to list and I didn't I didn't I
hoped I wasn't going to make her problem
by doing that but obviously I've raised
a question yes that's a number that's
that's actually very interesting that's
a very interesting question so there's a
there's a property that streams have
which have which I'm not going into here
called their their encounter order and
some operations are defined to preserve
encounter order in general preserving
encounter order can be quite expensive
for parallel streams and so if you can
actually avoid having to do that for
example if you're going to put your
elements into
map it doesn't matter whether or not
they're in order then you can explicitly
say this is an unordered stream and you
may get you may get efficiency savings
the the actual collector itself to list
that one doesn t preserve that that one
does preserve order it's defined to do
that though if the stream has knowing if
the stream has no encounter order then
of course that preservation doesn't
count for very much so custom
collections you can you can choose your
own supplier for the for the collection
the the there are two surprise it may be
surprisingly there are only two but the
two that there are actually don't
correspond to the interfaces set and cue
set and list and map and and and in fact
queue there are only two needed because
there's only there are only two
top-level interfaces in the collections
framework and that is collection itself
and map so the so the one for the one
for map expects and again this and again
I've added another I've added another
function onto the previous overload I
said is we're now having a map factory
the all the overloads are designed to
increase linearly the number of the
number of arguments they have so you'll
never find there are no to overloads for
example with three arguments to these
these methods if you want to know if you
want another one then you always have to
if you want to supply map factory you've
got to use the overload that requires a
merge function so here I here everybody
the same as I had before but now I'm now
I'm going to put them into us into a
tree map because I want them to be
because I want them to be sorted and the
not to pain you with the with another
animation the all that happens in this
case is that the the container is
supplied by the supplied by the other
map factory that you provided so the
same kind of idea also goes for for
custom collections as well so for custom
collections as this as against custom
custom maps
so here we the the the the because the
the generic types on this method
signature a little hard to understand
they've written it out in a slightly
peculiar way to collection takes a
supplier of C for the collection factory
where C has to be us to extend a
collection of your output value your Y
so the and what you end up with here is
a collector which takes which takes T's
and return and returns a C so that's
that's the parametric type on this
method an example of how you might do
that would be supposing you wanted to
stream your stream of people get the
names of them and then you wanted to put
them into a you wanted to put them into
a collection which was going to be
ordered a tree a navigable navigable set
ordered on the lexicographic ordering of
the names and this this would have an
effect alright are we okay so far
everything everything good yeah okay
because then because the next the next
set of of collectors are really are
quite interesting and actually a bit a
bit more challenging these these these
are classification maps and the idea of
these is that they're going to allow you
to essentially to classify your elements
according to some properties they have
typically it's a quite often it's part
of the properties is it it's a field of
the method you could classify books by
their topic or in this case we're going
to classify people by the city they live
in
or that kind of thing but they're
actually there's several variations on
this which are interesting to look at so
we and this is where we actually find
how composable look at the collectors
the collectors of the collections api
are so there's there are various over
loads of grouping by as simple grouping
by which I'll show you that's a grouping
bag which is composed with a downstream
collector and this one which is composed
with the downstream collector and the
map factory as well because we're always
going to end up with maps from these
from these grouping by
from these grouping by methods and
partitioning by of course it's that
that's like grouping by except the the
differences it's a convenience method
really all it does is simply choose
between two different categories
classification map will classify you
over over a number of values like all
the say it'll classify all the people by
the cities they live in but a
partitioning by would only classify on a
binary basis is it are these people more
than 21 are they less than or equal to
21 years old that kind of thing so first
of all a simple grouping by is using the
classifier function to make a
classification mapping it's sort of like
to map except the values that are placed
in the map are fixed they're their lists
of the elements that have come in each
one of them and each list corresponds to
a classification key so I said ah we're
going to use person get city to make a
map from city to list a person that's
really this one you can see that
actually to call this is simpler than
calling the map to map because all you
have to do in this case is simply a
supply the classification mapping I just
want I just want to classify these
person elements according to the city
that they live in and the and the
animation for this it looks like this so
here we've got it where the collector is
from person to them to a map that the
output of this collector is going to be
a map from city to the list of person
and each and there's no question now of
the clash between two different values
they're always going to get added onto
onto a list so they're so that here's
the classifier bill and John live in
London and Amy lives in Athens and we're
going to see the kind of thing that I
obviously love to spend a lot of time
doing Bill's end to the bill has now
been placed in a list which so far has
only one element in it because he's the
only person that we've seen so far Amy
lives in Athens and she's going to go
and this this notice this is actually
the person the person object itself
that's been classified in that way and
now comes John and instead of instead of
a clash he gets added to the list and
what we get out at the end is a map from
the from
these classification items to the to the
to the to the list of to the list of the
elements that have been classified by
each and that's this is a maps from city
to mister person so that's kind of you
can see that might be quite useful but
it also seems to be quite restrictive in
the sense that it's only providing one
particular kind of output container what
if you don't want to put them into a
list you maybe you want to put them into
a set well maybe you want to do some
other processing with them so so
actually there's there's a another
overload on the on the grouping by which
adds are what's called a downstream
collector turd so the the description is
really very similar except that except
that when they when the an element has
been classified instead of instead of
being automatically put into a list it
is instead handled by iron your supply
to downstream collector in fact though
in fact the way that the default
grouping PI operates is there is a
downstream collector just a series but
in this case except you don't supply it
yourself
what you get by default if you don't ask
for anything is to list that there or
rather the collector that's returned by
the by the to list method of the of
eclectus class so here if we decided
instead that we wanted to get a that we
wanted to a list of a set of persons
being mapped instead of a list of person
then all we have to do is provide its
provide an extra an extra argument to
the to the grouping by method chooses a
new overload and in this case the
overload is the overloaded chooses is
one which expects to get a downstream
collector and the way that in the way
that that works now is pretty much what
you pretty much what I'd hope you'd be
coming to expect here's the class of
here's the classification stuff going on
and here is the downstream collector and
you'll recognize this downstream
collector because it's a smaller
it's I've squashed it onto the slide but
it's the same as the collector that
produced would you sets in the in the in
the first place in the first thing that
we looked at so it so the it's kind of
obvious what's going to happen now
instead of going into a list these
things are now and now processed by the
down by the downstream container by the
downstream collector sorry and and we
get and then we get instead of it's sort
of a list resulting we get a mapping
from city to to a set of to a set of
person this is an example of the of the
nice composability of the of the
collectors they you can see that you can
fit them together in this way and you
get at it like a chain and a chain of
processing it's sort of unexpected
because what you would what you normally
think of if you'd if you're doing if
you're going to do functional style
processing with with streams is you
expect to get composition of the
intermediate operations that was certain
that I expected anyway I was very
surprised to discover that actually a
lot of the time difficult problems in
bob processing of elements were there's
using the stream API actually implement
it by clever things that are done by
composing by composing different vectors
together and that without that came as a
that came as a bit of a surprise to me
so last of all I think this I think it's
maybe the last one of these of the the
the compositions is a map it is the
mapping method and this is again this is
a factory method of the the of eclectus
class and what this does is it it
composes a something that will pre
process and an element and then send it
on to a dance that send on to a
downstream collector so I think I
alright so I didn't intend to jump over
this I've got a kind of stupid example
here which is what the which is the one
that I
used for the witch is one that I used
for the for the animation so I've left
it in here because they don't have time
to redraw the animation but the example
is not very clever so I put in one that
was a bit more a bit more reasonable in
this case we've got that we're getting a
set of city and what we're doing is
we're we're streaming the people and now
what we're going to do is before we
collect them with what we play before we
use this this collector to collect them
we're going to map each person to the
city they live in
so this is so this is really cut this is
kind of stupid because actually it would
be more sensible I think to in this case
to do the this mapping as an
intermediate operation on the stream
that would make much more sense and
there's but I didn't think of that when
I was doing the animation here's a more
reasonable example in this case you
would use mapping if if what if you
wanted to make the if you if you wanted
to create a collector which was going to
be used as a downstream collector
already before they or as a downstream
collector from a collection that's
already taken place yeah sorry I didn't
I didn't do very well I'm aware that I'm
aware that this that the slides are
really hard to read but I was trying to
think of the same thing that I could do
to make them more readable for the
people at the back so let me explain
what's going on with this example here
what we're doing is where we're going to
do we're going to do grouping by we're
going to get the city for each person
but that but before we do that we're
going to we're going to map a person to
the to their name and the the result
therefore what the what this no sorry
after we do this we're going to classify
the this is a classification function
but instead of instead of forming a map
from city to some kind of you know to a
to a list of person or to a set of
person instead we're going to get the
name from each person and then we're
going to join those together so this is
a way of concatenating all the names of
all the people who live in
and the names of all the people live in
Athens knowledge so and so so what we're
doing here is we were the this is that
this we're working on we're using the
mapping function to change to adapt they
the output from a remote from a grouping
by 2 to get to collect the results that
we have to collect the results we want
from it
so we don't in this case we don't
actually really want they we don't want
the person we want the name of the
person it would be it's kind of easy to
understand this in a different way
supposing supposing you were thinking I
want to do I want to do grouping by is
the only where things so I'm going to
get from from a map from city to person
but now I want to actually extract the
names from the person and do something
with the names now you know an ordinary
stream processing you would use a map
function for that that that would be the
thing but we're not we're not in the
ordinary stream processing any longer
we're now in we're now in with the
collector so what we need is a collector
which will do the same as that ordinary
stream processing map function would do
and that's what that's what the mapping
collected us it composes it composes a
mapping function with the downstream
collector to produce a new collector
which does what would have been done had
you had it like in the case that I just
assumed the case I mentioned here it
would have been sensible in this case to
have extracted the city first before
before submitting the the stream to a
collector in this case because we can't
do that with the output that we have has
already been as already within the
collector so instead what we can do is
create a new collector that's going to
gonna get that effect here's what it
looks like in the in the animation and
actually you'll see that this may
actually show what I'm talking about
more clearly because all that's
happening is that we're getting that
bill is being mapped to London something
that could have been done quite easily
with a map function further up the
stream so it would have been perfectly
reasonable to to have extracted London
from Bill and and then then just called
to set for for though for those
operations but if this was part of a
larger collector which it which is that
which was the way that it was on a
previous slide
then you can see that can't be done
because because the because what you're
getting in here is a stream of person
and that was what was required by the by
the upstream collector so so this is
useful not in the situation that we have
here but what but in an even more
complicated diagram where this is part
of it but this is a downstream part of a
larger collector okay so right so I'm
here's my proposal of what to do i this
talk now oh and let me my proposal what
to do is first of all to talk a little
bit about concurrent collection so all
of the all of the collectors are
guaranteed to work in a safe way in
framework guarantees this even non
threats a container so for example the
the to list method will return a
collector that will organize
accumulation to a note to an ArrayList
without into without interference from
from multiple threads even though even
though ArrayList of course as we know
isn't thread safe the framework
guarantees that the collection will take
place in the thread safe in the thread
safe way and they think this is really
one of the one of the big achievements
of the collectors API that it allows you
to use motor parallel processing and to
accumulate to get the results of it into
a non-threaded container without you
having to manage the the concurrent
thread access to it and this is it's
quite a big deal but of course it comes
at a price and the framework has to
handle that and that's going to be
that's that's obviously there's an
overhead involved so in some cases what
you what you're collecting to is a
container with you yourself know is
already thread safe the framework
doesn't need to do any work to to manage
thread safe access to it so what if your
container is already thread safe for
example if it's a concurrent map
implementation where there's written
that the the framework has to has to do
very little more so
you know for everything that that
accumulates to a map which is all of the
which is the to map methods and the
grouping by methods for every single one
of those overloads there's an there's
there's a corresponding method called
that has concurrent in the name so
there's a two concurrent map for all of
those to the for all of the to map
methods and this grouping by concurrent
for every one of them for every one of
the grouping by methods it assumes that
this assumes that the container itself
well-well manages and will manage the
multi thread access and and these things
will sometimes be more worth sometimes
being more efficient than than for
parallel prefer parallel execution but
sometimes be more efficient than relying
on the framework to do it the sometimes
won't as well I discovered this in the
performance experiments that I didn't
write in the book there are situations
in which actually you're worse off
choosing choosing a concurrent map
because in some cases actually adding to
the concurrent map implementations can
be more expensive and at then and in
performance terms I'll talk about this
briefly at the end but in performance
terms it all it almost always works out
as being the the biggest gain that you
get is when there is a sufficient
workload in the intermediate operations
to really justify parallelizing them
that's where the big gain is right so
it's going to talk about my plan before
I brought slide came up and I am going
to talk about I plan now so I've been
talking for an hour and I may I should
have mentioned this at the start but my
view is that it's really quite difficult
to concentrate for for much more than an
hour so and since the second half of the
talk it's about writing your own factors
and also what I'm gonna do is I'm going
to work through some examples of of
using the the things that we've talked
about in there in the first half because
there's a lot to take in there and I
think some worked examples are really
quite useful to do that with with you
collectively then I think some of that
stuff may stick more so that's my
proposal for the second half but I think
probably what we should do is take a bit
of a break first because I know that
it's not very much fun to listen to
somebody non-stop for two hours
so let's take a five-minute break and
then come back and do some do some
examples and I'll look at the what's
involved in writing your own clap tech
okay sorry about ice so how do I do that
oh I see save as right I understand
right okay save as default one right and
now I can now I found I did actually
find the font earlier by doing a search
on font but it wouldn't let me change it
now I understand why would it would that
help right and that is under view isn't
it okay all right okay and the
presentation was that better
ah alright okay it was better right okay
that's cool sorry right so I thought we
would I thought we would look at some
some little problems and maybe some
maybe some bigger ones and I'm gonna I'm
gonna ask you to do them because I find
that actually works that works pretty
well I'm not very well prepared I'm not
as well prepared so I would like to be
with a set of problems so maybe you'll
have to think of the problems as well as
the as well as the solutions and we'll
do this for about well do this I managed
to use up quite a lot of times we'll do
it for about 20 minutes and then last of
all I'm going to go on and when we've
done some problems I'm going to finish
off by talking about what is required to
to write your own collector and the
circumstances under which you would want
to do that so so some problems though
start off with some simple ones here's a
list of people supposing we want to get
to make it to get a collection of I
don't know the the set of their ages how
about that set of people's ages yeah
the stream method of arrays that creates
a stream directly yeah using the array
as its off yeah no no no no it no it
doesn't do that that would be that would
really be an unnecessary piece of
self-punishment I think a matter of
masochism so yeah I mean if you if you
have an array turn it directly into a
stream if you wanted to do a stream
processing okay so each one of these
things is going to start off by saying
well we're going to stream the we're
going to stream the people and I'm
hoping this is going to people dot
stream sorry don't know why it's
objecting to that just a person I do
yeah yeah I do
I do do so there's is there any obvious
reason as to why that would be let me
come out of presentation mode and just
check if I can do how do you how do I
come out of presentation mode somebody
sent me into presentation mode then I
got a exit presentation mode right okay
so I have no idea why why why this is
why that's not working people don't
stream all right sorry so I so people
that's bad people don't stream here
copied the code from there it looks
alright am I gonna have to use this
class looks like it people
mr. person you know it's it's really too
embarrassing to even think about
demonstrations I just I always make a
resolution after I've done the
demonstration I'm just not gonna do
demonstrations anymore they just work so
badly for me okay thank you thank you
for that so why is this visa it needs to
be static okay so they do all right well
just to save time that's what he'll do
because otherwise we'll be here forever
and we won't even get any problems done
at all that would be really irritating
yeah numbered right okay can we actually
write some stream code okay so this is
this is sort of trivial right what are
we gonna do with this business it's just
to start with
well I actually I've set a problem here
but I mean we'll do that in the moment
yeah part it will partition them in a
moment let's let's do the problem I said
I said that's it let's get a set of
people's ages no our right husband I'll
do that yeah okay maybe that will help
maybe that will help
right we are going to we're gonna we're
gonna want this is what I've been
talking about we're going to want to
collect it aren't we
I can write to set bun a set of instead
of instead of interviewer thank you
thank you thank you thank you well thank
you okay so in that case what are we
going to need to what are we going to
need to do to these people in order to
get there we can we're going to have
we're going to have to map them aren't
we what what the mapping folks should be
so this is what this is taking us away
from collection from collectors I'm
going to have to map them to in well
yeah but yeah that well sort of work but
what we'll get out of that actually so
here's here's a kind of useful thing if
I say person dot get age that actually
is a person : gauge that's going to
produce some problems because because
the age field of a person is actually
not an integer and what we're looking
for here is a reference stream so that's
actually not going to quite work so I
guess that I guess are there are
different possibilities if I'm going to
if I'm going to make them into a set of
integer though if that's what I'm aiming
for in the end I will have to box them
at some point I may as well box them
early on rather than rather than later
so one possibility would be to get to
get the page but I really want that
should be peed up your age but I
actually really want to I want these I
want these things to be I don't want
them to be primitives and the and the
age field of the person is an INT i
could i could just box it with a with
new integer
and I should make Matt I was hoping that
would make my red line go away but if
it's not made my red line go away
because now it's fine
so I cyclic inference we don't worry
about that okay so now we've got a set
up now we now have a set of well set of
integers sorry a little stream of
integers so sorry we're going to call to
set aren't we wait that's not right
there isn't a to set method on stream
this was useful to do actually I was
thinking apples maybe maybe insulting
you
we're gonna have we're gonna have to
call the collect method on stream right
okay another I think it should be Oconee
yeah well I'll I'll cheat right I wonder
if that will work
and how do you how do I may have
compiled it how do I am I better I
should I should check that I'm get
actually getting then we shouldn't tell
you so I'm gonna so I'm compiling that
now how do I could run it from the
keyboard maybe I've no idea I've never
used demonstration mode with fathers's
sorry all right
okay let's try it run demo code main see
what happens
not very much all right
okay a31 important yeah actually that's
worth it oh it's a surprise
do you know you know it's lovely for a
speaker to get applause but I have to
tell you that is the least desirable
round of applause I've ever had
okay let's try something else
let's let's see whether we I mean that
was actually quite useful because not
everybody knew the answer to it
which sort of surprised me so let's
classify people by their age yeah okay
the syntax of that is I mean I I am
cheating because I because I like to
make things look right nice but actually
what I should have written for this
collectors yeah there's a study there's
a static import there that's that's how
that's working so that's that that's the
that's the whole story right so let's
classify people by age and see whether
to see whether this can go a little bit
more smoothly it can't get less smoothly
right so I'll give you a start map from
integer to person of fun
yes probably well it should be yeah yeah
it should be a bad we could make it a
list we can make it a set what would you
like you'd like the list set hmmm list
okay list a person right and so we'll
have you tell map so we'll make that I
can't think of a sensible name for it
and we'll say we'll say people dot
stream and then it's up to you second we
certainly are going to need to do some
grouping by that's for sure
all right so I'll say grouping by I'll
need a dart okay but that's not all I
need I'll need the Clayton method as
well that was was happy for that rather
than being a bit more important grouping
by okay I've looked after my
housekeeping now you look after the rest
we're going to classify these people by
age so what's going to be the key to
this age right okay wonder is this gonna
would it work to just try
pun rants try it person colon colon get
age this is if you're not used to this
this is the method reference way of
writing lambdas but essentially
essentially it's just a lambda okay and
what's it expecting now it's expecting
so one of the that one of the things
that is really noticeable about about
working with streams is that you get
this really twofold effect of using of
using generics one of them is generic
types are actually really really really
really helpful because there's a huge
amount of of explicit typing information
we're not having to put in here because
the compiler writers have done a pretty
good job of
implementing pretty sophisticated type
inference and a lot of the time they can
work out what what what types
what types we need so this sort of thing
which really could require you would
expect to require an awful lot more
explicit typing doesn't so that's the
that's the upside the downside is you
sometimes have to understand this isn't
so hard to understand what is sometimes
really bit difficult to understand this
when you get compiled errors and when it
says that and it shows you - - really
complicated generic types and says this
one isn't it's incompatible with this
one and then you sometimes really have
to scratch your head so it's a little
bit like other api's that we're aware of
where a lot is done for you but when it
goes wrong it can be quite hard work so
in this case what we're looking for is a
what we're looking for is the is a click
from it's just one of those days I guess
really it's one of those days so let's
get on let's get that back
we're looking for a collector from from
a person we don't care about this one
this is the this is the type that we for
the the intermediate thing that we are
not usually using us as users of
collectors and we're going to we're
going to turn it into a list of person
so the default grouping by it is indeed
the is indeed to list so I could write
to list here and it would actually have
exactly the same effect as if I just
took the comma out and and that will do
I hope extra bracket Emily yep okay so
let's I think we managed to use a lot
more time for this one way or another
than I expected so I think we've
probably only got time for oh no we got
time for a couple more it's not too bad
right so so I'm running math and let's
hope that we will actually get back what
we wanted sorry oh I do indeed
yeah right let's think of another
problem all right what is it map well
it's running we'll think of another
problem so here's something that we
could work on you know I told you that
the mapping is like dual to the to the
map function of the on streams a lot of
the collectors actually have a very
similar role so there there are four
instances there's a collector for
counting which corresponds to the sum I
suppose I suppose that's not quite the
same thing these are the the the
collectors I'm thinking of now are four
reductions they're duals of reduction
rather than gills of of intermediate
operations okay so we've got this we've
got our map I think here so 33 maps to
put maps to bill and also to Eric and
they're both of them 33 and if I
I guess if I if I if I go further on all
cants across that other way
yeah okay in 21 maps - it maps to Amy
and 42 maps to John so that seems that
seems to have worked right so I'm
thinking another problem sorting based
on the length of the city okay
ask thank you sort based on name of city
how would you like to how would you like
them to be yeah length of city name yeah
and how that's that's a good one and how
would you like to get them back
how would you have to pun a list okay
list of and these to be people or yeah
okay list of person yeah well this
obviously is as I said one of them one
of those days well I would need would be
kind of catastrophic breakdown in the
machine at this point to just complete
my complete my day mister person sorted
by city name list list list name length
okay let's go
let me start sorry this is actually this
is actually a good question it's not
based on me length or City knows how
we're gonna do this what do you think
yeah that's yeah we needed we needed
yeah okay
yeah so but there's a sorted method on
there is a sorted method on streams and
it will take a comparator oops
there's a there's a new static method on
the comparator class so a factory method
it'll it'll create a new create a
comparator for you from the comparators
so is it comparators stop comparing yes
it is no it's comparator class that's
the one comparators up comparing so what
this does is it will it will take the
it'll take it it'll take a field you
supply it with or a rather function that
works on an object and it and what and
what it gets back it will use as look as
the as the P that the objects to be
compared on so in this case suppose you
wanted to compare people by their names
you call comparator dot comparing on get
name in this case obviously we don't
want to it's not it's not get name that
we want to use
so that's P arrow P dot get city that's
City so if it's City is an enum you know
a name docked
is it is it yeah okay thank you yes it's
his name dot length that was too easy
I thought was gonna be harder it's still
complaining though because it because
because we still got it because we still
have a stream right okay so so I'm just
going to collect that into a list it's
something more interesting we could do
with that just such an important method
okay right so that's worked that wasn't
I wasn't all that all that I'd hoped for
sorted nice is your name leave well we
run that how about how about pushing the
boat out if we've got time what about
the most yeah a comma-separated list of
names grouped by city okay we can do
that yeah
it's got to the the key that it gives
you that he gets back has to have a
natural order that's the expectation
there is only one natural order so I
mean so that's going to have to be it I
think we I think we've probably got
these on the yeah we've got Tulsa before
Athens before London so that's worked so
what was sorry I had forgot reduce a
comma-separated list of names yeah you
need to know something with I haven't
told you about this actually to do this
there's a nice way of doing this so this
is a map from city to listen to string
yeah I'll just do that equals people dot
stream so so what how we going to how
him start on this we can tap we get
we're gonna we're gonna have to group I
start off with so we've got grouping by
and person Wow actually I'm you shout
out what I should write here sorry
person thank you person : call and get
city otherwise I ended up writing it on
that's not interesting right now what
what we do now
we do we want to give it a downstream
collector that does the strange iron
that actually uses something that this
is this is nice because it uses
something I was talking about earlier on
we need to get the strings out of those
out of those persons before we join them
how can we do that
what with mapping yeah with mapping does
that mapping will take out will extract
us will extract a field from the person
that remember that what we're doing now
is we're map City onto onto person but
we want to do something to the person
now before we do any further processing
and what we want to do to the person is
we want to get their get the city out of
it so it so it's mapping so and what I'm
what should I write as the argument of
mapping person : : get name right and
now for the last bit now the last bit
you don't know how to do but I'm but
I've cheated and I do know how to do it
the way that the way to do to do it is
to use the joining method which is which
is provided for you by the by the
collectors API so this is another method
on there's another factory method from
from the clip from the collectors class
and one of the things that we'll do it's
quite intelligent so one of the things
it'll do it will take a separator for
the for the streams between captivating
together so I'm afraid I just have to do
that bit for you it's pretty neat okay
and that I think should you should give
us what we want
joining always works and only works with
strings yeah absolutely
oh yeah I've got yeah
you have got you've got a downstream
there already well no there isn't a
default no Denis we're not using a
downstream collector this collector here
is the downstream to that one and this
collector is the downstream to that one
so we've actually up three clips as
nested within one another and this is
why people find the collectors API quite
hard to understand to start off with but
when you see it actually in action it
kind of makes sense I think so let's see
if we can make this run uh-huh okay
let's see whether we can make this wrong
maybe this'll work
who knows yeah okay
did it work yes it did work no you're
not Bill and Eric I I guess people that
probably can't see but it did work no
more sardonic rounds of applause thank
you no more rounds of applause at all in
this session thank you okay how are we
doing for time I think I probably need
to go back to the slides
I need to go back to the slides it's fun
to do this actually and I've actually
really quite enjoyed I'm sorry that so
many things have managed to go wrong on
this occasion because it's a I think you
really learn quite a lot there's a
hands-on lab for lambdas yeah I mean I
really I really strongly strongly
recommend that you learn a lot in that
very quickly yeah all right okay
the output okay yeah would that be like
yeah I just saw you don't you something
yeah it's not that a run how about that
yep okay
yeah sorry the could that comma the
comma there is a comma
like it's the comma like that one yeah
it's not it's not it's not it's not a
comment that's miss stuck on the end I'm
pleased to say okay um so let's have a
try and get back on track this is where
it was that was that much more to say in
fact okay well I said we've looked at
mappers not was there was a nice example
that last one I have to say yeah yeah
this one here the the method second
argument of the mapping is the
downstream and notice it's something
that I maybe didn't give enough
attention to was that was that the
output from the from from the mapping is
a stream so we're actually collecting
into another stream and in this way you
see that the the the the we really are
talking about composition that it's a
new car it's not function composition
but it's collector composition they
really do fit together very well and the
thing that joins them together extremes
alright so it's kind of it's kind of
nice I talked about in current
collection right so writing your own
okay so here's the question why would
why would you want to write why would
you want to write your own collector and
the answer to that is there's two kinds
of there's two reasons why you might
want to write your collector and then
maybe there may well be more as well
there's two that I think there's two
that I could think of immediately and
one of them was that you want to collect
to an accumulator that doesn't implement
collection and then maybe well there may
well be occasions where this where you
wanting to accumulate some kind of more
complex thing and I've got an example
like that in the book and you met you
might want to share state between values
being collected and that's the example
I'm going to talk about here and there
may well be others too but these were
these are the tubers immediately
occurred to me and then maybe you don't
think they're they're very likely to
happen and I hope you and I hope they
aren't because actually although it's
not very difficult
it's is I mean it's gonna hold you up
from getting on with the day
I guess so so the problem I'm thinking
about here is Oprah's problem I call it
Oprah's problem because she's chosen
these 10 books I was looking for
graphics of books on me on the web and
she's and these are the 10 best books
she's chosen over the last 10 years and
her problem is that she can't find a
book out of her collection it was just
you know there's too many of them
and so she needs an algorithm for doing
it and the algorithm that that I've gone
to whether we're going to provide her
with is one which by which she can know
calculate using the thickness of a page
how far from the left-hand end of her
shelf she should look in order to be
able to find the book she wants it makes
sense to her so what she needs is as a
mapping from the name of the book from
from each book to the cumulative
displacement and of the of the books in
the in the shelf and this isn't normally
a problem you think you're going to it
you're going to achieve using functional
programming it doesn't feel like a
functional programming problem I mean
the interesting thing about it is it
does feel like you've got to do
accumulation I mean this is it everybody
will immediately see an idea attempt
into their mind about how to do this you
take the first book you keep a running
cat than the second one son you keep a
running count or the total number of
pages that there are and that's that's
what you're going to provide Oprah with
in order to be able to find each book
the three hundred and three hundred and
thirty six pages on the Shelf before you
get to the start of the Poisonwood Bible
because that's how many pages there are
in New Earth so is that that kind of
feels like that doesn't feel like the
problem it's going to be particularly
easy to to solve using a functional
style in fact it's in fact the solving a
problem like this I think I think is
always to do with finding the right
intermediate data structure that's going
to that's going to express the the
problem and it's going to contain a
partial solution to the problem and you
can see how you can combine it how you
can combine the partial solutions to get
a complete solution and in the case in
the case of the
case of Oprah's problem what what we're
looking for really is a it's a data
structure like this one here which
contains not only the not only the name
of the book and the name of the book was
far too big to fit in there but the
number of pages that it's got and and
its displacement from the start so each
book is now going to be wrapped in a in
the data in the data structure that's
that can that contains its information
and then these data structures can be
put into a sequential data structure not
a map unfortunately not a map but into a
sequential data structure and we can see
for what to join two of these things
together we can see an obvious algorithm
how we're going to do that into this we
clearly what you do is you just add the
you just add the cumulative displacement
of the previous one onto the cumulative
displacement of the of the next one and
and and the and its own count as well so
that's once you've seen that it's not
it's not a very difficult problem it
still means that you've got to actually
implement it so we need to get we're
going to need to have an accumulator
that will take a book and and we'll wrap
it up in some kind of and of a value
object that's going to contain all the
information it's going to be needed to
calculate the final result so there's an
accumulator here and that's going to
take a that's going to take whatever
this container is and and the book and
it's going to add a book to a container
so we hit so here's an it is an example
of his better example of doing it we
take you here we already have a
container with a book in it and now
we're going to add another one by the
way it's not easy to find books with
short enough titles to fit on the
diagram so if you if you get the book
here you'll discover that I actually
managed to by extensive research to find
a book with three authors and the total
number of letters in their surnames out
of those three authors were six two
letters each so you're writing
authorship is not an easy job you have a
lot of research to do so so so here's an
accumulator function the accumulator
function is kind of obvious really
I've been careful not to say what this
sequential data structure is because
when we when we look at what the
what the combiner is going to look like
then you see that that's actually that
it's not necessarily the using an
ArrayList isn't necessarily that this is
kind of the first and obvious choice
let's start from the bottom from what we
wanted from what we want to achieve
eventually we're going to have to turn
this back into a map but this is but
this is this this was the is the
objective of the of the first stage so
to get to this we will have had two
smaller two two partial solutions and
it's kind of obvious that the way in
which you combine them now it's going to
be by by taking the the total
displacement at the end here and I've
got a diagram of it later on but for
some reason they didn't get into this
this one adding the adding the total
displacement here to plus the length of
the last element and adding those to the
total displacement of the of the first
element and actually of every element of
the of the the second half right so what
I've done here is I've taken 776 and
I've added that to this and I've also
added it to this as well all right and
then and then working backwards oh and I
did have it on here
after all that 976 and I added it to
that and I'm gonna have to add it to
this and to all of the other elements of
that and in this way I can you can see
that having started that there so having
started at the top with with these
things generating generating first of
all a container that has only a single
one in and then combining those into
into repeated ones and gradually I'm
going to eventually get the solution
that I need right at the bottom and
that's the and that is the solution to
Oprah's problem which for which the code
is in is in the book of course it was
quite it was it was an interesting
exercise actually the accumulator and
the combiner are not very long when
you've done this I mean once you've seen
it it's really pretty easy it's finding
that it's finding the way to do it so I
said if there's a challenge problem in
the books and now you know the solution
the book will be of greater value of
greater value to you here is I think
I'll have to press on and take a
question at the end just for comparison
here is the way in which you would do
this if you wanted to
you use the the reduction solution I had
at the beginning so I my idea there was
that instead of using collection and
this clever thing which actually
produces a rather nice result what you
could do instead is you could use that
to argument form of reduction if you
were really stuck on reduction because
you've been a functional programmer and
you don't understand why we have to have
these newfangled things so what you
would have to do is for each you you can
you can achieve these things in the same
way but to get into here the combiner is
going to be the same but to get from the
you get from the book into the inter
subject you're going to have to the map
stage this is a map stage and this is a
reduced stage where you're going to have
to first of all you'll have to create a
new partial result which is that
container I should let you I should let
you in to end the suspense
I used a deck a double-ended queue
instead of an ArrayList because he would
because we're adding stuff onto the end
here a lot and it's a nice data
structure so I've got I've got to create
a new partial result a new one of these
things and then I've got to create a new
array deck and stick that in and I've
got to do this for every element that's
how that's what reduction makes me do so
I'm gonna have to do that for each one
of these it's really quite ugly and it
puts a lot more work on to the client
and it's quite inefficient so it's so
really with collection they've actually
invented something that's going to be
very useful to us you can see if you see
the difference in terms of the amount of
work that's in politic compared to
simply supplying the the accumulator and
the combiner and you can see it all the
more when you realize you don't actually
have to do this very often when you when
you see how neatly those collectors
neatly those predefined collectors
fitted together you can see that we've
got something really good there okay
quick word about performance the the how
well the collective works will depend of
course on the performance of the
accumulation and the combiner functions
the I don't really know to be honest I
didn't do very much research on anything
other than to map and the grouping by
things so I my pretty strong impression
certainly the other ones that the ones I
looked at was to list and to set are
liable to be
are gonna be generally pretty good but
for small numbers of threads the
performance will be dominated by the
accumulator the the only the biggest
problem typically in in in everyday real
everyday problems you can have very very
many fewer threads than you are animal
data numbers items in the data set so
many more accumulation operations are
going to be performed than combined
operations but therefore the performance
of the accumulator operation is going to
dominate and typically that's going to
blast that's actually going to be good
enough for the for these collectors to
give you good turnout you always will be
interested in knowing first of all what
the how heavy the workload is on the
intermediate operations because it's
that that more than anything else
controls whether or not it's worth is
worth going parallel in terms in terms
of in terms of just straightforward
performance the biggest problem with
these with with these things is that
you're going to is potentially for a
larger number of threads that you're
going to have to pay for the multi
thread access to ensure you have the
concurrency to ensure the thread safety
for the concurrent combination for these
non thread safe collections so the
thread safe ones is there's a very
surprising result I found it very
surprising somewhat so first of all map
merging is very slow for the I cheated
and telling you about oprah's problem
there because I didn't tell you about
the last stage which turned that deck
into a into a map which is the voice is
what she needed not to be able to look
at books up there was just a
straightforward it's just a
straightforward call of to map very very
easy to write but fantastically as it
turns out really a problem in
performance so map merging is slow and
and perhaps surprisingly map merging is
even slower at least for java.util
concurrent map than it is for latest for
Java util hashmap I guess maybe actually
it's not so I guess it's not so
surprising so you really want to take
into account if you're doing large-scale
if you're doing a large large scale bulk
processing you really need to try if you
can do to avoid doing map merges but
here's the thing if you do
have to do map mergers it's really
important to make sure you can precise
all your data structures and that's
generally going to be the case actually
for any large for any large collections
because the big the overhead are forcing
the the system to be doing the pre
sizing is twofold first of all it takes
a lot of time and secondly it's going to
create a lot of garbage so you really
want to avoid that so I'm going to have
to go straight to the summary because
there's only only a moment left then
I'll take questions so so that that's
that's my take on on performance to
finish off collectors generalization of
reduction you can always express a
reduction as a collector but not
necessarily the other way around they
allow a functional style this is a big
deal is they allow a functional style or
continuing to work with a language
that's based on mutation and they allow
you to and they allow you to use
concurrent collection to non threadsafe
containers this is a big deal they're
designed for composition and you've seen
how that worked actually in spite of the
fluffed demos I think you got the idea
of that so over overall a flexible and
powerful programming tool and they take
a bit of getting used to but everything
is going to take a bit of getting used
to so so that's that's the story with
collectors thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>