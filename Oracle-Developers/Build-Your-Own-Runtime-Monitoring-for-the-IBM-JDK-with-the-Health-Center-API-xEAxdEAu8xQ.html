<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Build Your Own Runtime Monitoring for the IBM JDK with the Health Center API | Coder Coacher - Coaching Coders</title><meta content="Build Your Own Runtime Monitoring for the IBM JDK with the Health Center API - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Build Your Own Runtime Monitoring for the IBM JDK with the Health Center API</b></h2><h5 class="post__date">2015-06-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/xEAxdEAu8xQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">what this presentation is about is the
IBM JDK has got a lightweight high
performance monitoring tool called
health center and we've been developing
that improving it over the last three
years or so and what we've done recently
is basically take the tool itself and
remove the UI and provide access to the
same data that it uses to anybody that
wants to do anything with it so it's the
data feed that we get out of the JVM in
order to create the health center tool
exposed to anybody to write their own
tools or you know if you're a tools
venden you work for app dynamics or
something like that you can embed our
data into what you do if you just want
to write an alert that says i want to
watch cpu usage and if it goes over
eighty percent i want you to do
something you can write a small
command-line tool effectively that does
that so what we're going to do is we're
going to go through the capabilities of
health center itself because there's all
the capabilities you get access to and
then we're going to actually show how to
write some code to the API and a demo of
a small utility that actually does
something with the API yes this is IBM
JVM only so it's only j9 okay as
everybody here been to an IBM session so
far at javaone no man that means you
have to read this every single word and
sign a bit of paper and give it to me
because otherwise it can't speak Harry
I'm talking you've got to confirm that
you know I'm going to lie to you except
it's all the story but yeah so me I work
for the eigen job development team have
been doing for 13 years in hers Lee in
the UK my original background is working
in the support team so I started off
helping users of all of the IBM software
stack or just IBM Java on AIX with maybe
tom cat or jboss or something helping
them fix their problems and we went from
that to trying to build in automation
and tooling to make it
for first us to fix those problems so
IBM is fixing problems for our customers
and then how we can make that available
so that people can do it themselves so
that we enable our customers to monitor
and fix problems in the application
without needing to come to IBM so we're
getting kind of selfish in that we'd
rather not you know have to spend our
own time fixing problems if you can do
it for us or you can do it for
yourselves the statistics actually show
that something like ninety-five percent
of problem records raised with IBM end
up being not related to an IBM defect
they're more related to problems in the
application so by making it easier to
visualize and diagnose what's going on
in the application it makes it easier
for you to fix your own problems so
that's my background that's where I came
from and basically lots of the stuff
that we've got here has evolved to help
us solve problems so the goals of the
talk we've actually got more than just
health centers so I'll quickly cover
some of the other tools in case you're
not aware of what they are and you
haven't seen them but then we're going
to help you understand what capabilities
are in health center so I'm going to go
through some screenshots of what you've
got and then we'll demo health center
itself the screenshots kind of their 21
make sure I cover everything into in
case the demo goes horribly wrong then
what we're going to do is talk about how
you can basically build your own health
center if you want to or build things
that do stuff with that same data feed
so I've got some live code examples in
slides I've got a demo and I've got some
stuff in eclipse that will go through
and then we'll actually show you that
IBM's products are using that API
themselves so we're not making an API
available that's not tried and tested
we've got real products that have been
released that use that API so the IBM
tools for Java basically we've got this
collection of tools which are branded
the IBM monitoring and diagnostic tools
for Java IBM is supposedly famous for
three letter and acronyms right that's
actually moved on a bit now we're much
better at four five and six letter and
acronyms one guy did want to call it the
IBM
mad tools for Java you know getting that
through later an acronym and it sounds
kind of cool but no IBM's bit old and
stuffy for that so it's the IBM
monitoring and diagnostic tools each
other but we've got four tools the first
is garbage collection of memory
visualizer so that's pretty much a tool
that does what it says right you take
garbage collection data or memory data
and it will visualize it for you so it
takes for both DC output into it from
any platform so it's any IBM platform
any hotspot platform it will take the
data it will load it in and it'll graph
it for you and you will let you do
statistical analysis window ever period
of time overlay multiple graphs on top
of each other etc and it does the same
thing for native or process memory so if
you've got output from PS or something
like that your graph PS memory for you
as well so that's do CMV we've then got
memory analyzer it's the IBM edition of
the Eclipse memory analyzer tool and
what that does is it will take an H prof
dumped from Solaris or HP so from
hotspot it will take a system dump if
you're running the IBM jbm so by system
dump I mean on Linux that's a corphal it
comes out if a crash occurs but you can
generate them non-destructively you can
generate a core dump on your application
carries and running so we can load that
into memory analyzer so we don't create
our own dump format trying to you know
pause the JVM write the dump and then
let it carry on we just let the OS
handle that for us so we do transaction
dumps on the mainframe we do mini dumps
on Windows and so on we've got another
dump analysis tool which is called ID de
memory analyzer is much more aimed at
the Java level so your java code java
objects and so on ID de is much more
aimed at the native level so it knows
about real sea based structures as well
as the java stuff on top so it's a it's
a bit more of an advanced complicated
tool but it gives you access to two far
more data and then we've got health
center which is what i'm going to spend
most of the time on each of these
tools visualizes the data but it also
does an attempt to analysis and
recommendations so lots of them do
statistical analysis of the data and
then use that statistical analysis with
a number of rules to try and give you a
recommendation if we think that there's
a configuration problem or there's a
tuning option you should put in place or
in some cases it just highlights bad
bits of data so if you have very long
poles in your application it may not
know why but it will tell you it's here
go and look at it in more detail and all
of these is available in a tool that IBM
provides called the IBM support system
and it's kind of like a tool box
container that you've install tools into
so if you download the IBM support
assistant then all of those tools are
available inside it so the first one GCM
v so as I said what you do is you take
the bose DC output or sv mall on AIX PS
on Linux the performance monitor tool on
Windows you can take the output from all
of those load it into it and the simple
thing it will do instantly is just graph
the data you have the option of graphing
a bit of data that's in that you want so
for garbage collection you can get it to
graph the amount of memory used over
time or the size of the Java heap or
when garbage collection occurred and how
long it took in those kinds of things
you can windows into particular bits of
time so zoom into it usual you I kind of
stuff but it also does a whole bunch of
statistical analysis and if you window
over the graph it changes the window of
time the statistical analysis is done
over so if you want to know the GC
overhead the amount of time spent in
garbage collection versus spending your
time running your application that
occurred between one and two in the
morning you can window over one and two
in the morning and it will change the
analysis and it will apply the
recommendations to that period of time
as well and in terms of recommendations
it will do things like say you know your
heap occupancy is ninety percent your
heap size needs to be bigger and based
on your data we recommend it's around
this size
secondly memory analyzer so this as I
said takes a system dump or an H prof
dump loads it into memory and visualizes
the entire java application so it's got
every single object that's been
allocated if you've done new hashmap it
knows about that hash map if you then
put a key value pair into that hash map
so your key is say string my key and the
value is my value then it will show you
there's a hashmap that there's a string
object inside it with my key and there's
another string and object inside it with
my value and this is actually quite
interesting to look at the state of an
application at a given point in time you
can go into your cash and you can look
at every single key value pair inside it
you can see the session IDs for people
connected to your application server and
so on and we've actually written a bunch
of extensions so there's an extension
API we've written extensions that knows
about the structure of things like the
websphere application server so we can
find every single session very easily at
the press of a button because we know
what we're looking for we know the names
of the objects we know which child
objects inside them contain the data so
we can give you a report that says
you're running Webster application 855
fixed pac-12 you are running on a linux
intel x86 machine with this hostname you
started the application at this time you
have seven web applications loaded you
have five live sessions against web
application my app right we've got all
of that date date and we can give you a
report of all of that based on loading a
system dump into memory putting it into
memory analyze and say give me an
overview of website please yes
so the question is are they production
ready and there's a two-part answer to
that first is they're fully supported
and you may use them in production
there's no licence fee charged so you
can use them for whatever you like then
the second part is what's the overhead
of collecting the data to use the tool
now for juicy MV that's verbose GC the
overhead of a boast GC is basically
nothing for memory analyzer the overhead
is generating the H prof dump all the
system dump and I won't lie to you that
takes time and it pauses your
application when you do it so if you
take a system dump its and your Java
heap size is one-and-a-half gigabytes
it's going to take about 10 seconds to
write that so your application will
pause for 10 seconds whilst it writes it
all to disk that's the same for H
profound for system dump so you know
whether you're using hotspot or IBM
you've got to pay that cost but you do
then have a complete image of everything
that's going on inside and inside your
application inside memory yes
okay so the question is when you're
generating some form of heap dump using
a Kilmister you're not getting variable
values so what so is this IBM or hot
spot okay so if it's IBM we've got to
dump formats and we've got the system
dump format which has everything and we
also have what we call the heap dump
format which is a neat he bumped up PhD
and that's a very cut down
representation and that doesn't contain
any of the data inside it and there's
two reasons we did that one it's smaller
right when you get a system dump its
initial size is the size of memory so if
you've got a one gig Java heap it's
going to be about 1.2 gigabytes in size
it compresses then down to bang you know
100 Meg but it starts off big so that's
one reason it's smaller but the other
reason is if you're a financial customer
or a government customer and you can't
ship that data to IBM then you want a
format that has no data in it what we've
done in recent releases is we've moved
over to system dump certainly on active
memory so if you're going to using it
yourself we basically say get the system
dump because it's got all of the data in
it and in fact we now have tools that
will let you take the system dump and
generate the strip down to eat dump from
the system dump so yeah we would
recommend there's some simple option
changes you can make to generate the
system dump instead so the question is
how do you do that so it's a minus X
dump command line option to switch if
you send me an email i'll send you the
options that's probably the easiest way
ok so that's memory analyzer as I said
we've got extension api's we use them
ourselves and you can use them to write
your own extensions to it see so you can
have knowledge of your own application
in your own code built into memory
analyzer iud de interactive diagnostic
data Explorer so this is the low-level
memory analyzer tells you about your
java application this knows a banked
lower level structures as well so it
actually knows a bank java java objects
and so on but it knows about the JVM so
if you
wanted to actually go into our class
cash it knows about the structure of the
class cash and you can go into it it
knows about the structure of the
interpreter the just-in-time compiler so
it basically NEC structure that we've
got from the JVM it knows about and
actually knows about some os-level
structures as well so it's one of those
things where it's probably not that
useful to you because it's two lower
level but we see no reason why you
shouldn't have it so it's there it's
available you can use it and again it's
got an estate extension API we use that
API ourselves and you can use it if you
wanted to write your own analysis
extensions for it okay and finally
health center so those last three tools
a kind of offline you get the data and
then you blowed it into the tool when
you look at the data afterwards health
center is much more designed to be used
for online live monitoring right that
there is an offline mode you can write
the data to file and in fact it
automatically writes some data to file
if you can figure it that way so if
there's a failure or just snap it to
file but really it's designed to be used
to start up so well designed to be used
for a live running application now you
add minus X health center on the command
line and that's it it starts the
monitoring you can also start the
monitoring live at runtime you just need
to get on to the command line do Java
minus jar health center jar and then
give it the process ID of the process
you want to start doing health center
monitoring and it will load health
center in and it will start generating
and start collecting the data so you can
have it basically turned off and at any
point in time say i want to start now
collecting data and it collects data
about a huge number of things and we'll
go through those in a bit more detail
but these are my slide versions in case
the demo fails you've got environment
reporting so this will tell you things
like which machine you're on what
version of java you're using what
version of health center you're using
what your IP address is what your
command line was what your system
properties are what you're in
vironment variables are and so on so
it's it's a full description of the
application that's running in the
environment that it's in we do class
loading so will tell you every single
class that was loaded when it was loaded
and whether it's in the share class cash
or not we do fire why oh so we tell you
every single file you opened when you
closed it if it's still open and what
the name of the file is and where it is
on the file system we do garbage
collection so we'll live graph garbage
collection for you in terms of memory
usage heap size Paul's times and so on
it does the statistical analysis and we
also do profiling of Java object
allocation so when in the code someone's
doing new object we sample based
collects information about those objects
and who's allocating them so we can
actually say you're generating you know
eighty percent of the data that you're
generating is an array is an array of
bytes and here's the stack traces which
are allocating those array of bytes we
do native memory so your overall process
address space usage both in terms of the
total amount of memory that the Java
process is using and the breakdown as to
which bits of the Java processor using
what so we can tell you how much memory
direct byte buffers are using how much
memory the Java heap is using how much
time is being how much memories being
used for the just-in-time compiler for
compiled code and so on so it's a full
breakdown of the memory space we give
you a list of the threads that are
running the state of the threads their
stack traces along with whether they're
currently contended to blocking on a
synchronized look so all of that's in
there we give you method profiling so we
watch every single method that's running
in the system and we tell you which
methods are taking the most cpu time and
we've got the cool stacks between
methods so we can say that method a
calls method be thirty percent of the
time calls methods see forty percent of
the time and calls method d thirty
percent of the time so you can see the
relationship between methods and how
code flows on the system we do profiling
of Java looks so synchronized blocks we
will tell you how often it's contended
so one thread
rise to take the lock but it's already
owned what the average hold time is for
the lock and so on and finally we've got
the abilities some limited control of
the application so if you want to get
that heap dump or system dump it run
time it gives you a button to press to
go and get it now obviously you may not
want to allow people to do that so we do
have authentication and encryption on
the connection to health center that can
be turned on if you want to so you can
say you know someone can't just connect
to my application they have to know the
username the password have the ssl
certificate and so on so now i'll try
and do a demo and we'll see how this
goes so the first thing I'm going to do
is who here is familiar with websphere
liberty ok so websphere liberty is it
well that's off the earth question who's
aware of the full websphere application
server ok so Liberty is basically a
lightweight version of the website
application server it can run in 60 mex
worth of memory running a benchmark so
it's much much smaller it's much faster
to start up we were demoing it this week
at the IBM booth running on a Raspberry
Pi attached to a remote control car and
it was a remote control web server so
anyone that's near it connect to it via
Wi-Fi so it's a very very small
application server so if I start trade
light what trade light is is it's a
standard benchmark that we run on top of
Liberty so that's starting up liberty
and the benchmark liberties up so it
only takes like three seconds to start
old websphere takes yeah minutes so now
that's up and running I should be able
to start health center
and when I started the the liberty
application server I didn't give health
center any particular settings i just
said minus x health center which means
it's set up to be connected over a
network on port 1972 so when i open
health center it gives me a connection
wizard and i'm going to say i want to
connect to my local host on port 1972 i
can use mbean authentication ssl
encryption so on so it starts to scan
for things it starts on 1972 i'll
actually scan through a number of ports
if you've got a number of java processes
it will list all the ones it could
connect to and i can connect so this
should now start to take the data over
the the local loop connection from the
running application server and it gives
me a whole load of data so if i start
with the environment inside the
environment I've got a tab for
configuration it gives me the boot
classpath it gives me the classpath it
gives me my java command line it gives
me the parameters down here it gives me
my version information it gives me the
name of the machine the OS etc on the
right hand side it gives me a list of
all of the system properties that is set
and it gives me a list of all of the
environment variables so if you've ever
been trying to set an option through the
admin console through the command line
you'd not really sure whether it's
actually been picked up by the server
this is the easy way of finding out
because anything that's set through a
command line option environment variable
or a system property will show up here
and in the bottom right hand corner we
do an analysis of what you've set to see
if there's anything that we don't think
is right so if you have set options
which don't apply to the IBM JDK it will
tell you that you've got an incorrect
option there if you're using options
which are considered to be deprecated
then will warn you you've got a
deprecated option in place and so on
next classes so this is
timeline of every class that's been
loaded by the application and when it
was loaded so we've got the full list
whether it's in the share class cash or
not and the time it was loaded up we
have cpu information so this is showing
me the cpu usage of the process of the
java process and the overall machine and
in order to get that to do something i'm
just going to open jmeter and apply some
load to the system and hopefully that's
going to work and i'm not going to get a
bunch of errors because i've forgotten
to set up trade like problem if it looks
to be okay and if this is right we'll
start to see cpu usage coming through on
the system so if i now look at garbage
collection here's my timeline of garbage
collection i started the demo about
three and a half minutes ago and i can
look at summary data so in garbage
collection of memory visualizer that
tool which loads in for HTC it did
statistical analysis and had some
analysis and recommendations so that's
exactly the same here this is the test
it statistical analysis this is the
analysis and recommendations so that's
all there for you now one of the things
I'm going to do is I'm going to turn on
the ability to get cool stacks for some
sampled object allocations so when
you're allocating objects we saw and
pull that regardless to find out what
types of objects you're allocating you
can optionally say get the stack trace
as well and there is an additional
performance overhead to getting the
stack traces but it's not actually
significant and you can also change the
depth of the stack that you want to
generate to how many frames by default
is 5 the more frames the bigger the
overhead but again it's not significant
so if i increase that to maybe eight
that means from that point onwards it's
now going to start getting the step the
stack traces when you allocate objects
now hopefully that means when i start
going through my samples i can first
we'll see samples by object tells me
that 22.6 percent of the types of
objects I'm allocating our SQL
characters in the org Apache database so
that so that's the org Apache Derby
database so the Derby database that's an
embedded part of the application server
that's being used for this simple
example is where most of our object
allocations are being done and we sample
by request site as well so this is the
method that's calling it but I can also
go down to call hierarchy so I can look
at any part of this and get the full
stack trace if what's causing those
objects to be allocated so I now know
which code is allocating the objects and
again in the same way that I said from
method profiling you can find out
whether the method a calls method be
more times than method see you've got
the same kind of you for object
allocations so it's more often that the
object allocation came from this
particular school stack them than this
one okay if I move on to i/o iOS are our
file so this is the number of files that
are open and what these files are so
includes things like the jar files that
have been loaded for the application
we've got that information we've got
information about the just-in-time
compiler what methods were compiled when
they were compiled and we've got
information about whether they're in the
size and legit compiled cash what time
of day they got compiling zones it's
just information about the just-in-time
compiler we have our locking so this is
our full list of every single
synchronized block in the system and
some information about how many times
that lock was taken in this case we've
got a stored page look which has been
taken 23 and a half thousand times and
we've got the average time that look is
held for once the locks been taken so
between that we then paint the bars from
green to red according to how much of a
problem we think it is if you see a red
bar you should go and look at it and
because we think it's a problem in terms
of native memory so this is the memory
usage of your application and the oval
ram usage of the machine and I said that
we have the ability to break
how much the JVM is using and we can do
that by expanding down here so we've got
a tree view that says the just-in-time
compiler is using 17.6 megabytes of
which 14 is used for the JIT code cache
and eight is used for the data cache and
the grass and the top right-hand corner
shows us how that's changed over time
and I can do the same thing for bits of
the class libraries so I can see how
much is being for you I classes that'll
be nothing right because there's no UI
but I've got the breakdown of what all
the memories being used for I've got a
profiling view so this tells me we're
all that the CPU time is being spent and
most of our CPU times being spent in get
character array and I've got a cool
timeline of when it was called and I've
got a breakdown of which methods calls
that method and when that methods called
what it calls so it doesn't actually
call anything else so it's a it's like a
leaf method in a tree but I know who is
calling it and I can see that there are
two methods that call get character
array string compare which calls it
seventy-seven percent of the time and
SQL char like which is responsible for
twenty two percent of the calls so we
know it's most likely to getting cooled
by string compare and you can continue
to expand out the tree and finally we've
got a threads view which shows every
single thread running in the system and
if you select one of them you can again
get the stack trace as to what that was
at that given point in time now the last
thing you can do is apply a window and
if I apply a window to given point in
time it windows the data to that point
in time and does so for every for every
window that you look at so if I select
just a small window of time there then
I've got the same small window of time
between three minutes and 6 seconds and
three minutes and seven seconds on all
of the views and I can then choose to
reset the cropping to go back to a fool
of you so that means if you've got a
performance problem at midnight you can
window over midnight and click through
all the views to see what was happening
in each case
now it's fair to say there's probably
better ways of visualizing that which is
one of the reasons why we make the API
available right people who know how to
do visualization should be given access
to do the visualization of the data
people who know how to do smart
correlation of data much smarter than me
as a JDM guy can do we give them access
to let them do that so that's Health
Center in a brief overview of what's
that so if I shut that down stop the
load test and kill off Liberty go back
to the slides hopefully okay yep so
what's the overhead of it so we run
benchmarks for health center internally
and the benchmark that we run is we run
websphere application server that's the
full website application server not
liberty running websphere 855 on IBM
java 7 sr5 that's the latest version of
IBM java 7 we happen to test it on AIX
7.1 on power it's the hardware we had
available and we wanted to run the test
couple of weeks ago now the test that we
run is called day trader it's a standard
benchmark that IBM makes available and
we do a lot of work with for the website
application server and we ran that with
50 clients now what that does is it
fully saturates all four cpus available
to it so basically we run it at one
hundred percent utilization so the idea
being that when we put some tooling in
place we see how the throughput is
affected we don't get away with the fact
that the spare cpu that we're using its
how is the throughput affected in its
worst case scenario so the application
through put our baseline when we've got
nothing in place is obviously a hundred
percent so the first thing that we did
was we did dorman level equals off so
health center is loaded but it's not
doing anything
when it's in that situation you can
connect the client to it and say start
generating data so when we ran with
level equals off so dorman doing nothing
performance went up by one point seven
six percent so it got faster and there
is actually a good reason for this so
when you run health center we put the
data in an internal memory buffer and
that's our flight recorder and you know
hotspot has the same concept so we have
a flight recorder that we put data into
now for legacy reasons we put a lot of
JVM trace points into that flight
recorder and they're only really of use
by JVM development for fixing problems
in house so the first thing we do when
we know we're going to you're going to
use health centers we say well let's
stop looking at the JVM stuff because
we're going to be looking at an
application so we turn those off so we
save 1.76 percent by turning them off
effectively next if we run with an over
the network connection so that's the
client you I i was running just with
their our performance went up by point
four percent so basically zero cost and
this actually turns on a whole load of
the JVM trace points as well so just by
readjusting what goes into that flight
recorder when you're running with health
center you actually run very slightly
faster than you would if you weren't
running health center if what you do is
you choose rather than to stream over
the network to write it to local file
the performance cost of that is just
under one percent and again this is when
we're running fully saturated saturated
so it's the biggest overhead that we can
we can get it to measure so one percent
if you're writing to file and we also
provide an option that says when you're
writing to file periodically zip it to
compress it and the zip activity is
actually pretty expensive right it
zipping is a fairly CPU intensive
operation so because of that and the
fact that we're running at one hundred
percent CPU means that we've got a three
percent
head when you're zipping if you ran on a
machine with spare cpu then it offloads
it to a separate thread and you don't
have that problem so the worst-case
scenario is if you write to file and
continually zip it the overhead is three
percent if you stream it over the
network it's basically zero and if you
just write it to file and don't zip it's
one percent so we're really talking 12
percent either way so we're talking very
very small amounts of overhead in order
to get all of the data so how do we do
that well the way that we do that is by
basically making available data that
we've already got most of the things
that we make available via health center
is data the JVM is generating any way in
order to do adaptive tuning of itself so
an example of this is garbage collection
right when you turn on for both GC all
of the bits of data in verbose GC we
collect anyway because for example the
the Java heap is going to expand when
you're utilizations too high so in order
to do that you need to know what its
current sizes and what the utilization
is after GC it runs its own heuristics
to say actually you should expand if
you're spending too much time in GC
shrink if you're not spending that much
time in DC so all of those numbers are
being used internally in order to self
tune so all that happens is we take
those numbers we already have and we
then make them available to you to graph
them and it's the same with the method
profiling all of that information about
where the CPU time is being spent and
what method calls what method is what
the just-in-time compiler uses to work
out which methods to compile when to
compile them and how to compile them so
our just-in-time compiler make smart
decisions right it says you usually call
this method not that one so we have to
fast pass this method and treat the
other one as an exception exception not
is in terms of Java exception in terms
of the rare case so because we
continually keep that information again
all we're doing is making it available
to be used to visualize what the flow
through the application is so again it's
stuff we already have
so the reason the overhead is so slow is
with it we're allowing you to visualize
data we've already got internally so
okay the monitoring API how do you get
to access that data so as I said health
center gets that data directly out at
the runtime and we put it into the
health center client so we've got this
eclipse-based you I that visualizes the
data now i cant of implied that we're
not really good at doing you eyes and
creating tools isn't really what we're
good at we're JVM guys would get it
making dates are available very fast so
basically what we want to do is make
that available in the same way that
memory analyzers got an extension API
and I d-des got an extension API health
center well we thought should get an
extension API and we did actually you
can put your own plugins into health
center but we then thought actually
people would rather access the data and
do if you want to look at the combined
CPU usage of seven deployments that you
put together you can do that right we're
not doing that but you can do that so we
make the holder set of data available to
you we're basically ripped off the
health center UI and giving you access
to the API now you can use the API in
three modes one of them is remote over a
network that's generally how the health
center client works you can do it local
you can run the API in the process that
you're monitoring we don't really
recommend you do that for two reasons
one at the moment it still reaches out
over the socket right we haven't fast
past it yet and to all of that cost of
passing the data and doing the analysis
happens in your process so your
overheads no longer going to be minus
point four percent it's going to be like
five ten percent whatever it costs you
to do the analysis so we don't really
recommend that but it's an option and
it's an option people like for
development because then you only have
one process that's running in order to
do this and you can do offline so the
JVM writes the file to the file system
or keeps it in memory and then snaps it
when you shut down and then you can load
it in from an HDD fun so as I said the
performs costs exactly the same as
running the full health center tool
unless you run it in local
mode in which case you pay for it now
there's a three-step process for getting
the data the first is you want to you
need to get yourself a health center
object from a factory right so it's a
factory request get a health center
object back from the health center
object there's a provider object which
is the type of data so there's a GC
provider there's a CPU provider and so
on and then from inside there you just
do a request to get the data now the
first thing to say is I kind of called
this the monitoring API or the remote
monitoring API and you look at the
package and it's calm IBM Java
Diagnostics health center that may well
go away at some point right we will
support this it's a fully supported API
but it's also the first release and we
really only had one use case when we
created it which is our own client so
really what we want people to do is use
the API and tell us what's wrong with it
and what it needs to do and we've
already got products inside IBM telling
us that we need to extend the API with
different functions so it's it is
growing over time in terms of capability
news ability but the API is there today
and it will be supported and IBM does
support on a basis of basically the
lifetime of the gel of a release and we
support java releases for something like
11 years at the moment so it's going to
be around for some time so what you need
in order to to to start with the API is
you have a health center connection
factory so a health center factory that
gets you your health center object and
you just do health center factory doc
connect and in this case we're passing
it a file so this says take this health
center HTM HDD loaded in and give me
back a health center API object now that
will block until it's loaded the entire
file it so it returns back once it's got
all of the data ok now you can do a
connection over a network as I said and
in order to do that the new thing is
that you have a connection properties
object that you need to create
if you give it a empty constructor it
will assume that you want to connect to
the local host on port 1972 once you've
done that you literally just cool health
center factory connect and pass through
the properties so that's the only
difference rather than a file it's a
properties and the properties if
creative when an empty constructor will
assume its local host point 1972 right
so maybe I want to connect to a
particular remote machine so you just
specify a remote machine IP address or
hostname and the port number and you do
that in the health center properties so
at that point rather than using an empty
constructor you've set the host naman
the port so describe the target and off
you go now I said you could do
authentication through jmx so the way
you do that is in your properties you
also call set jmx username set gmx
password that has to match what's set
for the server and then you can connect
without that you can't and again we do
we also do ssl so you have to set up
your trust or location password
certificate password if there is one but
that will do an ssl connection to to
health center okay so that sets up the
connection so next what we've done in
the demo is we're basically taking a
simple jfreechart and we're going to
graph the GC data so we're doing exactly
what you get in the view you just doing
it standalone on your own with the API
so what we do is we say from our health
center API I want to get the GC data
object so you get a GC data object and
you call get pauls time data and that
gives you all of the available paul's
time bet data back so two simple calls
gives us a data set if I wanted to get
java hit usage rather than saying get
pauls time data i can say get used heat
data if i didn't want to get the current
used heap i wanted to get the heap size
I can call get heap size data and that
your data set with the each size data
and so on so it's a very very simple API
if accessing the data at the moment
again same for CPU get cpu data get
process use or get cpu data get system
use for the overall machine usage okay
and finally graphing it so as I said
this uses jfreechart so I create a panel
that extends jframe once I've got a
panel that extends jframe I create an XY
series of data because what comes back
in your data is time value right it's
simple XY point and I load that into the
chart factory to get my jfreechart plot
and I add it to the content pane and
therefore display it so I'm just putting
a jfreechart with an XY set of
coordinates into a panel and when I want
to update it I'm pretty much doing the
same thing as next y series i copy my
data over and i remove the old data and
add the new data so let's see what this
looks like
so again i'm going to start liberty and
i'm going to take my code and launch the
api version so I've got my panel for GC
pauses now if i go to jamie to and apply
some load i've got a whole bunch of data
that's coming out now you'll notice the
numbers start at minus-7 and that's
because i decided to set my clock from
the point that i connected and the point
that i connected was seven seconds after
my application started so it pulls the
history over the wire so that's our in
memory buffer that's been filling up
when you connect it's got access to your
historical data so that was what maybe
30 40 lines worth of code which allows
me to to get my own tools doing live
views of garbage collection data yes
so the question is is there a
performance penalty to the server if the
client crashes and the answer is no
because the clients pulling the data so
if the court client doesn't request in
and grab the data then you know the the
server's not doing anything okay so the
fact that you can do this so easily
means that if I now wanted to say what I
want to do a second connection to a
second processing compare the two
verbose GCS I can do that if I if I was
in a virtualized environment for example
now VMware I've been doing a lot of work
to try and do cooperative memory usage
between two processes this would give me
a way of sitting in the middle and
saying well I know how hard this process
is working and I know the one on the
other the other vm is doing no work so i
can safely move cpe if someone wants to
write tool that does that they've now
got a way of doing it I as a JVM vendor
I'm not going to get funding from my
management lines do something like that
but someone who is going to get value
out of it will be able to so we're
providing a platform for anyone to write
their tools and we're doing that because
in all honesty our view is that
monitoring and diagnostics should be a
free part of the platform right we do
JVMs and when you look at monitoring
data the monitoring data really should
be at the level of the application that
you're running so where I've got that
view of all of the methods that are
running in the system that's great if
you're a developer but if you're running
the Webster application server don't you
really want to know how much CPU time is
my ejb using and does my ejb cool this
jdbc cool so you want it to be
abstracted up levels and that means that
rather than us at the bottom trying to
pull everything into our tool so that we
know about every single IBM product it's
we should just give our data to the
products so they can visualize it at
their level because they know what the
use cases and it's their customers
they're trying to surface the data to
so if I get in stop that shut down town
center go back to this mind so finally I
said that we're using that API inside
IBM so that that's growing over time but
one example I did want to show you was
rational application developer version 9
so this went live in February March time
maybe they certainly had a beta and at
the beginning of the year and its Gigi
aid in the first half of the year so
it's a ga product that uses the health
center API and the bit of it that they
were interested in was the method
profiling because it's a developer tool
designed to deploy applications on on to
the local machine if it's Java on to an
application server or whatever and
because they were developer tool people
want to know how the codes flowing so
they decided there was an interest in
having that data so what they do inside
Webster inside rational application
developer is when you choose to deploy
your application you can say i want to
set some profiling settings and there
you give the option of saying i want to
set health center is my profiling
setting i want to say that my
application is running quite slowly
that's the type of analysis i want to do
i want to use sample-based profiling
rather than trace base profiling because
i don't want to cripple the performance
of what's deployed and then you get this
view so they've chosen to use of you
that's very very similar to what's in
health center for the moment right now
that they've got this they can start
expanding on it and changing it and
doing interesting things based on
customer requirements to begin where
they chose to take the model that was
already working for us but now that
they've implemented themselves it's
their code they can choose to change it
however make sense for them okay so the
summary is that we've got a few tools in
particular health center is very very
low overhead and we get lots of data and
we want to help people do useful
things with that data so they can make
their applications run faster Manas of
them and understand what they're doing
and that's why we've made the API
available and it's available to
everybody else in the same way it's
available to the IBM corporation for
their own tools and they are starting to
use it but you know if you've got Stan
dling applications you can use it if
you're running tomcat IBM's not going to
run right monitoring tooling for tomcat
and if it beats and you know own benefit
but you might want to so we make the API
available and let people do what they
want with it and again it's fully
supported so if you've got support for
the JVM you get support for the API it
comes with it same with all of the tools
if you've got a supported IBM product
you can use the tool with you get
support for the tools and finally that's
the URL for the article we have on all
the sessions that the IBM team have done
this week and there's a link of that
article that get lets you get access to
all of the slides that we presented and
Java one usually makes the slides
available but they can take some time to
do it so we put them up on to SlideShare
these slides should be arriving on
SlideShare hopefully tomorrow it may be
next week I'm not sure yet any questions
yes
so the question is what's the minimum
requirements for the API so health
center itself works for JVMs from Java
five so Java five java 6 Java 7 are Java
8 beta all supports it as long as you've
got a version that's from about the last
three years and the newer the JVM you're
using the more data you get so there's
more data as you go through like fix
packs inside java 6 inside java 7 and
java 7 gives you more than java 6 so as
we put new features into the JVM we get
the data feed for that and yeah what the
API works against is whatever we can
collect data from so as long as you're
using Java 5 or onwards from bank three
years ago or onwards it works any other
questions ok I will finally say that at
the front we have Steve pool Steve he's
an IBM Oh works on openjdk we have Matt
he's an IBM ax he works on support and
we have pool at the back he's an IBM ax
he works on test so if you've got any
questions about any aspect of what we do
and mainly in terms of Java then come
and grab us afterwards thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>