<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Shaping the Future of Java, Faster | Coder Coacher - Coaching Coders</title><meta content="Shaping the Future of Java, Faster - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Shaping the Future of Java, Faster</b></h2><h5 class="post__date">2018-04-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/YZvFjhbPM1A" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good afternoon my name is Roger Riggs I
work for Oracle in the java products
group and today we're going to talk
about the updates have been made to the
release cycle of the java platform and
some innovations in the changes in the
way that open JDK development produces
releases we have a caution about using
statements here and for future planning
it said this is just don't do it so last
fall looking at the past set of releases
of the of Oracle's open JDK and Oracle's
jdk products a bunch of review came
suggested that we should make some
changes to improve the timeliness of
releases so today we're going to talk
about the the new release model and then
overview of what's in Java 9 which is
now quite quite old almost a year that's
in Java 10 which was just released in
March and a few edition HIDs heads-up on
what's in Java Levin so you probably all
know that Java has been around for 22
years and the community has been based
on had a very good support and community
based on communication collaboration
with quite a number of Java champions
and contributors to the to the open JDK
as well as continued support from
initially Sun Microsystems in and more
recently Oracle picked up that that
Charter and so there's been quite a bit
of growth and the Java continues to be
sort of the number one programming
language 12 million developers 38
billion active machines and 21 billion
connected virtual machines I'm not sure
where the numbers came from but if
they're really anywhere close to that
it's pretty impressive we're trying to
make sure that the open JDK development
continues to be open evolving nimble
that we're able to move faster and that
it's scalable both in terms of
developers who contribute to open JDK
and in that the the platforms that are
reachable with with to the Java runtimes
so the thing we're gonna talk about
today is where we came with Java 9 the
big advancements in there which is part
of what caused us to reevaluate the
release model and open JDK and then the
this the release cadence a few more
information about the the pervasiveness
of the job on the runtime it competes
favorably with the other platforms and
is used widely as I said nothing new
there in terms of Oracle's investment in
open JDK got a bunch of priorities
security is is number one we still have
periodic flares up of problems with
security that are getting addressed on
the right on a daily basis there's a lot
of new initiatives in terms of projects
in open JDK to in to improve developer
productivity and compatibility and
scalability project amber is focused
sort of on the language side of things
in terms of new syntax like local
variable type inference which we'll talk
a little bit more project Pama Phnom
Penh Panama will deal with war two is
trying to give better native integration
loom is is targeted at scalability of
threads and processing things project
Valhalla is a very aggressive attempt to
increase the density of information that
you can put in memory essentially in the
heap trying to use it more efficiently
less pointers and more more information
in the same memory and then their
ongoing projects related to the head of
time compiler and the application class
data sharing CVS on the garbage
collector side there's still quite a bit
of activity both from Oracle and from
some of our partners in developing and
improving garbage collectors and then on
the serviceability and maintainability
size and monitoring side the work on JFR
and the Java
JMC continue and we'll talk a bit more
about that before a later part of the
new release model is to go from
what used to be a very a two-year
release cycle where every two years
there'd be a major release of Java and
the planning going into that was you
know developed figuring out what
features should be in a release and sort
of deliberately trying to get them out
on that on that scale the practicalities
of getting smaller bug fixes and
releases out meant that there had to be
there were actually minor releases that
were every six months that included bug
fixes and you know small enhancements
that didn't change the compatibility
profile or or the spec of things and
compatibility was a major goal part of
what got reevaluated in all this was the
the nomenclature of how do you talk
about releases the reality for jdk nine
was that it took three years not to
because of the major changes that came
along with the jigsaw in the java module
system so that helped spur thinking
about well or we do we have the right
release model and the proposal was to
switch to much finer grain releases
every six months where new smaller new
features could get out very quickly
because they don't take time they don't
really backed up between behind other
work longer features have to have a bit
more planning they can be developed in
parallel and you know when they're ready
they can get released the nomenclature
for releases was initially thought about
like well we'll keep using the the dot
notation for releases but after a bunch
of discussion and sort of comparison
with other release cycles it seemed like
the more sequential numbering made more
sense for open JDK releases so we're
back to nine ten eleven twelve we'll see
where we are in twenty thirty or we're
still working on Java then but the other
thing is is that the support model for a
six-month release where if you've
previously Oracle would support the
releases for ten or fifteen years
because that's what the industry
required and that's not gonna be
vertical really workable if you have a
release every six months so like other
big big operating systems like a bun -
it seemed that using a long-term release
cycle
that happens every three years with
long-term support would give some
customers the stability they needed and
give Oracle the ability to support that
though that those particular releases
for that long so the model that were in
that we have been working on probably
for the last six months is this one
where we have frequently releases with
small features and big features as
they're ready and then long-term
releases every three years that are
supported for at least eight years I'm
not going to quote the exact numbers
comparing this with previous release
cycles including JDK six seven and eight
on the timeline here you can see JDK six
is actually being you know well very
soon now Oracle is not going to support
or do more new releases JDK sevens out
till the middle of nineteen twenty or
twenty twenty two and jk8 till 2025 but
then by then we should have completed
the shift over to the later releases and
JDK 11 will have the next long-term
support release so open JDK has one set
of release numbering which are
sequential numbers Oracle JDK Oracle
prefers a year and month numbering so
there are two sets of version numbers
that'll apply to different releases but
JDK 11 will be the same as 18.9 and the
nine is because it's in August so just
to sort of reinforce the distinction
between the licensing models that go
with what are now three licensing models
the original binary code license of BCL
that applies to JDK six seven and eight
and then the new licensing model for the
Oracle JDK the long-term releases is the
distributed through the Oracle Tekel the
technology network and then the one of
the new changes that's really sought
after by a lot of people are open JDK
binary releases with a gplv2 classpath
license
so we were in the middle of shifting to
this to this model and and planning
cycles this is all sort of rolled out
last last September and themes who have
gotten pretty good feedback from some
various people about producing Oh peachy
OpenJDK binary builds licensing and
letter under GPL v2 so they can be used
directly without any additional
licensing overhead and the other big
news which will I'll expand a little bit
more is there were a bunch of Oracle
commercial features that were built into
the Oracle JDK that are being moved into
the open source side of the distribution
and will be available with all the open
JDK builds so what's being open sourced
the Java Mission Control and Java flight
recorder were a pair of a pair of pieces
of functionality that supported each
other the flight recorder is a sort of a
real-time monitoring set of
infrastructure that goes in under the
covers of the running java application
and records events like garbage
collection events and file opens and
closes and other things that with that
can be recorded to a log file and then
the Java Mission Control analyzes that
stream of events and can help detect
problems with you know Gartland garbage
cushion lightens Layton sees and some
other problems in in the applications I
mean both of these are well known as
commercial Oracle commercial features
and there will now be available in in
open JDK I noticed yesterday there was a
as part of the open JDK infrastructure
there was a call for a vote to create a
new project to support the Java Mission
Control as a separate open JDK project
so that'll take on a life of its own
and support both flight recorder and
Mission Control another feature that
asked application class data sharing was
a way to speed up startup and to be able
to share classes between different Java
runtimes
by moving some of the work that got done
dynamically when you started out java
application and being a people take a
snapshot of it and then just use it the
next time you start the app so that's
also being moved to to open-source and
the Java usage tracker was sort of more
of a an enterprise capability of keeping
track of all the different Java runtimes
that are installed in an organization
that's being open sourced as well a
little bit more about flight recorder
Mission Control as I said it records an
event stream and has very low overhead I
don't think it's quite zero actually but
it's it's very low overhead to capture
the events that go on in a running
production java vm and can be analyzed
later to understand things that might
have gone wrong in an application the
flight recorder uses bytecode
instrumentation at the moment and
probably will just to be able to be
non-invasive on the on the java runtime
when it's not in use compared to a
profiler that a development tool like
NetBeans would use it doesn't it doesn't
make a big impact on your application in
terms of footprint or performance so one
of them in Java 9 which is now 8 months
old or something
is was the culmination of the work on
project jigsaw and 100 and plus other
features that were added over the three
years that it was in development the
part of the development process for open
jk that was put into place probably
three years ago was this notion of a
Java enhancement proposal which is a
specific project proposal within open
JDK to add a feature to you know change
some implementation to improve things
and they're done both for communication
and transparency and to get part of the
open JDK community involved in the
process there were you know quite a
number of different chips this running
list is available but it's sort of all
the little features that were added as
part of JDK 9
project dig saw was clearly the the
largest and as it was the most
controversial to create to remod Euler
eyes the JDK so that the different parts
of the JDK were were clearly or modular
in a way that they could be updated
independently and that they didn't the
module system also allowed with a lot of
the internal implementation of those
packages to be to be encapsulated as as
came forth and we had known for a long
time there were a lot of applications
that reached in under the implementation
of JDK and either used information or
changed information that made it harder
to maintain the JDK and or be sure of
its integrity so the major things was
the the introduction of the module
system actually modularized in the JDK
which this you can feel a piece of the
graph here and then on the on the
developer side for people that working
on the JDK reorganizing the source tree
and a bunch of processes that go went
along with how you developed for the JDK
the other big plus of the module system
is and it was the ability to
redistribute to repackage parts of the
JDK modules into a smaller runtime and
we'll see more about that in a minute in
a minute and particularly in the the
program for do that it's called J link
or the Java linker it takes it it takes
as input a set of the set base any set
of modules but starting with the set of
modules that form the JDK and it
determines the dependencies between them
both directly and transitive closure of
the dependencies so that it can produce
a customized Java runtime that has only
the set of modules that you use in need
and it allows you to create a custom
runtime that can be destroyed deployed
with your application code and it
doesn't have the full footprint of you
know everything that was in the JDK
previously
so let's see an example of that so
here's the the full graph of OpenJDK
suppose we want to create a new
application that uses for example the
java SQL rochette and the activation
framework part of what j-link will do
will identify the the transitive closure
of the dependencies of those of the
applicant modules that the application
depends on and then it will shrink the
sets to just the dependencies and
produce a executable runtime or a bundle
is just a ven time so it's quite a bit
smaller one of the other advantages of
being in Lamar lies of big chunks of the
JDK was to improve the the security of
the JDK there were there are always in
any implementation classes which are
powerful because they're needed for the
internal implementation but if they were
to be used in an arbitrary context they
might actually allow you to compromise
the runtime by being able to encapsulate
all the internal implementation of the
JDK we can now prevent a bunch of
internal classes from being visible in
any way to any kind of risk situation it
also makes it a lot easier for people to
maintain the JDK because the public
interfaces are the only ones you have to
maintain compatibility for you don't
have to worry about oh well somebody's
reaching in into the covers and using
this private system property or internal
API and so you have to keep even though
you might want to re-implement some
subsystem you can't because there's a
internal use so I think it's gonna help
in the long term of Crete with the
integrity and the stability of the JDK
one of the other big advances I
mentioned was the ahead of time compiler
which takes the Java byte codes for an
application and will statically compile
it into a shared library which is then
when you run the java application it
doesn't need to load all the classes
independently it already have cached it
already has predigested the structures
of those classes and this helps startup
time and shareability because the shared
libraries that are produced which are
architecture specific can be shared by
different Java runtimes so if you're
running the same application multiple
times on a system there will be improved
sharing of the of the storage and and
even though the initial set of code is
compiled to bytecode when you start this
still leaves enabled the dynamic
compilation that happens like when the
Java compilers look at the actual
dynamic uses of of classes and it will
read it may reoptimize them after when
it's really running a lot of developers
will probably really like the this read
print read eval print loop J shell has a
very interactive way to you know try out
some code it's pretty much like having a
command line that's just Java you can
use you don't need to write it comply
you know use an ID or write a Java
program to be able to try something out
and you can just you know type the
things into the command for a lot of
scope to actually show that in demo
today but actually I should probably ask
cuz anybody tried Jay shell okay
well it's a good thing it'll it'll come
in really handy it was in it's in JDK 10
I think it was in 9 as well and it can
help with prototyping and a lot of other
things so it's it's great the other work
that's been going on for quite a while
and will continue to go on is improving
the the garbage collector to reduce
pregnant pauses in your application the
G 1 garbage collector has been in use
probably for five years but in Java 9 it
was made the default it had been
improved enough in terms of performance
and overhead and it was stable enough to
replace the to be the default collector
they're still uses for the other the
other collectors we're depending on the
work
some of them are maybe more appropriate
or giving a better performance and it's
in this case it's in this it's better
because it treats memory and as larger
chunks and the chunks can be regions can
be processed in parallel so you get more
parallelism out of the garbage
collection phases and improve
performance as a result Java 9 was
pretty well advertised when it was I
went through GA last year and it's been
extensively reported on at JavaOne and
elsewhere so there's plenty of
information out about its features and
plenty of discussion in various forums
we've so Java 10 which was just released
in the latter part of March ads is the
first of the 6-month release cycles so
they were cut for us on our side there
were a lot of growing pains in terms of
changing processes and making sure that
we could do the get the release cycle to
be that quick include especially
cross-platform 10 or testing on multiple
platforms and release cycles and getting
the both the compatibility in the
integrity out it it has obviously fewer
really fewer features because it and
because it was a shorter cycle it's
supported on on the three major
platforms of Windows Mac OS and Linux
and it has fewer features but there's a
schedule there but that's probably not
interesting anymore a couple of them had
to do with consolidation of the
development environment creating the
forest that we work out of making it be
you know in one repository instead of
several local type variable inference is
one of the maybe may help developers
make code that's more readable and
easier to write
and I've got an example of that
basically instead of having to fully
declare variables there are a bunch of
contexts inside of methods and in which
you really just want to say the word may
want to say the word var instead of
typing out of a long type declaration
with its generic parameters especially
in the case here where you know the
right-hand side and the left-hand side
have a lot of common elements and so
from a readability point of view it's
redundant the the the introduction of
var just allows you to omit redundant
information when you're when you're
writing the methods there is a style
guide that Stewart Marks has written and
it's gotten some discussion on the alias
is about sort of good and bad uses of
local title variable influence in
particular things like the codes still
have to be readable so if the variable
names are too brief or misleading that's
bad if the type names and the types of
things that you're creating and the
expressions aren't expressive enough you
should go back to the old way of
spelling it out the emphasis still needs
to be on making the code be readable
because you write it once but lots of
people read it yes
it's a type arraylist so and I think
that's one of the things that gets
discussed is in many cases you might
have written list of string instead of
ArrayList of string depending on your
personal style as to what level of
abstraction you want the variable to be
but it the type inference mechanism will
generally pick a pretty specific type so
that it's it doesn't bring too many
other things in it the sorry moving on
the feature of application debt
application class data sharing which I
mentioned was being open sourced it was
a commercial priority muting product and
we originally had it applied just to the
JDK itself the application that class
data sharing extended that capability to
being being able to be used for
application classes so if you have a
bunch of libraries that get reused in
multiple applications you can use CDs
too and get better footprint and startup
time
one of the steps of moving from the
Oracle JDK to the open JDK had to do
with the security previously the
certificates that were built into the
JDK were essentially licensed and
redistributed under license to Oracle
and but moving to a pure open JDK bill
that's independent of of the Oracle what
IP constraints meant that Oracle had to
arrange for the owners of those
certificates to allow their
redistribution as part of open JDK and
that was completed for most of the cas
certificates so out of the box the open
JDK will will be able to to work with
many TLS servers which is an essential
component other projects that were
ongoing in you know open JDK that are
being open source there's a zgc or zgc
project which has come up with it's a
new garbage collector which is should
have even lower overhead or no overhead
for you know very large heaps the
there's another JCCC project called red
hats leading called Shannon dough which
is continues as well with many of the
same goals to do have a very good
performing garbage collector and garbage
collectors are one of the most important
and trickiest place pieces of software
in JDK also part of the open JDK
releases are is our being able to
distribute open JDK binaries directly
and Oracle has been distributing
building and distributing early access
binaries for open JDK
for a while now but it's it's sort of
more a regular process and it's easier
to do and that we're able to build
binaries and distribute binaries for
some of the sub projects which are not
yet part of the main distribution like
project Valhalla in the other aspects of
the open JDK development environment
that
are pluses there's a model for us off a
different set of repos for a sandbox
which have if you have people are
working on features that need to have
common shared shared source code with
the community they end up in different
branches in the sandbox so there's a lot
of sharing of code and development let's
see the in JDK 10 one of the one of the
other features in JDK 10 was the concept
of an incubator project one of the first
ones that was an incubator was the HTTP
to new client API where the idea was
that in order to actually get open JDK
users to use new api's to see whether
their you know their well done and they
need to be improved you actually have to
get those API is shipped with the JDK
but if you're not if they're not really
mature enough to be called supported
project forever they needed we needed a
category of things which were you know
we think this is good enough but it's
not final yet and so the there the
incubator project were created to allow
new API s to be put in place and shipped
with the JDK but they were clearly
marked as being I guess it's JD they're
all JDK incubator product XXX projects
and then eventually the incubators are
deemed to be mature enough and they get
moved to an official package within the
jdk or usually a separate module and
then they're they're supported there's
also a movement in progress to be able
to introduce preview features which is
simpler similar to the incubator but
allow changes that are a little bit more
tightly integrated with the java
compiler and the java runtime so for
example if you had some new feature that
wanted to change an introduce new Java
syntax you really want but before it's
really final and and you know deemed to
be mature it needs to still be set aside
as something different within the Java
JDK release and there's
working on exactly what the the preview
mechanism is and I think there is a
there's a Jeff already written and being
discussed about how to do that how to do
preview features so I've kind of rushed
through this stuff but so what we're
working on now for Java 11 is a new set
of their five Jets that are already have
been completed enough work and I'm
mature enough to be targeted to a
particular release the some of these I'm
not actually familiar with but part of
the separation part of the new release
model was separating some things out for
example the the Java EE and CORBA
modules have been there sort of archaic
in one sense but they have been
separated out from the JDK and for Java
EE in CORBA oracle has arranged and
other people who have agreed that apache
would take over the maintenance and the
in the development of those packages so
they're they're no longer in will be in
jdk 11 there are ways to pull in modules
and packages elsewhere if you need that
in your application but this is one area
that's in in is being changed the other
the other one of the longest-running
incubator projects was the HTTP client
package which just yesterday was was
deemed to be mature enough to be
targeted for jdk 11 so we're up to five
that's the JDK 11 freeze is in feature
freeze is in June so they will probably
be a few more things features jep
features that are in development that
will get should be targeted in part of
eleven including with the usual set of
you know bug fixes and security things
and documentation updates and and
everything else that goes on along with
the relief beyond eleven I mentioned
some of the one some of the big projects
going on the data layout one vault
project
Halla has been looking at how to get
better density in in heap storage by
looking at all the data structures that
have pointers between objects and saying
the pointers are sort of wasted space
and we need a way to get more data in
the same space and the project Valhalla
has been going on I think for more than
a year but it's it's targeted at what
are called value types which are there
they're like objects except they don't
have identity so you can't ask you can
ask if two of them are equals as spelled
EQ UAL s but not and you can probably do
equals equals maybe not anyway they
don't have identity so you can't tell
two of them apart even though that
values may be the same so you can't tell
whether two of them are the same in
instance sorry I'm butchering that one
anyway this is going to make a big
improvement in terms of the density of
applications and performance because
instead of the VM having to chase
pointers to find objects reachable from
other objects they're going to be able
to embed the data that might have been
in an object in without an indirection
and that's work in progress it's going
to take a little while to sort of
straighten that around as this mentioned
the you know the rest of the Java type
system that applies to objects every
aspect has to be examined to determine
whether it's actually a benefit or harm
to improving performance in the end this
kind of data
so that's Valhalla so the other project
is is in Project Panama the looking at
interoperability between Java and native
applications there are a lot of big data
applications that really kind of want to
do their own memory management and they
want to be able to take X get access to
and use data that are in GPUs and other
high-performance computing power that
are in a lot of systems today so Panama
is trying to make it easier to ingest
native data structures and then map them
into Java interfaces and Java API s
and then have the Java compiler be able
to essentially compile all that out and
actually just access the memory directly
so that's work in progress as well and
then one of for me one of the more
interesting one just has the one liner
here project loom is talking about how
to make essentially make threads be
lighter weight and because in a lot of
applications the thread is this a really
heavy weight thing and that I'm having
the operating system shift context
between different threads adds a lot of
overhead project limb is is looking at
fibers as a way as an alt sort of an
alternate threading model that is very
lightweight in terms of context
switching and it they talk about being
able to have you know hundreds of
thousands of fibers one of its main
benefits is that you can continue to
program as if it's a sequential
application but you'll get the benefits
of program of an asynchronous
application because the the ability to
store the context is is very lightweight
and the efficient mechanisms are very
efficient and that's in a fairly young
state too there's a project loom is one
of the project that on open JDK so I
think hopefully I've managed to
communicate that we're working to make
the open JDK vault development
much more efficient and responsive and
that we are that Oracle's being is been
able to open up its commercial features
and a variety of ways that make the
develop the runtime more attractive to
developers and they get more value out
of it as you probably all know the
development of the cloud is very fast
everything's are changing sort of all
the time in terms of what what it takes
to make to be able to deploy
applications and and make very good use
of the systems and the resources that
you have and be scalable so Oracle has
got a pretty we've got a good pretty
good tech nap roadmap for features I
think ten years beyond ten and we're
gonna be innovating as fast as we can
and try to get to get the whole Java SE
platform in the open JDK platform to be
a rockstar
continue to be a rockstar and that's the
pitch sorry I should say pitch I work on
this stuff every day it's really it's
great yes
right so the modularity mechanism jigsaw
allowed modules to be defined and access
to its its non exporting interfaces was
prevented that improves sort of improved
security because some of those internal
classes may have may have provided an
opportunity for it to be exploited well
so the transition has been it will
continue to be a bit awkward because
there are a lot of applications that use
classes most of the sunglasses I think
have long have pretty much forever been
unsupported and we've been working with
a whole bunch of developers to try to
find replacements or alternatives for
anything that they were that they've
been used so if you have something in
particular functionality that's there
that needs to have a supported interface
let me know or get in touch because we
you know as a whole we need we need to
be able to support the whole thing which
means unfortunately we have to seal off
a few backdoors and so right
do you have something in particular
they're probably a bunch of different
channels I mean there is a normal bug
bug submission mechanism if you want
send me email I'm Roger that rigs at
Oracle calm and all we have a there is
an open JIRA bug database that is
publicly viewable yes it's okay
sometimes you have to make a strong case
and okay yeah we like many other
organizations of constraints and
proclivities so anything else
to use sorry
right so I think there's there's there's
a long history of what do they call it
properties where a lot of people think
there a lot of different ideas about
what properties are and I think the last
time that category of requests had and
every one of them had had some
disagreement of whether it was the right
thing to do and so last I knew Brian
gets was disinclined to do any of those
there is work within amber on a set of I
think he they're calling them data
classes which if you could go look at
the amber mailing list you may find some
more detail there in which they're
trying to make the the use and
declaration of classes which are
essentially just data be easier and it
may last I knew I don't remember exactly
what's what I've heard and what's been
publicized there may be something in
that direction
other questions yes
I want to say yes it'll come file fine
because the you know there's so many
things have not changed the language
hasn't changed the core libraries
haven't changed but depending on exactly
what API is you know both inside and
outside of Java your application uses I
can't categorically say that there won't
be some hiccup for example if you read
if the current application reaches into
some inside class that's now
encapsulated inside of a module it won't
run there are warnings there's a way to
override it so that you can continue any
way but that there the compatibility is
still a goal except that it's it's
mitigated by the fact that we need to
close some of these doors for
maintainability okay thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>