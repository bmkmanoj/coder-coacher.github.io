<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CON6826   Ask the Architects | Coder Coacher - Coaching Coders</title><meta content="CON6826   Ask the Architects - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CON6826   Ask the Architects</b></h2><h5 class="post__date">2015-12-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/jAL72EhLTXo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good afternoon welcome to the ask the
architects session I'm mark Reinhold I
have three of my colleagues here they
can now introduce themselves Brian gets
John Rose Alex Buckley so this is this
is QA the this is the shortest
presentation dekhi will see this week
because this is the only slide and
there's only one animation on it a
record low for me personally I so so we
will take questions in in two ways one
is you can come up here to the
microphone and speaker question or you
can tweet at that hashtag and I'll try
to keep track of them and do some amount
of moderation and by the way there's
this this is on a live video stream
courtesy of the camera in the back of
the room on a 10 second delay so even if
you're not in this room you can ask
questions via Twitter so we have an hour
we are here to answer your questions or
maybe occasionally decline to answer
your questions but we'll do our best in
any case so who's first you need not
that I'm not repeating questions no no
no don't don't don't let me do that you
walk up here get a little exercise is
the nice microphone no code is you said
about future these questions about the
real far future no so this is at is so
so we have a collection of architects of
the JDK here you can ask about the
future the present the deep past
anything you want go there was a draft
JEP put in recently for spin loop hint
and I wondered do you think that's an
example of all the worlds and x86 and is
that a problem for the JDK particular in
the light of the rise of various arm
architectures recently I guess that's me
so there are certain low-level
functionalities in the vm that like
integer dot reverse bits
that apparently are going to be targeted
to instructions single instructions on
suitable CPUs and the spin loop is an
extreme example of that there is
actually an instruction in the x86
programmers manual called spin loop hint
and now we have a proposal for a spin
loop hint intrinsic so does that mean
that we are we've given up on all other
platforms in considering this know what
it means is that we still think that
Java occupies a sweet spot where it does
it lets programmers specify operations
that make sense on multiple platforms
and and so then the hard intellectual
effort is figuring out what spin loop
hint wants to be on other platforms and
whether it's in exactly that same form
and if not then we have to find a
portable form so since you mention it
you've probably seen the conversations
online between myself and other parties
trying to feel away feel towards what
that ideal form is we always want to
feel towards the ideal form even if in
the end there's a there's a clear story
for how it compiles to a particular
platform and and I think this sort of
illustrates you know the the value of
the jet process where r this particular
Jeff you know came from the community
and they had a certain idea in mind and
as it got discussed in a broader
audience a number of people said well
what about other platforms what about
other forms of performance ends and
there was a you know sort of a lot of
back and forth between experienced
people and the result of that is likely
to be a better outcome than whatever the
initial the initial proposal was no
matter what the initial proposal was
right so you know you can think of the
circulation of a jet as the starting
point for discussion and this particular
one there's been a vibrant discussion
which is great and eventually it will
either converge or it will not converge
and we'll proceed quarterly Ryan I have
a question for you oh no is it a better
outcome even on Intel
that's a low level question perhaps I
should out pose that question of the jvm
architect in my opinion yes one of the
interesting things along the long-term
history of Java is that the the hardware
architects are actually asking us
questions even as we're asking them how
the heck do we use your chip so they're
saying what would you like to see in the
next chip so that this is the sort of
thing where if we if we think of what
the programmer model is about a little
above the level the hardware and what it
should look like then the hardware
architects are likely to take take that
outcome as a refining factor on their
own heart burn you can line up here if
you'd like so well do classes two
questions here first do actually plan
like okay you planning for java tent and
value classes then assume you Stan they
also plan in the same release give us
access to a short vectors of doubles and
flaws that will get intrinsic I'd to the
corresponding vector instructions on the
crisp n processors and related questions
do you plan to support upper operator
awarding of those so we can actually do
mathematics on though in you know
friendly way so that that's three
questions right so the first one the
first question had numbers in it and
those numbers were numbers that were
correspond to jdk releases we've made no
decisions whatsoever about bed releases
so the second question is about what are
we working on right so we talked about
how in the context of project Valhalla
we're working on value types and in the
context of project Panama we're also
looking at vectorization and we haven't
made any decisions about how we would
want to expose that but clearly that's
something that's interesting to a lot of
developers and that we think is an
opportunity you know to add value to the
platform so yes we're investigating we
have no idea whether one would come
before after ever you know we're at the
same time as the other but they're both
things that we're working on and then
the third question you
best was a bad operator overloading as
you've abele demonstrated you can't talk
about value types for more than 15
seconds before someone says what about
operator overloading and we're
deliberately deferring solving that
problem until later for a couple of
reasons one is the problems that we have
to solve for value types are infinitely
harder and we'd like to we like to
attack the riskiest problems first and
doing value types without operator
overloading is far more useful than
thinking about offered over late and now
and deferring value types out into the
future so when we get there we will of
course of course think about it on the
other hand the history of operative
overloading in curly brace languages has
not does not give us a lot of confidence
for achieving a better future you know
the notable examples in which operator
unrestricted operator overloading is
available have been unmitigated
disasters and you might you might
convince yourself that well you know C++
was a long time ago that was a little
bit like back in the day is where we
didn't know was a bad idea to have 17
fonts on one page but eventually we
learned that and got better at it but
Scala is much more recent and scholars
experience with operator overloading has
been equally disastrous despite the fact
that we had 20 25 years to somehow learn
better in the intervening time so we we
are skeptical about simply saying oh yes
absolutely operator overloading great
idea because we've seen it be an
absolutely disastrous idea in similar
ecosystems that said if we can come up
with a way to do it that is more
constrained and therefore more likely to
stay within the sweet spot of numerics
that's possibility and we'll think about
it but not for at least two or three
years because we have their good things
to think about a prior condition before
thinking about operator overloading on
numbers would be actually to unify our
primitives and the theory the operations
of their arithmetic in terms of some
formal framework that has nothing to do
with operators probably interfaces in
other words the hard work is not coming
up with operators the hard work is
coming up
the theory of how the types work across
the different primitives but I will say
don't listen to these guys you know the
the angle bracket operator is really
cool for input and output like in the
burn shell and C++ so the next version
of Java will have triple angle bracket
shift will have output to standard error
not not on my watch what some looks Li
the sarcasm sign hold up the sarcasm
yeah exactly those who thought he might
be serious no are a question from from
Twitter are there any plans for non
nullable types is this even possible in
the current Java language int is an
unknowable type so we have that already
would professor gets care to elaborate
so this question could mean a lot of
different things so clearly you know the
JVM has some existing types that are not
nullable they have the primitive types
and it has all the reference types are
knowable so the question could be asking
is it possible to constrain reference
types so that null is not a valid member
of the type or the question could be
asking are we interested in adding tools
for static analysis and annotations and
and you know to to prove statements
about null ability for types for which
no actually is a member and the the
experiments we've seen in the latter
with annotating for null ability haven't
been very successful the annotation
burden is very high the annotations for
non null ability in most frameworks
don't actually demand that the type B
not nullable it just expresses more of a
a hope and a prayer rather than an
actual constraint so we're not so
interested in pulling in any of those
because we don't think those have been
been very successful experiments and
we're but it is possible that something
better might come along
in terms of value types we've thought
quite a lot about in user about
definable value types whether there is
room for some value types to be nullable
and some not and we're still continuing
to think about that but we don't have
any any concrete answers on that right
now it could also be a very coded
question about the optional type yes
good yes I could which someone may ask
about we should we'll see so a little
bit well maybe vaguely related if you
could do it over again would you make
collections immutable by default as they
are in objective-c I would certainly
make make variables final by default
right then this is like what is it so
the the defaults in Java are the
variables are nullable methods are over
I dab'll classes are non final yes and
all objects are lockable every object is
specified to have a monitor if you do
things that need to have a monitor on it
and one might think that these four
defaults are all exactly wrong one might
very well think that but you couldn't
possibly comment and I and I and I will
convert I actually kind of agree it's
amazing every default is wrong and yet
here we are you know maybe we should
just change them all in nine and
but if you if your dash source nine then
what that's released nine right yeah
what wait wait which ever i get on other
question here this morning the hack
session you said if you could go back
and add anything would be modules in 11
and then it was kind of joke about what
would you remove you could go back i
believe one answer was serialization and
I was kind of curious what each of your
answers would be evil what you could
remove if you could serialization and
are my were mine serialization is my pet
peeves I vote for that too as a vm
bytecode guy I hate the new invoke
special in it dance yeah and maybe ten
percent of the people in this room know
what that is but it causes security bugs
it causes limitations and features it
causes the the funk that the design of D
serialization to be all wrong because it
imitates what it thought the vm was
doing legitimately it's just wrong I was
going to say the same thing that I'm
really going to use a completely
different set of words which are exactly
the same thing constructors constructors
are popular simple and wrong and they're
wrong because you know they they don't
fit in anywhere else they're not members
of a class that's one thing they aren't
object-oriented because you can't
override them if you say new see you get
back exactly a see there's no
possibility later on of an alternate
implementation giving you a better see
they map to bytecode in this horrific
way really the invoked special
instruction that handles object creation
is this sort of monolithic thing doing
17 things at once it's hard to verify
its I Titan is hard to understand it is
arguably as complicated as all the other
instruct not just invoke instructions
all the other instructions put together
it's very close if it's not quite there
it's very close and constructors they
look so easy right but there have been
entire papers written about how the body
of a constructor if it calls methods
on this and they're dynamically
dispatched and the claw the object isn't
ready yet and you know i think you're
right in jcap about leaking this before
it's ready it's like they're they look
so attractive but again nothing's good
about them either in the language or in
the vm so i think we all have pretty
clear answers for what should go what
should have gone i want to point out
something that and that is the original
default for a final field was not only
the default but the only thing you could
say was a mutable field it was it wasn't
until java one dot one that we got final
non-static fields and the concept of
blank finals so the java started out in
the very mutable state yes this question
is sort of a two-parter so with all the
recent experimentation around invoke
dynamic and all the sort of interesting
mechanisms that it rings to play the
first part of the question is do you
perceive any remaining barriers to
performant structural types in Java and
the second part is are you actively
investigating that thank you
performance structural types i guess i
get i guess i get to em interpret that
however i want so like an ordered pair
type alright is that a good example of a
structure structural type no what I
meant is a sort of compile time duck
typing basically like having a an
anonymous partial signature that maps to
an actual Rafe ID type patron so if the
if the if a type has the same methods
and and roughly the same signatures of
those methods then it's the same type as
another type which looks similar to it
so yeah I think pair is a good example
of that because there are many places in
the Java ecosystem where somebody felt
they had to find a tight pair and yet
that's a different type in every single
occurrence and really they're the same
thing at least in the common
consciousness of all the other writers
so can we do can we do that sort of
thing well in order to do I'd say in the
vm for the for the foreseeable future
typing is nominal it's not structural so
if you want to be able to get the effect
of structural typing or duck typing what
you need to be able to do is issue a
type reference without committing to
being the sole definer of it or knowing
the sole definer of it you need to be
able to say i need a pair of x and y and
i don't care if if it hasn't been
defined yet somebody will define it for
me and then have some way of having
somebody supply the definition that the
whole crowd wants and we call this
feature class dynamic and we've
prototyped with it and there's lots of
good tricks you can do with it so in
some version of the vm there might be a
basically a type definition hook which
would give you give you the ability to
do types that are structural in that
sense as far as duck typing is concerned
which i think was the questioners
original intention if you want duck
typing than what you need is to code up
something like NASA horns runtime and in
fact we're you know we have a runtime
that is not just for NASA horn but it's
the Dino link framework
I Attila that will let you let you mix
that with invoke dynamic and you'll be
able to do purely name based method
calling okay question from Twitter are
there any plans to realize JEP 159
enhanced class redefinition alright so
of course we want to enhance our class
redefinition who wouldn't and there are
there are prototypes for this and some
which have been in existence for quite a
while and Thomas's work I think we
talked about it in fact last year we've
spent a quite amount of effort in the
last year or two looking at Thomas's
work in particular and also at the
problem in general not just at the
solutions that that were proposed in the
patch and there are some very serious
scaling problems and and speed potholes
performance potholes and also just
software engineering problems with
adopting any solution currently on the
table and so our runtime group is
looking looking very diligently at how
to improve the the redefinition of
classes one thing that does not seem to
work for us although it'd be interesting
to hear customers talk about it one
thing it does not seem to work for us is
to make the redefinition process linear
in the size of the Java heap in other
words it should not have to scan over
the entire Java heap which is that is a
constraint if you remove that constraint
then there are some things you can do
that are very nice if if you keep that
constraint then it's still very
difficult and it's going to be it's
going to be a matter of years to be
building up to the kind of redefinition
facility that everyone wants so I don't
have a happy answer for that I do it is
something that the
the runtime team hotspot runtime dev is
the relevant alias that the runtime team
is very seriously looking at it is
expended serious effort in trying to
adopt proposed solutions and and think
of think of new ones first thing you
guys would just love hearing you talk
about this stuff so I'll give you a
broad question I've been reading some of
the job aid stuff getting into
functional programming maybe for six
months so maybe it's an ignorant
question but why would someone do
functional programming in Java are you
guys going to get it better can you
maybe just give us some some trade-offs
sort of answer so I i think the the
dichotomy between object-oriented
programming and functional programming
is a false one and I think there are a
lot of proponents for doing functional
programming in Java and while I think
their heart is in the right place I
think they're experiencing the side
effect of confusing the audience as they
do that so my perspective is that as
programmers we all have something to
learn from object-oriented programming
and we all have something to learn from
functional programming and both of those
things make us better programmers and
two to quote to quote ugly on this then
we have to rise above them both to you
know to become truly better programmers
and so the functional vs. 00 i think is
is a less helpful way to frame the issue
then what can I learn from functional
and how can I use it to make my programs
better and you know I've I've been
writing code in Java for a really long
time only recently has java head lambda
expressions ah but it hasn't changed the
way that I've used functional idioms in
my java code it's just made it it's just
given me more opportunities to you know
the core principles of you know don't
mutate things that don't need to be
mutated is not something that we needed
lambda expressions to teach us it's a
just a more reliable better way
of writing code that has absolutely
nothing to do with functional versus oh
oh it's just about writing code that is
easier to analyze easier to compose more
maintainable more testable etc so learn
learn what you can from functional
programming learn what you can from 00
and rise above them both is my answer
and you might like to try haskell if you
if you're really sensitive to languages
and want to do functional programming
there are languages out there which
which are exactly designed for that
purpose but then there's always the
question of what what sort of commodity
platform is there out there you might
want to say well I want to do vector
programming but I certainly don't want
to do it on Intel because it's a
horrible instruction set and there's no
good tools for working with vectors on
Intel so I'll wait for a better vector
programming platform to come along and
then i'll use that and then you'd wait
but I you know I would suggest do your
vector programming on Intel right now
and do your general-purpose programming
on Java there are a handful of places in
the JVM or JDK where we piggyback on the
garbage collector to handle resources
that are not keep resources one of them
would be direct buy buffers and I kind
of class soft references another example
that it's just that the resource is
something unknown are we ever going to
get a manual way of clearing a direct x
bar in a way that it also invalidates
without using the reflection in the
cleaner and Huggy stuff like that in a
way that is secure and invalidates all
possible slices and views and etc no and
damn and are we ever going to kill soft
reference because i cannot early being
at the equivalent for this in two
thousand and seven or eight and people
complaining that it was completely and
utterly broken and unusable and i don't
think it's got any better
as the instigator of references back in
the day um well and of direct bytebuffer
for that matter okay so the the story on
on direct bytebuffer is if you want to
be able to release one manually then in
order to ensure the continued safety of
everything the performance of direct
byte buffers would become horrible
because every access to a direct byte
buffer would first require checking a
bit somewhere that o is the underlying
Nate native byte array still there or
not so that you would be able to uh or
in map it or whatever but your perform
the performance would be worse than than
byte arrays in the heat probably by
multiple factors so sorry I just I just
don't know how to do that on on modern
architectures as the soft references you
know sometimes we put things into the
platform that have a little bit of an
experimental nature about them I think
in in retrospect the soft references
were one of those experiments weak
references have you know how weak
references have a very long history and
languages going back to the to Lisp in
the 60s phantom references had you
actually existed as a concept in other
languages well before Java adopted them
soft references were an experiment to
try to allow some amount of GC feedback
on cacheable things and of course part
of the problem there is is it's
basically leaving what amounts to a
policy decision up to the vm
implementers and sometimes that's a
great idea in this case not so much
because if you're building a really
sophisticated kind of cash you probably
have your own policy in mind and it's
not going to match whatever your vm is
day and your ear selected GC is going to
do for you so you know maybe it's
actually time to deprecate soft
references or at least denigrate them
and
say yeah not really the most recommended
thing anymore hi there um I was just
wondering if you consider getting rid of
checked exceptions from the language
okay okay excellent time for a poll how
many people would would like us to get
rid of checked exceptions how many
people think checked exceptions are
great and we should keep them as is did
anybody raise boat varies hands for both
how many people think checked exceptions
are okay reasonable compromise so well
you don't know you'd in some cases you
don't have a choice about there any
c-sharp developers here yeah okay so
thank you but basically know okay so it
right and if you ask the question who
thinks all who thinks all exceptions
should be unchecked I'd one check its to
say i want to check it's the same hands
as people who didn't put their hand up
for who like jade exceptions but there
aren't really many hands up going for
unshaped exceptions only there are some
hounds there no stay stay your question
again in a clear well so your question
was who thinks checked exceptions are
great right and somehow lots of know
some hands went up and some hands didn't
so I'm say I just want to do the duel so
who thinks unchecked exceptions should
be the only way to signal and somehow I
guess some hands are going up okay it's
not but many more hands went up for our
checked exceptions yeah the point of
this little experiment is there there is
a small and extremely vocal minority of
Java developers who think checked
exceptions were the stupidest thing ever
and they're entirely entitled to their
opinion and and there is some validity
to the opinion that maybe it wasn't the
you know the best thing in the world but
there tends to be an assumption among
those people that everyone agrees with
them because they most of the people who
just think checked exceptions are a
reasonable compromise don't engage in
the debate
they have better things to do with their
life and their time so the reality is
most job developers think checked
exceptions are okay it's not the worst
thing in the world it's not worth going
on strike and lighting up your torches
and bringing your pitchforks out you
know would we have made different
decisions if we could rewind the clock
20 years maybe are we going to change it
no way it's not worth it it's not the
biggest mistake we've ever made it's not
the biggest pain point that that
developers experience every day is it a
minor annoyance sure let's move on so
personally I have a slightly different
view I I wouldn't argue for removing
checked exceptions from the language but
I do think it's worth going through an
exercise and looking at the checked
exceptions we have and asking should
every one of them really be checked I
yeah you know if we're working with all
the code in the JDK working with with X
weekly with external code for many years
you know among other things I I Oh
exception yeah that I don't think that
really needed to be checked and I think
that is a big part of the pain that if
people experience for checked exceptions
is that the choices that were made about
what is checked and what is unchecked
were made before we really knew anything
and we're kind of stuck with those
choices and that's that's really
unfortunate and that's colored people's
experience of using checked example well
the fact is were not stuck it is but it
is possible in a binary compatible way
to make an exception be a currently
checked exception be an unchecked
exception so we could we could do an
audit at some point and come up with a
list of currently checked exceptions
that are you know being you know cotton
wreaths thrown in every other method
that you ever write and maybe make them
object and it may be the check admiss is
not shouldn't be a declaration site
property of the type but it should be a
use site property of throw yes and so I
think we ended up with a model that was
potentially overly simplistic and then
we built some libraries around it
without necessarily the best sense of
how exactly to use the simplistic tools
that we invented and then with 20 years
later we end up
in the somewhat muddled state where
people's experience of it is somewhat
negative because of the inconsistency
there so there's definitely room for
improvement but I I don't think that
means we're going to remove them so mark
at the keynote you explain how you know
commuters changed in the last 20 years
like we have this fast course slow
memory right now and the cake was ok
will ultimately have value types to
address that but the problem is not
limited to Allah types like whenever
right hyper from us code and I wanted to
be structured the object-oriented I
always run into pain that whenever I
have an inner object references from my
larger object you see I want it separate
in the first place but I want don't want
to pay for the cost of the reference on
the other place so we'll is there any
consideration to in to allow into basic
in line you know final references from
one class to another somehow so object
and lining array on lining yes
absolutely right well I first answer is
if you make the inner type be static
then you don't get the link so if you
don't need the up level link from the
inner to the outer then you can drop the
you can you can drop the drop the link
by was saying that it's static but I
think what your which what the general
form of your question is objects are too
small and they require pointers to get
from one to the other right so and there
you go to the the flattening discussion
and so what we want is to be able to
have an array of array of things and a
struct of things and then we want to put
structs inside of arrays and arrays
inside of structs that seems to be
enough to flatten out most of the data
structures we're looking at and it's
it's doable in in the vm
interestingly the thing seems to make it
most difficult to accomplish in Java as
Java stands today is the thing that Alex
and the rest of us talked about with the
constructors if an object is going to
have variable length then the
constructor based creation mechanisms
are completely wrong and have to be dug
out and reimplemented replaced with
something that allows the the length
parameter of an object to be present at
that objects creation and allocation
which currently is not the case which is
why there's a special syntax for array
creation in the java bytecodes why only
Java arrays can be the way they are but
that's that's more an accident of the
way Java wand otto was created it
doesn't have to be true in the future so
as part of project Valhalla we are
looking at making struts inside of
arrays which is a value type inside of a
classic java array type but we are also
looking with less definiteness but
certainly eagerness to be able to put
arrays inside of structs as well and
then you know nest that nest that story
so the comment is he just wants to nest
an object inside object or in my terms a
struct inside of a struct and well you
can do that today if you're willing to
like blow up the smaller object and put
his fields inside the bigger object but
of course that's not what we mean but
the value types will allow you to put a
small struct inside of a bigger struct
and have that nest arbitrarily and then
the array stuff turns out to be
necessary in many practical data structs
to data structures also so yes we want
to get there flattening is
extraordinarily important the overall
one of the main benefits of flattening
is as the questioner said if you if you
have a bunch of objects that are related
together as a nest of sub-objects then
you don't need pointers to navigate to
each individual piece and therefore you
don't need to commit the storage and the
bandwidth to working with those pointers
okay a question I think for Brian from
Twitter have you considered extending
the stream API to support back pressure
yeah so all right so this is this is a
great question um so we know what's
underneath this question is can I make
the stream API into a reactive framework
and you can do anything with a big
enough crowbar but I would argue that
that's that's the wrong way to approach
it so the if you look at an API extremes
and you look at an API like RX java
which is a reactive api there are some
obvious commonalities they both have
methods like filter and map and grouping
and all of that and it's really easy to
think oh well these are really kind of
the same API couldn't we merge them but
they have extremely different models at
the far ends of the stream pipeline at
the head end they have an extremely
different model about where your data is
coming from and how quickly you can
access the data so for example the the
assumption behind streams is that you're
doing an operation over a mostly likely
to be finite collection whose data
elements are roughly a cache miss away
they're in an array there in a list or a
map or they come from a generating
function that can spit up elements as
necessary whereas reactive framework
like orx makes the assumption that your
data is infinite it's coming with an
unknown latency the elements show up
when they show up and similarly at the
other end streams you know the terminal
operations and streams are about things
like aggregating reducing you know
adding the elements up with the
expectation that you eventually get an
answer because you've added up all the
elements of the collection and now
you're done whereas RX makes the
assumption that the the data source is
infinite and you're just going to keep
calling handlers until the cows come
home and so you can try to make these
api is more like each other and make
each of them reach into the use cases
that are in the sweet spot of the other
but it's not very happy if you try to do
that and so my answer to the quest
here is no if you want a reactive
framework use a reactor framework RX
java is great it's great even though i
didn't write it right i mean the the
library i wrote ah you know is good for
what it's good for and it's not the only
good library in the world so if you have
different requirements that need a
different library go use a different
library and that's perfectly okay a a
coincidental follow up what will happen
to primitive streams like in stream
after Valhalla adds generics over
primitives death so so the the the
manually specialized primitive streams
you know in stream Longstreet double
string him along with all their
ancillary artifacts like optional int
and in predicate and all of that were
really uneasy compromises we didn't want
to do them but we realized we would get
atrocious performance in some very
common use cases if we didn't do them so
we did them very reluctantly um in
Valhalla we we already have a prototype
working where all of that code has been
ripped out and it's beautiful and we're
able to just replace in stream with
stream event and we don't have any need
for either of the specialized types that
appear in the API but more importantly
for the specialized implementation
components that you don't see but that
lead to terrible duplication inside the
implementation so the new implementation
is about seventy percent smaller than
the old implementation and a lot cleaner
and so and we're actually looking at
that as one of the success criteria is
for did we get Valhalla right which is
can we take the stream implementation
which right now is very complex on the
inside and render it down to something
that's very simple on the inside we and
we're making good progress on that okay
Brian's on a roll here let's just finish
this this topic off we've lived with
type you're a sure and the tricks to get
around it since Java five is type
capture also known as reification in the
future
it's a little unfair that this question
is coming from Twitter because my usual
trick when this question comes up is to
ask a question or what they mean by
reification and and watch them stutter
so reification means different things to
different people reification could mean
reflective access to type information at
runtime or it could mean full type
checking at runtime the latter is
generally not what we want to be doing
everyone everyone thinks of erasure as
being this ugly smelly trick that we
should get rid of as quickly as possible
it's actually a very very practical
compromise not only is it a practical
compromise from an engineering and
efficiency point of view but there are a
lot of programs that can't be expressed
very cleanly if generics actually did
all the type checking at runtime that we
might think we would like to so anybody
who's written more than a thousand lines
of generic code has had the experience
of casting something through raw because
they know the types matchup but they
can't express it in the type system so
who thinks all of those programs should
break tomorrow so all right so that's
500 votes against reification so
reification is a practical compromise
from a compatibility perspective there
is a lot of code out there that is built
on the assumption that generics are
erased and I don't want to break that
code either so valhalla will give us the
equivalent of reification for the
specialized types you know ArrayList
event but most likely we would retain
erasure for the generics that are to be
compatible that are expressible with
today's generics purely for
compatibility reasons if not for you
know for other reasons the other thing
that we don't want to be doing is right
right now if you if you look at what a
race doors do right now there is a type
check that's associated with writing
something to an array to make sure that
really is compatible with the type of
the array if we were to fully reify
generics as some people think is a good
idea we would now have to do generic
subtyping test at runtime which means
pushing java's genera
type system with wild cards and all of
that in the vm what do you think about
that job I like my vm the way it is yeah
with checked exceptions there's no need
to look at checked exceptions at all in
the vm the vm just ignores checked
exceptions when linking methods when
performing class casts or erased or
checks or whatever on on fancy generic
types the vm again ignores most of the
details and gets down to just the basic
amount necessary to maintain the
integrity of pointers the distinction
between pointers and ends I like the
fact that the vm is in its normal
operations ignorant of what the static
type model is and still is safe to use
and this leads some people to find heat
pollution happens you know through some
contorted programs that are have type
incorrect in the first place the vm will
allow hepa pollution so to speak this
does not bother me i like it it actually
lets me optimize my code more simply and
create create better code patterns
asking the vm to completely REM you late
all of the static typing properties of
the language would be something that
would make me sad so the short summary
is when people ask about reification our
answer is this is not the type system
you're looking for however if
reification means there should be some
way at runtime to express those types
and in an optional opt-in way to
associate those those highly reified
highly decorated types associate them
with the with the data structures that
they talk about compile time that's I
have no objection to that and I would
like that as a Java programmer but it
has it kind of has to be opt-in you have
to be able to say yeah I really do want
to record all the grody bits from the
static compiler on this object to do it
everywhere would be a mistake and that
means that the folks who are doing
reflection and asking you know what is
the type of the elements collection
still have to be prepared to accept the
answer it's been erased so I
think being able to do that although I
think that that's quite valuable it
would still be disappointing to some of
the people who are asking for this
feature and that's it it's more
complicated it looks will we ever have a
32-bit vm again you mean again you mean
you said a 32-bit vm it's a 16-bit vm no
oh oh I was thinking we had a 64-bit vm
you're taking out we're taking me down a
couple notches you didn't say what you
were measuring yes it's a class file
question pair is this a class file is
this about you to all the u2's in the
class file well class file and the
instruction set on the bytecode and
different right yes yeah yeah the
highest level of the vm where i sit in
the spec as opposed to under the covers
where i'm confident you are no longer
limited to let's do it yes so what
you're saying is the class file has many
no its you ones you to Zanu fours I
think there are no you ate that is true
there are no you eights in the vm spec
and the common case that people ask
about is and therefore I can't throw
exceptions beyond the 64 K boundary so
you can have methods that are up to full
gig as r2k because it's up there to have
a method that the graduate branch
offsets you can you can do all that
that's all you foreign next it's the
exception table that has the you to
offsets there's also kinds of other
tables that are you lose that there are
but I've never had anyone complained
that they can't have more than 65535
super interfaces that like like James
did good with that one right but
absolutely deep down in the code
attribute and the exceptions attribute
and I think we try to avoid this with
the bootstrap methods attributes but I
suspect there's still I think there's
still a 255 argument limits from a you
one even with
dynamic so fast them four episodes you
to 65,000 yes and so yeah there are some
pain points that are more painful than
others in the class file format and that
goes all the way I mean that just mapped
immediately to various instructions I
mean for example one of the reasons that
we only have these small arrays with up
to 32 bit indexing is the array length
bytecode returns an int and int is
defined to be so evolution of the class
file evolution of the instruction sets
rather than the implementation of the vm
is what the questions about having
phrased it that way when are we going to
see you know we bump the class file
version basically every major release
because there's something new in it so
it's relatively straightforward to add
you know a code 64 attribute or a new
style of constant pool when the version
is 54 which would be I'm not giving
anything away the se10 number are there
any plans to do it maybe how many people
would like to help design a new class
file format that would remove all these
limitations well yeah find all of the
tools that in jest and generate bytecode
and update them accordingly I i I'm I I
personally am foolishly confident that I
could I could fix one problem in the
class file format at a time but I once I
had in my kitchen the stove broke and so
we knew we had to replace the stove but
then there were no replacement stoves of
the same size as the opening the counter
so then we had to replace the counter
but by the time we were done we had a
whole kitchen remodel does that sound
like it could happen in the case of
class files yeah another another set of
yak I do like my new kitchen
maybe it's occasionally time to remodel
the kitchen that's not to say that the
YouTube for exceptions is a stupid limit
it is so why doesn't Java have unsigned
primitives and why does byte buffer
duplicates and I think slice ignore
endianness thanks I'll take the first
one the the so why doesn't Java have
unsigned primitives the other the
unfortunate answer is because it doesn't
um you know that at the time that uh
that Java was designed it was deemed
that there were eight primitive types
the byte codes are strongly typed and so
for every primitive type there is a host
of byte codes I load I store I return I
a store I a load etc so each new
primitive type would require consuming
another n where n is between like 7 and
15 byte codes and clearly that's not a
scalable scalable problem to continue to
add new chunks of a bike codes and so
it's something that at the time java was
created we somehow convinced ourselves
we didn't need it and then the ability
to add it back became quite limited so
our answer to this is way for value
types right because value types will
allow you to create new types that
behave bright black primitives but that
you can write as libraries and so you
can write your own unsigned 32 and
unsigned 64 or you know whatever bit
size you want as a library and not pay
any of the object overhead you know of
representing it so in the future we will
be able to solve that problem for
yourself maybe there will be some new
value types that will add to the JDK
whether it be unsigned or complex or in
128 or decimal or you know I'm sure
there will be a vibrant discussion about
what types we should and shouldn't add
you know
there was a question earlier about are
we going to get operator overloading for
those maybe maybe not but the short
answer right now is it's just way way
too intrusive to try to add those back
in after the fact so Brian you know the
story of how James made the decision
right John do you remember though so so
the story goes James in the end there
and the early the early you know green
oak team they were they were trying to
decide should there be unsigned numeric
types in oak before before it was even
called Java and be a my understanding is
that is that there were oak for quite a
while actually had support for unsung
numerics in it James went he collected a
handful of examples of arithmetic
expressions involving unsigned numerics
and he put them we walked down the hall
and drew them on the whiteboard of every
engineer in the team and asked them what
what what's the answer and he pretty
much got different answers from each
person and this convinced him that
unsigned numerics are just so
unintuitive that they weren't worth they
were just not worth putting in so well
yeah a little oddity here here's is if
you look at the at the character type
the character primitive type it is
unsigned mm-hmm so much for consistency
yeah they said there ought unsigned
types there's care and then there's the
operator left greater than three times
well yes or the operators unsigned even
though so the type that he's nominally
operating on is unsigned at the moment
yeah um yes that's true anyway so that
so that's the history I mean you know
personally I kind of agree with Brian it
was maybe not the right to sue
will be and value types are the are the
most sensible way to to try that try to
add them back we're not going to go make
you know allocate another big set of
byte codes just just prefer on it for
unsigned numerics so sorry go ahead
quick comment it four bytes it's it's
very common I think both on IBM and
hotspot jvms of the optimizer will use
an unsigned load if in fact you're
masking the thing that you're loading
right it stands to reason yeah the
second part of your question was about
the duplicate and slice methods on
bytebuffer why do they not respect the
byte order declare to the byte buffer
itself the answer that is a bug I think
that that is that is incorrect behavior
it was there for a long time as we were
working on the new I owe a pee is in one
dot for nobody noticed and it's too late
to change it without breaking people's
code I'm sorry you know it's my fault I
was the spec lead you know a and I I
think that this is a demonstration of
why it's so important to get early
feedback you know please if you if
you're at all interested in what's going
on at nine and even if even if you're
not you know download some builds even
if you only do it once every month or
two see if your current code still works
check out new api's it's you know the
early feedback we get and we've been
again starting with java 6 we we
published every build early feedback is
immensely valuable you know i i'm not
i'm not saying this to blame that bug
which is now baked into the spec on on
you know the ecosystem rather than us
take we take full responsibility for it
but you know had that had we had a
tradition at that point of broader
publication of really access releases
hopefully somebody would have noticed it
and and we would have fixed it so a very
early question came in and the answer to
that question is that my slide deck is
too short so allow me to fix that
you
sings live
so thank you you spin for pointing that
out wherever you were we've got five
minutes left anybody else wanna you need
to come up here and yeah so somebody who
hasn't asked a question so kind of the
converse of an earlier question not what
feature would you like to take out of
the language what other language feature
from somewhat language probably not a
jvm language have you seen would you
like to add to Java might not even be
possible but are there other features
that different languages support that
look really cool and yet probably don't
fit in Oh No can we just say really cool
and ok and maybe we should try to figure
out how to make them fit in and each one
of us might have a different answer I'll
tell you what my answer is continuations
continuations with an implementation
that's good enough to build true co
routines and channels and things like
that the way they would that they won't
be in job at ten they certainly won't be
a 911 but i'll do i'll do a quick one is
not so much from another language so
dependency injection should be part of a
language my argument against
constructors is that no because they
have problems that I outlined before
dependency injection had to be invented
and applied to Java now we have a
variety of libraries for doing it there
should be a choose keyword you should
choose C rather than you see and the
implementation you get back is the best
one for the time so I didn't say virtual
constr I you can guarantee that any such
feature that was eventually added to
Java wouldn't use any of the same names
as the feature in another language so if
they were ever you know so we have
default methods java rate we never used
the word traits on purpose so we hold on
okay because they're not yeah but
they're there let's let's see how
scarlet rates map closely to 2d four
minutes in and fortress traits each
closer yeah similarly there was a
discussion recently
you know our Java our Java lambdas
closures yes yes they are why don't you
call them closures good question not for
now so dependency injection in the
language is a good idea China matching
is pretty cool pattern matching good
John you only get to nominate one okay
sorry I know you've got a bucket full
well from marks one which I'm not
nominating continuations there there's
actually the beginnings of a prototype
on Valhalla in the repo the that we have
a meta circular interpreter which can be
lifted out of the heat out of the stack
really easily and then we just a matter
of optimizing but so if not you're a
simple matter of often what's so the
feature the feature that I sort of dream
about bringing in is a sort of from the
list macro days or from looking at dsl's
or looking at some kinds of array array
processing syntaxes I think there's and
and and the the thing that makes people
reach for operator overloading also
feeds into this what they really want I
argue is type specific sin taxes
starting with sin taxes for creating
literal expressions let's until contract
constructor expressions but moving up in
a towards also our race array reference
syntaxes array slicing sin taxes and and
maybe even to the ability to put
expression trees in slightly different
languages merged into Java I think all
of those three things really want to be
a single feature or cluster of features
in Java I got three there's there's no
stopping him okay so we are we are out
of time sadly thank you very much for
your questions see you next year</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>