<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Clouds, Functions, Density, and Compute | Coder Coacher - Coaching Coders</title><meta content="Clouds, Functions, Density, and Compute - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Clouds, Functions, Density, and Compute</b></h2><h5 class="post__date">2017-10-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/aumEOj8xRoY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome folks thanks for coming thanks
for coming so the type of the talk is
clouds functions density and compute
we're going to talk a little bit today
about what service computing is what
Oracle's approach to service computing
is and we're going to show you a little
demo of some software and that we're
hoping to open-source later on today you
folks are lucky you're getting a little
sneak peek at an announcement that's
going to happen later on this is your
your standard reminder that this talk
contains some forward-looking statements
blah blah blah don't make any purchasing
decisions so what is service what is
service I let you into a secret there
are service lots of servers and
networking gear and storage the point
about service is that we don't want to
have to think about them anymore in this
session we're going to show you how to
build from the ground up a scalable
reliable application and we're not going
to once mention networking virtual
machines load balancers auto scaling
groups or even containers all that much
so the heart of a server list platform
service infrastructure is a functions as
a service of bars a function is a simple
piece of code that does one job and does
and does it well normally takes some
input often on standard in and writes
some output often on standard out we're
not talking about functions in the
functional programming sense here they
see the in that these functions can have
a can and do have side effects so your
functions are deployed just the code as
a single unit into your functions in as
a service platform and this platform
then deals with provisioning the
underlying infrastructure deploying your
function code scaling up scaling down
security or authorization authentication
isolation and it has to do all of this
blazingly fast huge scale and for any
language or platform that you care to
use
as on its own is not necessary not
necessarily enough for a service for a
complete service platform
you also need somewhere to store your
state and you should check out some of
the state service talks later on this
week for some help with that and you
also need a way to stitch together these
little independent functions that you've
written into a coherent whole and app
more on that later on what is service so
your first platform enables your app to
scale organically per request without
you having to write any special code to
handle it and not just a gentle seasonal
demand that you might changes in demand
that you might see in a retail business
but also the sudden dramatic surges in
demand that might be caused by your app
your app going viral your face also has
to deal with isolation of your software
so that and it will be and it will do so
without you having to write any special
go to do so again here here again having
things keeping things small and well
bound it helps us write better software
and it also means that we can supply
secrets and configuration
- well bounded small pieces of code
which will reduce the blast radius of
any security vulnerabilities that happen
to creep into your stack above
everything else though serverless is
about being code centric and code first
about offering an awesome developer
experience it lets developers focus on
writing code to solve business problems
while the complexity is pushed the
complexity of scaling and managing your
infrastructure and securing your
infrastructure is pushed down into the
platform and handled for you and
serverless also has some economics it
changes the economics of computing as
well wrong right the - the two primary
principles and drivers are first that
you don't pay for your code whilst it's
not running you don't pay for your
platform loss it's not running so you're
not paying for idle time and secondly
when you do pay you're typically paying
in sub second increments today
that's a hundred millisecond increments
over RAM consumed by your function and
we see that billing granularity getting
finer and finer over time and then there
are secondary effects too as I mentioned
just now developers can focus on writing
code so your code to solve your business
problem so your developers become more
productive they're not writing code to
handle lifecycle and deployment and
provisioning and scaling because that's
handled by the platform for you because
we we slice everything up so small the
fast can pack workloads much more
densely than using VMs or containers
alone this enables better utilization of
the underlying hardware and therefore
better price performance and complexity
has moved into the platform and handled
for you we think that the combination of
sub-second resolution billing seamless
scaling and small reusable functions
will change the way we think about
software engineering as tools and
practices move to working at this finer
grained scale and as developers get real
real time impact real time feedback on
the impact of bad or poorly written code
they can choose to use code that is
better behaved and we think that'll
significantly improve the maturity of
software engineering as a discipline
over the next few years okay so what are
Oracle doing we are we are announcing
this week the f'n project this is going
to be an open source functions as a
service platform you should go and check
mark averages keynote out Java one
keynote out later for a really shiny
demo and some more information it really
it really is going to be open source
where is an Apache 2 license project is
going to be used using standard open
governance influenced by the cloud
native foundation style governance we're
actively seeking out like outside
collaborators for this project but at
the same time Oracle are going to be
committing significant engineering
resources to improving their
over the coming weeks months and years
neither is this just an open core play
where we're developing this completely
in the open we're not holding anything
back for the Oracle managed services
which we will be launching later on this
year hopefully everything will be
developed in the open so you can run
exactly the same code yourself in your
own data centers if you if you need a if
you need an on-premise solution you can
run it locally for a really great local
development experience we're going to be
doing all of this in the open in github
we're not doing this out of the goodness
of our hearts we believe that being open
is the best way to give an awesome
developer experience as I mentioned
earlier on one of the key advantages of
a service platform is having a really
good developer experience and we believe
that being open is the best way to
provide a really good developer
experience it's going to have awesome
Java support out of the box obviously we
are shipping with the service platform a
Java fdk which is our function
development kit it's a lightweight
unobtrusive library for helping you take
advantage of some of the properties of a
service platform it provides some j-unit
testing capabilities so that you can get
confidence that your code is going to
work as expected before you deploy it
and it's going to provide ways to ways
to access configuration and secrets that
are passed in and stored by your service
platform and it's going to offer type
coercion for to make parsing and
formatting your input and output as easy
and as safe as possible but it's not
just Java out of the box we are shipping
support for 15-plus stacks and because
our phase will be based on docker
underneath and you will have access to
that docker layer you can use
pre-existing docker containers or you
can use any platform that you care to
think about so awesome Java support out
of the box
capability to support any platform that
you that you care to think of today
we're also announcing FM flow so this is
a solution to the problem that I
mentioned up at the beginning of the
talk where you have these small function
small independent functions that you've
written and deployed separately you now
need to stitch those together into an
overall flow and you need to handle
errors and edge cases FM flow is our our
our answer to that problem there's going
to be open source too in the same way as
the rest of the FM project and we're
going to go into a bit of depth on that
later on in the later on in the talk ok
enough talking we're gonna do a we're
going to show you some code and do a
demo now I just want to tee up the
scenario so we're going to pretend that
we are a travel agent okay and we are
we've we've secured the services of for
third parties someone who's going to put
flights for us someone who's going to
book hotels for us someone who's going
to put car rentals for us and someone
who's going to send emails on our behalf
we've chosen the best in breed providers
of for each of these the best the best
of breed providers for each of these
flight provider likes us to interface
with their service through a Java SDK
that we that we that they've shipped us
hotels have got a ruby SDK that we would
like that they would like us to use car
rentals nodejs and emails emails Python
what we're going to do shortly is we're
going to develop a function an
individual function for flights hotels
cars and email sending booking and
canceling for each of those and then
we're going to develop a trip booking
function which lets us book a trip which
stitches all of those things together
and that's this these functions are
going to be reliable and scalable out of
the box and we're not going to talk
about infrastructure at all hopefully
okay
in the first part of our function we
first part of our demo we are going to
develop our first Java function to book
a flight so we've got a we've got a box
here which has got the FN CLI tool
installed this is all you need install
to get started with FN this is out of
the box and this is something that you
can install from our github eopns start
starts a local development server so
this will start a server on your local
box but is exactly the same as what will
be running in your cloud service this
lets you develop locally really fast and
keep keep you in the zone in the flow
next we're going to make a directory to
hold the code for our function and we
are going to run the F and init command
and we're going to specify a runtime of
Java what this is going to do is it's
going to create some boilerplate for us
here you can see is created a Java file
is created a test for us and it's
created this file called funky Amal func
camel is something that you will check
in to your source code alongside your
function and it describes a little bit
about it tells the service platform the
f-m platform how to run your function so
it tells it tells it that it's a Java
function and it gives it an entry point
in the form of a fully qualified class
name and then a method on that class ok
so let's have a look at the let's have a
look at the code that we've generated
we're going to show you in idea
hopefully so the the boilerplate is a
simple hello world function right that
it generates out of the box you can see
here this is just the Java that you the
you that you know and love it's a very
simple function that takes a string and
returns a string and we'll send you a
polite greeting when you call it so far
so good
we've also generated a test and this is
using our built-in j-unit testing
support there's a there's a rule that we
ship here that simulates the execution
environment of the f and platform so
that you can get to it to a very high
degree of fidelity so that you can get
really good idea that your code is going
to work as intended before you deploy it
and keep your development cycles and
agile and fast ok so effing has got the
concept the effing platform has got the
concept of apps and apps are a
collection of functions they group
functions together so before we can do
anything we need to create an
application we're going to create an
application called travel there we go
and then we're going to deploy our
application that we've just created do
the travel application and we are going
to do it with the local flag Owen
because we are developing against a
local server here then we can so now our
code is deployed to to the server and
and if we were deploying to the cloud
service this would now be live and ready
to and ready to consume by your users
we're deploying locally for the purposes
of the demo today we can now issue a
call and check that the function does as
we expect the FM platform includes with
it
a lightweight HTTP gateway so every
function that you deploy gets a URI
which you can call which you can call
from curl just in the same way that you
can issue the effing call command these
two these two are equivalent F and call
is just a wrapper around curl ok so what
have we just seen
we've seen that we've got a first-class
local development experience and we
believe this is something that sets us
apart from any other service off
offerings in the marketplace today
because we're open source we can that
makes things much easier right we've got
excellent unit testing support very high
fidelity you can run a local server
that's the same as that as is running in
your cloud service and then when you do
deploy to the cloud we're taking
advantage of docker layers so that we're
minimizing the amount of data transfer
that you that we have to push up to the
cloud secondly it's just Java right we
we didn't have to import or learn any
fancy new frameworks we just wrote a
very simple Java program
it's the Java that you all know and love
today okay so let's make our function do
something a little bit more interesting
and we'd like our flight booking
function to take some JSON input that
describes the flight that we'd like to
book and we'd like it to return some
JSON output that contains a confirmation
code for that booking right so we're
going to create some just some plain
plain old Java objects and pojos here
that represent the JSON so we've got a
flight booking request which we're going
to have our function take and a flight
booking response which we're going to
have our function return and for now
we're just going to return a canned
response from from this function
we've also so we've also got a sample
I've also got a sample payload sample
piece of Jason here so you can see that
this piece of Jason maps to the POJO
that we described just now so what
you've got here is we're not writing any
boilerplate we're describing exactly
what we expect our input and output to
be and the platform is taking care of
the marshaling for us actually behind
the scenes we're using Jackson and if
you need to tweak your serialization and
deserialization formats you can take
advantage of the full power of Jackson
to do that so when we deploy and run
this function now we're going to have to
pass it some input as I alluded to
earlier on functions take input on
standard in so here we go we're deploy
it we're building and deploying the
function we're building and deploying
the we're gonna build and deploy the
function just as soon as we've resolved
our networking issues there we go we've
built and deployed the function now in
order to call the function we're going
to need to pass it an input and we're
going to we're going to just pass this
sample payload and we can do that by
simply piping that into the F own call
function at the F and call command and
there you can see we have got the json
confirmation back
okay so what are we just seeing we've
got sensible defaults and extensible
when needed our default input input and
output type coercion z' try to do the
same thing for JSON formats but we have
an extensible api design that means you
can customize this to suit to suit your
environment and if you don't want to use
JSON then you can drop down to the layer
below and write your own input and
output coercion as to handle I don't
know maybe protobuf or maybe that
obscure wire format that your client
won't break backwards compatibility with
okay still our function is still not
doing anything particularly interesting
so let's let's have it actually try and
book a flight and what we have here so
we're starting to slowly bring in more
features of our function development
gate of our fdk and here you can see the
configure method which has been
annotated with the F and configuration
annotation and this will get called once
at the beginning of when your function
is is first run and it will be passed a
runtime context this will let you fetch
configuration and secrets in this case
we need a URL for our flight provider
and we need a secret to authenticate
with that flight provider our flight
provider has provided as I mentioned
provided a Java SDK so we can go ahead
and use third-party libraries or other
libraries in Java just just as always
and here we're initializing our
providers SDK with the URL em secret
that we're getting from the effing
platform and we're going to in the book
method now we're instead of returning a
canned response we're going to call to
our flight provider and we are going to
return the confirmation that we get from
get from them
okay so before we can run this function
we need to provide the configuration to
the function f and provides a couple of
different ways of doing this first is on
the command line we can provide config
to our function like so and we can also
provide configuration in the funky funky
ammo so here you can see we've provided
the flight API secret and the flight API
URL in different places you can also do
this either at the function level which
is really handy because it will let you
isolate secrets
so our flight function only knows the
secret for the flight function the hotel
only knows the authentication password
for the hotel function or you can do it
at the app level where you've got some
where you've got some global config set
for all of the functions in your app so
now when we call this now when we call
this function we are calling off to our
flight provider and we are getting back
any confirmation in the same format as
before so where did that confirmation
come from I'll let you into a secret the
flight provider is a fake and all it's
doing is calling out to this dashboard
and returning a canned response this
lets us see what's going on behind the
scenes so you can see the requests here
against the flight provider on the left
hand side and that's where that
confirmation number has come from and
we'll make more use of this dashboard in
subsequent sections of the demo ok so
what are we seeing flexible
configuration still just Java but you've
seen us start to pull in small parts of
the the function development kit it's a
tame it aims to be unobtrusive and that
you can pull in just the parts that you
need as you need them so we've we've
enabled easy access to configure to and
configuration with your functions and
you can use this is still just Java
right you can use the party libraries
as usual okay next part of the demo
we're going to create we're going to
create the rest of the functions and
we're going to do this in one go right
we're going to create the the flight
cancellation functions we're going to
deploy the Ruby functions for booking a
hotel we're going to deploy the nodejs
functions for booking tasks and we're
going to deploy the Python function for
booking for sending emails now f'n has
an app level deploy command so we can we
can go to the command line and we can
and we can effin deploy - - all and this
will now deploy all of the functions in
this application so it'll it'll search
the current directory for any funky
amell's and it will deploy all of those
functions so you can see it's now going
up going ahead is pushing ruby it's
pushing nodejs
and we can we can list all of the
functions in this in our application you
can see all of the see all of the
functions in our application here so now
we've got a function and a URL for for
booking and canceling flights hotels car
rentals and for sending emails
we also are now going to configure each
of those configure each of those
functions so that they know where to
where where to talk to for their
provider endpoints and where the secrets
are okay
so we've got a whole bunch of functions
that can book hotels and book flights
they just call out to our fake providers
so we can see what's going on these are
small isolated functions they all do one
job they do them well and because they
are small we can isolate secrets to just
those tiny bits of code which give us a
really good security posture for our for
our application what we need to do now
though is stitch this together into a
trip booking function so we need to be
able to our customers want to be able to
book a trip which includes a flight a
hotel and a car and that only needs to
do so reliably it needs to deal with
full flights Act hotels and empty car
rental Lots we want to confirm each
reservation or we want to make sure that
no reservations have been made at all so
we don't want a flight being booked
without without a car rental for example
this workflow or composition problem is
actually a general one that most service
applications reach when they get to some
level of complexity there are too naive
approaches that we might take to solve
this problem so first of all we might
create a top level master function that
makes that makes our flight booking call
blocks waits for the response makes our
hotel booking call blocks rate waits for
the response makes our car rental
booking call blocks waits for the
response that's okay it's going to be
nice and easy to understand but you're
going to lose lose some of the nice
capabilities of a service platform
you're going to be consuming resources
for the whole time that that function is
running but most importantly you're
going to have a reliability issue if
that function stops working somehow for
some reason either either for
infrastructure or because you don't know
your JVM crashed or whatever who knows
if it stopped working for some reason
you could be left with a trip that's in
an inconsistent state that's maybe got a
flight booked but no hotel booked and
all of a sudden you're having to write
lots of complicated code to go and check
the statuses of your various bookings
and undo and so on
another approach another the second
naive approach might be to chain one
function
to the next so you might take your
flight function and have that call the
hotel booking function and have your
hotel booking function call the the car
rental booking function that quickly
becomes a maintenance nightmare because
all of your upstream functions have to
know everything about the downstream
functions in order to take and pass the
right bits of information along error
handling is horrendous and collecting
all of the results together can be can
be quite tiresome to deal with so we get
to the point of needing an external
coordination service that you can
configure to call your functions pass
data down the down the graph and deal
with errors in the past this has meant B
pal or some other external workflow
based DSL and today the answer from
other clouds amounts to the same thing
but in Jason with fantasy visual
programming front-end we think this
approach has several issues that
prevented serious usage the first time
around with B pal and will continue to
do so continue to apply today so first
of all not all problems map to walk to a
nice state machine nice clean state
machine approach when you start to think
about error handling in that model you
end up adding a lot of complexity to
your workflows it's very difficult to
test these things because you're running
an external DSL it's even more difficult
to debug these things when they go wrong
and you end up having to run and
maintain and operate this external
orchestration service which is going to
be calling your functions and dealing
with the data you also end up writing a
lot of glue code which extracts the bit
of information from the response of one
function and formats it ready for
inputting into the next function so you
end up with a huge explosion in the in
the number of functions and bits of code
that you need to look after and maintain
and finally it's another set of
technologies and tools and practices to
learn and cope with
we think there's a better way so here
we're going to introduce F and flow it
occurred to us that Java already has an
API a mechanism for composing
asynchronous functions the completion
stage API which was introduced in Java
right and has been improved
significantly in Java 9 provides a
really nice tight safe promises style
API is lets us compose a graph of
asynchronous computations that lets you
specify concurrency fan out fan in a
bunch of other distributed programming
principles so we thought what if we
could use this API or something very
similar to it in our favorite language
Java of course to compose serverless
functions so we wrote a service that we
call the computer that can store and
trigger the execution of these
computation graphs and this backs a java
api that looks a lot like completion
stage and we're announcing this this
week it's going to be part of the f and
platform of the server side and the
client side is going to be open sourced
in exactly the same way let's have a
look what it looks like
okay so we've got a new empty function
excuse me which is our trig function
we've created some we've created some
pojos to take the input and the output
the the input takes a flight hotel in a
car request and wraps it into into one
object that corresponds to some JSON
that looks like this gone out of order
yeah some Jason that looks like this so
that's the same exactly the same
mechanism we saw earlier on and what
we're going to do first is we're going
to just call the call the flight booking
function so each function operates
within the context of what we call a
flow and you can access the current flow
using this flows current flow method the
flows dot current flow method has a
bunch of further over flows door current
flow object has a bunch of methods on it
that let you trigger and sequence
asynchronous computations in this case
we're using the invoke function method
which lets us invoke other serverless
functions on the f-m platform this
returns a flow future object which is
very much like the completable future
object in in java and this this in turn
contains operations for chaining more
methods for chaining more computation
when we get the result back from the
from the flight from the flight call so
what what we're going to what we're
going to see here when we deploy and run
this is that we can call the trip
function with our with our jason that
contains all of the information we need
to book a trip and then we are going to
then we're going to execute our flight
function with just the information we
need to book a flight so our flight
function is still the the nice
independent function that does one job
well
and the the trip the trip function is
going to deal with feeding the right bit
of data into that so we should see there
we go it's done exactly the same thing
so far so far so boring
next we are going to use next we're
going to use the then compose method on
the flow future so then compose takes a
lambda that takes the result of the
previous computation and returns another
future that represents the rest of the
computation that you want to do so we
can use this to chain functions together
and we're going to chain the hotel
function onto the end of a call to the
hotel function on to the end of the on
to the end of the flight function and a
call to the car rental function at the
end of the there we go as if by magic at
the end of the hotel booking function
and then we're going to use the when
complete method which happens right at
the end of your computation to send an
email to our customers that contains all
of the information so an important thing
to note about this code is that because
the results from the flight call the
hotel call in the hope and the car
rental booking are all in scope when we
send the email we can use those values
to to compose the email the platform
deals with making sure that those values
are in the right place at the right time
and each of these each of these calls
could be happening on different JVMs on
different hosts different over a long
period of time so when we deploy and
call this function we've got something
out we've got something a bit more
interesting we should see a call to the
flight API a call to the hotel API and a
call to the car API and finally we send
an email to our customers which contains
all of the confirmation numbers from
each of the stages so we're doing a
fan-out and we're doing a fan
fan-in chainÃ© chainÃ© calls and a fan
in with the results okay so what if one
of our providers is unable to handle one
of our booking requests let's say for
example that our car provider has run
out of cars in between our users
searching for the trip they want to book
and then pressing the book button we
need to introduce but but by this time
we may have already booked the flight
and the hotel so we need to introduce
compensating transactions if we get an
error
booking a car we need to then get back
undo the hotel and the flight booking
this is a this is something known as the
an implementation of the saga pattern
what we're going to use to do this in
the FM flow platform is the
exceptionally composed operator this
lets this is a bit like a catch block in
Java
it lets us it lets us compose new work
into the graph in the case that an error
has happened in a previous stage and you
can do anything you like in here you
could use it to supply a default value
you could use it to maybe retry or you
could use it to alert and operate or
whatever works for your use case
handling handling faults and your
application okay we can so here so here
Owen has put the exceptionally compose
operator in the appropriate point in in
the graph so that if we get a failure at
any point in this graph we're going to
try and undo the the previous actions
now our fake how our fake API dashboard
has the ability to has the ability to
inject a fault so we're going to inject
a fault into the car-rental booking
function this time when we call this
when we call this function we expect to
see some compensating transactions
happening so we see a successful flight
booking a successful hotel booking we
see a failed car booking and then we're
going to try and cancel the car cancel
the hotel and
cancelled the flight and we also send an
email to our users telling them that we
had a problem whom they might need to
try again at this point I'd like to
introduce the the flow UI so this is an
experimental UI that that lets us the
attempts to visualize what's happening
during this flow so if you go to if you
go to an earlier and it works and it
works live as well so you can see
feedback on how your flow is evolving
how your flow is is happening and as
it's happening time is on the x on the x
axis the y axis is roughly dependency
order of functions and you can see the
pending events the things that the
platform knows about on the right-hand
side selecting a node will let you will
let you pull the logs not just for that
node but any node but for any function
call that precedes that function so you
can really dig into detail and work out
what went on here and we can also see on
the right hand side the compensating
transactions kicking off in order
okay finally what would happen instead
of instead of failing to book a car the
car provider was down entirely we can
simulate that on our fake API dashboard
by setting the car cancel function to
return an error - in that case we'd like
to retry the cancelling of the car we'd
like that we'd like to we'd like to
retry the cancelling of the car so we
have come we have a retry helper class
here and what's really interesting about
this is that we're just using
capabilities of the FN platform like
exceptionally compose then compose and
delay to implement an exponential
back-off algorithm this lets us very
easily specify retry semantics without
making a hard code without making our
main flow to to much more complicated
extracting these higher-order patterns
for reuse in in your apps is a really
powerful feature of flow and actually
the completion stage API is - right so
this time when we run our flow we should
we should see a flight being booked
successfully a hotel being booked
successfully our car API is down so we
failed to book a car we try to cancel
our car but that fails because I car ate
the is down and we cancel our hotel and
we cancel our flight but we also see if
you go back to the SDK dashboard we also
see the platform retrying the car
cancellation looking at that in the flow
UI we can see here that while we're
while we're waiting for the retry
there's nothing happening there's
nothing consuming nothing consuming
resources this is not a blocking
function this is the the retry and the
delay is being handled by the by the FM
flow platform
effing flow also has some really great
unit testing support but we're kind of
out of time to show you that today so
let's let's recap what have we seen it's
still just Java right we've developed
this we've developed some small reusable
functions in Java in plain old Java and
we've we've deployed them to a platform
that can deal with scaling isolation
security deployment all of the
infrastructural concerns it's not just
Java though because we because we're
based on docker and because we ship out
of the box with a whole bunch of other
language runtimes we support anything
that you would care to write your
applications in this lets you choose the
the best tool for the job and we've had
a go at solving the workflow problem in
F and flow which is a bunch of
distributed programming primitives that
you can use to build scalable and
reliable service apps what we think this
is we think this is a really interesting
technology because it lets you it lets
you reason about and test your entire
service application in one place you're
not programming programming in JSON or
XML or some other some other external
coordination technology you can then use
the the first-class unit testing support
to make sure that it's doing the right
thing
in your build and in your continuous
integration so stay connected we've got
we've got this talk again a couple of
times this week if there's anyone else
you know who might be interested to hear
about the F and platform we're
announcing it officially in the Java one
keynote this afternoon so go along to
that that's going to be really exciting
we've got a hands-on lab where you can
get down and dirty with the F and
platform on Wednesday afternoon I can't
remember the time off the top of my head
so get yourself get yourself to that
there's a bunch of social connects here
follow us on Twitter and follow these
links to find out about other sessions
from folks in in our organization I
think we've got a few minutes for
questions so I think
question is now yeah if you could just
go to the microphone I'll repeat the
question if you if you so the question
was when we were retrying the car
cancellation was that done with
asynchronous processing or was that part
of the the same FM flow and the answer
is that standard asynchronous processing
it's part of the same the same flow but
there's no blocking calls there yeah
so the question was that when companies
start to roll out cloud or service
solutions there are security concerns do
we have to implement our own
authentication and so on we don't have a
good answer to that today that's
something that we're working on in our
roadmap over the next couple of months
the FM platform supports adding
middleware for authorization and that's
what we're going that's the
functionality we're going to be using to
plug into Oracle's authentication
services in our cloud service I would
imagine that we will also be developing
or or working with our community to
develop plug-ins for other common
authorization providers so the question
was that you said we can use any
language but the flow stuff requires
Java today you're absolutely right yes
the flow API is only is unique to the
Java fdk we have some skunkworks
projects to see what that might look
like in Go Python and nodejs
but they're there really early we do
intend it to be beyond Java but today
it's it's just Java the server side is
actually written lingo
so the question was when you change the
functions together in a flow that lemis
can you still can util execute them as
single functions yes you can and it
won't trigger the rest of the flow the
flow only gets triggered when you call
the master flow function
so the question
so the question the comment is that when
you when you compose functions into a
flow you can't assume that they're going
to be scaled independently but that they
will have to be scaled together and
actually each individual function call
can can and will be scaled scheduled and
scaled on the underlying functions as a
service platform independently
so the question is what sort of inbound
asynchronous events will be supported
here today we only support HTTP triggers
we are aware that we need better richer
support for a wider variety of inbound
triggers but today HTTP only any other
questions great you've been a great
audience great questions thank you for
your time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>