<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Class Transformer: One of the Best-Kept Java Secrets | Coder Coacher - Coaching Coders</title><meta content="Class Transformer: One of the Best-Kept Java Secrets - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Class Transformer: One of the Best-Kept Java Secrets</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/w9UphtuJQvg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome my name is Angela and it's
pleasure to stay here and tell you
something about our class transformers
cluster Samus were introduced into Java
in this Java 5 so ten years ago really
long long time and I think they are the
one of those parts of Java which are the
best-kept secrets in Java because ten
years ago and probably no one will know
them
if you submit a talk to a conference you
have to think carefully about the
content of course but you also have to
think about thank you very much to think
about the title and this title is also
fine for my talk in fact I will do two
demos and in the last demo I will show
you how you can pass all of your unit
tests okay so one slide about me I'm a
professor of computer science I've
written some books about JSF JPA and
jayvo seem so usually I'm working with
Java EE not Java se but it was really
interesting to look into class
transformers I was also a member of the
expert groups of JSF - - and shake a 2-1
so what I want to do is I want to first
introduce class loaders because most of
transformations are done while classes
are loaded into VM
after that I will skip to transformers
and there are two different types namely
a redefinition and we transfer me I will
show you later
what's the difference okay so probably
most of you were application developer
and if you are application developer you
properly can take much with you because
probably you will not transform your
application like I do with my demos if
you are a favorite of ellebra you will
already know how to transform classes
and then the main point is you will stay
at JavaOne because you want to learn
something and I think this is best kept
secret so you're right in this talk to
learn something about how classes are
loaded and how classes can be
transformed even if you will not do it
in your projects and because of unit
tests maybe we also have some fun in
this rocket at the end okay so let's
start with class notice how could how
classes get into the VM so if you
remember your start your programming
like a year so there was a professor or
teacher and he told you that classes get
loaded into the VM full stop end of
story and it's enough for hello world
level but it's not not enough for you
because you you're building real systems
for example the class loader in Java one
oh and one one was broken there was a
research paper showing that the fully
for the fully qualified name is not
sufficient you can do some tricks and
we mmm can change classes and the type
system is broken because JVM thinks it's
class 80 but it's Class B so this was
fixed with channel 1 2 and if you work
with Java you will notice that there are
some JDK methods which have a parameter
of type class loader and there is also a
class abstract class class loader so you
have to think about class loaders if you
are working up after hello modular and
if you are doing Java EE and you
remember the old days years and you have
to specify which war can see which
classes in a year it's it was important
for Java EE in former times it's also
important out but but not that much like
before if you look into the spec I have
taken an 86 but in this edition this is
just the same you can see that Java EE
is really unspecial unspecific about the
class load to use so in each application
server manufacturer builds his own class
loader and he old
only has to conform to some basic rules
about class loading and Java so it's not
really a big thing what does the virtual
machine has to do if I don't know
English
if VM has to loaded so it first has to
load the class it then has to links it
and then it has to initialize it so what
we need is loading loading means given a
string which is the name of the class
find some binary representation most in
most cases it's written in the in the
file system but it can be read from URL
or whatever you can think of so linking
means put this class into the VM state
and make it can be used and then last
there is a method called class we
mention CL in it which is called to
really initialize this class so let's
have a closer look at loading and
linking on loading creates a class
object and linking consists of three
separate steps namely verification
preparation and resolution verification
means that there are some checks that
the class will be well behaved sorry can
I step out - no sir but that's
if your step consistently closer they
can turn the game down and you'll get
lit okay I will try I will try thank you
so what kind of checks are there there
are many checks for example one check is
that you don't overwrite final methods
that you call a method with the correct
number of parameters and the correct
type of parameters and in general if one
of these checks fails there is a
verification error and for you as a
programmer it's very difficult to write
programs which which throw in a
verification error because it's it's
mainly impossible to to do such things
if you're using a compiler but for
example you know all that if you write a
constructor the first statement in this
constructor has to be a call to the
constructor of the superclass so if you
don't do this the compiler will do it
for you so you have some problems to do
this wrong but if you probably heard
about it there was a problem in some
months ago in August when the jdk
engineers built this verification step
into the VM with Java 8 update 11 so it
was there in the spec since Java 1o
which means 20 years ago but the
verification step was not taken so they
introduced it in update 11 and there are
some systems which are broken afterwards
because for example I will also use Java
as my examples if you're using Java
assist you can do wrong things things
which the compiler will never do but you
can do it by hand so this is the problem
here
okay preparation preparation means there
is storage allocated for the class and
class variables are prepared to be
initialized but it's take not takes not
place at the moment so resolute
resolution means that if your class
references other classes uses other
other classes so these other classes
have to be loaded too
so when when we go to to my Ju and test
example if you call J unit by by and by
command lamp I may even surefire
whatever there will be some J unit
analysis loaded of course
then your test analysis will be loaded
and then the class is to be tested will
to be tests will be loaded and so there
are dependencies and all the classes are
loaded one after each other okay if all
the classes are loaded then the class
variables and static initializer blocks
are executed and initialized okay
maybe you attend tutorial not a top at a
tutorial this morning at a thirty from I
don't remember the name but it was
plumper guy and he told us also that
each class has a reference to the class
loader which loaded this class so this
is important for some memory leaks class
loader leaks if you look into the
documentation of class class loader you
will read things like each class loader
has a parent a parent class loader and
if you ask it last so a piece load at
last the class loader will not load it
but first ask the parent please load
this class and only if this is not
possible
the class is loaded by the door itself
so if the parent is asked and this asked
the other parent the next parent the
next parents there must be some some end
and this end is called the so-called
bootstrap class loader and this also
things hold true since Java 1.2 but the
the lower part is new in 1.7 Java 1.7
1.7 introduces parallel capable class
loaders it works it works too loud for
for example if you start while fly or
another application server the wild fly
guys had developed parallel capable
class loader and you will see that my
four CPUs are raising up almost to 100%
so it's very interesting that before
Java 8 and before parallel streams and
and whatever and there was a 20 in in
Java 8 some guys really think about how
to make things more faster ok
so probably I will there so next slide
there is some chicken and egg problem
before the class loader can be used it
have to be loaded so who did this and
because the class loader is a normal
object and extends javelin object who
loads java.lang object so this was
already mentioned it is a so-called
bootstrap class loader and because of
this hierarchy there is some kind of
there because of the delegation there is
some kind of hierarchy formed so on the
top level of the hierarchy there is a
bootstrap class loader this is almost
always implemented in C or C++ there is
no class no towed class a file
representing this it's built into the VM
and this class loader loads for example
Java LAN object Java long string because
they are in runtime jar so then comes
the extension class loader which loads
extension so this is the first really
class Java class and this is the
extension class loader so next comes the
application class loader this is the
class loader which will load your
classes if you are do not working in
Java EE if you're doing programming in
Java SE and you don't write your own
class loader this last order is the one
which will load most of your classes of
your application and then of course you
are free to build your own last order
it's not that complicated and probably
some of you have already
don't last order and if you don't want
to go to it by yourself you can download
from Chavez and class load which is
called Chavis modules and this is also
the class load which is you was inside
wife lime I showed you okay okay there
the hierarchy is bootstrap extension
application class loader and then all
the custom class daughters can you prove
that this is correct what I tell you
yes you can there is an option to to
Java which is burbles : class and this
option will print all loaded classes
line by line what I did here is I
deleted many lines though at the bottom
there is line 384 but I deleted all all
the lines where no class loader
substring appears and there are many
many class loaders involves four in it
at the start there is object and
serializable to be loaded but then there
is some class lower delegation class or
a class loader within a class native
secured class loader and so on and there
is the system class loader and and your
ex passed loader and at the very end my
maintenance is loaded and for example
because the wipe method sorry is a main
method is void also the type white is
loaded and then hello world sprinted out
okay also very interesting is that the
class class loader has a field parent
and if you remember if your all the guys
as me so maybe you have a program in C
and C++ and in C in C++ there are
pointers and offset to pointers in Java
there are no pointers but references and
there are no offsets at all but if you
look at the documentation of the parent
field you will reach something
this is the parent class order for
delegation this field are now very
interesting note VM hard-coded the
offset of this field thus all new fields
must be edit after it so it's really
nice to eat such commencin in Java
programs I think ok let's skip this and
this is the slide also a copy from class
load documentation which states that if
at last Oh rise to load at last it has
first to ask the parent so is all very
well documented and you have you know
what you have to program if you're doing
your your class loader because class
loaders first try to ask their parents
to load classes this strategy of class
loading has a name and it's called
parent first and I told you that if the
same class is loaded by two different
class loader this classes have to be
different in the in the JVM to prevent
this Java is no type safe Aurora in its
paper but this small program shows you
that it's not so easy to to do this with
some built-in classes I will change for
example I define two class loaders of
type your edge not loader and so of
course these clans loaders are different
then I load the same class here by these
two loaders into class one and class two
and these two classes are the same why
because both are a class loaders ask the
parent and the parent is only one namely
the application class loader so these
class loaders don't load these classes
but the applications
loads it and therefore it's it's really
the same class inside the VM okay so I'm
now finished with the class loader stuff
and I will step into transforming
classes and the first we will do is
answer the question is there life before
main this is also something like first
semester you're teaching students at
university that main is the first entry
point of your programs and this get gets
called automatically by the VM and it's
not possible to do something before and
of course it's possible to do something
before and it's not easy not very
difficult it's very very easy okay I
already mentioned instrumentation was
introduced with Java 5 10 years ago 2004
very old stuff and if you read the
documentation you can reach that
instrumentation allows Java programming
language agents to instrument programs
so if you don't know what
instrumentation does mean you go to
Wikipedia and look into it and they will
tell you that instrumentation refers to
the ability to monitor or measure the
level of a product's performance to
diagnose arrows and to write trace
information so as per Wikipedia it's
primarily used for monitoring and my
first example is a morning monitoring
example but of course you can do with
transformation whatever you want to for
example if you have to write a JP a
provider probably you will do some kind
of instrumentation if you write some
test coverage tool probably you will use
some kind of instrumentation ok this is
also from the spec on java.lang
instrumental commentation so it's very
robust so I sum up on this slide an
agent what is an agent an agent is
something which is deployed as a jar and
inside the jar there is the manifest and
the manifest has to name the three main
class there are different alternatives
to start an agent if your Java
implementation is a command-line
implementation and hotspot is it because
you can write in a command on the
command line Java and it will start the
VM and there must be some possibility to
to start the agent this is in spec and
it's a requirement if the VM already
runs and you want to connect an agent to
a running VM the documentation says that
there can be something to connect to the
VM but this is optional so the VM is not
required to do this and it's
implementation dependent so you can do
whatever you want to connect the command
line my command line is very easy there
is an option to Java to the travel
command which is Java agent :
and then you name the jar file and you
are allowed to use this option as many
times as you want so you can load as
many agent agents as you want the
attribute in the manifest is called free
main and there is your remain your sorry
your agent class has to implement a pre
main method and after the VM is
initialized all free
main methods of all agents are executed
so you are allowed to to define as many
agents as you want and all the pre main
methods are executed and then the main
method is executed so of course it's
very easy to do something before main
the pre-made method is overloaded the
string parameter is the parameter of
this option so in this string there is
so this is one string and it's put into
these two arguments and the
instrumentation is some kind of
injection you get the some some handle
into the instructing instrumentation
package inject it and you can use it in
your agent okay there's also a method
which you can write which is called
agent main but this is only used if you
start if this is not used if you start
applying the command-line option but
this is used if you connect to the
virtual machine later after it's started
okay so the agent is loaded by the
system class order which is the class F
class loader and the it's not like in
the main method where you get an error
of strings you really get only one
strings only one string and you have to
parse this string into the separate
options if something goes wrong for
example if you mention the mink the pre
main class but it does not contain a
premium method or it is contained and
it's Rosanne exception the VM is stopped
so it will not run further so the big
question is what can we do with this
knowledge what what's the use cases for
agents so you can of course monitory and
I will show you that it's very easy to
monitor
you can build some proxies for example
if you have to implement a PA you have
to to implement associations and in the
Association method there is only a
return field but in fact you have to to
execute some sequel against some
database you can you have to do some
automatic data checking and such things
for example you can delete a final
modifier and therefore you can override
a method which you cannot override in
other circumstances or if you're
building some test coverage tool you can
mark you can insert some code to mark
all the pieces the J unit tests will
take so in general with agents and
instrumentation you can attach desirable
desirable behavior afterwards and only
if needed so there was a slide in the
beginning where I said if your
application programmer probably you will
not use this in your daily work but if
you have a use case attach desirable
behavior afterwards and only if needed
so you can use it of course ok so let's
do some monitoring this is a very simple
task and I want to count the number of
invocations of method foo what to do I
program the monitor class and there is
only a counter field and then in my main
method I call the Foo method and I print
out the counter error before the loop
and after the loop and of course it
prints 0 here and 0 here no magic of
course but then I do my agent so it's a
very simple agent only one pre main
method and the pre main method uses the
inject the injected instrumentation in
instance and registers transformer and
on the next slide I will show you how
monitor transformer does look like and
you have to mention that this class is
your agent that means that you have to
write in your manifest pre main class
and then : name of class okay let's go
into the details of monitor transformer
so I use Java assist a transformer has
to implement the interface class file
transformer this interface has only one
method namely transformer and I only use
this parameter class name or there as
our parameters I don't use so what I do
is I check if the submitted class name
is this class I want to monitor and then
I try to get some J's Java assist handle
to to get the code for this this class
then I ask the class please give me your
method Java assist is a very easy to use
bytecode manipulation framework because
you don't have to write byte code you
can write Java and the method insert
before the Java assist method insert
before just inserts a Java statement
before the existing body of your method
so I simply add counter plus class
and then I have to return the area of
bytes which is also very simple in West
Java assist and all other classes are
remain Unchained so only this class gets
some some change and if you do this and
run your main one more time
the counter will be so at first output
and one thousand at the second output so
it's very easy to write your own
monitoring system ten lines of code or
so okay dot that's the easy part
and now we want to connect to our
running virtual machine and execute an
agent in running virtual machine so the
question is how to talk with IBM there
was some spots before already some
sketch of the instrumentation package
documentation and this documentation
mentioned that implementations may also
support a mechanism to start agents
after some time the VM has started and
also some warning this is implementation
dependent but I have checked the most
popular popular implementation and
hotspot of course but also Dre rocket
IBM and SCP s AP SDK supports this
because they all use tools dots are
probably you know tools dot jar there
are some really interesting classes
inside and there is also one class
inside which is called virtual machine
this is the interesting class if you
want to connect to a running machine
- running virtual machine so if you look
at the documentation of class virtual
machine you can read that instances of
virtual machine represents a java
virtual machine an application uses a
virtual machine to load an agent so this
is the entry point to a running Java
system this virtual machine there are
some important methods to mention there
is some kind of a factory method which
is called attach and where you have to
submit the operating system process ID
of the running virtual machine and then
there is a method called load agent when
where you can load the agent and after
the agent is loaded the agent main
method is called similar to remain
before ok the agent main method is very
very simple it a simple similar to on to
remain it has the same signature but you
have to change the manifest attribute
you don't have attribute pre main but
agents math and there are two more
attributes namely can redefine classes
and can we transform classes so if you
change the already loaded class
definition with a complete new
definition you are redefining the class
if you ask the VM for the bytecode of
the already loaded class and you only
change some of the bytes you re
transforming at last okay in this the
the first demo I will show you I will
show you that
there is a class called class to be
redefined with methods say something and
it simply prints foo but there is also a
second instance of this class which
simply prints power or the other way
around
doesn't matter the agent simply
remembers the injected instrumentation
in instance though though I do it with
some variable here and I remember here
what what is injected and I have to
define the very defined classes and this
simply calls the remembered
instrumentation instance and call we
define classes with the same parameter
it's very very easy so the main class in
maintenance I have a problem because I
for the demo I have two versions of the
same class of the class to be refined
and it's not possible in in a JVM or in
with Java to have two classes and it
last passed by so it's possible but you
don't know what what will happen will
take happen so what I did is I put one
of the versions into a file called dummy
here and I load the content of this Java
class file into a byte array and then
you have to define a class definition
and the class definition consists of the
class itself and the defining class
which remains the array of bytes then I
load the agent and then I call agent
redefine classes
I get an instance here and I call the
method and I call the message after the
class is redefined and it prints your
full edit prints here are and it's this
is Java SE version five no magic at all
the next problem is how to connect to
the virtual machine and there is a
runtime MX pin and this runtime annex
pin are returns the name of itself with
process ID add name of main class so you
only have to select the process ID
operating process ID and you have to
call virtual machine attached on this
process ID when you load the agent and
if you are gentle you detach though it's
not not possible it's not necessary
sorry so that's all so you attach to the
machine and you load the agent and after
the agent is loaded its get it gets
executed easy isn't it okay so demo
for the demo I changed the program a
little bit and I made it easier but more
impressive easier because the main
method simply is a loop and it always
prints calls the method and prints foo
or bar I don't remember and the attacher
I will attach from a different virtual
machine so on the slides I execute in
the same virtual machine the attachment
so it gets the process ID of the own
process but here I will attach to the
process to the process ID of another
virtual machine and this is really
really impressive I think you can check
yourself so what I will do in the upper
window is I call the loop and then of
course I have to have a twister jar in
the glass pass I will check the ID which
is sorry
I will try it one more time into my
copy/paste okay and paste 504 Oh and now
I execute the attachment in another
virtual machine and you have to to look
at the upper window so really impressive
yeah okay so to be honest I use I'm
using not Java assist here I'm there is
no external library it's all Java SE
standard stuff
no no library no framework at all it's
only Java Java 100%
and okay what can you do with redefining
classes so redefining first it means
that redefining is the replacement of
the definition of economic class without
reference to the existing class file if
you want to use the existing class file
you have to go call retransform I told
you already it's also is interesting is
if there are instances of the class and
if there are active stack frames is
there defined what what takes place and
it is defined if a redefined method has
active stack frames those active frames
continue to run the bytecode
of the original method the method the
redefined method will be used on new
invokes and what are you allowed to do
you may change method bodies constant
pools and attributes but you are not
allowed to add remove or rename fields
or methods change method signatures or
change inheritance hierarchy so if you
remember the research paper that Java
one one was broken this is mainly
probably because of this but there is
also written that these restrictions may
be lifted in a future version but the
last ten years there was no restrict
lifted restriction so maybe because of
the proc type system okay we
transformation is also possible if you
want to retransform you have to set your
attributes can which we transform
classes to true you have to register the
transformer and you have to call
retransform classes instead of we define
classes and it's really that easy
so what I will show you now is how you
can pass all your unit tests so this is
a very simple class with two methods the
first should return the cannoli class
name which means it should return what
is commented out but it returns
something wrong and the second method
should return the sum of two ancient
integers but it returns the product so
all methods are completely wrong so the
the J unit tests no magic at all
probably you write it exactly the same
okay let's write the transformer so you
already know there is the transform
method inside this interface and I'm
using I'm still using this string class
name and what I will do is I will change
J unit yes so you have to do some tricks
if you want to pass all unit tests so if
this class is really the J unit research
class I call my message transform assert
in this method I get some Java assist
handle of this class and if you look
into the sources of this a search a unit
class the method the assert dot what
methods are not boolean methods they
don't return true false if the assertion
is okay or not but they throw an
exception if the assertion fails so what
this Java assist code snippet does
I iterate over all methods in this class
and if the class starts with assert I
changed the complete method body I throw
away the old and simply put in return so
there will no exception be thrown and
therefore the test the third method will
succeed it's very easy I don't know
three lines of code no magic inside and
it works so now I'm the agent and the
interesting thing in the agent is that
there is so you get injected from the
runtime and an instance of
instrumentation and you can ask
instrumentation give me all the classes
which are loaded already and now you can
iterate over all classes and if the
class is Akshay unit research please
transform it it's very simple
okay there is still one problem
how can you activate this agent probably
you will do it in your in the class
which is unit tested so if you remember
what I told you about class loading if
the J unit classes are loaded they will
load your test classes and the chest
classes will load the classes to to be
tested
and then all the aesthetic initializer
blocks of these classes get executed so
for example if I insert my load agent
inside this static initializer block
before the first Ju net assert is called
the agent is loaded and it will
transform all the assert methods okay
okay so seeing is believing
so I haven't changed anything it's the
same as on a slide so there is a class
to be tested and there is a unit test
and if I run it as a JUnit test of
course there are two failures two
failures of course but if i uncomment
this and I rerun everything screen okay
so I'm at the end of my talk so I told
you before probably you will not use
this in your daily work next week
probably but I hope you have some fun
maybe you can go to your boss and tell
him I will not I will never fail I will
do no more mistakes anymore oh please
more money so but this is the real point
you know now better that Java is very
you can very impressive things with Java
out of the box okay thank you very much
questions so I was a little bit unclear
on the difference between we want so to
be honest I didn't retransform it
because re-transformation means you get
injected the already present definition
of the class file and there are some
bytecode manipulate manipulation
frameworks which are working on the
bytecode level so you can use this
change some bytes in return and this is
different then I don't know if it's in
place I think it's called by value and I
think it's it's okay to to return a new
one but redefinition redefinition means
you independent of what is already
defined you create your byte array and
put it into a we transformation means
you look at to the byte array of the
already loaded classes and you change
itself something in this fight array
this is the difference between video
great definition and real transformation
there is nothing and there is no
compiler involved at runtime so at
runtime the Java assists the framework
simply changes the method body of the
cert methods so I do not compile at
runtime no because Java assist returns
bytecode it's a it's a bike of
manipulation package a framework and but
it works on Java syntax level there are
also bytecode manipulation packages
working on the bytecode level so what I
do here is I get some of the I don't
know 20 or so assert message starting
with the cert and I simply replace the
old party with the new party and the new
party is only the return statement and
there is no compilation because Java
assist transforms this to bytecode Java
assist knows the old bytecode of the
method and the old gets thrown away and
the new one which is only the bytecode
for original gets put into
I don't know I don't get the questions
do not get it but I I thought about I
have some ideas how to to read further
on this and there is a compiler API in
Java so you can compile at runtime
what you can do is you can without Java
assists only compile something in loaded
the reciting bytecode into Java so
you're you're not enforced to use some
bytecode manipulation package but you
may be in some use cases you can use
Java alone Java SE alone without
external library because
as a possible yes yes yes yes yes yes
I don't know if I have it on the slides
but if it's just flowing time there are
some security managers involved so you
can I don't remember I don't have it on
the slide so you can install some
security manager and the security
manager prevents from redefine classes
or load wrong classes or so
this is something like a discussion the
some all Christians so I'm you mean run
time cost sorry I don't know I don't
know if this is if this needs some some
effort but what I know I told you I
wrote some books about APA so all JP a
provider transform classes if they get
loaded and so if you re if you are using
an application server and the
application server does it automatically
but if you for example use eclipse link
you have to enter open JPA from Apache
you have to use - - Java agent to do the
transformation and all almost all I'm
not sure about I have a night hibernate
is really smart and maybe they don't
have to do it but open jba and eclipse
link only works because they do some
transformation stuff I'm sure and it's
it's only done one time at class loading
at if you're using JPA so it doesn't
matter if it needs one second or so I
think it's nothing I think it's not
important because it's only some
thousand bytes to put somewhere in the
VM
okay thank you very much so coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>