<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Hybrid Mobile Development with Apache Cordova and Java EE 7 | Coder Coacher - Coaching Coders</title><meta content="Hybrid Mobile Development with Apache Cordova and Java EE 7 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Hybrid Mobile Development with Apache Cordova and Java EE 7</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/eeY4iDvIToc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning everybody how's everybody
doing okay it's little early hey
Starbuck stuff and everything my name is
Michael finicky this is my friend and
co-presenter Ryan cupric we both work
for our little company in France called
Basso systems you probably never heard
of we make a software that builds things
like the big boat that's over the next
to the Moscone Center I'll have to talk
about that in a minute
we're gonna talk today about hybrid
mobile developments we're going to go
into the concepts both of Cordova and
je7 with a pretty heavy emphasis on
html5 JavaScript as well so it'll be a
as you'll see an end-to-end really nice
application that Ryan built for this I
hope you guys appreciate that
he'll do a self shameless plug later but
he is the author of several books
including that that means certification
one and EGP three in action so question
who wants to be a billionaire or the
next Apple Store billionaire like you
know the guy from Angry Birds you know
throwing pig birds at pigs and all and
snapchat and I mean it's just kind of
crazy right the amount of money people
are making on just simple apps well this
class will teach you how to make one of
those simple apps and deploy it on any
mobile device because as we know the
mobile market the smartphone market is
just exploding the exponential boosts in
China in particular I mean we're talking
like a billion users right even if you
1% of that you know you're already one
of those guys building Angry Birds right
so it's a really good incentive to to
work on this stuff in it and as Ryan's
gonna show you it's really really easy
so we're gonna go over some of the
fundamentals and the basics we're going
to talk about the mobile overview the
tooling that you need and then we're
gonna die very deep into j e7 and
cordova in terms of Ryan's app that he
built and we're not showing this just as
advertising for last year's open world
which actually we went to two of the
races it was really cool but his app is
actually as he's going to explain
managing one of those races so he built
an out a real app you know with real
code that could man it for someone to
manage that
and by the way you probably didn't know
that little-known fact both of those
boats were designed with our software
with Dosso systems CATIA software
unfortunately we don't have any logos
anywhere anywhere near the boat but it
really is without that's the cutter
that's the what we do we build a
software that allows you to build boats
and airplanes and cars and toothbrushes
and formulas inside of chemicals which
is what he does and I'm the Evangelist
for the platform okay so no more work
stuff we'll go right into fun oh and by
the way it has everybody gone down to
the Mosconi and seeing the boat it is
super impressive it's totally awesome so
anyway a little picture there for you
and this is Ryan's way okay so the we're
gonna be covering many technologies
today we're going to be looking at
Apache Cordova of course along with Java
EE 7 tie-in with that we're also going
to be talking a little bit about nodejs
which is required for the Cordova stuff
along with the user interface for the
mobile application which was done using
jQuery Mobile and I picked jQuery Mobile
for the demo application for today
primarily because most people are
already familiar with jQuery and some of
the other frameworks out there have a
steeper learning curve we're also gonna
look a little bit at the Android dev
tools and iOS dev tools just in passing
because both of those are required if
you're deploying to a trying to test on
the device and if you're trying to
develop for tins and Blackberry or
Windows Phone you also need those tools
as well the IDE that we're gonna be
focusing on today for development is the
NetBeans IDE which is probably the best
IDE right now for html5 development for
mobile I checked out I'd been doing this
presentation I tried to find another IDE
that had as sim as integrated an
environment for developing and deploying
the applications I did not find any
there's ideas like Xcode that are
specific for deploying for for iPhone or
Android developer studio for Android but
there's no IDE that really that really
integrates the entire experience in
terms of development for html5
applications into one place where you
can write the Java code the JavaScript
code and also push it out to the
so you know you can use something like
Xcode for developing it but it won't
have as good of JavaScript coding
experience as NetBeans does so as
Michael mentioned the application for
today is the sailboat racing application
I do a lot of racing during crew on a
boat during the summer so typically with
you have you set a bunch of marks out
there in the water and you sail around
them so if you were out here last year
for Oracle OpenWorld you'd see the the
the yachts going out and hitting certain
marks so that's that's essentially what
the application is doing the application
is basically handling distributing
information about the course and also
tracking the progress of the boats on
the course using geolocation pulling TSM
and from the weather service and
everything yes yep yep so the the basics
of the application or the you know how
racing is normally done you have a
committee boat that's usually volunteer
that goes out there so every Yacht Club
in the United States has something like
this committee boat goes out floats out
there sets the course and announces a
via the radio the boats also register
via radio so they call it and say I'm
you know a fast boat so I'll do racing
class I'm a slow boat I'm doing cruising
class and then each class of boats gets
a different course and they don't decide
the course until they actually get out
there they look at the wind the currents
and figure out what to do at that point
um so it's a real Apple you know it's an
application there's always this
coordination over the radio and you know
there's always somebody jumping onto the
you know the fishing boat and you know
talking about their catch while we're
trying to get the course out so there's
a then there's a start sequence for each
class and how a sailing race works is
that you know you have a start gun and
your goal is to be crossing the the
start line and not hitting any of the
other boats just as the horn blows so
it's kind of it's kind of exciting and
there's actually like accidents that's
with you
sailboat racers pretty kept the
insurance so then this so then you for
each class gets its own start the boats
go out there and then the the committee
boat tries to monitor what's going on on
the course to see what's actually
happening out there you know because if
the wind the fog might roll in and they
might not be able to see the books
that's where this app comes in
additionally the wind might die and
you know the long course that sounded
like a great idea means that everybody
will be finishing you know a day from
now and they thought they're going out
there for two hour race and then the
finish time for each boat is registered
at the end of the race and the final
results are calculated the boats have
different ratings so most of the boats
of when you go into a Yacht Club there's
they're not the same boat like the
Oracle race out here so there's a
handicapped associated with each boat so
even if you finished ahead of another
boat it doesn't mean that you actually
beat them so it's arils so this is an
apple this is a real application this
isn't like a to-do application or
something that's really simple so you
know there's some real problems with
this application so the functional
requirements the app must be able to
broadcast handle boat registration time
check for start notification tracking of
the boats that are out there race
announcements result some weather
information push being able to push the
weather information others to the boats
can find out like what's going on with
the tide and so in terms of developing
an application we'll kind of get into
this with the EE 7 stuff we have you
know concurrent asynchronous stuff
that's going on here we have information
where the server is pushing the
information out to the boat so this is
why Java EE 7 is a good fit for this for
this application for for mobile
applications so you know we'll kind of
be touching on this to see that this you
know there's this concurrency involved
eventually they'll be tying into the
batch processing stuff for processing
the results afterwards for the EE 7
stuff so this does this application is
made possible because of Java EE 7 is
much easier to write ok and the
architecture is relatively
straightforward we have and by the way I
think I probably lost over at all the
source codes up on github I show a
screenshot later but you can get all the
source code with everything of course
there's an infrastructure based on JMS
sedi the persistence layer is all JPA
we use a JB's for all the actual
business logic the application and then
for the UI it's Cordova so we can hit
both Android or iOS jax-rs for the
communication and the WebSocket for the
actual transmission of data so if you
actually it's also a great sample app
because it gives you almost every
feature in je e all coordinated and
working together
and so we have this demo app sitting in
an iPhone which is a single-page app so
even though it's running as HTML you
don't see as we'll see later the your
you know how many bars you got on your
phone and the changing pages thing and
all in html5 naturally that of course is
hitting the je app server with a post
grade database in the backend because we
also forgot to mention this is all
running on Amazon right then that'll be
probably our talk next year Lee how do
you do the deployment on Amazon and of
course as we mentioned it's also going
to query Noah to get the weather
information so that the guy can cancel
the race if a big squall comes up or
something and it's also many many users
right each boat a Pidgey would have a
copy of the app so they'd be looking at
it to see what you know the instructions
and so forth so it'd be really a huge
tool for the guys running the running
the races and of course he hopes to be
the next billionaire but just selling to
clubs and so forth and it's a rather
complex business model it isn't just
hello world and outright this has got a
ton of different tables I think there's
over 16 tables and lots of relationships
almost everywhere so it's a real solid
you know comprehensive data model that
you can again study for your own
personal enrichment and of course as I
mentioned so once again another plug you
can go to github even now and go grab
the source code off of Ryan's Ryan's
repository so that makes it real easy to
get started and he's now gonna demo the
applications ok cross your fingers this
is just a new live demo quick demo piece
try this at home okay so the server is
already running so that's the end 34
server so the application is in 34
Saylor let me run the application it's
been start the simulator it yes so this
is gonna launch the iOS simulator which
hopefully my aging laptop will kick off
so notice that I'm here what's that we
able to get it uh no I wasn't that's
what you could try at home
yes and I'll probably be able to run it
on the phone
later on as you can see we're all
watching the simulator I had to get my
Apple Developer account fixed yesterday
so notice this is all being done with
inside of NetBeans I'm watching I'm
deploying I'm compiling it's doing
native compliation underneath the hood
so it kicked off Xcode and actually ran
the Xcode developer tools underneath the
hood to build up the application there
actually is a Xcode project underneath
the hood that you can actually open up
and so here we're firing up Michael and
his part of the presentation will
actually discuss a little bit more but
you can actually debug the application
from with inside of NetBeans that's not
what I like to see no don't do that to
me yes so it is using a traditional so
NetBeans is just calling out to the
treasurer yes there are some of the
plugins I'll show that I guess because
nope no they do not have to install any
plugins for NetBeans in order to I know
you can't do this with Eclipse right now
there probably are some plugins out
there for eclipse so yep well that is
unfortunate ctrl Q
yes let's so let's check the council
here and see what's going on with the
application nothing not what I wanted to
say okay well I will have to pass on
that demo it was working at two o'clock
in the morning last night so let me yeah
let me let me just quite quickly go in
here and so this is the application the
application actually has a main landing
page here and I'll show the code off a
little bit later so this is the main
landing page right here we've got so
after you login so you hit it initially
hits the login screen then you log in it
takes you to a menu screen the menu
screen has a bunch of options for
actually you know starting an exist
joining an existing race starting a new
race and doing the rest of it so the
project has a nevians project there's
nothing that's required there's no
plugins that you have to install you
have to install the apple developer
tools the Android developer tools prior
to doing prior to prior to starting the
project template and also install Apache
Cordova but once that's done that means
is up and running for you so I'll have
to demo that there's actually a separate
demo this afternoon and another
presentation so I can demo it there okay
so that's that was to be the demo the
application actually does work so so
with the question is for this
application why use Java EE and I kind
of touched upon that before you have the
object pooling which is one of the
important features with enterprise
javabeans which means that you can
control the number of stateless beans
that are being configured you have
support for concurrency you can actually
control the number of threads that are
being created every WebSocket call
results in another thread being created
up on the server some of the
asynchronous processing that's going on
in the application results in additional
threads so using Java EE 7 you can
control and monitor all of that and you
can adjust resource pooling so that
allows you to evenly distribute the load
across your application servers and also
database connections I mean transaction
management because during
actions are very important that's
updating a large data model security
I'll touch on this in the presentation
this application does use Java EE
security and you'll see how I tie the
tie into that because it's a little bit
different when you're dealing with an
html5 mobile application it also does
enforce a good architecture on the back
end so the back end does not end up
being spaghetti code although the
JavaScript front-end sometimes can
become that and then finally Java EE 7
has a rich feature set in terms of
batching and a bunch of other you know
features that I can use so for you know
processing the results at the end of the
race I would probably use the Java EE 7
batching for doing that ok so the we
wanted to use Java EE was the features
around scaling right where you can
configure the number of pool the the
size of the pool when we start adding
more servers or deleting them having a
minimum so we don't have a certain draw
performance while we're waiting to spin
up some more servers and also caching of
course the beans as well so we could get
a maximum amount of concurrency and so
that means we can both scale up and
scale down as I said that probably next
Java one will do something more
specifically on deploying on the cloud
how to do scalability and load balancing
but that's another huge advantage of
Java EE that allows us that kind of
flexibility for more of an enterprise
class application and if you think about
it if if his application goes nuts right
and suddenly every amateur boat company
he's going to need something that scales
relatively well you know it's just as a
developer you can write things that are
not so scalable but if you're trying to
become the next Angry Birds for yachts
you know I guess you get throw yachts at
peace yes that's the aperture to
throwing a yacht at a pig that I would
buy and kind of tying into that I mean
right now nobody's out sailboat racing
because it's 8:30 in the morning open
till tonight so there's no sense paying
for resources with the cloud stuff this
morning when nobody's gonna be sailing
for tonight
ok so we're already seven minutes behind
mobile platform so I think we've all
seen that uh but you know Apple
basically kind of erased that little
icon down there at Blackberry so the
market is really
of course by Android and by by the
iPhone and that's why we're showing us
but we're gonna also give a little
credit to Android as well and I think
everybody's familiar these and actually
a friend of mine was saying it's anybody
using Nokia at the Nokia phone anymore
that's not an MS if Microsoft employee
we're still looking for one okay so in
terms of the development model so
there's several different development
models I mean that some of you are
incredible
developers already know you have the
native app model where you build for
specific platform so that means if
you're developing for Android you write
it in Java for iOS it's either
objective-c or now since they've
introduced a new language Swift and then
if you're developing for Windows you'd
have C sharp and the rest of it so
that's that's the first model that a lot
of people immediately associate with the
mobile development the second model is
the mobile web application so it's a
server-side application that runs you
know the backend runs up on the
application server it serves content to
the mobile to the web browser the user
has to actually launch the web browser
and browse to your application so
there's a lot of websites that target
where you have you know a mobile
application a native application then
you have a mobile version of the web
application for the people that haven't
installed the app these types of
applications typically use things like
jQuery Mobile Sencha touch etc you have
the responsive and adaptive web designs
for designing these types of thing you
have to absolutely change between the
two of them then there is the hybrid app
model which is basically where you take
WebKit and you make that the application
and you you know hide the fact that it's
a web browser that's actually rendering
the content you package up the content
with the applications so that they don't
actually have to you know go to a
website or it doesn't have to be
downloaded doesn't require a network
connection in order to run it now Apache
Cordova is just one of several different
frameworks that are out there it's also
known as PhoneGap or previously known as
vogue app there's a DF mobile IBM
worksite arrow gear app accelerator I
think there's one called titanium as
well so there's quite a few different
frameworks out there that are trying to
tackle this in addition to the cross
platform native ones that allow you to
write code and say Java and cross
compile into
objective-c and then there's a there's a
fourth model that's not on this slide
which is an application that is both an
html5 application and also a native
application so we have native
application bits we won't be covering
that in this presentation because I
could spend an entire day on that but is
it possible to use have 50% of your
application being html5 and the other
50% being code that you've actually
written for Android for iOS for Windows
Phone specifically
so although Apache Cordova you know you
can write mostly in html5
you can still crack open Xcode and code
your application in that so continuing
the development of the development
models the native application probably
gives the best user experience a mobile
web application allows the otÃ¡rio
multiple platforms from a single
codebase I mean you don't have to you
know as long as your app is just
presenting content you don't need to
talk to you know the accelerometer
although some of the web browsers
support that now that's a good thing
however most users do still prefer to
have an icon that they tap on arena as
opposed to having to sit there you know
and type in you know like an address for
a website you know you're at the you
know you're at the airport you need a
hotel you're trying to type in X P D and
then entering your username and password
and then the night and it's because you
know your native applications you expect
them to already be logged in and I'll be
talking a little bit more about security
later in the presentation and then
there's the the native html5
applications which is what we're
covering which allows you to target
multiple platforms from a single code
base and a quote you know stress the
single code base because you don't have
to have a single code base you could
write native code for each one of the
platforms where you need performance or
where you need an app specific feature
that Cordova doesn't provide and you can
also write plug-ins that will behave the
same across multiple multiple thumbs so
requires development tools for each
platform you have to access to the vise
features but with some limitations and I
must stress the I'll mention it later
with the PhoneGap stuff there are cloud
the phone phone cap comes with a cloud
service that allows you to actually
compile your application so you can
actually develop your
Cordova sorry Cordova PhoneGap
application for you know just one
platform and then upload it to the cloud
and the cloud will PhoneGap the PhoneGap
club provided by Adobe will compile it
for Windows Phone and give you the
necessary executable so you don't have
to have all of those dev environment
setup necessarily as you said before the
the sample app is a single page app so
it doesn't have the bars on the top and
bottom that an app that a browser-based
app usually without so it's far more
immersive and all the app logic course
is being done in a in JavaScript using
html5 markup SVG canvas and wgl for the
UI and then uh everything is bundled
with the app there's nothing else to yep
and so in terms of native html5 apps
versus web apps the first thing if
you're coming from the Java world there
is no jsps there's no JSF facelets so
you're not doing the UI using JSF okay
there's no JSF in the picture and then
the other gotcha is there's no HTTP
session so because you're not serving up
the content from the server there is no
HTTP session there is no timeout in fact
every time the application contacts the
app server it might be talking to if
there's a load balancer in the way might
be talking to a different application so
that's the main thing so that I thought
that I must stress there's no HTTP
session there's no J session ID up at
the top that's tracking your session you
don't have any HTTP session object on
the server side to put state in to be
shared across multiple servers so it
really is a completely different model
in terms of how you write your back-end
server stuff so with that being said and
then as Michael mentioned it is a single
page application if you're doing Apache
Cordova typically so this means that the
index page gets loaded first and then
using JavaScript
you know you browse you've moved to the
menu page it loads the menu page in to
the divs on the index page when we then
transition you click on the info link
there we then remove the menu page
content for it and insert that into the
into that content into the page so
although there's multiple pages out
there you're not necessarily clicking
and you know changing it you know
moving between the different pages
you're actually loading it into a div on
the page yes success yeah that's us and
the whole set correct and if you're
using Sencha touch it would also behave
the same behave the same way and also
that means that your javascript code up
at the top is executed once so there's
many different frameworks out there so
the one that I'm using truth that we're
using for this presentation is jQuery
Mobile
there's also Sencha touch the Intel app
framework ionic and project Twitter
bootstrap you can also use angular
there's so many of them it's not funny
so the advice is don't reinvent the
wheel with that and of course there's a
screen of essential architect note that
it forces good MVC practice because it
keeps you nice and structured it's very
similar to how you do the development in
Xcode or Android studio but it does have
a cost associated with it for $400
however the touch fit is free as I wrote
down here and so you can download cinch
a touch from sintra comm create the
enable show app structure with synth
essential commands the only issue I
guess
NetBeans has a couple of hang-ups when
it comes to essentia but you are able to
do that and it is very tightly
integrated to Cordova which is also
advantage when we're using Cordova and
so just talking back into that the sense
of touch stuff really does enforce a
good application structure on you so if
you're developing using that I mean it
will force you to use MVC using jQuery
Mobile like I did with this application
is very easy to deviate from that so now
moving on to tooling our tooling is very
important because we're actually looking
at handling multiple different
frameworks that you have to interact
with so you have Cordova you have java
ee you're working with app servers phone
simulators unit testing frameworks I
mean you're going to have your J unit
our Killian unit tests and then over on
the JavaScript side you're going to have
karma and all the rest of them so you're
going to write unit tests for Java code
unit tests for the JavaScript code so
have you know multiple different
frameworks and that's that's where the
power of NetBeans comes in for this
presentation because NetBeans does
support all of these it does support
unit tests with karma JavaScript it does
support the JavaScript unit test
framework so it does have integration
with karma and Jasmine so and it also
has support for the Java EE 7 stuff so
that's why you know I do that and with
NetBeans if you downloaded the latest
NetBeans so if you're doing this make
sure you have NetBeans 8.0 point 1
because they fix many bugs and they also
slipped in so even though that's a minor
point release they actually slipped in
grunt support which is the JavaScript
equivalent of ant so you can i viously
you didn't have a build system that was
associated with your credit over
projects although I haven't used that
yet because I just discovered it two
weeks ago but they've got probably the
best support for doing all of this we
also need the platform SDK in order to
build for the iPhone and so forth and in
order to automate the build scripts no
GS Chrome Java 8 NetBeans that's those
are prereqs as well and we can use maven
karma Jasmine in front music so we're
about eight minutes over and of course
you need to have a developer license you
need to go to the I at the Apple Store
and purchase you know $99 to get that
here's a couple other kits for the
different phones whichever ones you wish
to target NetBeans has been has the
integration directly for Android and iOS
there's nothing else to do and because
of phone the gap is we already made sure
that also allows you if you pay Adobe to
deploy that directly into the cloud
actually that's that's free actually
here's a p'zone 'pn source it's free so
you can compile up there for Windows
Phone that you know if you don't have
the environment for it so here's the
develop program owes in Euros because I
did it but it's a hundred bucks and then
of course we used nodejs it's required
but it's only we're only hijacking npm
so we have the package stuff we're not
using anything else in this demo of
nodejs of course kind of boring and
installations thing so I have fun with
that it took me a while to install all
the bits and pieces and then of course
Cordova which primarily command-line
base but that's a nice integration to
NetBeans and you don't have to worry
about
anymore but the initial setup as you do
your NPM to grab the packages and then
you use the command line to act add the
stuff so you can which build
environments you want I Oh s Android and
so forth and then you can very easily do
even me is not a programmer could
actually create a program and get it
running real quick and of course that
means it's directly in a good your
Chrome so I just go to chrome store
download the netbeans plugin and now I
can actually debug right in chrome as
well to make sure that pages are showing
up as I think they should and oops
oh you could debug in chrome using the
chrome tools the chrome developer tools
that's super convenient as well and of
course you have the NetBeans IDE and
this is where you need the developer's
license from Apple because it's going to
grab your provisioning profile when you
want to target your telephone to do it
and don't be an idiot like me and
upgrade to Yosemite and iOS 8 where
everything doesn't work anymore and then
of course you create the court of a
project I think for the interest of the
time we're actually going to do the demo
here because it's just click they click
new project and it just creates
everything for you you'll see that as he
goes through all the code and hopefully
if I get it running over there so like I
said this was just a do new project and
you see you just select which JavaScript
Mitas not all that interesting trust me
is interesting that he's got to say so
now we're going to go into the more
hardcore thing and we're like I said we
caught up with four minutes we're four
minutes behind but we'll make it because
we want to make sure there's Q&amp;amp;A time so
we're gonna go into the kind of the
heart of the Cordova bit so as the
history of it is Ryan was saying it was
it originally called PhoneGap I started
developing in 2009 and they wanted to
put a wrap html5 applications into a
native wrapper so I could put them on
any phone and only develop once target
many up architectures they nodoby
purchased it but then floated it as
Apache Cordova and they kept PhoneGap
for the deployment on the on the cloud
so they just have a the cloud build
system is over at Adobe
it has a whole bunch of a comment
plug-in so you it'll just natively use
whatever it is on the phones you don't
have to learn at Android or iOS it just
picks up right off the phone so it's
really easy and I mean you have this is
some of them in there right there in the
code so is another example of what's in
Cordova it's NetBeans so you have all
the different api's you just select the
ones you want and as a plug-in and then
you have access right to the camera and
everything else and I should mention
kind of kind of with that previous slide
there those are the the plugins that
NetBeans loads in there by default for
you there's many more plugins out there
on their website which you can manually
add to by just editing the configuration
project yes you can create your own
things so some of the other ones that
they have that aren't explicitly listed
up here there's a Bluetooth one so you
can actually buy one of those are
julinho modules that have supports
bluetooth and you can actually talk to
an embedded device so you don't have to
write any driver code or anything like
that for the phone it has supports it
natively so that is just that's the
short list of plugins that are supported
so Apache Cordova some of the quirks
with me when working with it the html5
apps will not necessarily match the
platform you lie exactly you do have
this situations like where they roll out
a new version of like iOS and you have
to wait for a patch of Cordova to catch
up and also deal with changes to the
apps UI to match or handle quartz and
the changes of the platform each
platform has its own quirks iOS network
information is cellular or Ethernet so
you're not told whether it's 3G 4G LTE
you're told that it's either cellular
ethernet iOS tells you on startup fires
the kind of light telling you that the
you do have a network connection after
the application is started the Windows
Phone emulator reports a network
connection of unknown device UIDs
on the iOS are apps specific on that is
to block tracking so if you ask if
you're using the u ed thing on iOS it's
just going to be something specific for
your application you won't be able to
actually use that to track track the
individual phoned user that's because
Apple doesn't want developers actually
doing that they believe heavily in
privacy the camera is
available in the iOS simulator so if you
do need a mobile device and actual in
order to actually test that you have to
have a tethered at altitude accuracy is
not supported on Android Windows Phone
doesn't provide battery level
information and each one of the plugins
and everything else has a list a mile
long so it really is although you know
you can you know that little adage with
Java you know right once the bug
everywhere this is right once and
customize it everywhere and it's kind of
a little bit it gets a little bit
challenging because as I mentioned with
the iOS fire in the network application
after start it's just not that the api's
are a little bit different the delivery
of those events are a little bit
different so you do have some
concurrency issues that you have to deal
with with that and then so for the you
know creating the project and NetBeans
you just simply load up NetBeans this we
would have covered this if we we're not
running short on time but you just go in
there you select the Cordova application
and you're off and running and I should
mention that the first two you can
create an html5 application and then
convert it to a Cordova application
later so you can start off by developing
an html5 application and then once you
get the UI kind of you know up and
running you know or prototyped out then
you can say you know you can go into
project properties and say turn this
into a card over application and the
only thing that really does is it
activates that feature so you're not
running it you know by default with the
first two you're not running it I'm
fighting with it initially so kind of
speeds up your development time and in
terms of developing mobile applications
I usually start out with an html5
application first get the UI up and
running before I begin to bring in the
idiosyncrasies of the phone because you
know initially you're starting off
trying to get your API is to the server
up and running correctly before you dive
into actual dealing with you know
interacting with the phone hardware so
you wanna get the basic application
working and you can use the the chrome
developed Chrome integration with
NetBeans to test that initially
so the code structure when you look
inside of Cordova you'll have a config
data XML which we're going to discuss
later that's the kind of the index of
everything on there and they'll be
platform directories so for all the
things you need for building on Android
iOS and on Android that's where you find
all the code that's specific to that and
in the WWE directory that's where you
put all your JavaScript and HTML files
so it's really straightforward from a
installation perspective and then the so
when you create the initial hello world
project so if you go in there and say
create me in Apache Cordova crates this
is the initial template that it gives
you as you can see you've got some
JavaScript called some you know some UI
that's going to get updated from the
JavaScript code down at the bottom you
call app initialized afterwards and then
the JavaScript code if you've done any
Objective C programming on iOS at least
for me this looks very familiar because
you've got your you know your device
ready your kind of like events you know
when the application initially starts up
so if you've done any native development
you'll see the you know kind of closely
mirrors what you'd see if you're running
Objective C or Android code so you've
got some of the same events some of the
same structure there so this code right
here once the device ready is called
then you're ready to go then you're
ready to get up and running then the
application is successfully loaded and
completed use the configuration mother
has all the metadata about the actual
program you're running the specification
the widget specification the Cordova
specification with the version plus the
name that he gave to the app in 34 looks
at all the metadata now there is a
cautionary note of this origin down here
need to be very careful of that that you
could be simply exposing yourself to
cross-site scripting exploits because
someone could use that star and then
insert Java code JavaScript code sorry
so the I did the default access with
that star means any the app itself the
client app could hit anything so if you
can't get control of that it can hit any
server and in fact any other server so
you want to be very careful about that
and give it a specific domain that it's
allowed to go to
however there's another gotcha because
that things are not the same on the
different phones so you're gonna have to
for iOS that you use a star dot you know
star name a dubbing star for the
BlackBerry it's got something special so
you're gonna have to do a little bit of
research to make sure you get the right
thing in there but you absolutely do not
want to put that star there that would
be really bad that would be a huge
security risk the default is the star
that is that is that a fault is axis
origin equal star so you definitely need
to modify that's we would to make sure
we mentioned it because otherwise you
could be really opening yourself to a
world
so how somebody would actually take
advantage of that is that they would
type in Jace you know to edit basically
JSON or JavaScript code into your in
july-- context a text field on your
application and then if they can look at
the source code for your application of
course there's tools out there that
allow them to see the actual content of
the application on the phone they open
it up they see that you're doing a
JavaScript eval so now you're you know
you call the server or trace it back
from the database some other user
actually they get back the the
JavaScript called and then if you made
the mistake of calling you know the
JavaScript eval function now they've
inserted their code into your running
application and it know and now they can
tell you in a cross-site scripting so
they can run scripts on other sites and
in fact other servers and all hell
breaks loose so you don't want to do
that and then inside of NetBeans you
choose the target of my target I oh s or
Android so you can very easily grab that
and then build and run your run the app
very very easy to to grab the the
statistics on whether the people are
there that you use the different plugins
to pull out the whether they're online
or offline so it's extremely easy to get
all the smart core the features on the
phones without actually knowing the
implementation on blackberry or iOS or
Android and of course you can also grab
whether you know what kind of device is
it because remember some of those things
are going to be specific device by
device and be very careful this image
simulator is not a real phone right so
it's not always going to give you real
life for sign all these can be pretty
addicting
so you really should be testing this on
a real phone to make sure it really does
what you think it does and then you need
to test it on both arm and Intel
processors because they might have
different behavior so like you said
right right once debug many times kind
of thing but just make sure that you're
getting the behavior expected on a real
device but don't expect that it's all
going to be a magic and then
additionally I mean in this case right
here we're looking at the network
connections or that's very well also get
the network information as I mentioned
before iOS is going to report cellular
and the other phones will actually give
you you know what type of actual
connection it is now looking at a patch
of Cordova so as I mentioned before you
typically gonna start with an html5
project and that means without cordova
and get your UI up and running with that
test in the simulator you can actually
use the browser and the simulator
initially because that will give you the
form factor so you don't have to compile
your application to a native application
sign that deploy the simulator deploy
deploy to a phone so you can actually do
something where you know you're running
your your mobile application on you know
on the local server on your laptop
running as a server and you can actually
test it with the mobile phone because
then you can get down some of the you
know testing out layout and stuff
because with with html5 that's where
you're gonna spend a lot of your time
initially yes
I know you are I mean you are the
Cordova just means that when you add
Cordova to an html5 application that
means that you're going to build a
native application that wraps that wet
wraps as a web browser embedded in it
but for simplifying development
initially you can you can just do your
development and and debug it in the web
browser right because the web browser
can render the content the only thing it
can't handle is the native the tie the
additions that Cordova has added for
talking to the you know getting
accelerometer results and so forth so
it's much easier you know in terms of
testing initially I initially developed
using the I initially started off with
an html5 application tested it on the
mobile phone and the browser on the
mobile phone and then added on the
platform specific code afterwards and
turned it into the Cordova application
so I got the basics working the Ajax
calls are working debugged all of that
stuff verified that my error handling
was working then I started adding in you
know camera support and the other
hardware things later because you know
do both deploying and running out on the
thing and one of the things that I'd
mentioned yes
so the question was whether I would
write native plugins in order to do the
communications actually no in that case
because HTML FRA provides the Ajax the
the Ajax and the WebSocket support
natively so I would only use write
native plugins for other things there
was no sense there that that would be a
pretty hefty thing to write my own
networking code actually and then
testing in chrome as I mentioned does
not equal testing on the device as I
discovered the initial application I was
initially storing to the phone if the
phone loses network connectivity while
you're out there sailing I was gonna
store the results in index DB which is
the database that comes with html5 I
coded up everything using index DB was
running with the Android simulator and
then went and slammed it on my iPhone
and discovered that iOS 7 doesn't
support index DB so at all this
asynchronous code to handle
index DB that I had to had to rip out
now it is supported on iOS 8 but I was
not going to make that mistake before a
presentation yes it didn't work now you
actually have to there's a separate
there's actually as a separate download
because the plugins are not yet in the
main repository I guess so they're kind
of like in dev mode so they haven't been
released yet but I was not gonna play
with I did that last year for a night
for the iOS and Java EE 7 presentation I
upgraded right you know the night before
I fool out so that was an ouch
so that can I use website you can go to
that and check out all of your mobile
browsers because some of the features
you might be using aren't available in
all of them now in terms of testing with
chrome so if you're testing with if
you're developing with chrome sorry
testing initially with an html5
application and then trying to test
inside of chrome your application is
going to run into a roadblock pretty
quickly because chrome is going to say
the content for this page wasn't served
up from that server you can't talk to
him right because it's gonna try to
block the cross-site scripting so this
is actually some Jam this is actually
jax-rs - OH
interceptor fairly common and what this
what this does is just sets the headers
on the Ajax request
the web services request to tell Chrome
yes you know I do allow somebody that
that did not request the page to talk to
my web services so this allows the
browser to do this now when you're
running on you know inside the Cordova
Cordova sets up the web browser so that
the web browser can talk to whoever
that's why the cross-site scripting
stuff that we talked about before with
the white listing is so incredibly
important this code here will allow you
to write your Java EE 7 application and
then test it with chrome and not have
chrome complained at you because you do
not want to disable that in chrome
otherwise you know you've got--you've
visit a website and get an ad that will
clean up your bank account for you and
then in terms of the plugin so this is
just you're doing a little bit more in
depth with the Apache Cordova with the
camera support capturing with the camera
is pretty simple you can actually when
you when you capture you can either
capture to the person's a photo album a
homophone or you can capture the picture
and also use it in your application so
the picture is captured and basically
encoded in base64 and that's what gets
transmitted over to the server the nice
thing is that with Java 8 you now have
base64 support so to make it easy to
decode that picture you don't have to
download like a separate library to do
that and then in order to upload the
code sort of upload the picture to the
drive the e7 application it requires
special jax-rs configuration to receive
the multi-part mime request so we'll see
that on the next slide here this is the
code to actually take the picture the
documentation for Cordova is pretty
excellent so I won't belabor everything
on here but as you can see here I'm
saying I want to take a photo you know I
want to you know where do I do I want us
to be able to save it to the photo album
the quality level and you pass in a
callback you know what happens in
success and what happens on failure and
on the success logic here this is not
using jQuery Mobile this is just me
talking directly to you know the server
side Ajax support so this is actually
uploading this code then takes that
picture that you've captured and uploads
it to the server so it's doing a post as
expected and it
you know down below since the you know
the data as you know image/jpeg base64
that's what the in majority is encoded
so you have to tell the server that
you're you're providing that's was being
provided to it and if everything goes as
expected it will be uploaded
successfully and then this is the Java
side of it this is all the code that's
necessary to handle receiving it now if
you remember in the past you might have
had to have downloaded you know
multi-part things from a patch in order
to do that you don't have to do that
anymore this is all Java EE 7 code with
annotations so we've just annotated a
method within a class that says you know
the path you know is slash upload it's a
post request that's gonna know we're
going to receive ok we're taking
multi-part form data so we've configured
the method and then we're returning a
response I always like to return
although I could return void and it
would return ok if nothing happened I
always like to do a response so I can
customize it if I want you to put a
custom error message going back or
something didn't quite come up right and
then you know the URL includes the boat
ID of the picture you know for the you
know from which the the thing was taking
and I get a hold of the
httpservletrequest so I can you know
work work through the different parts of
it and so down here you can see where I
pick out the you know pick out the
picture I convert it to bytes then
base64 decode it this is not actually
going to be the final code because this
actually loves the entire picture into
memory and with the newer cameras being
like you know 8 megapixels this would be
actually be a bad idea to do on your
server so you want to spin this off to
something else to do that and then it
sends back you know the fame or sends
back a 500 error if it didn't work now
in terms of configuring it there's one
more wrinkle you actually have to
configure jax-rs a little bit
differently so you might have seen and
some of the other presentations where
you can just add that annotation to
specify the configuration for the
application if you're doing this type of
uploads stuff we're going to have to add
you know configure the rest servlet
because you know under deep underneath
the hood it's actually just a servlet
that's being registered for the rest
support for ee7
and so you have to provide it with some
information you know the multi-part
configuration so that it knows you know
how to handle it
and then finally as I mentioned with the
this is a splash screen or if the app
was working we'd actually see although
some of the documentation up there makes
it seem like you know you just edit the
config dot XML file and you're off and
running there are situations that you'll
have to actually open up the specific
IDE for the you know the device that
your the device family that you're
targeting so in this case you know you
need to you know you don't have to use
Xcode but Xcode will allow you to
actually find where the graphics are and
the icons so you can't just go in there
and set it in the config file you'll
need to find the directory where the
splash screens are it's easier to find
it with Xcode so with Xcode you can go
in there and edit some of the additional
properties for iOS the same thing for
Android studio okay so now switching on
to Apache Java EE 7 so that kind of
concludes the you know the in-depth on
the Cordova scope at halftime guess
where it has so we're halfway through
here so hopefully everybody's free so
we're doing fit we're only seven minutes
over so how's the speed it's okay guys
thank you so that so that's the Apache
Cordova side uh you know in terms of how
to interact with the phone and
everything else the rest of the
presentation is gonna be focusing on how
do you connect the two of them together
so you know the Cordova stuff if you
know html5 you know insert your
framework in your knowledge you're off
and running with it so in terms of
overview what's the connection between
Java EE 7 and Cordova Grove applications
as I mentioned before single page
applications the application is actually
completely written and deployed with it
so if you write a Cordova application
that simply goes out to the web and
fetches your application and Apple
discovers that they're gonna reject your
application they don't they just they
like the application to be bundled as an
application they don't want you to do a
kind of like a rapid web browser where
you're pulling in content because that
means your application can do whatever
the heck it wants and they can't verify
it
so so anyway so the the JavaScript and
html5 is embedded within the application
actually the application actually ships
with those artifacts so as I mentioned
before you know you're not rendering JSP
pages that are getting rendered in the
browser it's all JavaScript and html5
code there's no HTTP session and the
other thing to realize is that no
network connection might exist so in
terms of you know what's the connection
between the two of them Java EE 7
provides the data in the back-end
infrastructure
it handles talking to the database
because you're not going to write code
that in JavaScript that's going to talk
to your database job Java EE 7 is
providing all that in Cordova sorry the
Java EE 7 side coordinates the
application processes so we'll kind of
look over you know there's you know you
have JMS you've got a bunch of things
for coordinating things on the server
side CDI events no there's just no HTTP
session so you know when you're with
your typical web application when you
connect to the server they'll create an
HTTP session yeah you know no you're not
rendering because all the content is
already on the phone the the html5 pages
are on the phone so they're all there so
the only time there's another HTTP
request is when you make an AJAX call to
the server or a WebSocket call so in
terms of device connectivity the two
ways of communicating with the server
are arrest which is request response
mode and then WebSockets which was
introduced with HTML 5 and now is a part
of Java EE 7 and that allows
asynchronous bi-directional
communication so that that allows you to
you know the server to be able to push
out data to the phone so that is in the
case of you know the typical example
we've probably seen a Java one with the
WebSocket stuff is like a chat
application where you know one person
types in a broadcast it to everybody
else that's that's kind of exciting the
other benefit to WebSockets within the
context of this application is this
application remember is going to be
jamming GPS coordinates from the GPS on
the phone down to the to the server
right so as the boats proceed around the
course
you're sending the GPS coordinates of
where the boat is now if you do that
with Ajax every time there's an update
on the GPS coordinates every you know 30
seconds you're going to open an HTTP
connection with those gigantic headers
you're going to send it down to the
server the server under then open up a
database connection and save it because
remember it's stateless WebSockets are
not stateless they're their
communication that's open for the entire
duration until you know the connection
is lost or one side or the other closes
it so that allows you to stream data
back and forth so in the terms of this
m34 sail or application it's the it's
always using the the the the the
WebSockets to send the GPS coordinates
down so that we don't have to incur that
high penalty of opening and closing a
connection every 30 seconds and then if
you're writing a game you can actually
do bi-directional so one of the other
uses for WebSockets is like in games
where you want to be able to send game
updates done so then kind of a little
more in rest restful client-server
communications from happens over HTTP
most most often using rest although I
put HTTP up there practically oh it
should be HTTPS you should never be
using just raw HTTP HT stateless which
that's the reason why the doing you know
streaming over the this wave for the GPS
coordinates do you want to use
WebSockets because every time you'd have
to get your database
you know session back and stuff like
that it is lightweight and highly
scalable so you have no affinity
necessarily affinity for a specific
server so if you're in a clustered
environment any one of the nodes can go
through the load balancer and it doesn't
matter XML is occasionally used although
practically everyone uses JSON and this
is critically important for mobile
application because browsers are the
mean though you know phones have come a
long way at last check the heap that's
available to the web browser for
JavaScript is still read is still in
megabytes it's not in gigabytes like
your desktop machine which means you
don't want to be shipping down XML which
you then has to parse so the client
unlike the client in both cases web
sockets and rest the client initiates
the connection differences that with
WebSockets the server can send the data
back and then you have with rest you
have the commonly supported HTTP
Erbs get the post put delete options
head etc and each one of those should
map to something in your application so
for instance with a sailing application
you know creating a new account is done
via a post updating an existing account
is done using a put you know you want to
kind of maintain the you know the rest
type of thing keep your API consistent
and you know the IDS at the end of them
and then you know you it uses the
existing web technologies and security
standards it's fully supported by Java
EE 6 &amp;amp; 7 others major enhancements in
seven now WebSockets were introduced
with html5 is a good tutorial up on
html5 rocks in terms of how to use them
that's pretty good site for just
learning more about it it offers as I
mentioned filled by true bi-directional
flow duplicate communications so this
means that you know any process up on
the server once they have access to the
session object can send data back down
to the thing that's not a request
response to resend data then the server
sends data back you send data server
sends data back both of them can be
sending data at each other a
synchronously and you can have using the
new concurrency utilities in Java EE 7
you can have multiple threads up there
streaming data back to the web browser
okay so for the the committee boat
they're gonna want to see you know
they're gonna want to see you know a
stream of data coming back with the
locations of all the boats on the course
now with WebSockets it is not a new
communication protocol the initial
handshake is done over HTTP which means
that this is fully compatible with your
proxy servers and all the rest of you
don't have to punch holes and firewalls
or anything like that it'll just it'll
just work so it's perfect you know as I
mentioned for games like chat for
applications like chat and games uses
existing web technologies the one caveat
is that the data is transmitted
transmitted as unicode which means that
if you're using WebSockets to upload
images the images are going to expand
they're going to take up a lot more
bandwidth because the transmission is
using unicode and then the prefixes are
either WS or SS
and I'm so upset that we can't do the
demo or the demo wasn't working because
I have you know that I have the the
Google Maps and the application that
allows you to see the boat as you can
simulate that with the iPhone simulator
and then the data for both rest and for
WebSockets is typically JSON so with
JSON if you're not familiar with it
already you have two data structures
objects and arrays the types that you
have available to our number strings you
know true false null let cetera it's
extremely compact I mean if you look at
this I mean if I had the stats somewhere
on the difference in terms of the amount
of space actually is in the book you
know different the size difference in
terms of the number of bytes between
JSON and XML so it's pretty substantial
so Jason was much easier to work with
now in terms of Java EE 7 support the
two containers right now that are out
that support it are both our GlassFish
and wildfly tommy is coming in 2015 I
believe as well as WebLogic on the
commercial side so it's more coming soon
Java EE 7 was released last year usually
takes the containers a little bit a
little bit to catch up some of the major
features that we touched on are the
WebSockets they've also added which
we'll be using today the JSON API the
JSON API for JSON processing concern
concurrency utilities batching the jacks
RSS stuff there's also upgrades to jaspe
which we'll be looking at a little bit
later in the presentation for security
now in terms of the layers for the
application layers that we're going to
be focusing on are the jax-rs WebSockets
JSON API for Java API for JSON and
Jack's B and the cordova is of course
running up on the top but it builds upon
all of these so you know these you know
consume you jb3 services we were using
JP a JMS between JTA so all of these are
basically being used along with bean
validation shameless pitch his book is
in the bookstore
that covers all of it so so up here as
you can see we have you know the the
jax-rs we've got the mobile application
and we've got Jack's B and Jason the
Java API for JSON in between doing the
post pojo to JSON mapping and I should
mention that with the the Jack speed
stuff that's kind of container or
implementation specific in terms of the
JSON support so there's you had Jersey
out there which has a set of features
you have the the other one Jackson might
be familiar with and with Java EE eight
they're going to be working in to
standardizing the mapping between JSON
and Java objects a little bit more
formalizing that a little bit more in
terms of connectivity tech technology as
we've kind of already covered both of
these but the restful web service says
you know both they're basically you know
the two technologies that we've covered
already
and they used for the rest of ones we're
going to be using jax-rs 2.0 and then
for WebSockets the Java API for
WebSockets so that's where the two of
those map into the Java EE stack okay
and so with rest jax-rs 2 is the rest
api for java received a major upgrade
with Java EE 7 important is that they
included a client API now and that
client API in order so when I wrote when
this application was developed the
client API was used in the AR Killian
tests to test the the to test the the
web to test the web services write the
rest of web services and then after they
were working with Java because of the
nice thing with the the Java API is that
I can get the Java objects that I
returned to the Java objects that were
converted into JSON with the client API
I get them back as Java objects again so
it allows me to do the initial testing
and verification and con sanity checking
of the web services first before I go
over into JavaScript land and try to
figure you know try to deal with some of
the idiosyncrasies over there they also
have you know support for asynchronous
on the interceptors which were mentioned
before in terms of you know handling the
Curris things it integrates with Jack's
be at least it's I think that's specific
to the
limitations it sanitation based so it's
pretty easy to get going you just take
your PO Joe and you add your you know
you know there's a method taking again
opposed to put delete etc well I'm
extensible and you know we've already
seen an example but this is another
example with a post for joining a race
you're creating a new entry for the race
and as you can see here you know we're
grabbing in this method I specify that I
want a header parameter as part of it
you know I get my path parameters off
the URL so they so the parameters are
pulled in off URL that is given so the
container dices them up and gives them
to me and then down below you know I can
return my response back and forth so the
ultimate URL down at the bottom is the
you know in 34 application race up at
the top because that's what the
parameter and the path is on the class
and then join on this specific method
and then the ID and the class of book
that's being registered now in terms of
passing parameters in you've got several
different so you've got six different
types that can be extracted you've got
query parameters and you can pass some
default value if it's not provided form
parameters for post requests now if you
do like a form parameter it's going to
require you know the hero URL encoded
you can get cookies you can get headers
and then if you're not familiar there's
also support for matrix parameters so
there's some pretty if anybody's
interested there's some pretty good some
pretty good explanations on what exactly
matrix parameters are because not a lot
of people actually are familiar with
those those have usually like semi
colons and the URL it's it's a bit
different now
Rustom Cordova application to make it
easy the examples in this presentation
use jQuery so that I don't have to deal
with video in any idiosyncrasies between
the different browsers kind of
standardized that it's got a very nice
API to work with in terms of handling
callbacks so this is invoking that
service that you just saw in the
previous slide so this is the code that
you know joins a race
and you can see where I set the headers
header information will touch on the
headers a little bit so jax-rs uses
jacks before the JSON the POJO
conversion that's not I don't believe
explicitly defined in a specification
right now jax-rs also integrates with
bean validation so what this means is
that if you're familiar with meeting
validation we can add your annotations
to your pojo you can verify when an
object is sent when you in the framework
converts an object to when it converts
the JSON to a Java object for you you
can use being a validation to verify
that to do validation on thatjob objects
you're only getting passed in a valid
object otherwise the container will
intercept it beforehand and kick a error
back to the to the browser saying you
know you've got a problem with the data
that you passed in so this means that
your your code here doesn't have to have
a gigantic long thing where you're doing
validation you know is this field null
all that field was too short you don't
have to do that that's already the
framework handles that for you know
I wish yeah so that's where that valid
annotation comes in and then on the
actual dto that's being passed back and
forth I've specified that when you're
creating a new race that it must have a
future start date and that I want the
name to be not null okay so when this
method gets invoked the JSON will be
converted into a Java object for me
being validation will be called and I
will only get a race object that has a
future date so in terms of being
validation and notations
you have a bunch of them to choose from
by default you've got you know you know
the future the max value so it's the
standard being validation there's no
surprises here with anything with that
and of course you can also do custom
validators so this one is actually from
the sample documentation from Java EE
from the Java EE website and this this
is one I think should be built-in by
default but it's one to verify that the
email is that is valid that you have
that the users provided a valid email so
you know you can define your own custom
validator so you can even do you know
multi field validation so if this field
is set this other field must be set so
you can write down the layers for doing
that and then all we have to do when our
POJO is add you know at email and then
that'll verify that the email address
that the users provide to this valid and
they've left off of these just so that
they would be readable you can also
provide you know validation messages
specific for these and tie those into a
resource bundle which will be detected
based upon the request so that the user
will get back the correct language you
know for what you know for you know what
the browser what their phone is running
yes right so you don't have to like you
know building separate support elsewhere
to handle localization okay now this is
very important with the jax-rs stuff in
terms of it converting stuff into JSON
for you automatically because you saw
before where you know I could return
back you know a Java objects back or
actually I didn't have that wasn't in
the sample but you can return Java
objects back in Jax the the jax-rs stuff
will convert be nice and convert it to
JSON for you now when using JPA you
might have noticed that I was using DTO
and I was like why am i using D tos and
not returning just the race object why
did I create a race DTL
and so if we're as well so this race
object if I return this this one
serialize well then I've got a list of
the race participants as a part of it
now that's the race participants have a
reference back to the skipper because as
I mentioned before this is a complex
data model and I'm using JPA just got a
reference back to the skipper and then
the skipper has a password now if I'm
not careful and I just use jax-rs and
say yeah I returned the race object it's
gonna go through and be very nice nice
to me and serialize everything back and
send back a list of everybody
participating in the race with all other
passwords so you want to be you know so
that's why this application uses DT
o--'s now all that you might see other
demos during the course of the the Java
one where they're you know returning
Java objects back so it's nice is
converting a back free but just realize
that if you're combining this with JPA
you might be returning more data than
you expect so you know give me a list of
all boats give me a list of all the
books that are participating in races
this weekend and get a list of
everybody's password in the system so
that's we're using that so you either
use you know I like to use data transfer
objects or you can annotate it with XML
trans yet I prefer the first one because
you know that if somebody's coding
something they've got a defect your
shipping tomorrow they're gonna go in
there and add it and not realize that
they you just streamed back all the data
to the client and then the other thing
that's fairly important that you can use
you can use this provider annotation
here so you want to compress the JSON
responses so even though we're shipping
back JSON which is nice and compressed
to begin with we also want to take in
gzip that's right and we'll set the
header to two gzip so this means that
after all the JSON is rendered by the
jax-rs service this basically intercepts
the response on the way back to the to
the mobile phone or to the web browser
and all the web browsers support this we
take and we gzip it so it's compressed
even more and you know the browser will
there's no jobs right any code in
JavaScript to handle this response back
the web browser will automatically say
oh you know the content came back as
gzip I'll convert that back in you know
I lungi zip it for you and then you know
give it back to you as JSON so this this
makes a big difference especially when
you're dealing with
phones which might not have the best of
connection to not only use JSON for
compact data representation but also to
gzip it so it's even more compressed and
this is all you have to in order to you
know to handle gzipping this is all you
have to write you don't have to do
anything
additionally right yeah you just you
just add this class and you're with the
annotation on it'll be picked up and
you're compressing route but now during
development you'll probably turn this
off because you want to use Wireshark to
figure out why something failed and to
look at the content so during yeah yep
so you can conditionally this is
apparently a dumb one this will say you
know everything goes back is just yeah
I'm now moving on a loop with small I'm
so moving on to WebSockets it's a
high-level declarative API so that Java
API for WebSockets is a high-level
declarative API the API is similar both
the Java and JavaScript side so the code
looks almost the same special here using
the annotated endpoints so the important
pieces you have the server end point the
on open the on clothes you know on error
you have a session object which is used
to send message this is not the HTTP
session this is the WebSocket session
you also have you know some other major
objects are the remote endpoint which is
used to send messages to the client the
message handling interface used for
processing messages
it's pluggable accent of all uses
encoders decoders it does not use the
JavaScript support that we saw
previously where objects would be
automatically turned into JavaScript
course we actually have to handle doing
that ourselves so this is a simple
example for the committee boat web
service so here we have an Arnold and
ROM message John goes on on there and we
register the our decoders and encoders
up at the top which I'll have more of an
in-depth example later on but this is
basically what a Java code site looks
like and I thought the next slide was
the JavaScript code but the JavaScript
code looks almost exactly the same now
remember you get called first with the
on open and
that until the connection is closed the
on close is called and then every time
the web browser sends a message to the
on message she gets called and that
happens asynchronously so it's not like
a you know where you're not like running
on a common thread you know where
there's a request coming in and then one
other important thing to note is that
the on error does not mean that the
connection is closed it just means that
something went wrong in the processor so
don't assume that because you got an on
error callback you have to actually
check the status of the call at that
bump but don't assume that we get on an
error you know the connection has been
lost that client know the on close will
be called when you lose the connection
to the client okay
interpreting parameter types you can
take two different types of parameter
types as either text or binary with the
annotated one you can have text and
binary or text and binary but you can't
do two of the the text up above so if
you have a one on message that takes
text you can't have another one that
takes a Java object and use decoders for
that because it's going to convert
everything into into text and then you
also have you know the Casa byte arrays
and you can have it where it segments
the byte arrays for you I'm down at the
bottom there is something you'll notice
in the API called up on messages if you
look at the JavaScript code you'll you
won't see any references to poly
messages and what pong message is
allowed to do which is on my to-do list
for this application you use plumbing
messages to basically it's kind of a
ping on a pong so the server sends back
I think ping or a pong and then the the
web browser without you having to write
any JavaScript code replies back to that
and so you can kind of you know send
data back and forth to get an idea of
what your latency is for instance that's
the purpose of the pong message in fact
I think there's a there's a WebSocket
book over in the bookstore just on Java
EE 7 and WebSockets and they talked
specifically about that about how to use
this and then the code for WebSockets is
basically the same thing as the one
forum for the Java code and as you can
see here the the client always creates
the connection so here you pass in the
the WebSocket connection information you
have you're on open on you know on your
clothes looks basically the same thing
and then in terms of how to send a
message so this is the JavaScript code
so I create my JSON object and I string
a fight and I assume that so that's how
I would send JSON over to the
server-side so this is pretty
straightforward wait 17 minutes okay
great and so the difference the
difference between rest and WebSockets
hopefully this animation works correctly
is that with WebSockets the connection
is always on
whereas with rest you know clients are
connecting they're disconnecting they're
connecting they're reconnecting
somewhere going slower and faster than
others but you know load on your server
you know what's going on with it with
WebSockets it's constant connections so
there is an object that's tied up
there's a socket that's tied up until
the connection is closed
yes yes yes I believe it does yes yeah
so yeah jump on yeah yeah open up with
WS and then there's a connection upgrade
which I'll have a slide on
nope it's got it wet WebSockets are
html5 so that okay okay I don't not
aware of that I was I didn't have any
trouble
I haven't haven't had any trouble with
it now the the support has gotten a lot
better the last couple of years in terms
of the WebSocket support but I'm not
aware of anything so anyway so your your
notebook yep so the the with the
WebSockets the important thing to
understand is that the impact upon your
load because you are tying up a specific
node with the rest stuff you know you
can have multiple servers you can spin
up servers bend down servers in Amazon
but with WebSockets you've got a
constant connection and as of right now
it is your responsibility to handle
failover so if one of the servers that
servicing a request goes down it's your
responsibility to you know have used
like hazel caste or some kind of
distributed cache so that when the
client reconnects he can get his data
back so that you're not caching
everything in memory Java EE 7 right now
does not provide that for you does not
provide the session failover for the
WebSockets so it's up to you to do that
so yes yeah so you can keep the session
in memory so that other objects can send
stuff back but if the if the connection
but any data that's associated with that
connection if that server goes down you
want to be storing it like in a
distributed cache so that if that
physical box were you know that you know
that machine that's running that VM goes
down the data is in the distributed
cache so that when the client reconnects
all of this information is available
that it wasn't lost and then as I
mentioned before the the HTTP stuff it's
a handshake request so this is the
initial request going up and we're
saying you know upgrade the connection
as you can see here I was using the web
browser for doing this not an ajax call
because we have the j session ID as a
cookie but you would not have if you
were doing this from an ajax call in
cordova and then the response back and
there's like the whole thing with the
codes you know authenticating the
response back and saying that yes the
connection was upgraded successfully now
there's two types of WebSocket end
points as programmatic and the annotated
annotators are the much easier ones and
any Pocho can be annotated programmatics
are much more powerful I'm touching
objects I've mentioned the WebSocket
session class so the session is the most
important object that represents the
connection to the plate despite what it
might say you do not have a rock up you
do not have raw access to the actual
Java socket underneath the hood okay
because the server might be implementing
it using n io or something else so
you've got this abstraction which
abstracts out the socket connection
there's very good reasons for why they
did that for scalability so the provides
key methods for sending makkad messages
back to the client closing the
connection storing state so you can
actually start state in it although I
don't know if that gets replicated
acquiring the principle information etc
okay and then the remote endpoint is
retrieved from the session so using this
you can get an async or a basic one
which is synchronous and so as you can
see here you have the different methods
for sending binary data sending objects
back and a whole bunch of things now if
you use a send object back it'll use the
Dakota of the encoders to figure out
which ones which object to encode the
message handler so you have two
different parts there's an interesting
discussion yesterday during the
WebSocket session
towards the end of yesterday where you
can't use lambdas with these as of right
now there's some some flying us after we
design the API for it and so this is a
more complicated example you know
registering decoders and building it up
using the programmatic endpoint which
are a bit more work and then you have
you know your chat endpoint with the UM
open and closed won't belabor that and
finally have your on message which
handles processing the message so this
one right here just you know does your
stand a standard broadcast for broadcast
back now the one thing with this code
right here although I'm looping through
the sessions that I've connected if
you're running and they'll many of the
code samples you'll see that implement
chat for the the chat application on the
Java EE 7 they always assume that you
only have one node right because if you
had multiple nodes and they're each
connecting to the different nodes like
in a typical load-balanced clustered
type environment you're only going to be
sending it back to the people are
actually connected to that server so
this is where the rest of Java EE 7
comes in that you're going to need to
use JMS so if I'm you know I put a JMS
mess put it into a topic and then each
one of the nodes that has WebSocket
connections connected to it is going to
send the message back from time to
trying to do a broadcast so for this
sailing application you know you have
say 10 nodes you know it's a busy night
you've got 10 different nodes up on
Amazon up and running with the
application and then you want to send
out a broadcast now each of the races
you know even though there's multiple
races going on there's going to be users
for each one of those races connected
into you know maybe nine of the ten
servers so you're going to publish a
message into a topic and then you're
going to have a code message driven bean
on each one of those servers reading out
the message and sending it back to the
WebSocket clients that are connected to
that server so this code here is
actually kind of bad because this is not
doing yep yes oh yeah well know that I
mean that the API itself is thread safe
I believe but this one would actually
have a would actually have some bad
because I'm getting the basic one so
it's going to send each one of those
messages
synchronously so you want to use the
asynchronous one so yeah so you get into
some really you know when when you
started doing
this stuff you're now dealing with
threading so now you're doing some heavy
threading stuff where you have events
kind of coming in and going now touching
onto the Java API for JSON this was
defined in jsr at 3:53 if res provides
the ability to parse transform and query
JSON so you can use it to create or
regen and you don't need to download a
separate library in order to do this
comes with Java EE 7 containers it does
not perform JSON to object mapping so
will not take your JSON the converted
into a Java object for you it's useful
for hand coding JSON so previously I was
showing a code where it was you know
take my race DTO and convert it to JSON
for me very often you might be
interacting with a web client where they
have custom requirement where there are
customer requirements for the JSON that
are going back we're letting Java return
whatever it is and telling the web
developer hope you know the app
developer well this is this is what Java
EE 7 is returning to deal with it might
not be an option right so this is where
you know especially if you're dealing
with things like versioning which I
don't get into in this presentation
we're gonna want a version all of your
I'll touch on that I'll mention it in
the summary but you want to make sure
the version all of your web services
because users do not necessarily update
your application so if you're a Cordova
application you're going to want handle
and support we check the version of the
app you know the version of the
application gets what the app server is
doing and you know you have different
versions of the restful web services for
different versions of the applications
and you have logic in there to handle if
that version is no longer support and
then the Apache Cordova application so
you gonna have to implement all of that
yourself and the API for this has got
two different API models and as an
object model which is like dome and then
the streaming model API which is like
sax and then for this application for
this WebSocket application I'll
basically I use kind of like the command
approach where there's different message
types that are coming over right so I've
got an abstract message there's a chat
message of tracking message and then
erase messages and the rice message is
like you know the race is started so
when the race starts there's actually I
use the Java EE 7 scheduling support
because you can actually have events
fire at specific times in Java EE 7 so
that you know when a new race has
created a start horn and a sorry warning
horn and a start horn timer is created
on the server using the Java EE 7 API
switch are
and then that results when that fires a
race message is then sent back down to
the client and the race messages can
also come from the clients but anyway so
that's the that's the inheritance
hierarchy for the messages is that
amusing so I have different messages and
so each message because remember with
JSON there's no additional metadata I
include the type of the message along
with it and then on the server end point
so this is the server end point I'm
actually using a stateful session beam
and I'm combining that so the WebSocket
endpoint for a participant in the race
as a stateful session be we got our
decoders registered and the reason why
it's stateful is because I'm using the
Java EE the extended persistence context
right because I'm gonna be receiving GPS
updates that I want to stick into the
database so I don't want to be every
time a request comes in let's go out and
fetch the user again from the database
and update the record so I want to use I
want to leverage the extent of
persistence context that comes with Java
EE so that's why it's stateful and we
have our decoders and encoders
registered up at the top and so we have
a tracking message and I'll show the
decoders next but then as you can see
down here my message takes an abstract
message and then I can either use a
command pattern or you know do an
instance of for each one of the message
types and process it appropriately
well because the abstract method the
reason why I couldn't is because it's
the API as I understand the API right
now that kind of can vary between the
different ones
that's a text remember I said you have
two different types that you can have
you can have a text and you can have a
binary right so this one is your text
one so the the implementation if I tried
it if if I tried to have different ones
for each one it probably might not work
because it's going to say well you know
you already have one you can only
register generally to message on message
handlers in the class it's a little it's
a little vague so I've tried to play it
safe for that so our decoders are
registered up at the top and then the
message object down below that's that's
my understanding of the how the API
works right now and then our chat
message encoder now notice I have the
encoder takes an abstract message type
and then the decoder I'm sorry so yes
this is code samples a little bit older
one of them they both they both take the
abstract message so the the encode
method encodes it to the to the type you
know sitting so this is how to write out
using the Java API for JSON how I you
know create the JSON so I create a
object builder and then you know add my
attributes to it and then convert it
finally to text and return the text as a
part of it and then decoding it once
again it returns a chat message down
below so the decoding method returns a
chat message down below and there's also
a Wilda code up at the top so that gets
called first so when it's trying to
figure out which decoder to use is it
loops over each one of the decoder is
passing in the message and saying
basically can you decode this can you
decode this and the first one that says
yes wins now theoretically you can
actually cache the content because
you've already pre processed part of it
so you'll probably want if you've gone
through like in this case because it's
kind of a bad example I've parsed the
JSON and I say yes I can return yes I
can I can process this and I throw that
object away then what's the first thing
I do down below and the next method I
read it once again in but this is not
specified in a specification as to
whether this is safe and all the
implement
although it probably is because they
might be pooling the coder so you know
the one that gets called with that will
decode might be different than the one
that get that it might be a different
object that then gets called with the
Dakota so it's something to be aware of
so this is basically what I just said on
the previous slide and one thing to note
exceptions in the message in message
processing can wreak havoc I had in
terms of writing the application some of
the worst problems I had in the bugging
things were when the that an exception
was thrown in this because a kind of a
newish feature I had trouble getting
errors back to the client to find out
that you know I generally what would
happen was I would just wouldn't get an
object call it send an object over it
would blow up and then I wouldn't then
my own message would never get called
with some of the behaviors that I saw
while developing the application there's
a little frustrating so and most of the
code says most of the encoders I have a
try/catch throwable to try to catch
anything that blows up right now just to
be safe so I to do that as I mentioned
the WebSocket can be a singleton or a
stateful session bean are you with a
stateful one you can use to extend the
persistence context and this line right
here the annotate on closed on error you
would not use that with the you'd only
do the remove with the on close so if
it's a stateful session being that's
your WebSocket endpoint you're on close
is going to be annotated with the on
remove to tell the container that the
object is no longer being used and it
can be tossed away right so otherwise a
container would have no idea when your
stateful session because no longer being
used so it would hang around in memory
until the server gets shut down or
there's some other until you have like
another timeout configured limitations
on stateful session beans you know you
can receive CDI events so initially when
I've completely forgot what was in the
spec I thought I could broadcast CDI
events to my app to all my stateful
session beans and that does not work I
had to you know use something else
actually every time you fired every one
I tried to use CDI events with it would
try to create another stateful session
so the WebSocket session can be accessed
from other threads semesters to the
client so a couple of things
there's no no compression supported by
default with WebSockets the binary data
is transmitted using base64 don't use
WebSockets on the main login landing
page of your application because if
every time somebody
you know you don't want somebody you
know opening up your application and
leaving it there and having a socket
connection so in terms of this racing
application only when you say join race
and the race is about you know and we're
near that you know like within 10
minutes of starting the race doesn't
open the WebSocket connection there's no
sense in you know tying up servers
waiting for nothing right ws can be
easily sniffed and packets injected each
message can take upwards of two kilobyte
header which is much smaller believe it
or not than a restful service call so it
is extremely compact so if you're
transmitting data lots of data like I
was doing this is a really good way to
do it on the WebSocket connection is
different than the HTTP connection limit
this means that your web browsers can
open up thousands of connections to the
servers which makes it easy to write
something that doesn't denial a service
attack in JavaScript so you're gonna
have a little loop there that sits there
opening up you know anything like 2,000
WebSocket connections are the same
server and Chrome so that's something to
be aware of with it and then WebSocket
stuff will suffer you know in addition
to you know this new denial of service
the thing because remember with Ajax
call you can only make like what 1 or 2
Ajax calls at any given time to the web
server the WebSocket connection you can
open up 3,000 of them from the page
that's where this cross-site scripting
becomes very dangerous absolutely right
it's going to click it'll be at the 10
o'clock okay okay so I went through that
a little fast
okay so jQuery Mobile 50 in the end so
in terms of developing I mean you will
need a mobile framework for doing this
although it's html5 you open up Xcode
and you see all of these predefined
widgets for you so if you're starting
out without using a mobile framework
you're going to be writing a lot of code
trying to get things to look right
because just you know you end up if you
don't use something like that you'll
first have to come up with your own UI
the reason why I use jQuery Mobile for
this presentation as most people are
familiar with jQuery Mobile and it's
optimized for mobile devices
um jQuery Mobile requires jQuery so it's
built on top of it
it also has support for touch which a
lot of developers don't aren't familiar
with but you know you if you develop
desktop applications you not necessarily
used to dealing with touch and then in
terms of NetBeans makes it really easy
to install it
I remember you're going to package the
libraries with your application you're
not going to use a content delivery
network in order to download them so in
order in terms of adding into your
project NetBeans makes it relatively
simple you just go in there and click
that you want to use jQuery jQuery
Mobile etc and it adds it to your
project for you and then just kind of a
quick introduction so this is what the
typical jQuery Mobile page we've got our
data roll which is an html5 thing and
then the dahlia which is content so this
the content is a section that's going to
get replaced every time you click on the
link move between the applications so
although we can't see the application
that's what it looks like so this is the
main menu of the application and that
HTML there that's what it gets rendered
as so we have a nice little thing across
the top with the back with the logout
button and then we have
of our you know individual menu item so
those are all links that result in
another content page getting loaded in
so that is why you want to use a
framework like Sencha touch or any of
the other ones that are up there because
you don't want to have to come you know
because you don't want to have to try
writing the CSS and all the rest of it
to turn it into that right so that's why
you use a mobile framework and I did
this using jQuery Mobile but the one
that I really like to essentia touch
because they have support in there for
device profiles although there's a $400
license for the editor and there's a
substantial learning curve they've got
the concept of device profiles which
allows you to have a different layout
for your application depending upon
whether it is an iPhone or an iPad
because if this is an iPad application
this menu is not going to take up the
whole screen it's going to be along the
left-hand side and you click on each one
of these is going to replace the content
over on the right so that's that's one
of the character that's something that
you'd want to look at for your
applications to realize with your
Cordova application it's going to the UI
is gonna be different it's gonna have
different you know it's not just you
know sizing it differently depending
upon the width of the screen you're
gonna physically lay it out differently
and the sense of touch also has
something that I like coming from the
Java world which is it's got the concept
of layout managers so you're not just
dealing with a CSS stuff all the time so
changing to another page you've got the
mobile change paid Mobile's not change
page just allows you to and JavaScript
code to transition to the next page and
then you've got callbacks for each one
of them that you know you can specify
what happens when you switch to the menu
page you want to update so in the case
of the menu page here is your already
participating in a race it changes join
race to race info meaning that you're
already a part of a race so I had adapt
the UI it's not static UI the content
actually changes okay no you know shift
shift over to security with these things
because there's some some things I have
to be aware of when developing the
application developer in the application
a little bit different first of all as I
mentioned before we don't have HTTP we
also have a different usage pattern than
your typical web application which I'll
get into on the next slide so the Java
as I mentioned we're consuming Java EE
services
on the user's do not expect to
authenticate each time you launch your
application want to change the template
we lost the words and on the right so
the first question to think about when
on this flight is every time you on your
iPhone or Android device you launch your
email application doesn't require that
you enter in your email address and your
username and password in order to access
it know it's cached something that
allows you to login right and and and
with that you'd hope that your
applicated that your applications are
not caching your passwords and user
credentials right because phones are
regularly sold and are lost most users
use the same password for all of their
accounts so and the same email address
which means that if your application is
storing the the names and the passwords
and text or even if they're you know
hashed you know when somebody has the
phone that can run through all of your
accounts and get access to your Facebook
account Google account and everything
else so so anyway so you do not want to
cache usernames and passwords so that
doesn't make the news so how is this so
how is a Cordova application different
than your typical web application and
how in terms of how the user uses the
application well let's look at their
sailing application here so you know the
application gets launched it's ten
seconds later the user clicks on the
thing to like join a race or it uses
race information so the user quits the
application checks email and motors out
to the harbor they get out there if you
launch the application once again they
click on join race it uses the
information that was cached to send the
message up to the server to say I want
to join the race and then the user goes
on racing for the next you know hour and
35 minutes ok and then after that they
decided to update the account or
something like that and then a couple of
hours later they view the results so
even if you were serving up the stuff
from a regular web page and this is
where the mobile you know a mobile
application is not necessarily a good
fit because if you had that HTTP session
the HTTP session is not gonna last for
three hours you're not gonna have that
stuff cached up on the server for three
hours right so that's that's a
difference in terms of this model is
that it's very you know you how many how
many times you know you you check your
email then you
over you check Twitter or something like
this you're constantly happening but
hopping between things and there's
really no concept of a session being
maintained with the server and that
brings up the next thing for this
application and using the Java EE
application you really want to be able
to use security right so you want to be
able to use the roles right so you want
to say you know the race bean is limited
to the skipper so you want to use the
declarative Louis right so it goes from
the Patrick card over to Jack's RS and
then the EJ B's but you want the roles
to be enforced for you and so you might
think well I think in the WebSocket one
yesterday
you know you edit your web XML and you
specify which are the restricted the
URLs won't work because remember the
pages aren't being served up from a
server there's no J session ID there's
no HTTP session me that that stuff is
being handled free for you automatically
okay now you could do this if you're
cashing the password right this is a bad
idea because you're cashing the password
on the on the thing and then with every
request you're going through
authentication again so say you did
decide to save the username and password
you know you figure that none of the
users are smart enough that they're not
going to use the same password for
everything well this means that every
time you issue a request you're going to
include the user giving password which
you know gives the person that's doing
what monitoring wire traffic ample time
to analyze the traffic the better
approach and I'm not claiming that this
is the only approach for doing this I
mean there's a lot there's other things
out there the handle authentication so
there's many different ways this is just
how I tackle it for this presentation
provide kind of like a template or a
starting point for you and show you a
better way of doing it
as token-based authentication which I
used a generated you would on a server
side so the user authenticates once
using the username and password this is
done using post so that you know you
can't capture the
captured as easily and then the server
generates you would which the client
then stores now we can on the server
side we can expire the token after a
certain period of time and force the
user to log in if the user logs in from
another device we could reset the token
at that point you know we have all kinds
of decisions that we can make
that if use if the token isn't valid the
user is forced to real indicate token
authentication is performed before the
web service is actually invoked so
before we even get to the web service
we've verified the token and the other
thing is to remember which we don't have
an option on the WebSocket stuff as
servers can log HTTP requests so you
don't want to put the token in the URL
because otherwise the token would end up
stored in some server logs somewhere so
if somebody gets access or the server
logs that can you know log into it so
one thing you might consider is to write
a web filter which will intercept the
request and perform logins right you
grab the token out of the request and
perform the login and by doing this log
and down below then the Java EE security
will work downstream right because your
principles will be set up in the current
session for the request and then you
know that down below I get that I get
the bean and I do the we're using your
injection here so we get the
authorization being and we do the off
you know the authorization underneath
the hood to login so that's the code
that's down below this is the important
code blown up so you can see it this is
a bad idea and the reason why this is a
bad idea is because every time somebody
makes a rest call your and go off to the
database and check the credentials now
you know generally you know the requests
are going to be coming so there's gonna
be bursts of requests right and so we
don't want to be hammering the data
because the tokens you know we can cache
the tokens and know that if the token is
valid it's valid for a while we don't
want to be hammering the database every
time somebody invokes a web service call
in the application so this is a really
bad idea so for the DBA will love you
when he sees you know there's been like
you know the the user table is accessed
you know ten thousand times per hour you
know is every time every time somebody
clicks on one of those menus get me the
list erases it goes off and does
authentication again you know they're
gonna hate they're gonna allocate that
so the drawbacks is the authentication
is performed on each request the client
must cache their credentials and
resubmit every time the container we
repeatedly checks the database as I
mentioned the alternate approach and
this is very hard to figure out the
first time is you can use jazz pick the
Java authentication API for containers
not many people have done this and it's
something of a black box the dock Java
doc and the Java doc is pretty much
equivalent to you
setname and the Java doc says sets the
name so that's that's that's in terms of
reading and understanding this it's
pretty hard yep yep so we're doing there
so the Jazz pick pieces we've got our
servlet context listener to do the
initial rest registration of the author
content writer so known below the server
off module is what actually does the
work and we've got these things all the
way in between that are basically
factories that create other factories
that return factories for us so you have
to go through if you want to implement
your server off module right now you're
gonna have to implement all of those
factories in order to return that guy
and I don't claim to be an expert on
this API this API there's many things to
this API in terms of learning it the
first time finding code examples what I
did was I went out checked out the
GlassFish source code from repository
found their implementation of it and
started reading through to try to figure
out because you can look at how they're
doing authentication right and you can
read through that and figure out how
they're actually doing it so this is the
initial web listener which register is
our first Factory which is that one then
we register our other factory which then
produces this guy we're almost to the
part that actually does the work finally
we're to the part that actually does the
authentication and here because we don't
this guy does not participate in the CDA
or anything else we have to go and
request our which is a singleton being
which I think I show which actually does
the author is authorization you know
checks that gets the authorized being
and that being this contact is you know
connected into a cache which has the
Kotok ins cached and everything else it
doesn't have to hit the database so what
we're doing is we're specifying the
we're interested in the HTTP message and
we're looking up our own EJB that
performs the authentication this code
sample here and then on the next block
of code this is the code that actually
sets up our principles so that all of
our Java EE roles you know declares
roles requires roles you know will be
what all that will be set up for us and
soap at the top there's two things to
realize and the thing yesterday we're
talking about WebSockets and how do you
authenticate you know how do you deal
with WebSockets because the web socket
API
on the client side there you don't have
the ability to set the HTTP headers so
that means you can't set you know that
the token because I set this X security
token to go back and forth so I know
that the request is you know the
authorization code I include that in the
token and the header well we can't do
that with WebSockets through the only
thing I can do here is I can either
handle it in the on message which would
then I wouldn't be able to you know set
up this stuff because I'm not at the
point that I can do this so what I do
instead is something slightly bad until
they have a better solution as I put the
token and the included in the URL this
is going to do this
in a production environment this would
be going using WSS so I'd be gone with a
secured socket so it's not that bad you
just would have to make sure that your
server logs are locked down and you know
I look at it and I grabbed the they
token off of that and that's how I
attend to Kate the WebSocket so that all
the roles stuff will work on the
WebSocket stuff downstream and then the
singleton being here you can see I'm
using the container manage concurrency
because I want to make sure that this
can handle multiple concurrent requests
at the same time I cache the token and
real implementation this would be
storing the tokens in hazel hazel you
know like in a distributed cache so all
of the nodes so each node doesn't have
to every time a request hits a different
node that node doesn't have to cache it
because you know that and then any of
those in those individual restful calls
are going to go to different nodes in a
load balanced environment right so this
is basically you know a you know just a
sequence diagram showing what's
happening we join the race we check the
token then finally we invoke after that
succeeds after authorization succeeds
and we invoke the RS endpoint and
finally the JB's get called with the
correct role information so Java EE
security of all information okay so no
testing I'll kind of go through this a
little fast so 20 minutes like so
testing can be done on both JavaScript
and Java EE code so for the Java EE code
you use the AR Killian this allows you
to run the container within your unit
tests and using the
the new jax-rs to client-side API so you
can actually test your web your web your
Ajax your restful web services in your
arquillian tests so it allows you to do
automated tests where you fire up the
container and then you have a client
that talks and tests all at all of your
your restful web services and then on
the Java scripting side Java scripting
unlike the Java scripting framework
something like the like the Java side
your your unit test Runner and your
actual assertion testing framework are
separate NetBeans are supports karma and
j/s tests I like karma thus far and so
you have your test Runner which
basically runs a web server uses the
chrome v8 engine underneath the hood to
run your unit tests you can even launch
the web browser to want to run your
tests actually in the Chrome web browser
so you'll actually you can actually see
it launch Chrome and then you use
Jasmine to actually perform and
implement the unit tests so in order to
and to use karma you to install karma
install the karma chrome launcher so
this once again is using the nodejs
stuff and then you configure NetBeans to
use karma specifying a karma
installation directories write tests and
everything else this could be an entire
presentation in and of itself as to how
to use this so this is where I say that
your development environment is very
important so that is one of the benefits
of using like the NetBeans NetBeans
stuff because it ties everything
together for you so then
or focused on how do you deploy it on
Amazon in the meantime you're welcome to
go a create account for free and there's
also a ton of tools on Amazon it's
actually incredible and the
documentation is awesome it really
describes everything top to bottom so I
invite you to check that out I think
next year Java 1 will probably have a
deep dive on how you actually deploy the
application and the implications of load
balancing so coming in next year and
then of course once you have built your
app then you can go off and try to put
it on the various stores the Apple Store
and Roo market and so forth and so on
there will be a cost associated with
that in many cases so just be aware of
that ok and kind of talking back let's
provide that we got accepted next year
actually as a part of this demo we had
grand plans from actually we set up an
Amazon account with wildfly on it with
load balancing and one of the demos we
were going to do but we don't have time
for doing it it's like fail knows and
show failover of like WebSocket
connections and how to implement that
but that turns out that would be like a
whole day training session so I was kind
of like sounded like a great idea back
in June so we did set up the servers and
everything for doing that so best
practices so you want to for rest you
want to use rest for the most part and
WebSocket only for food duplex
bi-directional communication or the rest
request should be not granular of it
should be coarse grains is what I meant
to say there which means that you you
want to return back as much data as
possible for each one because you don't
want it hitting the server a million
times get me get me the race ok give me
the list to race participants ok give me
the the boats for those race
participants you want to return
everything in one call because there's
gonna be like nnessee issues especially
on the mobile phone and for this
application once you get a mile off the
coast they don't have cell phone towers
out there and for JSON versus XML JSON
hands down some cases there's some
support for binary data but you can gzip
is up gzip stuff right now storing state
mostly on the client so this application
if you look through the source code
through it later you'll see that it's
using local storage to store the data
and and that is so that it caches it
locally because every time the
application launches come on have to go
out and fetch your data again because
you might not have a network connection
as I touched upon earlier versioning is
extremely important because your users
may never update your application so
they may take your app install your
application once and then never update
it so you know as you're you know
deploying new versions of your
application if I are on the server you
have to realize you're going to have
older versions of your your applications
so whether you do that with you know you
have one server running the old server
and the load balancer looks at there
with incoming requests and figures out
which server to run it to or you
implement that at the API level there's
many different ways of doing that
finally for security down below I've
shown you the my token based approach in
this case there's also other things that
would require you know you might want to
instead of forcing the user to create
another account you might want to tie
into you know the OAuth stuff there's a
session yesterday on Olaf you might want
to tie in to the people's users Facebook
accounts Google accounts and LinkedIn
accounts or support all of them so
that's where that comes in
then in summary so Apache Cordova
provides basically a true
standards-based cross-platform
development environment Java EE 7 makes
us all possible I can't stress that
enough that it provides a lot of
infrastructure that you would have to
write yourself so you know this really
this is extremely powerful on the you
can use the the demo code as a starting
point yeah
now this is safe you don't and did your
phone yeah yeah I didn't know you can do
that it's ahead so ok ok so yep so this
is the summary of some resources
whatever getting started one yeah other
than the fact that the apatheia doesn't
work a ceiling so Tyrus is the reference
implementation on the Java EE side
there's many things um I got my Twitter
handle
l e underscore Fein F Ino and of course
the two books again shameless plug in
the bookstore you can find Ryan's books
over there
yep gonna have got two more sessions one
this afternoon is on job FX vs. html5
last year's sort of yes sir oh so
there's one actually the applet so this
for that presentation there's basically
a version of this application written in
Java effects so that's what that
presentation we'll be touching upon is
looking at html5 versus Java effects
it's an FX presentation so be comparing
the implementation between the two of
them and this all sounds pretty
straightforward
until you you know start dealing with
some of the video sync receipts with the
browser and all the rest of it right in
terms of the different phone things like
you know the icons I like the bars
across the top and the fact that you
know when like one of the issues with
this application was on the registration
page the when the keyboard would come up
for you to type in the thing it would
push the application up right so behave
as if there's a scrollbar there so then
it wouldn't come back down so there's
all kinds because with the header bar up
at the top so there's all kinds of
little idiosyncrasies so yes html5
applications are extremely easy to write
and very hard to debug okay
but any questions said about five
minutes cordoba versions is it possible
to use the version without well to be
honest with you I practically nothing
about no js' so all you're using is the
thanks everybody</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>