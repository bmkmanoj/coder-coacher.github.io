<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CON2554   Java EE 8 Work in Progress | Coder Coacher - Coaching Coders</title><meta content="CON2554   Java EE 8 Work in Progress - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CON2554   Java EE 8 Work in Progress</b></h2><h5 class="post__date">2015-12-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/xrD6ABcMeTw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everybody thanks for coming I am
Linda de mikkel I'm one of the
specification leads for the Java EE
platform and in this talk I'm going to
give you an overview of work on in
progress on Java EE eight first of all
our standard disclaimer this is
definitely work-in-progress it's my best
assessment of where we are right now
with some speculation as to where we
will be going with some of the api's so
what the says is basically don't base
your financial decisions on what I have
to say here okay so what I'd like to do
is give you an overview of some of the
leading technologies that are part of
Java EE eight not all of them because
this is an overview talk I'll start with
a quick recap of the goals and themes of
this release I'll spend the bulk of the
talk talking about what we have
accomplished and what we intend to
accomplish as we go forward and then at
the end I'll give you some pointers as
to how you can get involved and where
you can get more information at this
conference so as usual when we plan a
platform release we look around with the
current and emerging trends are in the
industry and evaluate what's important
to address within the scope of a given
release so some of these will be
familiar to you from Johnny seven like
the html5 and cloud and mobile some like
HTTP to our new and of course we still
have the goal of ease of development
which has been a theme of arson to java
ee 5 and at the same time also providing
compatibility with previous releases so
that customers can run their existing
applications on new versions of the
platform without worrying about any
incompatibilities so before defining
what we thought should go into this
release we began by polling the
community and we usually do this you
know it conferences like Java one or is
our evangelists go out and speak around
the world we gather feedback on our
users aliases and our blogs and and
jurors and so what we did was we can
solid
we had been hearing and we consolidated
these ideas into the biggest survey that
we've ever run it has three parts
probably 50 to 60 questions including a
number of fill-in-the-blank questions
where people could write assess a as if
they want it and we got thousands of
responses and as the final part of this
survey we asked people to prioritize
among what were the most frequently
requested features in the first two
parts this pie chart here reflects those
results from part three you may have
seen a different version of it if you
went to the keynote yesterday but as you
can see jason b is the leading
technology that was most requested we
had a lot of emphasis on security
improvements mbc SSC and i'll be talking
about some of these as we go forward now
with any release we can't do everything
so we had to prioritize what the
prioritized list was and i'll be talking
about that as we go on so we normally
try to extract themes from what we're
going to do just to keep us honest as we
define our technologies and to allow
people to focus on what we see is most
important so in this release our themes
are pretty much the same as in the last
release that is the emphasis on web tier
enhancements continuing our theme of
ease of development particularly through
leveraging CDI and then improvements for
the infrastructure not just for
on-premise but particularly improvements
for cloud-based applications okay so
let's start with a web tier which is
where we've been putting most of our
focus I'm going to be talking about all
of these technologies as we go on to
this talk okay first of all Jason the
API for Jason binding this was the most
requested feature that we had in our
survey and what this is is it simply an
API for marshalling and unmarked Java
objects to and from json text
so you can think of this is similar to
Jack's be in the XML world or JPA in the
object relational mapping world and much
as we did with jpa our intent here is
not to create api's from whole cloth but
to draw upon the best practices of
existing Jason binding implementations
out there in the industry so of these
Moxie is our own it was done in the
Eclipse Link project which is where
we're pursuing this JSON be release
Jackson I understand is probably the
most popular also we want to allow you
to choose your Jason binding provider
implementation so much like JPA you can
choose the provider that you're most
comfortable with or which might have the
added features that you're most familiar
with and again to foster ease of
development we want to provide default
mappings that are the most prevalent
ones that you would want and give you
opportunities for customization through
annotations okay so Jason the JSON
binding jsr has released its early draft
you can download it you can explore the
API so I'm just going to give you some
highlights here so there are two key
interfaces that you should become
familiar with JSON builder which is the
entry point into the binding API it has
the operations for setting your provider
implementation or setting configuration
properties JSON B is the interface where
you'll be doing most of your actual work
it's an abstraction over the binding
framework operations you get an instance
of it through JSON builder and it has
the api's from from JSON and to JSON for
the for the unmarked lling and the
marshalling of JSON okay so looking at a
simple example here's a POJO I've
labeled it as an entity because I want
to stress that I want this to work all
the way from the jpa
persistence tier up through to the web
client so we're going to create a person
a Duke with a gender name and some phone
information and then using the JSON
operations I first create an instance of
the JSON be JSON be and then I simply
use JSON be the to JSON operation to
transform this pojo into json text and
you get what is on the right side of the
slide I've cheated a little because I
pretty printed it and I don't think I
think that you need to specify some
option for pretty printing but but
anyway you get a result it looks like
this so the goal here is to give you a
smooth solution all the way from the
client to the database and back so you
can use jpa to extract your data in
terms of Java pojos and then Jason be to
extract the state of those objects as
json text and this also gives jax-rs
which is very likely to be in the middle
here in many applications a standard way
of supporting the application JSON media
type okay so underneath JSON be we have
Jason P the API for Java for JSON
processing so the JSON binding
implementation can build upon the Jason
processing API we introduced Jason
processing as part of java ee 7 the
goals here are basically to keep it up
to date to track new standards in this
area new standards from I ATF and these
entail adding editing operations for
Jason objects and JSON arrays and then
also we're adding helper classes in
methods to better utilize the stream and
lambdas of java SE eight so let's look
at some of this
so one of the new standards in this
space is JSON pointer which is you know
what you'd guess from its name it's
basically a syntax for referencing into
a JSON document like the one I've shown
on this screen which is referencing into
an array extracting a mobile phone piece
of data so let's build up an example I'm
going to whip through this but what
we're doing here is we're using the JSON
API s that were introduced in java ee 7
to create a document that consists of
information for Duke and Jane so it's
going to look something like this on the
right hand side and then using the new
Jason processing api's and again I
should say that Jason processing spec
has had its early draft so you can
download all of this as well we're going
to create an instance of JSON pointer
the pointer is just a standalone pointer
it's not yet attached to a document so
you could plausibly use it over several
documents and then when we extract the
value pointing this pointer at a
document in this case our contacts array
we can extract the value from it which
will be Dukes phone we've also
introduced operations convenience
operations for mutating a JSON document
through JSON pointers so that I can use
the pointer to to add to replace or to
remove values from a JSON document so
here I'm using it to replace the value
of Dukes dukes phone Dukes mobile phone
in particular so you get a result like
that another new standard in the space
is JSON patch what a patch is is its
itself a JSON document that specifies an
array of operations for changing one or
more other documents and it's got a
standard set of operations I think the
full list is here
adding replacing removing and so on so
the way this is structured is that your
patch has an OP field which specifies
what you want to do and then it's got a
path which you can think of as a pointer
and depending on what the operation is
it may have other values as well such as
the replacement value here in the first
one of these operations so i'm using the
json processing api the way we deal with
patches is to create them we use a patch
builder so this gives you a fluent
syntax for creating a patch so in this
patch we're going to add operations the
same operations actually as I showed you
in the previous json text to replace the
value of the mobile phone and to remove
the second element of the array so I
build this patch and when you have a
patch the operations of the patch are
executed in sequence so if we point this
patch at our document in our contacts
document and then apply the patch what's
going to happen is first of all we're
going to change Dukes mobile phone and
then secondly we're going to oops
something went wrong here and then
secondly we're going to delete Jane from
the array another area that we wanted to
address here is integration of these
Jason operations with java SE eight
stream operations and lambdas so in this
example i'm taking our contacts document
and basically filtering it for the
contact information for the females in
the in the document and then extracting
their names and what this is giving me
using the standard java SE eight
operations is it's giving me a list of
strings which is I mean it's fine but
it's somewhat undesirable from a J's
point of view because now you're outside
the JSON world so to fix this problem
what we're doing is adding JSON specific
collectors so in this case we're adding
in a collector to to map the resulting
operations map the result of the
operations to an array there also a
collector for mapping to object and
there's even a group by this is also in
the API that was just released with the
early draft okay server sent events so
some recent events are part of the html5
standard what they're used for is server
to client streaming of textual data and
there's a specific mime type that's
associated with server sent events so
the way this works is that the client
establishes a connection to the server
that's intended to be held for some
period of time it's not closed after the
initial request response cycle and the
server holds on to this and it uses this
to push update notifications to the
client so is it a notification an event
becomes available it's pushed to the
client the client that processes the
event and the server is pushing the next
event so you can think of this as a very
basic pub/sub capability it doesn't have
the sophistication say objects of JMS
but it's but it's a basic facility for
server to client notifications so when
we start at this work we asked ourselves
you know there are multiple places where
we could do this work we could extend
the web socket API we could extend
jax-rs we could build this on servlets
we could do some kind of stand-alone
standalone work we polled the platform
expert group and we polled other expert
groups as to what their opinions were
of how we should proceed with this the
results we got back were that little
jax-rs was the most natural fit it
already supports streaming of HTTP
resources it turns out that this is we
think a fairly small extension to the
jax-rs API on the server side you need
the support for the new media type and
then output and then on the client if
you're going to support jax-rs clients
you need a handler for the events now
your client could simply be a JavaScript
client there's there's no requirement
that you use jax-rs on the client but if
if you want to them we need a simple
client API so the other benefit here is
that you can mix this with other
operations in jax-rs and our reference
implementation for jax-rs Jersey already
supports server sent event now there's
no expectation that what the expert
group is going to converge on is going
to look like what we have in Jersey we
don't we don't ever expect that but
they're currently actively engaged in
the back and forth of you know what's
the best model for server sent event so
if you go to their mailing list you'll
see there's a flurry of discussion has
started here so the examples i'm going
to show you are based on our Jersey
implementation but you should not expect
again that what's going to shake out at
the end is going to look exactly like
this it's just to give you an idea of
what's entailed okay so we have a jax-rs
resource class and we've got a resource
method here that's going to produce
server sent events so notice that on the
produces we specify the media type is
that which is specific for server sent
events so you can pretty much identify
that this is going to be a producer for
server sent events so we create a new
event output object and we produced we
we send this over to a thread which is
going to be producing these events so if
we look at the thread the key parts on
the right hand side here on these
schematics it's the thread that's going
to be in a loop until something caught
is this activity to be terminated or the
connection closed and it's going to be
sending out our stock quote information
on the client side again if we're doing
a jax-rs client the client looks pretty
much like other jax-rs clients that it
sets the target and what it has to do
here is to create a listener method
that's going to be called when the
events arrive so when the inbound event
arrives then this method is going to
take the inbound event and then extract
extract the appropriate data from it and
then the whole process kicks off when in
fact the client opens the event source
so MVC support for action based MVC was
another frequently requested technology
in our community survey so as you
probably know there are two basic styles
of MVC architecture component-based MVC
where the the controller for the the
controller piece of the
model-view-controller architecture is
provided by the framework itself and
this is the case with JSF for example so
we already have support for
component-based MVC in the platform with
action based MVC it's the applications
responsibility to do the controlling to
handle the inbound requests and then
update the models and produce the output
and so on so this is what we're
targeting in this release again we don't
want to do this from whole cloth what we
want to do here is to use this
architecture to glue together our other
parts of the platform in a consistent
way so for the model we want to be able
to use CD I managed beans in conjunction
with support from bean validation jpa on
the backend likely for the view we
already have to view languages
we have facelets and we have jsps so the
model-view-controller spec is requiring
that both of these be supported you can
use a CDI spi for pluggable integration
of other view templating languages if
you so desire and then the controller
and again this was a point of some
discussion when we first launched this
jsr but it was decided among the expert
group members that the controller again
should be done through jax-rs through
jax-rs resource methods so the MVC
expert group has just released its
second early draft you can again
download that and have a detailed look
at at the api's so let me give you an
example this is actually from the spec
so here we have a simple controller path
controller resource class and notice
that we've annotated the controller
method with the controller annotation so
you can apply the controller annotation
to the method that you want to be the
controller forgiven request or you can
apply it at class level in which case
all of the resources methods are assumed
to be controller methods the
disadvantage there of course is that
then you can't have a hybrid jax-rs
resource class where other methods could
be jack plain ordinary jax-rs resource
methods but it's your choice ok so our
controller in this example is returning
a string and when you do that the
results of the controller method are
interpreted as the view path so we're
returning here a reference to hello JSP
there are other ways of specifying this
you could use the view annotation to
return your view path or there's also a
viewable class which I think gives you a
few more configuration options you can
return a viewable details are in the
current spec so here in this controller
method we're basically we're taking the
the model which is going to be our
greeting class which we're injecting
here and we're setting
value in it so to look at our model our
model in this case is just a simple CDI
managed bean it's just a plain pojo so
we're updating the model in our
controller and then in the view this is
a JSP view notice that in the in the JSP
we're using the expression language to
extract the value that we just set in
the model which is the message hello
there which is what's going to be
displayed okay all right HTTP two is an
important standard that was just
finalized and the reason HTTP two is
important is it addresses the many
limitations of the existing HTTP 11
protocol which has been around for quite
a while and the problem is is that HTTP
11 uses the underlying TCP fairly poorly
for its purpose that is the HTTP flows
are kind of short in bursty but TCP was
intended for more long-lived flows so
their number of workarounds you're
probably familiar with a bunch of these
you know using sprites and CSS to
overlay combine multiple images in one
and then extract out what you want so
you don't have multiple requests and
fetching of the images sharding across
multiple domains to get parallelism in
lining stuff that you probably didn't
want to in line and so on so the goals
of HTTP two are to reduce the latency
that's inherent in the HTTP 11 protocol
including addressing the head of line
blocking problem or a lengthy initial
transmission slows down everything
that's coming afterwards to support
parallelism so that you don't have to
have multiple connections to get
parallel ISM and all of this is on with
keeping the same user visible semantics
of eight
ttp 11 so that this is largely
transparent to your application except
for the better performance so the way
this works is that in HTTP to
communications broken down into frames
which and the frames themselves are self
identifying so this allows streams of
messages to be interwoven over a single
connection so what you're doing is
you're multiplexing requests and
responses over a single connection and
handling multiple streams over that
connection it's the binary framing layer
that makes all this work in addition you
can specify you can specify with your
frame you can specify for your streams a
priority so that this can be used by the
protocol to determine what gets sent
shipped first so for example if you're
displaying a web page you probably want
your CSS to come before your just the
stuff that you're displaying there's an
option for server push so that on the
server side you can anticipate what the
clients going to need send it over and
let let their let it be cached on the
client there's also facility for header
compression so that you know with HTTP
we're talking to the same endpoints
there are lots of duplicates in your
headers you know like the accepts or the
user agent or so that this header
compression allows that to be eliminated
okay so it's the task of the servlet
expert group to support this in java ee
8 this is a major task so this becomes
servlet four-point-oh now and the server
loan expert group will need to figure
out in addition to the support which
should actually be surfaced and serve
the servlet api so I think so far that
they've agreed that the stream
prioritization and server push should be
surfaced as part of the api's that the
application could be using I think
there's some current disguise
Shin as to the the request response
multiplexing I think that discussion
still ongoing but again the servlet
expert group is busily involved in this
work I believe servlet has also released
its it's early draft now so you can
download you can download that as well
ok so now I want to shift gears and talk
about the ease of development theme this
has been a theme with us since Java EE
five when annotations were first
introduced and when we did some enormous
simplifications of some of our api's
this work is still ongoing but now we
have CDI that we can leverage to aid us
in the simplification so I want to talk
here about security interceptors
simplified messaging and pruning there
are a couple of other items that I'm not
going to discuss in particular we know
that jax-rs has some injection alignment
work that it needs to do we also know
that we need to define as a CDI scope
for web socket endpoints so that will
likely be addressed in a maintenance
release for web socket ok let's talk
about security interceptors so in java
ee 7 we introduced transactional
interceptors using the CDI interceptor
facility so that transactional
interceptors could be available for all
managed beans now this was building upon
an ease of use technique that we had
from way back when in the ejb spec with
container managed transactions you
declaratively specify that you need a
transaction or you need a new
transaction using an annotation and then
it's the responsibility the container to
initiate that transaction for you or to
ensure that you are in fact in a
transaction so we did that using CDI
interceptors we'd like to do something
similar with regard to security
authorization again leveraging CDI
interceptors I'm
the examples here I think I took from a
jira entry that was submitted there's a
very good ideas here again the security
expert group will be looking at this and
I think they're going to come up with
something even more sophisticated but
just to give you an idea what we want to
accomplish so with this is authorization
is authorized annotation note that we're
not only specifying the roles that are
required to execute a given method but
we're also through the use of expression
language accessing contextual
information so and the first example
we're we're checking the role for the
manager role but we're also checking
whether the context information for the
the schedule is in fact on the
appropriate hours in the second example
we're checking whether the caller has
the attribute where the direct reports
that correspond to the call or actually
contain the ID of the employee whose
salary information is going to be
accessed in the third example we're
accessing a repository of rules and
we're going to check whether the rule
for report is satisfied by the given
invocation so you can do some fairly
sophisticated things with just simple
annotations where the container is
interposing through interceptors I'll be
talking about some other security
features a bit later the security jsr
the security expert group is still in
the process of doing its its early draft
so this is not out there yet so what I'm
saying here is a little bit speculative
but they've just been bubbling with
great ideas there's a lot of enthusiasm
in the users group for that jsr and
again you can track it on the web
everything is available to you
okay JMS so JMS 2 point 0 which was part
of java ee 7 did a really great job of
simplifying the JMS api's again
leveraging the facilities of CDI but one
thing that didn't change was support for
asynchronous message delivery in the
form of message driven beans now message
driven means are part of the ejb spec
they're not part of the JMS spec but in
this release on the JMS expert group
would like to improve those api's
message driven beans haven't really
changed they were first introduced way
back when in ejb two point oh I think it
was they were then one of the simpler of
the ejb types but now they feel quite
outmoded so the goal here is to improve
message driven beans by focusing on JMS
message driven beans I mean that's the
leading case where the use of message
driven beans in addition we've had some
suggestions that we provide an
alternative to message driven beans by
allowing message delivery to CD I
managed beans and there were some
suggestions well maybe we can use the
observant observer mechanism of CDI to
do this this is a little bit more
speculative I think our spec lead would
like to get into this if time allows and
we can find a clean solution but that's
a little bit more speculative so to give
you some examples okay so what do we
currently have the slide kind of shows
the mess that exists today this is not
what JMS 2 point 0 would like to see
this is what we have in java ee 7 with
ejb as it is so when you have a
message-driven being there's a lot of
gobbledygook that you need to specify
for that message driven beam you need
activation config properties whether you
have whether you have a whole list of
them in your annotation like I've done
here which makes for some really ugly
code or whether you specify them in XML
and there are a number of disadvantages
here this is kind of old
style API design because these are just
properties they're just strings so
you're not going to get any help from
the compiler if no you know are you
specifying the right property name or
the right property value is the property
name even appropriate for the beam type
that you're defining there's no way to
get any kind of assistance from your
compiler on that or from your IDE and
that matter so that's kind of a mess and
then message driven beans were designed
to be more flexible than just targeting
JMS so if you want a JMS message driven
bean or any kind of message driven be
there's the issue of implementing the
message listener interface for the
message driven being tight and that can
strange you as well because here for JMS
we can have only a single a single
argument it's a message so you have to
you know you have to parse the message
is the particular message type it's
already generic and then do the
extraction do the extraction here so so
it's fairly restrictive and rather
suboptimal so what we're proposing I
think you could label as flexible JMS
message driven beans where the user can
define the callback method and possibly
you want more than one callback method
in your message driven bean maybe it
wants to handle more than one key or
topic for example and we want to
configure it using JMS specific
annotations which gives us more leverage
in terms of getting support and more
flexible message signatures for example
not just a single argument that maybe we
want to get access to the concrete
message type and the headers or
properties and so on so here's an
example of how much simpler this could
look we're using here a JMS queue
listener annotation so that we know
we're going to be associated with a
queue and we're simply specifying in the
destination lookup element here the
queue that were associated with and
because we're not implementing to a
specific interface we could call our
callback method anything so note we're
capturing the JMS specific feature here
through the annotation that we're
applying to the callback method so we
could have callback methods for durable
or nondurable topics as well in this
case we have a durable topic listener
and notice that we have elements of this
annotation that are specific to durable
topic subscription name and client ID so
you get help from the compiler in the
IDE and figuring out what you actually
need to supply when you're using such a
message-driven being and then another
simple example of how the flexibility in
the callback method helps you a callback
method is required to receive the
message but by the use of annotations
you can specify that the container
provide the facility of extracting other
information that you you want from the
message so header information or
property information so that in your own
code you don't have to go through the
more laborious extraction ap is so this
is all great we'll have a couple of
talks on JMS later I'll be giving you
some pointers I thought I saw our
specification lead way back there in the
last row Nigel Deacon he'll be speaking
of it later in the conference okay
another way to achieve simplification is
through what we loosely term pruning and
the idea here is to get stuff out of the
developers way that developer really
doesn't want to have to think about so
that's kind of an informal definition in
an informal word for what's actually a
fairly formal process what the process
is and it was defined initially by java
SC is it's a two-phase process a
platform expert group one platform
expert group defines a technology as
quote unquote proposed optional and what
this means is it gives notice to the
community
that we think that there are better
alternatives for you to use and maybe
you shouldn't write new applications to
this particular technology the next
platform expert group so the next
platform jsr has the option of defining
that technology now as truly optional it
doesn't have to it could punt the
decision or it could decide not to but
what optional means is that your
platform vendor still has the option of
implementing the technology of
continuing to implement the technology
but it doesn't have to if it does
implement the technology then it has to
conform to all the requirements of the
specification for that technology so the
implementations all or nothing you can't
pick or choose which features for a
given optional feature you will or won't
implement so in java ee 6 we defined
jax-rpc old-style ejb entity beans
Chuck's are and the deployment API jsr
88 as proposed optional and in java ee 7
we made all of these now as optional for
vendors to implement so in Java EE 8 we
just recently proposed to the platform
expert group that we consider that we
make support for korba including iiop
interoperability that we move that to
proposed optional status so this means
if we do this in Java EE 8 it can't be
until Java EE nine that we could
actually make the decision to make those
technologies optional and because ejb
the old style ejb client view is the
part of ejb that requires support for I
aop interoperability we're also
proposing that we move that to proposed
optional status the ejb 30 simplified
api the simplified remote business
interface
they have never required support for iop
interoperability I know that some vendor
support it for them anyway but it has
never been required by the spec so this
would mean ejb object and ejb home
interfaces would be pruned that's the
remote client view at the same time I'd
also like to prune the corresponding
local client view it's similarly clunky
and awkward so what we're talking about
is this is the old style ejb client view
you have these pairs of interfaces
notice all the checked exceptions in ejb
30 we replaced it with this so we've had
some discussion in the platform expert
group our experts are by no means
unanimous about this on the discussion
still ongoing but one of the things that
we wanted to do here at javaone was to
gather feedback from you all as to what
we should do so we have this handy dandy
pulling mechanism so while we're here
with that if you have it up and running
so option a would be yes we should
define korba and I p inner up as
proposed optional and option B would be
no we don't want to do that okay
a was yes we should prune support for
korba and I aop interop and the old
style client view this is all one big
package and he was no don't prune whoa
really how many responses did we get how
many eight only eight can we get more of
you guys people are jumping in last
second it's not fair if we don't get
some nose on there let me let me push it
again and see what people think now we
got 24 in okay I'll pull you at the end
for the for the results yeah it's on
okay so um I want to talk about a third
of our themes which I've labeled here is
modernizing the infrastructure on the
infrastructure that I'm going to talk
about could definitely use some
modernisation so first of all is the
management API that we're doing which is
intended to be a replacement for the old
j2ee management AP is and then many
enhancements that we're doing in the
security area and i'll be talking about
a few of these not all of these because
we won't have time so in terms of the
management API this is intended again is
an update to jsr 77 it's its name gives
away how sorely in need of modernization
it is I think it hasn't been updated for
probably 10 years so what we want to do
here is we think the functionality is
basically good but the old style
management API basically relies on on
remote ejbs what we want to do is we
want to have rest-based interfaces as a
replacement or an augmentation and alter
for you for the management EP is and
this is certainly a more suitable for
use in cloud environment and our spec
lead has also proposed that we consider
adding simple deployment interfaces if
we have time in this work to also
consider that as part of this management
API this work has been rather slow in
getting going I think we'll see some
activity in the next couple of months
but there's not much that I can report
on yet one other thing I should note is
if this comes to fruition then we will
also at some future date perhaps in Java
EE 9 have the discussion as to whether
the old style API should become proposed
optional in our new security jsr we've
had a vast flurry of activity you know
the problem is that the our current
situation with security and Java EE has
been you know subject to a fair amount
of criticism mostly justified that it's
you know it's too hard to use it's too
complex it's confusing it's you know
it's out of date it's not particularly
portable doesn't fit the cloud paradigm
that applications want more flexibility
so we know we need to fix this the
agenda that our spec lead has proposed
is really very ambitious I'll be happy
if we can you know address the majority
of these items and this release but I
think that it's quite likely that this
work would span more than one release so
password aliasing this is kind of a
leftover item from java ee 7 we tried to
introduce the notion of password alias
as a java ee 7 the idea is that you
should never have a clear text password
in your code in your metadata anywhere
and the proposed solution here is that
instead of the actual password that you
be able to define password aliases and
use the password alias instead and then
the mapping from the password elias to
the actual password is captured in a
secure credentials are
five which you can ship with your
application and then the platform
implementation would use that at runtime
for resolving the alias for resolving
the alias so in this little code snippet
you know instead of a clear text
password i'm using the alias for for
Dukes password another area where we
want to do some simplifications is in
user management particularly allowing
the application to manage its own users
and groups this was proposed again as a
JIRA issue we had some great suggestions
and JIRA issues and some very
interesting discussion actually in the
Jura itself so you want the application
to be able to manage its own users and
groups without the need for accessing
the server configuration and again this
is something that we would want to have
for use in cloud environments so this
leverage is the idea that we introduced
or the the kind of annotations that we
introduced in java ee 7 and actually
java ee 6 with data source definition
where the application can specify
dependency on an object that it expects
to be supplied in its environment so
here you would want to be able to supply
an application specified repository for
this information so it could be ldap it
could be database it could be file based
and then you specify this dependency and
then you inject a reference a resource
reference to the service that
corresponds to the repository so for
user a user service would manipulate the
users from this user source so the this
is again based on a dira proposal I
expect that the final ap is that come
out here will look somewhat different
but this captures the basic idea so that
you would have your user source
definition specifying your repository a
user service with operations to create
and
users adding users to groups getting
information and then some user info
interface that will actually give you
the details of the data here so this
might look like this where we have an
LDAP specific user source definition
annotation we're specifying the jinda
name under which under which this would
be accessed and then the URL did
actually maps to where it is a user and
password alias for it and then in your
runtime code you'd inject a reference to
this to the ldap user source and then
your user service that cars that is is
basically the entry point for that
resource would have operations to
extract and manipulate the information
from the service we want to do similarly
with role mapping again group to roll
mapping is you know it depends on what
vendor you're using there are many
defaults they're not all the same but
there's some common models so we'd like
to use this model again for this
particular area so that you can store
your role mapping info in an application
specified repository file system
database whatever and then your
application can use this to assign roles
to users and groups based on an
application specific model again without
access to the server configuration so we
would proceed similarly here with say a
role map or definition annotation to
specify the dependency on the repository
and then a service that corresponds to
that where you can access roles don't
worry about the slides will be available
to you later on so that you can get the
roles that correspond to particular
users okay so where are we so far we
have 11 major jsr s that are undergoing
significant updates for Java EE eight of
these three are new JSON binding MVC and
the new security jsr I think management
is like
after new because it's kind of a major
revision of what was there both MVC and
Jason binding have had early drafts out
there for you know some period of time
now so we asked the platform expert
group if the platform expert group
thought that they should be included as
required technologies in the Java EE 8
platform and in the Java EE eight web
profile the answer came back as a
resounding yes so if you download the
the new platform EDR you'll see that
these are now required in Java EE eight
security jsr is expected to have an
early draft sometime in the next couple
of months and when we get more
information from the security expert
group will have similar discussions in
the platform expert group so in addition
to those j srs we're also expecting to
do a number of maintenance releases and
what I'm thinking are going to be
smaller jsr s bean validation hasn't
been proposed yet but I think there's
going to be a new jsr in this space from
Red Hat and I know IBM is doing a batch
maintenance release I don't know if
there's going to be more than one but
they're in the process of working on
that with some of these other
technologies some of these maintenance
releases will be gated by requirements
of the main j srs that were undertaking
so for example connector architecture
and ejb we expect to have maintenance
releases there that are driven by the
changes in JMS 21 so ejb for managed
message driven beings and the connector
support for that interceptors I found a
few issues in the Interceptor spec so
I'm currently working on a proposal for
that JP a jpa is going to be having a
maintenance release our spec lead our
new spec lead for JP a no longer me it's
going to be presenting on that I think
later today and then we'll have some
changes for JTA and javamail as well ok
so how do you get involved all of our
Oracle lead java ee 8j srs are run on
java.net if you go to the first URL here
this is the URL for the platform jsr the
reason you would want to go there is
that there's a table that we are linked
in there which is the second URL here
and you can get to it from the the wiki
on the on the the first URL which has a
table of all of the platform jsr s not
just the ones that we're updating in
this release but all of them and it has
pointers to their java.net projects and
it has pointers to their JCP pages so
that you can use this as a reference to
get information so for all of our Oracle
led jsr s and this is also true for the
IBM and Red Hat led pieces of work
they're publicly viewable mailing lists
you can subscribe to mailing lists our
users observer lists get copies of all
the emails sent to the expert group you
can download all of these specification
drafts and you can submit issues and
discussion items other ways to get
involved are through the adopted jsr
program this is a really great program
where people can get together in groups
and focus on single jsr s and channel
feed back into those expert groups on
behalf of the adopted jsr members so
there are adopted jsr s for many of our
jsr s you can always establish one if
one does not exist so here's a reference
to a page that this is our glassfish
page for java ee adopted jsr projects
but it has links to the more generic
adopted jsr website as well you can join
an expert group if you don't feel
qualified to be a full-fledged expert
you can join on the user you can join
the project and participate on the
user's list where you can discuss you
can discuss issues with other users and
with expert group members we use the
aquarium to broadcast updates major
updates on our jsr activity so that's a
really easy way to track things if you
don't want to get
the nitty-gritty expert group discussion
and then as usual our reference
implementation is glass fish so where to
learn more there's way more than I could
list in the slide without getting really
small on the fonts but what this
basically is is it's a list of talks by
speculates on the j srs that i've been
talking about and then some so if you
basically i think stay on this floor for
the rest of the conference you can have
your fill of java e8 and then i'd like
to note that at the end of all of this
will be having or meet the java ee
specification leaves off tomorrow night
at eight o'clock i think in this room
where you can come talk to me and all of
our other specification leads who can
make it including members from Red Hat
and IBM and join us in some lively
discussion ok so i think i have a few
minutes for Q&amp;amp;A and i'll leave this
slide up in case anybody wants to crib
anything from it other questions you if
you want to yeah yeah let's see I'm kind
of trapped here with all my cords what's
the latest update for GPA 22 can we have
the latest documents as far as I know
there are no documents yet there's a
talk on jpa tomorrow at twelve thirty by
the person who is taking over the the
JPA spec Lucas young men will be talking
at two thirty this would be a great
question for him can i download this
presentation somewhere i'll make i'll
make the slides available i haven't
uploaded them yet but they should be
available when you go to the content for
this talk there should be a link in
future for these slides I'll make them
available to the conference why is the
portlet chase are not part of j2ee I
actually can't answer that I think that
just
predates me so I don't have maybe
they'll shot and can answer that
tomorrow night this it just three
questions okay well thanks everybody and
I'll be around if you want to come up
after this talk or catch me in the
hallway or come to the box</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>