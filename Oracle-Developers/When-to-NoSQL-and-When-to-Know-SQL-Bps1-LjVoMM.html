<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>When to NoSQL and When to Know SQL | Coder Coacher - Coaching Coders</title><meta content="When to NoSQL and When to Know SQL - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>When to NoSQL and When to Know SQL</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Bps1-LjVoMM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so just to give you a little bit of an
introduction of me and what I'm going to
be talking about today
my name is Simon Oh Istanbul I'm a head
of big data at wreck eight software we
usually make database tools but we're
also looking at researching no sequel
tools and researching how people deal
with change in schema and all those kind
of good things so if anyone has any
interest in that then please come and
find me and chat to me afterwards for
now I'm gonna make sure that all the
slides for this presentation are online
at that URL
I am trying at moment to make this
website a bit of a community around this
issue so please feel free to go on to it
and comment and hopefully we can build
it up into something that's a bit more
useful and a resource about this kind of
topic for everyone when I get some spare
time in between talking to good folks
like yourselves
so yeah if you want to contact me or
have any questions for me then that's me
on Twitter please follow me a hashtag
get in touch
I will quite happily take any questions
and if I go too fast or if there's
anything that's not clear throughout
then just stick your hand up and feel
free to interrupt and I'll try and I'll
try and notice apologies to the people
stuck behind the pillar I might not
manage back so about further ado let's
try and find out what is no sequel so
I'm going to start with a bit of a bit
of history behind this room back in the
day though is sequel and everything was
sequel you didn't really have a debate
as to what sort of database or what sort
of datastore you used you just put it
all in good old fashioned sequel that
didn't quite work for everyone so Along
Came no sequel and yeah this was a
fairly aggressive movement it was a
revolution you know you were not gonna
use any sequel at all it was all going
to be no sequel because of all the
terrible problems of acid and then we
realized that actually there was some
space for sequel still so we moved on to
be not only sequel movement and nowadays
we've kind of come full circle and
got to the point where we're just saying
no you sequel but real answer to this
question is that no sequel is a lot of
different things
so before sequel even came along there
were things which three states look a
lot like the kind of things that get
called no sequel you know we had things
like files that we stored data in we had
things like multi value databases
I don't know this anyone ever used a
multi value database like the old pic
databases yeah there's always one yeah
oh wow this is a record so yeah and all
these old multi value databases were
just never the kind of structures of
which are starting to come back to life
and be rediscovered into this trend
which is interesting and of course yeah
we have these things called hash maps so
I had a conversation with a very excited
member of the nodejs community the other
day who just discovered hash maps and
other sorry had invented hash maps and
he was very sorry to be disillusioned of
his fact so before sequel there were a
lot of things which looked a bit like
most sequel then Along Came the sequel
database VR DBMS for relational paradigm
and caught on all those good things and
everything switched to sequel you
weren't doing it right unless you were
using a full third normal form or even
fourth some people even go that far I
technically I think there is a seventh
but I don't think I've ever seen matte
implemented
yeah people started to use ORM s to fill
in the fact that not all of these data
structures fitted the way that you
wanted a program against these kind of
databases and if you wanted to scale
then you scaled up you bought more
hardware you weight up your Oracle
account exec to come round and offer
you've a chance to spend more money
scale up was the only way to go and you
started your design with the data I
think this is a fundamental point about
the difference between these two
technologies is that with sequel systems
and with our DBMS is you start with your
schema and then you build your
application around it
so what's different now we have no
sequel we have data stores which are
designed for V applications specific
needs so they're designed around the way
that you build an application not around
for way that you want to store
enterprise data that's a fundamental
difference we've got this principle of
polygon persistence where you can use
any old data store you want you don't
just have to use one day to Stoff your
application you can use the right one
but one that fits for job for that
particular type of data and that's okay
now cuz Martin Fowler says it's okay
scale out rules now instead of just
buying that one big server you can buy a
lot of little ones so instead of getting
the big giant IBM box you now go to Dell
and get a tiny little pizza box and it
doesn't matter how often they fail
because you can just slot in another one
and they're really cheap so it's a
different scaling paradigm and I think
the important element about this is that
we've moved away from considering data
as a series of enterprise data
warehouses to sort a big central point
in which data lives for your entire
corporation and move much taller and
more towards a a collection of API is a
collection of applications which
interact and which store their own data
behind those api's behind those
microservices so why should you care
about any of this what good is it for
anyone here well data growth is pretty
undeniable and people throw around to
exabytes and zettabytes and all sorts of
numbers so and I won't come up with my
own ones of those but there's more to it
than just for data growth there's also
the development productivity of your
programmers a lot of these technologies
allow patterns of data storage which
allow very very rapid development and
we'll look at some of those in a bit you
have a you have the issue of meaning of
being able to avoid migration problems
so in the olden days when you had a
rigid sequel schemer and you wanted to
ship some new code which just added a
field then that was weeks and waiting
for your DBA to say yes it's okay to run
this script that just adds a field
you get things like I've found a lot of
DBAs who talked about things like
migration Thursdays or migration
Tuesdays or something the only day when
you can possibly change a database in a
huge great change process so a lot of
these technologies allow a more flexible
schema and allow you to get round first
sort of problems and yabber some caveats
with that I'd save it yeah there are
fewer migration headaches generally but
it still happens you still have some
sort of schema we're also new yoots
cases are enabled by these kind of
technologies were things like machine
learning algorithms so things like graph
databases and enable recommend us I
don't know if anyone was in the session
that couple of sessions go ahead looking
at recommenders and graph databases yeah
there are all sorts of new techniques
which are much easier to write in these
kind of contests and of course the
social media which brings around new
approaches to data new structures new
interactions of data especially graph
databases graph databases are just for
social and don't don't believe anything
else the other reason you should care is
big bucks this is the O'Reilly our data
science salary survey from last year
they're about it they'll probably
publish the next one in two weeks time
but I'm guessing it's just the same
trend you see along the bottom here you
have the number of tools that you know
how to use and the y-axis fair is how
much you get paid so learning more of
these things more money so that's a
pretty good reason to care so what are
these things there are a lot of them I'm
gonna give you a quick map
everyone can read that right everyone
can really understand and clearly find
their way around that huge map of
current database technology please for
God's sake don't try and read that this
is just trying to show you that there
are a huge number of these technologies
around and that you need some kind of
categorization or some kind of map to
find your way this was produced by 451
researcher it's a fairly google-able
collection there are over 150 no sequel
databases listed on the on the website
no sequel database log and yeah this is
this presentation will hopefully give
you a bit of a map to understand and
start to put some of those into boxes so
starting with that let's start with our
first box office category of no sequel
database these are undoubtedly the most
popular ones document databases so I got
a couple of examples up there
MongoDB far and away for leader at least
in terms of numbers and adoption you can
argue about whether the tech is actually
any good but it does do a good job
there's Couchbase up there which has
some great enterprise features and
replication features on top of that as
well
and the other ones couchdb which is they
sort of fight those two but there are
lots of implementations here you know
you've got a lot of choice there are
language specific versions of these and
most platforms but what do they actually
do what a very good form
personally I think the best thing about
these type of databases that allows you
to very rapidly develop new applications
the way that a lot of them work or waive
it a lot of them can be thought of at
very least is that they're just a series
of keys and JSON documents now I don't
know I assume most people here are
writing some sort of war have written
some sort of web app now most web apps
these days are pretty much just
mechanisms for shuffling JSON from a
form into a page so via this is where
you get that wonderful match between
your datastore
and what's happening in your web
application itself
you're just shoveling JSON so why not
just keep it as JSON it really helps
with that sort of early stage rapid
development the other thing it helps
with is if you've got a very complex or
a variable model if you're following an
agile pattern of development then these
things can be very handy you can mess
around with the schema you can change it
rapidly and you can have a lot of
flexibility in the way that you store
your data which enables you to be much
more agile you can then look at later
pulling it out into something like a
proper relational form so you don't have
an upfront design cost that you have
with a traditional rating relational
schema they also work best when you have
a very clear known access pattern so you
remember I said you have a work key and
JSON if you are accessing a bunch of
information based on a key then this is
for sort of technology but you're going
to want to go for if you know the
patterns that your application is going
to follow with all its access then these
are great you can dig into them to an
extent but this is not the sort of thing
that you use to query every which angle
and pivot in any direction but you want
some downsides well downsides and not
necessarily downsides you have to learn
a very new query language something like
for Mongo query language it's it's not
gonna look anything like the sequel that
we're all familiar with its JSON based
pattern query language there's a certain
amount of complexity in it and they add
a new set of operators with every single
release spec and reverb really playing
catch-up with some of the features of
languages and so actually trying to keep
a track of this sort of thing is hard
enough and I'm not even going to show
you a slide of where it is at the moment
but the documentation is available and
things to think about when you're using
these kind of technologies you
denormalize everything because of that
known access pattern issue you want your
data to be as denormalized as possible
now this can be kind of counterintuitive
when you're coming from a sequel
background and it can create its own set
of problems where you're trying to do
things like an yeah
when you've got reference data for
example which is a sub table lookup
anytime you want to update your sub
table or change the name of a lookup
field or something like that you're
going down every document having to do
that and you have to do that yourself
joins device support joins everyone
loves joins right document databases do
not love joins the only way to join
anything in document database is as a
client-side join and it's a it's a
little light there but there's if you if
you download four slides this link there
to a fantastic blog post by a woman
called Sarah Mae who was part of their
dice hora project so has anyone did
anyone try diasporic
it was some open source Facebook
alternative our first attempt to escape
Facebook they decided that because Mongo
was the new trendy database technology
that that was what it had to be based on
they then decided to produce a very very
relational database design for their
data structures and try and force it
into Mongo and so they were performing
client-side joins all over place they
then wrote a blog post on why you should
never ever ever use Mongo this I
certainly wouldn't go that far it
wouldn't agree with that sentiment but
you should never ever use Mongo or a
document database as if it's a
relational database you have to think
very carefully about that access pattern
that you follow and how you denormalize
your data and then you'll probably be ok
but yeah don't do joins so how do we
compare to putting data in a sequel
database what the sequel do better the
main thing I think you find with sequin
the main difference is it's equals much
better at querying every angle will the
document database you've got that
document structure which is all well and
good but trying to dig down to elaborate
queries into the content of those
documents while you can do you can
create secondary indexes on most of
these database technologies it's not
really what there
happiest doing yeah you're gonna run
into performance problems eventually and
yeah there are ways of mitigating that
but you you tend to find that you end up
fighting that system if you're trying to
do the kind of pivot every which way the
sort of thing that an analytical query
might try and do you're not going to be
able to turn these things take these
documents twist from inside out and then
present them as a different set of
aggregates as effectively as you can
with something like a good normal by a
good normalized relational design you
can kind of do what these things do in
sequel right and what is the thing if
not a sequel table with a single primary
key and a blob of data that sounds a bit
like you know a document database right
but and this is where you do see the
slight advantage of document databases
over sequel if you just store a bunch of
JSON in a blob in a database then you
can't effectively query into it now I
just say that it wasn't exactly a
document databases favorite way or the
favorite thing to do to query deep into
documents but you can actually do it
whereas with the sequel approach of here
is a key here is a blob it's much harder
to be able to query into that especially
if there is any structure in it by none
you can't even sorry yeah I'm I will I
will come on to that in a second
so addressing your point sequel
databases have started to cotton on to
some of this so you start to get things
you have the early incarnations this
were things like the xml fields so who's
who's written views mapping xml type
data and those kind of thing did you
enjoy it yeah it's a horrible thing to
do you end up with visa yeah
disgustingly long XPath queries to try
and map into sequel and or escape out
into an X query piece which doesn't
really seem to fit the sequel model that
you're in
it's a bit of a hack and it's a bit of
an addition and it really hurts
so they've tried again most of the
database providers have tried again and
yeah as you say 12c has significantly
better support with native JSON types in
fields various other document various
other sequel databases a lot of the open
source document data add sorry a lot of
the open source sequel databases have
also added on this native JSON support
so you get things like Postgres has
really good native JSON support MySQL
added it I think earlier this year yeah
anyway it's there now so you start you
know this is basically the second
version so you can get some of the kind
of goodness that you get from a document
database within your existing sequel
database and you still get that nice
sort of structured content of a fields
so in a way a lot of a sequel vendors
have kind of caught up with what's
happening in document DB's so now I'm
gonna go I'm gonna go for a second
category off no sequel which is a little
controversial because not everybody
believes me but this is database or a
database at all because this is a search
engine
I will contend that most of the modern
search engines are basically databases
and I'm gonna try and prove it to you
now in many ways they are a lot like a
document database yeah search engine
like elastic search or like solar takes
a document type model and an indexing
routine and stores that document indexes
any content within it and then you've
essentially got an infinitely indexed
document database right that sounds to
me like a database you also got some
wonderful query capabilities and you
know we're not talking about Google here
we're not talking about yeah you can
just do a keyword search or you know
single text box kind of search these
technologies have very elaborate
mechanisms and aggregation mechanisms
and scoring mechanisms which enable you
to do all sorts of wonderful fancy
queries within them so again
storage and advanced query capability
database right something which is
particularly easy to do with something
like a search engine based system will
be things like scored document fetching
scored queries so this is about the Coe
scenario where you don't necessarily
have an exact match
so if sequel databases you're generally
searching for something which either
matches or doesn't right yeah you're
pretty certain about whether you want
that result or not with a lot of a
search engines your match is much more
probabilistic what you're getting is a
an ordered set of probable matches
rather than you know these kind of okay
it is it exactly matches that predicate
you're getting that document back so
there's a lot of power in that and you
can use that power and things like these
things like custom scoring scripts and
built in scoring scripts in things like
elastic search to be able to perform
quite advanced calculations on your
document set so this one for example is
well for one thing trying to train to
query trying to do a full-text search on
the turn no sequel yep okay that's fine
that's simple enough in sequel until you
start to get multiple fields that you
want to look for that sort of thing in
and you start getting things like like a
percent term like and suddenly your
database screens to a halt but what
about things like these functions these
boosting functions what I've got here is
a very quick example of a Gaussian
didn't dog Gaussian decay time stamp
based relevance calculation this is the
sort of thing that you can just do very
very simply and obviously out of a box
which in sequel is actually fairly
painful as possible and you know custom
script custom scoring's custom boosting
is custom probabilities all these kind
of things are just inherent of
engin are much much easier to do so they
can match that's a that kind of advanced
business logic that you want to be able
to put straight into that system so
here's the equivalent in sequel
I haven't actually tested that it was
fairly painful writing it I had to
implement my own Gorshin function now
this seems relatively simple but as soon
as we take things like yeah additional
terms on that then I'm having to double
up all of these yeah where clauses I'm
having to add all these little things
I've got correlated sub-query in there
as well it's it it's just not much fun
to be able to write this kind of thing
in sequel but search engines really
naturally lend themselves to precisely
this kind of query yet things like um
has anyone ever tried to implement
matrix model our scale matrix
multiplication or um tf-idf in sequel i
i'd strongly recommend that you don't
which is why i don't have an egg a
counter example to this particular very
simple example of pretty app frequency
checking against documents this is the
kind of thing that these engines excel
at this is what they're for use them for
that so the other thing they're really
good for is analytical aggregation
queries but things like facets so what
are facets facets are these things I'm
sure everyone's seen a LinkedIn search
before now if you look at those or one
of these search things which lets you
drill down through categories but the
important thing about this is that I can
actually get the quantity that I would
have matched if I had included that
query now in a sequel implementation
yeah I can do that right that's easy
enough in sequel I just run my query
multiple times with different groups and
so I run that one and I've got my first
set of groups and I run back one and
I've got my second set of numbers and
then I run a lot more of them and
eventually I've got enough to build a
page but what I'm doing there is running
thus having two
run the same query and incur all the
overhead of running the same query again
and again in the same set of matches and
predicates to keep getting my admin my
different aggregations out to produce
those facets such engine system they
thought about this it does in a single
pass and it's a lot easier to write so
one might you use one of these sort of
things when when is this worthwhile one
of the great cases for this is a logs so
there are firms like log Li for example
and you know all sorts of these log
analytics firms who used these search
engines and use things like elastic
search for precisely Vissel reason to
perform aggregations and calculations
and discovery of log information it's
really well-suited to anything like this
so anything that's sort of time-base
with semi structured information throw
it into a search engine and you get all
these good things out and you get the
ability to do those sort of statistics
with things like the faceting on oh
sorry we seem to lost picture
so fortunately I just read out my slide
but yeah we'll carry on and don't worry
if the slides are all online you can
follow along on the website if you
really want so there's another kind of
no sequel database okay
hey hey right yeah another cut who knows
it's very old laptop if anyone wants to
buy me a new laptop and this other thing
won't happen again
hands no oh well so another type another
important type is the key value store
now these I really like because they're
so close to your existing programming
model you can just start to think of
these as being exactly like the kind of
collection api's that you used to
program against think of them as a sort
of distributed map collection because
you don't have that sort of impendence
mismatch it's very easy to program with
it's very easy to reason about if you're
coming from a traditional
object-oriented background you're not
you don't have that mismatch between
your programs or your applications data
model and something like the sequel data
model but what Marx sees aside from that
kind of key and chunk of stuff that we
had with the database nod with the
document databases the real difference
is with these is that the keys can be
full objects in their own right so it
enables a very different way of thinking
about your data you can think about it
the other way up in many ways and start
to use complex objects as keys which you
couldn't with the data bear with the
document database objects so document
database keys are you know you get an
integer these keys can be all sorts of
weird and wonderful objects a lot of a
key value stores will give you lovely
little patterns for accessing these kind
of things again this is something where
they sequel databases have caught up
Postgres for example has hash types as a
native type so you can you use these
kind of things alongside sequel in the
same table or alongside relational
fields in the same sort of table so
there's things like hash types and the H
store extension in Postgres for example
there are various equivalents in Oracle
world and again this is something where
the sequel world is starting to add on
these benefits as well but what are they
actually good for what they where do
they really excel well one of them is in
dealing with in
parents so how many people have written
hibernate inheritance annotations for
used for discriminator column type yeah
there are a few grimaces which I suspect
means that you did and then the DBA
turned up and and wacky overhead until
you took it out right so previously ORM
soft ended to hide a lot of these kind
of things from us and have got us into a
lot of trouble with these kind of
databases you don't need to hide yeah
it's ok they can deal with different
types of object you can have different
types of object in the same collection
because you are just storing objects you
you just have a hash map and that's what
the whole database is so it's much
easier to read into store and deal with
things like inheritance in those sort of
scenarios so yeah the other thing that
they're really good for is hierarchies
so you remember key lookup process you
can actually delve into those keys and
create sort of hierarchical sub queries
on keys I'll look at some of that in a
bit another important thing to consider
about a lot of no sequel databases is
the physical data storage model so what
do I mean about that essentially and
again this is something which is very
present in the sequel world it's looking
at the way that you physically store
rows on disks so this is a table right
everyone seen a table before this is how
it might be stored in a sequel database
you know a record one record to record
three now what I want to be able to do
is sum a particular field so record one
field seek seek seek disk burn how about
if we store it like this so this is what
a lot of current columnstore indexes do
instead of storing things in a record
record record approach they're storing
things in a column column column
approach you might have noticed that
this is pretty terrible for writing data
because if you want to update one of
those records you're going to all sorts
of places however if you want to be able
to run a sum or an OLTP sorry an OLAP
query or any form of aggregation on top
of that then wow that's fast you just
start at the beginning of a column and
with through it and get rid of all those
seeks so again this is something that
sequels getting good at if you're using
some like MySQL you've got the info
you've got the info right storage engine
which supports this kind of disk storage
sequel server supports : or indexes of
any sequel server people here yeah
the columnar indexes are really cool
except as soon as you create one your
table ceases to be read right so this is
a this is an example of why these kind
of technologies are great for OLAP yeah
you don't want an OLTP system to which
you can no longer write but if you want
really really fast aggregations then you
know these are the kind of things that
you want to go for so you have a really
a data warehouse thing yeah you're not
going to want to use this in a
transactional system again these are
things which extend very well on to a
lot of a hadoop systems there are things
called Orci aisles and more recent
format called Parque I which is
developed I think by Twitter originally
for doing exactly this sort of thing and
storing things in this format so if you
want really nice fast analytics and
really fast elapsed all workloads then
it's well worth considering some of
these sort of things on top of something
like a hadoop system so another kind of
no sequel and these are separate sorry I
should really have changed the color
it's a little confusing : family
databases and with these I'm talking
about things like Cassandra and in some
senses HBase as well in some ways you
can think of these visit quite these are
quite cool you can think of these as
essentially a table with an infinite
width so if you imagine a sequal table
with a million columns then yeah that's
that's never gonna fly in a traditional
RDBMS but with something like Cassandra
you can put those millions of columns
and you can design your database just so
it is a straight matrix of you know all
of your users and absolutely everything
about each one of them and you can
retrieve those by that key on user so in
some ways for a bit like the key value
stores and something to note about some
of these and we'll come on some of this
in a bit is that they are eventually
consistent so you occasionally have to
code around that and we'll talk about
that in a second but on the plus side
they've got this nice familiar query
language things like CQL sounds a lot
like sequel looks a lot like basic
sequel so you don't have quite so much
of a learning curve to get going on them
either also they've got all the classic
types you used to if you have really
tight cellar as cell level security for
your data so if you really want to be
able to look at securing every single
cell of your data then you can do that
by sequel right and create a view for
every single kind of user and every
single type to select and be able to
limit which columns and which rows each
individual user type can great but
that's gonna that's going to end up
messy you're going to end up with a
absolute management nightmare trying to
do that sort of thing
so consider accumulo this is another no
sequel database it's built on top of a
key value store but what this allows you
to do is put security metadata against
every single cell if you really want to
in a database this was actually
originally developed by the NSA who then
open sourced it
so yeah yeah who knew but if you want
NSA great security Ben yeah that's the
kind of thing you're after so if
anyone's worried about whether it's
enterprise security ready yeah another
kind of data and database type that
you'll see in no sequel is the time
series database now these are an
interesting case a lot of no sequel time
series databases are absolutely great at
writing time series data really really
fast and absolutely great at getting
that time series data back for you but
you're not getting any of the
calculation within database that you
might get from something like a sequel
system you're not getting this for
example is a little bit of sequel using
some of the windowing functions to be
able to calculate stock returns on time
series now in a no sequel time series
database that is not happening for you
in the database engine you're retrieving
that and keeping your own window and
doing all that in application code so
this is one of those ones where I might
actually still consider recommending
sequel for some of your time series data
even though it's very trendy to use
something else sorry a question
so the question was this is very common
log use case are the other search
engines good at this sort of thing
no they tend not to be partly because
they don't keep it's difficult to reason
about multiple sets of documents in a
relative order in a search query
so yeah I'm they're not really you know
they don't tend to reason about you know
this document in relation to that
document they can reason very much about
this document or this each individual
one but not about independent sets but
if you have that kind of use case where
you want really really fast right of
time series really really fast read of
time series then consider something like
open TSP or um this is a relatively new
one and really cool influx DB these guys
store time series both of these really
stores time series as a kind of key
value or key array of values block and
again you're lots of people use
Cassandra in a similar way to store
these kind of time series data but you
can query it back with this sort of key
sub key subkey sub key and then a
particular metric for example which
might be at the end of your key and just
grab back a chunk of time they've also
got lovely sequel like languages which
let you do so Phi which have extensions
let you specify things like time ranges
and calculations over that time as well
so if you're if you're working with time
series data I really recommend looking
at influx DB and the sort of power that
you get out of that kind of query
because you can also do things like
create hierarchies a time series I can
say things like get me everything below
this particular key so if you're dealing
with something like monitoring an
application through jmx and you've got a
nice hierarchy of JMX metrics then you
can just dump those into a time series
it's database of this sort and be able
to really reason about groups and
individual instances are back they've
also got these sort of partial wildcards
off keys as well which is quite cool so
another area where I really want people
to stop using sequel is with queues keep
seeing people building queuing and
scheduling and job management systems
with sequel this five ways for queue to
the shard in London which is our latest
our latest skyscraper and yeah just a
little no sequel joke for everyone that
for everyone who knows about sharding so
you can implement cues in sequel and you
can write stuff like that and it's not
pretty and please don't read it and
please never write it I'm sorry I did
why are these bad for sequel you get
fragmented indexes you do kind of get a
log because you know if you're putting
all of your things into a database table
and updating the status of the flag of a
job that's where ever it ran all day
then you kind of got a log for free but
yeah you're losing an awful lot for it
for these kind of things use specialist
message queues which is one of my other
kinds of know sequel it's stretching it
a little bit but use things which have
proper api's for this kind of thing like
um yeah here are a few message queue
systems my personal favorite is rabbit
MQ but all of these what characterizes
them is that they have a datastore which
is exactly designed for this use case so
yeah they've got advanced capabilities
they've got routing of messages they've
got acknowledgment of messages all these
kind of things which you're just not
gonna get round to building in a sequel
based solution and all of them wickedly
fast because they're using a no sequel
style data store in the backend so if
you're using me if you're doing this
sort of thing don't try and roll your
own in sequel use rabbit or one of the
others or Kafka I should point out is
also very useful at this sort of thing
so there must be something where sequel
really hand down hands down wins right
what about relational data what about
data about relationships
only a relational database management
system is gonna beat out no sequel of
this right well this is when we get on
to graph databases so we've a sequel
database I can store a relationship
right I've got a key in a foreign key
and that's a relationship but what if I
want information about that relationship
or I want to say what that relationship
means right well now I've got a key and
I've got an intermediate table and then
I've got another key and I've got a
foreign key sorry okay I've got another
table now what if I want another sort of
50 different types of those pretty soon
my schema is completely unreadable and a
total mess the point about graph
databases is that they work on the basis
of nodes which are properties linked to
other nodes but the link in between them
has its own set of properties so I can
say things like you know person a is
related to person B but I can also say
that person a is person B's brother or
sister or whatever I can change that to
whatever I want I can model that
relationship and I can model a
relationship of business objects utterly
simply without having to worry about an
impending mismatch so that's where I
think graph database has really come
into their own
another area whether very useful and
worth considering is for things like
trees and hierarchies for the overloaded
relationships for kind of graph
algorithms anything to do with routing I
don't know if you've ever tried to
implement a routing algorithm on top of
a sequel database but it really hammers
the disk because of the amount of
lookups whereas graph databases are
storing things in a way which is
designed to do precisely that so you can
do
sorry question
yeah yeah absolutely so and yon
gentlemen pointing out that they're very
handy for things like fraud when you're
trying to find links and distances
between different objects then you can
either do that by yeah doing huge
cross-product queries in a sequel
database or you can use for graph
databases natural you know graph
algorithms to be able to detect a sir to
be able to execute this kind of
algorithms again you can do these sort
of hierarchical things easily enough in
sequel you can use things like adjacency
lists which of the things that we all
know about and yeah that kind of parent
key ID but pretty soon you end up with
some fairly nasty queries if you want to
be able to get multiple steps down a
tree yeah you think about a joiner every
level down us six level tree on that
yeah that's the kind of thing which in a
graph database is just a case of keep
following the vertex in a sequel
database it's keep joining another table
until eventually you run out of disk
capacity or memory or whatever happens
to fall over first yet things like
materialized paths to solve some of this
to be able to query out sub chunks of
trees so you know that's that's that
kind of technique where you have all the
dots in a ID field and you have to pause
it yourself and yeah sequels just really
not well-suited for this kind of thing
is it and then of course there's been
nested sent algorithm has anyone used
these before
nested sets or and modified preorder
traversal trees you may know them as
yeah yeah okay so these are these things
where you have the left value in the
right value and as soon as you try and
add something to the bottom of that tree
you have to rewrite the entire table to
be able to actually add something in
wickedly fast for retrieving sub trees
of things
incredibly slow forever updating or
writing anything again these are the
kind of things where graph databases
really come into their own because
they're designed to be able to handle
precisely that sort of hierarchical set
of relationships so I'm talking about
this quite a bit this year and I've
noticed a trend and I've given you some
basic types of no sequel so the document
the graph a few of a slightly weirder
types the column types are important and
the key value types but something which
seems to have been happening a lot over
the course of this year is some
consolidation of those database
technologies used to be the case it you
kind of had to pick one and then you
were stuck with it or you could add on
enough one on the side but you couldn't
get the whole thing in a single
datastore over the course of the last
year a number of things have started to
mature and consolidate around this kind
of technology so you get things like
Orion DB which is a document database
but it's also a graph database and it's
kind of got some search engine you type
things in it and again Arango DB which
is another document database with a
graph database on top of it with its own
sort of sequel ish query language so
it's starting to get back towards that
sort of sequel type approach you're also
getting a lot of a sequel vendors
starting to add on no sequel type
capabilities so things like we mentioned
POSCO has support for JSON and your
Oracle support adjacent of a MySQL
native JSON support all these kind of
things are starting to grow these kind
of document database type features into
sequel or key value type features into
sequel so starting to actually be able
to get all of these things in almost one
package which is an interesting trend so
there's another reason I'm up until now
I've really been talking about making it
easy to develop about reducing the
impendence between your data base model
and your application data model so there
are some other reasons that you might
consider a no sequel solution such as
Big Data the elephant that won't quite
fit on the screen here's an area where
actually your sequel comes in into its
own as well you've got the some no
sequel approach on the unstructured data
or things that you know you can write
MapReduce programs if you really want to
you can also write sequel on top of
these sort of things yeah for a number
of these are a number of the sequel on
Hadoop engines and so you know there's
five there this Impala from cloud era of
as Hawk from pivotal there everyone's
got one and there are technologies like
spark and spark sequel which allow you
to write all sorts of wonderful things
which kind of look a bit like sequel but
give you more than that sequel gives you
so you can write sequel against that
semi structured or unstructured data the
reason that you can do that is it's
moving much more towards for principle
of schema on read instead of schema on
right so in the traditional sequel world
you design all your schema and then you
force your data into it in this approach
you just grab your data then you make up
a schema on top of it and hope that it
passes but the point being that you can
delay that work until you've actually
got a query to ask so if that's if
you're dealing with that sort of
unstructured data then you know these
are a bunch of the things which are very
very useful which enable you to get that
there that's the best of both worlds
approach from a programming ease
perspective so those are some of the
kind of functional hard issues of you
know or decision points that you have to
make when looking at no sequel all about
the others
the kind of issues to do system issues
to do a scalability in speed and
processing and capacity and whether you
have the softer skills that you need to
think about
the fundamental thing to think about
here is the difference between the asset
and between acid and base database
systems if you need full
transactionality in your application you
are going to need to use sequel no see
if there are very few no sequel systems
which properly support transactions but
there are also very few applications
which absolutely require transactions
and do you really need everything thing
to be consistent all the time this is
the sort of question you want to ask
yourself well can you deal with this a
base approach which is you know things
are basically available your status soft
so this is covering a lot of the
in-memory databases for example and you
know your consistency model is probably
eventual yeah it doesn't matter if yeah
you immediately have that data written
to every single node in a cluster you
can wait for that but the key is to
understand what kind of trade-offs
you're making here so I don't know how
familiar everyone is with the cap
theorem but this is this is for basic
kind of tenets of how to decide what
matters to you in the no sequel world
you have consistency partition tolerance
so what happens if the network fails and
the availability of your data system
pick two you can only have two of those
which ones are you willing to trade off
for the various benefits B you get with
no sequel some other things to think
about a lot of no sequel works on it it
gets wicked fast writes you know the no
sequel technologies were and a lot of
them were developed originally to deal
with high-speed writes how do they do
this well they basically take away all
the protection if you don't have acid
transactions and you're not waiting for
that of a second high availability node
in your database cluster to report that
it properly ended it definitely has
recorded things to disk then you can
write really really fast all right that
data might disappear but how much does
that really matter to you if you lose a
few thousand in a billion low value diet
and data items coming off of a logging
stream yes they're actually going to
affect your application is that actually
going to affect any results can you make
that kind of trade-off to get that sort
of performance and yeah if you're
dealing with that very some low latency
right load right workload then no sequel
trade-offs are acceptable are you trying
to really did you really need that much
scale are you Facebook is anyone
Facebook no thing I did ask that
question a little while ago and someone
said yes at which point I wondered why
they were there and just told them to go
and don't tell them to stay behind and
do something completely different
afterwards but unless you really have
that kind of scale realize that it's a
lot easier to run one machine than it is
to run clusters of 10,000 yeah do you
really want to take on that extra ops
load can your ops people handle this new
database or should you be thinking of
something which is actually closer to
home and maybe if you want those great
development advantages look at one of a
consolidated solutions one that's easier
to manage or one that's already in your
sequel infrastructure who's gonna use
this thing who's gonna use the
application you write and developers
love to produce cool new things but you
know they they very really think about
what happens to the poor Ops guys when
they kick it over the fence and someone
has to run the thing if your analysts
are gonna use it then they're gonna want
a sequel interface at some point this is
why we have a lot of a sequel on Hadoop
things you know they want to be able to
use that familiar old language so
there's a lot to be said for sticking
with sequel even if you maybe have a no
sequel use case just to be able to keep
that analytical date and then verbs
analysts happy developers they just want
something that's going to work with our
application they want a good backing
store that works with our application
they're not necessarily thinking at the
level of the enterprise where they've
got to think of
consolidation of data from multiple
applications they tend to work in most
little units so these guy your
developers gonna be really happy if they
can just use a quick no sequel store
which works brilliantly for that new
project they're working on and fits that
applications use case perfectly because
they can just crank out code without
worrying about the impendence so that's
great and if you got data scientists
well just give them access we'll use
anything they're horrible hackers right
just as long as they can access any of
these technologies I'm sure they'll be
more than happy well the moral of all of
this this we you need to choose the
right tool for the job the no sequel
databases come with a lot of power they
come with a lot of very nice yeah
developer friendly structures yeah that
they're closer to your application
workload they make a lot of sense
there's less impendence mismatch between
you know but between object-oriented
code and for datastore but you have to
be aware of a trade-offs that you're
making to get those benefits so nova
trade-offs choose right tool for the job
and with that thank you very much
and I think we've got about five minutes
for questions if anyone
so the question is have I seen people
try and graft eventual consistency on
top of a sequel based store by using
something like a message system yes I
have this is really going back to that
sort of model of the isolated micro
service that yeah I was talking about
briefly at the beginning where you get
that sort of API approach with lots of
isolated things which may have a sequel
database behind them or they may have
Mongo database or and you know whatever
database behind them but communicate on
a message queue in you know between
multiple services so yes you could sort
of see that as an eventual consistency
problem that you have to then code
around but yeah I know it's I think it's
a very powerful architecture I don't
think it's really a sort of no sequel
versus sequel thing you can definitely
use both but it's about thinking in
terms more in terms of Micra service
architecture does that make sense does
that answer your question and yes I've
seen it used and I've seen it use very
effectively your Netflix and Amazon for
example do all right on that sort of
model any other questions I didn't talk
about cql in great depth no the
Cassandra query language is very similar
to sequel it's kind of like a very basic
version of sequel which is you know very
handy if you're you know the lessons for
learning curve a lot with that sort of
thing but I think the important thing
around thinking about Cassandra is not
necessarily for query language so much
is for data model that it enables with
the you have a very wide column picture
so you're actually thinking you know the
query language is kind of a crux it's
kind of a crutch because it's close to
what you're used to but the important
thing is for fact we even have a million
columns and that you're thinking about
your data in a very different shape I
think also the fact that it's very key
access focused so you're not getting
yeah you've got to be careful about the
performance with work query and our
where clauses in Cassandra
but yeah I it cql it's a big topic so
yeah
yeah okay so the question is when you
get this kind of microservice approach
where each application it has it's sort
of API and it guards its data source
jealously and you know there's no
centralization of data sources then
people get silos and it's difficult to
do analytics across the whole data state
right yes are you telling me that silos
don't exist in the pre no sequel world
but for a start but yes and you can get
a lot of our states silo problems this
is where a lot of the Hadoop vendors are
starting to play so you know you get
this principal of the data leak which is
pulling and copying data out of all
these applications or you get you know
analytic systems which are designed to
interact with the api's to be able to
achieve that so rather than trying to
centrally store all the data for the
applications and a half a thousand
applications act on a single database
yeah that central analytics platform is
going and fetching the data from those
applications so that's a lot of logic
behind a lot of the the data hub
architecture that a lot of a Hadoop
vendors will talk to you about which is
having this sort of big semi structured
or no structured hadoop cluster in the
middle which sucks all the data in and
then lets you do analytics on it so
that's you know one of the ways I've
seen people trying to solve that problem
there's something else I was gonna say
but it's gone sorry but yeah any yep
so you want a recommendation for a
Cavalia datastore
how important is persistence to you are
okay so on disk
you could probably try something like
HBase HBase is pretty good on top of
Hadoop yeah you'll get good performance
out of that if you want really good
performance then talk to Matt bar Matt
para Hadoop vendor who've taken a lot of
stuff underneath HBase and rewritten it
so it's faster no that's not
but HBase itself is open source yeah if
you want to just get some basic key
value stuff then start with bredis or
react which is simpler Redis or react
which is our iak it's produced by a
company called basher but they're
primarily intended to be in memory but
they do they will store and persist to
disk yeah yeah okay I think we're
probably being kicked out because
they've that they're pretty they're
pretty stringent about time here so if
anyone has anything else they want to
talk about find me on Twitter or mug me
at the door thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>