<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Leveraging Scala Macros for Better Validation | Coder Coacher - Coaching Coders</title><meta content="Leveraging Scala Macros for Better Validation - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Leveraging Scala Macros for Better Validation</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/RPdYar-bo7M" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thanks for coming to the session my name
is doable it's like Tom ER at the end
and I'm here to tell you a little bit
about Scylla macros and what we're going
to do is we're going to take a specific
use case which is data validation and
we're going to use it to drive our talk
and this is not actually a talk about
data validation it's just a sample use
case the context for this is an open
source library it's called a cord which
you can use its apache license and
that's we're simply going to use that to
drive kind of an introduction into what
macros are what they look like how
they're constructed etc etc in the
context of data validation so I'm just
going to take this opportunity to do a
little bit of bashing on being
validation jsr 303 bashed ok moving on
because that's not the point I'm not
actually going to focus on the feature
set of the libraries that are etc it's
not the point here macros are so to
begin with how many of you have been
doing scholar development for any
meaningful amount of time ok that's a
good percentage because this is pretty
pretty advanced stuff even for scala
devs so you know if anyone does not know
scala you'll probably lose mean like the
third slide or something I apologize in
advance so let's get started assuming
yeah so as we were data validation as
ever were right use data validation for
web forms for RBC systems for data
ingestion into into stream computing you
kind of use that everywhere and a twix
which is a company and working at we had
as were kind of migrating from Java to
scala we had need for a more advanced
data validation mechanism that can
tackle Scala's more advanced type system
and you know inherent features options
either as etc etc Binny validation did
not meet our needs so we started off
with this with this dream of a concept
which in this case will give an example
we have this case class of person this
is a really really simple domain
object has a first name which is a
string and last name which is a string
and we want to have some sort of
validation on top of that so for this
really really trivial example we want to
have a validator over the type of person
which makes sure that to validation
rules are enforced which are that the
first name and last name are not empty
so this is the example that we're kind
of going to use to track through the
whole presentation now in order to
actually use this validation that's the
other side of the equation you basically
just call validate over your domain
objects which in this case is is a
person with a valid first and last name
and you get back a success on the other
hand if you try to validate a an object
that does not meet your criteria you
expect to get a failure back and a
failure constitutes violations right you
have validation rules some of these
rules may be violated you want to have
an aggregate result of all of the
different validation rules that have
failed to validate which are violations
so in this case we basically have just
one rule that failed which is that the
first name is not be empty the value
that failed to pass validation is an
empty string the constraint is must not
be empty and and this is the this is
important bit the description a friendly
printable description for what actually
has failed validation in this case is
first name and you'll note that going
back a bit in this example I did not
actually specify anywhere that this rule
applies to a string that contains first
name so this is a chord in a nutshell ok
that's the API for a chord which is the
validation librarian question now accord
basically constitutes four layers that
work together to give you you know the
API and the implementation of that API
for data validation so we have the API
we have a library of something that's
called Combinator's because matters is
you know too easy a word so we had to
come up with a new one there is a DSL in
place in play
which is for instance earlier we saw p
dot first name is not empty that's the
dsl to work and there's a macro based
transferring code transformation which
is going to be the focus of our of our
talk here so just a quick overview of
the Accord API this is basically all you
need to know to understand hopefully the
rest of the dress of the talk any
validation can either succeed or fail
that's true both for a validator over
the entirety of the object called person
and also for specific rules a failure as
we saw before comprises one or more
violations so we really have this the
seal trait with two possible two
possible result conditions either a
success or a failure that also has this
set of violations now the validate a
validator over some type t is in
practice a type class and more
importantly a validator over type T is
in effect a function from a value of
that type t2 a result object which is
this okay that's basically all you need
to know about the API so what do macros
where the macros fit in right what what
do we need macros for so going back to
our example of defining a validator over
the type of person we have these two
rules we have this type person which
we're validating over and there's two
things that need to happen behind the
scenes for this to make sense so the
first thing is as we saw before we need
to have some sort of description of you
know whatever a subset of that the main
object were validating whatever
component were actually applying your
rule to and that's this p dot first name
thing ended up as a string firstname in
our violation model so we need to
automatically generate some sort of
description for each validation rule the
second thing we need to do is these
rules kind of exist in a vacuum okay but
what we actually have is an implicit and
combination over all these rules so each
and every one of these rules need to
succeed for the total result to be a
success otherwise we want to a group
all the different failures so these are
two things that with this syntax and
what we started off with when designing
this library is we actually started off
with our desired syntax with this syntax
there's just not enough information
within the confines of the scholar
language in the scallop type system to
actually get that information out so
that's why macros fit into this context
so before we actually get started on how
the macro based code transformation
works we need to cover a little bit of
ground about what macros are and how
they work so to start with you know this
is this is pretty hairy stuff okay
macros as a feature in Scala are
experimental okay what this means is
that the API is that you use to actually
define and employ macros make change
over time and in fact we have changed
not radically but they have changed a
bit between say Scala to tenants color
211 okay so that's one thing you need to
realize being an experimental feature
means that it may change and it probably
will a bit further down the road with
Scala 212 and so on and so forth second
their heart okay this isn't like even
though ostensibly we're doing very
simple things very simple
transformations over code D actual
implementation details or anything but
trivial okay so that's that's something
to consider given the length of the
stock and giving the amount of work that
actually went into the library i'm going
to have to gloss over quite a bit of
detail hopefully i'm not going to omit
anything that's of real importance at
least for a baseline understanding of
how macros work but you know don't well
you could heckle me but I mean I'm going
to I'm going to forgo a lot of details
that you go along because otherwise we'd
be here until tomorrow consequently i'm
also going to simplify quite a few
things about how a court is actually
constructed but the gist of it is here
so abstract syntax trees are kind of the
canonical representation of code as the
compiler sees it okay you feed Scala
files into
the compiler and Scala files are text
okay the compiler reads these in it
parses them and then it generates some
sort of typically in-memory
representation of your code which has
structure and semantics and submitted
data on top of it so the structure and
semantics are really really important
okay because essentially it builds a
tree of what your code does and then it
operates on top of that tree and that
tree may or may not include stuff such
as types okay for instance the first
stage of compilation where it actually
parses your code the type inference
engine had not yet drunk okay so some
parts of your code tree do not yet have
a known type okay so that's optional
emitted metadata and the availability
and richness of that metadata it depends
on which compilation phase you're
working the actual API to work with SDS
the model and all the tool chain around
it are actually provided by the
reflection API which may be
counterintuitive because in Java
parlance reflection is actually a much
less powerful concept and unfortunately
and this is this is actually kind of a
big deal for four people actually
writing macros the tree that you get is
mutable ok you can operate on it you can
remove data you can add data you can
modify stuff on the fly this won't
actually show up a lot in this
presentation but if you're actually
going to write a macro that's something
to consider because sometimes you need
to eliminate some data from the tree in
order to use it elsewhere or you know
you need or data that you might want to
have within that tree is not available
and you need to run some some sort of
compiler toolbox functionality to
actually add that to your tree so that's
abstract syntax trees in a nutshell
let's see what they look like we have
this really really simple example okay
we have this method definition we're
defining a method called method it takes
one strength parameter and what it
actually does is it just runs to
uppercase on it so we can kind of zoom
in on each constituent part of this
expression and
take a look at what the abstract syntax
tree looks like so if we take the actual
implementation right we have this pram
dot to uppercase we're actually what
we're actually doing is we're taking an
identifier okay the identifier that is
per am we're selecting something from it
we're selecting a symbol from it in this
case the symbol for to uppercase and
then we're creating it as a function and
applying that function with no
parameters because it doesn't have a
parameter list so the way this looks is
we have this identifier we're selecting
to uppercase from it this kind of
collapses this part of the tree and then
we're applying it as a function with an
empty parameter list and this is the
simplest bit of ASD that you can
probably find out there in the field the
parameter finition is actually a value
definition so there's a different set of
nodes that comprise it we define a value
that has the modifier of being a
parameter a function parameter it has a
name and it has a type and a type is
also a treat in this case we take skala
dupree diff which is something that's
implicitly added here to your scope
regardless whether or not you wanted to
buy the compiler we're selecting string
from that and that's our type have the
parameter and because we don't actually
provide a default value to it we could
in which case you'd have some sort of
expression free here in this case we use
an empty tree because there is no
default value and looking at the whole
thing we have this def def okay
definition of a deaths method no
modifiers name no type parameters
because it's not parameterised one
parameter list that has this internal HD
that we saw before of the finding of
parameter no return type you'll notice
that dasd before the compiler HD is
short for abstract syntax tree before
the compiler actually does its thing and
infers the return type of this method or
the result type of this method rather
this is actually an empty
I tree because it's a noon and then
there is the implementation so this is
just one small example of what an
abstract syntax tree actually looks like
within the confines of the scholar
reflection API with death macros def
knackers are the only type of macros
that are kind of widely available within
Scala to 10 to 11 okay you could add
different types of macros with external
compiler plugins and that sort of thing
I'm not going to focus on that I'm going
to focus on def macros because they're
by and large most widely available and
why'd you useful construct in Scala so
death macro actually looks and acts like
a normal function okay for instance if
we wanted to for some reason if we want
it to be able to express any number in
any mathematical base and have it
resolved to you know say for
simplicity's sake a long value at
compile time okay usually what we do is
we'd have a constant we'd initializer to
the result of constant function on the
math class library function that
actually happens at runtime in this case
we want it to happen at compile time so
we have this method called radix it
takes a string it takes a base it
returns long once again for simplicity's
sake and if i call it with these
parameters it actually it actually
resolves to the number ten thousand in
decimal form now the difference between
a def macro and a regular diff regular
function there are essentially two
fundamental differences one is once
again it happens at compile time as
opposed to runtime which is the whole
point of a macro second it operates on a
steez it does not operate on values okay
a normal method the normal
implementation for de stratix method
would actually take in a string and an
int and return long what what a macro
does is it takes the same shape but as
you will see in the next slide it takes
in an abstract syntax tree representing
the parameter that is the string another
one representing the base and returns an
abstract syntax tree representing the
result
so a deaf macro needs a signature as
we've seen this is the the regular
method signature except that what
instructs the compiler to treat it as a
macro as opposed to a regular method is
this macro keyword and also needs an
implementation now the implementation is
actually another method and it takes a
very similar shape to the original
signature the original definition except
that it adds this context it adds this
parameter list that takes in a macro
context which is something that will
cover in a bit and instead of being
parametrized with values it's
parameterised with expressions and an
expression in this context is an
abstract syntax tree and a known type
okay so what it takes in is a syntax
tree with a known type of string syntax
tree with a known type of int and it
returns a syntax tree with a known type
of law and as we mentioned before
instead of operating on values there is
a sts so with this kind of grounding Oh
lest I forget what's in a context okay
the macro context actually gives you the
information you need to treat this as a
compile-time invocation okay so invoking
the macro okay your user you're
providing macros your users on the other
hand actually invoke it as a regular
method call so there is a position there
okay the compiler knows to invoke your
macro at a certain point in time at a
certain point in the code so the macro
context gives you a whole bunch of stuff
including what's the position ok what's
the enclosing what's the exact position
in the code what's the enclosing method
definition if there is one the enclosing
class definition because there's always
in all ways is one because everything is
an object ok it gives you a bunch of
error handling techniques if you wanna
because this happens during compilation
you may want to emit a compiler warning
or a compiler error ok you want may want
to abort compilation so it gives you all
these it gives you some logging
infrastructure and
gives you some compilation level
infrastructure such as generating
instances of types doing some type
resolutions running the piper or the
type interesting engine of the compiler
on top of an HD all this you know all
these kind of utility functions are
provided to you via the macro context so
all this was just essentially an
overview of what a diff macro is and
with that in mind now we can actually
move on to considering how to apply how
to apply the code transformation that we
desire based on these features of the
skeletal language and the Scala compiler
so once again we have this just a quick
refresher we have this validator
definition all this is the macro
application okay validator over type of
person takes in a object p defines
validation rules of that code block is
actually the macro application this is
what we call to invoke the macro and we
have these things which for lack of
better term will call validation rules
so the validator macra essentially needs
to do two things it needs to take it
needs to search for rules take its rule
and then rewrite it by generating and
then applying some sort of description
as we saw the four and it needs to a
great all these rolls through some sort
of an and logical and Combinator the
signature for the macro looks like this
okay we have the the user user
recognized shall we say signature of
defining of validation which is a simple
method validator over some type T it
takes in a code block from t2 unit okay
looking back at this we don't really
care about a return type right we want
to encode that this is not expected to
return a value so all this is a function
from some type t2 units and we take it
in as a parameter and we spit back out a
validator over type T which is the
function from T
some validation result that we saw
before the corresponding macro signature
that we actually need to implement is
this so we have in this case I elected
to call the implementation method apply
over some object validation transform
you're not going to see this anymore so
don't put too much attention on it I
have this method apply it operates over
some some type T now in the context of
compilation actually need to know what
the type T is ok it's a generic function
but it's actually invoked by the
compiler knowing over what type it
operates which in our case is a person
ok so I also take in a type tag 40 I get
in a context I get in an AST
representing the function from TT unit
and i spit out an asd representing the
validator over type T so this is our
signature and with that we can actually
start considering what the what the code
transformation actually needs to do this
is a good point take a deep breath
because right now we're from this point
on we're actually going to die fairly
deep into the actual code okay so take a
second take a deep breath moving on what
do we need to do ok we basically have a
four four step process we need to search
for a validation rule within that code
block that were provided we need to
process that rule to figure out you know
what are its constituent parts we need
to generate a description for whatever
that rule actually validates and we need
to rewrite it in a way that actually
applies the description that we just
generated so let's start with the
obvious how do we search for rules what
is a rule ok a validation rule in a
chord is an expression and that
expression actually has it validates
some constituent part of our domain
objects o P dot first name is not empty
actually generates a validation rule
over the types
because that's type of the field okay
but this whole line this whole
expression actually has the type
validator of string so essentially a
validation rule is whatever expression
within our code block that has the type
validator over something okay and for
the search we don't really care what
that type is we're just looking for
validation rules within our complete
block so what we do is we recursively
pattern match over our given abstract
syntax tree and i'll show you how in a
second if we find a match we do some
sort of transformation over it we do
some processing over it so we apply a
function to the subtree that we just
found and the way we encode this is a
partial function from tree okay tree
being essentially the top-level nose of
a an abstract syntax tree or a sub tree
and a partial function from three to
some type are that's the easiest way to
include this so we'll start off with
actually a helper function that will
call collection pattern this is very
much analogous to the collect functions
from the collect the collection
framework right any collection has a
collect function on it that you provide
with a partial function it tries to
match that partial function and whenever
it finds a match it applies that partial
function to whatever matched it so we
take in a tree we take in a pattern
which is a partial function from tree to
some type are and we spit out a list of
those ours and the way we actually
implement this is we generate what we
first create a vector an empty vector
that we'll use to actually collect
whatever it is were were you know
looking for we use a utility thank all
traverser that were provided by the
reflection API it's just a recursive
tree traverser which saves quite a bit
of work to deal with the little nagging
details of how that's actually done and
for each node in the tree that we
recursively traverse over if our pattern
is defined at that sub tree we just
apply that pattern to the subtree take
the result add it to our found list
otherwise we just recurse further in
okay and then eventually we return the
list so this is just a helper function
okay it's intended to give you a very
rudimentary overview of what actually
working with asds is like and now we can
use this thing to actually look for
validation rules within our code block
so we have this concept of a validation
rule don't worry about it too much for
now we have a method that we haven't
even implemented yet called process rule
which takes in a subtree and spits out a
validation rule it's not implemented yet
and we don't care we'll deal with that
in a second and in order to find
validation rules within the body of a
validation block what we do is we take
the type of any validator okay we use
type of which is a very nice convenience
function we give it the type validator
over anything we get back this type and
we collect recursively from our
validation code block anything any sub
tree whose type is a subclass of this of
validator okay so that just gives us a
very easy way to search for validation
rules within our code block for each one
we find we process it and we spit out
the result and that's basically it now
we can deal with processing so what do I
mean by processing your rule let's let's
first take a quick look at what actually
happens when a user defines the
validation rule what gets spit out by
the compiler so the user right speed
first name is not empty ok that's the
validation rule and it's quite quite
legible it's easy to understand etc
through the magical implicit and DSL
constructs what actually gets emitted by
the compiler is something closer to this
there is this concept with
in the dsl of contextualized and the
reason it's there is this context
rÃ©aliser actually wraps the object
under validation okay what we're
actually validating and this rule is P
dot first name and the actual validation
is is not empty so this gives us an easy
way to deconstruct our validation rule
into its two most important bits which
is what it is that we're validating and
how we're validating it so this is the
name for this is object under validation
or ouv for short and this is the
validation rule and the nice thing about
this is as I'll refer to later the way
the dsl is constructed is that this
thing actually does not does not impact
the resultant type okay the dsl is
constructed in a way that it just adds
this bit of I guess you could say
metadata to the resulting ASD that the
compiler spits out but this whole
expression is actually a validator over
some type string okay so you could take
this whole thing and use it as a
validation function and apply to any
string not necessarily p dot first name
okay so we just use this to generate a
description and then throw it away so
looking at this rule this is effectively
and apply ast node okay because we have
this left hand side which describes what
we're validating and then then we're
applying this dsl function called is to
it so as i mentioned before because
contextualise ER doesn't actually do
anything to the type system we can use
the entire expression as our validation
rule which simplifies what we need to do
in the macro and we need to extract this
left hand side we need to extract the
object under validation in order to
actually generate any sensible
description so what we do is we try to
derive a pattern okay a pattern that we
can use to decompose this rule into its
constituent parts so the AST for this
expression looks roughly like this okay
we have this contextual Iser
it's actually a constructor call ok so
it's contextualized apply but never mind
that over some type string and it gets
applied to p dot first name which is the
selection of the symbol first name from
the identifier p and that's all we care
about okay we can basically ignore
everything on the left hand side here
because all we care about is this
subtree because this is what gives us a
search pattern and allows us to actually
extract the object under validation
generate a description for it so let's
zoom in on this we have this this
subtree here and it's a contextualized
for something that is of type string but
as i mentioned before we treat rules
generically we don't really care about
the type of the member of the person the
member field of a person that we're
operating on so you can basically ignore
this type here second we're interested
in the object under validation which is
this whole thing here but we don't
really care what it what the expression
is we care about the subtree then maybe
as we generate a description we can
actually look further into this but at
this point we just want to extract the
right sub tree from which to generate a
description so this is what we're
looking for and we can completely ignore
whatever is under that note okay and
we'll refer to it as our object under
validation or ouv now we can actually
generate a a pattern match a proper
skala pattern match over this this
generalized type of abstract syntax tree
so we have an apply a type apply this
thing is short handle I'll show you what
it actually looks like later but the
bottom line is where we're just looking
for this search term for contextual Iser
over any type and it takes in one
parameter because we know by definition
that contextualizes that's the way it's
constructed
no by definition that it only takes one
parameter which will call Oh UV and
obviously it's only one parameter so we
terminate the list and that's this is
our search pattern so putting this thing
together okay we have this search term
okay that we call contextualize er we
have this rule processing function that
takes a subtree and in order to do that
we use a second helper function which is
extracting pattern that's roughly
equivalent to find first in the
collection framework I didn't bother
going into the implementation because
it's not that important suffice to say
that it tries recursively to look for
this pattern and the first one that it
found finds it spits out and if it
doesn't find any such match it spits out
and not so this is the exact pattern
that we had from last slide if we
actually managed to find it at this
point we've actually decomposed the
abstract syntax tree that we get as an
input and extracted the object under
validation okay we've extracted the sub
tree that represents what we're
operating on the p dot first name and
it's called ouv now we can generate a
validation rule with an object under
validation and as I mentioned before
because of the way the dsl is
constructed we can actually use the
whole sub tree as the validation rule
okay because it resolves to validator
over whatever type it operates on and
obviously if we haven't managed to find
a match we did something wrong so just
to be on the safe side we abort
compilation we give it the position of
the subtree not a valid rule and we
actually might get that as a compilation
error okay the compiler is going to spit
on an error it's going to tell us you
know on this bit of your code I couldn't
do this because it's not a valid room so
that's the processing now we need to
generate a description for a subtree so
looking once again on our on our kind of
dsl dsl enabled output we have this p
dot first name is not empty
and this is our object under validation
again in this case it's a field accessor
so what gives us what gives us the
ability to actually generate a
description for it is the function
prototype and what I mean by function
prototype is our validator generating
code was invoked with a code block that
that operates over a type person and it
takes a sample object with the name p ok
so we already have in our hands and
identifiers that we can use to actually
look at this subtree and say okay p duck
first name is actually a field accessor
over our sample object so we don't need
the p dot part okay we can generate a
sensible description by resolving this
subtree against what we already know and
extract just the the field name that
we're accessing so the way we do this is
first of all we need to get at the
prototype and our macro signature gives
us this okay this parameter V the
function from t2 unit that represents
the whole code block it's an actual
function okay so we get back we get as
an input an abstract syntax tree that
represents this thing and we can
decompose it ok we can pattern match
over it by just using function and a
function is comprises two things a set
of parameters and an implementation ok
same thing with lambda in this case we
know that we only have one parameter
once again because that's the way the
API is constructed a validator the
validator macro takes in one parameter
one function from t2 unit so it's only
one parameter and we just name it
prototype and then we can also on the
fly extract the actual body so the
prototype is a valid F ok as we saw
before when defining a method ok the
formal parameter for that method is a
valid if so we get back FL def that
represents this P of type person the
sample object now that we have the
prototype what we can actually do is
this described rule takes in a
validation rule as
for the validation rule has the object
under validation and the actual
validation that needs to be applied to
it we for the purposes of pattern
matching we take the name of our
prototype parameter which in this case
would be P and then we decompose our
object kind of validation because this
is our HD what we need to do is we know
that it's some selection over some
identifiers we're assuming that
identifier is our sample object and
worse what we're interested interested
in is what we're selecting the symbol
we're selecting from that identifier
that's going to be our description so we
decompose the street we select from our
an identifier that's identified by our
prototype name we get the description
back that's the actual symbol that we're
selecting from that identifier and
that's all we're interested in we just
trying to write the string gives us back
gives us back in this case a you know
that the string firstname that's as good
a description isn't so I mentioned
before then I'm going to gloss gloss
over a lot of detail you might wonder
what happens if we have P dot first name
dot to uppercase and we validate that so
the actual library code deals with it
they're just you know I originally had
about four slides dealing with that
exactly but it seems to be a bit
overkill for for an introductory session
so you can do anything you want right
you get an ASD you spit out an AST
everything that happens in the middle is
your responsibility as macro developers
the last bit we need to actually rewrite
the rule ok so we've split it into the
object under validation with the
description and the validation rule that
it needs to be applied and we need to
rewrite it so what we're actually
constructing the results of our macro
application is a validator over the type
person but each of our rules is actually
a validator over the type string okay so
what we need to do is we need to lift
okay we need to we need to find a way to
take a validator over p dot first name
which is a string and lift it to be a
validator over a whole person and we do
this for every rule and then we end up
at creating them and we also need to
apply the description to the result so
what the way we do this is via quasi
quotes and quasi quotes and this is a
bit of a digression but it's not going
to be too long it's a really really easy
and useful way to construct and
deconstruct abstract abstract syntax
trees in Scala okay it's it's provided
out of the box with Scala 211 with Scala
210 you need to add a compiler plugin to
get it to get them but that compiler
plugin all only needs to apply to where
the macro is actually implemented okay
so it doesn't transitively affect your
end users which is a nice property we
have this sample abstract syntax tree
here I'll save you the bother ok the
bottom line did is this is X plus y and
having to construct this whole abstract
syntax tree by hand is you know it's
exhausting ok and it's complicated and
it's error-prone and it's unreadable so
quasi quotes allow you to do this ok
these two things are completely
interchangeable ok we have X plus y
running it through the quasi quote
engine actually gives us this abstract
syntax syntax tree so it's really really
useful to other useful properties of
quasi quotes is they also allow you to
splice trees so if for some reason you
want a macro that generates a a greeting
I don't know why you'd want that but if
you do you take in a parameter that's an
abstract syntax tree of a string you can
just do this ok you can just use it's a
string interpolator in a sense you can
just stick an expression or a tree or
you know anything that has dried tie
clasp and just splice it into the
resulting abstract syntax tree so that's
that's actually really really useful and
you'll see why it's so useful in a
second
also it can be using pattern matching so
you can you can use it to deconstruct an
expression into its constituent trees
that's actually not something I'm going
to use in this presentation but it's
really really fun to use so a rewrite
rule okay in our example we have this
rule p dot first name is not empty and
what we actually want is to lift it to
be a validation / person as opposed to /
string and we want to add the
description so our resulting code would
ideally look a little bit something like
this it's a new validator of a person
and if you recall at the beginning I
mentioned that a validator is
essentially a function from some type t2
Sun result okay we have the supply
method takes in a person we have this
whole expression that has the type
validator / string that we can just take
as is and users as our validation rule
we apply a rule to p dot first name that
we're actually allowed to use here
because we take in an actual value and
then we tack on a description to the
result ok and this with description
thing is just part of the domain model
for validation results in a court okay
so this is this is our ideal result
generalizing this is actually pretty
simple with quasi quotes we take in a
validation rule we call describe that
we've already covered we get back a
description description is a string so
we need to wrap it wrap it with a you
know with an abstract syntax tree that
represents a string literal the way we
do it is this we wrap it in constant
wrap that in literal and then we can
just basically stick it anywhere in our
syntax tree and it will work fine and
then we use a quasi quote so we do new
yada yada validator of type T and we're
allowed to do this because we got a weak
type tagged as part of our macro
signature and we can splice that in as a
type parameter the supply over prototype
prototype is a valid F right it's a
formal
of an entire parameter so you can just
take it and splice it in here validation
we define a local variable will call it
validation that's the validation rule
which we've already extracted so we just
you know splice it in here and then we
apply it to the object under validation
which we've also previously extracted
with description this small string
literal tree that we just generated and
that's a rewrite okay what we get back
from rewrite rule is essentially an
abstract syntax tree that represents the
same rule we were given with a
description applied to an entire person
as opposed to just a stream now finally
the last now finally we can just take
all these rules and aggregate them and
apply them to some sort of logical and
Combinator that's the implicit adage
part of the macro to transform so in our
case we decompose the function as
described before into a prototype and a
body we stick in all the code that we've
covered over the last few slides we
basically find the rules the validation
rules from the body we rewrite each and
every one of them so now we have a
sequence of rewritten rules with the
description and they're all a validator
over whatever type we were originally
given in our case the person and with
and then we just generate a result we
say new the Conte the end Combinator
which is you know part of the Combinator
library that you get with a cord this
double dot prefix is another useful
tidbit with quasi quotes that basically
instruct the quasi quote engine that
here is a sequence of syntax trees you
know treat them as a set of parameters
for whatever is in here okay so we just
take the sequence provide it as a
variable argument list to end and that's
a result the last literally last thing
we need to do is since what we're
spinning out is not
just a syntax tree but an expression
which is a syntax tree with a known type
we just wrap it with an expression of
type validator of T we stick the result
in here and that's it that's our macro
okay so it's a lot of you know a lot of
work to get what essentially amounts to
to code transformations in place but
it's really useful because otherwise in
this use case we literally could not
have had the syntax we could not have
forgotten strings for instance for
describing our fields okay we could not
have this nice concise syntax where each
line is essentially a validation rule
over our domain object we would have had
to wrap it with an end in some way or we
would have had to have kind of a mutable
engine that collects these validations
and does something you know at runtime
okay this is all done in compile time
you get back a function from teacher
result that you can apply to any
instance of your domain object and
everything has already happened in
compile time no reflection no hacks no
nothing okay the resulting code just
works and well before I take any
questions if there are any the library
is actually available in github apache
license you're welcome to take a look at
it obviously it represents a much more
in-depth expression of the same concepts
also if you end up using it that'd be
cool I'd love to hear about it and at
this point that's pretty much everything
I have for you so are there any
questions are you still alive like I
know that like even for seasoned Scala
developers this is pretty pretty
relatively hardcore stuff so yeah
the back room once I mean the resulting
code
so yes there is actually at least a
couple ways one way to do this is with a
compiler flag that actually instructs it
to spit out the results of macro
transformations another way which is
which you can if you're interested in
details is actually employed by a cord
is to have logging as part of the macro
so you give the compiler flag saying
something like you know minus capital X
macro settings cord the bag or whatever
and then at that level Accord as part of
the macro will actually spit out some
bits of code for you to have a look at
also the ripple is actually a really
useful tool for macro developers because
you can use the the runtime reflection
API to Ray if I code ok you give there's
the ref I macro you give it a bit of
code and then it spits out the ASD that
that's actually generated from that
codes that's a useful debugging tool
there's a whole bunch of things you can
do the bottom line is it's not easy
because it's all compile time the new
new as yet to be production grade skala
the meta project actually makes this way
easier and also include some ID level
tools to let you see the results of
macro applications but it's not not
really there yet any other questions ok
thank you very much for oh yeah there's
one more sorry
they're writing yeah we started off with
with this um yes yeah this is this is
valid code in a court I don't know what
you want to do that but you could yeah
yeah the the one thing I really dig
about Skylar macros is a person is
actually responsible for them calls at
hygiene there is no magic okay there are
rough edges there are annoyances etc but
there's a little magic it's all cool
okay you can't generate code that you
wouldn't have been able to generate you
know manually also one important bit
that I actually forgot to cover is you
can't feed a macro with invalid invalid
Skala syntax okay you can't make up your
own syntax because what you get in is
and already parsed abstract syntax tree
so what it means that the code that act
that you actually feed into a macro
needs to be valid okay it needs to have
the ecosystem around it the dsl around
it whatever it takes right but you can't
make up your own syntax you can't have
invalid scallop cool you can't yes the
semantics the semantics as you saw here
can change any other questions okay
thank you very much it's going to flavor</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>