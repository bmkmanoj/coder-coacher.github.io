<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Going Native: Bringing FFI to the JVM | Coder Coacher - Coaching Coders</title><meta content="Going Native: Bringing FFI to the JVM - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Going Native: Bringing FFI to the JVM</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/94tQ4bEwa6o" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right I think we can get started at
this point I have a question to start
this off how many folks here have ever
had to do J and I for some purpose and
how many of you really loved it
yeah you don't count your you're an
unusual one so we're gonna talk about
how hopefully the days of J and I are
coming to a middle and what we're going
to do to fix the use of J and I and get
it out of our face information about me
not nothing too weird none of my talks
have anything to do with each other from
year to year like it's jvm internals
bytecode Fi other stuff but this year
we're going to talk about the the little
bubble that we live in here on the JVM
world where everything has to be written
in Java or JVM bytecode of some kind and
so we don't even look outside we have
this tunnel vision about what's
available for libraries and capabilities
if it's not a Java library it doesn't
exist
to us and that's really a sad situation
because there's a lot of great work
being done in other languages that are
not running on the JVM yet anyway so
here's our world right now we have this
wonderful managed runtime and it keeps
everything safe for us make sure we
don't walk over memory boundaries and
whatnot we have lots of safeguards we
don't generally get seg faults if we do
the JVM guys usually love jumping on
that because it's not supposed to happen
fast development debugging we don't have
as much overhead as building a native
application does in many cases but it
can also be a little tricky to get
native performance sometimes you have to
write Java in a C style to get C level
of performance and because we're in this
isolated managed runtime that has
traditionally been completely separated
from the outside world it's very
difficult to access native hardware new
operating system features new libraries
that come out and we need to do a better
job of that because we end up chasing
the other big development world out
there C and C++ developers and all the
great work that they're doing so here is
our lovely stack with all the stuff
that's interesting to us but the problem
is that there's a lot more stuff
underneath that we actually might want
to use low-level file system features up
until Java seven we
didn't have access to any sort of sim
linking logic or appropriate or good
file system metadata we don't have
certain types of network sockets there's
no UNIX sockets there's no raw sockets
that you can do on the JVM interactive
sub processes the java.lang process
builder is really tore end Asst for
doing any sort of interactive sub
process work if you've ever tried to
control a sub process from a piece of
java code and have it really feel
interactive and really control it it
just doesn't work right
native gooeys crypto libraries just
getting access to native memory of
course lots of stuff that's happening
below that level below the JVM level
that it would be nice if we could call
into it and still have some of the
safeguards and guarantees of running on
top of the JVM so the work that we've
done with JRuby kind of centers around
the most level of our work is trying to
bring this platform this language from
off platform on to the JVM and because
it started off platform and it didn't
live inside this JVM bubble
it consisted of C libraries out there
and the whole world of C++ and native
code to use these are things that we
basically had to support on JRuby in
order for it to be compatible enough
with the C implementation that people
could just transfer their applications
over to use them so file system metadata
and whatnot we needed to have symlinks
support we needed to have permissions
and access control list support being
able to spawn sub processes control them
nicely the graphic stuff this all lines
up exactly with those libraries that
we'd want to be able to use from the
Java level we've done our own work to
try and integrate with these native
libraries for Ruby users and now we're
trying to pull that out and make it more
generally available both as a library
and then hopefully as part of the JVM
and the jdk libraries so here's the
traditional way that we do this we have
our user code at the top that needs to
call down to some native library native
function so we have our j and i call and
then on the C side there's the J&amp;amp;I
implementation that trip represents that
that down call into c and that
eventually calls our target library
somewhere on the system and if you if
you come to J and I for the first time
this looks deceptively simple when you
start
stick this native keyword on here and
we're making a native call that's all
there is to it right it's so easy it's
it's it's as easy as net but that's not
really the whole story because we've got
this generated code that we have to spit
out that you know if you're a Java
developer why would I ever want it took
a look at this stuff
I wouldn't I shouldn't have to look at
this stuff and it just gets worse from
there we've got a represent this in this
case all we're trying to do is call
getpid which cannot be determined across
platform in a reasonable way with any
java api is right now it's such a simple
call we can't do it it's strange and
then we've got once you've got the C
code and the other stuff figured out
then you've got to figure out how to
make it and that's going to be different
across platforms even worse if you want
to ship it for different platforms
either you need to send the native
binary along with it for all those
platforms which we've had to do in some
cases or you need to hope that whenever
the target user gets this library that
they're able to build it and get it to
work on their system this is way too
complicated and this this breaks the
whole idea of building an application on
the JVM that can be transplanted
anywhere and John had this quote that
I've been using a lot to discuss the
native access foreign function interface
stuff if non Java programmers find some
library useful and easy to access
it should be similarly accessible to
Java programmers there's no reason that
the libraries that are out there that
the C C++ node Ruby guys are using
shouldn't be available to us on the JVM
with most of the same safeguards in
place and so the bottom line is that we
need a standard Java API for binding
native libraries in native memory and
making function calls across that
boundary and that's where the Java
native runtime comes in so Java native
runtime you may be familiar with JN a
Java native runtime is a Java API for
calling native code native libraries a
managing native memory and so on
supported by a large set of runtime
libraries that we've built around that
that core functionality we didn't end up
using JN a in JRuby because of
performance concerns because of features
that we're missing I'll get into a
little bit of that later how many are
familiar with JN a job
native access it's the library most
people are familiar with Jay and I are a
little a little more hidden and very
nice implementation so we go back to our
little Jay and I thing here what
actually happens when you're using jnr
is that instead of you writing the J&amp;amp;I
implementation and the C code on the
other side all you have to do is define
a stub that represents two jnr what that
native library or what that native
function call looks like so in the case
of getpid which is a very simple c
function call takes no arguments returns
a long or unsigned integer of some kind
we set up our interface getpid we bind
in the getpid function and say okay it's
should take no arguments and it should
be roughly a Java long and then down in
the main we create an instance of our
library loader for the getpid library
bind it to Lib C here load c is calling
into the c library and that's all there
is to it there's no j'ni code that we
have to write there's no C or make files
that we have to deal with and this is
how it should be even within the JDK
there's way too much J and I we should
be able to do things like this to do
native calls rather than having to write
all that j'ni code
I mentioned that jnr has a sort of
layered runtime and a lot of support
libraries I'm going to go into most of
these at least briefly but we're trying
to build an ecosystem around this FFI
layer so that maybe the library your
gallant you want to buy and maybe if
it's a Lib C function we already have it
available for you you don't have to do
the extra work and then we can build on
top of that so we'll start at the bottom
Lib FFI the library that most platforms
use for doing this sort of programmatic
reflective access to native function
calls not much for us to say about here
we're using it as a library under the
covers to do some of the magic binding
once you actually call across to the
seaside J FFI is our J FFI straddles
that j'ni boundary for the Platte for
the Java native runtime stands for Java
foreign function interface it uses Lib
FFI as I mentioned but this isn't really
the API that you're looking for
surely this is where we keep all of the
native bits for Jnr this is where we
have the lowest level down call the
lowest level invoke this function logic
so normally you wouldn't be dealing with
this unless you're writing your own
layer on top of it
I mentioned that those platforms shipped
with GFI these are all binaries that we
ship currently with GFI and ideally you
throw Jnr into maven file somewhere on
any one of these platforms it should
load up and work just fine a couple that
might be missing here we do have someone
doing an eye series binary now I believe
the OpenVMS binary is out there but I
haven't haven't seen it submitted yet I
think they're using it internally
anybody have a platform that is not
shown here hp-ux um it shouldn't be hard
to build it I'm it'd probably be easy to
get the binary built for it but yeah
that would be an easy one to add
anything else what's that that's a new
one to me yeah no no scent OS is that
what you said
yeah that'd just be Linux we I see we
have we don't have arm 64 listed on here
but again shouldn't be too hard to build
it and this library is very small so if
you have access to one of these
platforms it's pretty easy for you to
build the little binary stub that we
need we can throw it in there and it
probably isn't gonna have to change for
a long time I don't think we've had to
do rebuilds of most of these in three or
four years at this point
Android it'd be arm arm arm 64 so that'd
be Linux arm
I believe this works I haven't tried it
recently but JRuby on dalvik should be
able to call down through the arm jfif
jfif &amp;amp; have access to all the native
libraries alright so let's move up from
there to something that's a little more
user centered Jnr FFI this is the API
you would use to bind your own C
function calls if you've got a library
that you want to wrap and have it
accessible to an application this is
where you would start roughly equivalent
to what you get in jaén a with the
annotations to say it receives these
these values it
returns these values different things
about call protocols and memory layout
and struts and so on Jnr FFI on the jnr
project on github all the JNA our stuff
is under jnr on github so i mentioned
why i'm it's a little bit about JN a we
don't use j na and JRuby for a few
reasons
first of all it wasn't really low-level
enough for us to build other libraries
on top of it JRuby ships and now
maintains a ruby library called simply
FF I that gives you a nice Ruby DSL for
binding native function calls and making
it easy to call them from Ruby code
building that on top of j na introduced
too much overhead so we wanted a lower
level and i'll see preprocessor
constants we have a separate library for
generating some of those preprocessor
macros and constants that you typically
need to call a C function for example
socket types you need to know whether
it's a UNIX socket or an eye net socket
things like that standard API sets out
of the box was nice we wanted to build
around jnr and have api's available and
pre bound for people so that they don't
have to keep redoing the work at the
time it didn't support callbacks from C
back up into Java I think it may now but
we added that in jnr and it works pretty
well and then performance was definitely
not where we needed it Jana's
performance is not where is it's nowhere
near doing the j'ni down call and that
means that it's many orders of magnitude
slower than a C to C call so let's talk
about some of the support libraries that
come along with this the first one to be
J on our constants this is what I
mentioned with the preprocessor constant
support
it's basically run it basically acts as
a C preprocessor that generates some
Java code for you to represent these
these values of these constants in
memory it has a set of generation tools
built into it basically you say here is
the header file here is the set of
constants I want you to generate Java
code for and then run that on all the
platforms you're interested in we get
some enums that represent those
constants across the platforms and then
you can use them to call into the native
api's some examples of the constants
that we provide in the library right now
that we've presented across
most of the same platforms jfo five
supports interesting ones like socket
different signal values if you want to
be signal control let's see what else is
interesting in here the low-level
protocol support in sockets stuff to
file control access different console
level things that you can do so these
are all pre generated for you and then
when you're making a call down to socket
at the C level you can just use one of
these enums to actually pass that that
preprocessor value down this is what
generates this is the set of socket
constants for linux generated with a
simple bit of of code in the generator
and it pretty much just works like an
enum actually when I presented this at
FOSDEM believe you asked how it uses
enums and has different values across
platforms there is a small indirection
from a platform independent enum to the
platform dependent enum so you can use
it in switches for example but then once
it actually gets the native value it
bounces one more level through to these
enums this kind of hides the fact that
you have a different platform all you
would use is jan r dot constance dot
sock for example and you would get all
of the right write values across all
platforms right at once and it runs
anywhere isn't that great
here's an example of using it in UNIX
socket library that we also ship so we
do a native down call to the socket
library we pass in the enums for the
protocol family the socket type and then
we do our connection and we're ready to
go let me say what kind of what kind of
selects we want to be able to do if
we're doing a non-blocking i/o and this
is all that's required for us to have a
UNIX socket in hand and start calling it
from Java pretty nice this is all you'd
write so moving sort of to the side
we've got our constants that represent
all of these different functions and the
values they receive J and our POSIX is
our attempt to bind all of the POSIX
POSIX API slid C API is essentially that
you'd be used to and that people would
commonly want if they're going to come
to something like J and our FF I to get
filesystem access
or signal management things along those
lines so it's a pre bound set of POSIX
functions we are aiming to try and have
100% of those functions abound but for
the most part right now it's been driven
by what JRuby and Jathan use this is our
shared POSIX library that lets us have
some commonality of native function
access this is a small subset of the lot
of the functions that are bound some
interesting ones like being able to
actually fully exec and replace the
current process fork is bound and it
does not work you can try it it's an
epic crash log when you do it but on a
platform like dalvik which actually is a
four Keable version of a four Keable JVM
like thing it's possible to fork may
actually work or with smaller VMS like
java or some of the other ones and what
else is interesting here oh there's our
getpid function so you don't actually
have to do the getpid code you can just
add j' in our POSIX to your dependencies
and call get fit and you're ready to go
mmm
read link symlink filesystem symlink
access file stat to get act like lower
level information about files process
times without calling through some JMX
management beam that's way too slow you
can just get the native process times
directly maseeh at the bottom but
there's also err know is bound so the
last error of whatever the C function is
we do it on a thread local basis so we
save the err no value you can have
multiple different libraries calling in
to C functions they'll always have the
right air no value and you can reset it
and manage it POSIX pond is down at the
very bottom which I'll talk about a
little bit later too so a library that
we've built on top of a more Purpose
Driven purpose-built library as JRE and
xio so you can certainly get your file
descriptor from calling down to native
code and then pass that file descriptor
to read and write calls through through
J FFI or through J and RFI but ideally
if you have a native file descriptor
you'd like it to just look like any
other n io channel any other stream on
the JVM so enx io takes that file
descriptor wraps it up in a n io channel
full selection capabilities and
interrupts ability and all that and then
does all of the i/o operations using
j'ni rff i doing native down calls to
read and write using KQ or a pole or
whatever's appropriate for select on
that platform all handled behind the
scenes all you have to do is construct
it and pass in a file descriptor and
you've got a channel that looks like any
other ni out channel but it can do all
of the standard native calls that a c
function will be able to do and this
we're using this in JRuby in a few
places we're using this to get standard
in standard out that are selectable you
can't actually select on any standard
i/o streams on the JVM we're using this
to do native sub processes that are
actually interactive several other
things that make it so much nicer than
than what we have available right now
there's a couple examples from JRuby
where we're actually creating fully
selectable niño channels based on
standard in out in air pretty easy code
new native device channel 0 1 or 2
and we've got a selectable standard i/o
very easy there's a closer view very
nice so now once we have something like
this where we can build on top of native
file descriptors native down calls and
have a real n io channel let's start
creating some of the different socket
types that people don't have access to
on the JVM so J and our UNIX socket
builds on top of J and our enx i/o and
it is pretty much what you'd expect it
you give it a path you get a UNIX socket
out of it but it looks to the JVM like a
regular n io channel selectable enlists
and all the other stuff that's available
there's an example of using it we've got
a path to some UNIX socket file that we
want to use we'll set that up to delete
on exit create a new UNIX socket address
similar to how you would do a socket
address for a standard socket on the JVM
create a UNIX server socket Channel and
open it and bind to that address and
that's all there is to it now we've got
a UNIX socket server we can create UNIX
socket clients and do all the things
that the UNIX socket guys love to do
that we've never been able to
okay yeah question well for example uh I
believe my seat will still ships by
default with just UNIX socket access you
have to turn on the network socket
access and there are some risk-averse
shops that would rather you just use
UNIX sockets that aren't going to be
accessible off machine so any of those
situations are gonna be improved by this
doing the full socket access is also
generally a lot slower than doing a UNIX
socket because it's gonna have to do the
full socket protocol of course rather
than just going through kernel level and
just passing stuff through so being able
to use UNIX sockets where you would want
to use UNIX sockets like in secured
environments very easy now with this
okay let's move on so I mentioned that
Jay and I are fi jnr in general has
considerably better performance than JEA
we'll talk a little bit about how we're
doing that so we've worked very hard to
make sure that jnr is as fast as
possible and ideally as close as
possible to jay and i performance as we
can that's that's kind of the lower
bound at the moment for performance so
we are generating little byte code stubs
so when you make your get pit call
there's probably only gonna be one hop
to the actual native down call we do
some invokedynamic work on the JRuby
side if you're using the Ruby FFI
library making the function call the
call site where you do that getpid
actually be the direct native call with
just a little bit of argument
manipulation on the other side of the
boundary we generate J&amp;amp;I stubs at
runtime using a library I'll mention in
a minute so we bought we create the
smallest possible simplest fastest j'ni
a binding code at runtime rebind it back
into the JVM and then it's really only
like two hops from a Java call into the
native function of whatever library are
using the the library reasoning to do
that which is another part of the jnr
platform Jnr x86 assembly so if anybody
has ever wanted to write assembly and
then call it from the JVM here's your
library how many folks
really like to do that see there are a
few there's always a few and it's it's
it's actually kind of fun so what this
does is it has a full sort of DSL
library API for generating ASM x86 or
actually 664 assembly then it basically
binds that in as a j'ni entry point and
lets you call it through the rest of the
jnr machinery so you can generate any
amount of native code that you want and
call it through all of the JR stuff
without writing any native code or
compiling anything that's pretty amazing
so we're using that to speed up the j'ni
side of Jnr how does this end up working
out for us well compared to JN a it is
roughly 10 times faster just for
straight-up exact same sort of code if
you map the the JN a code directly to JN
are bought ten times faster now you can
actually do some tweaks to the JN are
binding to speed it up a bit more I
mentioned that we're tracking err no
values after every C call and as you'd
expect sticking getting that err no
value sticking into thread local there's
a little bit of overhead involved if for
example it's getpid and you're really
not concerned about the area now it's
going to be unlikely to ever trigger an
error you can add an annotation that
says ignore error don't do that extra
work to track the err no values and that
gives us another 25 percent or so on top
of the the improvement we get over J
there's certainly more to do though here
we add a couple more possibilities the
interesting ones Jnr getpid and JN are
get paid with ignore error are the
pluses and squares here and oddly enough
with the code generation that we're
doing on the java and native sides we
actually beat a straight-up j'ni version
of getpid be and i'm not actually even
sure what how this has been managed the
guy who did all that native level stuff
wayne Meisner's is kind of a magician
when it comes to this and he's managed
to do some amazing things with that code
generation on either side suffice to say
we're at least in the neighborhood of a
J&amp;amp;I down call so if you're using jnr to
do
native code access native function
access you're not going to have it
nearly as much worries about it being
much slower than Jay and I there's
really no reason to use Jay and I if you
can use jnr that might be the bottom
line now the the more to do is obviously
that GCC - oh three down here is
considerably faster than what we're
doing and that would be a C - C call now
there's potential that JCC may be
optimizing some of these calls out but
it is it is doing some amount of work
here and we're not getting to the point
we should be able to match that the JVM
should be able to see that we're doing
these getpid calls make it a direct
library call and avoid all the Jay and I
overhead entirely and that's what we're
gonna work towards okay for those of you
that love the internal details what we
would really like so this is the actual
assembly code that's generated for
getpid right now we've got our invoke
interface there let's see if my pointers
not showing invoke interface getpid this
basically all boils down at the bottom
down to eventually a in an interface
call to get pid' that does a mapping
through that generated java logic and
finally does the native call what we
would like at the JVM level to be able
to run as fast as C code we'd like this
to actually bind directly into Lib C at
this point so when the JVM gets this
code it can see we're doing a native
call here's the C function let's stick
that directly into the generated
assembly for that java code then we skip
all the J&amp;amp;I overhead which we don't need
for something as simple as get pit and
we can do C as we can do native calls as
fast as C at this point so that's what
we're working on and that is why we need
JVM help for this so if we had a
standard fi API in Java and the JVM JIT
knew about it it would be able to drop
that j'ni overhead perhaps with some
hints from us that this is a trivial
function call it doesn't need the j'ni
stuff or it's not blocking we don't need
to have some safe point stuff around it
we can do a little bit more with
security we can do more with seg fault
protection or memory man
lots of stuff that we can do if we have
this baked into the JVM as part of a
standard API so to work towards that
obviously we worked on jnr for years and
we used it in JRuby and we've done a lot
of stuff with that
but the JVM language summit 2013 I
presented similar talk to this and
showed what we were doing with Jnr and
then begged the JVM folks to work with
us and find a way to do this even better
I kind of expected that I'd be booed off
the stage for talking about native code
access in the the JVM but oddly enough
everyone was really excited about this
idea and I think the folks that were
most excited are the open JDK developers
that do have to write j'ni code and
don't want to anymore if we could get
this into at least open JDK is an API we
could sweep away a whole bunch of C code
that we don't need anymore and it would
make the make open JDK a lot more
approachable for folks so this went well
everyone's excited about this the next
step was then to do a JEP JDK
enhancement proposal so JEP 191 is
foreign function interface for the JVM
the JEP was approved earlier this year
and we do have a now we do have a or an
open JDK project so if you're interested
in seeing our progress on this and where
we're going with it
the project is Panama it's a standard
open JDK sub project on the open JDK
pages John Rose is currently leading it
I'm going to be working closely with him
will will share some of the lead
responsibilities here but we want this
is this this is important to note we
want both the Java API access and the
ability to call these functions and the
JVM hotspot should know about this stuff
so we have someone from the hotspot team
we've got someone who works on the the
consumer side the JIT the Java side and
then folks all along that path we'll be
able to make a really nice really solid
FFI for at least internals of open JDK 9
so step 3 then once we've got the JEP
really functional and working well for
folks would be to do a jsr
and this is certainly a much more
involved process we need to at least
have the JEP underway which it kind of
is at this point we need to get some
more code out there but how many people
would like to see a standard jsr
standard JDK API for doing all of this
stuff alright pretty much everybody
would want that so that that's what we
really would like to do hopefully in the
next few months we'll get to the point
where the JEP is solid enough that we
can start looking at what a jsr might
look like at the very least getting this
available in open JDK itself so how can
you help with this well folks that are
here obviously have some interest in
doing Native calls or native working
with native memory let us know what you
need out of these libraries or what what
would be your killer use case for a jsr
a java standard java api for doing this
you can try out Jnr as i mentioned all
of these have maven artifacts all the
libraries i've shown you can go to the
github project and see a few other
libraries I didn't mention you can help
tidy these up you can help us do some
better documentation the documentation
is a little weak
right now in these libraries so help
their help with the wikis and whatnot
sharing your success and failures with
this stuff letting other people know
that moving from J&amp;amp;A to jnr has made
this improvement for you or creating
additional libraries additional pre
bound libraries for for something else
that something that people might want to
use some lib crypto or something like
that that's available help build out
this runtime in this ecosystem around
native function calls and tell everybody
that you know that is interested in this
native stuff oddly enough there's people
who haven't heard of J&amp;amp;R wasn't it's not
odd that they haven't heard of jnr
there's people that haven't heard of J&amp;amp;A
either and there's a lot of folks who
were still struggling along with J&amp;amp;I not
knowing that these other options are out
there so so let people know about it
I am definitely well ahead of time but
that means I can have lots of questions
so yes let's start with questions right
there
yes okay so the question was about C
functions that return or in some cases
receive a structured form of data
basically a C struct or a union of some
kind at present the way that you would
end up doing that usually is to figure
out what that binding looks like in Jnr
you create a simple java data object
that represents it and then mark it up
with this is this many bits wide this is
that many bits wide and you know maybe
you have to do that on a couple
platforms to get it to map across for
example stat structures have things in
different orders and different widths on
different native platforms what we are
working towards however is the ability
to generate that layout there is a
library for the Ruby side called FF ijen
which uses Lib clang Lib clang is the
the clang C compiler library in a
library form so you can have it load up
code and then introspect against that C
code so we use Lib clang to generate
Ruby code and all you do is pointed at
the header say I want all the functions
with this prefix and all the constants
with that prefix and it generates the
code for you with the struct layouts and
all that stuff
we now are working on the same thing for
jnr there's a project I think on
bitbucket right now called jnr clang
which is a pre bound clang library that
can do a lot of that same generation so
it should be able to generate your
struck layouts generate your function
prototypes so they match up on different
platforms and then you don't have to
then you want anybody to have to write
any code I mean that's that's even
better if we don't have to write any
code to call native then we've won the
game yes here
right so the question is if you're
passing byte buffers back and forth are
they being copied that's kind of up to
you if you define these structures or
define the layout in jnr so that it's
going to be native memory it will proxy
accesses of that memory to the native
code to the native side and then nothing
gets copied when you pass it around to
other functions if you're just saying
okay here's a struck and it has a string
content here or an array content here as
a java value a java object then it does
do the copying when it passes that
struct back and forth yep
here c++ libraries so right now you can
do it cuz C++ functions are just Z in
some way but usually the the challenge
then is figuring out what the compiler
mangling is you know Lib clang or
something that is a library form of GCC
might help there hopefully what we'd be
able to do with Lib clang and some of
the generation tools is be able to
generate the same sort of bindings for
C++ stuff as well so that you can have
the same sort of transparent
representation of a C++ object and it
all it does all the native calls for you
behind the scenes so that is a goal John
I think where we're putting in C++ as a
priority on this right we really do we
think we need to do it right all right
and so for the recording john said that
yes we were going to obviously C has to
come first because everything is going
to be C like calls but there's probably
a lot that we can do for C++ as well and
again with the generation tools
hopefully we can make that easier than
doing a swig binding or something awful
like that yeah
right right so dealing with the memory
life cycles between Java and the C code
we don't do anything specific to deal
with it right now if you have a jnr
object that's allocated that represents
native memory you will either need to
call free on it essentially in some form
or just be satisfied that finalization
may eventually not take care of it but
it hopefully it will eventually take
care of it but that's that's kind of the
best we can do at the moment there are
pot there are api's in the C Ruby
fo five star the Ruby FFI API for doing
bounded access so for example you might
do a try with syntax in Java try with
this native structure do the code
underneath it and then essentially the
auto cleanup of the closeable stuff will
be allocate it for you that might be the
better pattern to use if you're using a
native call but at the moment is still
still very much a manual process you
have to manage native memory like native
memory people do
right right yes exactly so so C++
definitely provides even more challenges
for doing automatic memory management of
that stuff but I mean those are those
are the sort of things that can come as
we get the basic API up there try and
figure out better patterns for managing
native memory making it fit better in
with the JVM and then of course having
JVM but adding better understanding at
the JVM level of these libraries the
fact that this call and this object is
attached to this native memory that's
going to be applicable to a lot of other
stuff that's going to be useful across
the JVM so that we can do better native
memory management
so hopefully that stuff will all kind of
come together as Java 9 yes
well for you would be able to do with
byte buffers at the very least if you
pass a byte buffer across that boundary
in jnr it will come out as the raw byte
oh right on the other side and it won't
won't be any doing any copying for that
I don't know if there's anything more
than what I've might have talked about
here really the you can you can do just
explicit memory allocation right well
see that's the thing the limitations of
J&amp;amp;I up calls back into the JVM and how
easily they can access Java objects are
still intact if you wanted to pass a
Java object out to a native call you'd
either need to serialize it across as
some form the native code recognizes or
as in Jay and I would have to come
across as some sort of handle reference
that isn't actually the object so in
that regard it's not going to be a whole
lot better than what you would do in the
J&amp;amp;I code but that hopefully that
translation that passing across into the
J&amp;amp;I side would be more transparent than
having to write it all in Jay and I and
manage both sides of it and again with
more JVM help we may be able to do some
better tricks to give it a you know like
like Jay and I has soft guarantees that
maybe you can get a pinned reference to
a byte array or something those are the
sort of things that JVM helped with FF
I could do for us a little bit more
automatically in some cases yeah well
one of the big ones is the fact that you
can do P and VOC on net and be able to
do native down calls now what I don't
know is how how well that's optimized
whether it's basically just the plain
old reflective f if I kind of call or if
at build time or link time it's doing
some magic to turn it into a direct sea
call so that's one example the example I
mentioned with Ruby FFI the FFI library
that we've got for for Ruby and J Ruby
and other implementations is in wide use
this standard 0 mq driver that you would
use across Ruby implementations is just
FF I based and people are not having
performance issues with it it's it's
actually really well well designed it
works pretty nicely so uh what's the joy
on the C types yeah so there's C types
as well which again is very similar to
Ruby FF I I don't know about
optimization level how good it is but
it's not good yeah right okay so Jim
mentioned that there's also a c FF i for
python that they're looking at building
on top of jnr Forge I thought as well so
there there are other platforms we're
one of the last ones to have reflective
native access so we need it in the back
it's just a pointer I mean so as a
callback that would be coming back up
into the JVM this debt that is again is
where some of wayne's
black magic comes into play but he will
do these jnr x86 stubs that represent
that up callback and that knows how to
do the J and I up callback into some
object so as long as you can dynamically
link that code in and get that stub you
can do a C callback back up into a Java
function and it generates the
appropriate J&amp;amp;I calls for you well it
would just be the same as a standard J
and I up call at that point yeah here
right it has to have a code spinner cuz
it's it's gonna be done dynamically at
runtime I need to pass this this
interface this object with this
interface out as a C callback generate a
little bit of J and I stub codes so that
the callback pointer does the right
logic to call back up into my object and
it works pretty well yeah so the
question was about for example libraries
like packed object and is that the Azul
winners with the Azul the azul when is
structured array I think that represents
a specific memory layouts and whatnot
yes absolutely all this stuff dovetails
this the the JVM language somewhat
represented this last year was kind it
seemed like the native function call
native memory jvm language summit
because every other talk was about some
aspect of this native object layout
native memory in native arrays and
whatnot so all of this stuff is going to
come together in some form at some point
right now this is focusing mainly on
what we have in Jnr now where you would
do explicit mapping of native memory
locations and manage it yourself but
obviously this all fits together in the
future so if you could pass structured
objects or you know different types of
arrays native arrays with Jnr and have
the JVM know about it then then we have
far fewer issues with that boundary
across yeah
yes Project Panama we we really want to
get that done for Java 9 and there's
like I mentioned as open JDK folks that
are just waiting on this to start
throwing up j'ni code like the day that
we've got it really working well we can
start taking some J&amp;amp;I code out
so yes the JEP the project panama
libraries should get into java 9 we
haven't committed them to the repository
yet we're doing some cleanup still but
they'll be under a jdk internal package
similar to how the nas Harn guys brought
objects Webb's assembly library and
another question to speed up the
invocation of these C functions that
that will come along with that as we
have the basics of library working then
we can get the JVM itself to start
recognizing that these are native down
calls and what that means so we can do a
better job of reducing the overhead of
those calls if we if we do this right we
should be able to make to see calls at
least trivial C calls like getpid as
fast as C would anything else yes over
here yes that that that that is a fun
fun side project that I've tried a
little bit myself I actually at one I
don't know if I ever committed I just
played with it because I wanted access
the JVM TI native functions from the JVM
so that I could do mean nasty things to
the JVM so it certainly is possible it's
it's basically just going to be that Jay
and I down call that does some JVM ti
work I have no idea what that would look
like at the JVM level and how it will
affect things but it's in theory you
could do things like that plans not
currently no so is your your question is
more about being able to have the
additional functionality of JVM ti along
with JDI for exam
basic we've been at a Java level you and
opal no specific plans yet but it's it'd
be a great side project to work on
anything else yes one more
right well so the question is about
making sure that we're not stepping on
the garbage collector anything's that we
need to worry about
well the currently the the Java GC is
not going to know anything about the
actual size of the native memory that
goes along with some object probably the
simplest way to avoid stepping on the GC
would be to do the copying back and
forth you have the overhead of the
copying but everything in the Java space
just represents exactly what the GC
understands as we improve this API we
should be able do that as well for
native objects that are partially native
and partially managed but right now it
still is more of a manual process if you
have native memory you're kind of in the
the basket of having to manage that
native memory yourself the GC is only
going to do what it can at the Java
level I love having lots of questions
anything else all right great
have fun thanks a lot</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>