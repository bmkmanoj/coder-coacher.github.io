<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Using MQTT in Real-World M2M Communication | Coder Coacher - Coaching Coders</title><meta content="Using MQTT in Real-World M2M Communication - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Using MQTT in Real-World M2M Communication</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/r6HEQVhgnP8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everybody my name is Hans Kaimuki I
come from beautiful Munich Germany and I
want to thank the program comedy that
they invited me to do the talk here even
though some of my colleagues were sort
of shocked by the fact that I missed
Oktoberfest this year you might know
that Oktoberfest is happening at the
same time as JavaOne and was a little
bit reluctant accepting the invitation
because it's really a big thing and but
after I've been to one of the keynotes
yesterday I notice the difference is not
that big now this is a clover faced
picture and have you been to one of the
keynotes it looks pretty much like that
they don't wear these funnies heads here
and there's a little less beer
but otherwise it's also a lot of fun I
think it's important for me to
understand a little bit what would you
guys do and what you are so if you have
never felt the need for a safe protocol
when you cook when you need to connect
devices to our back ends would you
please raise your hand
okay okay good
and if who's the leader of the MQTT
expert group any somebody here no so so
there's everything in between and I hope
I can cover stuff that interests all you
my first picture here is a is a
measurement that we that we have taken
on a German Autobahn and it's a
measurement of radio signal strength
when you when you go from Munich to
Stuttgart that's a two and a half hour
ride and we have measured the continuity
of the GSM signal and as you can see on
this picture it is this is not really a
linear graph here but it's it has a lot
of interrupts in it and
you can probably imagine that if you
rely on a connection for communication
that is not that grade in an application
you have to take care that you have a
lot of communication outages and so is
that something that you would have
expected did you know that this is a
typical situation I mean Germany's
probably a fairly developed country and
still we have a GSM connection that is
that bad so did you know that yes
did somebody know it okay
the hawk has the word has the words real
world in it and and the reason for this
is because we work for for a company by
the name of fleet board which is which
is a hundred percent subsidiary of
Daimler and it's basically the
telematics unit of the Daimler truck
brand it's a company of a couple of
hundred people who create telematics
solutions and what what they have a
great portfolio of things they can do
and they they do all kinds of
measurement on trucks during the drive
they maintain logistics processes when
when trucks go out to carry goods they
have like handheld scanners where you
can scan stuff that goes onto the truck
and they have like all kinds of
measurements into trucks for example if
you need to measure the temperature of a
refrigerated truck they can get all
these data from the canvas of the truck
and they send it back to a cyber Center
where they aggregate all this data and
then there's client software where you
could like look at the data that come
from the truck so it's it's pretty
obvious from us from a scenario
standpoint that this this kind of
application needs a secure protocol to
communicate between a truck
the cyber center and this is why we have
looked into mq-4c for this particular
customer we also have a couple of other
customers who are actually used MQ and
the past and still are using mq MQTT to
be correct and some of the stuff that I
show you is just an aggregation of the
experiences that we had with the
different customer situations here so to
make this a little bit more transparent
I have and this is original fleet board
material that our people have free would
have been so kind to allow me to show
this to you so this is this is how the
the basic components of of these
telematics systems look like to you
typically have like a cyber sender or
does this thing some artwork yeah you
have a big back end that aggregates all
the data then you have like the moving
parts of the system the trucks and and
lorries and buses and of course you have
these GPS tracking devices and then it's
so the work place of the people who are
actually interested in these data and
very recently we released a new version
of most the software here for a
particular customer scenario and it's
actually this customer since narrow is
there anybody from Brazil in here now
you meet a lot of Brazilian people here
on job one but not here obviously this
is a folder that we've taken during a
test drive that we did when we deployed
the latest version of some of the
products in Brazil and maybe when you
remember the first slide with with all
these short outages honestly here we
have outages that are like 30 minutes if
you go on a truck you go into the jungle
is this is a road that wrote from Sao
Paulo to
to the port of Sao Paolo somewhere and
you just go through the jungle for two
hours or so and then you suddenly have
like 30 minutes outage and no connection
whatsoever and the interesting question
is when you're an application developer
do you really have to take care about
this do you want to see this in your
application code that there's stuff that
there's situations out there would that
make you stop the communication for 30
minutes and then continue from there
known so now this is like more like a
general approach and and this is how the
presentation is structured so if first
going to go into like more like an
abstract definition on what m2m
communication should be like then I have
a section that explains mqtt and how
it's working and the building blocks
within the protocol and at the end of
the presentation I have a section where
I'm actually showing you a way how we
actually implemented a mqt decline and
mmm QT prokhor so we did our separate
and our own implementation for a number
of reasons and I if we still have time
we can also give you some insight into
extensions that we've done to the
protocol so when you when you have to do
communication in the IOT world the first
and foremost thing from my perspective
is is reliability when you when you want
to get the data from the truck to the
cyber center it is important that you
really get the data it's not like you
send stuff out and you don't get it and
nobody cares it's really important that
you have a reliable protocol next thing
is scalability if you have a couple of
trucks that's probably not as not
another problem but if you are a company
like Freeport who's
also providing back-end services you
might end up having hundred thousands of
trucks or when we talk about the
Internet of Things you might end up
having millions and billions of devices
that want to talk to your back-end so
scalability is very important and this
is not only scalability into the
direction of the of big it's also
scalability into the direction of small
because when you have like small sensors
and and small devices that have weak
processors and little memory because
they only need little power and that's
an important thing in the automotive
space you know everything that's
connected to the battery of a car and
needs to run while the car is off eats
up the battery so so all the engineers
in the automotive space are looking for
stuff with low power consumption low
power consumption means slow processes
little memory and all these things so we
need a solution that scales up in the
large but it's also capable of running
on very small devices and have some
small footprint and then again another
very important thing the the usage of
the bandwidth of the network that you're
working with so you don't want to put
gazillions of bytes on the network bytes
on the network are always expensive so
and and it's time consuming just send
them over the network and we will get
into this a little in more detail later
but that's also an important factor here
the next thing that that is interesting
is is the flexibility in the
communication model so you probably want
a protocol that supports one to one one
to M end-to-end communication because
you have like different schemes of
communication that you need or want to
support and I'll have examples of this
later
and finally you probably are happy when
you're working on with an open standard
there's there's a lot of closed source
stuff out in the world and there's a lot
of proprietary protocol
but when you do communication in the end
to M word you probably want to connect
to a number of sources of information
and you want to connect your device that
is talking to the war to number of
recipients of this information and if
you have a common protocol this will
ease the integration of the business
case that you're actually trying to
achieve here and then there's one thing
that is exceptionally important in in
the automotive space and it is a very
very long product life cycle when you
look at a truck when when you buy and if
you I guess here's no truck drivers or
guys who are in this in this business
but when you buy a truck you want it to
run like ten years or so
so you deploy technology that needs to
be there and functioning ten years after
you have started deploying it and the
funny thing is when we first looked at
MQTT this is exactly 15 years ago
so our first mqg project was 50 years
ago and now when you look at all of the
all of the IOT conferences and
everything MQTT seems to be the hot
thing you know it's 15 year old hot
thing this is really strange but this is
good this is good and you will need this
in the indy in the end time space from a
developer perspective first and foremost
is it needs to be easy to use you don't
want to learn our thousand pages
handbook to use it it needs to be simple
straightforward fast for me personally
the most important thing is the
appropriate abstraction and and that
actually the third is the the third item
here and this is the most important from
my perspective you want complete
separation of the communication from the
application code I told you in in the
beginning when we when we looked at the
at the coverage the radio coverage on
the German Autobahn that there's
short short-term interrupts on on the
connections that's something that you
would probably handle with timeouts in
your application you know when you start
writing this application that talks to
the back end and there's like seconds of
out of time outages you would probably
do like timeouts in your app and check
out whether timers longer is the time
odds would be short short enough to make
this to the smooth application when you
when you use this type of application in
in the jungle where you have like 30
minutes outage it's it's a totally
different world and you actually have to
think about whether you want to persist
the data that you cannot send do you
want to do this in your application do
you want to take care of outages of 30
minutes you probably don't want one day
so in an ideal world and actually mq is
is is giving you that that power you
would just send a stuff out when you
have the data ask for new data if you
want them and if the networks there and
if the communication works you get it
you get the information otherwise you
don't have to take care about it so you
don't do your code for persisting
information this should be done by the
by the implementation of the protocol
also important of course multi-platform
support the device certainly has another
operating system another processor on
there as the backend and of course all
developers love open source so you you
want to have open source implementations
ideally from many sources where you can
choose from whatever you want and as
soon as you have open source you always
also want to change the code and extend
the code so if the protocol is
extensible this would be really ideal so
how does does mqt fit in into this so
what first of all what's the
abbreviation
mqtt means message queue telemetry
transport and this is and just make sure
we're on the same page with this this is
not an implementation it's just
a protocol specification and I'm always
a little bit astonished that people are
so hyped about MQTT because it's
basically the definition of how bytes go
on the wire so what's so exciting about
that I don't know it's it's a message
oriented public subscriber protocol that
is defined in the specification it
basically specifies message types and
message formats it's a pretty
straightforward it to a certain extent
it specifies how these messages should
be handled by the clients and the
brokers and if you want to learn about
this you should go to n QT dot orc it's
the are the best best source for
information about mqt what entity is not
it is another specification how to
implement a broker or a client it's just
the specification on how you put the
data on the wire it's not a
specification for a particular platform
and it's not a specification for an API
so when somebody says we have MQTT you
it's it's not easy to say how they do it
and because there's it's not the
specification on how you would call a
certain method or how the protocol would
look of from a programming perspective
it's it's not an API it's just a
protocol specification what are the
advantages of mq well it's it's really
simple it is a lightweight it has a
small overhead it supports the necessary
communication molds and it's it has a
very interesting and powerful feature it
supports quality of service levels we
will go into deed into detail of that
later
it supports hierarchical topics and I'll
explain that also in detail later
it supports push messages so that's very
different from HTTP its data agnostic
you can send what whatever they do want
over and qtg so again
it's it's a very generic protocol
definition and it's initially designed
for low quality networks I said it's it
has small overhead
so why why small overhead so important
here's a his little sample from another
project that we did for a company that
does power meters and gas meters and
water meters and they have these are
tiny devices with almost no computing
power and what they do is like look for
a reasonable sized city of a million
households these these meters send meter
data every 10 seconds so you probably
don't understand why a water meter would
send its meter data every 10 seconds on
the other hand you have the expectation
that when you click on the website of
your utility you can directly look
what's your power consumption or your
electricity consumption or your water or
huge consumption so so these companies
start to gather data really on it like a
10 seconds frequency and when you when
you do that this this adds up to three
point one five ten to the power of 12
measurements per year so one byte
overhead in the communication protocol
means a terabyte extra traffic on your
network so in now when you look at a
typical HTTP communication when you send
out anybody an idea how big like a
regular HTTP header would be
right so right right and right for
header so so I would say if we really
strip the stuff down it would be a
couple of hundred bytes but still mqtt
gives you something like a two byte
header and it makes a lot of sense when
you look at these numbers and actually
this this seems to be a big thing these
data are first of all they are collected
from the meters and they go to a
concentrator because the rate the range
radio range of the meters is not not
long enough to send the data directly to
the power to the cyber center so first
of all they are send a concentrator and
then from the concentrator they are sent
on to the cyber center so everything is
all again doubled so you can probably
imagine the the amount of data that
flows over over these networks and it's
really really good idea not to send
sensors overhead the the protocol was
actually invented by two gentlemen one
working for IBM another guy eventually
works for your attack and it had the
pleasure to meet one of the your tech
managers just in another meeting and he
these guys have been so friendly to to
open up the specification to the public
for for free so there's the free
specification of amputee since 2010 in
the early days there were only
commercial implementations available in
particular from IBM and the thing was
initially invented and designed to to
measure data that came out of our
control points in oil pipeline that that
goes through Alaska and as they had to
measure the temperature and the pressure
in in the pipeline to make sure whether
the oil was flowing all the time and
the way they did this was through
satellite links and satellite things are
of course very expensive and we just had
a discussion about the amount of
overhead so these guys were very aware
that they would probably not send two
men too much data over the over network
the the MQ TV spec has been submitted to
Oasis standardization organization and
it is actually standard sized
standardised at the Oasis Foundation
since 2013 and the kind release is three
point one one so let's have a look at
the the general layout on how and on the
components of MQTT communication so we
have typically we have like on the
left-hand side we have a client the
client might have a persistent store or
might not have a persistent store then
there's a broker and it's a mandatory
component in the in the mqt world so
you'd never talk client to client you
always have the broker in the middle you
have things that you send over the
network which are called messages
typically the most important thing in a
message next to the to the payload is
the topic with I which identifies the
message yeah then you triple give a
number of flags that specify how the
message is transported then you have the
the broker which is distributing the
message to the subscribers the broker
typically has a data store then you have
the client side so these are entities
who are interested in the data that
somebody publishes and last not least
you have a transport which is typically
is tcp/ip in case of mqtt the
specification is sort of implying tcp/ip
we have actually put MQTT on other
protocols as well so it's possible to do
it and that's also very interesting that
you're not confined to do
tcp/ip there's there's other NQ related
specifications like m2t TSN for sensor
networks that are definitely not built
on tcp/ip but on protocols like CP or
the like so if you are interested in
that you have a look at the mqtt a zen
specification so that then how does an
mq t message look like and this is it's
just a rough picture but it gives you an
idea and this is this is all about the
specification you know this is how how
when you open the specification look at
it it's just all these little boxes
saying bite one says this and bytes two
says this and the fourth bit in despites
is this so there's there's always like a
fixed header and this fixed header is
like only two byte and it definitely is
the smallest message that you can send
then depending on what type of message
you use there's a variable header which
normally includes the topic in case you
publish information and in case you
subscribe for specific topic and finally
then there's the the payload width which
is essentially a byte buffer and this
you to some extent you have to make your
own marshaling case you send data
between processes that have different
engine engineering so like it when you
have a big-endian processor and a little
endian process and you send native stuff
it's up to you to make sure that the
byte order is really correct in your
case what people usually do is they send
like Jason or protobuf stuff XML is not
so popular because it has too much
overhead of course and now this is this
is the whole set of messages you can
send with them kitty this is is it this
not a lot you know it's connect
acknowledge the connection publish
acknowledge the publishing then there's
some stuff for odd - for two-way
handshakes we will look at this later
subscribe so you you announced that you
are interested for a particular topic
there's acknowledges for this it's a
ping like for implementing a heartbeat
and and the disconnect may message and
this looks really simple but still it's
pretty powerful and I have I and I want
to show you how how powerful this can be
you with only those four four messages
so if if you imagine you would do
something with these four messages
connect to a broker subscribe for a
topic and then sit there and wait until
somebody publishes something to this
topic you would get the data eventually
you would unsubscribe and disconnect so
your well behaved application should do
is you do it like that but there's other
options so this is what I just said you
connect maybe with an extra flag that
that says clean so this is a new
connection I don't want to have old
stuff you subscribe for a specific topic
than you wait you don't you get data or
you don't get data at certain point in
time you say okay I'm no longer
interested you disconnect and when you
do this again after a while it will be
the exact same sequence here and you
will only get information while you are
oops
while you are connected and while you
have subscribed for a particular topic
now when we when we and this is by the
way this is called a non-durable
subscription for a particular topic and
now when we look at a thing that's
called a durable just subscription the
the see just the sequence of the
messages has changed here so we start
with the connect we do with subscribe
for a particular topic and then we
disconnect for whatever reason and at a
later point in time we reconnect so we
go again connect and at that point we
will receive all message
that have been published to the topic in
the meantime while I was disconnected so
that's very very powerful and then we
can disconnect and do whatever we want
but that's that's an interesting way so
from an application programmer
standpoint it's it's really nice
you just disk you can connect and then
you are no longer sure what's happening
you just disconnect wait when you until
you have nice network connection again
and you do the connect and you get all
the information was initially intended
to reach you on a particular topic this
is all done with the same four messages
just in a different order so I think
that's a very powerful feature and the
other thing that makes mqtt so strong is
is actually the quality of service thing
and you don't have that in for example
we had a HTTP sample you don't have that
in HTTP if you want to get data through
HTTP you just send the request and get
response and that's it in MQTT you can
specify how seriously you are interested
in particular data and again here the
one of the criteria that makes that
makes this interesting is if you if you
have if you want really know low
overhead you might be accepting a lower
reliability and if you want to be sure
to get particularly information you need
to accept a little bit more traffic on
the wire like two-way handshakes us on
so you can actually get the data in MQTT
we have like three service levels
defined
first service level is qs0 messaging
fire-and-forget knows he just publish
don't care if anybody gets it just
subscribe don't care if you actually get
the stuff that you're asking for why
would you need that is there any use
case for that it sounds like it's
completely ridiculous right it's it's
it's not ridiculous the real-world case
for this is like GPS data when you
consider you have a truck and there's a
telematics uniques in there that has a
GPS antenna this thing will publish GPS
data by the second typically this is the
frequency that the GPS engine is sending
data out then consider you have like a
handheld computer that has no a GPS
adapter like the ruggedized things that
go into trucks typically don't have that
but you could run a navigation system on
this thing and the navigation system
would be happy to receive GPS data like
every second so it would be nice to
connect your handheld computer to this
particular data source and get the GPS
data by on every second so but still if
you if you lose some of these data if
you if there's a certain interrupts and
you don't get the GPS today by the
second it doesn't matter because usually
you your GPS in and it's not really
getting GPS data every second when you
go through a tunnel or when you go in
areas where there's other things slowing
down the reception of the GPS signal you
won't get GPS data at all so the
protocol here to use like
fire-and-forget is not inhibiting the
general use case because the GPS the
navigation system is actually used to
not get data every second you know and
so you don't have to buy in security
with extra overhead for this type of
data
how does that work well there's a
message you publish it's sent to the
broker the message is there and then
it's going to be distributed on to the
subscribers and then there's a second
message that we send out and in case
it's like not going through nobody will
know I nobody will be interested us one
messaging and that's the probably the
most popular way of using MQ it's our
protocol where actually the reception of
a message is is acknowledged from the
other end of the communication it's a
simple mechanism and it's only making
sure that a particular message is
received at least once Oh in case and I
will show this protocol in more detail
shortly but it's like there might be
retries and the message might be sent a
couple of times but you can be sure you
get it maybe you get it a couple of
times but you it's made sure you get it
and the typical applicator get vocation
for this would be like when the on board
unit sends a collection of GPS data to
document a certain tour that the truck
has taken and this information must go
into the cyber center because it's
describing what the truck was doing and
it's part of the business process that
is implemented so you you will not be
happy to lose these data how does it
work so we have again a typical
situation here we send a publish we
measure we publish the message it goes
to the broker and I'm doing the critical
case here when the broker sends the
acknowledged message back to the client
we consider that this message is lost so
what happens now the specification is
funny in with that respect so it says if
there's a time out the sender may retry
delivery I think if it does not and then
there's going to be very little in
communication going on so I I think we
have to wait for the timeout and then we
will send a message again and the
message is labeled with a duplicate flag
here for the interested parties to
notice that this is a second time send
and it's being sent and when it is
received by the broker their brokers
actually acknowledging the message with
the pub back message back to the client
and now we have the situation the
clients happy he could deliver the
message and on the other hand we have
like two copies of the message on the
other side and one is labeled with the
duck leg it's easy to to do a sample
where there where the initial message
does not go through so you just would
have messages with a duck flag so when
you use this protocol you can just make
sure that at least one copy of the
message is being received by by your
communication partner and so you can use
this whenever you are able to
distinguish between the W Cades on the
content of the message so the protocol
doesn't help you you have to actually
look into the message and find out
whether it's information you can make
sure that this is a duplicate so it's
not is something the protocol cannot do
you for you so if you want to make sure
to get exactly one copy of a message
then you have to employ q has two
messaging it's like a double message
exchange to ensure that there's exactly
one message being transferred to the
communication partner and when would you
do this well when you cannot identify
the duplicity of a message from the
payload and what's a typical scenario
here and as the session title says the
real world thing so what we use this for
in case we
send status messages of an engine so
consider you have like high oil pressure
or something and you want to send it to
the back end so somebody can make sure
that there's an oil change you know in
the engine or something like that and if
you get dublicate messages on that you
might get the impression that there's a
permanent permanent thing going on you
will get the same information a couple
of times and actually it was only a
single incident so you would use qs2 for
these types of messages and here's a
little sample on how that works and i
have not built the sample tool to
contain an error case is just how this
would work normally when everything goes
well so the message is sent to the
broker the broker and now again here's
actually there's two two flavors of qs2
messaging I'm just showing you one here
is this is not an order protocol
discussion in detail but I'm showing the
the more prominent version of the qs2
the message is the receptor which the
message is gotten by the broker and then
it's persisted in the persistent store
of the broker the broker sends a message
to the client says I got I got this
particular message the client is happy
about it and says ok you can release it
to my subscribers when the club when the
broker gets the release message it's
actually taking the message out of the
store and forwarding to the subscribers
and then we'll send a publication
complete a published complete message
back to their mqtt client and then
everything is great now I'm all these
slides it was just the publisher and the
broker you can define the QoS levels on
both ends of the communication path so
you can specify on how on which QIS
level you publish particularly
information at the same time you can
specify as a sub
driver on which qsr level you want to
receive particular messages and uh it's
easier to show on a slide and they
explain the text here so just imagine we
would subscribe for a particular message
with Q as one so we have the demand to
get messages with QoS one so when we
publish something with QR 0 this will go
through to the client with Q s 0 if you
publish in Q s 1 we will get it in Q s 1
and if we publish something Q s 2 we
would still downed ready to cue s1 on on
the subscriber side so what why does it
make sense for some reason your
subscriber might only be capable of
doing Q s 0 because he has not the has
not enough computing power or network
bandwidth to do the handshaking
say they you would just be happy to
receive the stuff and your publishers
might have a different intention but you
just have the capability of receiving Q
as 0 so you could still do that and
here's a second example if you ask for q
qs' 2 on the subscriber side you will
just get on the communication path it
will just get the same Q s that the
message was published initially so when
you send in 0 you will get it in 0 when
you send in one you will get in 1 and
when you publish in Q as 2 you will
receive it Q as 2 now it's very easy to
imagine what happens when you subscribe
and Q s no 0 right you will always get
the stuff on the Q s 0 this is a sample
I have taken from from the IBM read book
about mqt communication and it's a rough
it gives you a rough idea on how
expensive these QoS levels are and
there's a assumption made that when you
send a single message it's TTM the time
that is it being used and if you send a
qs1 you use the time for the message
the time for the acknowledge and when
you Duke us to it's like three times the
time for the acknowledge and one time
the message and then the numbers here
that are they are from the red book and
it gives you an impression on a typical
typical case on a GSM network so it's
like it more than doubles the time when
you use Q as two compared to Q zero
there's some other nice feature think in
M Q there's a last will message in case
is the communication breaks down while
you try to communicate with with a
client or in case you fail to respond to
a heartbeat request the broker will send
a last will so a the brokers under the
impression that you that you as a
publisher or as a subscriber have have
died and he send your last tool out to
the world
typically this would be a message to an
operator to say oh you better look after
this particular device it's no longer
responding it's not a message that comes
from from the client or it's a message
that's being sent by the broker who can
no longer establish and maintain a
connection to a particular kind this
this message will of course not be sent
when you do a regular disconnect it's
only being sent when you when something
linked goes wrong and the typical
situation here is is fatal device you're
handling and then there's another
interesting feature
it's called retain messages and it's
it's a way of informing people about a
particular last typically a last value
so when you send a message with a retain
flag said this message will be stored
and if somebody subscribes for this
particular topic at a later point in
time the message will still be delivered
to him so it's a it's like somebody
comes in late and wants to get some
information he just subscribes for the
particular
we can he will get the last message that
was sent from the publisher so typically
this last good known value we actually
use this type of thing for for an
information when the when the guy who
sits in the cyber center wants to look
at a truck and once look whether it's on
the Autobahn or on a parking space we
just have a particular topic where we
publish something on the Autobahn on a
parking place and when somebody connects
to this particular topic you will see
what was the last message that this
particular truck has sent so it's very
handy just a short word about topics
topics are basically strings and you
will be weld wise to just think of a
file system it's like you can combine
strings with separators and these topics
basically define how the different
clients talk to each other so you would
say like this is a truck slash
oil pressure and then you would get for
a particular truck you would get a
particularly pressure if you subscribe
to this topic and it's important to
understand that each message has only
exactly one topic you can form topic
trees and as in a file system you can
also use wildcards in it in the topic so
if you're interested like in the oil
pressure of all your trucks you would
just go like truck hash and you would
get all all information what that was
send to the truck slash whatever topic
then there's single every y cards and
multiple level Y because I think that's
that's pretty straightforward now how do
you form the topologies in the
communication that's again very easy if
you want to one one-to-one communication
just use a single topic between you and
your communication partner it's maybe a
C even a secret topic if you want to go
like 1 to N
that's the that's a typical lectures
scenario you would publish to you there
would be a publisher that would publish
to a specific topic and many people
would subscribe and if you want to have
something like a chatroom then the same
clients can publish and subscribe to the
same topic and then this will be like a
m2m communication scheme there's one
thing in the specification that I
personally find elite it's the it's the
security thing
the mqt specification does not really
care a lot about security the idea is
that they have the underlying transport
taking care of the security or the
application which feeds the stuff into
the payload takes care about security
the only thing that we find here that
protocol specification is like you can
send a username and password with your
connect message and if the broker is
interested to interpret it he does it if
he's not interested in you it's just
ignoring the information so this is sort
of a very very low level security
approach the MQ guys defend that they
say it's it's not our it's not our
business to take care of security it's
the business of the transport I don't
agree
sure sure sure
responding so if I want to be
the pillow to preach a message
absolutely yes
when we talk about a fourth of surveys
on number one
who is in charge to
we move from the database the message to
deliver to the subscriber or the
specification does not say it it's up to
the implementation to decide yes
absolutely yes
and we will see an example later if you
want to know who who implemented MQTT
just go to mqt get up to IO and you will
find like gazillions of implementations
for all languages that you can imagine
and probably learn some new languages
that have you never encountered before
just because they have an MQ
implementation I'm not going to go into
detail here I just want to mention the
power implementation of the Eclipse
Foundation I was on the Eclipse board so
I have to do that and it's a good it's a
reasonable implementation by the way so
now we we get back to back to like the
actual use cases we've been facing and
now this is this is something that
basically describes the typical setup of
our telematics thing you have like a
headless onboard unit this thing
publishes vehicle data and then there's
the back end which is je circ mostly je
so the broker running on there and then
the actual business applications are
client to this broker and reads the data
from basically subscribes for the data
from the headless onboard unit now when
and we had this December before when you
now you add like a handheld computer
which sits on next to the dashboard of
the truck and this this thing has no
Japan and GPS antenna but you it's a
Windows Mobile thing you could
by a 15 euro our nav system and you do
have the data here because it's the data
stairs being sent to the cyber center
all the time so wouldn't it be nice to
just use the same data on your on your
handheld to feed the GPS data into the
nav system yes it would be and the one
way to do it would you would just open
up another network connection and
subscribe for the data that is best by
the headless onboard unit and bits
that's the way you could do it it's it's
totally legal
but it's also totally stupid because you
would send the data over the network and
then send it back over the network and
you just have these two things sitting
together in the truck it makes no sense
to use the network on almost connection
so would it be much nicer to have a
different communication scheme so I
think that's a lot better you just send
the data to over the network if you
really need to send it over the network
and otherwise you have like the option
to subscribe like locally and when and
it's easy to to imagine that the
handheld computer has a Bluetooth
connection to the onboard unit that sits
in the car or in the truck and then you
have a second subscriber for the same
data
and if you want to do that you have to
run the broker and the client on the
onboard unit so when you look at all the
implementations that are out there
there's like C implementations and Java
implementations Python implementations
all that kind of stuff and you certainly
don't want to have a broker or running
in C broker running on the onward unit
and then have a Java client or something
like that so you would be probably happy
to have a simple implementation that
runs everywhere and that you don't have
to test everywhere I mean open source is
great but you also have to test it and
especially when you do commercial
software in the automotive space you
really have to test it because when it's
out there and it's not working the V
codes are being called back and this is
no
fun you can't even insure yourself
against the cost that come come out of
these callbacks so you really have to
test this very well and what we thought
would be really cool is to have an
implementation that would actually work
on all of the systems that would work on
the handheld would work on the onboard
unit would work on the back end and
what's the preferred language for this
okay is not a surprise we just said just
put JA everywhere you know this is l1 so
not a surprise so we we thought it would
be really cool to have an implementation
that is fully Java that does all the
protocol handling handling in Java is
symmetric so we can use actually one
single jar to deploy it on all the
devices we would actually want to deploy
the same jar on a server and on the
device this would be really cool on the
other hand it's also maybe not so cool
because you if you run on like a server
cluster the implementation is probably
would be really different from an
implementation that runs on a 60
megahertz arm so this is it's not so
easy so the way to handle this is
actually to do MQ implementation that is
based on SPI is like service provider
interfaces and we have factor out a
cover a couple of service provider
interfaces that make sense to us this is
in particular persistence there you go
it's the transport you can we can
abstract the transport from the protocol
authentication and then we have a thing
that we call timer and worker that's a
it's basically I'm gonna come to that on
the next slide and we do have a logging
of the need for logging you know when
you do real real projects you always
need to know what's happening and things
out there you need in be inform about
what's happening and it logging is
always very important and these two
implementations client and Broker they
would just use service provider
interfaces
to do the action thing so the
implementation of MQTT there is
basically a passive implementation
there's no threads in there and no
processing in there it's just passive
code which is executed by and this is
the worker timer worker thing here will
be executed by a thread that is passed
on to the implementation who actually
does the work and then the threads done
and this works very well when you
implement MQ as a state machine the
requirements that come out of this
approach is you have to be fully
reentrant with the implementation of mqt
of the protocol implementation but other
than that it's this is a really low
barrier to to do and we choose to
actually use a very portable language
set so we we have limited ourselves to
use Java 1.4.2 language features so we
can run in a classical CDC environment
and we can run on server of course and
this is it is really good because when
you have done all the testing on the
protocol itself
you're practically done and then you
only have to take care about the service
provider interfaces and this is like
this is like how how this would look in
in reality when you run either the
client or the broker code on a device
for persistence you would probably have
a flash file system if any so you could
probably survive even without any
persistence you would have a local
authentication service we have been so
bold to implement other transports so we
can use MQ over serial we have
implemented a call level interface that
actually called just calls as a java
method in case we run the broker and
declined in the same way mmm at the same
time so we don't need to go over the
network or employer
IP connection for this we can just use
it as a call level we can even use the
canvas to transfer messages over MQ and
then the timer worker this would like in
many real-world embedded systems we have
like a cooperative multitasking approach
with with a message queue where where we
sort of get time slices and so there's a
typically we have like a thread a single
thread that is passed into the
implementation just does the state
transition and then gets back to the
normal code and on on mqt server-side we
would actually running on a server dirty
to be correct we would have like an
in-memory DB or we would like have a
real sequel DB right there
authentication would probably be done by
talking to an LDAP server transport is
typically tcp/ip or JC a connector the
timer would be a thread pool not just a
thread so the time of worker thing would
not just be one thread but it would be a
thread pool that you would get from a
from a GE server so you can run many
requests in parallel and logging would
either go to it to a database or to
filed and the funny thing is here like
logging on on the device is something
that we do with UDP it's more
lightweight and doing something else
okay so I have three more minutes MQ is
really great for sending short messages
when you send big messages things get
sort of ugly why would you want to send
big messages we thought when we did this
we didn't think too much about big
messages we thought like typically GPS
data and stuff is short but then the
client said okay we want to push
software configuration information out
there in the field we won't actually do
software updates
this is OSGi stuff so we
want to send particular bundles out
there and we don't want to have a
separate communication protocol for this
so why don't we send the same
information through AB Q it's secure its
fast its lightweight so let's use it
only recently we had to include like
photos and and document scans to the
application which being sent back to the
server so the stuff that goes through
the communication channels getting
bigger and bigger and the the bad thing
about it is that the the message
transfer is atomic from from a
communication standpoint you when you
start sending like 10 megabytes over MQ
and the 10 megabytes don't go through
because you have a communication outage
somewhere but all the 10 megabytes are
gone and then there will be a retry and
they will start again to than 10
megabytes and they will be interrupted
and you end up sending a hundred
megabytes even if you just want to send
one photo and the obvious solution is
automatic fragmentation so when when the
message gets to a certain lengths we've
we start to fragment the message but not
not on the API level just on a protocol
level so from the front of me API
standpoint you just send your big photo
the implementation actually interprets
the lengths of the payload and starts to
descend then decides to make a lot of
messages out of the one message and then
when you have outages during the
communication you only have to resend
particular fragments of this there's
there's some technical problems here you
have to have sequence numbers when you
send these things out you have to have a
consecutive number of message IDs and
this can be ensured by the
implementation and then the
implementation also has to take care to
reconstruct the message on the
subscriber side the one thing that that
we found ugly is that there's no
actually there's no support for these
fragmented messages in MQ and we misused
in the mqq header it's a reserved bid to
identify that a particular message is of
a part of a fragmented message this is
very fast because you don't have to look
into the data you can just look on the
protocol header this is a fragment needs
to go somewhere and wait until the rest
comes in it's not okay from a protocol
perspective because this is a reserved
bid and you probably should not use it
we actually did it and this is so so
it's not compliant it you can do it
otherwise you can do it by just looking
into the payload and do the
fragmentation completely on the payload
level but then you have to do it like on
the on that more on the application and
you for this you sure need qs1 because
you want to make sure that every
fragment goes go through oops wrong
direction okay then then there's one
more thing before I'm done when we when
you receive a big message we don't
rebuild this in the memory because you
might be a client only with 15 Meg's of
memory and you're getting a software
update with that is a hundred Meg's so
you can't even store it in your memory
so what we do is we put the fragments in
a persistent store and when you want to
access the data you get a streaming
protocol on the API level and can access
that okay so that's it I'm over time
already thank you for thank you for not
falling asleep so I see everybody said
and I'm open for question of course
was great and then 15 next 15 minutes we
level was great and that world became
not so great let's see how that would go
how do you tell the protocol we move
been sending around you had no
communication to is taking out which you
don't want to stand which you want to
discard it you have to do it manually
you would you would so this is it's it's
a question about the semantics of the
data how to interpret the data or would
you that it's not the protocol that
helps you it's a matter of
implementation excuse me for the
recording can you repeat the question
oh yeah that the question was whether
the whether there's an option to to
discard stale messages that are no
longer interesting to the subscriber so
the one option would be to publish to a
topic with a retain flag so it would
only hold the last message but it's not
what you what you want you want a
particular you want messages that are
not sent out then you want to look at
these find out they are stale and then
throw them away not send them at all
right that's something that you can do
when we actually did this we have
implemented like a priority scheme on
messages in the implementation we can
even we can even say okay there's a
important message and we want it to be
sent earlier than other messages but
that's an implementation detail of how
we did it it's not in the spec
right the question was this they're like
a timeout for messages that are in the
queue and then would be discarded after
a certain point in time it's not it's
not in the specification you certainly
can do it in your implementation now
this is proprietary and we're not
selling it it's it's part of a couple of
projects so this is a like a collection
of things that we learn and then we did
it's there for it's just information not
a product for me oh sure there's there's
certainly implementations out there who
do implement portions of this or
fragments of this or all of this I I
don't know this is just what we what we
learned and how we did it but it's a the
question is did we look at co-op as an
alternative protocol seriously no it's
the decision views q is almost 10 years
old that's that's put me a CO app
there was another question that the
topic is basically identifying the
content that you are interested in and
the message ID is being used in in the
handshaking protocols to identify to
which particular message the message ID
would be in the variable header then yes
now the maximum essage size is 256 max
sure next question please
the question was how did we solve the
problem with finding the right topic
names I organized the right topic names
honestly the topic tree is very small we
basically have only two levels in most
of the applications and we don't know it
we do not use the deep trees here it's
it's device name to ident to be able to
as the first part of the topic the
device name is very important because
you can actually establish one-to-one
communication by using the device name
is the first part of the topic and then
it's basically like a handful other
things that are subtopics and that's it
we don't go any deeper than that it's
also like something that it it increases
the message size when you when you do
like big big topic trees you usually
don't you don't want that okay any more
questions
okay thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>