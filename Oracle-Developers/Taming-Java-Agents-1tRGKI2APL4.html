<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Taming Java Agents | Coder Coacher - Coaching Coders</title><meta content="Taming Java Agents - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Taming Java Agents</b></h2><h5 class="post__date">2015-06-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/1tRGKI2APL4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to the session about java agents
taming Joe agents to be more precise I'm
anthem he is Nikita we come from
different companies but our products
that we do leveraged our agent
technology and this is why we are doing
this talk together I was thinking if
what could be the reason for you to come
this to this chalk and I have no clue
right I have I can just assume that
maybe you have read the title and you
told it's cool and would be cool to
learn about java agents and come to this
talk or maybe have even read the
abstract maybe not maybe you are
interested in tools who knows but yeah
as we go through the talk if you have
questions please mark down come to our
software words ask the questions
afterwards it will be pleasure to talk
about this subject later as well so this
talk is about Joe aging technology and
how our products terrible and plumber'
actually leverage this technology to
implement what we do and we will talk
about it later what those products do we
come from Estonia just happened so that
we live in this small country in
Northern Europe 10 hours away from here
in time zones and well this those
products are not open source and this is
why we are not really revealing all the
technical details but we give you some
pointers not don't hate us for for that
and but for the start let's let's start
with something completely different just
to give a brief introduction into the
subject so that we move smoothly
so consider this simple problem simple
problem of logging logging is never
enough right you never know how much
logging you actually need to to look or
to trace what the application does and
probably need actually tracing at this
point of time you may ask why tracing
tracing is the same as logging because
traces can be added in that dynamically
to the application so basically it's
dynamic tracing you start with no traces
for your application you add traces then
dynamically when it runs to just
illustrate simple example we have a
method with a bunch of statements inside
there is no logging at it at all we
didn't think about it we thought it's
not needed to log anything there and
suddenly but some exception happens
there's an error or the program starts
to misbehave or just something
interesting is happening and you want to
know what is happening there and you
always think it work oh if I could only
add some logging they're not possible
right too late so there are some tools
that you can use to add traces
dynamically into your running
application there is B trace that can be
used with visual vm there is this cool
open source project by by jboss called
bite man which is which is based also on
java agent technology and it's open
source so after this session if you are
interested in this technology you
probably would like to go and check out
how it's actually implemented inside but
just to give you an example what can be
done here is this little snippet of code
that executes threads you start some
application with parameters and the
every parameters print it in a thread in
a loop right so with brightman you can
add an aspect of like rule which the
points
okay I have a thread class please
instrument the start method of the
thread plus and insert a trace they're
so after this rule is applied e-every
started threat will print out this log
line and if you start your application
with vitamin agent it can transform the
existing thread plus to have this trace
line so on the start but as I always
already saying you might have the use
case when you need to add traces
dynamically when you start without the
agent so assume that your application is
running already the one that is up there
and you want to install an agent to
retrans form the thread class so there
is an option invite meant that it hasn't
a small utility that you execute you
give it a process ID it attaches to
running JVM installs the agent returns
forms the classes by default it doesn't
apply the rule yet but we can apply the
rule later using some other utility
which just parses the script submits to
running JVM running agent and that agent
will returns from the classes and apply
the rules so this use case basically
shows the power of Chau agent technology
and in here we give you a brief overview
of what shower agents are and what are
the main things to remember by the way
how many of you are familiar with Java
agents as such also it's pretty like
fifty percent of you at least so the
main three things are the java agent
plus it has to implement some notation
to be treated as a gel agent and this
packaging which is important you
to the proper packaging to start to
apply or to say to Jerry am that this
class is actually a java agent and of
course there's a proper JVM argument
that you use to bootstrap DJ so agent
itself is plain old java class you and
really implement any interfaces there is
just a notation where you implement two
methods basically a pre main method
which was added in Java five and agent
main method which was added in Java 6
and in there you have all this and a
gateway into JVM into class loading
process to start instrumenting the
classes adding and using the
instrumentation api so if we go to pre
main remain is applied whenever the
classes are low but basically when you
start your application with date with
the agent not not the option when you
have to apply the agent as an
afterthought instrumentation can be
optional and it also requires the
manifest we will see a you take a look
at the manifest a little bit later agent
Maine cannot touch it uses the it can
use the virtual machine API and can
attach to you running JVM and basically
the only use case we can think about is
applying some changes post factum to to
the running process or maybe maybe some
adding some traces or adding some
monitoring capabilities and so on so
manifest it has a few attributes that
are important agent Maine Class remain
class so those two are respectively for
pre main method and agent main method so
you can you can you can define those
methods in different classes and in the
same packaging you can say that this
class implements the bootstrap agent and
another one will be the attached agent
for instance boot past buff is basically
when you need to use some other classes
that don't belong to the application but
you want to use some JSON API for
instance inside the agent so you would
define it there and then you basically
give capabilities if you allow the agent
to redefine redefine re transform
classes this example is the exact copy
from durable manifest file we use a few
attributes there the pre main Clause so
we are always the bootstrap agent we
don't attach to the running JVM but we
will always have to start the
application with predefined ciao agent
we also give the capability to to
redefine pluses so it's the main
function of terrible to redefine classes
on deploy boot class part of course we
bundle all our utility classes into one
jar so that it will be easier to use and
that's why we just specify one jar there
and the main class sometimes we need
some utility options like generating
something for the user so that's why we
just have this standard main cluster so
this is the API for attaching to JVM
basically in tues jar you have a virtual
machine plus which you can use to attach
to process ID and load the agent and
detached from from running JVM so
whenever you do load agent it actually
will apply transformations and apply
your rules and this is just a little
picture to illustrate that you start one
JVM without agent and you start another
one with the agent and when you do load
agent Beijing to connect to the running
JVM and light rules again so the API is
not that big in the instrumentation API
there are two main
interfaces that we would be using it's
the instrumentation interface and class
file transformer so instrumentation
actually provides a bunch of methods in
here they are not all listed but just
few of them and classify transformer is
pretty simple for us the main capability
or the main methods or this one so we
could add multiple transformers
enjoyable because in our tool we have to
integrate all the ecosystem basically we
spring we're with application containers
with all kind of other frameworks and
just to keep things modular we we use a
notion of plugins and each plug-in is
basically one transformer so we could
add multiple transformers depending on
if one if we if we identify that some
framework is used so for instance if you
start don't get we identify that you are
running on tomcat we have to integrate a
tomcat and we can add a special
transformer for don't gap of course we
can add some some new classes or the
utility classes that we need for for our
operation either to bootstrap class
loader or system class loader and those
are the next star be somewhat useful
methods you really find what classes are
loaded and depending what kind of
classes are loaded in which class loader
we we might might apply different
transformation transformation rules or
logic and basically the core methods for
us already find classes and return small
classes the difference is very almost
non-existent there but basically you
would use returns from pluses method if
you already have defined clause in your
memory am i right yes berkeley don't
sleep
okay class flight transformer interface
it's very simple little it has only one
method with a bunch of parameters but
basically they all the only parameter
you have care about is the byte array
because this is what what the
representation of the closet is you
might be interested in in the
classloader of course if you need to
define the classes in some particular
class loader of the running application
but let's simplify things right now it
think that we only care about the byte
byte array class name is sometimes
important if you want to modify and only
some classes so based on that last name
you can filter out I I don't want to
touch this class little lip it alone
right so basically you can customize
your logic there depending on those
parameters of course so here is a simple
example for how you can start
implementing your own transformer I said
only care about by the way right now and
there are some libraries the key that
you can use to start working with the
byte code for instance you could use a
sm or or java cyst or CG lead to start
pre transforming the existing bites into
some other phone let's say adding new
methods adding new fields adding some
other capabilities so in this example I
have Java sea's API right now so we are
basically obtaining the instance of the
class path and creating a model which is
City class API defined in Java system we
we can read in the bytes do some
transformations and basically get the
bites back after the transformations so
just to illustrate this process of
little bits of class loading is a
process assume instrumentation is kind
of a gateway that can apply transformers
onto this process and inside
transformice we can apply the libraries
to work with the bites
right to to do our stuff there so Java
cyst I have a little example for you
just to get a clue what what we are
doing there it's it's a simple library
uses Java like sin taxes to do bytecode
transformations and it's a JBoss project
so here is a real copy paste code from
chunk from terrible and from a CDI
integration plugin so you could add new
beam you see I beans new injections with
terrible and this code this is a snippet
of code that actually creates the
instrumentation but of course not not
all instrumentation so in this case we
are finding the abstract beam class from
the classpath from weld library and we
decide to add a couple of methods that
would add some capabilities for us to
work with this existing class definition
so that you know we could have a same
interface to the to it so those two
methods actually a part of our API a
part of our interface for plugins and
the the interface is called plus event
listener so we would say that okay there
is just an existing class in the
framework we decide that okay it should
implement an interface and since it
implements the interface we should
implement the methods as well and once
we add the methods actually java cysts
will compiles thus those strings and
inject the bytecode into the class
definition whenever it's loaded and
basically it will define new bites
inside the running JVM so durable is the
tool that basically we are doing my
company is doing not him he's just
sleeping again and I'm listening
it's so interesting yeah you totally you
are talking such interesting themes I am
listening okay yeah gerbil is a like a
Productivity tool and it has one Duke
Choice Award couple of years ago it Maps
the running application back to the
YouTube workspace so you basically have
a mapping from your ID to the running
application in development not not in
life applications and it can reload Java
classes on the fly whenever you change
something so you add a new method change
the configuration file add a new beam at
a new egb whatever it also has to
integrate with all the ecosystem as I
said integrating with application server
supplicate integrating with frameworks
and also ID plugins in some cases ID
plugins don't provide our IDs don't
provide the API for us so we have to
redefine the platform sometimes as well
so whenever plus loaders class is
loading the one that is responsible for
loading your application let's say a
system plus loader for us to map your
application to the workspace we have to
instrument that plus loader and we are
using the configuration file which is
called rebel dot XML in our use case and
whenever the class loader is loading and
we check if the class loader sees this
configuration file we will redefine the
class loader logic to pick the path of
of the director is where it should find
the classes or resources and redefine
the class loader logic to seek in some
other location which basically will map
to the workspace right to get to your ID
to your project and this way you
basically can deploy an empty web
archive in your application server and
it will find the configuration file and
load the resources from somewhere else
so this is one use case when we actually
apply class transformation next it will
be all regions forming your application
classes to be capable for reloading and
whenever you change something we will
load the same version of the next
version of the class through the same
class loader so we don't have to drop
the class loader we have done have to
drop the state and this is why we are
instant just instrumenting the class
loader next it will be reloading or not
reloading but redefining the behavior of
frameworks for initialization if you
change the configuration file obviously
this configuration file would apply some
changes in the behavior of the framework
let's say you are changing annotations
for instance restful restful annotations
you decide some method should be on some
URL path you add a new value to the
annotation and the instrumented
framework should redefine itself again
to make the URL available in the browser
when you hit hit the beach I was
thinking of doing a live demo but you
know live demos crash if you are
interested in seeing the demo we have a
booth at the expo hall or or you can
come to me later and I'll show you but
with that actually give word to Nikita
thank you so until set a little bit
about how Joe agents are cute and useful
but sometimes what you really want to do
with your to you want more you want to
write a tool that is capable to be to do
more to be more powerful to be more
awesome you want your agent to be more
awesome something like that
oops sorry you change picture no that's
better your agent should be awesome
something like that Oh like that the
matter of taste and then fortunately JDK
or JVM gives you that capability gives
you the necessary tools to make your
agent even more powerful and that tools
is JV MTI jvm to link interface eating a
nutshell is an API a bunch of functions
and events there are more than 100 of
those functions really a lot of them
about class loading about objects days
about thread manipulation different
stuff I will mention or we'll talk today
only about some of them and there are
about 30 plus G different events so even
JVM happens something you can know about
that you can provide a call back and do
some you useful stuff that gomti
interface is specified from java java 5
it is being developed and changed
unfortunately it's not that reach a lot
like internal interfaces that for
example Java Mission Control users but
is this API is a rich enough and i will
talk to you about how plomberie uses
this api and what cool things we are
doing with it so the only problem with
JVM chai is that if he we have to write
your agent in see that H file header
file for GM ji right c code to include
gomti dot dot h and then you have all
that power at your fingertip fingertips
but well you java developer now you have
to write Chico
welcome to the real world soap lumber is
yet another estonian startup we try to
solve a performance problem so that you
gel developers can concentrate on your
business law logic we have started with
memory leaks and I am bold enough to say
that we have solved the this problem so
if you have memory leak then give all to
try and now we are looking for other
problem so if you have some performance
related problems then come to us to tell
us we will solve them eventually well
you have how many how old Java is 20
years so you have 18 18 18 18 18 18 it's
it's already coming of age it's 18 you
can buy booth so you have to add 18
years of creating problems with Java and
we have only two years solvent and
forgive give us a time but regardless
memory leak you take our lumber Joe
agent of course if java agent plus
native part because we used event try to
hook into JVM so we can we we have to
use C code as well you take it you
attach it attach it to your running
application just like Anton Schott and
then if your application has memory leak
we will give you some neat report that
your problem is here and in order to
solve it you need to do that that's it
and how we do that and why do we we our
development team has about 20 years
combined of java developer experience
and we have we had to write C code why
first of all we
of that event object free whenever
object is died is that whenever garbage
collector sees that this object should
be freed and reclaim it sends an event
object free you can hook into it and we
can know on the object granularity level
when objects die and we want to know
when your object died we like to see
your object die because that's good if
they if they don't dive their mortal you
have memory leak so we use the object
free went to to know we're not just died
and then we use another functionality
follow references to walk that heap to
follow all references in your hip in
order to make custom format memory dump
we make custom heap done in order to get
more information about your objects
about your objects in runtime because
well as standard heap dump that you can
make with Jay map tool with visual where
visual vm provides only so much
information and we need more information
other type of information so we have we
we do our own custom memory dump using
follow reference function so for memory
leak detection functionality we use a
couple of gomti functions that are not
available on Java API level we have to
go to the sea level do below in order to
hook into JVM internals object free
event for example that's all that inside
inside GM well that far inside GV magic
I can imagine and for our next for the
next problem that we would like to solve
for you
for example you can using JVM toi look
into where these threats are now been
waiting on what objects on what locks
the the threats are locked and contained
it and why your program is so slow why
you have lock contention issue why your
threads are teal and not waiting and not
doing their job and then when you when
you when you know those logs or object
that the that are highly contended then
you can monitor them and you can think
you can look into why so much threat and
which thread are being contained it on
there using this infant information we
hope to solve what contention problem
and deadlox program and lifelock problem
and unfortunately again all that
information is not available on the Java
API level so we had to go deeper to
little deeper and i believe thats about
it you can summarize me yeah thank you i
would basically before summarizing i
would ask you guys how many of you learn
something new today at the world at our
session all right thank you very much
the summer is that okay we there are
some awesome tools JVM not only terrible
and lumber course but Java agent
technologies something that really
enables that and the instrumentation
maybe I of course so if you have any
questions ask now send us an email Ram
person to on Twitter whatever you
feedback thank you very much if you want
to hear it my cards you can take it you
can find me around this week off your
questions for for demo I
I have them all well no not only uncle
Anton thank you any questions the
question was how that what contention
part is different from Jay stack or
similar tool we believe that current
tools on the market give you information
you can run Jay stock you see what's
going on right now but you have to
unload I that yourself we have run that
Jays take a couple of times compared the
tech traces you have to analyze that
information we try to give you the final
answer that you need so you don't have
to run our life you don't have to have
that expertise just like with memory
leaks you take lumber put it to your
application and you get the final answer
of your leak is here not bells and
whistles and dashboard like other tools
I will not mention yes yep and the
question was how and if we distinguish
between genuine memory leak and the big
cash that's the problem in fact one of
the more one of the most usual cases for
false positive we had a little bit false
positive our caches unfortunately for us
sometimes we can convince our client
that unconstraint eid cash is really a
memory because if you care grow
constantly that is that manually so we
we can show you your cash is too big are
you sure that you have constrained in
there
and the question was if you have a
problem with you have too many threat
for your number of CPUs and their tea
and you have context switches too
frequently you have two main threat that
can be a brawl a problem front eyes if
Blomberg helps you with that not yet
that's that is an ongoing effort we
looking into what other problems can be
solved and low contention is one of them
memory waste or blood may be other we
right now just investigating the market
what do you want for us what do we want
us to solve for you so we need your
feedback on that that was just an
example yes please the question was how
to debug java agent that's a good
question you probably trace it actually
it depends where the code that is being
run if it's something like on the
bootstrap level then you don't really
debug it the only trace it oh well you
can't try to debug that with your well
II gear ID know essentially debug line
by line because well it's in Java code
if you judge java code that you can't
step into it and try to debug it but
well unfortunately I imagine Jay rebels
commercial tool is obligated so you all
know just in general if there are two
parts in the loading so one part loads
before actually debugger can attach it
yeah right so you can t values like
normally no but I didn't try it myself
sorry yeah
sorry closed test driven development in
for the agent for the oh it depends what
you mean by test-driven development of
course you can create unit tests or you
can create functional tests right so
what gives you writing a unit test when
you're adding a new method to a class
but you can check you can check only if
the method what was added right it
doesn't make any sense you actually have
to make a test that will be functional
and we'll be testing through the
framework how this new logic was
actually injected into the code
basically it means that you create a web
application two versions of the web
application right the one before the
method was added and the one after the
method pizzette almost the same answer
here we do except instead of functional
patient not so we have outta my details
but not test first because as well a
little bit complicated yes so how jerebo
compares two aspects aspects are
compiled into the code on the start so
basically this is the only similarity
between them terrible its function is
different aspects apply some new logic
on the startup and it stays there but
terrible function is to see that the new
class appeared check the style time step
stamp and reload the club new definition
of the class in JVM and then depending
what the class was doing before maybe it
was a part of framework right it had
some annotations there you have to
reapply the configurations into the
whole surrounding framer
sorry yes it's only for development in
mind well you can you can have an
analogy for this hot swap when you are
debugging your application you have this
capability of debugger to replace method
bodies so you add a new statement there
but this is the only capability JVM
provides you you cannot add new methods
you cannot add superclasses new
interfaces new fields forever and it
only works with the code so hot slob
doesn't know anything about the
ecosystem if you spring configuration
files servers anything yeah yet yeah so
just to repeat that configuration files
for spring hibernate mappings anything
like that right
could you could you take it offline
please yes yes the inside strings right
you're right Joe at the Java code within
strings up the question is but there is
a more sane way of doing it well what
you actually want to have is out the
completion of your code right and syntax
check and everything if if the two would
could do that for you maybe that would
be a cool thing but you can use for
instance groovy with HT transformations
it has a DSL that you can use just
normal groovy files not within strings
and then it provides you the ast
transformation so that you can write dsl
quite low level dsl and instruction
level dsl not not really a bi-level dsl
oh that way well you could write it in
of course in text files and you have to
read those txt files in and so on yeah
but we are not using those but it is
because different developers use
different ideas basically to support
that you need you know the support in
every ID and again we went more lowly
level we use I am so in fact we don't
write Java code and streams we ride bike
lock instructions so we are more up now
we are using a SMS phone all right thank
you guys for coming here and have a good
conference have a good conference yes</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>