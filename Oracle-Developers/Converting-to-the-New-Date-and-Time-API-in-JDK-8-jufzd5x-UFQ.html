<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Converting to the New Date and Time API in JDK 8 | Coder Coacher - Coaching Coders</title><meta content="Converting to the New Date and Time API in JDK 8 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Converting to the New Date and Time API in JDK 8</b></h2><h5 class="post__date">2015-06-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/jufzd5x-UFQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Steve Coburn and I are here to talk
about converting from the existing Java
util calendar API to the new Java time
API has been developed for Java 310 our
third collaborator chairman Chen
couldn't be here today but will fill in
for him
the now-familiar comment about the lack
of authoritative nosov the slides in
terms of predicting the future so just a
quick summary of what we want to cover
today there's a certain set of design
patterns that are run throughout 3:10
and then a lot of it will talk we'll
sort of do side-by-side comparisons of
the current API and the Java 10 API in
for the basic times and the regional
calendars and formatting and in a
naturalization if I can get brief show
of hands how many people were able to
attend the talk on Monday afternoon
introduced in Java taemi API great glad
to see you here and there we're going to
sort of give a quick refresher of the
top level things before we dive into the
examples so the Java time API is made up
of five five packages some of which you
may never have to deal with but the core
package has the basic times for ISO date
and time phone date and time dealing
with both the human Ori at a time and
the Machine time just clocks and
instances this package dedicated to
parsing and formatting which will give
some example for the chrono package is
dedicated to dealing with calendars
other than ISO particularly that we have
concrete implementations of Japanese
timing ago and Hajj and then there's a
package which is probably pretty much
for advanced usage but there's some
interesting things in there related to
sort of the framework that he is used to
extend fields units and build things
like adjusters and queries and then
finally there's a package which is
pretty small but it encapsulates the
timezone the timezone specific related
information so here's a chart that
Stephen used on Monday to just give a
real brief sort of high-level view of
the date/time classes and what pieces
are in them
local dates just to date year month and
day no no complexity about that did it
similarly local time is our minutes
seconds and undercover or not other
covers but there's also nanoseconds
resolution possible then combinations
local date and time is just you know the
pair of them together whenever you need
to represent something which is as both
a date and time but isn't really time
zone sensitive offset time gives you a
way to represent time relative to in
some way knowing where it's relative to
UTC but with a fixed offset and then
zone dating time is sort of the power
tool in that it encompasses in both the
zone to the zone that you're in and any
daylight savings time changes that might
come automatically with that along with
the local date and time and then some
utility classes for a simple year a year
in a month like a credit card expiration
or a month in a day like a birthday
where you don't want to reveal your age
and then finally in the Machine time
there's this an instant which is as a
simple format it actually prints out
other than that but it's a just a way to
capture an instant in time without
really trying to tack it down to a
specific calendar so some sort of
highlights of the API comparison the
3:10 design was targeted at coming of
these points here on the Left where we
wanted a very fluent API that was easy
to use easy to recognize as easy for IDs
to help discover the methods and and
write code the you know as good now is
known to be good design principles
immutable instances are real winner in
terms of knowing what the state is of an
object dealing with multi-threading and
sort of knowing that things aren't
changing when you don't want them to be
changing obviously these days that needs
to be thinks needs to be thread safe
because otherwise you really have to pay
attention when you're doing potentially
multi-threaded things a lot of that
comes really for just from immutability
but that was the criteria the the strong
types was an essential piece and in the
current calendar there's
one type and you have to sort of guess
as to whether you're using it for a date
or time or both or and what but with
strong types as we'll see when you have
a particular use in your application you
get to pick the right type for the right
job and you get the right operators on
it and that's kind of elastic bones by
comparison the current API designs many
times and actually I think this is
calendar is sort of the third API time
API and the JDK they didn't use the flu
and design patterns which probably
weren't really prevalent back in ten
plus years ago mutable was you know all
these things that it does there were
sort of a sign of the times when the
api's were designed and since then we've
learned things better ways to do things
so real quick examples here on the Left
we've got the Java top ten time a P is
and on the right the corresponding if
you're using a calendar or Gregorian
calendar if you need the number of
milliseconds it's you've got our zone
date time I'm using zone day time
because it's got all the times dates and
zones in it but the same operations
exist on local date as appropriate local
time that's one of the other design
patterns is reusing the names of the
methods throughout consistently so you
know if you need to get some of these
fields they you know they're readily
available slightly different syntax then
then Java util calendar where it's
everything is field oriented and you
name the field you want to manipulate
nothing too clever here just a couple of
points in Java time there is an
enumeration for months which allows sort
of typesafe composition of things
including constants for the twelve
months and ISO and one of the
differences is you see that red plus one
over there on the right the months in
the Java time API are numbered from one
to twelve not zero to 11 I we kind of
hope that won't trip anybody up they've
gotten so used to the other bad way of
doing it but too bad get used to so as
with immutable objects when you're
trying to change something you can't
just modify the current ops
instantly you have so the pattern of
using this whiff method or with
nanoseconds with minutes is common
throughout the API it produces a new
instance which has the modified value
whether it's you know day of month of
time obviously with the existing API
you're setting your mutating the current
state and nothing too clever there other
than you have to remember to on the
month to subtract one another suite of
methods for adding and subtracting from
the various fields of times
pretty straightforward arguments the
couple things will stand out here so
milliseconds which has a prominent
presence in the current Java time or
Java API is for time we thought that
didn't really have enough resolution or
precision and so you have to use sort of
a long notation to get the milliseconds
the natural way to record time these
days is with you know stick to the
nanoseconds it's it's you don't have to
worry about some middle ground whether
it has enough precision nothing else too
clever here so just a quick mapping from
the current from the the new types to
the Java util calendar types the given
the number of things in date that have
been deprecated the only real use for it
today is as an instant in time so it
maps to the instant type which is just a
snapshot in time seconds seconds from
1970 + nanoseconds it's it's a simple
duration from that from that epoch date
local date local time and local date
time sort of map to the calendar well
elsewhere everything most of everything
Maps the calendar after this because
that's the only type the generic type
that was existed in Java util
zone date/time ads in the characteristic
of having a zone whether it's a fixed
offset zone or a regional zone and then
the zone IDs and offset in zone rules
that correspond to the information
that's available through the time zone
API in the JDK the same database is used
for both api's both
sets of calendars and the time zone data
so that the data is consistent the only
thing that's different is the API
mechanism we think that the Java time
API is a little easier to use and
provides more information another note
about the weekdays I mentioned there was
an enum for the days of the week in
there there's a new Monday through
Sunday recording you know following the
ISO pattern for four days of the week in
Java time that corresponds there is a a
little bit skewed off of the current job
a little time in that the week there
starts on a Sunday according to the
Gregorian candle by calendar by default
they're both numbered 1 through 7 which
will probably be a source of confusion
but in Java time if you stick to using
the enums where possible you will avoid
you know so many of those pitfalls and
then I already mentioned the
correspondence that UNAM for the months
and the correspondence there so I
mentioned earlier that we had picked
some design patterns in terms of method
names for that are used throughout the
API which with irrespective of which
class things are on so of is typically
used wherever there's a factory method
that produces some instance whether you
you know what creating a local date from
some set of parameters or just anything
that would create a new one from method
is used when you're kind of converting
from one sort of type of object to
another it converts the instance sort of
automatically knowing that both are have
a common basis in in the temporal system
date and date now are typically you know
you find those in method names that are
constructing new dates from from a set
of arguments or from a clock parsing and
format kind of go together there the the
do love each other format appears as an
instance method on the types if you need
to you know format a particular one
given a format string which we'll get to
get with plus - most of them are pretty
pretty straightforward
the
at method as we described on Monday is
used when you for example if you have a
date and you want to add a time to it
you can say you know some date at noon
and it'll give you a date time as a
result and then some handy comparison
methods for date and time so that it's a
little coding that you're writing makes
a little bit clearer that you're you
know comparing before or after various
methods so just a couple more examples
of things that we think in the API will
make think code a little bit more
readable here you might if you wrote
things out you would have imported the
months and referring to months that June
there and but with static imports you
can import this you know the particular
enumeration values and then elide the
get rid of the it in the code so the
code may can be a bit more readable in
this case and that's true whether you're
referring to
you know the enumerations days the week
the months or the names of the fields
which we'll see a bit later so that's
kind of the basics on the the iso api
the next section of the api is about the
calendar of neutral api and there we had
to deal with quite a number of other
calendars besides the iso calendar that
have quite a bit more variable
characteristics that can cause
potentially can cause trouble if you're
not paying attention to it so in this
api the focus is on trying to make sure
that the if you have to use this api to
deal with a calendar that you're well
aware of some of the pitfalls for
example you know the number of months in
the year is not a constant it is not 12
it might be 13 it might be 12 i don't
think we know of any others that are too
much beyond that but
ready yeah
and it varies so you know if you're
using the this API you want to make sure
that you use the arithmetic operators
wherever necessary with the right
arguments so you know don't ever head 12
months to something don't do it if I see
that in the code your failure your code
review fails another thing as usual
don't assume that things roll over
particular days of months you know
months different calendars have
different months Lin lengths of months
and it changes per year and you don't
really want to you don't want your code
to be polluted with any assumptions like
that there are classes that help you
support if you want to use different
starting days the week there's this week
field class allows you to compute things
make a building in the necessary
computations if the week starts on a
different day of the week like Sunday or
Thursday or something and you know use
the API to do the translations from
numbers to months and to names because
they all that it's built in to do the
right set of conversions so with the
kind of neutral API it this reverse a
bit back to sort of like Java util
calendar in terms of the form of it the
there's like you know typically a get
method and then there are fields on all
on the objects that refer to you know
day of month or month of the year hours
of minutes but one of the it's been
valuable in the API is to make a
distinction between this API where you
need to pay more attention to details
than the more fluent API this use just
for ISO and in the case of if you're
adding or subtracting the one of these
date times has up there's a plus method
in which you say I'm going to add three
nanoseconds or you know one day so it's
a little bit different form of the API
but it focuses the the attention on
things that are different about these
calendar neutral api's quick mapping
just from the tip roll for the kinds of
units that are in Java util calendar and
then in the Java time API there's a
distinction between fields and units
and fields correspond to the value
within some composite whereas the unit
is an actual duration or almost a unit
but that's kind of redundant this won't
be much trouble for you so here's an
example where we're using the the
calendar neutral API - there's a
chronology type which is embodiment of a
particular calendar and you can look it
up by name chronology of with the name
or you can look it up by a it's
registered cldr
name and or in this case in the third
case if you want to use there's a way to
drive the calendar selection from the
locale the language tags that are built
into DCP bcp 47 and you can look it up
by building a locale with a particular
calendar data that you want and then
looking the chronology up based on that
locale data ocal and then but once you
have a chronology the next thing you
probably wanna do is create some kind of
a date so chrono date with some
arguments which are the proleptic year
and i guess that's probably worth a
little bit of explanation the in order
to have some common baseline across the
api's the there's a notion of a
proleptic year which is sort of
uniformly goes into the future and far
into the past around the right time from
and so it's a reference point there are
a couple of calendars like the Japanese
calendar which the native calendar is
actually built up into eras that have
smaller ranges of years but there is
still a long term sort of monotonic
calendar from one into the other and the
we call it the proleptic year allows
things to lend the API sub better
another example here of just some simple
operations to find a calendar get the
value different values and the
comparison to java.util calendar this is
actually quite a bit closer in the in
the usage to Java calendar
the ISO calendar but it's all hard to
use it's not it doesn't create as fluent
a coding style you can see on the bio an
example on the left if you want to go
forward to the next month you can just
code it as some date with the beginning
of the month go to that plus one month
correspondingly in the in the job you'll
calendar case you probably want to clone
it so you don't modify the existing one
maybe do care maybe you don't you know
the corresponding methods are pretty are
pretty straightforward but you end up
with a different object with modified
with a modified date so here this is an
example of the the at time method where
you've got an existing date and you want
to concatenate it with it or mix in a
particular time and so there's you know
at time method there's at zone date/time
if you need to augment the time zone
into it as EPS own in the middle to
bottom example and you can again with
all these types if you you can insert a
new like here inserts midnight into this
chrono zone date/time this isn't a
mouthful but just with the width method
and it'll give you the full full output
so just a more specifically there are
some calendars the calendars that we've
sort of pre built into the JDK for
Japanese Thai min ago and Harrah's also
come with a specific set of concrete
types that are immutable and fluent that
allows you to if you want to deal with
that particular calendar that will be
very obvious in your code that you're
dealing with the Japanese calendar there
won't be you can you can if you care to
you can revert to the using some of the
assumptions you know about accountant
Japanese calendar in this case the
comparatively you know the Japanese
calendar naturally has the era's built
in so you know the other method has the
factory method there takes the name of
the era along with the date within the
era
creates the appropriate object there's
always like local time now is something
that uses the default system clock
whether it's just the time or a local
date or local day time and initializes
it from the current turn Java system
clock well spend some more time a little
bit later talking about the formatter
but at the bottom here to get the same
format or out of format out of the Java
10 day time for matter with this similar
pattern which is comes from Cler the GGG
YY mmdd you have to jump through a
couple more hoops in terms of using
simple dates format they get that from
from using java calendar but the output
stills the same and then one of the just
another example of the similar example
using the garage calendar where the
concrete type of of the the of this the
with the International calendars the
only type that really gets specialized
with the caliber neutral calendars is
the date so the Arras date but when
you're talking about a composite of a
date and a time the API resorts or uses
the print generic types to have a
parameterised here it's a chrono local
date time that knows that it's got a
garage date as the as the date was in it
and that being able usik parameterised
the generic types allows you to go in
and out to kind of reacts tracked the
garage date where needed down here where
it says to local date it'll actually the
type that comes out will be the aroused
date and then just a real quick example
of the format the similar kind of
formatting for the dates there so that's
sort of the brief day overview of the
calendar neutral api's I think we're
going to next Stephens going to talk
about localization and formatting
so while Rogers was talking I had a
quick look to see if there are any
calendar systems with other than 12 or
13 months in the year the the only one
which I came up with was the Discordian
calendar which has sort of five months
in the year sort of anyway formatting a
localization so we've got loads of
predefined date and time formats
obviously there's a million zillion ways
in which you might want to format dates
and times but it turns out there's a
whole set of relatively common ones so
ISO 8601 is the international standard
which defines data interchange for dates
and times so it's yeah if you actually
create a local date object the to string
is the ISO 8601 format if you create a
zone a offset date time the to string is
the ISO 8601 format so what you actually
see up there are where that two string
method isn't good enough or you actually
want a formatter itself then we've got a
whole selection of other formats
available so basic ISO date is basically
doesn't have any dashes in it so that's
2011 December and zero three four third
of December 2011
there's the format with the dashes and
as you can see they're build up all the
way down so there's a whole selection of
different pre supplied format in terms
of using them so you can just do now -
dot - string which will get you the
standard one otherwise you can actually
do now adult format passing the
formatter object and you'll just get out
your string so a formatter simple date
format is that thread safe no date time
for matter is so if you've only ever got
any static
if you've got any static simple date
formats in your code go and get rid of
them now because they're all wrong and
broken them horrible
so java.util for matter how many of yous
java.util for matter just out of
interest its third a dreamer yeah
something like that it's one of these
things I think some people use in some
people don't it's very much sort of in
out kind of things so this is another
mechanism which you can use to format
dates and times now Oracle has gone in
there and done the work to integrate
using the existing Java util formatter
patterns
so these percent T C's dollar TVs all
these kind of codes you have to go away
and look at the Java util formatter Java
doc to understand what the codes mean
but basically you can use the same codes
that you used with Java util date or
we're going calendar you can just pass
in a local date or a zone date time and
the same code will just react and work
fine
so it works kind of you don't really
need to think think much more about it
than that so a bit more dive into the
actual date time for matter itself so
here's a case where we are having a look
at some of the ways in which you can
create stuff so here we're creating our
zone date/time object if you just print
to string then you get this format out
so this is the iso 861 format so 9th of
august 2013 320 in the afternoon for
hours behind greenwich and this last bit
where we specifying the timezone ID
that's actually not part of the iso 8601
format but we need to output that to
make sure we got a whole object if you
use one of these formats which please
supply a format for the RFC for
standardized ISO format and then we have
these of localized data time so
obviously if you're writing a global
application you don't know what the
date-time format is in South Africa
let's say you don't know what the
correct format is to use there or you
don't know what the correct format is to
use in Poland so what you're using is
you can basically say I want the full
length format for that location or I
want the medium length format this is a
familiar concept that's the same thing
exists here it's just a bit more
typesafe so rather than passing in an
INT obviously insa being replaced by
enums these days so format style is the
enum that you pass in so these patterns
Roger mentioned them before so the
patterns are basically the same as what
simple date format takes in as its
patterns there are some little
differences on the edges and this is
because this pattern mechanism comes
from the common local data repository
the cldr and they basically define what
pattern letters mean and with simple
date formats Java slightly diverged from
the cldr definition so what we've
managed to do in json 310 is to resync
with cldr and actually the difference
isn't that great but right around some
of the edges if you push it far you'll
find a few differences so here's our
example here where we're printing out a
Zed Zed Zed triple Zed for said and the
Vivi's and you can see that they print
out different varieties of the timezone
ID so there's lots of stuff in there
Oracle's people have done a very good
job in terms of actually implementing
the data behind the scenes here some
other examples we've got a year a week
formatted year we've got some time being
formatted and we've got quarters in
there so you can say q3 she's good Oh
moron locale paste date taken time
formats and so here's his sort of the
comparison between the old way the old
and the new so here we were creating a
simple date format object of medium
medium with a locale again over here
it's format style medium format style
medium with a locale so there's not a
lot of difference between those two
except the you'll notice that the with
locale is kind of a separate method here
and obviously that's it's returning
enough
object because date/time formatter is a
mutual you all know that so that's fine
the end result is the same by the way
there is a bug on the slide up here we
have Gregorian calendar calendar is cast
Gregorian calendar from calendar to get
instance unfortunately calendar got
rocket instance doesn't necessarily
return a Gregorian calendar if you're in
Thailand and you're jvm locale is Thai
it'll return a Thai Buddhist calendar
object and so that will get you a class
cast exception always be careful with
dates and time yeah ok so here's an
example of daylight saving this time
obviously daylight saving time is great
fun
we love having time disappear for an
hour and double it up for a time for an
hour obviously that's great great news
for everybody so here we're creating a
zone date/time object we can get hold of
the zone from that we can get hold of
the rooms the rules from that so the
rules are actually they how does it
change when does it change when these in
the actual daylight savings time we can
find out when is the next transition
after now so when is the next time that
daylight savings time does something
weird when when's the next spring jump
forwards or fall jump back you can get
hold of the length of that so the
duration of the transition or the
transition length is normally an hour
normally you jump forward an hour jump
back an hour sometimes you don't you can
find out when it occurs you can say if
it's negative it's a fall back otherwise
it's falling forward and so we can get
out a whole description the bottom here
yeah which is a nice English description
of when does it move forward when does
it fall back all the informations there
so we have this day time format a
builder so if you can you can just get
away with using these pattern letters
the same as you done with simple date
format but if you need more power there
is now a lower-level more powerful API
that you can get to so this is basically
a builder pattern which allows you to
build up a date
for matter and the patterns we've been
talking about are one of the possible
inputs to the Builder so the builder
allows us to add in literals it allows
us to do numeric values you can control
whether the sign is valued hadn't
leading leading zeros widths you can
control things by local island style
so those localized formats we've been
seeing you can add in the patterns
control fractions the JDK actually
simple take format amusingly gets
fractions wrong if you actually try
pausing pausing something with two
digits fractions when you've declared it
to be three digits it doesn't work in
the way you think it will and you can do
field padding's and obviously all these
extra fields as well right more you can
do case sensitive versus insensitive
parsing so you can specify in control
which control that there's optional
fields so you can say when I'm passing
this bit is optional this bit might be
there or might not be there you can have
default values and there's three modes
of parsing there's strict lenient and
smart so the default is smart so the
smart mode does something intelligent
but if you want to be mean on your input
um you can say strict and that will be
very you know what you defined is what
you is there anything I'm gonna accept
or you can be lenient and lenient is
well pretty pretty loose so if you
specify the you know thirty second of
January it'll give you the first of
every so that's what lenient would do
smart does something in the middle
generally what you want here's our
example so up at the top here we're
creating our formatted builder we're
saying we're going to append an error of
day of a minimum of one character
maximum of two characters and it's never
going to have a sign then we've got an
optional block which is adding on a
colon in the minute of width to another
optional block which is the second of
minute we're ending our first optional
block ending our original optimal block
now if you're pausing and you haven't
passed the minute and you haven't power
the the second obviously we've got to
specify what they are now so here we're
saying if you didn't pass the minute
then would default it to the value one
and if you didn't pass the second
defaulted the value zero now if you
don't include these two lines by default
they'll choose to be zero for time
fields but there's no default for date
fields so one of the common mistakes
that I've seen is people entering a
pattern for year-month-day and choosing
lowercase M rather than uppercase M for
month in their pattern letter so why why
why why mm DD but theyíve used lowercase
M now jsr 310 will complain when it
passes that it'll say I've passed year
minute and day and I don't know what to
do with that so there's a lot more
information available to you in the way
actually does the parsing
so here's our example at the bottom so
this can actually pass if you just put
in nine then it'll default four minutes
an hour the minutes and seconds so you
get nine a one but if you specify 905
then you'll get nine a five so the I
hope I hope you get the impression
there's quite a lot of control and power
in there whether you need that power or
not is up to you but if you need to dig
down you can so you can pretty much
handle most different formats there's a
date picker again Oracle has been busy
this isn't part of the JSON but has been
done along the side and so there's now a
date picker in jail for effects that's
kind of what it looks like
you create a new date picker on an
action you can get hold of the local
date that was picked by it and it is
it's a local date it's just a date
doesn't have any time element so local
date is exactly the right object for it
at justice so adjust those of these
things that allow you to make an
adjustment to a date so it's one of
those things when you're doing
calculations with dates often you have
to say things like get the last day of
the month so there's an example given
the date
return me a new date with the last day
of the month now although we haven't got
the example here this could be
statically imported so you could get rid
of temporal adjuster here and the code
would be very short it would just be and
it would read exactly as your business
requirement which is get me a date with
the last eighth month or you could say
get me the last Friday in a month here's
an example where you want to say get me
the second Monday in a month or you
could get the previous Wednesday so all
of these things are kind of common
things you actually want to do when
you're playing with dates and dates and
also times temporal adjuster does
support manipulations of time but it's
typically dates that you get these kind
of problems with so it allows you to we
supply the ones up on the screen but you
could also write your own so if you've
got some weird way you need to
manipulate a date great you can do it
prepackaged it and use it here's an
example so here's a calculation of a pay
day so the adjuster method takes in the
temporal here we're moving a skipping
Saturday and Sunday moving to the 15th
and then if it's a Saturday or Sunday
backing up so I think this is quite an
American calculation for a for a pay day
as you might know this is relatively
complicated often the internals of an
adjuster would be relatively complicated
because they're doing some kind of
complicated logic but the idea is that
you write it once and then everybody
else who's using it doesn't see that
complicated logic so the use of this is
literally going to be date with next pay
lake right it wants unit test it done
reuse it reusable components they could
yes and that would apply it's not just
to a local date that that's applying to
so you could use the same this same
logic with a local date time or a zone
date time quite a thing that has a date
it's a bit longer when it's
gregoriancalendar bit about joda-time
so similar naming conventions in general
I mean Jo saw three dinner is intended
to be inspired by Jo time to pick up
what was good in joda-time and to fix
the things that were broken so class
names are relatively similar you've got
local date local time local date time
very much the same as what we have there
so Jo two times date time class has
become zoned date time just for a bit of
extra clarity and Jo two times date time
zone has now split in free so there's a
zone ID zone rules and so an offset and
the splitting in three actually helps a
lot when you get into the into the
managing the internals and managing
managing the data it allows you to
express it in much more detail plus it
allows us to have classes like offset
date/time which is very useful for
talking to databases and talking to XML
that's typically what you pass across
XML for example so in joda-time
you have a period class and that
represents all the fields from years to
seconds so you can say it six years five
days and 30 seconds whereas in jsr 310
the period class only supports years
months and days so we've simplified what
period is from joda-time to jsr 3:10
whereas the duration class in joda-time
is basically the same a situation class
in json 310 it represents a number of
seconds
milliseconds in joda-time nanoseconds in
Jos our 310 formatters immutable in both
format a builder relatively similar
so in general jsr 310 is more open and
flexible so the adjuster stuff that
we've just seen the queries they are new
you can design your own field in units
and you don't really want to add a color
of the system in joda-time it's way too
hard but adding a calendar system to jsr
310
it's really not that hard to three
classes
so the aim if I get enough time which
hopefully I will do is that I can
provide a version of joda-time that will
implement that temporal interface is
provided by JDK 8 so you'll be able to
have a version of joda-time that you can
use using the JDK 8 for matters for
example so they'll be an integer
operation between the two but it won't
be it's never going to be ideal because
Jodha times local date class is gonna be
the same as a jdk its local date class
and say it's not going to be totally
obvious which one you've got without
going you're looking at the import
statements and there's not much I can do
about that other than when JDK AIT's out
start moving across it and move your
whole application across at the same
time because it'll make a little life a
lot easier so in summary the new date
and time API we've got fluent immutable
thread safe and easy to use that's kind
of what's being focused on lots of
strong typing so if you're representing
a birthday use a local date object a
shop opening our use a local time object
etc etc formatting and parsing there's
much more power and control in there if
you need it or if you just want to stick
to what you know you can still use the
patterns that you've been familiar with
there is interoperability with Java util
calendar so there are two and from
methods on Java util date Java util
cannon and Gregorian calendar there's
more regional calendars from the JDK
provided before but in primary focus is
on the ISO calendar which is what the
world uses for date and time any
questions or thoughts ok so we're going
over here first
I think the question is are there any
links to Java SQL yeah yeah yeah yep so
the JDBC standard has followed SR 310
all the way through and they've enhanced
their specification to include reference
to jsr 310 so if your driver vendor has
updated their driver it will support
their cell 310 types but note the caveat
so the Java SQL database queue all time
and time stamp based subclass Java util
date and actually they said class title
date the Java SQL types have been
updated to have the correct behavior as
from Java util date yeah so you can
convert from Java Rescue a date to a
local date object in Java rescue time to
a local time which is useful yep say
yeah
okay so the question is I'll how are
leap seconds handled and what about ta I
Stroke UTC type timescale so we kind of
covered this on Monday the short answer
is they're sort of handled and they're
handled in a way whereby most developers
just totally ignore leap seconds and the
way we do this is we define a Java
timescale if you want to look at the
details of it you can download and look
at the Java time instant class on
basically what it says is we divide the
day into 86,400 seconds where our second
is not necessarily the same length as
the second defined by an atomic clock so
if a leap second occurs it in theory
it'll get smooth however the reality is
the Java doesn't have any accurate
clocks no system current time Milly's is
not accurate operating systems don't
give you accurate clocks so trying to
pretend that we could provide ta I or
some other kind of timescale wasn't
realistic if you want to know more come
and ask me afterwards okay
okay so the questions about the period
class yeah
so the period class and whether it so
whether it's sports overlapping in this
kind of thing so yeah so the period
class is an amount of time it's an
amount as in six years and five days it
doesn't specify where those six years
start or where those six years end so
there's no concept of overlapping
because they're not tied they're not
tied to the time to an actual time scale
we ingest are three ten do not provide
any class that ties it and locks it to a
particular point on the time scale you
know maybe that'll be in scope proof
enhancement to JDK nine or maybe it'll
be an open source library it's a useful
thing to have but it's just not in scope
for genders for JDK 8 but but if you do
want to operate on periods the way
you've implied you'd add a period to
some base date to give you another date
and then compare the dates from an
absolute point of view as before or
after and remove any ambiguity yeah yeah
I'm hoping that we will be creating a
well I'm planning on creating a github a
github project three ten extras which
will work with JDK 8 and having the kind
of stuff that's that is missing or
didn't get included in scope so exactly
that kind of thing a Discordian calendar
these kind of things are the kind of
things that can go in there I think we
had a question here first
the question is are we going to
deprecate java.util date and job YouTube
calendar and the answer is no it's to ID
years Oracle don't wanna do it yeah well
they're too deeply embedded into many
applications and the Java Runtime we
have we make very few changes that are
actually going to make any previous
application network so we obviously we
encourage you wholeheartedly to run out
and convert things to date in time and
use them with JDK
but you don't have to go years no force
to retrofit yeah in green
okay so the question is what's the
maturity of the JDK 7 backport so my
company open gamma we use the JDK 7 back
port I maintain it for the purposes of
my company it currently is about 6 to 8
months out of date when we reach API
freeze for JDK 8 which is 2 weeks time
or so after that I will have to go and
update the back port to match the API of
the final JDK 8 and when I do that you
know that should be the point at which
the API is as stable as JDK 8 API in
terms of you know easy accurate does it
pass its tests yes you just might have
to cope with a bit of a bit of API
change to match the JDK 8 API that's all
but the ISO piece which you're probably
relying on has been very stable for a
long time
any other questions yes we got a
question here
okay so the question is what about
escape analysis and sort of performance
tuning in terms of because obviously
they're immutable classes that's going
to mean slightly more garbage collector
churn I haven't done any testing are you
aware of any no everything is in various
small methods with pretty narrow scope
so yeah I mean most most of the most of
the methods tend to be relatively small
they should we've tried to follow what
best practices considered to be for what
good stuff will occur that kind of
tuning tends to occur after the API is
locked down and can carry on occurring
during the lifetime of JDK 8 so we're
not worried about it in general
performance when I've done my high-level
numbers seemed to be fine but yes
there's nope no specific tests on
garbage less not yeah a few things that
I did the performance of Java time API
is better than yeah you can you can make
you tool calendar do really bad
performance if you do get followed by
set followed by get full of ice set that
makes it really bad for dick we're going
red
okay so the question is how does the
memory footprint compare so java.util
date consists of Wong long in essence so
that's 64 bits but I think it also
consists of a reference to a internal
Gregorian calendar object for caching
purposes if I remember rightly so it
probably bigger than that the equivalent
object java.lang Josiah Java toddler
instant consists of 96 bits it's one
long and one INT and there's nothing
else
compared to that's the object header
obviously yeah I don't count those Ja
local date is very efficient it's one
int for the year a short for the month
and a short for the day of month so it's
64 bits designed to be 64 bit so it'll
align nicely with all kind of stuff so
in general all the classes have had have
had the data that they store very
carefully chosen to be essentially
memory efficient and actually more than
that we've taken great care on
serialization the civilized forms are
actually very optimized so if you
actually go and look like the the local
time format if if your object only has
an hour it'll only store one byte if you
have an hour in a minute it will store 2
bytes the caravan an hour minute second
it'll store 3 bytes if you have
nanoseconds then it'll store 7 bytes so
it adapts and is it's very optimized and
actually uses a shared header concept so
if you actually go and ever deserialize
actually print out the contents of a
serialized object you'll find most of
the bytes that get sent across the
network are the class name and field
names of the class that you're sending
so if you have a local date a local time
a local date time you could have loads
of bytes which is to all header and very
very little data but we've mangled that
all together so there's a single
serialization class so you just have one
header no matter how many dates times
local date times offset dates and
ascending and
the minimal number of bites so a lot of
effort has gone into serialization to
make it a very efficient for any other
questions thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>