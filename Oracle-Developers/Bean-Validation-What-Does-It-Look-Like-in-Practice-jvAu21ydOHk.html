<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Bean Validation: What Does It Look Like in Practice? | Coder Coacher - Coaching Coders</title><meta content="Bean Validation: What Does It Look Like in Practice? - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Bean Validation: What Does It Look Like in Practice?</b></h2><h5 class="post__date">2015-06-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/jvAu21ydOHk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">today we are going to talk about bean
validation the roughly three kinds of
presentation the first one is like
listing features via bullet points I
tend not to do that kind of stuff
the second approach is to do explaining
the wild pitch then how do you use or to
use it not necessarily how it has been
done I tend to do this kind of stuff but
then recently I've decided to actually
show the future life cutting and you
know so you could see how to use it like
for you and I hope I live up to the
expectation because the the king of Java
EE 7 life carrying on stages Adam bean
is just right here so hopefully I won't
be and I want to look like a fool so
most seriously so what you will get
today is first of all a quick overview
of what is new in bean validation 1.1
and what you hope you will be able to
get in your application very soon and
then we'll move to the application where
it's an existing application and I will
start adding being validation to improve
the validation and the security of my
application the quality of my
application
who knows and use bean validation
already okay so you will see some stuff
you already know in the in the live
coding but that's okay we will also show
at least you know half of the time new
new features and how to use them so my
name is Emmanuel Bona I'm the spec lead
of bean validation I work for Red Hat as
data platform architect and I'm
historically involved in the hibernate
projects and still am but you know I
touch everything data in the in the
middle website
what else if you are interested in the
JBoss community and the various jabba's
projects I highly encourage you to go
listen to the JBoss community Asylum
podcast the last episode is was very
interesting so we hooked up with one of
our lawyer and we literally discussed
open source licensing and what it means
how to use
how to understand them and so on so if
you use open source software on I'm sure
I read every single one of you do I
highly encourage you to you know listen
to this one-hour episode so first of all
bin validation was fairly open from the
get-go I guess thanks to the kind of
open roots of JBoss but then follow
version 1.1 we went one step further and
really tried to do every every single
thing in the open and everything else
source code is actually available on
github you can do a pull request and
help us when I say everything I mean the
reference implementation the TCK the
actual specification text the website
bean validation org so literally
everything so if you want to know
something about bit validation I have
the reflex to go to bean validation dot
org and if you want to participate run a
tutorial find typos whatever just you
know open a pull request and I will be
very happy to to use your your
contribution so let's go back to bill
validation 1.1 proper the first thing we
did was trying to rethink the way we
manage the lifecycle of the values bean
validation component so like you know
every piece of software bean validation
do handle a few different components
method resolve reversible resolve sorry
message interpolate or possible resolver
also the values constraint validator
implementations and so on and you know
within the Jie platform it it would be
nice for those component to actually be
a regular component of the platform in
the sense of being CGI beans and that's
exactly what we did so all of those
components are no actual CDI beans you
can use add injecting them and and you
know receive other beans with different
scopes and so on and so on this is
probably the most useful in a constraint
validator where you actually write your
own validation and maybe
access to a service or even a couple of
services from there of course you can
use @inject for the validator and
validator factory to use them directly
in your code you can also ask if for
some reason you got more than one bean
validation implementations you can
actually ask for a specific one so the
spec offers the way to in a type safe
way ask for you know a specific provider
and we use also CDI and ma generally act
you know Java e7 interceptor which have
been put as a general concept in the
platform instead of just being CDI CDI
thing so we use that to implement method
validation which is the single biggest
feature of of the spec so method
validation has an interesting history
because we almost made it to the version
1.0 but we thought it would be too big
for a first version and decided to just
put it other than in an appendix for the
next wave so when we started working on
method validation we say well should
it's gonna be easy I'm just gonna take
the appendix make it a chapter think of
it about you know a couple of weeks
maybe a month and then I'll be done well
I guess a year after that I were still
working on it so it told out to be a
much more complex feature than initially
thought especially because we wanted it
to be nicely integrated with the rest of
the platform and nicely integrated into
any kind of environment whether it be
Java EE or even outside Java so what is
method validation bean validation offers
the way to put constraints on your
objects in general the domain model you
put the constraint on the properties
attributes you know whatever the thought
here is that not all data that is coming
in actually end up being into an object
field to be validated sometimes you just
receive that as a parameter of a method
and you want that to respect a given
contract before you actually go and
execute the method and maybe these value
will just be used within the algorithm
and then forgotten
that's where a method validation comes
you literally expressed the fact that
you want the parameters of a method to
be of a certain type so for example I'm
receiving a string then email and I want
I want that to be an actual email so
I'll be mean validation will validate
that for you and if it's not an email
write an exception to the client you
know passing the information so from a
client point of view you just call the
method
but then invalidation hooks into an
interception technology in this case in
Java EE that would be the actual
interceptor spec and we look at the
method we look at the parameters if
there is constraints put on them then we
go and execute bean validation parameter
or validation if everything is fine we
go and execute the method otherwise we
collect the failures and write an
exception providing the the failures
right so let's pretend the parameters
are okay then we go on execute the
method potentially it has a return value
pin validation can check the return
value making sure it's also valid maybe
it should not be nervous kind of stuff
and then we send that back to the client
so from a client point of view it's
transparent but at the implementation
level the method is guaranteed to have
been to have had this parameter being
validated and the client knows the
return value will be safe and another
bonus feature that I kind of like which
was not at all plan in bean validation
initially is the ability to express
error messages as expression language
expressions so the reason we did that is
we wanted to improve bigdecimal
as you know big decimal let's just put
boundaries like that's a mean that's a
max but using big decimals for that and
we wanted to add the ability to include
or exclude the actual boundary and when
you think about that you say well the
error message will be different whether
you include the boundary or not what
strictly lower than or lower or equals
to so we found a couple of solution to
hack that around but we decided to take
a step back
and realize you know how to actually
make offer the ability to be much more
flexible in the way you express our
messages and we needed some kind of
templating system and expression the de
L expressions were available on the
platform so we decided to use them I
think that will be a feature very
interesting to use I mean it's something
we added just for us but I think will be
you know much more useful in a in a
general way
all right enough slides and talking so
let's let's go to the actual application
so for the person that I've been and my
previous story about hybrid search you
will recognize the same application but
the card we'll be talking about being
validation and not hibernate search this
time so this is an application where you
literally can buy tickets so here I've
got different categories of tickets then
I go to this concert I can select for
that event a given venue and then of
course a given date and I was you know
order of some tickets I really want to
be very well you know position so I get
the hot you know best placed sections
I'm adding a ticket and here I you know
just to confirm my order I just need to
put to good an email and that's the
stuff we will want to actually go and
validate so here if I put a valid email
everything is fine I am booked and I'm
ready to go
what we will want to check is if an
email is not valid you know rich on
those kind of errors and so on and so on
let's go to the code it's it's a rich
client application using a backbone just
so I won't show too much of the client
side chorus now really the interesting
part here but the server side is mostly
arrests you know application exposing
some of the contracts so here we've got
this method really represent the last
part of the applique the last part of
the application where you have a ticket
in your basket in your cart and then you
are ready to do the checkout and provide
the email and
you want to come transform this girl
into a booking right so that's what this
method method is about by the way I'm
deploying this stuff on whitefly 8 which
is the new name for Jas it's the version
alpha 4 I think they are all that will
be releasing Pizza one very very soon
not everything works but it's you know
pretty stable I mean I did find a couple
of issues but not not too much I'll talk
about that actually in the later and in
the talk so if we look at that so we got
the cat will receive the card and then
we create a booking object which has
contact email and then constellation
cards then we look through the cart and
then we've finalized the actual seat
allocation create the tickets associate
the ticket to the booking and then we
persist the booking and we're off we go
ok so what we really want to do is make
sure the booking is going to be a valid
object so we go into the booking and
then we define the constraints that we
want to apply on the booking properties
I imagine a booking with a ticket
doesn't make sense I'll put a not empty
annotation what else looking here
constellation curl likewise is probably
an should you know should not be should
not be known or empty if we look back at
tickets I want also the ticket objects
to be valid right so I can ask to
cascade the validation using the add
valid annotation here so when I'm
validating a booking the Associated
ticket will be validated if I go to a
ticket there might be a couple of
properties I'm interested in in
validating for example the price let's
make sure I don't give too much money to
my customer so let's say the mean price
is going to be at least zero dollars or
Euros or whatever currency you are using
back to booking at the cancellation card
the dates so I've got you know other
constraints here that I can apply here I
don't want the
it has to be in the past otherwise
something seems to be wrong so I did put
some constraints that are meaningful for
the user and some that are really
meaningful for the soundness and the
quality of my data okay and of course an
email sorry um the contact email should
not be empty and should be an actual
email so there is a set of default
constraints in bean validation and then
hibernate validator of the reference
implementation adds some more including
email and not empty let's love not empty
is an interesting one because it's using
composition so I don't know if you're
familiar with the idea of composition
inside bean validation but the basically
the goal is to say I've got this
high-level constraint that is named not
empty but really I could compose it from
two lower level constraints the one is
not neuron the second one is ad size so
instead of me having to actually cut the
validation verify verifying the size and
so on and just reusing some of the
implementation and I'm adding an
annotation here that says I don't want
you to report that this stuff is not
nner or the size is wrong I just want
you to say that it's not empty so I
report any failure of the composing
elements as a single violation which is
the not empty violation I think we
should be good while we do that we're
done with describing the constraint we
want to apply the second step is to
actually go and execute those
constraints so you can inject as I was
saying in my in my slides previously you
can eject validator which is the
contract that lets you validate objects
and if we look at the card I think it
would make sense to validate just before
the persist of aeration right so let's
go call the validator there is obviously
a validate method on it
I passed the object I'm willing to
validate which is a regular object in
this case that would be the booking and
I can pass the list the groups that I
want to validate a group is really a
constraints can belong to one or more
group and it's really a way to select a
subset of constraint that you want to
apply in this case I'm I just want to
execute the default constraint so I'm
just doing that so this would return me
a set of constraint violations which
could be empty or not empty so if it's
empty I'm good if it's not empty I need
to do something right so actually let's
rename this stuff doesn't look good
failures that's better
so if failure is not empty something is
wrong and I want to provide that
information back to the user so I don't
know if you paid attention but the
response is actually so it's not
expressed
yeah but basically we're going to return
a JSON a JSON string representing the
actual you know list of failures so the
way you do that is in this case we're
going to just use a map of string sting
was last year this will represent my you
know the root of my JSON object you go
and then I'll create our errors property
with literally the list of error
messages that I want to display so the
list there uses list of string there you
go and then for each of the failures I
want to do something about it so for
each of the constraint violation
well I want to do something about it so
if we look at the failure object I've
got a lot of information here I will
only use the actual error message but
you got a lot of information to do
whatever you want and whatever details
you really want to provide back to the
user the constraint descriptor will will
represent the annotation more or less
the add email failure or something like
that if your validate method you will
get the executable parameter values that
led to the errors same for the return
value in our case for the email that
would be the invalid values get the
wrong email then the beam that was the
property the message the message without
the internationalization the property
path that leads to remember booking can
validate the Associated ticket so there
is a navigation to go from the booking
to the actual property in tickets that
would be invalid for example so I got a
lot of information here I'm only
interesting in get message because I'll
just do error messages and adding the
actual message in this list then I guess
I need to to put the arrows property
into my JSON object what else
I guess need to raise some kind of
exception that my that will be
transformed into an HTTP all code and
then you know how we go so I suppose
Duchess I guess for forward makes I mean
I for 400 so it would make sense but
request there you go and then I will
attached an entity which will be my JSON
structure right I'm going to build that
and I should be good so that should work
are we going to test that it actually
works
not yet so you can do that except that
the goal of bean validation is for you
not to have to use the actual API so you
use the annotations and describe that
into your object but the fact that you
have to call validate oh that validate
is sort of a failure for me because what
I really want is all the frameworks to
actually call that for you transparently
at the right time in our case GPA it
would be nice for JPA to go and validate
the associate you know entities when
they are but we persisted updated or
deleted potentially and that's exactly
what is happening so instead of doing
that what we will do is react to GPA
rising at constraint violation exception
and do the little gymnastic routine
doing here the failure actually are part
of the exception so you can get the list
of failures of constraint violation that
led to the you know validation of a
given entity but then if we do that we
don't need any of these anymore and we
should be good far as I know let's give
it a try so booking a ticket
selecting the chick ticket to populate
my car my cart and then I use a wrong
email all right I've got an error here
that says I'm sorry if that's not an
email if we look at the JavaScript I
mean the backbone associated to it here
you got the actual save operation which
literally corresponds to me clicking
here we go called the rest methods that
is bound and if there is an error forget
about this first if but if there is an
error we pass the JSON from the response
and for each element in it we go and
display an error here okay yes
it is no actually what I was saying is
that if you use Java EE or if use GPA in
this case every time GPA will save an
entity will go &amp;amp; Kolbe in validation so
you you do not have to explicitly click
call validate I just showed it to show
you or you actually you know can do it
if for some reason you receive an object
that is never persisted or not used used
outside Java EE and you want to manually
validate it that's what you would have
done it yeah sorry for being a bit
confused confusing here aldohn you're
ruining the whole presentation here so
JP has an integration and also
presentation frameworks have an
integration JSF for example look at the
bound you know property of an object and
do the validation transparently we get
tapestry you know many of the other
presentation framework no have a nice
have a nice integration with been
validation GWT to for example and we'll
talk about it a bit later but Jesse or
not Jesse actually Jax the rest because
we did that in the stand up also have an
integration but so that's a nice not
this one there you go well that's a
fairly generic message who holla like
ruined my presentation I think
well it was and then I disabled it just
to show you the the plantation because
technically you can easily do it on the
client side by using the email type from
html5 right but then don't trust what's
on the client side when you receive it
from the rest area so that would work
for email but let's say you've got
something more complex like the email
has to be from a subset of domains you
could decide to do that on the client
side as well but at least also do it on
the server side and if the client server
side is fast enough then just do it on
the server side and get the result like
as like I'm showing right now make sense
so sorry I I I guess I didn't clean well
enough my my demo here the message that
you should have seen is a very generic
message which is the default one from
that is provided by being validation so
let me show you that very quickly the
email damn it didn't work I got to save
it
redeploying there you go
there you go you got a generic error
message that says it's not a well-formed
email address and what I want to show
you that you can change that you're
probably familiar with the fact that you
can use add email message and put it
directly in the annotation so that would
be there and puts the message you really
want here the better approach is to use
the validation messages property here
that's happening
if we look at email back here you go
you see this key here it's it's in
brackets which means we delegate to a
validation message here to to to receive
it to sorry to interpolate it so I could
write my custom message here and what I
want to show you that in bean validation
1.1 you can actually receive the
validated the invalid value and put it
in your message so we created we
literally can use the expression
language to access property name
validated value does not look like very
email and you would get what I've shown
you initially which was error you know
these values does not look like a valid
email what what if for some reason the
validated value is not I mean the value
we're looking for is not a string but
something like a number that I want to
format or dates you can we actually
provide you with a formatter that you
can use is that yeah I think it's dollar
sign and of course here you can use the
format of syntax from Java to to do
anything you want here and then you will
get the error message from your properly
formatted for you okay let's now go into
a custom constraints so let's go and
write our own our own constraint if we
go back to cancellation card if you look
at the way it's implemented here we just
pass some random string but let's
pretend the cancellation card is very
well-formed
it's a UUID okay so i would like to make
sure the cancellation card is actually
valid
so I'm creating a cancellation cut
annotation that will represent my
constraint because it's an annotation I
needs to define I need to define the
target in my case that would be field
and value I feel done method sorry I
also need to define a retention which
means you know do I keep this stuff in
the source code is it visible in at
runtime and so on and so on
at the actual runtime is what I'm
looking for and to make this annotation
an actual constraint from from a
minimization point of view I need to add
the constraint annotation and then
provide the list of validators that I am
looking that that will be validating my
my constraint okay the second stuff I
need to do is add three mandatory fields
the first one is message which is string
which is the message while we were
describing when we were talking about e
email default to so the recommendation
of the spec is to use the fully
qualified class name of the annotation
plus plus message
and put that in brackets or somebody can
actually update the validation messages
that property and you know put the
localized message or whatever so this is
one the second one is the notion of
groups groups is literally an array of
class an array of interfaces it defaults
to the default group and it's also
defaulted to nothing so if it's empty we
default to the g4 group and the last one
is a mechanism that we put in place in
case we screwed up something in bin
validation 1.0 apparently we haven't
found the mistake yet so just create
that doesn't it work
there you go okay and then I can put
those it these three are mandatory and
then I can put my own stuff for example
if I've got a range I would get a mean
and a max right property but if we look
at cancellation card I was talking about
a UUID so what would be nice is to use
composition remember the ad not nur so I
could use a pattern here and say the
regex
is something like
oops
getting a bit conscious now
so that should that should work right
and I can even put the ad report a
single violation to make it like a the
cancellation code is wrong you know go
and go and fix that but that's not the
the one I want to show you really the
one I want to show you is custom
implementation so alternatively I can
write a constraint here
okay which needs to implement what
happened exactly
Oh
I'm rust
one what
okay thank you
all right
so this one must implement constraint
validator which except the actual
constraint the the annotation you you
play with and the type you're targeting
so that's why I can put more than one
validation here I can have different
type I can very data string and a number
and so on and so on
I'll add the an implemented methods here
and I don't have anything on
cancellation card like additional
attributes so I don't need any
initialization but I need to do some
stuff here for example well the first
thing you need to do is verify if the
value is null you should just let it go
and considering its true if the user
really wanted the validation code to be
not null you would have put ad not null
annotation aside from your cancellation
color notation then I guess we can use
remove
so let's reemployment what I was
describing which
here but let's do a bit more stuff so
let's do another pattern that that is
ignoring case so in my actual validation
here I can verify whether or not the
pattern is properly you know checked so
is UUID much of value actually in
matches if it's the case then I return
true fine and I use the default method
message as defined in the validation
message dot file but let's say the in
kid of the ignore case I don't consider
it valid but I really want to provide a
better error message to the user so what
I could do is to say well if the UUID
ignore K is much actually matches I
should return false because that's not
valid but I will do I'll do it with a
different error message and that's where
the context object that you're seeing in
the in the method here comes comes into
an D so first of all I will disable the
default error message and then I'll
create a new one that is specific to to
the situation I mean you know
cancellation card should be all in caps
and then I add the constraint violation
if for some reason I you know can
navigate to let's say a map and then a
map as an object and an object as a
property I can use the add parameter
node property node and be no to put the
error exactly where I want and the
constraint violation object will
actually have this information so if we
go back to the application here
and this time put a very tick email oops
you didn't save this one
I will get there all message
I could have done something else which
unfortunately doesn't work yet with a
version of white flat light that I am
using is literally sorry in the in the
class here I get rid of all the code and
use the inject maybe I do have a service
that already do the consolation card
logic for me so I could inject it and if
the value is not known I could literally
reach you know cut series is very done
passing the value okay if we look at
consideration code service that would be
exactly the same code logic that I was
describing so if for some reason you
want to reuse the same logic from that
you use within a constraint valuation
and some other service in your in your
CDI environment and just just use inject
and and delegate to that final stuff I
want to show you is is the what you are
describing before which is the fact that
I can express constraint on the actual
method parameters in this case this
happens to be a JAXA rice method but
that works just the same as a CGI bin
method so here I will say simply verify
that the email should be valid and to
make sure we have the proper one
I'll change the actual error message and
that should be enough what's happening
here is that when jax-rs sees the input
request it will ask me invalidation to
validate the parameters same for the
return value afterwards but the here
validate the parameters and if the
parameters are not valid then but
request error will be created with an
entity representing the the failures so
if we if we check the application here
we with the wrong email we should have
the error message that just described
and there you go right so it works for
jax-rs
methods also resources that you bind
using like bind to fields or settles it
works for any CDI bin so any CGI bin
that you call a method of you can put
constraints on it that's pretty much
what I wanted to show you
let's open up for for questions on you
know in validation 1.1 or even been very
to bean validation generally speaking
yes
so is your question could have just put
it in uppercase just for the user so
that he doesn't know it doesn't receive
an error message but instead I would
handle it myself
it doesn't normalize it's really verify
that the value is correct or not there
is no conversion or transformation
question yes yes I've got a question for
you though why would you do that
okay so so yes you can use there is in
the spec there is a way to express it in
XML and if you use the hibernate
validator specifically we also have a
programmatic mapping API okay I'll let
you express all that which I find better
maybe it doesn't work for you yes yes
that's something unfortunately there has
been no new version of easy Jack's B yes
Jack's B but that's something we would
have done meaning literally can have a
two-way bridge between Jack's big
constraints and what you can put in your
object that would be you know mapping
the dejected access this schema so the
XS d would say add not this stuff is not
now limited to 40 characters and then we
would generate the add not null at max
you know 40 characters unfortunately
nobody was working on that spec so that
didn't happen
so the way yep right so the way you
would do that is literally using the the
metadata API that we have that was that
was a primary use case for for it so JSF
use it a little bit but what I had in
mind really was for JSF or any other
presentation framework to be able to
either generate the JavaScript
associated to that thanks to the
metadata saying well this field is
actually an email so let's do some
client-side validation here or do some
kind of binding saying you know for for
this fully qualified you know email
constraint let's use this email dodges
you know piece of code and bind that and
fortunately nobody I think rich faces
did that partially but primefaces too so
you can actually say let's say I write a
custom annotation like social security
number which is my stuff you could
actually bind a JavaScript piece of code
and okay right okay so it goes at least
alpha through the division a hat and
maybe they did it all the way through
yes
they're using a genie weary sigh
yes well now in this case that's that's
backbone so I'm literally receiving a
Jason's no I'm actually receiving a
response that I that I do boss I didn't
show it because it is a bit nasty and
that's something I hope to change before
before we go final for whitefly so rest
rest easy which is the implementation
JBoss use for jax-rs
actually does something like that
so if you put an arrow on your I mean if
there is an arrow literally on the the
parameters what's happening is the
return first of all the header as
validation exception equals true well
it's it's present so I you you can check
it that's why I do that and the message
looks like that it says here is the type
of error so in this case that's a
parameter I or the return value where
all right so here parameter then it says
forward if it's a fully qualified name
but that's literally the the method name
here plus the name of the argument
if you don't do anything that would be
our zero one two if you can place the
parameter on named implementation to
actually you know get it from the debug
in for hopefully in Java is it in Java
that they will have actual parameter in
the class anyway in one one day in Java
will be able to actually access that so
we'll got better message like that would
be email here right and then the actual
error message so you know the email is
wrong and finally the actual invalid
value so not an emergency so I had to do
this nasty stuff and I do not
contrary to what the presentation show I
hate regular expressions took me forever
try this one
but that's not you know that's not
practical what I really want them to do
is to retrieve you to provide back a
JSON object that would contain the list
of errors and each you know you know
specific properties so for example you
would say you know an array of error and
the errors the you know type type value
parter then the actual source that would
be you know the method name then the
parameter name you know and so on and so
on so you can much properly pass these
stuff and expose that to your to your
user the way you want and and don't have
to do some kind of string passing like I
have to do here yes yes so just back
back to the previous question
unfortunately that has not been standard
in Jack's the rest the way you export
the error messages hopefully they will
do that in an x-ray or something like
that so back to the next question which
was hey this file here can I actually
get the information from a relational
data format data source instead of just
this file the answer is yes in a bean
validation we've got something called
the message interpolator which literally
takes this string and return the
interpolated string so here you can have
an implementation that goes and get the
value from summarize if you use
hibernate validator we even have the
stuff split in two there is a notion of
resolver and then the notion of actual
interpolate also the logic of finding
the key and interpolating it is split
from the the logic of retrieving the
information and the keys values yes
or parent bin so almost so it's not
sanitized no no that wouldn't be via the
payload but there is a unwrap method in
context so an actual implement where was
that
there's a unwrap here method that lets
implementations to actually do
additional stuff and I think getting the
beam because what you're really
interested in is accessing the beam that
is hosting the property
I forgot how but you can do that in a
hibernate validator
so you can literally access the beam
that is hosting the property and you
will be able to do what you want I think
no no just context unwrapped and forget
the type or looking forward you would
get it otherwise if you do if you want
some kind of context but that it's not
related to the object graph you're
validating you would use just CDI to
inject what you're looking for so let's
say you the behavior of the other of the
constraint validator is really dependent
maybe of something inside the database
or somewhere else
then you would use you know at inject
and get the value or the meaningful
information from there right that opens
up the possibility to do whatever you
want well the validate what you describe
in XML as far as I know is the right but
the constraint implementation is still
in Java yes
it is it's a report as single violation
so when you use composition it's just a
way to say if use composition or don't
put that one if there is like five
composing constraints and there is three
arrows you will get three error reports
right
you should really want it as one as a
global error then you would use the
report as single violation make sense
another question yes yes so the the
validation messages properties here is
you can use the I forgot the detail with
underscore and then the your actual
locale and if you use JSF we just have
actually passed the proper locale of
your customer not the one from the VM
which you don't care about right so the
customer would get the proper you know
if he is Swedish would get something
very weird and if he's English it would
be understandable any Swedish here no
okay I got one question for you I saw
you know a bunch of people leading so
was the presentation format just wrong
or you know what's your feedback on the
fine okay okay so I guess I got a hit
love relationship in there that's true
that's a good point actually
anyway any if you have any question we
still got time otherwise we can get
early lunch
that's nice
it's the purpose no it's too late
that would be from an HTTP point of the
on point of view that would be an error
of 500 well the server was supposed to
give you something and it failed that's
exactly the binding by the way jax-rs
will rise a 500 if you have the real
code the way I see it is really a way to
express the contract between the client
and the contract implements or using a
notation instead of just describing it
into into your Java doc it's it's really
influenced by the program
what's the name programmation by
contract from you know the FL language
so where you literally describe the
input constraints and output constraint
of a method and then the method itself
really focuses on the what it has to do
and not just a validation of what's in
and out right so it's kind of a good
practice you could just not do it but
it's I find it that it expresses you
know what you're really want out of the
contract but that's definitely much less
useful to validate the return value than
the parameters
so yeah I got it so I guess you were I
had a JSF presentation weren't you it's
not quite true it is true in the in the
binding with JSF because we couldn't
express the metadata that said when I'm
validating this stuff it's really
validating those three properties we
didn't find something that was good
enough but what you can do is add a
constraint or D on the class itself so
if you if here you put a constraint on
the class itself what you receive is the
ticket instance and of course you can do
ticket that price and ticket that
category to do your cross validation for
parameters we actually can support cross
parameter of validation so you can check
that let's say password and you you know
repeated password are actually the same
if this is possible
right well so you can you you you can
solve that problem with the existing
with what I was describing so you put it
at the class level but then you use the
context that create custom error message
and then you place it exactly on which
property you want because you could do
you could do you know adds property node
and then decide which property you want
to put the constraint on I guess that
would be that would depend on the
presentation framework whether or not
they have done a binding but I write for
JSF I think they have not done it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>