<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Programming with Lambda Expressions in Java | Coder Coacher - Coaching Coders</title><meta content="Programming with Lambda Expressions in Java - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Programming with Lambda Expressions in Java</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Gsfmfeb2XW8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">let's get started welcome to the session
on programming with lambda expressions
in Java my name is Venkat Subramanyam
we're going to talk about some of the
most fundamentals about what lambda
expressions are how we can use them the
best time to ask a question or make a
comment is when you have it so please
don't wait till the end any time is a
great time for questions comments just
about anything you want to share so just
grab my attention and ask your question
you're most welcome to participate any
time so let's get started with what
we're going to do here today
well before I get started real quick as
you can see I'm not going to use any
slides over here but if you're
interested in downloading the code
examples that I'm going to show you here
you can download them from my website
I'll post them later on today so you
should have them available by end of the
day so let's get started it's a bit of a
shock actually for myself to be standing
here and talking in praise of Java
because I was one of those guys standing
on the other side of the pickets and
line and and constantly complaining how
Java sucks
well Java actually has come a very long
way let's take a look at where Java has
been if you really look at the time when
Java was created right after that about
20 years ago are a little bit more well
there was a bit of a doldrum there's
really nothing happened Java 1.1 had
some features then came along Java fight
with some questionable features like
generics and auto boxing and then Java 6
had no real language features at all and
Java 7 had again some questionable
features one of my most favorite is you
could put underscore in numbers as I'm
becoming older that's a feature I really
enjoy so I can count the number of
digits well all that is going to change
absolutely with Java 8 and Java deserves
every bit of the credit I'm going to
praise over here so one of the biggest
changes in Java 8 is lambda expression
so what's the lambda expression well the
lambda expression is an anonymous method
or anonymous function well actually it's
a cute little anonymous function well
what does it really mean well so far in
Java we've been doing object composition
which means we have been creating
objects and calling methods and objects
using various things related to object
in the programming well now we have
another choice another tool on our hand
we not only can
use objects we can also use function
composition as well or even better we
can mix object composition and function
composition together if we like to so to
understand this I'm going to work with
the series of examples but in order to
understand this example I'm going to
start with something extremely simple as
in familiar we have done this so many
times a million times everybody in this
room has done this and I'm going to
start modifying the code one small bit
at a time and every time I modify the
code we may learn something a little
different
get familiarize with this comfortable
with it and then we want to refactor it
one more time after that so let's get
started with a little example that we
can work with something that is very
familiar to everybody in this room I'm
going to start iterating a list of
values to begin with so let's say for a
minute I have a list of integer values
we'll call it as numbers here for a
minute and let's say this is going to be
a raised dart as list
we'll just say these first few values
that I want to work with and we want to
simply iterate over these values and I
want to print them out well given this
set of values that we have on our hand
is the font size big enough for the
people in the back row give me a thumbs
up if it is alright excellent so we can
see that we want to iterate through this
what would I do so I would say for int I
equal to 0 for example and then I less
than we would say numbers start hmm
here's at length or okay you got the
point right and then I plus plus oh wait
a minute is it less than or less than or
equal to would that ever be less than
equal to sure have you ever faced this
thing call off by one error
so I have a infinity design patterns I
have a name for this design pattern this
pattern is called self-inflicted wound
pattern there is absolutely no need to
do this in 2014 right and yet we see
code like this written over and over and
over and we got to pause and think
whether we are doing the right thing
well people will tell you this is a
simple for loop well they got the term
totally mixed up the word they're
looking for is not the word simple the
word you're looking for is the word
familiar there's a very big difference
between the word familiar like
mother-in-law's familiar doesn't mean
you enjoy the company right so the point
really is that familiar doesn't mean
you're comfortable with it familiar
doesn't mean it's simple familiar
doesn't mean it's likable familiar
simply means that you've seen it so many
times you probably don't want to see it
again so this code I'm going to say is
one of the most complex code you could
actually write and the reason it's a
complex code is because if you notice
look at the number of moving parts in
this code you got a first set up the
value of I properly then you got to set
the boundary conditions properly then
you got to increment it properly then
you got to make sure you got all the
things lined up properly and then you
got to call other methods too axes too
many things going on well already we
know there is a better way to do this in
Java it's been around for a long time
and that is simply to say for element in
numbers and then we could simply output
the number what a breath of fresh air
isn't it so we didn't have to work that
hard to produce exactly the same result
and Occam's razor says that if there are
two solutions to the same problem and if
they produce the same result we got to
choose the one that's simpler and
absolutely you can see that this is a
simpler solution compared to the
previous one but collectively these two
together we can name them as what are
called external iterators so what is an
external iterator now an external
iterator is like having a root dog at
home you say move and it doesn't move
you got to move it every step of the way
right so you control the entire
iteration at this point you are in full
control what's wrong with being in full
control well the problem with being in
full control
if you want to change to do something
else you got to still expend the effort
to change it but rather than trying to
take all the effort on our own shoulders
it actually makes sense to see some
control and let the API or the libraries
do the job and this is called the
internal iterator so what is an internal
iterator it's like throwing a frisbee
and the dog goes to get it so the point
is you are not focused on managing the
iteration you're focused on
communicating what your intentions are
the result you would expect and you
don't have to worry about actually doing
the actual iteration itself so how would
we go about doing that so I'm going to
say numbers dot for each well let's stop
right there for a second and understand
the semantical difference we have on our
hand syntactically I'm not showing you
anything that you have not used to so if
you look at line 16 you're called
methods on objects a lot before so soon
tactically it's no different at all
however semantically it's a world of
difference if you look at line number
seven you get exactly what you asked for
which is sequential e iterating through
the values one at a time whereas in line
number 16 we are not quite specifying
how to perform the iteration the
iteration could be sequential the
iteration could be concurrent the
iteration could be lazy we have all
these options on our hand how in the
world can we get those options well we
know this exactly because we call this
polymorphism so polymorphism basically
is where you go to an object and you ask
you to do something and the object
decides at runtime how exactly to do it
so you'd effort the implementation
details and you focus more on the
behavior you expect out of the object
well that's exactly what you can get
from the for each method because you can
ask it to do the iteration without ever
telling it how to exactly do the
iteration and the benefit of this is for
reaching towards the end of the session
we will reflect back on this and see how
that actually benefits and we can see
how that can be very useful in writing
code but let's get to using this how do
I use this internal iterator call for
each
well in order to do this I'm going to go
back and include here a function dart
consumer well what in the world is a
consumer well these are single apps
correct method interfaces in Java and
one of those is consumer but we know
already several single abstract method
interfaces in Java
like runnable callable actionlistener
and so on every single abstract method
interface in Java now is automatically
called as a functional interface every
time I use the word functional interface
I just laugh a little bit because I
always wonder if there are some
functional interfaces what about the
other ones are they dysfunctional anyway
so the point really is that we have
functional interfaces now on our hand
and we can go ahead and use it but how
do we use this functional interface in
this code so I'm going to go ahead and
say new consumer and I'm going to say
integer over here and this interface
over here the consumer interface has a
method and the method it's going to have
is called the accept method which takes
an integer a value and then I'm going to
output the value on my hand so if you
look at this code we turned around the
way we are doing iteration rather than
focusing on the mechanics are the
mechanism of engine the iteration itself
we are instead a belief Oh Kisan just
what to do and let the for each take
care of the iteration as a result we can
get all the benefits I talked about I
know what you're wondering with your
quietness I can feel it you are saying
wait a minute this may really be such a
better way to do it but in order to do
that if I have to write yet another
anonymous inner class heck no right
I mean seriously is there anybody in
this room who gets up in the morning out
of the bed and says yes I'm going to go
to work and write yet another anonymous
inner class right nobody the evidence is
to the contrary right if you ever think
of that you call the boss and say you're
very sick and you won't show up to work
right so nobody likes writing anonymous
inner classes why because this code has
a lot of noise it is a very high
ceremony now what do I mean by siree
what is the real essence in this code
the essence in this code is this one
line we see here which is to print the
value part for each of the elements in
that indicate in the collection we may
print the value in may do other things
with it who cares what we do but that is
the essence but what is around it well
what is around it is called the ceremony
ceremony is what you have to do before
you get to do what you really want to do
anybody here gets excited about ceremony
right no because ceremony sucks the life
out of us right so we don't want to do
it anymore it's like nevermind we don't
want to work on it well if you really
look at this code lets to kind of
refactor there's one more time so let's
go ahead and pick this example and tear
it apart a little bit and if you notice
again in this particular example we
notice that in this particular case we
have this collection on our hand we are
looping through it but if you really
notice we said this is really the
essence well maybe we can give a little
bit more we need to know what the
parameter is that we are receiving but
everything around it is pure ceremony so
notice what I'm doing I'm highlighting
just the ceremony and cuff I delete that
part and then I'm going to go back and
put a little arrow here and then remove
the other part of the ceremony which is
right towards the end of this and we
removed all that fluff around this code
and now what we have on our hand is a
very nice little elegant lambda
expression so what is a lambda
expression well a lambda expression is
nothing but an anonymous function now
most of us would agree that a function
has four things in it a function has a
body a name a parameter list and a
return type of the body the name the
parameter and the list and the return
type we all could agree that the body is
the most important thing
well that arrow is pointing to the body
and saying that's the body that's the
essence of this function to the left of
the arrow is the parameter list of this
function hey what about the return type
it can figure it out what about the name
who cares what the name is when
everything is done it's anonymous
function so we
essentially have the most essential part
of a function the parameter lists to the
left of the arrow and the body of the
function to the right of the arrow as we
can see so when we run this little
example with the lambda expression you
can see that code still works so rather
than accepting a single abstract method
interface the for each method is more
than willing to accept a lambda
expression so what this means is
something extremely powerful you can go
to a library written in java 1.0 like
the java's thread class and rather than
sending a new runnable you can now send
a lambda expression look at the power we
have on our hand is that we can not only
remove the smell right now but clean up
the smell from the past as well pretty
easily with this kind of expression but
this brings us to one other point with
this code if you take a look at this
code there is one other small problem a
little annoyance in this code if you
notice in this example we set a integer
value let's quickly reflect on this what
are we really working with we are
working with a list of integers take a
wild wild guess if you iterate over a
list of integers what would you pick on
your hand like books
donkeys no integer start out what a
great idea do you know it of course you
do does Java know it of course it does
then why in the world are we saying the
most obvious thing over and over and
over so here's one lesson I've learned
in life there is only one time we should
say the obvious that's when you make the
better half you say I love you right
that takes care of your day really well
any other time you say the obvious it
simply dams us right so for the very
first time in a long time Java is
finally intelligent we don't have to
specify the variable type anymore and
notice the code was just happy and it
figured out what the type is in fact if
you poked at it a little bit and say foo
knows the error you are getting the
error actually says
that this actually is a integer object
so it knows it fairly well so there's no
reason for that ceremony to pass that
over and over and over so that's great
we got that code working but we could
remove a little bit more noise in this
code as well for example let's go back
here one more time and we could get rid
of this little parenthesis especially
when we only have one single value why
waste that little noise in there so we
can see that that's a little lambda
expression that works really well well
we are come quite a long but there is
still one other thing we could do to
make this a not better so if you look at
this code for a second
watch carefully what's happening in this
code we receive a value and we are
printing the value now sure nothing
stops us from doing something along
these lines we could have printed the
double of the value or we could have
incremented the value and printed it or
we could have done so many other things
but the point is we dint and all we did
was we simply printed the value that we
received so if you really look at what
the code is doing you received a
parameter and simply turned around and
passed it without touching it so again
going back to design patterns I've got a
name for this pattern I call this
pattern the office space pattern if you
remember seeing the office mates with a
space movie right Tom what do you do
here I take the requirements from the
business people and I give to the
programmers right so nothing intelligent
happens in between so that code is
pretty stupid if you really think about
it right because you're not doing
anything except for the verbal syntax
but history has shown one thing for here
in the past 20 years Java programmers
never write stupid code they actually
invent IDE to vomit stupid code so the
next thing you will notice very quickly
is that programmers will feed each other
hey what's the little id shortcut you're
using in your editor and so they knew
this was coming so as a result what they
decided was to really simplify this and
simply you can say I want to call the
print line method this
is called as method reference so in
other words for simple cases where the
parameter is simply a passed through as
an argument or the parameter without any
alteration is being used as a target to
another method call rather than writing
any syntax that is verbose we could
simply use a method reference and a
method reference saves us quite a bit of
effort and writing the code it also
becomes a lot more concise as we get
used to it now of course we got to get
used to the syntax but once we get used
to the syntax it becomes rather very
simple and expressive as we going to see
or when we use these method references
over and over in what we write so we
have come quite a long way in this
example as you can see we started with a
list of these values then we did an
iteration using the traditional for loop
where it gives us a sequential iteration
but one of the most complex looping we
have used to and then we used in the for
each iteration which had fewer moving
parts in it then we traded that to an
internal iterator which unfortunately
was still ceremonious and noisy then we
traded that with a lambda expression
which really helped us do remove all the
fluff and the noise in the code then we
removed the type information use type
inference then we remove the little
parenthesis and finally elevate this to
a method reference because that was
quite adequate for our purpose in here
so that is an example of how we would
start writing code for doing what we
have been doing for quite a while but we
can do it a lot better when it comes to
writing code in Java
thanks to lambda expressions so we have
a fundamental shift in the way we are
writing code we are going from what we
are used to which is imperative style of
programming to something a lot better
which is functional and decorative style
of coding in order to understand this
let's take this a step further and look
at one other problem you're going to
solve with this so let's say for a
minute that we have this collection of
data of values rather but we are not
interested in printing those by
iteration but we want to perform let's
say
a total of the double of all the values
well how would we write code for this
well let's try this into result equal to
zero and then we would say output the
result when we are done but how do you
do the iteration well we would say for
an element e in numbers and then we
would say result plus equal to e times
two so you can see that that iteration
produce the result well anybody in this
room who is written code like this of
course right everybody has done it but
the real question is how do you feel how
do you feel after writing that code you
feel dirty don't you right you go home
at the end of the day and children run
towards you say don't touch me I gotta
go take a shower right so it feels like
that it feels like we've been really
doing dirty it's even worse for those of
us work from home because a kid runs
into the room you got 10 seconds to
close the monitor otherwise the kid
looks at this and says that's what you
do for a living right
so it becomes really hard why am I so
critical of this code will see why it is
in a minute but instead I'm going to
trade this with a lot better way of
writing so I'm going to say numbers dart
stream hey what in the world is the
stream well a stream is a very fancy
iterator in Java 8 stream essentially is
something that gives us an enormous
number of capability beyond what a
normal iterator gives a normal iterator
says well I got another element here you
go this is the element but this stream
is like on steroids it gives you
enormous number of capabilities one of
the things I'm going to do with the
stream is a perform an operation called
a math operation where I take an element
that's given to me and I'm going to
double that element in here so
essentially what we have done here is
rather than sitting and playing with the
iteration we are being more directive in
saying well given this collection
perform a transformation function we're
given five elements apply this function
on the five elements produce as many
results as the
number of import where each of the
output is a double of the respective
input so look at how communicated we are
in seeing what we want to do rather than
playing at a lower level about how to
actually do it and as a result now that
we have a mapping done the next step
here is to reduce this to a single value
and in this case I'm going to start with
initial value of 0 I'm going to start
with a carryover and element and show it
that I can perform a carryover and the
element addition over and over to
produce the result there are other forms
of reduced methods available but this
shows us the point about how we can
actually perform the so-called Map
Reduce kind of algorithms very easily
with the stream API so in a sense we
have done the same thing as the top one
but we have gained enormous Lee from
this example now if you look at the top
code this is called the decade the
imperative style of programming the
bottom one is called the Declaration
style of programming there are two
smells when it comes to imperative code
the first smell with imperative code is
mutability if you look at line number 8
we initialize the result to 0 but
unfortunately on line number 10 we
mutated the result over and over and
over if I turn up the volume of the
computer and run this code you will
literally hear the variable result say
out out out on line number 10 because we
are poking continuously at it on the
other hand if you look at the code below
there was no mutation no variable was
tortured in the making of the code in
the bottom as you can see it's pretty
humane as you can see so the point
really is we are not doing mutability in
code insta we are focused on really
immutable operations to get the result
the other advantage is in the imperative
code you are focused really on not just
what to do but how to do it in a way the
top code feels like you're talking to a
toddler suppose you are at home and you
want a cup of water
the toddler jumps up the under get the
water what you do immediately you got to
instruct
toddler every step of the way sweetie
walk slowly hold a cup with both of your
hands look where you are going and you
got to be very instructive on the other
hand the court below feels like you're
talking to an adult
well actually knowing some adults oh I
know let me rephrase it it feels like
you're talking to responsible adult
right so the point is that you say what
you want and you get the results really
quickly without really focusing on the
mechanics the house but you're able to
focus on just what to do so that is an
example between these two style of
programming the top code is also known
as pyramid of obsession because we are
focused on the lower level details
whereas the code in the bottom is a lot
more expressive as you can see in terms
of just saying what to do and that
becomes very very helpful but this goes
a step further beyond this as well and
in order to understand the further
benefit of this kind of programming with
lambdas let's move a little step further
with this let's change this collection
just a little bit I'm going to say 1 2 3
5 4 and then I'm going to say 6 over
here 7 and then let's say 8 9 and 10 so
I've got 10 values on my hand but notice
the order in which I wrote these values
I got 1 2 3 followed by a 5 and then a 4
and the rest of the values around it now
the problem I want to solve is this find
the double of the first even number that
is greater than 3 so it is a very simple
problem right find the double of the
first even number so it is an ordered
collection and the collection could be
anything we get the collection could be
coming in as we write the code not just
this collection of course but whatever
the collection is it's an ordered
collection we want to take the first
element double the value but only the
first element that's even and greater
than 3 so let's go ahead and write this
in the familiar imperative style
int result equal to 0 I want to output
the result so what should I do for int
element in numbers and in here I'm going
to say if the
element is greater than three and the
element Mart 2 is equal to zero then go
ahead and say result is equal to element
times two so right there is the code
what do you think is this good what
break wanna break we got only 20 more
minutes to go Oh breaking the code of
course
okay break what do you think is the code
good now notice you went from it doesn't
work do we're still thinking well that's
an example of imperative code imperative
code is one that lurks around waiting to
hurt you when you least expect now let's
say we finish this code and in good
faith what do programmers do when they
write code well guess what we run it and
I ran it and it said eight so yay it
works right what about three months goes
by you hear the knock on the door you
know who that is the tester walks in and
the tester says hey your code sucks what
do you tell the tester you say I know
don't tell me the obvious but tell me
how it sucks that's the part I don't
know right we always know record sucks
but the question is how does it suck
well the point is this cord sucks it's
got a problem in it but we won't talk
about it we will actually figure it out
by rewriting this code in a declarative
way so I'm going to go back to this code
I'm going to say numbers dart stream one
more time but notice this time what is
the problem statement say find the first
number greater than three so I'm going
to say given an element
give me an element greater than three
then find a first number which is even
so I'm going to say even and then do a
double of the element so e times two
but only find me the first element in
the collection and we can see that in
this particular case we rewrote it in a
more of a declaration style now if you
look at this code let's first run it and
see if it actually works so if I run
Scot notice we already see the result
and you probably say oh of course notice
it did not give us a eight it gave an
optional eight why because the given
collection may be empty the given
collection may not have a number greater
than three the given collection may not
have any even number at all
so the point really is when you run this
code I apologize for this being a little
too low here so if you run this code you
notice here that pretty much at this
time we have this code where the display
pretty much tells us that we have on our
hand optional rather than a real result
on our hand so the point really is that
we are able to run this code but know
that details pretty clearly it is very
transparent as you can see so optional 8
what does that really say it says that
there are times when there may not be a
value so the result is none now go back
to the previous code and see how we can
fix it now oftentimes you look at this
and say we can fix that we will change
this to integer and then we will set
this to null how do you feel right so
the point really is that we don't have
to go through that ceremony the code is
rather very revealing as you can see in
this particular case so that is an
example of how we can write this code in
a more of an imperative style so sorry a
decorated style rather than an
imperative style and that's basically
what we saw this also illustrates one
other really powerful capability on our
hand which is function composition so
when we start programming in Java 8 more
and more will employ function
composition all the way through we will
take a value and we would go through a
series of transformation of the data to
arrive at the result and that becomes
block more powerful so that you can see
is distinctively different from the code
we saw earlier where we had a loop but
we were continuously checking for stuff
inside the loop to
going on in one place not a good
separation of concern a coat that is
rather terse rather than being concise
whereas the scored is a lot more fluent
in terms of what it shows any quite you
please the word you're looking for is
unfamiliar right so so this is a very
common so I was in in Norway a few
months ago and people said exactly the
same thing and I said look at all your
street signs they look very complicated
and they looked at me and said do you
know Norwegian I said no not a bit
well the point really is this we don't
even give it this is human nature it's
not your fault even wired this way sorry
right so the point is this right when we
are comfortable with something it feels
normal to us and to a great extreme we
put up with complexity even though it is
not simple but once you get familiar
with it then we get to decide whether it
is simple or complex I'm not going to
say it's simple I'm not going to say
it's complex it is unfamiliar and we
cannot in its defence claim about its
simplicity or complexity until we get
familiarize with it what is your problem
a lot of things happen in the bottom
code well the question how do i D but I
don't write code with bugs so I can't
answer the question so this is another
thing that I want to emphasize most of
us are keen on knowing how to debug
let's rephrase the question how do I
test it rather than debug it right
well functional code is easier to test
why because it's got fewer moving parts
imperative code is really hard to test
because it leaks every corner of your
turn right so if we adopt the fairly
decent testing principle then it becomes
a lot easier to work with debugging wise
the complexity is not from the syntax we
see here the complexity actually comes
from something we haven't even talked
about yet if this was a very simple
sequential execution the way of debug is
exactly the way you debug code
now put a breakpoint and step in what is
a lambda expression it's an expression
with a function it just that you didn't
give a name for the function well what
does the code do it gives a name at the
level of the code so if you step into
the code it's going to have a name you
don't care about but you're going to see
exactly the code you wrote and you want
to step through it to debug so is it a
problem with debugging absolutely but
the problem is not where we think it is
we haven't gotten to that point at all
yet so it is quite natural right we look
at something very unfamiliar and we will
throw fits at it you will do it I will
do it why because that's our nature as
human beings but once we get past that
initial shock and you get used to it
remember the first time you probably
don't but remember the first time
somebody showed you polymorphism you
told them this is crazy stuff how do you
do up this because you call this
function it jumps anywhere you possibly
can I can deal with it what we call that
object under programming and we've dealt
with it for the past what thirty years
really well so the point really is it is
the unfamiliar and we got to get really
used to it any other questions please
Wow wonderful question I was waiting for
your question what about performance let
me rephrase what he said well sir what's
your name you I'm going to give you a
little job to do kay are you ready for
it
all right perfectly ready let's do it so
I want you to count the cost of this
code ready with me so notice we got one
two three five four six seven eight nine
and ten
that's ten values so we start with the
first value one and one is greater than
three no that's one expense bill greater
than three no three greater than three
no he is 5 greater than 3 yes he is 5
even though is 4 greater than 3 years is
4 even yes double the value of 4 how
much do we do 8 8 operations keep that
in mind right so 8 operations let's get
to this code we got a collection of 10
values we check if each of the value is
greater than 3 how many operations is
that
dead-on-arrival eight versus ten but
let's continue plus seven more for
checking even plus four more to double
the even values only that's about twenty
two operations so what he's saying is
okay this may look a lot cute but if
it's going to be a lot more expensive
are you out of your mind that's what
he's saying right well that's a really
good question well in order to
understand that I'm going to do
something a little different keep in
mind eight operations is what the
original code took the imperative code
but before we continue further let's do
something a little different and get
back to this I'm going to write a method
here the method I'm going to write here
is called boolean let's say e is greater
than three and I'm going to say in
number and in this case I'm going to say
return number over here and number is
greater than three let's say I'm going
to write a few more of these functions
for us to work with so in this case I'm
going to say is even and in this case
the even is going to basically say mod 2
is equal to zero and then finally I'm
going to say this is going to be
returning an integer we'll call it
double it and that's going to simply say
it number times two well I'm going to
use these functions here so what I'm
going to do is simply say sample is
greater than three and change this part
to sample let's say is even and finally
we'll change this to sample double it
shouldn't change anything except use a
bit of a convenience on my hand well
let's talk about the performance now I
forgot to mention one thing about
screams streams share a characteristics
I've seen them on my children they both
are lazy to the bone so my children are
having fun fighting with each other I
say hey guys are having too much fun are
you done with your homework yes daddy
how did it go wonderful for any problem
nothing at all can I see it sure and
they disappeared right so the point
really is in this code you go to the
stream and say stream filter done filter
done
map done find first oh dear let's do
some work now so in other words stream
has two sets of operations intermediate
operations and terminal operations so if
you look at this code even though it
produced this result these are not done
in our human eyes like the way we think
it is that's where the complexity I
talked about comes in this is where
what's called a fusion happens the
highlighted three functions are called
intermediate functions Stream
automatically fuses these three into one
ball of a function and applies them
exactly at most one time not exactly at
most one time on every given element so
if you notice in this example if I go
back to this code and if I output over
here is greater than 3/4 and say number
and similarly let's say is even for
number here and then finally over here
I'm gonna say double it for number and
I'm going to print those three now
notice what actually happens in this
code when it runs this code notice the
number of operations that actually
performed is exactly back to the same
eight so you got a best of both words on
your hand the code is more expressive
easier to understand easier to read once
you get comfortable with it but
performance wise it did not take any
more effort than the other code dead
because it does exactly eight steps as
well so what really happened rather than
creating collections and then creating
collections and then creating
collections it ended up only working
through every object just once at most
once so in other words it goes through
the filter for our operation and filter
another filter and map and checks would
find first are you happy if even it gets
up to that point if it the minute it
gets to the first fine first the
terminal operation it says we are done
no need to work any more and notice that
it never considered elements past four
in this example so six
seven eight nine and ten or any number
of elements after that we're never
evaluated now granted this depends on
the collection and the type of operation
we are performing but you can see that
the laziness is built into streams
already and that as a result we're not
expending the effort to recreate
collections after collections of your
collections it is extremely efficient in
terms of performance so we can get the
best of both worlds on our hand now this
gives us quite a bit of support as you
can see the lazy evaluation is baked
into streams in Java age and as a result
we not only can write code that is more
expressive we can also get good
performance out of the code as well as a
double bonus this opens up doors for
several interesting things as we're
going to see here what are the very
first benefits is code clarity and what
is the chord clarity the code begins to
read like the problem statement and what
does that mean if you had a loop with
several if conditions in it and our
domain experts comes to you and says
what is the score do you normally say so
don't quietly that's what I'm trying to
figure out right whereas in this case
the code begins to read like the problem
statement given a collection only take
greater than three only take even
numbers double the values but I only
care about the first one right so we
stack up operations rather than being
twisted through iterations it nicely
stacks up which means you can insert new
rules and remove rules more conveniently
rather than trying to mess with a
complicated code structure so it nicely
is modular as we can see the code also
has fewer errors what is the reason for
fewer errors because we are avoiding
mutability in code and mutability often
leads to more errors in code but this
also leads to easy parallelization as we
will see in the next example so let's
look at one other example here of what
we can do with this so let's say for a
minute we are interested in working with
a group of stock symbols and we want to
do certain operation well what do we
want to do so display
the stock price for the largest you know
stock in the following list but where
the value is less than let's say five
hundred dollars so the condition is
we're not interested in stocks that are
more than five hundred but of all the
values less than five hundred we want
the highest stock from where ticker
start symbols so I've got a little
tickers with a few symbols on my hand
and there are a few stocks like that
about twenty of them and I want the
prices out of them let's write this in
the imperative style that we are all
used to then we will come back and
refactor that so let's first say time it
dart code and I want to know how much
time this code is taking while we are
doing it we call it find imperative for
a minute and we will just call this
particular function as such so let's say
find imperative and what do I do within
this code
well right now I'm not doing anything so
it shouldn't take a whole lot of time to
do it and you can see it's displaying
the time for that particular computation
but what I want to do here is first of
all I'm going to say a list of stock
info we'll call it stocks equals and you
are a list so we are creating an empty
list of stock symbols well what is the
stock info after all it is nothing but a
POJO
we have a ticker and a price value which
are public via fields as you can see in
this case and then I have a stock info
constructor that just initializes those
fields and the to string method simply
prints the value out as you can see
nothing else in the stock info what am I
going to do with this now I'm going to
say is for string so let's call it as
symbol and this is going to come from
ticker start symbols and I'm going to
loop through and say stocks dot add well
what are we going to add stock util dot
get prized and I'm going to specify the
symbol that I have on my hand well let's
take a look at the stock you dill and
see what it does the get price method
makes a request to Yahoo Finance and
asks for the price of a stock once you
give it a ticker symbol I won't show you
what get Yahoo Finance get price does it
simply parses the result from a web
service call you can take a look at it
when you download the code but it
produces that and puts it into a stock
info object and returns the stock info
to us and I simply added that to this
collection as you can see now what do we
have on our hand we got a list of all
the stock prices on our hand the next
step here is going to be list of stock
info and I'll call it as talks less than
500 equals new ArrayList
one more time and this time I'm going to
say for stock info we'll call it stock
again but this comes from stocks itself
and then I say if the given stock so
stock you do and we'll call it as is
price less than 500 so this particular
function we'll see what it does in a
second and I'm going to give him a stock
if that were true then I say stocks less
than 500 dot add and I'm going to simply
add the stock to it let's quickly take a
look at the East price less than 500
function this function this method takes
a price as a parameter but notice it
returns a functional interface called
predicate a predicate simply evaluates a
true or false and returns a boolean
result in this case the evaluation is
based on the price value of the stock to
the price value we are interested in
which is a value 503 are passing in so
as a result you can see in this case we
have received the price tested for it if
the stock qualifies we added to the
second collection well let's go one
other step further we're going to
specify one other variable here we will
write this as a private static we'll
call it as stock info we'll call it
dummy for a minute equals new stock info
no name and a zero point zero so this
serves as an initial value for us to use
so I'm going to say here stock info hi
prized equals new stock price which is
dummy then I look through one more time
so we'll say stock info and we will take
a stock on our hand but this time it
comes from the stocks less than 500 and
I'm going to say high priced equal stock
yudo and we will say pick high among the
stock that we have on our hand and the
high priced we have computed so far so
if you look at the code here the pick
high takes two stock info as a parameter
and returns one of them which oh it is
the highest price in value so given all
of this what did we do so far we let's
go over the code one more time before we
run this we started with the list of
ticker symbols given to us we found out
all the prices for all the symbols and
then we took from there to finding the
stocks less than 500 and then we went on
to picking the highest priced stock
information from it so if I go back and
run this code this is going to go to
Yahoo get all these price values compute
these operations while this is running
let's talk about what did we really do
we went from a list of stock stock
symbols to list of prices then from the
list of prices to a list of prices less
than 500 and then from there to a single
value which is high well we normally
wouldn't write code like that we would
instead merge all the three loops into
one loop right well what is the good
thing about one loop it is one loop we
just write one loop everything happens
in there well the court would become a
little ugly and hard to read but that's
not a problem we only write code we
never read it anyways so we could just
leave it at that and walk away right
well we could write code like that
absolutely but let's take a note of what
we are dealing with here of all the
prices we have those less than 500
dollars it turns out Amazon is the
highest price among those three hundred
twenty three dollars and 21 cents keep
that in mind
and it took about 25 seconds for this
code to run but let's go ahead and write
this in decorative style and see how
it's going to feel so let's go back and
write this as a code again we will time
it but this time I'm going to call it as
find in this case we'll call it
functional and we're going to pass
ticker start symbols over to it let's go
ahead and implement the functional
version of this so static void I'm going
to say find the functional it takes a
stream of strings as a parameter will
call it as symbols for now and what is
the stream
well stream is the API in Java 8 that
gives the magic of streams so I'm going
to say stream darts cream here so what
are we going to do with the stream
that's given to us well I need your help
let's go ahead and do it together so I'm
going to output but what are we going to
output here well given the symbols I
have all the stock symbols on my hand
but I want all the prices what function
would I used for that that's correct
I heard the word map somebody said that
here thank you
map and what would I say stock you do
and this is going to be get price isn't
it so we can use the method reference in
a very expressive way so what are we
saying if we know what a map means what
are we saying here
we'll apply the mapping take each of the
stock symbols and give me all the prices
on my hand well this is all the stock
prices but I only want prices less than
500 what function would I use for that a
filter absolutely are absolutely on
target filter stock util dot is price
less than 500 well guess what is
priceless than 500 returned a predicate
and guess what filter wants a predicate
that's marriage made in heaven so you
can just pass that filter over 200 over
to it well the last thing is now we got
a collection of all the prices that are
less than 500 but we want only
one of those prices what method could be
used for that well let me give you a
different question for that little quiz
salt is - pepper a SMAP is to reduce
that's right I like the game we are
playing here so dot reduce right so you
said reduce and what are we going to say
at that point
well dummy is the initial value stock
you tell and peak high is the function I
would like to call so let's go ahead and
run this version of the code and see
what this code is actually going to do
well in this case of course I want the
pass to this function find functional
I'm going to pass the stream of this
code so I'm going to pass a stream over
here so when I run this code this is
decorative in nature it is still
sequential in nature not any different
from the performance of what we saw
before I'm of course talking through my
wireless network sometimes the wireless
network can go berserk but assuming it
holds to the same performance in terms
of network connectivity the performance
should be not any different what was it
25 seconds almost if I'm not mistaken so
it should be in the same ballpark the
stock price was three hundred twenty
three dollars and 21 cents I got a sad
news for you just because you write
functional code you don't get better
stock prices it is exactly the same
stock price what about the time about
the same right 25 seconds so no big
difference at all in terms of
performance or the result we got however
we load a lot less code even if he had
merged the three into one loop this
would be a lot less code isn't it why
because it is very expressive you are
saying given these collection get me all
the prices pick the ones less than 500
and get me the highest price so you're
stacking up really nicely now you look
at all of this and say okay this is all
good we got the benefits we talked about
so far but is that all the benefit well
there is yet another benefit to this
code which we cannot ignore let's go
back to this sequential code which is
imperative for a minute it doesn't
really matter whether you have to
the three loops are you merge them into
one loop it doesn't matter the
discussion holds for both of those if
you had the one loop or the three loop
it is imperative in style notice what
you're doing within this loop you are
constantly updating a collection or
you're constantly updating a single
value right if it was a collection
you're putting elements into the
collection if the single value you're
replacing the single value over and over
now we know one thing very clearly that
code is easy to write sequentially but
the minute we talk about concurrency all
bets are off
well let's say we wrote the code
sequentially using imperative style like
the way we did about a few months goes
by you hear the knock on the door the
tester walks in and the tester says we
got a problem here I tried with a large
number of stocks and application is very
slow we got to make it faster so now
you're spending time how do we make this
faster you are struggling with it when
one of your colleagues certainly says
I've got a bright idea immediately
you're nervous you say what's your idea
well your colleague says remember how we
have multi-core processors we could use
multi-threading immediately your mind
raises back to the previous job that you
had remember that job you had a job
where everybody was smiling at each
other when you went to work it was a
nice place to work with for with right
people to work with but then one day
they decided to use multi-threading so
you introduce threads and then what
happened the code no longer looked the
same it turned into a monster
and it did not work anymore you went to
work every day to debug remember that
and as you spend hours and hours and
hours debugging you finally decided this
is not worth it
so while debugging you apply for the
next job
that's called concurrency right well
that's called concurrency right now
you're like I have none other that's
that well why
I did that turn into a monster because
the code structure is fundamentally
different between sequential and
concurrent code but what if it's not
what if you don't have to change the
code at all to go from sequence you look
on current so notice the fine functional
code we are saying hey go get all the
stock prices pick the ones that's then
500 and pick the high guess what we did
here we told it what to do guess what we
did not say here how to do it so as a
result you could say over here go ahead
and do this for me please and you don't
have to change what you do because
you're doing exactly what you wanted to
do but in this case you just told them
just do it a little faster right that's
all we did so in this example as you can
see what we did here was of course the
network it shouldn't be this low but you
can see at least it's already faster but
hopefully it'll be a lot more faster and
the point really is we right there so we
went from a sequential execution to a
concurrent execution and all that we had
to do for that was simply change the
word stream to parallel stream
notice how we did not change what we're
doing but we did change how we are doing
it and I call this the master switch of
concurrency and the reason I call that
the master switch of concurrency is you
are the boss you know when to use
concurrency and when not to use
concurrency if the problem size is very
small it's foolish to use concurrency
you'll be trashing starting threads then
getting real work done if the code is
the algorithm or the problem task is
very very short
it is foolish to use concurrency because
once again you'll be spinning threads
only for the threads to finish too early
more overhead is spent in spinning
threads than getting real work done but
who knows this you do because you are
the one writing the code when the code
is executed you can check the problem
size you can check the logic and say do
I
concurrency now or not so you can flip a
master switch and say I want concurrency
now where says I don't want concurrency
now and you can vary that as you please
but with that one switch you can go from
a sequential mode to a turbo mode and
back as you feel fit now of course this
didn't come for free it came from the
fact that we followed certain good
things which is we followed the
decorative style
we followed the functional hygiene we
didn't sneak around and manipulate
global State if you start modifying
global variables from within your lambda
expression that is called evil
programming and that doesn't help us
write all kinds of problems we'll arab
if you're lucky you get the error if
you're not lucky your program fails when
you do an important demo so the point
really is that you still need to follow
a good functional hygiene when it comes
to writing this code but if we do that
we can see how this can take us to a
very different way of writing code so to
summarize what we talked about so far we
have lambda expressions in Java 8 but
lambda expressions itself doesn't fly it
works with a lot of other things that
have been packed in here with all this
given to us we can fundamentally write
code that is a lot more easier to
understand once we get familiar with it
easier to understand easier to maintain
easier to work with easier to optimize
as you can see and also easier to really
make it more efficient in terms of
parallelism as well however even though
there is a new set of syntax available
in the language I'm going to end by
saying the biggest change in Java 8e is
still in the minds of the programmers
and that's what makes this a lot a lot
fun I hope you found this useful thank
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>