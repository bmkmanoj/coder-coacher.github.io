<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Art of Simplicity | Coder Coacher - Coaching Coders</title><meta content="The Art of Simplicity - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Art of Simplicity</b></h2><h5 class="post__date">2018-04-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/AKwYmCnYD8c" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">excellent well thanks for the option to
speak here I want to talk about
something that we deal with every single
day well what we do at work is
constantly fight problem solving with
complexity so I want to talk a little
bit about complexity and how we could
possibly make things a bit simple and to
make things really manageable so that's
what I'm gonna focus on today well right
here in this room we have probably one
of the most complex things ever and that
is our human brain we are incredibly
smart we are innovative but at the same
time we get tangled up with emotions
we don't really think clearly a lot of
times and then clarity eventually
emerges out but after a lot of struggle
so why do things get really so complex
what's really hurting us in terms of how
we can do better and in terms of that a
lot of times when I spend time with my
children we talk about various things
and oftentimes the conversation becomes
you know into science and physics and we
talk about Schrodinger's cat well
shooting their head this mental
experiment he said what if a cat is
sailed into this box you cannot see
through it and he said that any given
time the cat may be alive and they are
and dead at the same time well takes a
lot of time to Reason through things and
I feel like a lot of things in life are
like the Schrodinger's cat well when it
comes to complexity we deal with
confusion she has said life is really
simple but we insist on making it really
complicated so I want to ask the
question why do we really make things
complex but I think I have a reason that
we do and the reason is it feels really
good we have to be honest about it isn't
it well if you build something and your
colleagues look at it and they say gosh
that's simple you maybe feel a little
let down you say let me come back
tomorrow we'll be working on this and we
want to give the impression that what we
have done is important and to do that we
often make things a little bit more
cluttered and complex sometimes
complexity cells if things are simple
maybe we feel like it doesn't have any
value
so we have to really fight the tendency
quite a bit well it turns out I'm ten
actually said and in any intelligent
fool can make things bigger more complex
and more violent it takes a touch of
genius and a lot of courage to move in
the opposite direction
oh and underline a few words here that
are extremely important and that is a
lot of courage and that is what I think
is one of the biggest challenges that we
have to face if you come up with
something really simple sometimes you
get ridiculed about it sometimes we get
critiqued by colleagues and it actually
takes a lot of courage to stand up and
say I don't need to make this really
complex here is a simple solution to
this problem that actually works why do
we want to really make this more complex
than it should be do you have that
courage is extremely important well if
simple we're sitting next to you in a in
a train would you even know that this is
simple and that is one of the things I
often find as a challenge I think almost
every single developer you come across
with would agree to the fact that we
have to make things simple so the
problem is not that we are in
disagreement about making things simple
the problem really is identifying what
that simple really means I remember
working the group of developers I was
constantly complaining that a particular
piece of code was extremely complex
after about a few minutes of me
complaining one of the developers said
hey man kid I just want to speak up for
the group you keep saying it's complex
but we collectively think this is simple
and I said well how could you think this
is simple when it's clear it's complex
can you tell me why you think it is
simple and the developer said yeah
because all we are doing in this code is
use a very simple FL statement and
that's when it dawned on me a lot of us
don't know what complexity really means
well I pointed out the problem is not
that they used an if-else statement the
problem the complexity came from that
being repeated seventy times in this
code and that that code being copied and
pasted countless number of times
throughout the application which means
every time they had to extend the
application they had to spend a lot of
time and effort changing every piece
of code that made the decision and the
complexity blew from the violation the
try principle in this particular case so
we have to really ask the question how
do we really even recognize this and do
it well unfortunately though it's really
hard to tell what simple errs as we have
understood maybe I can take an opposite
approach maybe I can try to say what is
not simple and maybe we can recognize
that and avoid so let me take an attempt
to that so what is not simple well
simple is not clever how many times have
you written a clever piece of code we
all have done that isn't it well why do
we create clever code because it feels
like our solution is worthwhile when we
make things really clever and that
becomes really problem after a while
after all well let's take a look at this
example here for a minute
public abstract class enum e extends
enum e just think about that for a
minute oh that noise you just heard is
your brain throwing an exception that's
when complexity kind of broods over
things and these are not very simple
things for us to understand we kind of
stare at it and say hey what does that
mean really well you know people often
say how do i office get my code and I
often tell people why do you want to
obfuscate your code your programmers
write naturally right self office gated
code even they cannot understand it
after a week of programming so the point
really is we don't really need to really
take the effort officer gate code we
want to really move in the opposite
direction well as it turns out I came
across this piece of code notice that
float X in all honesty I don't have a
clue what X means but whatever X is I've
got good news for you we now have half
of it and then of course don't tell me
you don't understand this code right
because it's so beautifully done and
then when you read all this code you're
wondering but I got some really good
news with this code at the end it
returns X so the point really is how do
you really maintain code like this when
all these become extremely cryptic for
us to deal with
oh remember how we are told often that
when we work with things that the
alternative programming models the real
world well we have to be very careful
with those statements like this one
developer took you to the heart and
wanted to really create an example of a
program that modeled flights and he
created something along these lines my
question is where were the other
developers well this guy was writing the
code somebody should have said dude
don't go there please don't do this to
us right and that becomes really hard
for us to maintain over time and that
becomes unbelievably complex for us to
deal with so complexity comes in several
forms but one of them is cleverness we
want to make things very clever and we
get trapped in the process after all
well the next thing I want to say is
simplicity is not necessarily familiar
we often confuse the word simple with
the word familiar familiar is what we
are used to familiar is something we
have seen a thousand times over and may
not really care to see it again and
sometimes we have this comfort that we
begin to feel what is familiar is
actually simple but the evidence is
actually to the opposite well let's
think about this for a bit if I ask you
what is this some people in the room may
be able to answer other people are going
to look at this and say oh my gosh that
looks very complex well it turns out
this actually is not that complex at all
in fact it is saying simple
uncomplicated casual and common you may
ask how did I know it I just use the
translator but the point really is that
we often get confused with things with
be unfamiliar with I travel them the
world I'm often in places where I don't
speak the local language it'll be pretty
naive of me to turn around and say
everything around me is complex it is
just that I need to recognize everything
around me is unfamiliar to me I always
keep asking this question to my
developers is this something that's
really complex or are you just telling
me you are unfamiliar with it one is
easier to solve the other
one is really hard to solve we don't
want to deal with unnecessary complexity
but we have to remove the unfamiliarity
about things quite often let's take a
very simple example here just to get a
feel for it let's say what I want to do
is take all the values here and I want
to let's say total the double of even
numbers in this collection how would I
do this
first of all I'll say total equal to 0
well I want to of course output the
value when I'm done with this but what
am I going to do in between I'd say for
int I equal to 0 and then what do you do
then you say I less than well in this
case price is Dart well if I take the
prices value what do we call after this
is it length is it sighs is it count we
have to make a decision to that point if
it's an array it's a length otherwise
it's a size but then of course you stop
and ask the question is it less than or
less than or equal to do you ever ask
that question every single time the only
purpose of code like this is to make us
feel really stupid because we get scared
when you look at it what if I make a
wrong decision with this and then to add
complexity we have to write that as well
then what do you do then you have of
course have to say if I came to add
insult to injury you say get the element
of that and then I could say is Mar 2 is
equal to 0 and then of course you can
say total plus equal to maybe the price
value look at all the complexity we get
dragged into well I call these as
accidental complexity and the reason I
call these accidental complexity is this
is not a complicity complexity that came
from the problem it's a complexity that
came from the solution we choose to use
and a lot of times we get dragged into
complexity like this make no mistake a
lot of us are very familiar with the
style of programming it is called the
imperative style of programming I grew
up as a kid programming imperatively
what I'm trying to say you know all
those words says I had a terrible
childhood this was really complex things
to deal with but
don't have to deal with so much
complexity after all we could try to do
this very differently let's give it a
try maybe slightly different way to do
this what if we started out by saying in
this particular example let's start with
prices as we did right now but then we
will say given the prices will go
through an internal iterator we will
filter out given a price I want to say
price Martu is equal to 0 for example
then perform a map operation over here
and then in this case of course I'd say
given a price maybe I want to double the
value over here and then maybe I'll
perform a sum operation in the very end
of this to perform the result of that
particular operation and compute it well
as you can see in here I even forgot to
double the value in the mess that I was
creating but the point really is the
code can become a lot more easier to
understand easier to follow we can have
a beautiful flow of the data through it
we call these the functional pipeline
well a lot of us are unfamiliar with the
details of functional programming but
one in I took a long time to really
figure out how to really use it but once
we become familiar with it we begin to
realize it's actually less complex
compared to the imperative style of
programming so on one hand what we are
very familiar with turns out to be
really complex on the other hand what we
are not so familiar with may turn out to
be actually simple in the long run so
the question to ask is are we unfamiliar
with things that are maybe simpler than
maybe familiar with things that actually
are complex so don't confuse familiarity
with simplicity so a lot of us are
familiar with the imperative style of
programming but declarative is a lot
more simpler and so what does it really
mean what simple has fewer moving parts
in it and and Michael feathers once a
tweeted I thought this was a brilliant
way to express it he said that in
object-oriented programming we
encapsulate the moving parts in
functional programming we illuminate the
moving parts that's a really brilliant
way to think about it because we want to
eliminate that complexity rather than
capsulated because when he encapsulated
its waiting to come back to bother you
when you get rid of it it cannot trouble
you anymore well simple is not
over-engineered we come across solutions
like this all the time for example well
Rube Goldberg made is maimed by creating
very complex solutions for simple
problems like for example coming up with
this very complex automatic back
scratcher but if you really think about
it a lot of us have done this at work
for our own projects I remember working
on a project where the developer had
taken a data from a database and gone
through 250 lines of code to transform
it into XML and then passes that down to
another function and that function
parses the XML performs a very small
operation and stick the data back into
the database I'm scratching my head why
go from the dare to XML and XML to data
and I called the developer and said I'm
looking at this code and he said isn't
that cool like No why are we doing all
this work here he said because this code
is extensible I said extensible for what
he said ranked it you need to have a
vision I said I'm really sorry I don't
get it what mission am i lacking here
where does the data come from here what
does it go here then why are we going
around the world to get the data back
here he said no no no you should
understand the vision we should have in
developing software while I was saying
it I picked the phone and dialed it he
said excuse me and I picked in hello
hello I said is that you Venkat I said
yes
why are you calling me right when you're
in front of me I said you'd have a
vision I could be anywhere in the world
and talk to you now so we should always
talk on the phone even if we live near
to each other right well a lot of times
we get kind of carrier by complexity and
don't realize we got to really solve the
problem we really have on our hands and
not get carried away by it
what simple is not really terse I want
to write concise code but I don't want
to create a terse piece of code for
example I came across this code on a
client
and I was doing a code review for them
and we were going over code and we were
trying to improve some design and a
developer showed this you know brought
up this file and then quickly switched
over to another piece of code I said
okay excuse me
can you go back to that code you just
showed me this was a code in production
and he said sure and I looked at it said
would you mind if I take a photo of that
he said yeah absolutely go for it as
long as you promise never to tell who we
are to the world I promise and I took a
photo of it oh sorry what I wanted to
take a photo was not this line the line
that was below this this wasn't
production it said god help me have no
idea what this means and developers
write code like this can you imagine
working on a project where and I asked
them why didn't you remove this words he
said that's the last word of the
developer before he died right or quit
so so there's a little respect to the
person who wrote it this is how we feel
about it when we write code enormous
complexity not because the problem is
complex because we cast to it these are
called self-inflicted wound we create on
ourselves and so here's an example of a
code where I'm using a very verbose test
to write I have a set price and I have a
max profit and I have a fail I have a
catch
guards it's a lot of code to write we
should do better than this well it turns
out this isn't verbosity how do we make
it really concise I would argue this
solution from J unit 3 &amp;amp; 4 is a terrible
idea and the reason it's a terrible idea
is notice that while this says I want
this exception it doesn't tell you which
line actually caused the exception I
never want a test to fail pass rather
for the wrong reason and I would argue
this is not a concise code it's a terse
piece of code so what is the difference
between terse and concise both terms and
concise are really small but thirst is
waiting to hurt you when you least
expect it so I want the code to be
concise and not curse so I would rather
read write it using a Landis this is
what a unit 5 provides for you in
concept artists and so here you can wrap
that code in the lambda expression and
say I want
that piece of code to fail not anything
else and this is concise and
communicating the intent very clearly as
you can see so we don't want the code to
be terse after all so don't confuse
sturdiness with concise and simple as
well well here's a beautiful code by
Toni her he says there are two ways of
constructing a software design one way
used to make it so simple that there are
obviously no deficiencies and the other
must make to make it more so complicated
that there are no obvious deficiencies
and we deal with this a lot of times we
don't even know what's broken in a piece
of code I remember working on a project
as I was going through the code I found
there was one variable totally
unprotected from concurrent axis I went
to the team and I said excuse me I'm
looking at this variable it's totally
unprotected are we not gonna have
concurrency issues with it and the
minute I said this one of the developers
got very angry and said hey Rankin this
code has been in production for three
years what makes you think you can come
and scare us today I don't know how to
answer that question but thankfully I
didn't have to because before I could
say anything one of the other developers
said aha but wait a minute remember
however a code crashes every two weeks
and we have no clue why it does so
sometimes we kind of deal with issues
don't even know where the problem could
be potentially well okay so I talked
about a few things that are signs of not
being simple but it's only fair that we
talk about what is simple though we said
simple is not clever simple it's not
necessarily familiar simple is not curse
simple is not over-engineered but okay
this is all what it is not but how about
talking a little bit about what it might
be well let's take an effort simple
keeps you focused what is the most
valuable thing in the world today in the
world we live in with tweets and
Facebook feeds and everything around us
do constantly distract us I think it is
our attention if a code can keep us at
our attention that is wonderful if a
code is not keeping our attention we
a way to do other things and the problem
is still at hand and the solution is
still away from us so we want to really
help to keep things focused
let's talk about this a little bit let's
say for a minute you and I are
programming we're not quite sure what
Java API to use and we're not even sure
how we would approach a problem what do
we do in this today's world you don't
get paid to take seven days to solve a
problem that every other person has
solved already so you may tell me when
you're going to just quickly do a search
fair enough why don't we do a quick
search to find out the solution to our
problem well I'm going to go ahead and
bring up the browser to do a search
right away and the minute I go here hey
interesting what does it say here oh
look at that there's some really
interesting news up here about various
things happening mm-hmm
even about Los Angeles here they're
talking about some brilliant company
well you know where I'm going with this
the minute I went there I got completely
hijacked with these stories and 20
minutes later on life what am I trying
to solve again and I completely got
hijacked with the process this to me is
unbelievable amount of distraction
that's out there what I came here for is
that little box but what I did got
distracted about is all these wonderful
things that are obscure interesting
things no doubt about it let's try this
one more time if you will so let's go
ahead and quit that hey let's do a
search over here what a beautiful
picture over there I am not sure what
that picture is I want to search for it
but I'm a little anxious about it what
if it recursively end up with yet
another cute picture 20 minutes later
what was I trying to do a search let me
try this one more time let's try this
again I'm gonna search what can I do at
this point
search there is not a whole lot else I
can do how many of us use Google here
there's a reason for it right because
you care about your time and I want you
to think about this for a minute just
close your eyes and imagine this let's
get convinced this as easy remember what
Einstein said it takes up that a genius
and a lot of courage can you imagine the
day when this developer went to his boss
and said I've got the search page
working let's see it
here you go and the boss said what the
heck is this well it's a search page I
see it what what there's nothing here
well I put a button call I feel lucky
well you should do you think how many of
us work in companies where you can
present that kind of simplicity and get
away with it very difficult isn't it
because the minute you present something
people say show me something more I want
something here this is too simple but
the simplicity is the genius here let's
make no mistake the minute you click on
that but even if you before you click on
that button there is enormous amount of
complexity behind that button several
servers and algorithms and data
structures and processors are running
behind it but they didn't bring that
complexity to us and say you suffer with
it we don't have to be distracted
simplicity is the essence this is one of
the reasons why I love pair programming
honestly why if I'm sitting alone
there's a beautiful statement called
shaving the Yak shaving the Yak simply
means you're not solving the problem
you're working on you're solving a meta
problem we all do that that is in us if
you're not sharing yak you are not a
developer we all just shave yaks just
don't talk about it and if I'm alone and
programming I bring up the browser and
the browser says would you like to
upgrade oh yes of course click on it
next thing you get a proxy error 20
minutes later you are fighting something
deep down here and the boss comes to the
class and opens the clause and says
excuse me what are you doing here in the
closet oh I wanted to search for this
Java API I turn on the browser it told
me do you want to install the upgrade I
click
on the button got a proxy error and
everything is wake after this and
suddenly I don't know why I'm in the
class they're shaving the yak right now
and this we get dragged into quite often
well let Syria pray prope programming
you're sitting it's somebody and you're
coding with them and you say that your
colleague says why did you just search
for it you blink the browser it says
would you like to upgrade and the and
the colleague says mmm and so like oh
never mind not now you so many acts are
being shared for that after afternoon
isn't it a point really is it keeps of
our focus to do what we want to do
rather than getting dragged into
something we shouldn't be focusing on at
the moment so the point really is
perfection is achieved not when there is
nothing more to add but when there is
nothing left to you take away what a
beautiful court I remind myself of this
every single day it is not what I can
add but what I can remove that really
makes things simple this is to me the
key behind refactoring i refactor a
piece of code not to add stuff but to
remove the clutter how can I make this
piece of code continue to work when it
can have fewer elements in it when it
can have fewer things in it and still it
can serve the need it does to remove all
that complexity that is in front of me
to make it really simple well simple
eliminates accidental complexity and
hinds inherent complexity so we are
dealing with complexity two types of
complexity one is inherent to the
problem the other is accidental to what
we do and simple fails a lot less if I
ask you the question why is this cover
circle in shape I think most of us would
give us the reason immediately and the
reason is it doesn't fall in well here's
the question to ask yes it doesn't it
well it doesn't fall in that's great
that's a good answer
I'm not saying it's not but if I came to
you with a request to create something
that doesn't fall end
how many of us will create it especially
if you're a consultant getting paid by
the complexity that you create I'm one
of them how would you really create this
it turns out here are the solutions that
also qualify for that and we would have
made more money creating one of these
shapes and all of them qualify they
don't fall in well it turns out there is
a year yet another important benefit of
this design not just it doesn't fall in
it doesn't matter how you roll that on
that imagine you are the dude who is
coming out of it and then a tank the
very long day you're trying to put the
lid on while your colleagues are waiting
hey what are you doing trying to see how
to fit this in just show the damn thing
over let's go home
he's a beautiful solution to have so the
point really is it is not just it
doesn't fall in but it is very easy to
use its intuitive and it fails less and
that is something we need to really keep
in mind as an example though it's been
quite a while long time ago I remember
this weird experience when my child was
very small in the middle of the night
your wife wakes you up and says could
you please please go get the bottle for
the kid and you're about absolutely half
asleep your eyes could barely be open
and your problem at that point is to fit
the bottle with the lid i remember the
saying this sounds like an np-hard
problem to me right now right trying to
fit that in that is complexity you have
to deal with which is completely
unnecessary and we see this in every
aspect of life when things become
incredibly hard to do so simple is
easier to understand and easier to work
with that is a nature of simplicity as
well so here's an example let's say I
want to find if a number is a prime
number what if I can do something like
this is prime and return number is
greater than 1 and a stream of data
where I can say none match and find if a
number is prime what if I can find all
prime numbers well what if I do
something like this prime given starting
at if the number is prime returned that
concatenated with everything following
otherwise skip it and return everything
following it ideally this would be great
but it doesn't work why not
because this leads to what's called an
infinite recursion and it blows up
eventually hmm great idea but hard to
implement or maybe we can try this a
little differently what if we can write
something like this stream dot eat away
and we can keep generating this lazily
and then we can limit to the number of
values we create well solutions which
are unfamiliar becomes enormous Li
beautiful to use once we figure out a
way to actually do it and that becomes a
very compelling way to organize it let
me explain how this really helps what we
do well simple is very elegant and well
what about elegance really means well we
need to really appreciate elegance in
quite a different number of ways to it
why is this the words famous painting
ever well the reason for that really is
that if you look at this picture it is
the most simple thing you could even
ever imagine there is not a whole lot
here there is no clutter there's no
ornaments there's nothing to distract
this is pure genius
as we call it and the man is genius not
because he created something complex the
man is a genius because he created
something beautiful elegant and simple
that's why we admire this I'm gonna talk
about what's called an architect's
dilemma I was in Boston and I was
walking through downtown Boston with my
family we were having a good time
enjoying the the city and I came across
one thing that just absolutely
mesmerized me and this is the Trinity
Church
I stood admiring the church until my
family said dad we have to move now are
we calling the cops on you and what was
so admired thing that admired me it just
took any other church isn't it oh this
is not the church I was admiring what I
was admiring is something very nearby
well next to the church there is a
building called Jane Hancock building
and when they wanted to construct this
building the city would not give
permission to build it and they said we
won't let you build it here because if
you build a tall building here the
beauty of this historic church will go
down so no and the architect of this
building said I'll take this challenge
when I finished this building the church
will only look more beautiful than it
does now without ever touching it so
what did he actually do he built the
building in a particular angle with
beautiful glass doors and my camera is
not doing the justice to this but I
stood there admiring the reflection of
the church on these classes telling
myself and everybody else around me
saying isn't that a stroke of genius
right there in the ability to really
reflect the church so beautifully that
you could just admire the church not
directly but through the reflection and
this again is very simple solution to a
problem at hand a lot of us cannot even
think about it and we're trying to fight
the solution when we can innovate
simplicity through it but it turns out
simple has to evolve let's make no
mistake we cannot sit down and create
something simple
nobody can in my opinion we kind of
create simple by evolving from various
things we do we have to take the time to
evolve it Richard Feynman said if you
cannot explain something to a first-year
student you haven't really understood it
this happens a lot in my own experience
I've seen this quite often when I try to
teach a course or write a book about a
certain concept I find it incredibly
hard to explain and at that point I step
back and say I know why it's hard to
explain because I created a monster I
have to simplify this before I even try
to explain it but Occam's razor says we
have two equally likable solutions to a
problem choose the simplest often I'll
share with you a personal experience
about it I was writing the book on Java
8 this was about a year to two years
before Java 8 was released and I was
very eager to write this book on Java 8
to sing its praises but I also wanted to
show some things in the book which are
really hard to do in Java but you could
really do with functional programming in
Java what
read some things before to prompt me to
do this here is an example of a
factorial and I can say if number is one
returned the number otherwise number
times factorial minus one well clearly
know this leads to a stack overflow
error because of an infinite recursion
when the number is very very large how
do we really solve this problem well
here's an idea I've read through some
interesting books and worked with some
languages one of my favorite books is
structure and interpretation of computer
programs in this book Sussman and
Sussman enabled sin
talk about two different things they
talked about procedure procedure is what
you write they talk about process
processes the code that runs after
compiling transformation stuff like that
if you write an iterative procedure it
runs as an iterative process if you
write a recursive procedure it runs as a
recursive process but the real power is
if you can write a recursive procedure
but in turn it runs as an iterative
process that is when we can get the
elegance of the code and the performance
at the same time so this kind of
optimization is done by several
compilers this being one of them
Erlang being another Haskell being a
third one a lot of functional
programming languages do this Scala does
this at the compiler level
so does closure gloomy does this to the
library level so when he sat down with
Java eight I said to myself
aha these languages do this in so many
ways
I know language like groovy does this at
the library level Scala does it at the
compiler level what if I can implement
tail call optimization in Java so in the
middle of writing this book I started
playing with tail call optimization not
a good thing to do when you're writing a
book I spent about two days of my life
doing nothing trying to implement tail
call optimization and here's what I came
up with further ten hours later I came
up with this solution while not complete
current equals current out apply call
complete is equal to current art East
complete just focus on this while loop
well the problem is this in the book
until the previous chapter I've
repeatedly told the programmers avoid
mutability and Here I am with the
beautiful solution to a complex problem
which is doing mutability and I was
stuck honestly and I said there stared
it for a day I could not know of a way
to remove this loop and the mutability
in it and I think I came up with a
brilliant solution to the problem and I
hope you will agree to what I did was I
wrote this in the book and I said dear
reader do you see that I'm using
mutability on this line number seven the
Prada the challenge to convert this code
to immunity is the left as an exercise
to the reader I thought this was a
really good solution honestly this would
have worked 30 years ago when we didn't
have the internet because I can hide
comfortably after writing a book today
we're on social media the minute this
goes to print somebody will tweet and
say oh yeah why don't you take the
challenge yourself and show me how
that's not going to work that is
rephrased it I said they're meaner do
you see me using mutability here
don't use mutability in every place you
can avoid it except places like this and
that really felt sick and I realized my
code just sucks I got to do something
different and honestly I said I don't
understand this maybe I will run into
one of my Java friends show them the
code and say what you think is there a
better solution
I said I'll wait for that then a couple
of days went by I moved on to write
other chapters and then I was on the
treadmill jogging as I was jogging on
the treadmill my mind completed detached
from the problem slowly I started
thinking about it and suddenly it dawned
on me I'm like oh my gosh I've been
looking at this problem wrong there's a
much simpler solution I never even
thought of it I jumped out of the
treadmill and ran across the floors of
my home with my children screaming are
you okay daddy I'm like no no you
understand it God this problem figured
out
ten minutes later I had the code working
so what did I do
well here's what I found out I can turn
the recursion problem into an infinite
stream problem just think about this for
a minute
what if I take every single function
call think of it as an object for a
minute then every function call is an
object then this object can form in a
collection it can form in an infinite
collection well all of a sudden when I
finish that Ackerson I curse and I say
give me the next recursion give me the
next recursion and I keep getting the
next recursive object to execute and and
the minute that you realized it the
solution is gone from complexity to
something simple with no mutability
stream that iterate the current call and
apply to get the next call keep going
until the problem is complete find the
first one
get me the result of it this is what
went into the book eventually well what
is cool about this though is it is a
lazy evaluation and an infinite sequence
it becomes incredibly easy once we
understand how to do these functional
mapping so a lot of times we struggle
with solutions maybe for days maybe for
even weeks sometimes the best time we
find solution is when you are away from
the computer when we are away from the
problem we are dealing with our mind
detaches and suddenly there's a click
and if somebody comes to you and says
how did you figure this out the normal
answer for that is a shrug I don't know
I just thought of it
and and maybe I say something you say
something I say something and you say
something I'm like oh wait that's
brilliant answer and you're like what
did I say then and they look at the
solution we come up with solutions that
way which is fantastic well Einstein
said everything should be made as simple
as possible but not simpler so always
wonder is my solution simple or maybe is
it complex I might think it is simple
right now you might look at it and say
why are you doing this here is an
alternative solution which is much
simpler and I'm like yeah
what you suggested is much simpler than
I thought about let's go with it and
this is a discovery that keeps happening
almost every single day it is not about
my solution versus your solution by the
way it is about working together to find
a simpler answer and sometimes you may
have a better answer sometimes I may
have it or sometimes both of us will
come together and realize a better
solution in the end so we have to work
continuously towards it so is the simple
or can it be simpler than this I'm gonna
say simplicity yeast like showing us
can't the solution we come up with a
simple and complex at the very same time
it is simpler than what we had before
maybe it's more complex than what we
will do moving forward simple makes
things easy but let's no me make mistake
simple is not easy at all to create it
takes a lot of effort to make things
really simple as da Vinci said well
simplicity is the ultimate
sophistication in life and every bit of
effort we put in to achieve that
simplicity in my opinion is worth it for
two reasons we make the current problem
at hand simpler we also gain the skills
we need to address complexity I would
say the very first thing we should do
really is to even have the sense of
complexity a lot of times we go through
for weeks and months sometimes and not
even realize that we are sitting in
front of something highly complex then
we should really so the very first step
is to develop that sense and the second
is to tirelessly work towards making
things simple and eventually not only we
make things simple we also develop the
skills to make things simple also in the
long run and I think that's pretty worth
it for what we do hope that was useful
glad to take any questions you may have
thank you
we got about two minutes delighted to
ask any answer any questions or comments
you may have please don't hesitate
thank you
hey there thank you for your talk that
was super informative and I'm in web
development so there's not a whole lot
that I can wrap my head around but I was
able to keep up because the points you
were driving home were really universal
to all coding and all programming so I
appreciate that thank you for like just
diluting it down so everyone can
understand thank you as a new program
are getting involved where do you think
like would be a good path to begin
that's a really important question and
I'm not saying this lightly one of the
things I think we should really take the
time as developers whether you're senior
are junior is to really implement a
fairly decent feedback loops I have
gained so much knowledge not because I'm
smart it's because there were kind
people around me who would look at what
I did and said you can do better
sometimes people say what if I'm wrong I
want to emphasize you're never wrong
you've just done something that could be
improved that's the way to look at it so
ask other people around you to review
what you do ask them to critique you as
them to give feedback and and knowledge
is a wealth that grows when when it's
given not only do you gain I bet you
they gain as well because when they look
at what you have done they begin to
think and realize there are better ways
to do and one of the things I admire at
young people today is they pick up so
many things that I may not have time to
pick up so in the process we both really
become better so I cannot emphasize
enough review mechanism is extremely
important we're not just doing it enough
in our industry we should do that if
you'd back loops are incredibly powerful
way to do this absolutely thank you
thank you you should absolutely thank
you just a quick question
premature optimization is a well-known
issue so I never come up with a simple
solution at the first so what do you use
to define if it's already time to
optimize or simplify versus that you
have to perfect the solution yet
probably dealing with more complex
issues right so that's that's a really
important question to ask when do we
begin to our
- my recommendation has when it is
complex clean keep cleaning it up to
make it simple however to me
optimization has to be driven by a
result not by a goal to optimize I think
that's where a lot of us fail we want
optimize the code and I always ask
people what are you expecting as a
result after your optimization or I want
to improve the performance can you tell
me what your current performance is I
don't know but I have to be fast is not
a good answer so set a goal a and second
see how your code performs to that goal
right now
third ensure that goal is really a true
goal I can optimize endlessly on a piece
of code if that has zero value for the
business I wasted my company's time and
my effort towards that optimization that
has no consequence so is the optimum is
the result relevant to the you know
business and finally the question is how
do we optimize given all these tests
that pass is the time to really look at
it so a very important question glad you
asked that but but we need to answer so
many questions before we can even sit
down to optimize and a lot of times it's
a foregone conclusion we can begin to
optimize even without considering it and
I think that's a bit of a disservice I
think that brings us to the end I'm out
of time but I'll be hanging around today
so if you have any questions I'll be
more than happy to talk to you along the
way thank you for coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>