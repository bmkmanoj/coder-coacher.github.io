<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Polyglot Enterprise Development on the JVM | Coder Coacher - Coaching Coders</title><meta content="Polyglot Enterprise Development on the JVM - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Polyglot Enterprise Development on the JVM</b></h2><h5 class="post__date">2015-06-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/on6_BUdVrns" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I don't know how many people have
ever seen mark littell so as far as you
know I am mark littell I'd like to
inform you that I'm not mark littell I'm
Tom edible unfortunately I never got a
doctorate I only have a bachelor's
degree so mark littell couldn't make it
unfortunately and I was nice enough to
help him out and do this talk today I
revamp the deck for my style and my
knowledge of this material and this
should be ok I've been a Java programmer
since the beginning I mean working on
JRuby since 2002 so I have a reasonable
amount of experience in the polyglot
world a lot of the people that you'll
see faces of towards the end of this
talk our people that are actually my
team at Red Hat's so I get a fair amount
of exposure to these projects but with
that said I haven't been a je programmer
in probably 10 years so I'm a little
rusty there but it'll be okay I promise
next thing I am also not a VP at Red Hat
so these opinions are going to be mine
as just a nerdy engineer who has
opinions in polyglot and not like
official red hat statements on polygon
programming and since I am so into Ruby
you'll notice i talk about Ruby a little
bit more most of these statements will
actually apply to other languages and
communities so I'm just going with what
I know a little bit to draw off of that
so I'm really not trying to brainwash
all of you to use Ruby use Ruby whatever
so I'm going to start out by talking
about why polyglots important um if you
just walked in out of the hallway
because you saw Polly go out what the
hell is this this section will be really
useful but I want to go beyond that just
a little bit be
cuz I want to talk about how polygraph
programming actually helps benefit you
even if you're not a polygraph
programmer then I want to go over some
of the goals I think would be important
for us in the jvm community to go and
help expand on poly God and most of the
talk will be surveys of various open
source projects where there are red hot
engineers working on it but their full
open source projects so with that in
mind I'll end it out with some
suggestions for how you can help work on
these projects so let's start with why
polyglots important well for starters we
have all been polyglot programmers for a
long time if you've ever written a web
application which I it's fair to say
everyone here has you use different
languages all the time they fit into
different boxes and those boxes feel so
natural and coarse grained that you
don't you don't really think about it a
little bit i'm going to talk about how
we should apply the same mentality
towards your internal application
architectures the other thing that's
happening is the amount of programs that
are being made just keep expanding
nearly exponentially in the number of
devices that we have to program keeps
expanding now most of these devices are
using different languages in different
environments and if you're not in a huge
company you're probably actually having
to write both the client side and the
server side polygons been really
successful recently on the JVM for
trying to kill the java programming
language monoculture i program in java
everyday I like Java but it's absolutely
horrible at solving some problems the
most famous example is concurrency you
know using low-level thread primitives
creating your own threads having mutexes
dealing with bugs um when a concurrency
bug comes in to JRuby I just going to
hide under up bad I hate debugging this
stuff and I think the reason is because
this is too low level and this is too
difficult here's a picture of Stewart
Halloway he became enamored with closure
probably about four years ago and now he
makes these little quickie jokes and
he's thinking about these problems a lot
differently because of his exposure to
closure and so what we need to take away
from this is we need to start using the
best tools for the job here's an example
of taking your existing architecture and
trying to figure out which logical
pieces are made up I stole this from a
scala book but if you want to have a
nice configuration syntax you can use
Ruby or groovy to make a nice dsl if you
have a concurrent problem instead of
doing new thread you can go and you
Scala and use the haka framework and
then you're now using a much higher
level abstraction for for dealing with
concurrency closure in an in and of
itself encourages immutability and when
you do actually have mutable state they
either encouraged software transactional
memory or at least e-marketing
transactions and you can see that java's
still down there Java is still very
important but you know you've got to
start looking at your architecture and
start thinking is there another language
that exists on the JVM or another
framework on that language that is going
to solve the problem in a fundamentally
different way than what you do in Java
the other thing I like on this
particular topic is Ola beanie he's not
so much a Jay Ruby contributor anymore
but he he was back in the day he put out
a fairly influential blog post to me
about looking at the different layers of
writing software so I'm just going
pop over to this at the bottom you have
this base and it's a solid base once you
the code that you put down here is stuff
that you shouldn't have to change the
API is fairly solid um if you do need to
change its usually adding additional
classes but if a new business
requirement comes in this probably isn't
the layer that you're going to be
changing and it's going to take the most
work to change because it's going to
bubble up through the rest of your
architecture and the middle tier this is
where you are actually working in
business requirements I just put Ruby
there because i really like Ruby but
there's also no compile phase it's
fairly easy to go and make changes and
in a language like Ruby but you could
substitute any other language hear that
home probably is dynamically typed and
not statically typed and then at the top
for things like configuration stuff that
isn't going to be you know the
deployment of the next version but might
be something that I need to change it
for tomorrow you go and develop a dsl
and it's very easy to change I also feel
that this kind of goes in order from
least likely most difficult to read the
most easiest to read if you make a nice
dsl you can potentially give that to a
DevOps person or even a business analyst
and it might not be able to write it
while DevOps person can write it but
they can certainly read it and that's
really handy in the last just a dry
mouth
in the last six years is been in just a
huge proliferation of different
languages many of which now are getting
a significant uptake which is great many
of them may not make it they might just
kind of stagnate and the user base won't
grow but the idea of these different
communities existing I think is really
important in particular I want to draw
off the idea of biodiversity ideas are
sort of the food in this so you have
programmers that belong to communities
every programmer always has a different
idea of how something should be done but
by having these language communities
they congregate together and talk but
for the same actual problem space you'll
have n different language communities
all having the same conversation and the
pessimistic way of looking at this is
this is not invented here syndrome right
everyone's designing their own wheel
over and over again and then we're like
oh that's sucks it's that's not how it
should be we should all just use one and
that is probably true but the neat thing
about this is one of those communities
occasionally comes up with a really good
idea that no one ever thought of and
then one that does happen since we have
programmers that have their feet
multiple languages at the same time that
idea will go and cross pollinate and go
to the other communities very rapidly
the example that that I I saw firsthand
was when David Hina Meyer Hanson
ruby-on-rails he was he actually came
from the Java world for very short
period of time but he got really sick of
having to update configuration files to
do every particular action he did so I
don't know if he actually came up with
convention over configuration but he
definitely popularized it so whenever he
added a new controller and an MVC
framework which rails is he doesn't
actually have to update anything to say
this controller exists here and it's
bound to this particular URL path
structure it just sort of work
and since rails is just going up that
that huge hype wave in 2006-2007 it got
a lot of visibility from other language
communities and literally within one or
two years every web frameworks seemed to
like kind of embrace this idea the truly
weird weird thing about it is isn't this
really obvious so we kept reinventing
the same wheels over and over again and
then someone eventually like realized
something in retrospect that was obvious
and it had a big effect so different
communities can have a large effect on
you even if you don't actually have any
involvement in that community okay so
some of my personal goals that you
should all walk away with and do the
first we have a lot of projects that
have Jay at the beginning and if I was
to ask you what that would be everyone
would say Java unfortunately job is too
overloaded of a term Java is also
associated with being slow and bloated
which I'll get to in a little bit but
it's too it's too confusing we need to
actually kind of take back the J and
start selling the JVM because there's
very few people on external communities
that actually think that JVM is bad but
there's a lot of X Java programmers in
the early days that walked away to what
they thought was a greener pasture so we
need to we need to change the vocabulary
the next thing that we need to do is
absolutely every language that exists
out in the world that we can implement
on the JVM we should implement on the
JVM and make it the best implementation
of that language now that's probably
easier said than done but when when I
said that you're probably thinking well
it'd have to be operationally better
like it has to be faster or use less
memory or take advantage of something
that the JVM has um like native threads
for contrast and they'll talk about this
more later
see Ruby has no native threads and JRuby
does have native threats this ends up
making a much much better implementation
just by that alone but probably more
importantly there's an awful lot of
value adds that even if the language
wasn't as fast it would still probably
be a better language the fact that there
are so many JVM languages that are
different programming paradigms and they
all exist in the same vm space and share
the same garbage collection and all that
stuff and they can actually talk to each
other so jruby can trivially as a quick
hmm yeah I know there's some languages
where there's been attempts and they're
just kind of a limited support and not
quite good enough her Jang is trying to
emulate Erlang and it requires
continuations and so there's but the
other thing to take into consideration
in this question is what is possible for
the JVM do to do today might not be the
same as what's possible in five years
because the JVM is actually evolving
much more quickly than the Java
languages itself so in addition to being
able to talk to other languages easily
we have these application servers that
are deployed everywhere and they're good
application servers and Red Hat JBoss um
but if you actually want to deploy let's
say Ruby on Rails odds are it's going to
be very easy in a mid to large sized
company to actually deploy to an
existing app server than it is to
convince them that you need to set up
process based concurrency and have a
whole new set of tools so this is pretty
huge but in addition to that we have all
these je e services that we've developed
for the last nearly well
15 years now and all those things are
just available for use so our JVM
versions of the language can rapidly get
some really mature features with very
little work there's tons and tons of
tooling on the JVM I probably see this a
little bit more than most because I have
one foot into the scripting world but
the tools for evaluating a running Ruby
process in see Ruby is pretty primitive
even maybe by like 1995 standards of the
JVM so all these things combined I think
sets the bar a lot lower for us to be
the best implementation of a particular
language the next thing is every time
you go to a bar or go to a conference
and someone says java's bloated or e's
bloated or e's awful this is kind of a
marketing slide that made it in here um
we need to we need to correct that
because that hasn't been true for a long
time it's like this weird this weird
zombie that's chasing Java around but
there was there was a there was a grain
of truth originally Owen Java first came
out it took a long time before it became
a fast implementation of a runtime and
heeey let's face it it wasn't perfect in
1996 I think it took years and years
just to have an implementation that
appropriately did container manage
persistence so these other languages
have two options for adding the support
for EE this kind of two topics got
merged onto the slide I'm just rolling
with it they can actually build it from
scratch in their language and of course
they will because the not invented here
thing is strong in every language but as
I said earlier biodiversity kind of
makes up for the fact that we keep
reinventing the wheel or they can
leverage existing implementation
and and to some extent that's what over
half this talk is going to be about the
last goal and this is probably a goal
just for us implementers is we need to
maintain really good relationships with
the other implementations for the
language that we're going to be better
like oh wait I'll say that about once a
month we meet with the see Ruby
committers and the Ruby language is
still evolving so they'll say oh we're
going to add this feature and then if
that's going to be very difficult to
implement in the JVM we push back and we
have a good relationship and we move
together harmoniously because having
multiple good implementations of a
language kind of helps all boats rise
because there's more options for
developers to use but at a second level
if I went and used the slide best
language at a ruby conference that might
seem kind of arrogant and might not be
the best way to build bridges in that
community we just really want to be a
good set of value ads and a different
implementation that someone can use if
they run out of runway because the sea
implementation isn't solving some
problem they have okay so now we'll just
spend the rest of time looking at
technology and what a surprise the first
thing we're going to look at is JRuby
this is me and Charlie were paid to work
on JRuby full time and have been for
last six or seven years it's a great job
if you can get it Jay Ruby's compatible
with Ruby 187 and 193 we spend a
majority of our work actually just
working on compatibility bugs I said
I've been working on this since 2002
there's an endless stream compatibility
projects are really easy to understand
the scope but very difficult to ever be
done jruby does have the value adds I
was talking about here's Jay
be just scripting java classes and using
it so just like java we can import a
class and construct it and see the news
on the right and to the left so it's on
the right side java x-wing jbutton we
can do kind of an inline call the next
line add action listener we have
convenience syntax so you can use snake
cased calling conventions instead of
camel case just to make it feel a little
bit more like Ruby but the cool part of
this line is that it actually expects an
action listener interface implementation
but we're not doing that we're just
passing in a ruby block which is going
to be the equivalent of Java 8 closures
and we just figure that out and it works
so we can talk well with other languages
here's kind of a bogus performance
benchmark although this is this is this
is better than most because red black
trees a reasonably complicated data
structure the current versions Ruby too
but a majority people are probably still
using Ruby 193 so running this benchmark
takes between two and a half in four
seconds there's a bunch of other Ruby
implementations they're doing a little
bit better if we go down and look at
this 193 + CX + 20 plus CX um this is
what Ruby users do when they don't get
performance they bust out the c compiler
and write it and see and then they make
a like a.j and i like call out to this
method to get good performance and so
they're able to get five times faster by
doing this and here's the big the big
surprise at the end when we run the pier
ruby version we're running it ten times
faster approximately than Ruby too I
won't say that this performance is
always this good but I think people are
always really surprised that we can go
and make a language on the JVM that
actually
runs faster than the sea implementation
if we go and cheat and rewrite parts of
the red black tree in Java we get down
to point 1 seconds so we have this we
can bust out and do polyglot to get even
better performance and I just want to
brag a little more last week there was a
tweet this was a native see ruby
implementation was using 40 extra large
ec2 instances and so i don't know if
they were they're probably running out
of money right so they moved it to JRuby
and it worked out really well for them
they're down to 12 medium instances they
actually reduced their operating costs
by over ninety two percent so they could
maintain the nice clean rail stuff that
they wanted but save a lot of money and
this other ones an example of us inter
opera calling java classes to get a
massive win this guy went and took a
native ruby script that would find one
solution in 24 hours of execution but
native ruby can't actually run on
multiple native threads at the same time
so if he wanted to try to parallel is
this hate up to subdivide the problem
and executed across processes way didn't
he didn't do that he decided to try
JRuby and it got faster because we are a
little bit faster and then he decided to
go and paralyze the problem and split it
across threads and got a nice bump and
then he realized that there's two or
three contentious points in a script and
they replaced those with Java util
concurrent classes still scripted as
Ruby and he was getting 30,000 solutions
a day so this is a good use case that we
can take the best out of another
language pull it into the source
language and get a big benefit without
having to like invent java.util
concurrent which would be a lot of work
and I'd probably never leave my
underside of my bed
mmm I'm not done talking about Ruby but
i'll talk about javascript a little bit
um deine Jas is another implementation
of JavaScript started by these two will
actually started by Douglas it was
started about three months before nas
horn so that might give you an answer
why it exists and at this point there's
a healthy set of contributors so it's a
living breathing project I really really
wish they could have said that their
past a hundred percent of the
conformance test for JavaScript they
have 11 failures out of over 11,000
tests and they're all J Ruby's fault
because they use our regular expression
engine and so we just have to accept
some patches and then there'll be a
hundred percent so that's that's a
pretty big accomplishment I think
another difference from now is horn is
that it's a mixed-mode engine so it has
a simple interpreter and after it runs a
bit then it jits and it also has it also
depends on invoke dynamics so for the
most part it requires java 7 or higher
ceylon i'll be honest i don't know a lot
about ceylon um but I really loved the
development methodology they scoped out
what they wanted to be in the eventual
language and they kind of mapped it out
and then they put out milestones and so
from a community perspective is like a
language geek what happens is when that
release comes out you'll see something
show up in hacker news or whatever and
then you have this nice HTML page to see
what's changed so it's a really good way
of engaging a community so I think
they're doing that right as far as
trying to encourage developers into the
fold Plus are not trying to implement
the whole thing at once so they can they
can do it in smaller bites and get more
feedback to see what works and what
doesn't work another really really cool
thing about it
is that it targets to back ends Oh yep I
can't give you the pitch because i
looked at the tour page it if we look at
some of these types I think you'll
understand better but wait I'll do a
little little pitch it's it's a single
inheritance based language like Java
that has multiple inheritance interfaces
that actually can behave more like
mix-ins but then they have a whole bunch
of type things like Union and
intersection types which this is another
one these things were in a programmer
brain maybe this should have been an
obvious idea but it's okay well brother
son wine so yeah
so stay in this room and you'll learn
about sale on i'll just go back up to
the top and some of the stuff will be
filled in with what I know so since it
runs in two back ends I think this is
really good for language design the fact
that you might actually depend on
something fairly inmate at the low level
of the vm but by targeting to VMS i
think it's going to shake out that
oddness so maybe someday there can be a
sale on back end that maybe just targets
see or something but i think that's a
good idea if you're trying to develop
your own language unless you only want
it to ever run in one back end you know
the apocalypse could come and then
people stop using java and then where
would sail on go so there's Union and
intersection types an intersection type
will basically figure out what methods
these two types have in common and then
make that the type if someone does go to
the emerging script bowl I would love to
know what the use case for this is I was
trying to find one I couldn't find one
it's really cool but I don't know why
they have it but the one below it does
make sense so I think maybe they were
just trying to have some I can't think
of the term but it's it's it's
consistent Union types are actually
quite useful because in ceylon if you
define something as being string type
and it ends up getting a null the
compiler will actually tell you that
you're receiving a null and I can't tell
you how many times I wish Java had the
ability to to have that so if you
actually want it to be string or null
you just do string or null in fact this
is common enough in the language where
that I think they have string ? which is
the equivalent of this and I mentioned
that interfaces connect like mix-ins I
didn't mention that there's a higher
order functions their first class
part of the language but the truth is um
there's lots and lots of features so I
think even with that script Bowl they
probably won't get through most of them
ok now we're kind of going up to servers
the first one is one that I probably
have the most experience with called
torque box it's torque box layered on
top of EAP six currently and basically
it takes all the nice bits of a jboss
application server and puts them into
nice Ruby api's so they're typically
just very thin wrappers around but they
have a nice syntax this next bullet
point might look a little weird you can
run multiple applications in one server
but to a ruby user this is kind of
strange because they have to run
multiple processes for each listener
much less multiple applications and I'll
cover some of these basic EE likes
features and a few slides but i think
that torque box is a good example of
what the java community just takes for
granted now and many other environments
you don't get so much done for free and
the example here is that ruby has green
threads essentially it's not quite true
they have native threads and they'll run
a different native threads but they have
something called a global interpreter
lock so only one of those native threads
can execute at a time so that's pretty
shitty let's face it um but this has
huge ramifications on doing things like
doing a background job or or even like
listening for concurrent requests and
it's essentially process based
concurrency so if we look at this
feature in torque box we can do an
asynchronous fire-and-forget style home
method call so we create a user
after we create it then we want to send
them a welcome email welcome to my
social networking site and then we want
to render the the Welcome page back to
them but we don't want to like pause as
we wait for the message to get delivered
to the mail server but that's really
simple to do a torque box all we have to
do is include the background of the
logic and then specify that whenever
mail is called this is just an
asynchronous call that's going to
immediately return and then we're just
done now we could have this exact same
API and see Ruby elm there's multiple
ways that there's many many gems for
doing this so there hasn't really been
one like winning horse for doing the
style of thing but here's what happens
you have many listeners each one of
those blue boxes with mail or doubt mail
is a different different user being
registered when they actually call
mailed up mail there's some magic
metaprogramming that happens that will
go and Marshall that method call request
and store it in a database or a message
queue and then there will be a set of
other processes that will basically read
off that queue and send the mail
messages now this is really pretty
horrible because every one of these
things is a separate complete instance
of Ruby running that's running a
complete copy of rails it's running a
complete copy of your application
because you need to main logic and then
sometimes processes get wacky so then
they layer another set of monitoring
processes on top of that to kill
processes that take too long and they
define their own policies for this or
ones that appear to be sleeping and
doing no more work you know I don't ever
remember going to a talk or people talk
about servlet threads dying and how do
we recoup these it just seems like if
that was a problem it was so long ago I
don't really remember those talks
existing but that is probably like ten
percent of the talks at a ruby
conference
as managing a DevOps environment and
dealing with mysterious things another
great thing about torque box is that you
can programmatically configure your app
server I think this looks a lot nicer
you can pound out a lot of redundancy
you can use variables and define methods
DevOps people don't typically like this
but i like it and i think a lot of
developers prefer it however you can use
y amal to do the same thing yeah milles
like XML but it doesn't have the
brackets and it uses significant
whitespace rubios prefer yelled here
under the covers we're using a this same
scheduling API that jboss is using but
it's been dressed up a little bit to be
a friendlier API at the top we can do a
cron style thing where we do something
once a minute but down at the bottom I
think it's a much more interesting
example here we're still doing it once a
minute but you can see we're doing it
every sixty dot seconds this is a really
nice feature of the Ruby language itself
is that you can add methods to any type
at any time and it's a pure
object-oriented so 60 s actually an
instance of fixed gnome so very very
handy for dsl's next is the project of
mutant this is essentially just the
closure version of torque box it
provides them the same basic services I
think they made some slightly different
choices like I don't think that jboss
that they're built on top of is actually
using courts I don't know why they are
pulling that in but they can figure
things a bit differently this is an
example of bending the Java services to
into the programming paradigm of the
language that you're using so in this
case if we type in whatever host the
servers on / hi it's just going to
execute the function my handler and this
this feels much more natural if you're a
lisp II sort of guy another example
let's say we wanted to do in the
equivalent of making a transactional
bean this would be how you do it in Java
but in a mutant you load their
transaction functions as TX and then you
can see we have the same first and
second method defined here but then we
have a TX requires new in TX required
and all the functions that get executed
inside there are happening in that that
transactional context so again under the
covers its mapping into Java types
similarly to what I just shown before
but you would never know and I just
threw in this scheduled jobs slide
because I did it for torque box again
they go through some work to go and make
this look nice i'm going to try a
difficult feature that i was just
reading about this morning that that was
pretty cool but I don't know if I'm
gonna be able to explain it how many
people know what unix bikes are okay so
everyone okay I don't have to explain
that so this is sort of like UNIX pipes
you specify a list of functions and the
result of that the result of the first
function will go as input to the next
function and so forth it's a little more
complex than that and a little more
useful than that though here we're
trying to reverse a string the first
thing we do is generate an iterable
sequence and then we call a function
that can reverse a sequence and then we
reapply that sequence to make a string
but what actually happens in the
implementation of this as as the
function completes
saves the result with some time to live
and then the next function will pull
that out as a message and process it and
so forth so this still doesn't seem that
useful yet and I should probably point
out that you would never do it for this
example you actually want to do for
something that takes a substantial
amount of time to do work but you can
actually specify concurrency in this so
in the reverse step we're going to
specify that we want to start up three
workers and then for the rest will say
the default concurrency is too and now
we have this scenario so this is pretty
damn cool if you need to set up a
pipeline of processing you can actually
like tweak it and then adjust the
concurrency on the fly to you know make
things flow nicely the this is another
project I didn't know anything about it
is close to a mutant I don't know how
many je e features have been moved as
far as services if you actually go to
the page it mostly just talks about your
ability just to deploy it can run lift
or play frameworks of Scala and I think
you can do vaadin as well but there was
it was kind of confusing and the way it
was written up there's I think it's
somewhat novel um design goal here which
was that you could run multiple
different versions of Scala and multiple
different versions of lift at the same
time in the app server which would be
really nice for not having to upgrade
the world if you decided you wanted to
deploy a bunch of small Scala
applications to the same app server a
number of the people that were working
on dine j/s are actively working on a
nodejs implementation nodejs is
basically a reactor based callback
eventing thing they actually have a fair
amount of stuff completed but the
projects still fairly early but it's
enough now where users are actually
trying things out and it's exciting
enough where people are actually
submitting their own patches and I just
wanted to back up to talk about to talk
about open source contribution if you've
ever wanted to contribute to open source
and you've just been hesitant or worried
a project like this is totally perfect
and this is the perfect time because
every day you add a method to it one
more thing starts to work because this
is a compatibility project the scope is
totally understood you know if you
implement a method on zee love it has to
behave just like the one does on the sea
implementation so it's it's a lot of fun
to get involved at this stage and a
language and I suspect this one is
really easy to contribute to because how
hard can it be to access the file system
so I think the potential for Nodine and
is there any nodejs experts in here as
anyone know nodejs is okay I think the
potential for this is that the
JavaScript engines will have a single
reactor that essentially has to run on a
single core what I'm not sure of is
whether CPU execution that doesn't do I
owe can actually use up additional
course I want to say that the can't but
with no dine and dine JS for sure you
can have multiple reactors or pool of
reactors and then send things off to
different cores and fully saturate your
CPU which is what you want right the
last project I'm going to talk about is
vertex this is actually built on top of
Nettie and I guess I technically
wouldn't called it this an application
and server but it's definitely
definitely a platform for writing stuff
in various languages I actually after
when I first heard about this project
I'm like oh it's kind of like Erlang but
you write lots of these small actors
essentially and these actors can go and
send and receive messages across an
event bus this is really wild because it
has WebSocket support it actually can go
and send and receive vents from
JavaScript running on the browser so
it's it's it's transparent in that
regard but that's cool um but for it to
work everything you do has to be based
around non-blocking i/o and thinking
more asynchronously the atomic unit for
vertex is called a vertical I guess it's
named after a particle and they've had
running systems that have had million of
concurrent verticals in play and it
actually scales well for what I just
said in the previous slide about node
Nodine home in that they basically take
end processing cues one for each core
you have and when an event comes in it
basically processes a vertical on that
and it will completely use every ounce
of CPU machine house and the other
reason to really like this is it's based
on the actor model a lot of the
complexity of concurrent programming
just kind of melts away when you send
and receive messages and process a
little code snippet as a non-threaded
set of execution so hopefully one or all
these projects is interesting enough for
you to like take a peek my real helping
out suggestion here is that if you go
and try one of these out I implore you
to provide any feedback at all to
projects having worked on open source
projects for a long time they're all
literally be bugs that hundreds of
people have run across and no one
bothers to to send an email or report to
a mailing list to report the bug you'd
be surprised how many things you
discover have been discovered before and
if you just sent an email you'd make the
developers really happy and hey you feel
part of the community and you could pat
yourself on the back or have someone pat
your back but if you do like it enough
definitely start sending bug reports and
play with it morons and push into weird
nooks and crannies all languages have
lots of corner cases so if you want to
really help out a project just try to do
really weird just do things that
you would never normally do as a
programmer and you'll probably find a
bug and save someone some trouble down
the line most of these projects are
actually hosted on github so if you use
git you'll fit right in so these are all
the projects that i referenced and
that's all the material I have I would
be happy to answer any questions sure
JPM or absolutely level right where you
can run multiple languages but the
bigger the enterprise or governance you
have right to train standardized you
still have an issue of having multiple
developer skill sets that just
operations okay um so the question for
the recording is what's the direction of
polygons and enterprising isn't making
progress essentially um well I can say
in 2006 I talked to someone in my vision
said with someone at Dow and they
started using jruby and that was quite
adventurous and how they did it was they
said well I'm that I'm the person who
gets to make technology decisions I'm
the architect and Jay Ruby's just a jar
file now that that was maybe not so
aboveboard and he was maybe following
the ask forgiveness / permission but as
time goes on I've noticed that more and
more single use cases first go into the
enterprise so like in the groovy space
they might start using Gradle for the
build tool and then once people get
acclimated to that syntax then if they
start using groovy for other things they
start spiking projects for Grails in the
case of like concurrency sometimes the
stories just so bad that they believe
the articles that it is a much better
world and I get permission and they go
through a lot of long and hard of
hurdles but again it's it's it's always
it's always a problem of momentum I
don't think right now the problem is
that people are having a hard time
getting into the enterprise whereas it
was very difficult before but it hasn't
quite gotten to that
point where everyone just accepts that
that's a valid thing to do so we're
getting closer but I will say the jar
file thing isn't a bad way to pitch it
because it does run on the JVM it is
garbage collected by the same system you
are running tests you're going through
Home Staging environments I mean you
should know by the time it goes to
production whether it's safe the
education thing is a much more difficult
problem but I think what I've seen is
typically most languages are using Java
in one other language and that's a much
easier pill to swallow sir anything else
talk is cheap sure
the question was where these the
implementations listed where the
implementations listed written in Java
or some other back end oh oh I see yeah
that's a great question and you know
what I have not seen that yet so the
question is whether these alternative
languages are they always implemented in
Java are then implemented in something
else and I I haven't seen it oh okay so
the answer for the the recording is that
there's a lot of self hosted code and i
would say for ruby probably eighty five
percent of our standard library and core
classes are written in ruby itself and
we could probably implement quite a bit
more and for our next major version
we're going to have to because we're
going to have a new set of optimizations
that if they're not implemented in ruby
we won't be able to inline certain
important areas so yeah self-hosting is
a it's also a quality of a good language
more the more that's implemented in the
language itself I think the better the
language it is and why would you want to
implement a language in anything else
really isn't that why you're
implementing the language in the first
place I implement Ruby so i can write
Ruby sure
yeah I ok so the question for the
fractal programming Allah yeah so that
um it's more about impedance and and how
much effort it takes to go and make
changes so for me it makes more sense to
go and use a dynamically typed language
or one where you don't have to recompile
a jar but there are statically typed
languages where you can change quickly I
mean what am I trying to say here the it
might actually sound insulting for me to
go and tell someone that Ruby's less
effort to change the Scala so I think to
some extent that impedance is is how you
think about how easy it is to change the
flexibility of a language and Scala is a
quite flexible language home even though
it's statically typed it's going to be
easier to change than Java so that is
that that is really interesting because
there is a lot of psychology involved
there I haven't really haven't really
thought about that it's as programmers
we always look at things is just like
black and white because we're you know
it has to be 0 or 1 and we're computers
and but it is much deeper than that yeah
ok yeah so no I I think that's in the
eye of the beholder a little bit we
could maybe try to try to make an
experiment to see if that was actually
true but that wouldn't matter because if
you really like closure or Scala you're
not going to use Ruby no matter how fast
it is to change actually all you have to
do is know that it's going to be faster
than ready in Java in your mind right
anything else
okay well thanks a lot I know it was the
is basically the end of the conference
and we didn't try to do a bait and
switch but we did do a bait and switch
so thanks for your patience</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>