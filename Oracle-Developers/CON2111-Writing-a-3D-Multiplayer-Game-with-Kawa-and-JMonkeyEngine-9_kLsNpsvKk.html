<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CON2111   Writing a 3-D Multiplayer Game with Kawa and JMonkeyEngine | Coder Coacher - Coaching Coders</title><meta content="CON2111   Writing a 3-D Multiplayer Game with Kawa and JMonkeyEngine - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CON2111   Writing a 3-D Multiplayer Game with Kawa and JMonkeyEngine</b></h2><h5 class="post__date">2015-12-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/9_kLsNpsvKk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I will be talking about the right
project about writing a game called
fabric using a tool called J monkey
engine and the collar programming
language I'm a partner and this is work
joint with Michael Evans so it's on the
phone and but in Arkansas and we'll be
able to answer questions if you have any
I am the lead and the maintainer of the
cover language project they have in the
previously i worked on JavaScript person
and Oracle I work was on the Javed GCC
steering committee I work for signal
solutions on gcj i define compiler keep
us both other things michael evans is
developing the fabric game he also write
science fiction in before he worked 10
years for apple and next working on
among other things dylan language and
the newton OS is since they worked on
very smaller companies gaming and
endless environments so the fabric is is
a far future massively multiplayer
online role-playing game i have to say
carefully these are typically
multi-million dollar projects and
developed using traditional see postbus
style edit compile debug cycles the
fabric of everest developed just by
michael and it's written hundred percent
in the cava dialect of scheme and does
use various libraries of course
especially the j monkey engine gaming
engine which is written in java and this
talk will be about how this is possible
and the experience gained i'm going to
try to demo some stuff and let's see how
this works so let's
if that out of the way and and let's try
here e let's first
let's compile the whole thing
ah that takes you see most of its
building the jar and this builds a jar
that includes everything thirty five
megabytes including fabric of our assets
and I'm monkey and a monk engine very
things and it's plain ol jar you started
in the normal way that you start to ours
by double-clicking or by typing
something like where is it note aunt
and it comes up it's a network
multiplayer game but it's definitely in
development and I'm not a game person I
have you know didn't write anything and
i'm not a game player so you know i'm
just demoing a few things that I figured
out it do so first you pick a character
the characters are autonomous AIS in a
far far future solar system and and the
various you can pick various these are
sort of semi randomly generated names
and they have various properties to
various characters then when we pick a
character it takes a few seconds because
it's generating the player state the
game state everything everything except
some of the texture mappings is
basically generated programmatically and
here we are the in the center of the
screen is us and in front of Jupiter and
Volvox city is this thing that we're
going to try to navigate towards and and
so let's see if I can remember how to do
this
so you know we you know somebody else
has Ted who can do this better and then
we can move forwards and backwards and
we could move through this humongous
this is actually a humongous structure
in space and and the game is sped up
because there isn't decent not realistic
you know it's it's it's just you know
game game design of how fast and how
slow is a tricky issue but but it's as
you can see it's a fairly responsive
let's see if I can do that this is i'll
probably get lost this is using the
third mouse button and you know you can
sort of the screw up with the whole
thing around very quickly but it's you
know I can you know it's hard to control
if you don't know what they're doing so
so this is just ok so there's planets
there's a eyes there's there will be
networking there will be other things as
I said I haven't implemented it I will
have another demo a little later they'll
go a little further hopefully that was
just to take give you the taste of it
then that it is at least somewhat real
so let's go back to the slide deck let's
see if we can full screen that again
there we are so some factors when
picking the tools and for such a project
is you know well I will you know at
least at least Michael he is you know
from his experience he wants interactive
incremental development will talk I'll
talk more about that later Breaking
other factors you know you need to like
to send tanks it needs to be reasonable
composable extensible you want to avoid
boilerplate there's also factors like
you know specifications and
documentation how well did it get with
Java and of course performance is very
important and you know then there's the
issues of you know tools and you know
how you build things and deploy things
what we mean by you know interactive
incremental program development is multi
multiple things one is that you know you
obviously you don't want to explicitly
have to run the compiler
you know if there is a compiler it
should run automatically most of them
unless you explicitly want to compile
ahead of time you want to avoid needless
boilerplate you don't want to have to
specify times but you know types can be
nice adoption you want to be able to add
new code while a program is running
existing code can be replaced it should
be dynamic you should have values that
read eval print loop you should be able
to create functions and classes at
runtime existing values should be able
to modify existing function you should
be able to call from a rifle and I did
the goal is a sort of seamless
transition from exploring ideas to
prototyping to testing to sort of
serious development organization and
deployment and we believe that the Lisp
style languages it doesn't necessarily
bila syntax but at least the ideas of
Lisp are very valuable to that style of
programming and what is list well it's
it's kind of a vague catch-all it
includes Common Lisp scheme Dylan
clojure and lots of other languages
including sort of extension languages
and customization languages for emacs
lisp and stuff there's decades of
history goes back stin 1958 lots of
experience lots of research originally
lists were tied to the artificial
intelligence community and symbolic
processing they pray a need a lot of
things like ripples garbage collection
lambdas and a lot of other things that
have since been rediscovered by others
and they've always emphasized
interactive development and avoiding
boilerplate and the goal is to make the
programmer fast and so you want to go
from an e big idea to write code
so one of the feature of lisps is that
their expression oriented that means
that there's no syntactical difference
between an expression at a statement a
statement just an expression as values
ignored this is more common now you know
where java has statements list would
have expressions that return values for
example at rice the equivalent of a try
statement can return the value and the
equivalent of a break kid return value
to whatever context is breaking to and
this way you know you can compose
expressions more easily you can move
things around more easily there's less
duplication in the embel language
specification so that's a nice feature
the most noticeable feature of lisp
languages is the parenthesized prefix
notation so you have within parentheses
you have an operator followed by the
arguments and the operator can be a
procedure could be like a addition
procedure plus square root length it can
be an expression that evaluates the
procedure it can also be and this is
where it gets a little unusual a control
structure that could be like if or
lambda and let's pick you also have
macro so you can have a operator can be
something that is transform at compile
time to some other expression in the
cover language the operator can also be
a class of type name in which case the
call is is instead a constructor
expression it can also be an array or a
list or something like that in which
case the call is in indexing there's
just a sort of nice syntactic sugar so
the benefits of Lisp style syntax
expression orientation in fix sorry
prefix the one is that you have did maps
to relatively simple core syntax that
can be written written that
read and written easily which because
their data which means you can right
tools to analyze and construct programs
more easily it also means you can write
macros more is leaked and have a
relatively clean macro expansion system
so you can extend the syntax you can
extend the language you can create
domain-specific languages there's no
result identifies and the goal is if you
notice repetitive code the abstract it
out with macros so for when Michael
started on the app fabric is he's tried
out three lists family languages for the
JVM cava which is an implementation of
scheme and a bcl and implementation of
common list and closure so a bcl what is
that it is armed bear Common Lisp it's a
complete implementation of common lisp
on the JVM with compiler and an
interpreter based on the ANSI standard
from 1994 it includes the Common Lisp
object system which is very flexible
it's a very dynamic object system so and
those like you really like it but it's a
little hard it doesn't you know it's it
doesn't quite match the Java object
system directly at closure is the most
well-known of these languages released
in 2007 has become very popular since
it's not compatible with other list
might languages it's known for having
strong support for side-effect free
programming using immutable data
structures this enables helps parallel
and multi-threaded programming
and closure has a lot of tools strong
ecosystem and a strong community so kava
is of course what I'm I'm proposing and
I'm like well but we'll talk about the
pros and cons its implementation of the
scheme language it implements the
standard from the r7 standard from 2013
except for the tricky on continuations
which I'm not going to talk about but
there is a prototype implementation of
continuations that I will hopefully
merge in a jump point soon and of course
that's like other languages lots of
extensions and JDM Canadian and
conveniences conv is as far as I know
it's the oldest still active compiler
based language for the JVM besides the
Java it goes back in 1996 the only other
language act selectively the same age
that I know of is ace networks which I
don't believe it's compiler based covers
also toolkit for language implementers I
used it to implement a very different
language call X square which I'm not
going to talk about anymore it's an it's
an interesting language it if you're
interested in obscure languages I
recommend looking at X squares there's a
lot of neat ideas they're sort of
boilerplate of random color features i'm
not really i'm going to talk a little
bit of a more some of them but
there you know the usual various it
features you know supports for java
ethics and android and various you know
lots of features and things that i've
added over the years sorry no as far as
i know this is just random cava features
it does use the JavaFX packager which I
don't I'm unclear on the relationship
between diet and child effects but
Michael did use the javafx package or
whatever that is to create the fabric
jar so you know any you know non toy JVM
language is going to let you access the
Java classes objects and stuff like that
some are going to do easier job going to
make it a little easier some are going
to make it a little more complicated or
inefficient one factor that comes up
specifically for fabric and Jane honk
engine the latter works by extending
abstract classes you know you extent you
use J monkey engine for your project by
extending abstract classes that's not
really straightforward to do that in
either closure or a bcl it's possible of
course there are workarounds but with
cover its trivial and that's one of the
things that makes cover little easier
for this another factor is as I
mentioned the common less public system
is very powerful and dynamic but it
doesn't map very directly to the JVM so
there will be some overheads and some
complications if you want something that
you know
that you can pass back and forth to Java
more easily closer does have multiple
ways of defining classes and interfaces
which I'm not an expert on several
turley say anything more about it here's
a sample of Aqaba class definition the
syntax is based on common dish to
coalesce hmmm take a drink the we're
defining a class named fabric client it
extends simple application and action
and implements actionlistener it you can
annotate it there in this case annotated
a serializable you can specify the
fields user name is a string with the
initialized to know simple in it app is
a method 0 argument that end calls in it
client there is also defined class that
supports true multiple inheritance so
you know this is you know fairly easy
way of basically writing Java classes or
own classes that are very compatible
with cha wap7 so it is this there is
some magic there but but it's it's it's
it's makes interoperability fairly easy
convenient syntax you know they all have
closure has of you know dots and stuff
like that cover uses the colon notation
quite extensively where X colon n gets
the property named n from the object X
so for example doc colon buffer gets the
buffer field from the object doc string
colon index off calls the index off
method you can get a static field if the
if the X is a static is a class name and
you can call a static method if the X is
a class name again and like bigdecimal
column value of so because cover doesn't
distinguish Cobb objects from Java
objects there is no separate khabar
object class that the Carver objects
inherit you know there's no it makes it
easy to sort of mix them there's no
separation between Java and Java objects
there are some languages like jruby I
believe has at least they used to have a
separation there that that makes do that
it sort of means you can put a lot of
useful stuff in the you know Ruby object
class or whatever it is but it also
means either have you know two separate
worlds a little bit there is a cover
also hides the difference between
properties and as fields and a property
says get set methods so to call the get
authority method on a URI object you can
either actually explicitly call the
method or you can just access it as if
it were a field and color will do the
right thing to compile and this will all
be done at compile time you'll get the
same code as Java assuming the various
types are known at compile time and
object creation is again uses the type
name as a constructor function so T of X
Y either cost new or cause a value of as
a factory method so here's a little
sample from fat the fabric code where
you know you're calling the constructor
and then you have these keyword
arguments and the keyword arguments at
the end are set the various properties
of the resulting object they eat the set
the field name text or they call the set
text method and
as appropriate so that this you know a
lot of languages you know groovy a lot
of they have variations on this syntax
but this is sort of automatic with
cowboy does it sort of without having
just customize it custom light and that
you don't have you know it works for any
class that has you know set methods and
it generates very efficient code you can
also similar variation on the syntax for
arrays and lists where the class type is
a rake last and then with the elements
and then they become the elements of the
resulting array or objects so here you
use basically the same syntax you create
either a integer array a job a cob a
star a scheme vector type or a plane
array list and this notation is
generalized to tree nodes or structures
that have child nodes which you'll
reveal you know we need a GUI program
you do a lot of building complicated
nessa structure so it's nice to sort of
it's so there's this source code can
represent the the structure of the coton
de tree and so here's an example you
create a weapon bed I a weapon button
group initialize it with the various
with the constructor arguments and a
keyboard parameter and then you have
child elements of two radio buttons that
get become the children of the weapon
button group and by default this calls
the add method of the weapon button
group but in this case there is no add
method so it has to be a little bit of
customization in this case either it has
to be a little snippet of code to tell
Calvin that use the add button method
instead of the plane
the method the camera modules are I
think I'm very simple and elegant I'm
very happy with how that turned out it's
there's nothing that and nothing it's
it's extremely simple is a source file
defines a namespace or module and a
module contains definitions you name
classes functions macros variables
aliases and may also contain top-level
actions and the program will can specify
that some definitions are exported and
then some other module or the rebel can
import some can import a module and then
this will create aliases for the export
the exported modules definitions and so
then these imported definition can be
recorded and you can rename and so it's
a it's simple and basic and important
factor is when you have a variable in a
module that you export you can export it
in the defining module but you can't
modify it in any importing modules that
way the compiler and the reader knows
all the assignments to the variable and
that way you can do the data for
analysis and type inference and error
checking which is very important for for
performance and sanity said if you have
but when you have random pieces of code
can do random assignments or things are
hiding all over the place it gets much
harder to keep track of things or
optimize things
the implementation is simple a module
name is just basically a fully qualified
class name and importing a module you
know you search for the class or you
search for a corresponding source file
and the source file can be explicitly
specified or it is constructed from the
module name it's very similar to what
relatives and then for each exported
definition equally creates a static
field possibly with annotations
importing camacho the compiler will look
for the static fields and analyze them
and so you don't need any special
databases yeah so let's try another demo
here this way this one will be let's see
where are we this one will do the and
what's the you know it's delete all the
compile files and we're in two different
talk to her now let's get rid of this
first
kill the existing law and get rid of all
the compiled files this time we're just
going to do from source code completely
interactive way okay
and so we can let's say I didn't set
this up as
so we can do for example this is where I
need the mouse
so if Michael uses Emacs for this nerve
various Emacs environments that well I'm
just using the plain old command line in
a show window and and we brings up
fairly quickly this is you know and we
do with plug in the default again same
way we can pick various characters work
the same way but now we have a wrap oh
let's do a few other things here instead
we can for example let's try a teleport
out it's going to be have to be careful
with the code sir
because these are funny quotes
and we go to the moon hopefully they
were there sir
and we can we can go to the
interactively we can let's move to the
create character States the point is
here is that with interactive
development it's you know you can
develop the game you can change it sort
of on the fly and you can experiment and
play with it more and and and and so i
did i'm just showing here here we have a
character picker you can sort of choose
factions you can choose armor you can
choose augmentative and it'll you know
change it to display it so let's try a
little experiment here and sub this
works so here so the let's say we don't
like this text here choose your weapon
let's say I choose exchanger to choose a
weapon and I was just do them on first
is to keep safe and then then okay let's
reload import view web and picker did I
get that right yep and let's restart
okay so now it's been reloaded and now
let's reactivate the plate estate any
others it says more weapon there and
when we reload it it will hopefully says
to speak you know that the updated state
has been reflected in the game
environment you can tweak positions you
can tweak you know things around
basically
you know like the calculations of where
things are hiding here are these
parameters you know if you know if
you're actually developing this game and
know it you can you know I don't know
what happens if we change the font size
save it let's just try see what happens
probably it will probably will do
something nasty that so we load it and
we've changed to you yep we got a big
big big amount there so you know so so
that's the that's the key point of
interactive and development is that you
you know you you change the game on the
fly and that's the strength of deep the
languages that support that right in
Java is obviously not really the great
for that and Lisp our language is
historically have been very good for
this let me continue so was there
anything else demo that's yeah you can
sort of switch back and forth you know
just just type things in the reptile or
cut and paste them or and you know
there's stairs we we moved to the moon
back to the moon
so where's my slides
that we are and
and what's the time
okay that's halfway okay and we're about
halfway timewise but through the demos
that we have okay advice that's not full
screening
okay not sure why that didn't full
screen properly
okay that doesn't really matter except
this is
not good okay let's
okay we do not tap ok that we have we
have something going on here
the demo killed the presentation never
have any demos their day there I usually
don't have them us and himself okay how
do we do this okay let's see okay
okay looks like it wants me to login
again that's is enough maybe start over
again sorry that didn't work why did
that not work
okay let's
ok let's start up John well it's no more
demos
okay we're here we go we were roughly
done with this let's go with hair okay
so you know there's also besides the
interactivity and and you know editing
things in place that you obviously
especially for something like a game you
care about performance and execution
speed covers always prioritized
performance and keeping the overhead low
the speed is comparable to scholar Java
it's helped by you know the type
inference and data flow analysis and
there's also a little hooks in there so
that for example for built-in functions
like plus you can there's a hook there
so you can customize the code generation
for example if you had two 32-bit ends
the result well it will use the I add
bytecode instruction directly without
calling any method so function or
anything like that and and then
similarly customize the type inference a
bcl enclosure are a bit slower than
cover and though they're faster than
many other dynamic language on the JVM
so they may be perfectly adequate for
for you know for your application
closure does have one neat thing in the
data structures which are designed to be
side-effect free which allows for a
interesting programming style it can
avoid some blogs it also makes the use
of multiple threads and parallelism or
more flexible however these data
structures do use more time and more
space than a plain old Java util type
data structures so you have to you know
trade that off
you know Calvin a bcl also encourage
more side-effect free programs but it's
not enforced by the language or the data
structures again you know we have to
decide what you like in practice I
believe it's easy to get good
performance with kava and as a side note
I both think simple instructions
multiple data stream programming are I
think something that needs to be
explored more inspires a better way to
get good performance with fewer bugs and
this is sort of like Javed streams or a
peel type or a really big difference is
start up speed closure and a bcl both
have notoriously slow start up on the
other end like starting cava and loading
fabric from a jar is half a second
loading from source is just a little bit
longer compiling the whole seven to five
hundred seventy five hundred lines it's
only five seconds and most of that was
as you can see building the jar which is
this big shebang of 35 megabytes which
is actually fairly small compared to you
know many other games but partly because
fabric generates a lot of the data
structures on the fly programmatically
rather than having these huge assets
that take millions of dollars to develop
so one reason for chavez faster startup
is that it's compiles each function
top-level function to a method whereas
closure compiles each top-level function
to a separate class and having multiple
classes means more classes means bigger
jar files and slower start up
it's a little simplification when
there's nested functions you know
there's you need to do some way of
handling the the captured variables so
so so some classes are obvious donated
for that another factor is that closure
at least historically would load
everything at startup time and the
entire functions all the functions in
the startup environment and all the
functions will get loaded which means
you have these big day destruction takes
a lot to read everything in Carver just
for the standard functions it just
builds you know in direction and aliens
with the class name of the film name in
a structure so and then the actual
function gets loaded lazily as needed of
few notes on memory use of course the
lazy code loading and I just mentioned
States memory of the unused classes the
noting that the closures no side-effect
free structures they are going to have
extra overhead compared to just using
plain old Java collections or arrays and
similarly for a bcl the cost of the
class memory object model is because
they don't map so directly to the JVM
there it's going to be a little more
overhead one of the weaker factor of
kava I I demonstrated reloading code and
and you know into running executable
that's not as strong in cow as I'd like
and that's part because kava does a lot
of type propagation and inlining and so
when you reload something that that can
break something else that makes
assumption about what the class was that
was previously compiled
closure is a little better in this
respect and a bcl Israeli robust in
terms of reloading that's the whole
thing about Lisp traditional lisps so
the first part of the solution is
recognizing the problem and that is the
you need to have a separate interactive
mode where you do less in aligning less
in lining and more in direction and what
I'm planning on them more more advanced
is the solution is you keep track of
dependencies between modules think
steady load and you do automatically
recompilation of functions as as things
stay depend on get changed and this is
hardest when you take it talking about
classes if you know if you edit the
class in a source file and you try
reloading into your running program and
there are existing instances of the
class what's going to happen well you
know you know the other thing is you
reload the class you know you get you to
get a new class but that's then they're
not going to be compatible so you
basically have to keep the same class
but you know use in direction for the
methods and getting access to the
objects to end the fields and stuff so
so I you know I think I know how to do
that it's doable without too much
overhead but you know the superclass is
the extension implements 10 will have to
stay the same when you reload but
everything else I think it can be
changed with with a you know reasonably
modest amount of indirection and this is
working progress
building a tooling this is where closure
is strong it has a huge ecosystem lots
of tools most closure projects use
lining in which can do a lot for you
compiling Cray projects special
dependencies and there's other also
other tools in the closure ecosystem
covers is much simpler but you know the
argue it doesn't really need it the kava
command is just you know Brenda jar you
know use whatever tools you'd use for
Java to build things or for deploying
things you don't have to learn new
things I'm quoting her to quote Michael
cloture is dependent in closure is
dependent in a large and complex
ecosystem and choosing to use closure
essentially means committing to that
entire ecosystem the majority of
learning closure is not learning the
language it's learning khlo jars and
lining m and n rebel and boot and ring
and home and mavin and atomic and other
stuff that I don't really know anything
about so but here are quoting Michael on
the other hand the to develop fabric
Michael just uses the curvature do with
genuine contenders and and emacs with
the crackers you know much simpler with
a little note on main functions cover
doesn't have it java and culture have a
separate main function or main method
carver i instead the top-level actions
of a module are compiled to a run method
i then when the virtual is loaded for
the first time the run mountain run
method is invoked there is a compiler
option when you compile ahead of time
the dash dash main option will create a
main method which then just cause this
run method
deployment with cover it's very simple
you ship the jar file you shape your
application and you can use the same
tools as you use with Java aunt or Java
fix packager which is what Michael used
standards have you know purses and
minuses they you know enable or ease
multiple implementations they encourage
text books and research and classes
stability they make help you define
what's the difference between a bug and
the feature which is sometimes helpful
but the first they can be political and
committees especially formal standards
committees can be very slow and
contentious closure doesn't follow any
separate standard you know just what
standardized within the closure
community a bcl follows a commerce
planet Carly implements the 2013
standard so here again I'm quoting
Michael about standards cava is a
particularly convenient implementation
of a particularly convenient standard
scheme is a convenient standard because
it's small and mature its standard are
well understood flexible and adaptable
its community the small is evergreen its
partisans continue to contribute to the
advancement of language design cover is
a convenient implementation because it
makes the cost of using a non java
language and valid Louis it possibly can
be a single drowning your classpath is
only need to incorporate cover into your
project so i'll have another bottom line
of mixed mixed things later but first
why and why Michael chose khavari these
reasons the start at time is much faster
the performance is generally better
working with J monkey engine was easier
because a inheriting from Java class is
much simpler and cover and closure is a
little awkward on working with
traditional imperative object during
libraries it doesn't really match
photo style very well finally cabas
toolchain smirks implement closures so
here's a few other things to consider
ABC l wins in terms of interactive Ness
expressiveness and a robust rebel
closure obviously lanes on the size of
the community it wins on the elegant
side effect reprogramming a bcl and
cover win on being standards-based if
you care about that and closure wins in
terms of the amount of tooling available
so you know there's there's a lot of
pluses and minuses I have it let's see
us sometime though we have 20 minutes
they'll let me finish the slides and
then we'll do crush than answers after
that so this is what one of the major
major features coming in a soon food
assume you know cover release is pattern
matching which ties in with a lot of
other futures so but the quarries
pattern matching basically the bang
operator is sort of like defining but it
takes a pattern and an expression all
right and then it binds x and y to the
result of make a list assuming make a
list returns a list of two and then it
binds the x and y to the corresponding
elements and you know patterns can be
generalized the most important pattern
is the colon colon type specifier little
that's in the later expand so first we
have a conditional pattern where you
instead of a bang you say ? and then
then you can have it inside an F and
then you
do the action d if the then part if the
pattern matches using the bound
variables otherwise you do the else part
of the if and a very colonists case
would be the one here where you you
match bow against the type T if it
matches you curse it and give it get
result X then you can use X in the then
part of your if otherwise you do
something else and you can sort of nest
these with ends and you can sort of do I
think we've all written sort of
convoluted any code that requires
instance of codes and curtains and stuff
can get pretty messy in Java and so
there's this is and I think it's a nice
feature common is this nice feature for
process literals for running c'mere
external commands basically it's kind of
a DD &amp;amp; % backed it takes a command with
an options and then that results in a
process object the interesting thing is
when you convert a process objective
string you get to stand it up but if
they say this is automatic conversion
there and because this means that this
this this sort of automatically handles
process substitution because you
couldn't you know you obviously want to
be able to insert a string in a command
line well that's you just insert the
result of the previous game another
command they commit and the other
feature is these process literals you
can take you can pass key words like
here the in keyword means the following
expression is the input the standard
input is evaluated as this scheme
expression and then convert the string
and fit into the standard input of the
TR command which inverts upper and lower
case in this case
and so if you combine these ideas a pipe
is just take a command treated as a
string and pass it to the next command
and of course kara is smarter doesn't
actually you know run the date command
and you know create a string in memory
it will try to you know pipe them
together minded make sense and this
there's there's actually there's a you
know there's a whole bargain web page on
on you know double quotes and how we
handle ads you know addition you know
it's interesting how would you you know
you how would you do the shell syntax of
you know when you substitute variables
to double-cross a single cause and how
does that make sense when it's not quite
when you have typed and variables and
arrays and stuff like that and so I
think I think I've came up with some
fairly nice conventions are we also have
XML laterals which are just you know
lots of languages of XML literals and
you can substitute strings and nodes but
they're kind of you need I've been
working on a PL style arrays which I
think are kind of neat here we define
the v1 as a constant list of an array
actually of six elements if we use that
as a function with an argument to we get
the second element zero based so five if
the index is instead of a simple element
in dec instead of a simple integer it's
a another array of integers we get the
result is in array so this is just like
a piano if you're familiar with it so
you can be it's kind of a function
composition
the weird syntax here with the for
greater equal that's combining and sort
of it's a keyword it's a keyword with
syntactically but it means create a
range of the number starting at four
counting down until we are as long as we
are greater or equal to 2 so it's
equivalent to the one of four three and
two and this supports assignments and
replacement of slices you can do insert
when you've changed okay I added these
fairly recently so there's a couple
typos there you can change the size and
I'm kind of working on generalizing this
to APL style multi-dimensional arrays I
think this is the last one the at sign
list this kind of needs for used in a
call it sort of explodes the argument to
have evaluates it's a sense sequence and
then expose each element becomes a
separate argument so it subsea
production it's useful for you know
concatenate in building things yeah okay
I think we are ready for questions some
may be you know Michael is hopefully on
the line if you have any question not
one yeah okay
performance to see out of the garbage
collector set up you get a lot of
Michael did you hear that our dinosaur
pitted I not here dude okay Donnie
you're great okay what what's
performance you get with the garbage
collection and Jim McKeon chandila get a
lot of hesitation really very like you
feat baby in a complicated fee might be
a little but not much can you be more
specific as to give us a metric to give
a metric like better than not nice I
can't if you want I can try measuring it
if you want to contact me but up stop my
head no I can't it's really a problem
right okay I don't think it's ever been
a problem okay it's not a soft real-time
system as a question right not know next
question
another one
i knows this enjoyment
he noticed in je manque ancient a lack
of anti-aliasing is that correct um yeah
message and that's intractable ?
intractable no I can't bothered with it
yet he hasn't bothered with the guilt I
think that was what I heard so far no
team that I've worked with has gone
below 150 frames per second so I'm not
really worried about it at the moment no
why is it safe okay so you made a
statement about multi massive
multiplayer
so being multi-million dollar
it in the presentation it was mentioned
that massive multiplayer online games
are multi-million dollar investments and
that this programming environment did
not require that can you speak to why
that's true and what productivity gains
you you're getting because of your
architectural choices yeah the one or
that first of all a consciously chosen a
game world that does not require me to
make a lot of static graphic asset
single largest expense in making a game
of this type is the huge amount of
static graphic and sound f it that you
have to create I've consciously chosen
up an environment in which abstract
characters and other models make sense
so that I don't have to do that so they
can build things procedurally in
software and then the other thing that
makes a big difference is that with the
interactive programming environment I
can generate extremely quickly I can
change the way things look on screen and
iterate through different appearances
and arrangements many times in a few
second which is not the way that
traditional game development works so
basically i can write code that does
things i can write it faster i can
iterate factor i can get results faster
and I've chosen a world where I don't
have to hire millions of dollars worth
of artists to build static acid
okay one more question yes Jay monkey
Asian eyes it's a multi-threaded
environment sorry part of that dropped
out J monkey engine is it a
multi-threaded environment it is not a
good environment yes I'd asked you
earlier about he was wondering have you
thought about the possibility of
integrating J monkey engine with javafx
not really um I mean it's an interesting
question it I guess it's not quite sure
that I haven't thought about it um I
thought about it briefly and it might be
worth doing because javac FX would give
me a richer palette of user interface
elements in the in the software that you
seem demoed the user interface elements
are provided by a third party ad on two
day monkey engine called Tony God UI and
you know to be fair the GF the JavaFX
you islands are nicer and more complete
it might be worth doing that's just not
where I'm expanding Muslim effort right
now so I've considered the subject
briefly but I haven't done it yet
how difficult would it be to integrate
the 3d components of javafx with jamin
qianjin i don't think i would try and um
jimjim earthy engine is sort of its own
thing it's it's it's own model of a
scene graph engine and i'll take at
right up to mix the two i might be
interested in using job FX for UI
elements but not really the 3d game
engine i mean i chose je monkey engine
particularly because it's easy to work
with interactively and I've monkey with
a lot of different 3d game engines and
there are you know other engines have
their own strengths but the nice thing
about j monkey engines it works
extremely well in the context but i'm
using it if you even make it work is
there anyone else has questions no no
other questions or do you have any more
questions i guess one more thing I'd say
about working with j monkey engine in
particular is that it's the fabric is
designed to work dynamically I mean not
just to enable me to work with it while
it's running to test things out but the
gameplay is designed around procedurally
constructing things while the game plays
and so it's important to have a game
engine that makes it easy to do that for
example all of the all the objects DC
and a scene are built dynamically when
the scene is started and some of the
things that player characters can do to
each other into non player characters
rely on being able to dynamically take
models apart and put them back together
gay monkey engine gives me good tools
for doing that any more questions oh
then thank you thank you for thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>