<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JDK 9 Language, Tooling, and Library Features | Coder Coacher - Coaching Coders</title><meta content="JDK 9 Language, Tooling, and Library Features - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>JDK 9 Language, Tooling, and Library Features</b></h2><h5 class="post__date">2016-09-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/vKYzmIi_1LM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello thank you for coming here this
morning my name is Joe Darcy I work in
Oracle's Java platform group and I'll be
talking today about JDK 9 language
tooling and library features if we don't
get to your questions at the end or if
you're watching the talk on streaming
you can tweet questions the hashtag on
the first slide here getting a 9 Lang's
tools libs this is a very important
slide from Oracle's lawyers they want
you to make sure to not put too much
trust in what I have to say here during
during this talk this is the safe harbor
slide I must say though if you're
interested in safe harbors there are
many other safe harbors in the Bay Area
or you to visit so please especially if
it's your first time here please make
sure to check out some of these other
safe harbors in the area quick survey
which JDK 9 release are using now in
production to show of hands JDK nine
early access which cutting edge dig saw
a few people using that that's good
about the other JDK 9 builds the usual
ones it's good to put these in your CI
systems now to see how your your
products work with the upcoming builds
JDK 8 good it's good to see strong
adoption JDK 8 people still on 7 ah
maybe 15-20 percent or so 6 still some
hands 4 6 I now admit it who is on 5 or
older anyone ok we have a few brave
souls will admit hopefully after this
talk and others you'll you'll have more
motivation to try to update to some of
the newer day decays we've had since
then an overview of JDK 9 current
schedule released next year in July as I
mentioned the early access bills are
already available there's a one main
lease line of development and a second
one for jigsaw that's a little more
farther out for that product JDK 9 is
being developed under the auspices of
open JDK so if you're interested in
following the development as it goes
along
there are mailing lists and projects so
you can get the source code there's also
the option group if you want some help
getting started with JDK 9 part of the
adoption group
is also an outreach to various open
source projects to have them run their
test Suites and their products with JDK
9 to give us more feedback sooner about
how other software products in the
ecosystem I work with 9 along the way
throughout the rest of the talk I'll be
using term jep for a jdk enhancement
proposal these are a document to use for
project tracking now and dhoop needs you
yes--you to help out in try your java
programs with jdk 9 please let us know
how it goes so we can make any
provements before GA next year now as
you've no doubt heard modularity is the
big feature coming coming in JDK 9 in
project jigsaw and in a nutshell
modularity lets you group together
groups of packages in a unit with
stronger encapsulation than you find in
a jar file now this is a very pervasive
change to the platform we're changing
the language there are new module info
files that allow you to declare the
dependencies between modules and other
aspects of the modules so that means we
have to modify the Java C command to
recognize the new source files we also
have to update the runtime command Java
to recognize the modules and there's
also updates to core reflection and
things like that so we would have to do
those set of changes for many like
larger language changes such as lambda
would have to change those as well but
with modularity it's also a change to
the programming model so it's really a
much more pervasive change than many of
the changes we've seen previously to
Java so the modularity work wouldn't fit
all in one talk the jigsaw teams
actually giving 5 talks here at JavaOne
most of them are given twice there's
some of them starting later this
afternoon in this very room so if you
want to head out and come back in later
on you can get caught up with jigsaw
there's also a hack session later in the
week after some brief notes about our
stewardship of Java there's three main
areas we'll be talking about for first
to note though that JDK 9 even without
jigsaw is a significant release it's
very large
just to give some scope here's a quick
graph of the bug counts in 8 vs 9 so
basically since the beginning we've had
a higher bug fix rate in 9 min &amp;amp; 8 so it
is a very significant release even
without jigsaw and we'll be talking
about the non modularity features in
this talk today you can group those
features in three basic areas tool
improvements language libraries the
features don't always align neatly with
these divisions so we that's not a
stretch division how to talk and if we
have some time at the end we'll do you a
so first a quick note on stewardship now
the approach the stewardship we use in
the JDK is not the sort of stewardship
we saw by Denethor and Lord of the Rings
films it's much more benign actually
under Oracle the main priority of the
Java platform group has been to keep
Java vibrant that's been our consistent
priority over the years and that
influences the approach we use to
evolving the platform so this is written
up in this document the open JDK
developer's guide part of keeping Java
vibrant is for the most part keeping the
things that work today working tomorrow
there are exceptions to that of course
but that's that's the default in more
detail what that means in technical
terms is that we want to preserve
compatibility and there are different
kinds of compatibility you can talk
about first is binary compatibility
that's the fun in the JLS as they can
continue the ability to link so when
Java goes to the run your jar file or
other artifact you can still link it and
get it started
there's source incompatibilities does
your code still compile if it's still
compiled does it compile to a program
that means a class file that means the
same thing
and finally there's behavioral
compatibilities what does your code
actually do do at runtime so we want to
keep all of these in mind this informs
our language evolution too we want to
make sure to keep recognizing the old
class file so you don't have to recreate
your jars to new versions of the
platform we want to limit the cases
where ode cold doesn't compile anymore
with the new language version and we
don't want to introduce silent changes
and how Java C generates code for the
most part and that is supposed to be a
three dimensional graph but you can't
see the axes on the display there okay
but just imagine it's a grid four source
binary behavioral layout like you might
see in physics class so this
compatibility policy differs for
different releases with the
implementation of a differs so if we
have every release like the quarterly
security updates that come out every few
months we want to have a very small
compatibility impact in that kind of
release so we might have something
that's limited to the source behavioral
plane so we have one a little bit of
behavior compatibility we don't want the
exploits to work anymore for fixing your
security issue maybe a tad of source
competive source incompatibility if we
have a larger update release something
like 8u 20 or @u 40 we have a little
more room to maneuver a little more
leeway to make behavioral changes
because it's a large release but still
not too much source compatibility and in
both of these cases no binary
compatibility change we don't want
people to not have the ability to link
on the program if we have a feature
release like JDK 8 or especially JDK 9
there's more room we are we will make
larger behavioral changes in some cases
will make source battle changes in with
an up justification we will make binary
incompatible changes in a release like 8
or 9 so let's give an example to help
illustrate how this policy works in
practice this is the specification for
hash map buff iterator returns an
iterator and particularly out here the
elements are returned in no particular
order
that means a correct program should not
rely on the order of the elements
returned by the iterator so that's
allowed by so if we want in the
implementation to change this order
that's allowed by the spec so going
through the different kinds of
compatibility that's binary compatible
there's the same set of methods so
nothing's changing there its source
compatible for the same reasons you know
nothing that would affect the source
code is changing however it is a change
in the behavior compatibility and we
know that people can and do rely on the
iteration order sometimes even our tests
rely on the iteration order then we have
to fix the test
so this kind of change generally
wouldn't be allowed in either kind of
update release but it can be and has
been made in a feature release like 8 or
9 so when you update to new JDK or
perhaps as you've already updated to JDK
8 we use this binary source behavioral
compatibility documentation in the
release notes and compatibility guide
reproduce for the JDK release so he the
slides will have a link to the guide for
eight a particular note if you've
updated 8 you might have already run
into this the order of methods returns
by class yet methods changed in JDK 8 so
if you had a unit test for lolling on
that you have to have update them and
later in nine time frame will produce a
similar document for JDK 9 and if this
sort of discussion about compatibility
interest you there's a talk by Ian
Robertson later in the conference about
the science and art of backwards
compatibility ian is in the audience but
the since this is in the keynote we
won't have them come up and do a walk on
so how is JDK 9 different from other
platform releases with modularity coming
because it's a large feature and it's
one that we think is necessary to keep
Java vibrant for the next 21 years
there's a larger compatibilities a
larger set of changes will make to
compatibility more so than usual for
example in terms of behavioral
compatibility we're making changes even
in the layout of the file so there is no
RT jar and JDK 9 so if you have some
process that relies or assumes RT jar
will be there it's not anymore and
you'll have to update that so that's a
good reason to start the early access
builds now to be aware of all these
things sooner rather than later rather
than when you were running to job jt9
fuse done rope to help support
modularity we'll even breaking binary
compatibility in a few cases this was
documented at the end of Java SE 8 and
we've implemented in nine there are some
unfortunate dependencies on Java
in far-flung parts of the platform like
java.util jar which is part of the base
module so we don't want the base module
to have to depend on beans in terms of
property change listener so we got rid
of those methods and not so it has a
binary incompatible change but we feel
the sufficient justification to make it
in nine we're also going to have a more
muscular deprecation policy in nine and
we'll be hearing more about that later
in the talk and that's the help better
manage transitions across JDK is over
the years all right so now we'll start
talking about tooling improvements first
one I'll talk about is J shell in
historical perspective a common way of
implementing with many other language
environments especially in the lips Lisp
tradition has been an interactive shell
called a read evaluate print loop or
repple now there's similar functionality
you may have seen for other languages
you use like Ruby and Python and on the
JDK on the JVM side Scala groovy and so
forth so what about Java now we have one
command that does this called a J shell
and JDK 9 I'll do a quick teaser demo of
that
so Jay shells are command in the jet k9
bin directory so we can just get that
started here on a jet ek build so you
have you have a shell a good thing to do
in a shell is get some help so you can
print that out here if the screen was a
more usual size the help output would be
more useful and I will make this now the
output should fit on the screen not
quite even when you think you've gotten
things set up ahead of time sometimes
you have it okay here we go so what's
the first program you write in a
programming language hello world so we
can start typing that right here and hit
return and J shell valuates out his
expression so notice we didn't have to
do any public static void main string
you know args all that we can just start
typing right away and get some results
but that's not a terribly compelling we
can also define variables in J shells so
let's say we wanted to find a double
variate tau that's equal to two times pi
and pi is of course in the math class so
if we do autocomplete hitting tab J
shell will list the choices here so if
we type P for pi that completes for us
so that's a that's about twice pi so
that's good we can find methods in J
shell
so let's say we want to define a
squaring method that takes a X and
returns x times itself so let's add it
to our environment now and now we can
evaluate additional expressions using
this so let's say we want to square
autocomplete for that math dot sign you
can take that and we can use the
variable we had previously tau we can do
usual command line editing and if we
take the sine of a angle and add it the
square of the sine of an angle and add
it to the square of the cosine and we
should get something close to one and
that's indeed deed what happens here
go back to the presentation out so a few
things about this if you're a new
student getting started with Java
there's a lot less ceremony you can just
start typing your expression right away
without having to avoid this well what
does public static void mean like well
it's a long story we'll get to it later
in the course you don't do that anymore
but this is not just a feature for for
students or people learning for Java
it's also very helpful for experienced
developers this is a good way to explore
using those new 9ap eyes where if you
haven't upgraded to JDK yet you know the
new API is that you haven't worked with
so far and we found this very useful in
the jdk group playing with new new
language features in terms of how J
shells implemented it uses a lot of
interesting technologies indicate JDK
including a API to programmatically call
Java C and some debugging api's and the
lead engineer for J shell Robert field
will be giving a more detailed talk
about J shell later in the conference
Javadoc so for many years Java doc has
been outputting HTML 401 a few years ago
there is a a new HTML standard html5
came out and now Java doc can output
html5 as an opt-in basis even though
it's outputting html5 there are no
videos by default though so the Java doc
output still looks basically the same as
before in terms of a frames style layout
how many people will have work with
dockland we introduced in JDK 8 there's
a few hands there perhaps a few grumbles
with unwanted warnings or errors in your
build dockland is a lint checker on the
structure and semantics of your Java doc
tags that works both in Java C as well
as Java doc so you can add it to your
build we've added some additional
controls for dock lint in jdk 9 besides
the previous controls or which
categories of errors you can now limit
the doclet checking to particular
packages for example in the JDK build we
only document the Java X the Java dot X
in Java X dot star packages
these are there particular dockland
categories and they do range over from
the syntax of the HTML to the semantics
of it so you can do things like if you
reference a at sea or at link to a
method that doesn't there that's a
semantic error and that can fail they
fail the bill at that point so you can
make sure to keep it up to date are
there any doclet writers in the audience
not not this time so the standard doclet
is the most common doclet that we use to
generate the HTML as part of the Javadoc
output but you can write your own
doclets to the original doclet api is
very old I think it's fair to say it
would not it doesn't follow current best
practices in Java API design so with the
benefit of hindsight we've been able to
design a better API is including a
better language model that's more
extensible and we've read the Java doc
command on top of the new API and not
another Java doc feature we're excited
about in JDK 9 is search I'll do a quick
demo of that
all right so now you can see in the
upper right-hand corner of the Javadoc
output is a search box and you can start
typing into it so let's look for math so
this shows a few things here it finds
occurrences of math in the package names
so the Javadoc math package in the base
module as well as type names so Java
lying math in Java math big decimal it
also goes down to two methods and fields
farther along this also works over
modules so if you want to look for the
base module that can pop up right there
and then you can go to the Javadoc page
for the base module you can see the
packages in that module as well so you
won't have to use the search engine as
often to find things in java rock you
can just search right in Java doc
instead this is a client-side
implementation JavaScript as I mentioned
it does index the names of packages
types feel fields and methods there's
also a way you can add additional index
terms for your own items if you choose
to do so the next two features are going
to be about facilities to help
transition from one JDK to another one
in the future both release jar files and
the Java C dash dash release option
first up the - - release option for many
years Java C has been able to cross
compile back to older JDK s in the Java
C man page and elsewhere there's been a
description of how to do this you have
to do three things you have to set the
source to the Roshan you want the target
for the class file version you want in
finally you have to set the boot class
path for the RT r r TR classes if of the
older lease do those three things we've
starting to dedicate restricted the
range of old versions we support to one
plus three back
so in jdk 9 in particular 9 is the
default we support 8 and 7 as well as 6
but 6 is deprecated and you get a
warning issued when you use it so
likewise when we roll them out into jdk
10 will support
10987 when 7 will be deprecated all
right so why do you have to set the boot
classpath well let's take an example
here in jdk n we have library that has a
food method and then in jdk n plus 1 we
add an over load foo that takes an int
in terms of our compatibility policy
this is a fine change it shouldn't cause
many problems and let's say we have our
client library here that has a foo with
an integer argument all right that's
good so let's say we take this code we
compile it against this JDK but we run
it against this JDK so when we compile
it against JDK n plus 1 the compiler C
okay you have a foo method it takes an
int so which which foo method is going
to call in the class file but the one
that takes an int or one one six double
its going to compile down to the one it
takes in it that's the more specific one
that's what's required by the language
specification so then when you go to run
that class file against the earlier JDK
even if you set the class file version
appropriately you'll get a message like
this no such method error and what this
basically means is it's looking for a
fool event and it's not finding it and
that's correct because there's no food
in there there's only foo of double so
this is why you have to set the boot
class path to avoid this sort of
situation but people kept running into
this in JIT back in JDK 7 we said you
know people keep owning into this will
give a warning if they use the older
source or target without setting the
boot class path so we did that that
helped a little bit but we still kept
having bugs come in
so in JDK 9 we thought you know what why
don't we just actually provide the
feature people art people want to use
here which is to cross compile to the
old version and make that easier to do
instead so that's just what we did with
the - - release flag a note on that
we're adopting a more the new style
options convention so - - release or
suggest - release so this is
semantically equivalent to doing all
three of setting the source the target
and the blue class path to the old RTR
now the information from the old RTR is
the old version of the platform is
stored as part of Java C it's part
the JDK build now so it's a compressed
format as another benefit as in one way
to help you're ready for modules that
the - - release will only provide the
api's for the older versions that you're
supposed to use so it'll only provide
the java SE AAP is that are part of the
standard as well as the exported api is
in the jdk and it's the same set of
release values as for source and target
so this has a few advantages if you were
being diligent in using the old audio
jars you don't have to manage that
anymore you don't have to try to get
that from somewhere to address this
problem people sometimes use maven
plugins like animal sniffer that's come
up some time so you should have less
need to do that because it's just right
in Java C another advantage is is we may
make improvements to Java C in newer new
releases there are bug fixes sometimes
we're performance improvements and you
can take advantage of them if you use
the - release flag and we'll see an
example that later in the talk so multi
release jar files so if you have a
library it's inconvenient to have
different jar files or artifacts for it
to correspond to different versions of
the JDK you prefer just to have one
artifact and distribute that instead so
that has a few downstream effects it
means there's slower adoption of new
features because more people are
compiling for the against the original
jar files now you can work around some
of these problems occasionally using
reflection so like if you want to call a
new innate API only when you're running
on 8 you can check for it reflectively
and all that so that sometimes works but
it's awkward code and it certainly
slower runtime than just using a normal
call now another feature is that with
the modularity support coming in 9 it's
going to be harder to access the api's
you shouldn't be using like those
tempting some dot star AP is that many
people find helpful from now again but
you've well I got a policy of not
calling them so you won't be able to get
to them as easily in 9 so as an
alternative we added a multi release jar
feature in 9 so there's a common area of
the jar files as before that shared
across all the releases then there's
platform-specific overrides put in meta
inversions so if you have a base draw
file for 8 you can put nine specific
class files that kind of override the
other class files in a versions nine
directory similarly similarly for ten
and so forth you create these with the
jar command using some extra options and
the other parts of the platform that
read jar files including the draw file
API in Java util as well as java c do
are aware of the multi release jar files
now we'll next talk about a number of
the language changes made in jdk 9 first
I'll talk about a set of milling project
coin features milling on a coin is is
the name for putting those ridges along
the edge that was originally done as an
effort to avoid debasing the currency
back when coins use made of precious
metals people kind of shave down the
edges to you know get the silver or gold
and sell it separately to kind of
devalue the currency so four million
coins was meant to prevent that in our
sense here million project wine is meant
to keep the value of the coin features
up to date by fixing some unfinished
work from early releases these were the
feature set in JDK 7 we were generally
happy with that at the end of the
release however there are a few features
where we wanted to tweak it a little bit
but we ran out our time in the release
so we're getting back to finish that now
first one of these o project lambda is
in a similar situation they also had
some work they didn't manage to get to
at the end of JDK 8 so we're including
that as part of milling project coin in
JDK 9 first up is safe VAR args on
private instance methods so this is a
code you could have written in the JDK
for many years back from JDK 5 you have
a list of lists of strings and you're
using some platform classes arrays that
as list to initialize it so it all looks
fine when you run this through Java C
though you'll notice you'll get a
warning like this
uncheck generic array creation for VAR X
parameter type list of string array so
it certainly sounds very very
intimidating that something might be be
going wrong here this sort of warning is
mandated by the
it is possible that something bad is
happening something called ulti
pollution this is discussed in the Java
language specification basically there's
a bad interaction between arrays in
generics that could possibly occur in
this situation now in this particular
current using arrays that as list
nothing bad actually happens the sort of
bad things that could happen don't
happen in this case and that is a nature
of doing this kind of a soundness
analysis so if you have a analysis you
want to be sound that means you have to
warn if you can't know that something
bad doesn't happen but that's not
informative in this case this is
basically a false positive and we wanted
to address this situation with project
Coyne back in seven so what we did we
added a new annotation type safe VAR
args that basically means trust me I'm
not doing anything bad in the VAR args
method you know the sort of heat
pollution problem that's not going to
occur here and we updated the platform
methods as appropriate to have this
annotation that did two things it got
rid of warnings in the declaration of
the method but more importantly it got
rid of warnings at all the uses of these
methods so all the user code that call
these methods didn't have those warnings
anymore so that was pretty good
due to some aspects of the design of
annotations you can only apply this
annotation to methods that cannot be
overridden so what are some kinds of
methods in Java that can't be overridden
well we can't override final methods by
by definition we also can't override
static methods now for the same reason
we can't override constructors from a
certain point of view a constructor is
this a very special static method that's
kind of how it looks at the VM side so
we can't so you use in there now there's
actually another kind of method we can't
override either and that is private
methods now private methods were emitted
from the list of methods you can use say
for args on in jdk 7 and now we're
fixing that in jdk 9 and this is a very
small language change I will show the
entire specification change on the
screen now so we like it when we get
nice simple to
just like this because they happen so
rarely so they're usually they're much
more complicated next up we have some
changes to the tribes resource statement
to have it use effectively final
variables just a quick refresher the Tri
of resources statement so you have your
resource being managed and basically the
tribes resources make sure you the close
method gets called when you leave a
block so it gets roughly translated by
the compiler or something like this so
there's an additional try finally around
around your block here and you make sure
to call close it's actually more
complicated so in terms of full
disclosure this is what Java C actually
does on our behalf but you don't we
don't to worry about this because Java C
takes care about that takes care of this
the extra complication is because of
some nuances of exception handling
so in jdk 7 the resources being managed
have to be done under a fresh variable
declared as part of the Tri earth
resources statement now if you follow
project coining JDK 7 that wasn't the
original proposal originally you could
have any expression here that have the
type auto closable which was the new
type created to to host the close method
but we figured out that this could be
problematic so let's say we have a
resource here we have it point to a
first resource resource one we pass that
in ok it has the right type and then
within the try block we change our to
point to a different object resource 2
now we exist a try block which object
should have its close method call so
this is a bit of a problem and it in
particular it's a problem we didn't want
to have to solve so we we decided that
you know what we're just not going to
allow that we're not going to allow the
situation by requiring you to have a
fresh resource variable so we won't have
to run into that situation that was a
bit overly strict though because there
are variables that can't be modified in
a tri or three sources block like final
variables or effectively final variables
which are variables that the program
would compile if you made them final but
you just haven't made them final yet so
what we can do now is to take advantage
of that if you have a variable that's
final or effectively final
instead of declaring a new variable in
the try of resources statement to host
it you can just pass it in directly and
since you can't to change are inside the
block we don't have the problem of like
which object to call it's closed method
on here's the grammar changes for that
not not very hard to the grammar change
the spec change is bigger as we expect
here it's a little more complicated than
you might suspect so you might think
like well you just need to have like
final local variables or something
we prefer if the language changes or
more orthogonal so you can actually do
things like if you have a final field
within a newly allocated object
well that's final - so you can use that
in your try earth resources statement
instead and that's what the longer
specification here allows you to do next
language change has to deal with diamond
diamonds are made under the earth and
great heat and pressure and will have to
go down the rabbit hole a little bit to
see why this feature is needed but it is
a good change we have the got into nine
so we using this little example of a box
type you can think of a box as a
simplified collection justified you take
objects it you put objects in and get
objects out so you have a list of
question mark here and you want a new
box to hold the the list so this should
be fine so what happens with this
diamond so inside the compiler the
compiler needs to infer a type to use
for box so Java is still a statically
typed language it's just not always a
explicitly typed language meaning the
compiler sometimes infers the types on
our behalf as programmers so what does
that look like inside Java C so the type
disk inferred is list of capture of
question mark so you can't write a type
list of capture fresh mark in your
source code so what's going on here well
this is something called capture
conversion and this is a non de notable
type which is described in the JLS now
this is a part of the JLS where you
might want to have a type theory book
nearby to help figure out what's going
on basically what's
means that is often the case in
languages there's a richer type system
inside the compiler than the one made
available to the programmer
so when Java C sees a wild card the
question mark type here it translates
that down to a new fresh type variable
inside the compiler and reasons about it
that's what the CAPTCHA conversion
process entails so you have your box
class one thing you can do with the box
you can subclass it it has public
constructors and you can also subclass
it anonymously all right so that might
be okay but maybe it's not so how do you
how do you compile down an anonymous
subclass so there's a full class file
for it so if we would write in a source
code look something like class of box
dollar one extends the box and we need
to have some type to fill in for what
how it extends box and the type that's
in furbot compiler is this list of
captures question mark so far so good
however there's a bit of a problem here
because this information has to be
stored in the signature attribute of a
class file the grammar of the signature
attribute does not allow nonde notable
types like list of capture question mark
to be stored to be represented so this
is a this is a problem here of using
Dimond with anonymous classes when you
have these non inaudible types so what's
been the interaction here over time way
way back in 1.1 many years ago inner
classes were added years later generics
were added the generics were added in a
way that interacted with inner classes
so that was fine then in JDK 7 we had a
diamond and inner classes in diamond
interacting together work fine inner
classes engineer diamond in generics
interacting together separately work
fine but when we combine all through
these three things together we get a
visit from Fang this is Duke's evil twin
brother who's coming to mess up our
plans to improve the language and as a
brian gets this fond of say this is a
case where yet today's problems come
from yesterday's solutions where these
language features made
or decade apart had this very
unfortunate interaction this was
actually discovered by our jck team and
they're writing performance tests for
the feature back in seven
so unfortunately seven the solution had
like you know what this sounds kind of
complicated to deal with we're just not
going to let you use Dimond with
anonymous classes so that will avoid
this problem for sure that was a little
unfortunate so when we were finishing up
the JCR 334 specification we did note
that you know his future in the platform
we could allow diamond with anonymous
subclasses if we don't get those nonde
notable types if we just had a normal
notable type then it'd be fine and we
could use it and that is in fact what
we've done now in JDK not the
specification to do that is is more
involved this is how you say non notable
in JLS ease fortunately our spec guys
take care of that for us so that's here
so what's been the effectiveness of this
when we were initially designing Dimond
we could get rid of about 90% of the
explicit constructor arguments using the
diamond feature in seven and we feel
that by allowing diamond with de notable
types in anonymous classes we can get
rid of a lot of the remaining 10% we've
had good experiences using this feature
in the JDK we've updated hundreds of
call sites to use this often for the
security pillars action next up
underscore is no longer an identifier
name so this is something that's been
discussed is a part of project lambda a
number of years ago when you have a
lambda parameter in eight you cannot use
lambda as a parameter name and if you
use lambda as a parameter name in 8 you
did get a warning from Java C notifying
you that well one day you might not be
able to use this as an identifier
anymore and indeed that day has has come
to pass so why are we doing this this is
against our usual policy of keeping
programs that compile compiling we feel
it's not used very option and if there's
a better future use of it if we reclaim
the syntactic real-estate some things
that might show up our partial diamond
so just in for one one type variable
manage another
or partial writtens like this on generic
haul maybe we can encode this is
something else like parameter names
expressed far not use messages and so
forth private interface methods one of
the other changes made by lambda in 8
was default methods these are methods on
interfaces that have code so they're non
abstract and so these are very helpful
in evolving the platform at the VM level
it was convenient and necessary to
actually have private methods on
interfaces to help have some of the meta
Factory stuff go on however at the
source level you couldn't have private
methods inside interfaces and now we're
changing out in 8 so you can also have
your own private methods in the source
code of interfaces you can both have
private static methods in private
instance methods so what would you do
with such a private method typically you
have that as a helper method for the
default methods in your class so you can
put some common code together as a
private interface without exposing that
to all the users of the interface next
up we'll start talking about about
deprecation and import statements so
it's a bit of background the JDK is
large Java code base we've had our share
of technical debt over the years this is
a multicolored diagram of the java c
warnings we've had building the jdk
itself as you can see back in jdk it was
over 10,000 so we had a few number
messages in the code base over the years
we made progress on this we have some
good interns and some other days and
later on we started turning warnings on
in the bill and from the time of this
diagram stops to you know then later in
jdk 9 we went from thousands of method
of warning messages left down to zero so
in the core part of the platform the
open code the close code generator code
it's all warning free we build with
excellent W error this covers many of
the dockland features as well so this
covers of the core parts of the platform
meaning the base module and the Java
based module and desktop module
well it does not include things like
CORBA jack speed jack ws instead maybe
we'll get to those someday maybe we
won't
and people often talk about technical
debt but I think the benefits of a
project like this can be seen as
technical dividends there are now entire
classes of problems in the JDK we don't
have to worry about anymore because
they'll be caught by the build and
people fix them right away so for your
serializable class did you declare a
serial version UID even an exception
type because all exception types of
realisable how about equals and hashcode
it's easy to make a mistake there
there's a very nuance check we do now in
the compiler that you know make sure you
do things properly
there's even possible security
implications something like a switch
fall through you can execute unexpected
code and that's the same basic problem
that was in that go to fail go to fail a
security issue from a few years ago and
finally is it really acceptable to have
more deprecation warnings on a
deprecated item so the the very button
there's I did write a blog entry if you
want to from the JDK experience removing
warnings recommendations you might want
to have for your own project to go
through a similar effort now the very
bottom layer of that graph of the
warnings there was a crust of very
stubborn deprecation warnings that we
had to get rid of as well deprecation
warnings are generated by the use of
deprecated types methods and so forth
these are mandated by the JLS now
there's a few ways you can resolve these
warnings you can remove the use of the
deprecated elements that's great when
you can do it you can't do it all the
time it might be part of the API you can
propagate the deprecated annotation to
the youth site in this case kind of the
cure is worse than the disease you're
making the deprecated part of the
platform bigger instead of smaller and
finally you can use the suppress
warnings feature to suppress warnings of
that case and that's what we we often
did all right so here is a here some
client code and here's a deprecated
library so when you run the compiler you
see that indeed you do get a warning
that it uses deprecated API uses
that blue right here so you say all
right no problem I can't remove use of
the API I don't want to make my client
too deprecated so I'll suppress the
warning instead so right at the top of
the class I'll suppress the warning I'll
run the compiler again and you still
have deprecated API warnings so what's
going on here if you look at more
information Java C is warning you that
well yeah you're using the deputy type
in the import statement you're not using
the code it's in the import statement
this is also mandated by the JLS you
might say well okay I'll just add
suppress warnings on the import
statement that doesn't work
that's not syntactically allowed so if
you really wanted to get rid of the
deprecation one you could do something
like for each use of the deprecated type
name replace it with a fully qualified
name of the type instead of the
important aim well that's a little silly
right in the you know the program is
just as bad if it's using a short name
versus the long name so why why do you
have to go through this fuss instead so
we change Java C to not require emitting
a deprecation warning in this location
so if you're on an import statement you
don't have to get the warning and that
was an easy fix here just one sentence
in the JLS but because of this fix is
now tractable to remove the deprecation
warnings from a significant codebase and
we have an existence proof of that in
the JDK so I encourage you to try to get
rid of the deprecation warnings in your
own code because of this fix there's
actually much more to say about
deprecation in jdk 9 that's just part of
it so what is deprecation mean it's been
a little unclear over the years does it
mean that this API is harmful does it
mean it's going away if it means it's
going away why haven't those guys in the
JK group removed any of these things
that have been deprecated for years so
we wanted to enhance deprecation aid to
help answer these questions and make the
management of deprecated API s easier
over the years so there's some new
methods that were added to the
annotation one that says whether or not
this deprecated item is for removal or
not and that defaults to false another
one is since when has the item
deprecated we've updated the deprecated
annotations in the core part of the
platform to have this additional
information in them they're supporting
updates both in Java language
specification java c and java talk
there's also a new static analysis
analysis tool called j deeper scan that
will analyze your class files and draw
files for use of ABAP eyes that are
deprecated in the JDK so one issue when
we add new deprecations to the jdk
saying jdk 9 people don't always
recompile their sources so they don't
have a way to get notified that things
have been deprecated now so j depper
scan is meant to resolve that problem
because you can make an existing draw
file run j deeper scan and see if it's
using api's that are now deprecated in
the new version of the JDK there's much
more to say about a duplication feature
you can get the full prognosis and
history from Stewart marks aka dr.
deprecated ur at a talk later in the
conference finally we'll talk about some
mostly library updates besides having a
new version with JDK 9 we have a new
version string scheme the summary is
we're getting rid of the 1 dot in 1.9 so
if we're never going to change the one
we figured might as well just get rid of
it this is also done to align better
with the semantic versioning and things
along those lines
so this is what the current version
output looks like from JDK 8 build and
this is what it looks like now a 9 so if
you have some system that parses the
version string output you'll have to
update that a bit if you use native
processes on systems there's a better
API to do that now and particularly you
can now get the something represents the
kid of the native process so that's as
handy when you need to do that strings
are one of the most commonly used types
in in Java there have been some changes
there
the compact string project previously
inside the string the information was
stored in a car array so that's 16 bits
per character often is the case that all
the characters in the string have the
upper 8 bit 0 because the characters are
all in the the first 128 characters so
with compact strings now based on the
contents of this string it always uses a
byte array and sometimes it uses a one
byte for character encoding and
sometimes it uses a 2-byte for character
encoding so this is transparent to users
it's the same API but there's better
memory density related to strings was
improving a string concatenation
drinking cat nation is another very
common operation Java C will generate
calls down to string builder to do this
now the pattern of string builder calls
Java C generates and the patterns of
string builder calls a particular VM
recognizes as being amiable optimization
may differ and they may differ over time
is one of the other changes so instead
to address this because it's the common
operation we created a new entry point
in Java line string concatenation and
then the VM can recognize especially at
runtime to optimize so again this is
mostly transparent to use it but should
result in better performance for string
builder and it should be future proof in
terms of API updates in the future so
it's less brittle in terms of the alphas
ation front there are other cases where
improve the engineering of existing
features one of those is called tiered
attribution which dealt with type
inference in Java C so we've talked
about type inference before with diamond
so we have it here we have a class with
generic class we want to have a
constructor for it you use diamond so
that's fine so we start compiling it and
we start having some nesting of these
constructors it takes a little bit to
compile and it's taking longer to get
more nesting and hmm it's seeming to
take a lot longer than it really should
for this length of program so if you
just have 16 nested calls here on the
machine we use this took 25 minutes to
compile now it is a bit longer but this
seems kind of excessive and the same
thing holds true for lambda if you have
nested lambdas like this you can also
get very long compile times now now we
don't want to give people an excuse for
having swordfights waiting for their
class to compile so we can graph this
here the linear scale looks pretty bad
but we can look at a log scale and you
were
all that if you have a straight line on
a log scale that means you have an
exponential growth curve so this this
looks this looks pretty straight here so
this is this is this is not good
generally in a compiler like Java C you
want to use linear algorithms with
linear growth in the program size or
length is linear you can get so
exponential is pretty far from that
so we've addressed this in jdk 9 with
Trude attribution and so these lines at
the bottom show that this is JDK nine
plane and this is JDK nine using dash
dash release eight so this means if you
compile your eight source code on nine
compiler you will avoid this exponential
slow down here so how is this
accomplished type infringe isn't magic
or mind-reading it's a form of
constraint programming so you generate
lots of constraints and what in the most
straightforward way to generate
constraints generates a lot of them an
exponential number of them and then you
solve it so the essence of pure dot
rebuke many ocean which is a fancy way
of saying caching so basically when the
constraint set was built it didn't add
redundant constraints going on and that
allows this much faster a solution time
for the type inference so that's good
there there's also lays the groundwork
for more optimizations for inference in
the future there are other parts of the
platform including security libraries
let's see how we're doing on time the
different parts of the security
libraries there's Java security itself
there's ap is that you can add use with
your own codes like photography
including SSL for networking there's
also a few command-line options like a
key tool and so forth the policy
security is secure by default that means
out of the box you can have a secure
configuration even if you have to
reconfigure it differently to be less
secure to meet your own needs and
there's a notion this is something
that's always changing to keep up to
date on the security best practice and
so forth in terms of the algorithms that
are used Oracle's recently published a
cryptography roadmap this documents when
in which algorithms aren't going to get
retired so you can make preparations for
Kove so in jdk 9 the crypto roadmap and
secure by default is that a few
implications we've increased the default
key size in some cases for certificates
weak keys are no longer accepted by
default so if you have a certificate
using md5 or RSA with short keys those
are not going to be accepted anymore and
the reason is even though the
functionality of you know things like
RSA and md5 are the same cryptographers
are very clever and they come up with
better ways of attacking the old
algorithms and of course compute there's
more computing resources over time so it
was considered secure in the past isn't
necessarily security more and the way to
guard against that is to do things like
use large key sizes and in terms of
preserving behavioral compatibility if
you really need to use the older
algorithm for some reason there's
usually a system property that lets you
do that we've also kept security
libraries up to date with other
involvements there's new hash algorithms
there's a new random number generator
which they call a deterministic random
bit generator instead on the performance
front processors including spark
processors and x64 processors will have
special-purpose instructions have speed
up cryptography operations and we take
advantage of those in JDK nines using
something called a hotspot intrinsic so
basically hotspot can recognize certain
operations is special and replace them
with the corresponding assembly code so
they go nice and fast if you're
interested in security there's a session
on that it actually happening right now
so you can't can't see it but you can
probably catch the replay and if not the
security team is having a ball tomorrow
evening you can catch them there saying
a few words on the client libraries and
JavaFX JavaFX has also been updated for
the modularity features coming in
platform as well as high DPI screens for
the client libraries the genera fication
of the client libraries has been
completed this was part of the warnings
cleanup effort again we have high DPI
across operating systems the font layout
has been updated there are a few places
in the JDK where open JDK in
the Oracle JDK used different code bases
one of those was in the graphics
rendering one use Pisces one use ductus
and JDK nine they've both been changed
to use the new Marlin graphics renderer
if you like TIFF files you can now have
support for those in the fathom or as
well if you're interested out client
there's again there's a session right
now that you could have gone to instead
but there is a Baath to meet that that
team later in the conference as well a
few miscellaneous small library changes
that are helpful
here's one for convenience factory
methods so how often have you written a
code like this you want to have a set of
strings so you have a hash set and then
like I got initialize it and now you
want to make it on modifiable so I have
to have this other calls like that's a
bit of a hassle it's a lot of code for
what should be a simple operation this
might say well I'll do something else
instead I'll use a raised dot as list I
don't have to have all these add calls
and ice off to have this wrapper here
there's other ways people get around
this I won't even show the trick with
the double braces we use anonymous
subclass I know people use it so we
don't we don't have to do that anymore
in JDK 9 we can just use code like this
ah this is not nice and short yes yes
thank you yes this is a Stewart Marc's
work what's going on here there's new
static factory methods named of on list
set and map they return unmodifiable
collections to make sure people don't
depend on the iteration order we
randomized it for sets and maps not for
lists and if you want to hear more about
this the stewart marks who added this
feature is giving a session on
collections later in the conference Java
util objects has some utilities for
common programming tasks there's some
more null handling there's a few methods
to take the TD matter of writing index
checks few odds and ends on the
mathematical front we have support for a
fuse multiply add operation which is
also going to have intrinsic supports on
a different processor soon if you like
taking square roots you can now not only
take screw some double values but also
big decimal values and beginning your
values some of you might find helpful is
lexicographical array comparisons and
Java you array
these also have intrinsic support so
they go nice and fast on processors for
concurrent programming there been some
updates there for timeouts for
completable future and if you do rocket
science kind of concurrency stuff
they're interesting things invar handled
that are on par with the features in c++
Atomics so in summary there's
fundamental changes coming in jdk 9 with
modularity but there are a lot of other
features coming too including completing
planned work on project coin and project
lambda and these features are meant to
support long term evolution and help
ease transitions to new releases over
time if you want to find out what's
happening you can follow along on open
JDK
and the EA bills are available now for
your evaluation so with that I'll take
some questions for a minute or two this
is a URL to the slides you can also
tweet questions to this hashtag and
please make sure to download the jk9
builds for evaluation thank you question
the question is is the o for the house
that does it use a perfect hash for the
of I don't believe it does but that'd be
an excellent question to ask it
Stewart's session later in the later in
that conference
so the question was about the the higher
plane characters and strings is not
going to be changing given the new
internal representation so the aunt
dancer is no it is as inconvenient or as
inconvenient
today as it was was was previously to
get the surrogate Paris well the the
speed of the relative speed different
operations of work was done to try to
not have gratuitous degradation to
performance so there may be some
operations that are slow with the new
encoding but others that are faster
different people want different things
yep
so so the question was could you get
around a diamond with non notable types
by using a specific type argument yes
you could certainly basically not not
used diamond or try to influence the
inference that was going on to make it
the notable instead but since the
purpose so that is is a fallback but we
did want to support it
the inference in this case where nothing
bad actually happened with it in notable
types so the question is what's the
difference between the EI and ei with
the latest jigsaw so the jigsaw feature
is currently and has been in the
mainline ei bills for some time the
jigsaw team they do some more
exploratory work in the a builds and
then once that stabilize it gets put
into the into the jigsaw train and then
once that's stabilized they put it into
the other ei bills right it is more
bleeding-edge it's a little more
experimental
the question was the with the security
updates and the using the eliminated
ranked libraries in jk9 I don't know
offhand but Sean Mullan and the other
people on the security lives team will
will be able to answer that question
handily at their bluff and I think one
more question
so the question was on backwards
compatibility so are you asking about J
Deborah scan or which which are you
asking about
I'm not sure understanding your question
I think I'll answer it off offline here
so so thank you for coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>