<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Demystifying invokedynamic | Coder Coacher - Coaching Coders</title><meta content="Demystifying invokedynamic - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Demystifying invokedynamic</b></h2><h5 class="post__date">2015-06-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/sHHSCqd-0HM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right good morning welcome to the
session on demystifying
invokedynamic my name is Venkat
Subramanyam
we're gonna talk about this interesting
feature in Java I'll spend just a few
minutes talking about why we should
really care about this topic and then
I'll get into quite a few details along
the way the best time to ask a question
or make a comment is when you have it so
please don't wait till the end any time
it's a great in for questions comments
and if you do have a questions please do
draw my attention I may not be looking
at your side so if you raise your hand I
may not notice I'm definitely not trying
to ignore you so draw my attention I'd
be more than happy to listen to you so
why do we really care about this topic
of invokedynamic
well let's let's set our expectations
really well here this is our topic which
probably is something you would not
really use at all so this is really to
Kindle the needs of your the geeks in
you if you really want to put it that
way because this is not something you
would code in Java directly but one of
the reasons I want to know about stuff
like this is that I'm always curious
about how things actually work I'm not
happy writing code and saying okay that
code word I want to know how that code
really worked this also is useful for a
couple of other details one is we're
gonna be asked quite often as we move
forward into Java eight is the
performance gonna suck and you don't
want to say no it's not gonna suck it's
gonna rock really but why would the
performance really rock well we have to
be able to say why it's gonna really be
good and again knowing about these
things can be somewhat you know
interesting and useful so so to
emphasize you're not going to write code
for this but almost every code you write
in Java is gonna make really extensive
use of this so this is not something you
would go write code for but every code
you write is gonna benefit from this so
this is really what's under the hood
there's probably a cup you people in the
world who have made the extensive use of
this one of them is Charles Nutter who
wrote that who writes the JRuby compiler
he's made extensive use of this in in
the JRuby compiler the Java compiler
team itself makes use of the
very heavily the groovy folks are making
use of this right now so language
authors language designers compiler
writers are the ones who benefit from
this most to make those languages more
efficient so enough said about all of
this let's look at some of the things if
you're interested in downloading this
topics list or the code examples we're
gonna right you can find them on my
website the link for which is at the
very top here but as a slide over you
will also see this in the bottom as well
so you can note it down towards the end
if you are interested I'll present this
again the link again so let's get
started well let's talk about the
compilers there are really two compilers
in Java one is Java C the Java compiler
but the other is the different flavors
of the JIT compiler itself now the java
compiler compiles the java code into the
bytecode and the JIT compiler takes the
bytecode and compiles it to the native
representation under the hood so there
are these two compilers that we normally
use let's take a quick look at what
we're gonna see there's a lot of opcodes
are the bytecode levels you know several
hundreds of them but there are about
four of them that I'm gonna be keenly
interested here so in this example have
an instance method have a very simple
method as you can see which simply says
instance method and returns our double
of the value given I have a static
method which doesn't do a whole lot
other than simply saying return print
out the static that's all it does right
nothing else really then I have over
here an implements comparable interface
that's all I have and and i implement
the compareto method no big deal
and I'm not really implementing that
method here because I don't care about
implementations right now and then
finally of course the main method for us
to work with so what am I going to do
within this method just to kind of
curiosity's sake let's go ahead and call
the sample and say I'm gonna call the
static method let's go ahead and create
an object of sample here say that this
is a sample object and on this object
let's go ahead and call the instance
method maybe send a value of 2 to it and
then we'll also say a comparable
interface for the sample will say
comparable over here and then we will
simply assign it to sample really not
doing a whole lot of stuff here other
than simply calling the compared to
method and send the sample back added
and
what we're gonna do here just call this
method itself on the comparable right so
now that we have done this code I don't
really care what the output is but
what's really interesting is the
bytecode is really generated so let's
get back over here to the command prompt
for a minute and I'm gonna run Java P
minus C to take a peek at what we really
have here so Java P minus C and I've
already alias minus C for myself and I'm
gonna go ahead and say that I'm
interested in looking at the sample code
that we just created so if you look at
the code we just created at the byte
code level what you notice within the
main method right here is that first of
all you notice there is inbox static
well no surprise the invoke static is
useful to create called the static
method then you have an inbox special
that's for private methods and
constructors of the class in this case
you can see it's calling the constructor
the init right here and then the next
thing you see is in book virtual which
is going to be calling the instance
methods and virtual methods and then
finally the invoke interface which is
calling the method using the interface
now while we have these methods over
here it turns out that the compiler
actually performs quite an interesting
set of optimizations now we can look at
these optimizations in different ways
but in order to understand a little bit
about this optimization let's quit that
for a second let's go back to this code
and I'm gonna start with a little quiz
for you just to prod your minds a little
bit and don't worry about being right or
wrong because I'm wrong most of the time
or my wife reminds me so so don't worry
about you know really being right or
wrong but let's go ahead and say in here
we're gonna take this instance method
and mark it as final so remember what a
final method is a final method would
never be overridden by another class and
Java would not allow us to override it
so I modified it to a final method and I
did compile the code now I go back here
I'm gonna take a look at the bytecode
now before I go into the bytecode and
show you what's in the bytecode remember
the last time this info instance method
call over here was in
book virtual what do you think it's
gonna be this time since we marked it
final in what final well okay good try
but there's no call calling book final
but hey why not right
any other ideas a static mmm a special
right we we are throwing these ideas and
guess what I did when I first thought
about it that is exactly what I thought
about as well I didn't think anything
different from what you thought about so
let's dig in and see what it is doing go
to the main method one more time and
take a look at what it is now you feel a
little cheated don't you and I felt the
same way as well I said what in the
world is this why is it in book virtual
and not anything else was that it must
be something wrong isn't it it why is
should it be in virtual I say that again
for me sorry that's okay okay okay fair
enough fair enough right right sure but
but we did say final and so the
implication I'm kind of leading into is
well because its final it will never be
polymorphic then why go through the
overhead after invoke virtual call
because it's not polymorphic well the
reason simply is just because it's
invoke virtual let's get back for a
second here let's go back and say this
is no longer final in here right so I'm
not working this as final well when this
is no longer final if I go back and take
a look at it it's still in book virtual
however the JIT compiler says hey when
I'm going through this invoke virtual
call the JIT compiler kind of looks
around and says is there an
implementation of this method right now
and the answer is no there is none so it
actually in lines this call right away
even when the method is not final in
other words we are more
focused on optimizing when it's final
but the compiler JIT compiler smarter
than that its optimizing even when it is
not final
so as a result the Java compiler said
why should I work really hard that folk
over there is working really hard so
I'll take it easy today so the Java
compiler doesn't have to work hard
because the JIT compiler really is
working hard and JIT compiler will
optimize this to inline call right away
but if you load up another class at
runtime then the JIT compiler says oh
wait a second
that inlining was really a bad idea it
worked for a little bit but no longer
this will work anymore so it quickly
dirties that call and the next time you
make the call it would be polymorphic in
that case final is purely a cold level
constructs to say you better not mess
with my class at the bytecode level it's
um it doesn't seem to care at all so the
model of the story here really is
there's a lot of stuff that's going to
happen in terms of these optimizations
that the compiler is gonna perform and
in short the real objective here is the
more good things you give to the
bytecode level the more optimization you
can get from the JIT compiler the less
you give to the dead compiler the less
you're gonna get out of it so that is
really the focus of what we won't start
with so what can we do about it
well it also turns out that the four
methods I refer to invoke static invoke
virtual invoke special and invoke
interface both all those four methods it
turns out are extremely statically typed
and that is the real static typing in
Java is not in the Java language alone
it's in the JIT compiler the invoke
static says wait a second do you have
the permission to call this method is
this a public method on what the scope
of this method is are you passing the
right kind of arguments to this method
it performs all these type check and
makes the call the very first time but
if you're calling this in a loop of some
kind it's not going to go through the
overhead of checking this over and over
it'll check the first call time and it
will do optimization at that point to
say
this has been verified this is good I
can continue further from now on so
it'll perform the checks quite a bit in
the same case if you're calling invoke
interface it has to perform one
additional check to make sure that the
interface you have received is
comparable with the reference that you
have on your hand meaning is the
reference instance of that interface
it's got to perform instance objects as
well so in other words all of these
calls perform quite a bit of a checking
type checking and verification at
runtime so given this this is all great
and work really well for Java but there
is one other thing that's been brewing
around us and that is that we have an
explosion of languages on the JVM right
now there are over 200 plus languages on
the JVM so the question is what about
those other languages well what's the
big deal about it so let's take a look
at an example here I have a little bit
of a groovy code I really enjoy
programming quite a bit in groovy and
several other languages so I'm gonna go
ahead and write a function here called
let's say play a play here and I'm gonna
say you know stir or some kind of a
Greek message and I'll call this as call
shout for lack of better words and I'm
gonna go ahead and call the shout method
on the Greek so I'm gonna say greet Dart
shout and then I'm gonna catch the
exception and just print the exception
for us if there was an exception now in
this particular case if I were to call
set greet over here let's go ahead and
say greet is equal to hello and I'm
gonna call the method here called call a
shout and pass greet to it you can see
that this code is gonna fail because
there is no such method called shout on
the string we all know this right if you
look at the JDK there's no method called
shout on the string so it says I'm sorry
I cannot support it and it actually
failed but on the other hand in
languages like groovy we can come down
to the object and then we can say Mara
class dart shout and then I can inject a
method into the class at runtime so now
I added a method called shout on the
greet object right away and now I call
call shout one more time and passed the
greet do
and notice this time around the result
is very different on the very first call
it bombed on us saying I don't know what
this method is but a second that later
it was able to call the method and
convert to uppercase so in other words
this compile the code right here failed
the first time and does not fail the
second time but the question is which of
those four calls we talked about is this
going to be and the short answer is none
of those four calls because all those
four calls perform very strong type
checking and they come over to this a
call and say what are you trying to call
and it finds its calling a method called
shout which doesn't need to exist on the
string and it will drag it by the collar
and kick it out of the building and say
don't ever come back here again because
this is not a valid call to make so in
other words because of static typing at
the compiler level these languages
cannot make use of those four
instructions directly to make the call
and what about other opcode that may be
in the in the bytecode level none of the
other are going to help with this either
so what did these languages do
unfortunately for these languages to do
their job they had to go around about
now what does it mean they had to go
around about well let's quickly take a
look at the groovy code that we have
right here you can see that the groovy
code was not really that much over here
but if I go ahead and compile this
groovy code using the groovy compiler
without any optimization at all so I'm
kind of showing groovy and it's in its
bad way right now just to illustrate the
point but there are other ways to
improve groovy as well nevertheless but
then if I take a look at the groovy
compiler generated code and I say Java P
minus C on the sample one more time and
take a look at it you can I don't even
have to extend Oh make this larger
because all I want to do is scroll to
you and show you how much bytecode
attack to generate right there so we
don't have to really look at the byte
code to see there was a lot of byte code
so what's the consequence the
consequence is when we write code in
languages that are dynamically typed and
can extensively make use of meta
programming and type information at the
same time they first of all have to
generate a la
a bytecode to get around this particular
problem rather than calling the methods
directly they call it's called something
that will lookup and dispatch at runtime
which is poor performance as well so a
lot of byte code means bigger jar files
more time to load things more time to
process and poor performance as well and
that is the problem we have with these
dynamically typed languages now what can
we do about it well the JVM folks could
have done two things they could have
been in denial and said we don't care
about these languages or they could have
said is there something we could do
about this and I'm so glad they took the
second hire out and they said we're
gonna do something about it let's help
our brothers as well and let's make this
work for them and that little act of
kindness really paid back heavily as
we're gonna see here today so this is
really a fun journey in looking at into
the from the morality of human life in
psychology if you want to look at it
that way so they decided they're gonna
do something about this as a challenge
so they created invokedynamic so what
does invoke dynamic just to be sure
invoke dynamic was first tossed around
as an idea to improve these languages
but that's not what it is today
invoke dynamic is a way to do things
better for every language out there not
just dynamically typed languages so the
word dynamic in invoke dynamic is really
not about dynamic as in dynamically
typed languages it is dynamic as in
we're not statically sitting around and
tying two things we would late bind and
make decisions at one time that's what
dynamic really means in this context so
a way to think about invoke dynamic is
what does it really do well David well
said in computer science we can solve
almost any problem by introducing a
level of indirection so in other words
rather than calling a function directly
let's make use a function pointer that's
correct
let's make use of a function pointer
finally Java has the capabilities of the
C language isn't it so I'm just making
fun right here but the point is that it
gives us this power of indirection
really and we can have this function
pointer but what's really cool about
invoke dynamic
is not that we are going to use a
function pointer but this function
pointer can be tied to something at
runtime but it can be retied at
different times what does that really
mean we can be retied at a different
time the point really is this imagine
like a train going on a train track you
said that train on it goes at about 200
miles an hour
absolutely no problem but you don't want
the tracks to be static all the way
through you want to go to different
cities starting at different cities so
how do you really do that
well how do the train systems manages
well there's a track and they send a
train through it at high speed and then
as soon as the train passes a little
foreman over there our mechanic over
there presses a button and that tracks
kind of shift a little bit like this and
the next train without slowing down
without stopping zips through but goes
in a different direction than going in
the former direction so think of this
train track which can kind of just a
little bit invoke dynamic exactly is
that like that it will tie to a method
call and then as long as you don't
change it you can be zipping through it
really fast
there is no overhead at run time at all
because this has been bound to a
function and that's been character
captured at runtime depending on the
particular virtual machines decision at
any given time you decide you want to go
to a different method like what for
example if you notice in the groovy call
right I made here I can come back to
this method one more time and I can now
say in here I'm gonna repeat these three
calls but this time I'm gonna modify the
shout method over here like if you
really got your toes hit somewhere
you're not going to shout really like
normal you're gonna probably do that so
in that case you're going to see that
the output is going to be different
along the way as it's going to type out
and you can see that the shout method
has been redefined in this case and we
can you know you know do whatever we
want to do as an implementation and see
the output you can see that's a very
different output so the moral here is
that the method can be bound to a method
at any time but with a flip of a switch
you can dirty that particular call site
and immediately it can go to a different
location the next time you call and then
from then on that's going to be faster
because it can cache though
calls together so that is essentially
what invokedynamic is going to do now
now all this said very nicely though but
unfortunately I cannot really show you
any of those from the Java code so we're
gonna simulate a little example to just
play with this to get a feel for it
you would not write code in Java to do
this really but the point I'm really
making is it is for us to get a feel for
how this would really work at the
bytecode level so let's create some
examples to play with this
so I mentioned about the called site at
runtime so invoke dynamic has two parts
to it one is the called site and the
other is the method handle or the method
pointer which is the evaluation part the
called site is like your side of the
handle you say I want to call through
this location here and the method handle
is the one that results at runtime and
then the caching happens in the call
site and any time you want to change it
you go to the call side and say dirty it
and the next time you go to the call
side and say call it says well okay
that's dirty reevaluate and then in the
cache it and now you can call from now
on so there are two parts to it so what
does the invoke dynamic really do invoke
dynamic will first of all create a call
site it will wire up the target to where
you really want to call and then will
cache that particular target for
performance reason and then every time
you call this it keeps going back to the
call over and over until you say I no
longer want to call that I want to call
it something else then the rewiring
happens and the caching will happen one
more time so in order to understand and
appreciate this let's take a look at an
example in Java and like I said again I
want to emphasize you would rarely write
this code in Java ourself we wouldn't
write it but it's a fun to really play
with and see how this works so for this
there's the in book java.lang invoke
package which i want to use here and
we're gonna use the so-called method
handle which is really the handle into
this object a function pointer for us to
be able to call things so how would I go
about using this so let's get back to
this Java code we had a minute ago and
remember how we call over here the
instance method and the static method is
what we call here a few minutes ago you
can see those two calls being displayed
there but instead of going through this
right here we're gonna go through it in
in a roundabout way to get the
flexibility and so what I'm gonna do
here is I'm gonna first of all say
method handles over here and then dart
look up so like think about this as a
registry that you can go and pull up
things and you can create pointers to
not only existing functions but it can
create pointers to functions that don't
exist what does that really mean
so instead of thinking about a function
as well let's take a look at that static
method for a minute or take a look at
the instance method for a minute if I
ask you about the instance method you
would say that is a public method it
returns the double its name is instance
method and it takes one parameter called
double well we can define it that way
but if you want to look at it in a
lambda form we don't care about the
method name anymore because what's
really important for us is the signature
of the method and not the name of the
method and what's in a name if you want
this table to be lifted you don't really
care the I mean not care as and you
don't care evenly but you don't care who
the person is as long as a person is
capable of Google doing the job for you
so what we care about here is the
signature of the method and not the name
so the method pointer binds us to the
real essential signature which is I want
a function he is an instance of static
that's important what are the parameters
this function takes and what is it
return and what about the name of the
function the name of the function is
called ID C or I don't care and we don't
really have to worry about the name
itself so we want the function pointer
like that so notice what I'm gonna do
here in the code I go up to the lookup
object right here and say hey look up
can you go ahead and find me a static
method on the sample class please and
the name of the method is called a
static method and the method types is
going to be over here
a void class and it doesn't return it
returns a void so the way the method
type is given is you specify the return
type first and then any number of
parameters remember a function could
have zero or more parameters so if a
function has n parameters you would
specify n plus 1
values here where the first value is the
return type and the end values are the
parameter types in itself and now that
we have a method handle on our hand I'm
gonna store this into a static method
handle for lack of better words I'll
just call it that and then now that I
have a sample class over here with that
method and I got a handle on it
oops I have a handle on it what I'm
gonna do now is simply say that I want
to call the static method on this object
and then I'm gonna say in book exact and
I don't have any parameters to pass and
it's complaining that I'm not handling
the exception there are two ways to take
care of the exception one by
specifically taking the exception and
handling it or we could do it like the
Java programmer way where you can simply
throw the exception walk away for now
right so we could either do it that way
are the more appropriate ways to handle
exceptions I'm of course being very you
know a joke ful here but we do want to
handle exceptions properly absolutely
and the reason is because we are trading
what we would get at compile time now to
an exception we'll get at run time so we
got to be more rigorous about this so
let's go ahead and run this little
example and see what it does and you can
see that we made a call to the static
method one more time so there are two
calls to the static method one directly
and one through this API let's try this
one more time so I'm gonna go back to
the lookup method now and say finds
virtual method in this case again on the
sample class again and what I would like
to call here is the instance method and
I would say method types over here and
the return type is double dot class and
the parameter type is also a double dot
class so we passed in both of those
values and I'm gonna store that into an
instance method handle right here
however I cannot call this use this
handle to call the method right now
because this has to be bind to the
sample instance before we call because
instance method require an object to
call the method as well now that we have
the second in a handle here I'll call it
as instance method a handle
let's say handle for sample right here I
allow variable names like this because
finally there are things that are longer
than my name and so right
I gave that name and finally I'll say
instance method handle for sampled art
and then I would say invoke exact and in
this case I'm gonna spray a faster word
for let's say well 2 as the other one is
well unfortunately when I run this code
you can see that it actually failed and
it gave me an error what happened well I
call the invoke exact method as a method
with an attitude so it not only says you
can call me it says you better give me
exactly what I expect because I'm not
gonna do any adaptation or casting for
you and not only that what am i what am
i to return make sure you put it right
back where it belongs also otherwise
I'll follow you and and give you a hard
time that's what the invoke exact method
says so in this case to make this work
we had to say in a 2 dot oh because it
expects a double and then we have to say
result over here and I'm gonna say
result equals and then pass it to a
double as well and set it and then when
we are done with that we can present the
result out and run the code as we can
see here and it gave us a value of 4.0
and the bottom two calls we're done
through invoke the the called site and
the method handle and the top two we're
done directly instead of calling invoke
exact we could also call something
called invoke and invoke is more of a
friendly method than invoke exact it
will all of you reduce something and
we'll do the casting for you and if the
casting didn't go very well you it'll
throw exceptions and stuff like that
obviously there's a performance
implication to this you are calling
invoke exact you better give exactly
what's needed and then of course and
what makes more sense right because the
compiler can do type checking already
and then call an invoke exact whereas in
a dynamically type language maybe we
want to go for an invoke rather than
invoke exact so it uses the fav flavor
of the two and we can pick and choose
what may make sense so so that is what
we saw so far in how we are able to call
these methods through these particular
instances methods and static methods
that what we saw so so far so good
oh please yes
a great question great question
absolutely right now the difference is
this in the case of reflection
you only get reflective methods to
existing methods method pointers can be
created to something very dynamic that
didn't even exist yet
but it can create at runtime second
reason why this is better as as much as
reflections are optimized and good
reflection still is a library API so in
other words you're calling seven methods
putting together an array of parameters
and sending it and the job of JIT
compilers gonna look at these 70 code
and say all right I'll optimize this
optimizes optimize this optimize this
and the collective optimization is not
good because it individually optimized
it whereas now you said hey I want to do
this operation you are being by intent
here and so this becomes one massive
call at the bytecode level and the JIT
compiler says cool I know what this
means in my language I will optimize
this in cache it that optimization and
caching doesn't happen so think of this
as the reflection plus plus or
reflection on steroids or the way
reflection should really be if it was
handled at the bytecode level then at
the language level fantastic question
there was another question here I
thought please correct well that's
purely a lookup way but there are other
because I'm being lazy here but you
could also create a method handle off
the bat and then start specifying things
to the method handle remember it
remember method handle is the pointer
there are seven ways to get to the
pointer one is my easy lazy way too
early on a Wednesday a Tuesday morning
or Wednesday morning I don't even
remember now as you can see that's the
reason or I could say I want to create a
new method handle and start specifying
things more more coding effort for that
really really good point to erase yeah
right so the question is should we
really use this in place of reflection
the answer is not really because the API
should have evolved to make use of this
because a Java code level we don't want
to go to this I would argue this is
pretty low level to be doing in Java
code itself but I'm sure as time goes on
more fluencies will come in and then the
optimization will begin to happen
without us Java programmers have to
spend this much effort writing code so
that's why I was kept emphasizing you
would not write this code in Java but
but the compilers would be doing
equivalent of this under the hood to
give performance and that's where we
really want to be as well okay now yeah
I mentioned earlier you will not have
any use for this at all and I said that
hoping that most of you will leave the
room but you all kind of decide to stay
to say that you really are geeky and
want to know and so I really feel bad so
as as active thank you for being here
I'll give you one thing you can actually
use how about that so and that is called
multi methods I love multi methods multi
methods are polymorphism on steroids
let's take a look at what this really
means with an example so what I want to
do here in this example here is I want
to go back and write a class let's play
with this for a second and I want to say
I want to write a class called let's say
a base over here and the base class
hasn't met the call fu1
and all that I'm going to do within the
foo one method notice it is taking a
double value and all that I'm going to
do within the foo one method is simply
output over here base : : foo one I'm
gonna go ahead and copy and paste this
method one more time and I'm gonna make
this method foo two over here which is
just simply gonna print food to also
great now I'm gonna take this entire
class that we have right now and make a
copy of it one more time and this time I
will call this one as derived over here
and then I'm going to say derived and
let's go ahead and say this extends from
base and this time I'm gonna change this
to a int rather than a double so just to
summarize there are two methods full one
and four to full one is simply
overriding with the same C
mature double photo is a bad boy it
changes a signature to int instead of
being double so keep that in mind now
what I'm gonna do in the code is I'm
gonna get back to this main method here
let's go ahead and create an object off
derived but we're gonna save it our way
into a reference called
base so let's go ahead and try that out
so right about here I'm gonna simply say
derived sorry base B equals new derived
and I'm gonna call B dot foo one with
the five and B dot through one also with
a 5.0 so notice how I called the foo
method twice but I called with an
integer and a double we all know what
polymorphism is so when I run this code
you can notice over here in this code
I'm passing the method foo one here with
a five and a double value here which is
who want to take I directed it properly
and then I have a few one which also
takes a double over here so I got this
overriding here it would actually help
to change this to derived as well right
too early in the morning so right there
this is derived as well so let's go
ahead and see what the output is just
now so when I go ahead and try this
little example no surprise over here it
called the derived through one and
derived through one why because well the
last time we checked that's called
polymorphism right great but on the
other hand I'm gonna save a food art a
bead art food two with the five and call
B dot food two with the 5.0 now notice
what's going to happen when I call the
method foo - even though they were very
similar food - had a different signature
and they're derived than the signature
in the base class so when I called this
method notice we when we run this code
it ended up being something different
than what food do is so notice how while
the foo cause went to derived the food
two calls really went to the base now
why did it go to the base even though we
wrote this method foo to here in fact it
is taking an int well make no mistake
this call is polymorphic if you look at
the bytecode level you will see invoke
virtual definitely but what happens
unfortunately is
when the compiler the Java compiler is
compiling this code the Java compiler
says hey go call this method called futu
and the compiler says hang on a second
let me check
I only know right now that B is a base
type goes to B and says you have met the
called foo - oh yes I do it's an
instance method great it's invoke
virtual it's polymorphic and what should
I pass to you oh I want to double and he
says darn it I have an int on my hand
but no worries at compile time I'm going
to convert the into a double so I can
call the method because a conversion
happened at compile time at the run time
it doesn't matter that you have a 5 as
an end because a conversion takes place
already and as a result it is
polymorphic but only calls a method on
the base class and not the method on the
derived class I'm making sense ok so how
do we solve this problem let before we
try to solve this problem let's grab
this code completely and then let's go
over here to groovy code and I just
pasted the code as it is I didn't change
anything so far and just to remove a few
ceremony I'm gonna remove this curly
braces from here and I'm gonna remove
this main code from here as well because
I don't really care about main here so
that's all I did
everything else is the same over here as
you can see it's the same code we saw a
minute ago
and then finally I'm just calling this
method over here when I run this code
however notice the result is very
different in groovy in the case of Java
you notice it called only the base
methods in the bottom in the case of
groovy it's calling the derived and the
base now this is called multi methods so
what is a multi method sometimes you
could call it multi dispatching multi
methods or multi dispatching ears
polymorphism on steroids what it really
means is polymorphism says the method
I'm going to call is based on the type
of the target object at runtime
that's what polymorphism says right so
in other words that's that's why this
meant to derive because at one time be
is referring to a derived object and so
it said I have to call the derived
method that is what polymorphism says
multi method says the method I call is
based not only on the type
the target at runtime but also the type
of the parameters at the runtime so it
is multi dispatching because it
dispatches not just based on the target
type but it dispatches based on the
target type and the parameter types as
well
it considers multiple things to make the
decision and hence multi dispatching or
multi method so far so good now the
question is why do I care about this
this is one of the features that you
would not use when you don't when you
can't use and the minute you start using
it's like the cell phones right how do
you live without it right and that's
kind of the way you feel about it it is
once you start using it you want it I'll
give you an example where I used it I
have a message passing system where I
can get different types of messages XML
message JSON message binary message
string message now I have an interface
called process and what would it take or
object on the top now I have one class
which only processes XML great no
problem another only process a string
not a problem in each of these what
would I do I'll write the method called
process I would cast away the message to
a string or an XML and then I would go
about using it but then I had one class
which process three types of messages
XML binary and JSON guess what I had to
do process object message if instance of
string do this if instance of XML do
this if instance of you know binary do
this and what does the code begin to
look like a procedural code and then you
suddenly ask yourselves how did I end up
in a procedural code while I was
programming in an object-oriented
language right so this is kind of really
a bad pace and you tell you herself
wouldn't it be nice if I did not write a
process object method at all and I only
know three sweet little methods process
XML with an XML bar parameter type
process with the string type and a
process with a binary tied and you are
done no more it felt statements and
procedural code wouldn't that be nice
well multi mess it can do that for us
how can we use this in the code so what
I'm going to do here to show that effect
is I'm going to come back over here and
show the difference of how we can
all this so-called multi-method and one
what do I want to call on B and what do
I want to send five and what's the type
of five it's an integer so in that class
so right there I passed it and then I'm
gonna say call multi-method one more
time on B again 5.0 again and what is
the type here double dot class and you
can actually make this a little bit more
intelligent by actually finding the type
internally if you want to but I'm not
going to go through that pain right now
so now I'm going to go ahead and
implement a call multi method this is
going to be just an object with an
instance over here this is going to be
just the object which is the data that I
want to pass and then finally this is
going to be a class which is going to
take some value we'll call it as data
type over here so that is all I have so
far
now I'm gonna say method handles dot
lookup so I got me look up on my hand
great now I say look up dart and I'm
gonna say find virtual on instance dot
get class and the MIT that I'm
interested in is food to which you can
also pass in as a parameter if you want
to the data type is going to be met the
type start data type avoid dot class
because it doesn't return anything and
the data type and then finally I'm gonna
call on this a bind to method so here is
my binder to the instance itself and
then I'm gonna call the invoke method on
it and send their data type on it so so
that is the call that I make right here
is I've gone through and made all this
call so I obtained a pointer to this
handle right here in fact let me go
ahead and save that our way here we'll
call it food to handle for a minute then
I'm gonna say food to handle dart bind
it to the instance and then on it I want
to call the invoke method and send that
data type to it right there I want to
call that method so let's go ahead and
take care of the exceptions one more
time and then come back to this code and
run it one more time and let's take a
look at the output we get this time ah
let's see what the exception is we can
handle it so wrong with the conversion
method handle to avoid let's go ahead
and fix it
so in this particular case it is
complaining that it couldn't find the
method
over here for whatever reason of the one
that takes an INT let's make sure it is
actually valid so I have an instance dot
get class which is going to be the type
of the object I'm passing N and then I'm
going to say method type is void class
and the data type and the data type
should be an in class which is a double
class so let's see why this is
complaining so Iran met the type say
looking for me of course wouldn't that
be good absolutely
thank you I love pair programming that's
why right so because I'm kind of blinded
when I see that right absolutely you're
right so that's what the complaint was
and there we go thanks for your help so
right there it says right here notice
the difference between these two and I'm
sure you notice the last output you see
here is exactly what you saw on the
groovy side as well because it's calling
the derived in the case of the right
method a signature and the base in the
case of the right method signature
that's polymorphism with multi methods
whereas the second one is the poor man's
polymorphism right that's what you're
seeing right there
so far so good yeah please oh of course
life is no fun without without having
the flexibilities where with I mean
there's no free lunch but here's the
question he is performing such a big
deal all the time so there's the two a
couple of measures right you cannot do
it when catch sit down or you can do it
if you really need it but it is the
price you're gonna pay for it and I
think that's a choice we want to have as
programmers and we are smart enough to
realize that and decide when it makes
sense versus when we don't make sense
but but remember this without this
there's the enormous degradation in
performance for those languages so it's
a very big boost for them and places
where do you really need this you're
saying you know what I'm dispatching
messages how what is the cost of this if
the cost of it is of wash in my
application I would rather do this than
being forced to go through the if-else
statement over and over this code makes
it more extensible so your point
well-taken
yes there is a performance consequence
but I always ask myself what is the
consequence of performance if it is
negligible I would rather use the
flexibility if it is prohibitive then I
would go back and optimize at that point
and not before
any other questions
very good so we looked at a few things
so far are you having fun so far
yeah so it's a very interesting concept
it's lovely how they have done this
really nice
so given this let's talk about one more
thing what if we can make the calls a
little bit more dynamic wouldn't that be
good so again I'm trying to put examples
together where we can see this at the
code level just to get a feel for how
these languages would do things under
the hood so let's take one example to
see how we can do this but before that
we got to understand a little bit more
about call sign we talked about the in
handle method handles and the method
handles can tie to a method at compile
time and then rebind to at a runtime
what about the call side a call sight is
really an object that will bind to a
method handle and the call sight comes
in three flavors one of them is called a
constant call sight now why would you
ever care about a constant call sight
what a constant call sight will never
ever change once you create it and you
say well if it is really not never gonna
change
why would you then want it to change in
the first place why would you need a
invokedynamic and all those good stuff
well the reason is there are two types
of constants in this world a constant
that you know at compile time and a
constant that you know what run time you
may be creating an object and you know
this value only at the time of creating
this object or calling a method but you
don't know this ahead of time so in
other words it wants to postpone this
constant creation until you know what
the value is but once you know where
it's gonna bind to that value and never
let you change it that's what a constant
called site is so these are very useful
for the constants that you want to bind
in the code then there's mutable call
site well constant call site one more
time is going to be extremely thread
safe because it can never change so
there's no locking involved in it
mutable call site is something that can
be mutated you can create it and this is
a train track example I showed you once
you created the Train keeps running fast
on it but at some point you press a
switch it points to a different
direction and the next time the train
goes it goes through a different track
and then you rewire at the time but the
problem
mutable called situs as the word
indicates it's mutable which means if
you have multiple threads running you
got to worry about concurrency and
threat safety they handle it extremely
well
they say it's your problem right so
there you go so the moral of the story
is if you're using mutable called side
either don't do multi-threading in a
single threaded application that's is
very safe or if you're going to do
multiple threads you have to handle the
synchronization issues the third option
probably the most undesirable is the
volatile called site as the name
indicates it is going to be extremely
thread safe with the enormous
performance penalty you're gonna pay so
this is for people like me who say this
is too early in the morning I want to
get a prototype to work first if it
really works I'll come back and worry
about other things later on so that's
what a Bala to call site is because it's
going to go to the memory push through
the memory barrier all the time it is
going to incur the overhead for doing
this let's take a look at an example of
how we can use this with with one simple
example making a call dynamic so in
order to understand how this call is
going to work let's go ahead and create
a little example of a method I want to
call repeatedly over here and and see
how we can use this so let's get rid of
most of these guys we don't care about
right now in this example and get to a
little function that we gonna create
within the class so the function I'm
gonna create right here is gonna be a
method called a tick method so let's go
ahead and create a method called a tick
and all that I'm gonna do within the
method call with pick is simply say
thick that's all I'm doing
right so similarly I'm gonna go ahead
and create a method called talk so that
is my talk method and all that I'm gonna
do within the talk method you simply say
talk now having said this what I'm gonna
do here is I'm gonna create two handles
for our use so I'm gonna say public
static over here called let's call it a
stick let's got it's a method handle so
method handle we'll call it thick handle
and I'll also create one more over here
which is going to be called as a talk
handle so there we go we created two of
them now what I'm going to do here is
I'm gonna go ahead and use these methods
so I'm going to say create called site
and this method is going to return a
called site for us let's go ahead and
create this method so in this method I'm
simply saying give me a call site now
what does this method really do the
first thing I'm going to do here is go
get a method handles first of all
perform a lookup operation on it and the
lookup is going to return to us a method
handle so in this case find static on
the class sample of course that we are
using the MIT that I'm interested in is
called the tick method and the method
types is going to be just a boy class
and I'm gonna go ahead and store this
into the tick handle itself that we
already have on our hand so right there
we store it away
similarly I'll create one more handle
here we'll call it the talk handle which
is going to refer to the talk method
itself so that's all I have so far and
the last thing I'm gonna do here is I'm
gonna return new mutable called site and
the call site is gonna handle to the
thick handle that's all I have so forth
now let's go back to the code right here
we're gonna call the call site let's go
ahead and save it into a call site then
I say called site dart dynamic invoker
and I'm gonna get a handle on this guy
and I'm gonna iterate over ten times
through this code and all that I'm gonna
do is method handle dart invoke and then
I'm gonna take a break so thread dart
sleep so this is going to take a second
delay and then it's gonna just go
through so notice that every second it's
a stick this reminds me of something the
Big Bend Tower a beautiful tower in
London I was visiting big men last year
it was beautiful but then I came to know
that there's actually a twitter this is
really sad there's a Twitter account for
Big Ben somebody has created and all of
this account does is every hour on the
hour
it says donk at 2:00 o'clock it says
dongdong at 3:00 o'clock it says Doong
Doong Doong you can see what happens at
12 o'clock the shocking part is not that
it says that the shocking part is there
are 450 thousand followers to this I'm
like what is this world going to write
this is crazy anyway so this is
essentially printing these messages out
here as you can see it said take but
what
has been nice to be dynamic without
changing the handle itself how could we
make that happen
notice I'm not gonna touch the handle
anymore at all
but instead what I'm gonna do here is
I'm gonna simply say you know a switch a
called sight and there are several ways
to do this I'm just giving you a plain
vanila approach there are so many wealth
of API that's around this but this is
just one example and I'm gonna go ahead
and send the call site to this guy and
the index value I and notice I'm not
touching the call a method handle itself
directly so here's my call site and
here's my index and I'm gonna say if
index is equal to even for example then
I want to say called side art set target
is gonna be a thick handle otherwise I
want to set the called site set target
to a top handle so now if I go back and
ride around the code we can see that oh
wait a minute it
oh there it is a little delay there
because I'm a count error so we could
see here it changes the value I'll
change the stock handle so we can
actually see that so talk handle and
this is going to be my pick handle and
you can see that it's gonna flip through
every switch through this so you can see
tick and talk and take and talk just to
wrap up this one here real quick we
could do one more thing if index is
equal to eight then I'm going to do
something that doesn't even exist kind
of going back to your earlier question
I'm gonna say a runnable equal and I'm
gonna say runnable equals and this is
going to be just a method called a
system dot out dot print line and this
is going to simply say tada now in this
case I'm gonna go ahead and say method
handle start lookup and I'm gonna ask
the lookup to give me find virtual so
I'm gonna ask him to find me a virtual
method on what a runnable dot get class
the run method I'm interested in because
again going back to earlier question I
could use other ways to get to the
method itself and then finally the
method type over here is going to be a
void class and then I'm going to bind
this one to a bind
- the runnable I have on my hand and and
that is the handle that I've created so
a run handle let's call it as run handle
so now that I have created a run handle
I'm gonna simply say over here called
sight dart set target to run handle I
want you to pay one more close attention
here which you may not realize as you're
looking at this code the tick and tock
are static methods but run is an
instance method and notice we were able
to send the pointer to static methods in
the beginning now we are sending a
pointer to an instance method a prove
that it doesn't really care it only
cares about the signature of the method
at all but of course at some points it
may worry about static versus dynamic
difference re instance depending on the
context but not in this particular case
so I'm running this and you can see it
goes to can talk and they can talk and
then finally at the very end of this you
would see that it calls the tada method
to show that it was able to be switching
over dynamically if I were to stop this
presentation right here we will leave
this room saying all right great
the guys were really good they had a
kind heart and they gave feature that
will improve the performance of dynamic
type languages ie I'm really excited
about this because I program in those
languages or I don't care less because I
don't use them however this is kind of
where you have this little thing more
morality in life if you do good things
to other people it pays back heavily for
yourself and and that is what was a
great a surprise for me is the feature
where invokedynamic is used the most
today is in java itself a heard Brian
gets talked about this last year he said
we could have created a solution that
will take us home for dinner and that is
we could have just wrapped all the land
experience as anonymous inner classes so
to understand what that means really
let's do one more quick check over here
let's go back to this code for a second
and let's go ahead and call three
methods I'm gonna call here to play with
the very first method I want to call
here is going to use the traditional
approach so I'm gonna call a play one
method over here on the object so let's
say sample here and I'm gonna save it
away a sample and I'm going to say
sample dart play one and what does this
play one method do
in the play one method I'm gonna say
list integer and then we'll call it as
numbers over here so we'll say numbers
equals an array is start as lists and
let's give a bunch of values just three
values is enough for our purpose and
what I'm going to do in this example is
that I'm gonna go ahead and use this
actually let me move this into the class
so don't re implement it right so what
am I gonna do and play one method I'm
gonna say numbers dot for each new
consumer integer and I'm gonna go ahead
and call the method on this which is the
apply math except method so in the
accept method I'm going to simply output
the value itself that we guard and this
is going to be the value so if I run
this code notice that here we have the
value being run it is one two three
let's go take a look at quickly the
bytecode information here for a second
so if I go back here and ask for the
value of the the bytecode information
notice it tells us right now that there
are sample and sample dollar one no
surprise to us right now let's go back
to this code for a second and imagine I
want to call this a few times for this
iteration and so I might actually do
something like this
I may call this a few times in the code
I don't even know how many times I
called but if I were to go look at what
happened now at the disk level I would
probably faint so this is going to be
really pathetic if all we did was go
from a lambda expression to a anonymous
inner classes we don't want to do that
well thankfully that doesn't happen so
let me roll back all of those changes
for a minute and instead I'm gonna write
a sweet little lambda expression here
value and I'm going to simply say system
dot out dot print line over here and
then I'm gonna simply say this is going
to be a value when I run the code it
does produce the same result as before
but this time around if you ask for what
is there notice how sweet that is there
is no nothing else other than one class
if you're curious about this Java P
minus C again and take a look at the
bytecode itself and notice that in the
bytecode
we have a sweet little function sitting
here called
lamda dollar zero and then if you notice
over here we have invoke dynamic and
invoke dynamic says I am going to at
runtime pick this lamda dollar zero
function I'm gonna instantiate an object
of consumer on the fly and I'm going to
tie it except the method right there is
except method on line number 49 you can
say I invert I its accept method to our
instance that I create dynamically and
morph the consumer but the first time I
do this I'll do it but it made it I'll
cash this so I'll go one go through the
overhead of creating an object over and
over and over making sense so even
better than this notice if I go back
here and say why go through so much
effort and rather than doing this I'm
gonna simply pass a method reference
which is already part of Java eight also
and I'm going to simply say method
reference then when I run this code you
can see it is still producing the same
result but the bytecode level is much
more sweet here because if you look at
the play method this time in the play
method all I have is simply a
invokedynamic one more time
but the invoke dynamic now says I will
quietly route it to a print stream
object that is there already and morphic
through rather than creating a klaris
separately and loading them off and then
if you look at the number of times I can
call it a few minutes ago you saw me
what happened when I called this
multiple times but now you can see I'm
calling it several times I don't know
how many times I'm calling again but if
I go back here or one more time and take
a look at the directory over here you
will notice it doesn't have any of those
and then if you look into the code
itself it doesn't have any extra methods
as well purely done at compile time
using invoke dynamic and at runtime it
is going to make it efficient you can go
back and study the performance
implications of these and see how much
the better invoke dynamic is and it's a
lot of fun to work with there is a talk
by a child's Nutter later today
I highly recommend that talk if you are
interested in lot
more details of invokedynamic because he
has emerged into this a lot and so you
can learn from it if you're interested
of course in the lambda expressions
there are plenty of talks today and
tomorrow also on the topic I really hope
you found this useful
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>