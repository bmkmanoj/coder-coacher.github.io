<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JAX RS 2 1 for Java EE 8 | Coder Coacher - Coaching Coders</title><meta content="JAX RS 2 1 for Java EE 8 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>JAX RS 2 1 for Java EE 8</b></h2><h5 class="post__date">2016-09-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/0KArzAbaPWQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay hello my name is Ed Burns could
everyone hear me okay all right all
right this talk is jax-rs 2.1 for java
ee 8 thank you very much for coming
today we really appreciate you choosing
our session there's lots of different
sessions to choose from and I'm very
glad you chose this one first a little
bit about myself
I am the servlet in JSF co spec lead
I've been a speaker at many conferences
internationally over the years and
written a few books enterprise Java
related books for mcgraw-hill and so I'm
happy to be talking to you about jax-rs
was a technology that I've used but
never had a leadership role in
specification lead
I'm also longtime Jersey developer so
basically I participated on Jersey since
version 1.1 which was released like
eight years ago
which is virus reference implementation
so here's our agenda for today we're
gonna set the context by putting jax-rs
in the perspective of where it lives in
Java EE eight we're gonna go over the
reactive API and what we have already
what we're thinking about doing in the
future some detail on server-sent events
which is one of the big-ticket features
in 2.1 we'll talk about Java EE
integration circuit breakers an HTTP to
present the roadmap which you've
probably seen already but maybe we have
another a little more detailed
information on it and some Q&amp;amp;A at the
end so we've announced jax-rs 2.1 a
while ago and the scope largely remains
unchanged for this one we will fold in
and make adjustments to better align
jax-rs with new Java EE eight focus on
micro services
containers another key aspects of the
AEA update that you'll see later on
Jersey will continue to be the reference
implementation class fish will continue
to be the release vehicle so everything
is going to be okay with jax-rs
I feel that it's a very important
technology if you're pretty much doing
rest in Java you're likely doing it with
jax-rs
the most popular alternative if you're
not using jax-rs is the spring rest
controller but the two technologies are
very similar in how they solve the
problem and how they present the
solution to the user or developer there
are quite a few popular frameworks that
depend or leverage Jersey drop wizard is
one of them spring you can use Jersey
with spring boot apache camel and eh
cache server are all using Jersey in
some form or another I'm very fond of
pointing out that a specification isn't
a specification unless there at least
two implementations out there and Jersey
is no exception to that rule
so I'm Jack's arrest is certainly no
exception to that rule with Jersey and
rest easy and apache cxf three multiple
different implementations there a brief
aside here a friend of mine from college
is giving this talk caveum happens to be
one of the technologies that's used in
Oracle's bare-metal better mental cloud
so I don't know if they'll talk about
that specifically in this session but
today at 4 o'clock over in the Hilton
they're gonna be talking about Java on
arm 64 servers so take a look at that
now the jax-rs history jax-rs history
has the kind of similar track to JSF if
you can believe it whereas it started
outside of Java EE and then got brought
into the platform so jax-ws was the
jacks hot jacks technology of Java EE 5
because that was 2008 and soap was the
new hotness at that time so jax-rs one
dodo was actually not in any Java EE
releases it was an independent release
not until Java EE 6 in 2009 did we have
jax-rs version 1.1 going into the core
platform
and that was jsr 311 it was you know the
way to finally do rest in Java because
at that point in time as early as 2009
rest started to heat up you know and web
services started to go down and soap
started to go down and just plain old
rest started to take off
it did have support for POJO based model
development it was HTTP centric and
container independent and all these
things that we come to know and love
about using rest for our web services
which do only gonna calm Web Services
anymore though then we had Java EE 7
with jax-rs 2.0 jsr 339 there we use the
rest client API we introduced filters
and interceptors asynchronous processing
begin validation which was a part of
Java EE 6 but we can use it in jax-rs
2.0 and json p which was the big deal
although the integration story for json
is going to get much better for jax-rs
2.1 which brings us to the next bullet
point 3 our ASR 370 and that is going to
be adding non-blocking i/o reactive
client server sent events all the things
we're going to talk about here I just
want to mention briefly innovation and
standardization as a longtime JCP spec
lead i'm i've seen firsthand the perils
of premature standardisation we
definitely believe that innovation
happens an open source innovation
happens where you guys are using the
technologies and anger and then we
eventually will take the best practices
and put them into the spec and say hey
this is we've president we've figured
this whole bit out as an industry let's
put it in the standard and see if we
could all use it so I wanted to use this
opportunity to show how technology
starts in Jersey and moves its way in
the jax-rs as we go along so jax-rs one
that X had just the basic feature set
and then Jersey for a long time had the
client API and filters then when we did
jax-rs 2.0 those moved from Jersey
into jax-rs so now we have some more
features in Jersey 2x that we're working
on we've got out there now and we're
going to be putting those over into
jax-rs 2.1 so we expect this cycle to
continue as we go forward let's talk now
about the reactive API okay so this is
what we've gotten Jack's are us 2.0
already and calling it reactive is sort
of an exercise for the developer because
though the requests are made
asynchronously what you do with them is
up to you you have to handle the
blocking or non blocking yourself with
this code here it's up to you when
you're gonna call future get so you can
certainly do that in an asynchronous and
reactive way but it's quite labor
intensive but it's people are doing it
and there's no problem really in 2.1
this is the first version of jax-rs
where we can actually take advantage of
features in java SE 8 most notably the
improved future and completable future
if you have a look at this API it's very
much it's very powerful and there's a
lot of features of about 38 methods or
so and it's really ideal for this kind
of sequential reactive invocation where
it's all about letting the blocking get
pushed as far away from the core of the
system as possible you want to push the
blocking as far up the stack towards the
user or whatever can is consuming the
API as possible so one of the things
you'll see with many usages of reactive
API is finding answers to questions that
are coming from the client and a lot of
times in order to get the final answer
from the client you have to ask multiple
different questions combine the answers
and then serve up the response and doing
that in a non-blocking reactive way is
the challenge okay so this example this
example actually shows how you can do
this reactive think in
Chuck's Rs 2.0 so it's actually okay
though if you don't see the code it's
intentionally too small to read it's not
something I want to explore but this is
using invocation call back from you xrs
2.0 which in which you have the
possibility to basically register
something which will be involved when
the responses are received
so this implements simple example you
can imagine that we have we want to make
two calls in parallel then get the
responses combine them into one single
stuff thing and send it as a request
entity to another remote service and
then print out the response there are
several challenges you need to face
basically if you have the invocation
callback the callback is called from
different threats so you need to handle
multi-threading to have received a
synchronization etc and basically you
don't know which which are come first so
you need to make sure that you are
storing these responses appropriately
and reading them in the when they are
available to basically not to block the
track so as I said you don't you should
watch this code and this is jax-rs 2.1
way so you can see that the change in
the in the api is quite minimal we just
added a new request builder which is rx
and by using this you will get a
completion stage instead of playing
future completed completion stage is an
interface which is implemented by
computable future and this actually
brings in all features at all dimension
so in this case I'm doing the same same
use case so I'm doing two parallel
requests and then combining these
completed completion stages into like
into one so I'm combining them into
single one and then registering a lambda
function which will be involved and both
of these completion stages are finished
when this is done I can safely read the
response I know it will be it won't be
blocked because I there is a guarantee
that I will already have these responses
and
making the next coat with a testicle
with combination of these responses and
then he's telling another one the
function which will process this call
and and prints out the response so you
can see that this code is much more
elegant than the previous one much
easier to read and more error-prone
which which is good because the more
code you have the more chances are of
introducing bugs so minimizing the
amount of code you have to write is what
we've been trying to do for years now
many people are already aware that again
it's kind of this conundrum because
we've got Java e8 and by the time he ate
is out se9 will be done but we have to
have a EA with se8 and you know that's
just how it is but boy would be nice if
we could use that flow api wouldn't it
well the design that's been proposed for
jax-rs two one is the rx invoker of T a
parameterised type and that lets you
leverage the java SE 9 flow api what's
i'll be covering in more detail during
the servlet talk today at 4 o'clock in
this room and so this is a very nice way
for jax-rs to be able to ship in the EE
8 schedule but if you are using SE 9 in
your runtime you'll be able to take
advantage of it so let's get into some
more code this is a simple restful
service showing how to generate a set of
items for a product list a wish list
right so we have 3 different sources of
information that we're acting with here
first we're asking user management
service give me the wishlist products
for the current user so for each user
get the product ID and for that Product
ID ask the promotion service give me the
promotion's that are available for that
product and then for each product get
the details for that product and combine
all those results into the list which
we're going to be serving up in response
to this nice get requests for wishlist
promotions
now to do this with the existing API
it's all of this jazz here and it's a
bit much to grow understand and parse
but basically let me see if I can make
this a little easier for myself to read
even right we're doing a get request on
wish those promotions and you can see
that we are producing the wish list
promotions with the suspended annotation
here and the suspended annotation is the
thing that causes the server to not
block when you are waiting for the
results of the resource innovation
method another thing to note is we're
taking advantage of server 3.1 and i/o
and Java SE 8 function pointers here and
also some completable future to get the
job done so it's still rather complex it
doesn't really compare to this previous
code in terms of ease of use this is why
the you know traditional blocking stuff
is so easy to understand your brain
knows things happen in a certain order
in reality and you can see that
represented in the code it'll be very
nice if we could take this simplicity
and combine it with the desired goal of
having this be reactive where you know
as I said before all of the blocking is
pushed out of the system as far as
possible I mean ideally if you're in a
web application the only thing that
blocks should be the browser's event
loop that's actually painting the
buttons on the screen and all that kind
of stuff that kind of blocking leave it
up to the UI code that's right in front
of the user blocking on the server side
you don't want to do it if you can avoid
it so we came up they actually this is
an idea that Santiago and Marek came up
with and presented the sketches of it
last year we're gonna give you some more
details here what they call declarative
reactive code so I mentioned the browser
as being an important factor here well
one way one of only two ways really to
get the right level of asynchrony in the
browser is to use server send events so
weird
flaring an SSC source and that's you
know when the browser says give me the
wish list of products what it gets back
from the server is actually a promise of
the products when they're going to be
coming in from all the different
services that are going to be aggregated
so let's assume the browser has already
made the request
give me the wishlist products the SSE
event socket is open now so we are
starting to get events coming back from
the product service so we get one event
for the product ID and we want to get
down to the point where we actually have
the list of promotions so how do we get
from here to here so we're gonna be
asking these two different services the
promotion service and the product detail
for their you know actions that they
need to do and then we're gonna be
combining the result down here and
serving it up so these different result
annotations here are showing us those
kinds of aggregation steps you
understand anything more about this yeah
maybe maybe please take this only as a
like proposal basically as the state
which we'd like to get in but it might
not be really part of the specification
we still we are so figuring out whether
this belongs to Jack Suarez or maybe to
some other specification which could be
done but most likely not in scope of e8
I guess anyway we would really like to
see this working at some point but yeah
kind of far from that yet and like you
will definitely need to write more code
to achieve this I guess at least for the
next release so continuing with
non-blocking i/o and the first thing I'd
like to say about from looking Kyle that
anything is not unblocking I think it's
basically about putting the word to the
different thread so you are not booking
your application application thread
because for example if you are on the
client side executed in some service or
somewhere else basically and you can you
can
less or get the response if you want but
basically when I'm looking the
application code on the server side it's
very similar and actually it's done in
jax-rs 2.0 supports it using this at
suspended annotation which you can get
asyncresponse and then once you are
ready to produce the actual response
also the reference method won't be
blocked and once you're ready to produce
the response you can call asyncresponse
a resume method and provide a response
entity and that's basically it so what
is from looking
non-blocking i/o is basically that you
don't really so each invocation you have
in your spec must be non-blocking
and then you can say that you have fun
blocking stack from networking Claire we
already have non-blocking HTTP
containers or HTTP transport that's fine
we even have service since version 3.1
it introduces nonworking a non-blocking
api if you if you are without
specification then you know sir what
input stream and a lot of good stream
which allows you to register some kind
of listeners which are notified there
are notified when when you can read or
write in non-blocking manner
unfortunately in jax-rs we don't have
anything like that and if you are
familiar with that API well enough or if
you ever try to consume or produce
entity in like lower layers so basically
if you if you were implementing for
example message with a reader or a
writer you get to the point where you
need to deal with input output stream
from Java API and that's the basically
the place where you are making blocking
calls input and output stream are
blocking API and if we want to state
that you can create access application
in an ongoing manner we need to get rid
of that somehow or enhance the
functionality basically to provide away
how you can check maybe before you bill
call this API whether the next call will
be blocking or not so that's what we are
trying to do in Jack's RS 2.1 it's not
really clear how this will be done yet
there is actually jax-rs 2.1 most
one was released last week and it
contains some of the ideas about how to
do non-blocking
especially on the client side so it
introduces and Ioana walker and i
override and IO input stream and output
stream and you might ask that why why
don't we use Sara watt input stream
answer without posting because it's
already there but simply because we
don't have we don't want to have the
dependency on Sara
API directly like embedded in Jack Cyrus
API because we still explain that you
should be able to run Jack size
application outside of Sara and that
might be something that is more
important and gets more important in the
future when we think about Java EE 9 and
breaking the things apart making them
independently deployable and what
they're calling just enough runtime and
so it turns out you know the separation
of concerns that we get by separating
our world into these different jsr s
that intentionally most of the time and
sometimes unintentionally don't talk to
each other at least you don't introduce
dependencies that are hard to break
later on Thanks ok so anyway this is to
lock in progress if you have any ideas
or any suggestions which you might want
to do how would you like to have it be
this done in Jack's address feel free to
send them email to Jackson for a
specification in support for service and
events there was a discussion whether
this actually belongs to jax-rs or not
but it was decided that it does it's
basically sub just it's basically
support for just under a media-type so
in that sense it kind of belongs there
server sent events is a protocol which
is part of the HTML 5 5 family of
protocols and it provides a
communication channel from server to the
client and it you can see that as a
synchronous channel so basically the
client will subscribe to to event update
and then the server can send when there
is such an event available
it will send it back to the client it's
protocol the assessee is text protocol
and each message has some metadata so so
metadata
it's event data I knee and retry event
you can see event a topic or something
like that data is actually payload
payload message ID is the sequential ID
of individual event and retry is
basically some kind of like
communication or negotiation about for
how long the client should wait until
repeating the connection when the
connection is lost or trying to connect
when the connection is lost service and
events are actually widely supported in
various browsers as you can see on the
table on the right side the only issue
is that for some reason Microsoft
Internet Explorer and Microsoft edge
browsers don't support service and
events I don't know why last year I
believe it myself oh my
check can I use and last year when I
when I did my research then it was even
like the Android browser did not support
service and events but it's about it now
so you can use it on Android but you can
windows box I don't know what's going on
but actually I saw an issue felt against
Internet Explorer and even Microsoft
edge and they are going to include it I
guess finally so so we'll see maybe next
year so service and events is like it's
built on HTTP so you can see that as
basically there is no difference
compared to standard request response
scheme but the only only thing is that
when you get there when you receive the
response then the response is actually
not not bound like it's not it doesn't
have fixed size you can expect more
messages to come so this is actually
output of Cairo which I did
one of our example so it really printed
out like this nice text output on the
console and these events were so
basically when I produce an event
produced and even then it was seen by
the client as it is now so I mentioned
earlier you're not blocking being the
best thing and there being two of two
ways to not block for doing web based
applications so server sent events is
one and the other one is WebSocket and
you can also consider Ajax to be a kind
of similar thing but it's it's this
whole notion of having multiple channels
open at the same time okay so how to do
service and events in jax-rs
again in recently published must-own one
there is a notion is basically this api
already present and so basically when I
when I think about WebSocket on the
server side and there are two major use
cases the first one is that I'm creating
some operation or I'm posting some data
and I want to be notified about the
progress of that operation so this is
exactly what is being done here you are
when this resource Mentos in is involved
then the SSC event output is created by
calling SSE contacts and basically there
is a new treads pound for dot action and
and instantly by channel and there is a
nice arrow which slide so please don't
don't start it's like this you need to
use concurrency yeah things like that
actually Kirk pepperdine made me put it
in okay so it's just an example anyway
so when this set is created then it will
actually use the created SSE event
output to produce these messages about
the state and once the status or the
operation is done opposed to channel
and that's basically that's how the
client can know the information whether
the operation was completed or not this
is basically just like a one-time event
so you have only single listener to this
event and you might want to do something
more complex I hope this is good enough
to eat well so there is another notion
and it's another class it's called SSE
broadcast that's basically more tied to
like exposing some messaging API or at
least part of it using HTTP so you can
use your clients or web browsers to
basically subscribe to some kind of
topic and then it will be sent to the to
the browser and underlying like the
event source can be given like some
messaging framework from some JMS or
something like that it doesn't really
matter this example just creates
artificial messages I guess so you are
subscribed when when client subscribes
to this event source then the event
source is the SEC amend output is
actually added to the broadcaster and
then you are not dealing with individual
that's an output but you are only
dealing with the broadcaster which
manages sending these events to all all
subscribed clients and the last thing I
basically wanted to mention about this
protocol Oh No but anyway the idea I
already mentioned in the message is
actually can serve as I like semi
reliable messaging because or it's
trying to solve that so if you use this
and it's optional in the protocol and
you can add sequential ID to each of
your events which you are emitting from
the server side and then client when it
loses the connection it it can include
this ID when reconnecting to the server
side and the server if it support this
feature you can reply the messages which
were which were sent or transmitted in
between of when this was reconnecting so
that's actually a nice feature and you
can what if you already have messaging
and you need to you need to somehow
as I see so the way to go if the one
region is good enough for you on the
clock so this was the server side jax-rs
supports service and events on the
client side client side as well
we have two models push and pull push
model is more like this in Dunedin like
vision and that's JavaScript API this is
very much in the same so you are
registering a lambda function which will
be involved when an event arrives to the
client the other model is pull and
that's basically you can you can
blocking the read from the SSE event
input so that's this part and basically
it's it's very much standard jax-rs
client invocation you were just asking
for SSE M and input class you you will
get the instance and it has a reed
method which is blocking so once the
arrives you will get the SSE event and
that's basically it
so let's talk a little bit about HTTP to
you just a bit of foreshadowing later
for the talk that's coming at four
o'clock with server-sent events it just
so happens that if you're running
service than events on top of HTTP two
you can expect some better performance
at least on the server side in terms of
socket utilization and that's because
one of the main things that's in the
HTTP 2 specification is the ability to
cram a lot more down the one pipe of a
single TCP socket so one stream can be
used as an SSE channel from the server
to the client and another one can be
used as client-to-server but this will
just happen for you transparently by
using the HTTP protocol with server sent
events at the same time you might start
to think oh I've got bi-directional
protocol I got an event thing that I can
send from it's not quite the same as
WebSocket
you can kind of approximate it by you
know using JavaScript on the client side
to actually what you do is on the server
side use the service and event to
pre-populate the cache and then you like
you use server push that is to
pre-populate the cache with resources
and then you can send servers that
defense to fetch things that you already
know are in the cache so that's kind of
one way to use HTTP to multi-directional
communication as an approximation but
you know what anyway this is basically
like interrupts I talked about the
complete set of protocols from how we
began from simple HTTP and actually I
end with protocol so thanks okay a
little big chapter of this
jax-rs 2.1 is integrations with other
specifications so Java platform is not
just a set of individual specification
right you need to be able to use use the
stack completely so if you are using
jax-rs you are most likely using CDI as
well and checks B and stuff like that so
that's exactly the first thing and I'm
really excited about Jason B being added
to the platform specification because
Java EE 7 and older we have only Jex B
as the binding provider so if you wanted
to send some data or cellulose and data
from directly from Java beans then XML
was your only option now with with Jason
B being added to the platform since IE 8
you will have the like you should have
very simple very how to serialize and
deserialize jason to standard java
objects this will be done in jsr 367
java api for jason binding
unfortunately this to talk about this
was yesterday
but I'm not sure whether it was recorded
anyway the specification will include
like very similar features to what check
three provides that it's not that
complex situation is not by far another
complex as XML and there were some like
standard standard features like naming
and ordering strategies adapters and
coding and stuff like that but this is
to be expected from that specification
so I wondered I have a kind of a warped
perspective as being inside aspects for
so long but when I worked on our code
and use jax-rs in Jersey I find myself
in a situation where I'm asking well you
know is this feature coming from Jersey
or is it coming from jax-rs and one of
the things that's annoying is okay I
have to use moxie or Jackson to get the
JSON goodness that I want does that
bother anyone else okay all right all
right so it's not just me okay well you
won't have to do that anymore
so basically thanks that this provides a
really nice way how we can write
portable applications so you don't we
won't need to care if you are running on
top of Jersey or less T so just use JSON
and that'll be it so I'm really looking
forward because it actually this creates
pain for me as a developer as well
because there is like sometimes
confusing configuration and I can say
that every jacksters
implementations do support Jason in some
way but the support is different in each
in each implementation so basically when
somebody will get example from I don't
know rest easy and he tries to run it on
charity it works but it produced
produces different output and then there
are some confusions about that so I'm
really looking forward to integrating
with the specification I think we even
had some bugs we had effects once
whether it's a problem with a version of
Moxie that was in WebLogic and
mismatched simpler is better yes oh by
the way max is nice nice cool Charlie
because we were trying to solve this in
multiple ways and one of them was to
provide Jason binding for annotations
which for objects which used checks B
annotations which is basically what
mocks it has mocks it Mach series checks
B implementation but
also provides XML binding but again if
you don't have this support in your
checkers implementation it simply
doesn't work so next integration is or
next specification to be integrated with
its CDI and basically CDI is becoming
more and more used in the platform and
it basically serves as a glue between
multiple specifications so if you are
adding check you can use chex RS
resource which is also a CDI bin and it
will get some perks based on that there
are some things which needs to be sorted
out for example jax-rs do provide some
guarantees that which for example about
which constructor will be used when when
you are creating the jax-rs resource and
sometimes this is not in sync with CGI
so we need to look into that and say
basically how it should work and it
means to be defined somehow and there
are some small features but I want to
highlight one and that's basically in
what we are seeing with Java and 8 &amp;amp; 9
basically running on top directly on top
of Java SE so if there is something
which needs to be done in jax-rs to
enable this scenario electronic running
CDI container on top of java SE and
running CD access application in there
then we might want to include this in
the specification as well the first
problem which comes to my mind is that
if you are in observer then usually
request scope is handled by service
implementation but once you are in Java
SE video the server then basically you
need to handle it by yourself somehow so
that's something which might need to be
added even to the JAXA respect what some
call back or something which would
control the request scope another thing
another specification option which is
going to be improved in Java EE 8 in
Java Java EE security API the main
addition for that which was announced is
adding of an open ID cannot support and
if you know if you ever doubt
with security in jax-rs you know about
injectable object which is called
security context you can get some like
user principle and authentication
information or scheme from that object
and if we are going to support out and
open hiding so then we will need to
enhance this and basically negative
changes in this so then we can support
these cases as well it's actually the
the security context as if it's now is
quite simple a class or interface but at
night it might need to be like much more
complicated especially when dealing
dealing with like different
authentication and authorization schemes
okay and one of the newly introduced or
proposed to be added specifications for
Java EE 8 is configuration specification
the goal of that spec is to unify access
for the configuration from the
application configuration and for the
like framework config as well for
example if you want it to access the
stuff which is defined in web.xml you
need to inject service context and
somehow get the information from there
if it's if it's exposed by Sarat api so
we hope that this would help this would
provide unified API hope to access even
like your so the configurator to the
application itself but even like to
think which are coming from the
container if there is some container
another important thing is that it one
of these goals is to provide
externalized configuration support that
means you can have single package you
can call it chart file it can be
something else and you can use this
single package for development testing
staging and production and basically
just defining the configuration
somewhere else so the configuration
wouldn't need to be included in in the
package itself which is kind of a big
deal if you want to know more about this
specification there will be a short talk
tomorrow I believe it will be in this
very room by Dimitri so please stop by
and show the presentation it's very nice
of this so
how this can be implemented with or
integrated Phil Jackson is the obvious
thing is that let's say there is a
config object which will be introduced
and then you must be able to inject the
configuration into jax-rs resource
that's the most obvious way and it
should just work what you could do is
you can even inject like individual
properties as a for example Java field
the parameter of the method if you think
about it it's very same thing as you can
do with query parameters or parameters
in jax-rs already so in the very same
line ok so this is just a proposal we
will see how it run or what the
configuration spectral option everything
but this is something ok talk about
about circuit breakers here I just think
it's kind of funny that we've got
circuit breakers and we've got back
pressure I think everyone wants to be
either a plumber or an electrician
nowadays mhm alright so with circuit
breakers in electronics and here in
software the idea is if the circuit is
open no current can flow through it if
the circuit is open no requests can flow
through it so this is a bit of a simple
state diagram here when the circuit
breaker is closed everything is fine and
every time you ask the circuit breaker
to go through if it's closed then you
know you're gonna succeed or fail and
you're gonna keep going through this
loop here and everything is good and
requests are flowing however when the
circuit breaker is open that's sort of a
failure state and the whole idea with
circuit breakers is and you can
configure them to how to respond in the
open case so if it's open you could say
let's retry a certain number of times
and then for the request or you could
define a back off strategy where you try
it once and then you wait then you try
it again and then you wait twice as long
and so on and that's we call them the
half open state and you can also
to find what sort of response will be
returned when you're in this half-open
state which is maybe you just returned
the same answer you gave last time or
you could perhaps pre-configure it with
a canned response to do in the case when
you're trying to determine whether or
not you're going to ever recover or not
so this half-open say is really where
all of the retrying logic and stuff
happens okay so it's generic way to deal
with failures and remote services and
you can really kind of protect your
system resources by monitoring these
calls to the remote service so it's it's
aware of what's happening downstream you
configure it to know what's happening
downstream so when this is added to
jax-rs 2.1 the real speck portion of
that will be defined specifically what
happens in the case of certain HTTP
error codes or tcp error codes what to
do in those cases and that's something
that's perfectly well suited to
discussion on the expert group and
decide what are we doing with different
500 series error codes in those cases
like everything else in jax-rs there's
going to be two approaches the
programmatic approach and the
declarative approach the programmatic
approach is where you just invoke API
yourself to set things up and the
declarative approach is when you
sprinkle annotations on the code and it
just does what you think that way the
things you will be configuring will be
the service level agreement you know the
various back-off strategies and such and
this is still very much open discussion
on the expert group
the question about does jax-rs need to
have any specific changes to account for
HTTP - you know it's HTTP - we gotta put
a bunch of new api in there and make it
HTTP - ish well it's still a request
response protocol and really the newer
features that are exposed as far as real
surface area goes on an api are defined
in lower layers so we were thinking that
you know you would be able to achieve
that by just injecting the
httpservletrequest and then that's where
you get your push builder which I'll
talk about later today - if you wanted
to actually use the H if we do server
push P or feature for example we'll drag
the rest be faster on HTTP - this is
another thing that people talk about
there if you were a binary protocol
person like you used to remember calm
and D calm and all these technologies
that would interact on the network using
a binary protocol you remember they were
fast right because they didn't have to
convert everything to 8-bit ASCII or
Unicode or utf-8 that is and so we've
sort of fallen by the wayside everything
is text now with rest and such well HTTP
- is in fact a binary protocol so if
you're sending and receiving binary data
you'll get you know an instant boost in
your throughput and resource wise as I
mentioned earlier there's better usage
of sockets so it's less consuming and
resources and that's all I wanted to say
there so this is the talk today HTTP -
this is the this is the title of the
slide but the talk here is all about
just servlet 4.0 in HTTP - if you're not
coming back to that coming to that talk
I'll just give a brief overview what I'm
going to be saying there it should be
two features in one dot X you know you
have request response write an ace
should be - you have one request for a
response and multiple requests the
responses can happen in the same socket
however with server push you know you
can make one request and the server can
know well when I when this when I see
the
request I know that I'm going to need
this web page and these associated
resources or in the case of a restful
web service you might you know use other
things other than gifts and images and
such as I said earlier being able to
inject your server requests or response
and all the other artifacts is how we're
currently it's the point of record for
how to expose htb to in jax-rs okay
we're done basically there is the
website which you might have seen on the
Java EE keynote so the jax-rs 2.1 is
part of java ee
it's but set of specifications and we
actually plan to deliver it by the end
of next year so hopefully next job one
we will be able to announce so next
steps if you have any feedback or if you
want to help with specification or with
the designing of these features which we
just mentioned then feel free to send us
an email or message to what if you are
going to provide extra so edit feedback
to jax-rs back my link list or if you
want to talk about generic stuff about
java ee direction then you can use a
linked list it's actually I just checked
before this talk and there are all
discussions about these new proposals so
feel free to chime in like we are really
keen to know your your opinions about
this matter and most simplest
importantly please take a survey okay so
you can you can join the JCP and
actually if you if you are or if you
want to talk about jax-rs we will have
given I definitely but I will be in the
hacker garden from 2:00 p.m. today so
feel free to stop by my plan is to
actually spend some time of attempt or
request on Jersey so if you have
somewhere request which is open for some
time then feel free to come by and we
can we can work something out yeah I
wanted to say I don't know if anyone's
explained the purpose of these user
lists right here right so the purpose of
these user lists is that each JCP jsr
including the Java umbrella jsr has to
set up a user's list such that anyone
can subscribe to it and any message that
is sent to it also goes to the expert
group so it's a way for everyone to
reach out say hey expert group you know
you got to see this now the expert group
you know and not everyone can just
discuss on the expert group proper but
everyone can send and discuss on the
user's list so it's kind of like a way
to have an extra channel to reach the
expert group you can ask like shortly
highlight like two talks I only
mentioned this configuration for general
e which will happen tomorrow and there
is actually even security for Java in
the cloud so expect some major updates
in the level by KK nice talk as well so
if you are interested in security then
go to zero ok any questions
okay so the question was when doing CVI
indirect interaction with JAXA right now
the resource locator causes a bit of a
impedance mismatch between the two
technologies is that going to be
addressed to be honest I'm not sure
about but it should actually you can you
can address it even now because if you
are returning sub resource locator as a
class not as an object then it will it
should get injected if you are returning
new instance then it usually cannot be
injected we could do something larger
definitely but it's it it won't work
because we cannot really call the
constructor right it's your
responsibility so something along these
lines yes but I actually would even try
it even even now after talk we can move
out and to see whether the like return
class is injected or not I believe it
will be because Jersey or at least
Jersey uses hk2 as a internal injection
framework and when this is properly
connected or bridge to CDI then you
should be able to get everything from
CDI as well but actually at was
something which I didn't mention that we
we like to like get rid of HK - I do and
basically have the possibility to run
for example unlike pure CDI even from 4
o'clock Jersey internal stuff or not
just CDI we can we can you can think
about any injection framework so
basically the goal for the
implementation if it's possible will be
to create some like unified API which
would provide pluggable very how to
basically bring in any injection
framework you want so it can be CDI it
can be used it can be anything you want
so but yeah it feels like cause of work
and I'm not sure
the question was when the sub resource
locator returns a class is that defined
as required by jax-rs or is it an
implementation feature of Jersey so
that's it's not required it's one of the
or another option you have you can
attend a class or instance but I'm
pretty sure this is part of the
specification great question
so the question was is there HTTP to
support in the jax-rs client and that's
the one thank thanks I will you know
there is an HTTP to client in Java se9
so yeah so actually that might be a
problem and we don't know about like we
don't really know how to deal with that
yet
because as a dimension we have Java Java
or HTTP to client in Java 9 but Java EE
8 is Java SE 8 so we cannot really use
that so it's not completely clear
whether we may make it mandated in
jax-rs to provide HTTP to enabled client
so we don't really know if actually if
you want to have it in the spec like
define then send a message to the
mailing list and just say ok so when you
are providing server-side HTTP to API or
support then you really need to provide
client support as well and that's it and
there certainly ample precedent for a
specification saying if you're running
in an environment that has X you must
support X so we've done that with bean
validation in JSF for example but
thankfully not one any other questions
you know
ah okay Oracle does not make any
comments on staffing or resources
. questions the question was is roles
allowed a part of the spec and I think
it is it's 250 right actually I looked
when I was creating that slide and I
tried it to try to see whether this is
actually included in jax-rs
specification like there is some
explicit mention of this being supported
in jax-rs
and it's not so it seems like this is
just a jersey feature right now but if
we are going to read with a security
support or basically improve security
support in jax-rs
we might even input these as officially
supported in in the specification itself
anything else six minutes left
well does this look like something that
is promising is it looking pretty
interesting you people are circuit
breakers looking all right
okay yeah go for it
by back right
so the question was we specifically
mentioned HTTP tierre HTTP T HTTP error
codes as things being considered in the
circuit breakers what what kind of other
things would be considered so again this
is just a proposal but when I was
thinking about this I actually went a
little bit like further ahead and I
would even get like full control of the
HTTP address and HTTP status code and
basically that the implementation or let
the user of that API decide whether this
is okay response or not response it
would be even like I would even consider
having this implementation access to the
entity itself but that might not be a
nice thing to do because then you might
need to catch the entity and if it's
like a big one then you don't really
need to do that so so headrests and
source code definitely yeah that can be
reconsidered you can basically if your
application is always returning HTTP 200
but sometimes if it isn't some something
some strange nature basically mark this
response as a bad one then yeah you
should be able to do that so questions
all right well thank you all for your
time enjoy the rest of your show</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>