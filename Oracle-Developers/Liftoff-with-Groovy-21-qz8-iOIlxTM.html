<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Liftoff with Groovy 2.1 | Coder Coacher - Coaching Coders</title><meta content="Liftoff with Groovy 2.1 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Liftoff with Groovy 2.1</b></h2><h5 class="post__date">2015-06-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/qz8-iOIlxTM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everybody welcome to my session
and we are going to speak about groovy
and especially groovy to the groovy to
line with grid 2 dot 0 1 2 3 and the
upcoming in groovy 3 so lift off so I'm
gium Lethal's i'm working at pivotal and
I've got my colleagues who hand out some
flyers with all the interesting sessions
that my colleagues myself are doing so
don't hesitate to come to other
interesting sessions and especially
don't miss the script boulware groovy
will compete against all the languages
so you have to come and support me and
upload us and cry and shout as loud as
possible to allow me to win because I
lost last year so I really need to win
that year so yes I work at pivot all I'm
working on the brewery project I've been
working on it for almost 10 years now so
here are a few links if you want to
follow me and so on I won't bore you
with those details and I usually applaud
my presentation on speaker dick dot-com
/g divorce if you want to have the the
latest slides I will be putting my
presentation there so what's groovy
first of all who knows what worry is ok
not everybody and well it's a dynamic
come we're just an alternative long wait
for the JVM which is optionally typed
but as we shall see during this
presentation we built so supports static
type checking as well as static
compilation and will also mention the
difference between the two which is
important and the well nature which a of
groovy is to be pretty close to Java in
every possible sense of the term
including the syntax because the groovy
syntax actually derives from the Java
syntax itself which makes it very easy
to learn
for java developers because of you know
the familiarity between those two
syntaxes so this talk is not so much an
introductory talk so for those who
download movie all that much I'm not
really going through all the little
details of the syntax and features etc
this one is more about the latest
developments on the 2x line of groovy so
I don't want to disappoint you but
hopefully you won't be I mean even if
you don't look Rudy very well the syntax
will look familiar because of how close
groovy and Java syntax are so gooey is a
pretty successful open source project
with an apache license I made some stats
for last year and we got a pretty good
number of downloads 1.7 million
downloads that's a pretty good number
actually I'm pretty proud of it and it's
well couple or three weeks late but grew
is now 10 from the first announcement of
the groovy release well of the creation
of groovy not in the first degree
release but the creation of groovy tail
end of august then that that'll be
that'll have been 10 years and almost 10
years that I've been working on it
Andrew it's not just about groovy the
language it's also a full-blown
ecosystem with other interesting
libraries around that so in the first
place there was groovy so let there be
light you know in the first place that
was good then there came Grails the
framework the web framework web stack
for developing web applications rapidly
and you might have heard also Griffin
the desktop framework based on the
graves infrastructure to create desktop
applications with javafx with different
view technologies and you might also
have heard of rattle which is
a built solution built on groovy or
using groovy for its dsl the growl build
system has been adopted by Google for
example for the Android build or at
people all my company there are many
projects like the spring framework which
is built using using gravel and around
that there are also many other
interesting projects for static code
analysis for testing like the spot
framework in the bottom left hand corner
etc so they are very interesting
projects that are complementing somehow
groovy that I invite you to have a look
at but let's start so first of all I'll
speak a bit about groovy to dollar which
was released last year and focus on the
key features first theme was the
modularity since not everybody needs
everything at the same time and because
groovy is not just the long wait but
also the API which comes with it like
templating library etc we wanted to make
things more modular rather than having a
big monolithic jar so we split the api's
in different modules for example
template engine the swing UI builder
stuff etc so we split everything in
smaller jars you can still use the big
job but you can also use the smaller
jars and here are the various modules we
created for the XML support the testing
support etc so the core jar is now twice
smaller with only three megabytes and
you can pick up one of those modules and
here so it's very small down you don't
need to look at the details in the boxes
but just wanted to show you the
hierarchy between the two modules and
basically you just go shopping and pick
up what you are interested in for
example you may be needing just the
template engine in addition to the core
or you may be
Pop's you're doing some JSON store
parsing slurping creating some jazz
impales so you can just use the J's
module if you wish so you can just pick
the ones you're interested in and also
in the process as we developed that
modularity aspect we also introduced a
new way of enhancing existing api's and
libraries and existing types also for
those who don't know groovy it's
interesting because guru being a dynamic
language we are allowed we've got some
facilities to decorate existing types
for example if you look at let's say a
java.lang.string there's no trim method
which removes what a white space on the
left and on the right and groovy added
the trim method to geralyn's string
although java.lang.string is final it's
a final class we can extend it to add
new methods to it but groovy being a
dynamic module with a runtime system
where you're able to somehow decorate
existing types to add new methods to
dedicate classes to third-party
libraries to your own types if you wish
and as we had decorated let's say the
XML support etc we needed to introduce
those additional methods with a certain
mechanism so it was kind of global
before the modularity work but now you
can also because we needed that when
splitting the modules we introduced that
mechanism which now allows you to create
your own extension yourself so to do
that for example if you want to
contribute a new method on string you
create a special class that you you name
the way you want so there's no
particular convention it's up to you to
define the name you're interested in you
want to have you create static methods
which will actually be added to as
instance method to the strain class and
the signature has been interesting
because so this is the usage
we speak about the usage first so you
want to add an introduces method on
strings so ultimately you want to be
able to say Guillaume that introduces
Cedric Cedric is my colleague on the
groovy team and to do that you want to
add a method called introduces okay here
it is which takes actually one parameter
which is the name here and there's this
special first parameter which is the
actual class and instance actually on
which you're going to add the method so
it tells the groovy runtime okay I want
to add that method to strings and here
is the instance of the string I'm going
to work on and then I'm just returning
some results and once I have to declare
in a special for a no special file in
meter in services in that long file name
you specify the name of your module
version etc and you define the list of
classes providing extension methods and
you have so I quickly skip this one so
you can add instance methods like this
is the case here introduces is an
instance method of well for that
specific string but it's available on
all strings or null string instances but
you can also do the same for static
methods but it's just the declaration in
the meter in file that distinguishes
between the two classes and here I just
want to add a static hi method on string
so you still have the first facial
parameter which is the type on which you
want to add new methods and there are no
additional parameters so there's no
parameter no argument that is passed to
that method so you don't have extra
parameters on the right here and it's
just returning the high string constant
and then you declare all that in that
special metal file and you'll have those
extension methods available to any class
of the JDK
clancy's your own types etc so we needed
did that when we worked on the
modularity for groovy and it's a
mechanism which is available for
everybody and not just us groovy
developers when we write new modules
another theme which was the Java 7 theme
with two sub-teams with the project coin
syntax enhancements and invoke dynamic
support because of the of the common
grammar that we had so Greece somehow a
superset if you will of the the grammar
grammar and features in general and
people are used to copy pasting Java
code into some groovy files and often
groovy beginners tend to write groovy
code with the Java syntax rather than
using the new groovy I do et cetera so
we wanted java developers to feel at
ease with all the various constructs
they've been using in Java so Java 7
introduced different little syntax
lensman enhancements in the coal project
coin for those small enhancements so for
example now you can create binary lead
roles for defining your own numbers so
in additional two decimal octo lenexa
decimal you can use binary literal so
it's 0 B and then a suite of ones and
zeros now you feel like you're seeing
the inner working of the matrix and
there's also again from project point
the ability to put underscores pretty
much everywhere anywhere you want to
separate you know groups of four digits
or things like thousands millions etc or
groups of bytes or beats so it can put
underscores we also support the multi
catch exception when you want to catch
and treat give the same treatment for
two different exceptions that are being
cut for example if this code inside the
try block tries to access the file
system and somewhere another statement
is potentially throwing a
nullpointerexception and you just want
to let a load the message or wrap the
exceptional inside another exception or
something about you just want to do that
once instead of duplicating the the
catch block for those two exceptions or
instead of coaching throw a ball because
you may want to do some different
treatments so you can just regroup the
two or three or more exceptions in the
same blocks thanks to the pipe so it's
IO exception pipe nullpointerexception
so you catch both of them and treat them
in just one block so that's in Java 7
and actually I've never used that in
java 7 myself so i'm not even in brewery
but at least for those who are used to
using it it's there so that's awfully
old coins then another interesting
things that got added to jdk 7 it's the
invoke dynamic support in wrote dynamic
is a byte per instruction which is the
well the method dispatch for dynamic
languages so it's a bytecode instruction
but also it's also a set of api's
providing various things representing
things like the point where a method is
being called for well it's at the cold
side can defined a handle to a method
which will be involved etc so there are
many api api classes which are useful
for us implementers of a dynamic
language so we added support for invoked
enemy so one of the advantages is that
you'll teammate lee you should be
getting
more rent I'm performance in practice
depending on the different updates of
the jdk 7 the performance sometimes was
good sometimes not as good as our old
optimization techniques so you might
have some mixed results there in terms
of performance but ultimately since
invoke dynamic is also being used in jdk
8 with a new back end which is also used
by lambdas in java 8 the perfume should
really improve over time even further
compared to the various optimization
techniques that we've been using in the
past like the cold side caching
techniques etc to optimize the
performance of GUI to make it as fast as
possible so we worked quite a bit on
that support so it's kind of transparent
to users but it's been quite a bit of
work for us implementers of the language
and we also have a static theme with
introduction of static type checking and
study compilation groovy being a dynamic
language you can have certain class of
errors at runtime around that
compilation time for example if you're
making a typo obvious typo in a you know
method name or variable name you will
get runtime error it wouldn't be flagged
by the compiler because the fact that
movie is a dynamic language and allows
things like domain-specific languages
and all sorts of cold dynamic features
like be others etc for those who know
groovy sometimes what would look like a
typo is actually not a typo but use age
of a dynamic feature so we usually throw
runtime errors for things which were
actually typos but they are quite a
number of users who are using Ruby
Morris a javascript in long wait rather
than as a full-blown long wait with all
its features so they are writing groovy
code in a Java fashion to integrate
groovy and script Java API s and those
users usually prefer having the same
kind of feedback
the one which is provided by Java sea's
the Java compiler so usually won't
errors at compile time for things like
typos and such so the goal of the groovy
static type checker is to make the
compiler grumpy that's why you have this
little dwarf there and the initial claim
of that feature was actually grumpy so
beth's we've been told that it's not a
serious name for a feature for serious
language so you better call that feature
static type checking okay it's more
boring but you know at least for you
know there are some corporate corporate
environments where you shouldn't be
using you know where names and so on and
in the past I had well I shouldn't spend
too much time on that but I had emails
from guys from big companies telling me
you know i have problems convincing my
management my manager to let me use
groovy because groovy the fancy names i
cannot use groovy in my project because
of the name well okay i can't be much
fun for you guys anyway so we nailed it
static type checking its stead of
groping which was well unfortunate but
the thing is for those kind of usage
where scenarios where you want to embed
a javascript in long way to java plus
plus language you don't need all the
dynamic features that brewery offers and
you want the same kind of feedback as
the java c compiler provides so for
things like tap typos or non-existent
method that you're trying to call or
you're making bad assignments and things
like that the compiler should complain
but it should be clever enough to do to
still allow you to write idea Matic
groovy code without requiring too many
additional static type information so
normal groovy code is still valid under
the static type checking rules and we'll
see how we enable or disable static type
checking in a minute so we made the type
checker pretty clever by supporting type
inference and some fine grained aspects
of type inference and also the static
type checker understands the new
mechanism that we mentioned for
extension methods introduced by the
modularity a fort so let's have a look
at this example so how do i enable type
checking I can enable type checking by
using this annotation at type checked to
say okay this test method is going to be
type checked by the groovy compiler and
here there are double tees Double H
triple O's instead of method so I want a
compilation error for that same thing
for the name variable again some obvious
typos will throw compilation errors
rather than a runtime error and also
I've put time checked on at the method
level where you can also put it at the
class level or you can skip type
checking just for one method if you put
it at the class level so there are some
options there I mentioned wrong
assignments for example if you aside and
object into a primitive type or an
object into some other object some to
some of the type you'll get a
compilation error it understands that
the elements of an array of string of
course you get strings and not let's say
an int so it's going to to flag that as
an error or things like adding a string
to a number doesn't make sense so again
it's going to throw a compilation error
when you're doing some if else branch
here you can notice that return the
return key word in guru is optional so
here in one branch of the if and
returning a string and the other branch
I'm returning an inch that's okay but
here I'm returning the string so it's an
obvious compilation error because I
shouldn't be returning a string and for
things which are more well I do Matt
groovy for example here we have this
operator which is the left shift
operation
which returns the string builder itself
so I'm appending hi to the at the end of
the string builder and I'm appending
name afterwards it's returning a string
builder but groovy in your old normal
green on tight checked we don't require
you to say return string builder to
string but there's an automatic
conversion and pull to two string by
default so things like that although the
I mean the inferred type of that
expression is actually a stringbuilder
the type checker understands the groovy
rules which allow automatic two string
method calls so it's not going to
complain and throw compilation errors to
come on idea Matic giriko and it's as I
mentioned a bit of type inference in
some of these examples already but for
things like here we have a variable
which is a optionally tired I just say
def name I didn't say string name it
figures out that name is a string
because we initialized that variable
with a string so I can call to uppercase
because that's a valid method on strain
it understands the methods added by the
groovy GDK the groovy development kit
like the new train method that is not
available as part of the JDK but as part
of the extensions that we provides and
it also understands the that the
elements of an array of something is off
type something so that's type inference
at play for the cases where you use
dynamic methods like here we have a
builder which will which allows you to
create HTML or XML payouts for example
there's no actual HTML method on that
marker builder class it's a dynamic
method which takes a closure which is
delimited by those curly braces inside
the body of that quarter we have another
method call and yet another method call
inside the other closure all those
methods are delegated to
Makka builder and so you can create your
own you know XML payload it's not
following a specific schema but this is
a dynamic aspect of groovy because those
methods HTML body divot cetera are not
real methods so you won't find it if you
use reflection for example you won't
find those methods so it's a dynamic
aspect of the language and you can
actually mix dynamic and Static like
statically typed checked code for
example here my greetings method call
that method which generate some markup
and this is time checked this wasn't is
actually dynamic because it's not
annotated with ad type checks yeah I
wanted to say yeah no that's all I
wanted to say when in well in plain
groovy this code just works even without
the appetite checked annotation but if
we were as verbose as Java for something
like that here we would have had to use
some casts or temporary variables to
inside those branches of the if-else
statement so when you do if Val instance
of string you would have before being
able to go to a bracket it would have
had to create either temporary variable
but in any case user cast to say okay
Val okay it was an object but I know
it's a string so I have to cast it to
string but in Ruby it's not needed
because it's just dynamic but in type
checking mode we know that inside that
if branch Val instance of string so I'm
allowed to go to a per case I don't need
to do any cast like in Java in a verbose
way so no need for cast here and also in
this other example since it figures out
that val is an instance of number can
call the int value method from number
and it also understands again the GDK
method additions
we allow the operator of loading for the
existing operators you cannot create
arbitrary operators but for those which
are existing operators there's a
convention which is that the star symbol
is actually equivalent to the multiply
method so it understands that there's a
multiply method on string added by
degree GDK so it understands that ok I
can call strain x int because it knows
that well vow was a number so it could
call in value so this returns some kind
of int so i can call multiply which
takes an intense permit so it's pretty
clever in terms of type inferencing and
another example of type inferencing out
play is here could you guess so i
omitted the read the return time here in
the Declaration of the method but would
anyone have as a gut and try to guess
what's the the inferred return type of
that expression here what is it a list
of numbers something more curate
so it's trying to actually find the the
most common denominator so it's not
really doing things like tuples you know
where it would say okay it's a to pull
off an integer in a bigdecimal but it's
actually trying to find what we call the
lowest upper bound and it's actually so
you cannot really write that in Java but
it's a list of T which actually extends
number but also comparable and also
serializable but if you look for example
at the number in class or interface
number isn't comparable but both integer
and bigdecimal are actually comparable
so it it's got a fine grain
representation of the type of that stuff
so it's pretty it's a bit more clever if
you will than the type representation in
in Java so that you have the you know
the best feedback from your ID from the
compiler for code completion in the ID
and that kind of stuff so that's what we
call the lowest upper balance and we the
type checker also follows the
assignments made to local variables and
particular dynamically typed variables
for example here in VAR i put a an int
then i put a string so here VAR is the
strings although the type inference
kicks in and remembers ok this is a
string so i can call to integer but in
but then you put back an inch in the
variable and it's going to complain
because there's no to uppercase method
on integers so you're going to get a
compilation error so usually so it's the
kind of code you can write in groovy
because it's optionally typed but
usually it's not the kind of coded
advise people to write because you know
it's kind of error prone to put
different types different different
values of different types in the same
variable its could smell for me but
since it was code that actually works in
normal groovy we also wanted it to work
when type checked so don't do that but
be sure to know that the inferencing is
clever enough to figure out what's the
type of your variable or parameter at
one point in the copies so static type
checking to enable it you use this ad
type checked annotation type checking
actually doesn't change the behavior of
your code because under the hood it's
still dynamic code which is being cold
but there are some limits to static type
checking for example all those dynamic
aspects like the marker builder you saw
earlier it's the kind of things which
are not possibly tight checked or not
tight checkable if I can say it like
that or things other techniques like
putting dynamic variables into by script
bindings and that kind of stuff is not
something that you can type check at
least not without plugging into the
static type checker which you can
actually do so learn things like meter
programming stuff I think I have an
example afterwards know things like
calling string dot media class dot food
to add a new method dynamically to the
string metaclass cannot do that in type
checking road by the only way now that
we have some courtesy which is
statically typed checked what about
compiling it statically which is about
generating the same kind of bytecode as
the java c compiler would generate you
can actually do that so study
compilation is a bit different because
that's not the same bite cut that the
GUI compiler used to be generating so it
bypasses all the runtime aspect of gooey
and what's interesting also is that for
those who are not yet on jdk 7 and
Beyond who cannot use the
small performance improvements of invoke
dynamic you can use static compilation
and the advantages are that it's type
safe because you use static type
checking you gain better performance
because that's pretty much the same
bytecode as the Java Sea that Java Sea
generates and it's the another
interesting aspect is the fact that the
there's no dynamic code involved so
you're immune to monkey patching so if
someone tries to dynamically change the
behavior of some method that your
library relies on so you're immune to
those kind of changes because you
totally bypass the dynamic rent time of
GUI so it's a kind of safety net if you
will and you can obviously better
performance so you avoid little monkey
the nasty monkey and the drawbacks are
the same ones as with the static type
checker certain dynamic aspects are not
possible and just like the previous
example where I was using I was mixing
statically typed checked coat and
dynamic code here I can also mix
statically compiled and dynamic code so
that's the same example as before but
with the at compile static annotation
static compile this part is dynamic and
something that is quite important in my
opinion is the neater good practice to
do that is to have properly although GUI
is optionally typed you can say def
generate markup def name or even just
name and everything all the types are
totally optional but still I like my
methods being method signatures being
contracts because it helps in terms of
ID support for code completion it's
better for your Java doc or groovy doc
and so that it can read ok this is of
type this and that etc so it's always
better to have proper methods in nature
with proper types that's a good habit to
use that but inside the body of a
message
can very well use optional typing like
deaf stringwriter it's totally okay and
what about performance I haven't updated
the the numbers recently so it's with
great oral all that it's probably
slightly faster with two dot one and the
upcoming in groovy 22 I compared a few
benchmarks which were typical worst-case
scenario kind of patents for Buri we
took the for example if you looked at
the old brewery 17 compared to the time
it takes when the algorithms are
implementing pure jaw you could see the
worst possible gaps in tub in terms of
performance the overall performance of
groovy versus Java is not as bad but
those typical micro benchmarks are the
ones really exhibited the worst
performance for robbery so don't be
surprised with the big numbers at the
bottom of the of the table yeah INRI 18
we added some optimizations whenever you
are using primitive types so when you're
doing some math arithmetic swith
primitives and already for very
algorithmic and well math oriented a
micro benchmarks the performance was
pretty close to that of Java but for
micro benchmarks which are more oriented
towards method calls and with bigger
stack frames with deeply recursive
algorithms and such the performance was
still pretty bad here you know three dot
six verses 23 seconds that was all
pretty bad and with study compilation
once you study click compile those micro
benchmarks we get pretty much the same
performance as Java you know a few
persons
sometimes even better than Java but well
it's usually pretty close and there are
so perhaps this number is now better as
well I haven't run the benchmark
recently but it's within a let's say ten
or twenty percent range compared to the
performance of Java so it's pretty much
the same performance as John so if ever
you hear someone say groovy is slow
because Donna me yeah but for those big
hot spots there where you need raw
performance you can write a code which
is statically compiled and get the same
performance as Java ok that was agree to
that oh now greet total one which is the
current main version of groovy but in
the coming couple of month we all really
scree to that to the invoke dynamics
support wasn't totally completed some
places were not optimized so we
continued working on that we've got a
new feature which is metal notation
facility which allows you to combine
several annotations into one and for
those hello AST transformations which
can which are kind of macros in the
groovy language they are usually those
transformations are usually triggered by
annotations so you can use meta
annotations to combine and parameterize
existing annotations let's have a look
at an example for example if you want to
always annotate let's say your domain
classes or some particular classes with
at mutate the at immutable
transformation and a custom at to string
you can collect those two annotations
together you specify the collector to
say ok we collect those two annotations
and you define your own annotation you
know own meta annotation annotation if
you will so this is the name of your
annotation and then instead of saying at
immutable add to string etc on
person I just say at my LGS and it's
going to apply at immutable and add to
string what's interesting is that it's a
compiler feature so the the underlying
framework libraries etc don't even need
to know that it's metal annotation which
is not the case with some you know metal
notation that you can find in Java EE in
spring etc because the frameworks
libraries need to know that those are
metal notations here it's really a
compiler facility which actually
replaces the metal notation here with
the those two annotations and here
transformations so it's a pretty handy
way to avoid repeating the same
annotations all the time on certain
classes which support the same you know
characteristics the delegates to
annotation so Ruby is great for
domain-specific languages for various
reasons because of the dynamic features
it provides because of the tweaks we did
to the Java grammar to be able to write
plain English sentences in Java in
groovy sorry you can make some nice
dsl's with groovy and there are some
dsl's for example here I've got a
snippet from granel the grotto beyond
solution where you have a you defined a
task which is supposed to be copying
some files from a certain directory into
another directory and the from method
and the into methods are actually
methods from the copy class and there's
no way that the ID can know that where
is that from method coming from where is
defined IDs don't know about that so we
needed a way to tell the ID to tell the
compiler to tell the static type checker
that ok I know where those methods are
coming from and we the type checker for
example can
stand those dynamic features of GUI so
if we want to implement a DSL like that
say you want to delegate the full method
call to this spec instance here so you
may have that class for the spec
variable or perimeter which is God which
has got a foo method and then in terms
of implementation of that dsl what the
exact method looks like so it takes a
NEX expect instance that's the spec
variable here and it takes a closer it's
the curly brace delimited block here it
takes a closer as perimeter and then
we're doing the quarter delegation we
say ok see is a closer i'm going to say
the delegate of that closure is this
instance of exact spec and I'm calling
the closure with the delegate so tween
to tell IDs static type checker about
that you can add add delegates to exact
spec on actually the annotation is not
well placed so up here sorry live
correction so you put the annotation in
front of the closure to say ok the
delegate of that closure is going to be
some instance of the exact spec so the
type checker and ID etc can know about
that and will not flag that foo method
here and you know in the line saying I
don't know where this method is coming
from so it's pretty nice for
documentation purposes ID support and
static type checking support as well and
it's clearer because it understand the
various delegation strategy provided by
groovy etc so important for the
documentation integration with the ID
and static type checking alibis
and speaking about static type checking
again you can actually extend the static
type checker can write your own
extensions this one that was this
morning I went to the talk on me today
times Ric eight and with annotation
processors you can actually do a bit of
that in a way but it's perhaps not as
far as we can do that we go a bit
further with groovy here when you used
type the static type checker by saying
okay this this exact method is tight
checked you can also pass a parameter
the defining the extension to the normal
type checker offered by uri to create
your own extension and to go beyond what
the type checker knows for example at
some point the static type checker may
say okay I don't know that method or I
cannot infer the type of that variable
so there there are some events that are
triggered at the type checker level and
ultimately adding compilation errors to
the output of the compiler but you have
a chance to hook into that static type
checking process and react when you
encounter things which the type checker
by default doesn't understand for
example you have some events like like
him yeah an unresolved an unresolved
variable perhaps you know that this
variable is coming from the script
binding or from some place so you know
it's a dynamic variable and you want the
static type checker to understand for
example your own domain specific
language you can extend the type checker
to understand very highly dynamic
features of movie or of your own dsl's
so we provide a an event oriented API
which looks a bit like that so in a
special file like my extension movie
that you pass as a parameter as an
argument of the type checked a notation
you can say okay on method selection I
want to do this and that do some login
do some transformation or whatever and
you can react and create your own
extensions to the type checker it's a
bit of an advanced feature because you
really need to understand the AST the
abstract syntax tree representing the
structure of the groovy language and its
grammar construct and so on so it's a
bit of an advanced feature but you can
really make the compiler and type
checker understand what you're doing in
terms of dynamic features in gruene no
need to pre compile it but in agree to
that too we also allow pre-competition
some of the examples of the stuff you
can do with that let's imagine that
you're using some framework like jpa or
JDBC where you define some queries like
sequel queries and it's a verbatim
string select star from users blah blah
blah where etc it's a string but you
know the Java compiler can do much about
that string so it's only going to be the
framework the library you're using
that's going to say at runtime okay
you've made an error in your sequel
query because there's a typo you forgot
the you said selec instead of select or
something like that so you'd get runtime
errors for that even in Java itself with
custom static type checking extensions
you are able to say okay static type
checker look at this string there that
you pass to that special method which
takes a sequel query string and look
what's inside and say okay if it's not
valid sequel syntax then throw a
compilation error so you there are some
situation when you write your own
extension to the type checker where you
can have better feedback from the groovy
c compiler in terms of compilation
errors then you can get from the jumper
that's kind of funny for a dynamic
language to be providing more
compilation errors than Java so it's
pretty interesting to use that
especially for dsl's it's also a bit
related to dsl's you can really tweak
the groovy compiler for example so we
introduced various ways of customizing
the compiler thanks to compliation
customizers that got introduced in
previous versions of gooey but there are
two flags for the brewery compiler which
allow you to define the bay script class
for all your scripts when you define a
groovy script without all the class you
know structure just a list of statements
basically those scripts are actually
instances of groovy length script that
you can define your own base script
class if you want script to share some
common common you know base methods or
kind of soup to the global methods so
you can define a bay script class and
another thing you can do with this all
the flag it's the config script which
allow you to configure the glory
compiler to add things like so i'm going
to show you perhaps in the well i'll
show you the next line first which is
more interesting there's a small dsl
this is just a groovy script that you
pass a parameter to the groovy c
compiler which say ok which is i want to
add nasty transformation to the class
which is called my bean you want to I've
got ya or this one for sudden groovy
files with a certain file extension I
want to add to string HT transformation
or I want to add some default imports
like import static java.lang.string port
can do some customizations for your dsl
so that you avoid repeating
towards the application of certain HT
transformation so it's a way of
configuring the groovy compiler so there
are tons of details about those two big
releases greeted olive oil and greeted
on one and at the on the groovy website
if you want to learn more be sure to
have a look at that and now I can focus
on what's coming up in Greek to dot 2
and further visas as well so groovy to
that too so what we saw is 320 was
released mid year in last year ritu
Darwin early this year and in a couple
of month we should have groovy to that
to available so we zoomed on that part
now we'll look at the end closures
you've heard that Java 8 is adding
London which are kind of equivalent
closures so when you have a predicate
tea with a test method tea for the
generic type and let's say some API
which filters a collection according to
that predicate if you used Java 8
lambdas you could write least dot filter
a new path of lambda which filters you
know people over 18 if you did that in
groovy you would have had to be explicit
and say ok I want to course that's a
coercion mechanism that's the name of
that feature you won't course that
closer into a predicate instance so you
somehow had to tell Ruby ok transform
that quarter into a predicate instance
if you had a list filter method which
took closure a groovy closure you
wouldn't have had to add as per decade
but since the API was written by us for
example well how can I do that well with
my groovy folders I would have had to
say as per decade so we wanted to
in that particular case you see that for
once ruby is more robust than Joe come
on come on we have to do something about
that okay let's remove that there
go wrong so that's what we call implicit
closure coercion basically that's more
less the same mechanism that is at play
with Java 8 to map lambda to some
interface a functional interface type
but with groovy course basically so that
way you can have shorter code we're more
concise not java yeah but it's not just
about you know being more concise or
anything like that it's also about being
more you know straightforward and have
the same feeling in terms of using api's
existing api's as you have with all the
enhancements that will be added to
things like the collection api's etc so
we wanted to have the same kind of
support and also to go slightly beyond
that mechanism offered by Java 8 and the
the conversion from lambdas to
functional interfaces we also allow this
mechanism to work on abstract classes
because in Java 8 with lambdas it only
works for functional interfaces but it
doesn't work with abstract classes with
just one single abstract method so we go
a bit beyond the jar java here as well
to support that case with abstract
method single abstract methods on
abstract classes what time is it seven
minutes I had a better hurry up we've
got so I mentioned the ability to use a
special base script class for scripts
for example in a script which could be a
configuration script of some sort you
may want to delegate variable assignment
or method calls to a special instant
of your particular configuration class
so you can do that with the the
delegating script feature which is
coming in Gori to do and we to that to
which was contributed actually by a
cushion k the jenkins lead because
groovy is quite heavily used for
customizing jenkins inside and how you
would do that you would specify the base
script class to be used on the configure
and profiler configuration object then
you part the script you define the
delegate and then you run the script and
you can check that that delegate has got
name from the previous configuration
script example etc so it's a nice way of
doing delegation with scripts some of
our tools like the groovy come online
tool has been improved improved sorry so
when you say doc java.util.list it's
going to launch your default browser and
show the documentation from the jdk
documentation as well as all the
extension methods added by groovy
there's some good completion available
in groovy SH as well so if you say
import groovy dot it's going to groovy
it's going to agree on reacts if you say
groovy Dutchess and out it's going to
you know complete all the possible
classes and what else here to uppercase
if you type to tab time to complete
upper case etc and our two variants the
one taking 0 parameter on the one taking
several parameters that's why you see
those two propositions import completion
and methodical condition another feature
which is coming up into the to
memorization so we had memorization with
closures but we added memoization which
is a HT transformation to methods as
well so when you have
expensive operations are expensive well
method which take a big amount of time
to compute some results so I'm faking it
with a slip one second so that's adding
two numbers being very slow in groovy
that's why because you we add slip one
second everywhere no that's not what's
happening of course so the first time
you call that method expensive up one
and two it's going to take one second to
return the result but because you
memorized the the results of the well
the previous invocation of that method
with definitive set of values as
parameters the next time you call the
same method with the same parameters 12
regional immediately because we
memorized the return value so you add
memorized only if you know that the the
result is always the same for the the
input parameters of course plus well
several little additional things but
it's a bit behind I won't dive into
those small details now what's coming up
in two three we are looking at adding
some static trade support Groovy's
dynamic language it's got dynamic mix
mix ins and such but we also want to
support static traits like is available
on some other languages as well so we
are prototyping that with a new keyword
trait which applies the ad straight
transformation so that you're able to
say okay want to add a flying ability to
my car and then okay i can say c dot fly
and I've got a James Bond car which is
fine so I can implement several traits
at the same time etc we're also looking
forward to rewriting the groovy doc tool
because it's still the old you know
style of Java doc groovy doc is not sexy
dog so we want to have a nice or nicer
looking documentation like
you know with a bit of JavaScript to do
a search search for this method or feel
or that kind of stuff so we are going to
look into that hopefully in 23 but it's
not yet or if it's going to be there
where there's a bit of overlap on the my
text we are looking at right we started
working on some new documentation for
groovy and also some new websites with a
common look and feel and further down
the road 33 we are looking forward to
reworking the dynamic core of groovy
that's the mop Demeter object protocol
so it's a quite a big work to rewrite
the the poor runtime of groovy because
there are many you know ten years of
groovy you cannot have 20 fication
happening in with new dynamic features
on top of other dynamic features etc so
we want to imagine how moja oh I never
managed to say that word homogenize the
the runtime system dynamic runtime
system so it's a big work and also to
rewrite that meaty object protocol to
fully work on top of invoke dynamic and
leverage in group dynamic the bestest as
we can the syntax of groovy won't change
but internally we use on tiller for for
defining the grammar and if we want to
continue evolving the groovy language we
need to update to a new version of on
Club for and which requires a full
rewrite of the grammar so it's also a
bit of work but it's also related to
another theme for ruby three which is
JDK 8 which adds a few new things to the
Java syntax like lambdas obviously but
also things like repeated annotations or
annotation on types pretty much anywhere
so we need to also evolve the gooery
grammar to support that so it's going to
be a good opportunity for us to actually
rewrite the grammar and
those new syntax elements from Java 8
and that's it's right on time so thanks
a lot for your attention and I can take
one or two questions perhaps any
question yes what is the the runtime
performance of memorization well this
it's just a LRU cache under the hood so
there's not much cost apart from you
know fetching value from the hashmap the
underlying map so you'd normally
compared to an expensive operation it
should be pretty much free for example
if you implement things like Fibonacci
or something like that you're going to
see all some results compared to the
usual recursive way of writing the
algorithm for example another question
so the cost of type inference and
particular lowest upper bound
computation the groovy compiler is not
much slower despite all the type
inference going on with the static type
checking so we didn't even measure it
it's pretty minimal so it's not it's not
slow because you're using type checking
so the glory compiler stays pretty fast
so it's more expensive to do that
inference but it's not that much because
of how we the compiler stores the nodes
representing the various classes and
types it's well it's not i mean the
algorithms might be complex but we've
got the right data structure to figure
that out quite rapidly efficiently yep
well greased at a time well there's not
much improvement there because there's
the jdk started time first of all then
some initialization but for example if
you I didn't try to measure that but for
example if you just pick the modules
your you really need there's a bit less
of class loading to be happening so you
may gain a little bit if you use just
the right small jars that you really
need but it shouldn't make a big big
difference you'll make it yeah of that
okay so type checking and study
compilation by default it's possible for
example if you use the config script
flag you can tell the glory compiler
okay for just those classes or all
classes apply static type checking or
static compilation yeah so you can say
to turn off static type checking you can
say at type checked and you pass it's an
enum I think or some constants in a new
interface can say a type checked skip on
yeah type I don't remember which class
but there's a there's a special way to
say skip that one yeah okay thanks a lot
for your attention
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>