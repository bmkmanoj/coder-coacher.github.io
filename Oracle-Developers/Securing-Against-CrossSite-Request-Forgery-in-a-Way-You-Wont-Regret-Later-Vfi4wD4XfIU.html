<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Securing Against Cross-Site Request Forgery in a Way You Won’t Regret Later | Coder Coacher - Coaching Coders</title><meta content="Securing Against Cross-Site Request Forgery in a Way You Won’t Regret Later - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Securing Against Cross-Site Request Forgery in a Way You Won’t Regret Later</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Vfi4wD4XfIU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm Erin Hurst I'm gonna be talking to
you today about securing against
cross-site request forgery you may have
noticed this isn't the only session
about cross-site request forgery
hopefully some of you had the chance to
attend Frank Kim's excellent talk
yesterday where he went over it briefly
there's also a birds of the feather
session this evening if you are a night
owl that said you'll still get something
out of this that's unique in particular
we're going to be talking about dot dot
dot in a way that you won't regret later
and by that I mean implementation
choices so we're gonna be looking at
some high-level implementation options
and architectures that secure you
against cross-site request forgery and
future proof your application so I'm
Erin Hurst the goals I want you to get
out of this are first of all to
understand an attack I'm gonna make make
no assumptions about your background in
our site request forgery so we'll go
through this we're going to talk about
protection schemes sort of the theory
behind them what works what doesn't work
in particular what doesn't work well
look at implementation for Java Web Apps
this is not going to be a tutorial so
I'm not going to tell you how to set up
each one of these different
implementation options but we are going
to look at the pros and cons and how one
can still make mistakes of them and
speaking of mistakes we're also going to
look at future proofing so even if you
implement a cross-site request forgery
protection scheme it's perfect today it
may not be tomorrow so we want to get
this right both now and in the future so
why are you listening to me talk about
this
I'm from Coverity we're the leader in
development testing so we have the
world's deepest most precise and most
widely used commercial static analysis
tool so one of our products security
advisor reports awasa top 10
vulnerabilities so it's cross-site
scripting various injection attacks
sensitive data data exposure and of
course cross-site request forgery so I'm
the principal engineer in the java web
app security group I'm a developer I am
NOT a security professional and this
sense that that's all I do I do give
speeches for a live
but I do spend a lot of time looking at
Java security vulnerabilities and in
particular I look at Java security
vulnerabilities in a wide array of web
application so I see a good
cross-section and hopefully I've
collected some wisdom that I can import
with you about that so the anatomy of an
attack so cross-site request forgery
I can stop saying the entire long name
for it now I prefer the abbreviation
CSRF or C Cerf so when you hear me say C
surf in the future I just mean
cross-site request forgery the short
version is it allows an attacker to
trick a client's browser into making an
unintentional request to a web server or
at least a web server that's vulnerable
so you can imagine what a vulnerable web
service essentially doing is giving a
hacker control of your users Mouse so
you can imagine that they're doing
something bad with that they're probably
capable of doing something bad with C
surf and unfortunately this is a little
bit less well understood than other
attacks one of the other things I do in
my role is talk to clients and other
organizations about their cross-site
request forgery vulnerabilities and more
than once the response has been hmm
let's get back about that and it's not
something that really inspires
confidence in the security field what it
is what it is and if you're new to this
you're not the only one so the best way
to show an attack is to just walk you
through a simple one so I've decided to
bank with my insecure bank they have a
really good CD it's one percent that's
good these days if I log into it with my
account do some banking what that does
is when the request is sent to the
browser and my authentication is valid
it is I'm going to get a request back
from the browser that looks like this
plus some other content and the request
is probably going to include some
setcookie directive and what that set
cookie is going to do is set a session
ID so if your web app developer you're
very intimately familiar with this
concept but what that session ID is
going to do is it's going to serve
credentials so if I do anything in the
future on my unsecured bank if I click
on some links if I go back in my browser
that session ID is gonna be sent with
every request so that I don't have to
type in my password every single time
generally users find that pretty
frustrating and um that uh cookie that's
set back in this response is going to be
put in my browser store and it's going
to be made accessible to other requests
to the same domain to my unsecure Bank
so in the middle of my banking let's say
I don't sign out and I go browse my
other website that like to go to pirate
chat it's not a mp3 sharing site but a
discussion of all things seafaring and
the pirates being scallywags that they
are I've launched a sea serpent ACK
against me that's unfortunate
the way that this typically works is
somewhere in that web page the attacker
has embedded some HTML may it look
something like this it's an image tag
and instead of pointing to an image
that's going to show up and look like a
treasure map or whatever you would
expect it's going to point to something
at my insecure bank it's also you can
see that this particular URL includes
some additional parameters that look
like they're probably going to transfer
some money in this case a thousand
dollars to some account number and if
the attacker correctly
reverse-engineered my insecure banks
protocol it's going to do exactly that
and if there's no of course no see surf
protection now me when I visit this
webpage I don't see anything that
happened right this is not visibly
rendered see they're too small or not a
valid image and the browser is going to
automatically load this as soon as I
visit the web page so this happens
quickly and instantaneously and not to
my knowledge so this is why it's forgery
so what that looks like is my browser
sends an HTTP request to my unsecure
bank when it tries to acquire this image
so it's going to send it to this
transfer address with the parameters
that you see in the page and it's also
going to include the cookie so what that
cookie includes is my credentials to do
something on my own secure bank and this
comes out with a browser cookie store
and it's totally valid because it's
going to the same
domaine that it was set for um and if
there's no other protection my insecure
bank is going to see that as valid
requests with valid credentials and do
something that I don't want and probably
leave me quite a bit in the red and
could you think you can only do this for
get requests like I just showed with an
image that's not true
you can also do this with a post request
so let's imagine the attacker put some
HTML like this in the page it's a form
Methodist post points to that transfer
page again on the same website it's got
some hidden inputs right these are the
account number and the amount same as
the last request that I shown and again
nothing here is rendered these are all
invisible now imagine somewhere else
they've also included a script so this
particular script points to the form and
automatically submits it so here now
you've got the reform that's generating
this bad request and the script that's
automatically submitting it and it's
having the same net effect as that image
that got automatically loaded so totally
unbeknownst to me I'm again transferring
money into pirates so how do these
things actually get launched and
practiced well the attack can get
launched from many possible places the
site can be one that's just actually
administered by the attacker you can
possibly browse to some let's say seedy
corner of the web and they might run
that website and you're toast at that
point websites can also intentionally
allow HTML posting this used to be
common on many like chat websites it's
less so these days but it's still out
there so if you're visiting a website
that allows such posting that's another
see server tack vector and in any web
site of course that has a cross-site
scripting vulnerability is subject to
see serve attack so that's actually one
of the most common ways to exploit a
cross-site scripting vulnerability is
that the attacker will use that to
reflect HTML and then attack you via C
surf so if you're unfamiliar with that I
definitely encourage you to investigate
but I'm sure everyone in this room is
well versed
so the other half the attack is well how
do they find the victims where the
victims are both the server and the
client
well on the server side they probably
just observed an interesting request
something that did something that they
wanted to replicate maybe in some
different way like transfer money but it
can pretty much be anything under the
Sun and then they needed to locate some
users to perform those actions users
that had credentials that were logged in
and the way that they can feed links to
users are actually numerous so one of
the most popular ways is social media
you can just post a link on a Twitter
post or put it on Facebook it can also
target it maybe your website by knowing
what some sites are worth related
content that might have vulnerabilities
and attack those or they can just do it
scattershot if a million users browse
see surfer tack most of them don't see
anything happening but one of those
million is a user that's logged into
your website then mission accomplished
as far as they're concerned so does this
actually happen in the wild the answer
is yes here's some scary headlines I
apologize if any of them are your
company you're not alone but you might
ask okay sure this has happened but what
actually is the prevalence of cross-site
request forgery vulnerabilities well
we're actually coming from static
analysis telling me that looks at a lot
of different code and a unique position
to answer that question so let me just
share a little bit with you what we
found so as part of constantly improving
and evaluating our tools we analyze a
whole set of Java web applications a
couple dozen and I've collected some
statistics here about the
vulnerabilities that we found now
obviously this is bias to what the tool
can find and you can take it with a
grain of salt if you absolutely want but
it's at least some quantitative
measurement so here are just five
vulnerabilities on the right side we see
a sequel injection
that's where sequel query is some
malicious codes rejected and injected
into it
Java web app developers have known about
this for years and actually have done a
pretty good job at we're meeting and
remediating against it so there's not as
many of those paths manipulation is
where
some unwanted directory traversal is
injected risky cryptography it's pretty
self-explanatory
other than that the next biggest is
cross-site scripting and dominating that
by over a two-to-one factors cross-site
request forgery so this is open source
web applications and there are some
bright spots in that field some of them
are doing it right but it's a fair
characterization to say that they're a
little slower in the uptake of security
fixes so you might ask well what about
enterprise applications and at least
there's a measurement for open source
web applications there's about 120 see
Cerf ulnar abilities per million lines
of code
interesting to note for enterprise web
applications we see about the same
pattern it differs a little bit um these
two example companies are doing some
things right
one of them has no sequel injections
both of them have no risky cryptography
that we could detect what cross-site
request forgery is still the number one
average issue between them so it's a
problem in both open source world and
for enterprise applications so you've
been attacked
that's unfortunate what are you gonna do
well one of the problems with C Cerf is
that it's difficult to distinguish
between real and forged requests from
your point of view as a server
administrator both of these requests
come from the clients browser both of
them come from the same ip address and
both of them come with the clients
credentials so like their session
identifier if you look in your tomcat
log both of them are gonna look the same
so if you want to imagine some sort of
programmatic way to unwind an attack
like go back to some previous safe data
and then replay it it's very difficult
to do because the attacks are
indistinguishable from the actual
requests that the users make so it's
really tough there's not much you can
actually do short of calling up your
users and saying did you actually intend
to make that request but that probably
gets pretty tiresome for them and I
don't know if it makes me a bad person
but I'm still waiting for my stockbroker
to call me and ask if that time I sold
Apple in 2000 was a sea serpent act but
hasn't happened yet so the only answer I
have for what to do if you're attacked
is give some tough love and say that you
need to protect beforehand so I'm going
to want to talk about protection I want
to just start off by saying there are a
lot of things out there that don't work
some people think that they do one of
the very first suggestions to fixie surf
was to use only posts requests this was
from the early days when the
vulnerability first appeared and was
based on the fact that people only knew
about the image attacks so they were
only seeing the get sea surface acts of
course as I've just shown you he could
do the same thing with the post request
so that's not valid anymore
I'm HTTPS you should use it it encrypts
your link but it has no protection
against cross-site request forgery I've
seen on some bulletin boards a lot of
interesting suggestions about doing
things to this session identifier to
help with sea surf some ideas were
multiple session identifiers for the
same session you can change the length
or randomness one suggestion is to
shorten the expiration of the session
identifier and this of course does
shorten the attack window that someone
can hit you with a sea surfer tack but
if you're happy with a shorter attack
window but still vulnerable application
that's the way to go if not you need to
do something else and one of the more
interesting suggestions that I've heard
lately is the use of are you sure
dialogues so the idea is to pop up some
dialog and ask the user if the action is
really intentional and that's a really
good way from preventing unintentional
things happening in your legitimate web
code it has no use whatsoever for the
attackers attack so they're just
circumventing this and doing whatever
they wanted to do anyway so there are
some things that do work fortunately
we're not all at the mercy of Road
pirates referrer validation is one of
the things that does work many web
browsers include a referer header that
describes the origin of the request so
what page you browsed from problem with
this is it's not always present
some browsers can remove it there's
actually some Network hardware that can
remove it and usually this is done for
privacy reasons because it's telling you
where you came from not everyone wants
you to know that it's also not present
for certain transitions in between HTTP
and HTTP so what do you do for these
cases well you have two choices
essentially one choice is you can be
leaning about this and allow these
requests to proceed problem is is that
that's going to be insecure you're still
vulnerable there or you can be strict
about it and make your website and
accessible to those users that have
their referer header stripped though
that's top choice another option is
custom headers so instead of using refer
you can actually add a header of your
own so you can do this using javascript
there's the XML HTTP requests function
this one of the things that can do is
allow you to add your own header problem
is is that you can only use the
JavaScript XML HTTP request to send your
post requests this doesn't work with
HTML forms so if you have any forms or
any sort of legacy HTML of that sort
this is not a viable solution for you
the reason that this does work is that
all modern browsers respect this same
origin policy and what the same origin
policy restricts attackers from doing is
to add a custom header to a request that
goes to a different domain so our
different origin so a different origin
is defined as some website with a
different scheme hostname report so the
browser browser prevents see surfer
talks through that restriction so the
most general solution and the one that
we see most often in code is the use of
secret tokens so the way that secret
tokens work is that the server generates
some shared secret between you and the
legitimate client this is included as a
hidden form parameter so here we've got
some HTML form that does something the
canonical transfer example and it's got
hidden input that we inserted I called
it anti Caesar but you could call it
anything you want and it's got this
shared secret token the
the server is generated and stored and
remembered so then when the user goes
and submits that form the server checks
that the token value that's submitted is
the one that it previously generated and
stored if it's valid then the request is
the quest action is completed if it's
not valid then you know you have a
forgery on your hands so the way that
this is secure is that it also relies on
the browser's same origin policy the Dom
is inaccessible to pages from another
site so that hidden field in the forum
you can't access if you're an attacker
with HTML on a different page the token
has to be of course unguessable most
people just use a cryptographically
secure random values like it's similar
to a session ID but not a session ID if
you're using your session ideas your C
surf dokkan then something's bad you're
about to get hosed sooner or later the
token also needs to be temporary most
implementations use a like a token
lifetime of out of a session so between
the user's login and logout we can
actually do something shorter if you're
really really concerned about C surf the
problem is is that users may find this
annoying because if the token expires
and they hit the back button on the
browser then that request gets rejected
for being invalid and that's not ideal
so just to illustrate to make clear how
these secret tokens foil attackers so
let's say my insecure bank hired a
really sharp security guy and he went to
fix all their problems he might consider
adding again this anti C surf token to
their page the transfer money page and
when the user goes to post this
particular request they get the cookie
with the session ID that's their
credentials the account the amount and
it also includes the c-cert Okun the
corresponding hackers request doesn't
have access to that value so they can
leave it off and then the server will
just reject that request so that
insulates my insecure bank from Visa
forged requests
so next I want to move on to some
implementation choices so I'm gonna
focus mostly on the use of secret tokens
I think they're custom headers and the
referrer validation are pretty
self-explanatory they work for you
that's all the better
but with secret tokens we need to do two
things we need to answer the question of
what do we need to protect first of all
and then make some choices about how to
protect it so as far as what to protect
basically anything that modifies the
webapp state is something that you
should at least consider protecting
database updates changing anything on
the file system things that are
long-lived attributes so like session
scope or application scope attributes or
things you might want to consider
protecting interesting login pages are
something that are often forgotten so
login pages don't typically have a
session identifier but because they're
updating the web application state
they're in fact setting the session
identifier it is possible to conduct a
sea surface against the login page so
I'm not going to go into this particular
attack in any more detail but I
absolutely encourage you to investigate
it if you're not familiar and one of the
things that's challenging for enterprise
applications are if you have back-end
services that you're communicating with
from your front-end web server these are
things that may modify their own State
and they need to be protected just as
much as if your web application or
changing the database but you can't go
and protect everything in the web
application life would be much easier if
you could you could just deploy your
protection and forget about it but you
need to implement some holes in it
because there are certain things that
can't be protected or at least are
functionally incorrect to protect some
examples of these are landing pages so
someone's intentionally browsing to your
website from another domain you don't
want to protect against requests for
another domain things that are stateless
or unauthenticated these are not
something you care if someone's forging
right if it's an unauthenticated form
submission like maybe an account signup
or something the attacker could very
well just do that on their own they
don't need to forge it from your clients
browser and in general anything that's
bookmarkable
so these are links that you want to be
long-lived and the sea sir proken is not
long-lived so you need to be holes so
when looking at the code that we've seen
through our static analysis
investigations we can say that maybe
most checks fall into one of three broad
categories so there probably other ways
to do this but almost everything is one
of these three ways first one being
manual checks so when I say manual check
I mean some programmatic way to check at
each entry point whether the sea serpent
is valid so here we've got a servlet
it's a do post handler so it's handling
post requests and you can actually just
insert a function call that's checking
for the parameter that you expect
whether that's a sea surf to open that
you've previously generated if it's not
and throw an exception don't go any
further and you protected yourself right
there manual checks are nice your server
containers dispatching to anyone of your
request handlers and you can introduce
this century at whichever ones are
needed so here I have a little century
icon right it's on two out of three this
gives you a really nice tight coupling
of the functionality and the security so
you've really fine-grained control the
protection so this is nice because you
need to decide on a request by a request
basis whether it needs to be protected
or not the downside to that is that you
need to decide for every request whether
it needs to be protected or not so
developers need to think about this it's
no longer set it and forget it you have
to think about sea surf every time you
write a new entry point to your web app
not ideal and the more opportunities for
you to make mistakes the more
opportunities someone's going to get
into your application so pros and cons
servlet filters are another way to
implement sea serve protection this is
actually one I think it's most common
you can actually do it using a servlet
filter or I'm going to lump some other
things into this category like I know
spring has some mechanisms to do
something similar and the servo filter
is just a single monolithic check for
your entire web application so it's
checking the requests for all of your
specific individual request handler
the bad side of this is that it's a
loose coupling of functionality and
security so what you need to do and what
you need to get right is correct
behavior in two places so your requests
are either updating the stated
application or not and your server
filters either protecting the requester
or not and if those two things aren't
synchronized and you've got problems
probably got a vulnerability last but
not least there are some anti sea surf
libraries out there so uh Frank
mentioned yesterday oh I see surf guard
probably the heavyweight in the room is
spring security they now have a CC surf
solution since version 3.2 and Apache
has something equivalent and these are
really nice they give you code that does
the token generation and management
you're going to avoid errors in that
they also do a lot of the legwork for
you so they have some ways to modify all
your views so that the forms will submit
the C surf tokens and that's great you
don't have to change all those that's a
lot of implementation effort but they
don't solve all the problems in
particular they don't tell you how to
protect something or sorry they don't
tell you what to protect they all make
some simple assumptions about what parts
your application need to be protected or
not with some limited configuration so
if your application is more complicated
or your security obligations differ in
some way from the configuration
dimensions then you're a little out of
luck in these cases and they also have
known security weaknesses so one of the
examples is that they expose tokens so
the token is out of deforms and the
token is out of deforms to your website
but also to forms that are submitted to
other websites so in the off chance that
your forms being submitted somewhere
that you don't want the person to know
your anti-sea surf token and that's
possibly a security vulnerability so
there are some challenges to using any
one of these Caeser protection
strategies so I'm going to in this
section focus a little more on some code
examples so we've collected some from
open source hopefully this illustrates
things not to do
so the challenges are essentially how do
you implement these exceptions so you've
got to specify or define them in some
way and you've got to decide and
evaluate whether they're correct doing
this requires both some security
expertise so you need to be able to
evaluate the security consequences of it
but you also need some knowledge about
the functionality of your applications
so you need some development expertise
as well and finding someone that can
wear both of these hats is often very
challenging these organizational roles
might not be found in the same person it
might not be found in the same part of
the organization or even the same half
of the world and also retrofitting an
existing system is really challenging so
it's nice if you can generate a new
architecture so that your customized
around one of these c-cert protection
schemes but if you've already got a web
application that's in the field you
can't change the architecture of the
request and that's what it expects so
there's some additional challenges if
you have to backports eserve protection
and something that it's already a
functioning web app so the single best
thing that we've seen to minimize your
risk of sea surf owner abilities is to
use the correct HTTP verbs so if your
application is restful or you subscribe
to that philosophy this is gonna make
your life much easier in terms of sea
surf protection the reason is that these
HTTP verbs so get post put delete they
give a language that's meaningful to
developers most developers know when you
should each use each one of them and
they also simultaneously capture the
security obligation so you've got a
developer he sees a get request he knows
that this is something that you use for
requests without side effects something
that's item potent a post put or delete
right these are things that you use for
requests that have side effects or
change your web application in some way
and your security auditor when he sees
these two things he sees a get request
and he knows that it's something that
doesn't need Caesar protection because
it has no side effects and post put and
delete these are the vulnerable entry
points that need to be protected our
security auditor has a tie I just
noticed I don't know about your
organization but I think our security
guys are the least likely to wear ties
and the gum
but I'll change that one next time so
that's great if you do that the problem
is is that it's easy and tempting to not
get the HTTP verbs right everyone's got
that one case where you're restful in
the rest of the application but you just
want to use a get request for that one
state change it's easy and tempting so
here's a piece of code from an Java open
source web application it's a spring MVC
3.0 controller some cart so you can even
read the comment what it's doing it's
adding an item to the shopping cart and
you can see that it's an entry point
because it's got the request mapping
annotation and you can see also that the
request method that it's handling are
get and post so clearly if the rest
application is restful and this is
adding something into a shopping cart
you don't want to be using a get request
to do this so the reason that this is a
security problem is that if someone
comes along and expects that only post
requests need to be protected this one
thing is going to be a glaring hole it's
going to service get requests that are
state change and that's not going to be
protected by this post protecting only
see surf scheme so that's in fact many
of the schemes that many of the anti sea
surf libraries use so this is
problematic so are there any spring
developers in the audience so okay so
anyone know what happens if you leave
off the specification of the request
method right it serves all of them so
that's even easier to mess up in my
opinion than to get it wrong is to just
leave it off so this is particularly
problematic again because it's
functionally correct it's going to
handle the request method that you
expect but it's also going to handle the
ones that you didn't protect against
Caesar so that's a giant gaping security
hole so I've talked about using HTTP
HTTP verbs not everyone can do that like
I mentioned if you're a legacy
application and you've already got some
transaction architecture you may have to
resort to something else fortunately
that's something else isn't pretty
so here is a example web.xml file from
java open source web application so what
they're doing is they have some filter
class that's protecting them against C
surf and they have exceptions because
they need holes like every web
application unfortunately the way that
they're specifying them is very
difficult to understand so it's a common
delimited list of both the combination
of web.xml style URL patterns and some
regular expressions so if you are coming
to look at this for the first time
you're a new developer or security
security auditor how in the world you
supposed to tell it's protected so
there's also even something fishy with
this that an early audience member of my
slide presentation noticed they
suspected it was a copy/paste there
anyone see what it is
so it's the last three lines they've
lost three regular expression lines
don't have a comma after them whereas
the rest of them do so what does that
mean who even knows this is some custom
code I mean if they get it wrong that's
their problem so here's another example
of if you try to do this on your own for
a complex application this is a way that
particular Enterprise web application
specified the exceptions in their servo
filter so this is essentially the logic
diagram for the servlet filter that they
implemented and this didn't come from a
nice piece of documentation or a
specification I had to extract this
through some very deep code archaeology
so on the on the right side you can see
it's just like a flow diagram of the
various things they're checking to
decide whether they want to require a/c
served open or allow the check to go
through and the places that the data are
coming from that allow them to determine
whether that should be accepted or
rejected our set of hard-coded literals
in the code somewhere not in the server
filter multiple property files and some
parsed XML trees so if you're again an
auditor or a developer and you want to
add an exception or evaluate whether
it's correct what the world do you do
here it's at least not an ideal
situation one thing that you can do is
at least to verify that you've got it
correct so if you take the simple route
and use HTTP verbs to define what your
protection obligations are you can at
least enforce or verify that they're
used properly so that's pretty easy to
do and if you need to make any
exceptions maybe because you're not
using HTTP verbs to decide your
protection obligations you need to
carefully evaluate them maybe with
security auditor sitting behind you or
at least someone that's very
knowledgeable about the web application
so you need to ask yourself whether the
request handlers are changing the server
state but wait how do you even tell that
so I've got another example here this
one's from a open source java web
application it's a request handler
so if I want to decide whether this
changes the state or not I look at this
code and I'm gonna spoil it and tell you
that there is a side effect in this
method what can you even spot where any
guesses
yeah how's that
that's actually a very good guess got it
right to me that's not obvious because
it's getting the root content vo so this
is just a view object but it actually
writes to the database exactly like you
said if it didn't exist so you'd make a
very good security auditor but um I
don't expect that a security auditor
that I hired would look at this code and
let's be honest they would probably look
at this code for about as long as we
just did right here because there's many
other entry points to consider the
chances that they find this based on
this inoculating function are I think
close to zero so what can you do is
there anything we could do to make our
lives easier I've got to make sure that
these things are implemented correctly
so warm approach that I know a little
bit about is static analysis so this is
at least one tool in the toolbox that
you can use to make sure that your
cross-site request forgery protection is
correct the way that the static analysis
approach works is that we use a tool to
automatically identify the methods that
update the state of the application so
again these are the things that have
database rights file system rights etc
you can also use the tool to compute the
coverage patterns of whatever see serve
protection you've implemented if you've
even implemented any and this could
include things like looking at the UI's
that filters are mapped to and whether
they intersect the URIs where your web
request handlers live can be looking at
the manual protection at every web entry
point whether it's present or absent and
for these libraries involves digesting
some of the configuration to see how
you've set it up and what URLs and what
request methods are covered so if you
can automatically compute the coverage
patterns where the vulnerability is live
is an intersection of these two if you
update the state and you're not
protecting it in any way it's at least
something that a human needs to look at
so just to give you a quick look at what
some of these look like to be a walk
through this is our web application so
you can run stack analysis on your
source code you run it once you get a
set of results and in our workflow you
commit it to this web tool called
connect gives you a list of all your
issues we're looking at some source code
here it's annotated so that all these
red and orange boxes you see here
describing the things that are happening
in it that the tool is derived and then
on the right side we've got a navigation
pane with the list of events the rest of
this involves ways to like manage the
defects and track them and triage them
and make sure that you're following up
on fixing them I'm gonna ignore that for
now since I want to talk about Caesar so
let's dive into a piece of code so
here's a yet another sea surf defect so
let's let's tear this one apart see how
they're doing this so um what the tool
is telling us first is that it's
identified a request handler so you can
again see that there's a spring request
mapping annotation if I were to look at
this I would see that hey it's a saver
view method it's probably doing
something to update the state of the web
application in this case I think it's
saving some sort of product or real the
tool of course doesn't know that based
on the name review item so it has to
accumulate some evidence in another way
but it can still identify that there is
a state update so here it's called out
this call to rating service review item
as something that's updating the
database so the reason it knows that is
that in this particular case our tools
interprocedural so it can dive into
Khali's so if we ourselves dive into the
call you can just click on it the web
interface it will show you what it
thinks about what's happening in that so
here if we look in the review item it's
in the rating service in bold Java so
it's uh not an interface but the
implementation i've allotted some of the
lines of code but here it's calling out
another call in this so call the rating
summary Dao dot save rating summary
again any human looking at this could at
least tell that this is gonna update
something the Dao layer
but the tool also gives you the full
chain of justification of why it thinks
that this updates the database and at
the very bottom of that chain of
justification here's this call to a MDOC
merge so this is of course to call a
Java persistence entity manager which is
a RM write a database update so the
other half of what the tool is telling
you is not just why it thinks you need
protection on this particular entry
point but why it thinks it's not there
already so in this case it's noted that
there are manual checks elsewhere in the
code and in fact it's going to show you
examples of positive checks as evidence
that the entry point we just looked at
was missing one so here some were
totally unrelated in this particular web
application it's a you can see it's a
different controller the upload add or
update controller it's highlighting a
see search ech so this is pretty obvious
from the comments it's a check for X
same things that just different acronym
xsrf and there's a call here to this
exploit protection service compare token
so it's exactly just checking the
service object is generated this token
previously it's just checking that it's
a valid one so we actually find that
this particular half of showing security
defects is the most important half so
this is the remediation advice so if you
actually have to fix this it's not
enough to just tell a developer who may
not be familiar with C serve may be new
may not not know how you do it in your
web application it's not enough to just
tell them that they're vulnerable it's
very valuable to officers tell them how
to remediate it and this holds true for
all sorts of security vulnerabilities
since that expertise isn't present
always in everyone in your organization
so here's just a quick quiz I want to
see if you're paying attention because
in this entry point they violated one of
my rules anyone see what it is I know
the codes small I apologize
exactly so this is not using the HTTP
verbs correctly never a good idea in
this case they implemented their C surf
protection using manual check so it's
not going to actually necessitate that
there's a vulnerability because of that
but if they were to switch over to
something like using OAuth C surf guard
which protects post requests by default
then this would be left out in the open
so good I okay um I just wanted to wrap
up with some conclusions at least about
what we've seen today don't let anyone
tell you otherwise
sound cross-site request forgery
protection as difficult to get right and
usually the way to get it right is to
not build additional complexity into it
and I realize it's very very tempting to
build additional complexity and to
already complicated enterprise web
applications but the simpler you can
keep it the more likely you are to get
it right and particularly the more
likely you are to get it right in the
future HTTP verbs use them they're a
great language they're already there
they're well specified and they've also
captured the security obligations for
cross-site request forgery
that's probably a piece of advice that
applies to any developer anywhere not
specific to cross-site request forgery
but be clear about what your method is
doing especially in the case where you
have a human auditor looking at your
code or maybe evaluating the result of
the tool you need to see what the
methods doing and be able to quickly
make a judgement about the side effects
so you don't know what to protect if
it's not obvious to you and well you
probably could guess this already but
having some verification is important
and probably actually from a security
point of view having multiple methods of
verification is important having human
human auditors look at code I'm
employing any tools that you can use
static analysis the more you can unleash
on your application to find these
defects vulnerabilities the more likely
are you to avoid the pain and Caeser so
I'm gonna open up a few minutes early
here for a question and answer if you
have any curiosity about the technology
that's the website we've also got this
free Java software quality evaluation
going on and when I say quality that
doesn't unfortunately include the
cross-site request forgery checker which
is a looking for a security
vulnerability what I'm sure it will
still uncover lots of interesting
quality violations that are similar to
this one in your application and without
any questions
yes
so the comment was that in or get
requests that you still need some
protection in many cases and that's
absolutely true
if you don't partition your verbs
correctly so if you're still doing some
sort of state changing transact
transition with a get request which is
totally fine to deal
yeah yes so keep in mind that from the
attackers point of view when they
unleash one of these pieces of HTML
unlike some chats I adore and some
vulnerable website and you run it
they don't actually see the result so
it's not necessarily a direct type of
information back to them but if it has
some side effect that in some way
becomes visible to them are they're able
to use like money transfer to their bank
account but they're there many other
similar things that are a little less
crazy that see server attackers can do
so there they're really gaining the
value through that side effect not
necessarily through a flow of
information but you're right I mean
there are many other web application
vulnerabilities that are caused by
sensitive data leaks but yeah I don't
think that this particular protection
scheme will protect against those
that's absolutely true it is pretty
complicated if you can use one of the
simpler methods like custom header or
refer validation sorry yeah this is it's
sort of um orthogonal issue to
authentication because you can still get
off them to kitchen wrong but in cases
where the user is authenticated
correctly what the sea surface is it's
using that authentication to do
something even additional and unwanted
so yeah um yeah I unfortunate don't have
an easy answer for you but that's the
state of things at this point question
and they are separate products so we
have a question was about the product
hierarchy and at Coverity so there's a
product called quality advisor that
finds these sort of concurrency resource
leak all sorts of software quality
defects that and that is sold separately
from the security adviser which is
targeted to Java web applications a
question
we're going
it's not necessarily insecure so if you
don't trust where you're submitting your
forms to so if they're going to some
other domain the problem is is that
these tokens get out into everything
unless you do something to mediate that
and um if an unsecured person in another
domain is receiving your form it's going
to have an extra token in it that gives
information that they could then used to
launch a Caesar for tack through some
other vector you probably don't want the
token in anyone else's hands if you can
avoid it
again it's requires a specific security
evaluation of that particular system and
what your trust levels are to the
various entities but it it is a
potential vulnerability for some people
the question the fence
so for custom hunt headers you don't
actually even need to use a token the
reason is is that you can only add a
custom header to a request that's
originating from your domain so that
header won't even be present there's no
way to add it right because of the
browser's same origin policy if that
request is coming from HTML on pirate
chat or some bad link right that can't
add that header and send it to your
domain so you're safe just by the
presence of that header don't need to
worry about the token generation in that
case it's a question over here the
question was what's the justification
for expiring the sea surf token and yes
it's absolutely to prevent that from
leaking somewhere help you absolutely
should make it on a per user basis right
if you're using the same sea surf token
for the whole application and the
attacker can create an accountant and
see that and forge other people's
requests but um how often you should
change it is just a matter of your
comfort level with that persisting I
mean users can still leak these things
if you kept it around forever if someone
would copy and paste right maybe a page
source to show an example on a web
developers forum it might accidentally
include the sea serpent right pending
cases like that you want to avoid but
yeah they're pretty rare
it's an excellent point the point was
that if you lose your phone then now
you've lost your Caesar token and now
you're vulnerable to attack if that is
persistent
so there's question in the back against
the pillar mm-hmm yes that is will not
provide you protection against Caesar
the reason is yeah
well the problem is that serving and
down in the cookie doesn't have the same
origin restriction so that cookie gets
sent with a request to your website even
if it comes from somewhere else so
you're you get hos that way
question back to and the black that's
true yeah the the point was that um if
you don't use HTTP then the request
traffic is subject to snooping and you
could lose the token that way and the
other points absolutely correct I guess
the best you can do at that point if you
are assuming that attackers snooping
everything and you aren't able or aren't
willing to use HTTPS you're you've got a
hole there I guess the best thing you
can do is to change the token as often
as possible yeah absolutely right
question
so the question was does it matter where
you put the token well it needs to be in
the form on it if at least if you're
using traditional HTML forms so wherever
the form is in the body is where it
needs to be if you're doing something
more sophisticated like using javascript
to send these X to XML HTTP requests you
can put in the JavaScript in the header
that's fine
the reason is that the header is like
the rest of the body it's also protected
by the same origin policy so you're safe
there a question in the front
so the question is how do you persist
and manage I think in general what
general management strategies for the
tokens so usually what happens is the
way that it's most commonly implemented
is on the server when you initiate a
session the same time you generate the
session ID you just generate a new C
served open-face valid through that
session so if there was an old one and
you generated a new session ID you might
as well just generate a new C serve
token as long as you know what the the
valid token should be for a request so
later if they browse somewhere and come
back or don't log out that token will
still be stored on the server somewhere
that it can be checked against a
question
yeah that's a common way to do it I mean
you like I said before you can have it
even shorter live than that that anytime
you generate a view you can generate a
new token that corresponds to that view
yeah that's exactly the problem so it's
just it's just convention that the
common point to do it is it login like
we were talking about earlier you could
even keep it for a longer than a login
it's probably not a good idea and I
definitely don't recommend that but as
far as if that token is kept secure that
that does work too so generated to log
in is the best way to go so that
question in the back
yeah I suggest googling it you can find
I think there's a an academic paper
about it that guides you through it
generally the idea is that the attacker
can forge a page and have you log in as
them so then essentially what gets
stored is a session ID that corresponds
to the attackers account and then any
actions you perform will possibly leak
information to them or do something with
their credentials on the server so to
protect against that case there it's not
obviously not possible to use this see
surf token for that case but there are a
few other ways including the ones
mentioned with headers the way that is
also always safe against sea surf is the
use of a CAPTCHA so if you have a really
secure account or if you're generating
an account logging in in a particular
secure way CAPTCHAs are our safe
so the question was if the hacker
becomes aware that there's a token how
they might try to grab it so there's two
is you can imagine that they might grab
it so if they have access to your wire
and they can see what the server is
actually sending right then that's your
vulnerable well it's not a cookie it's
something that's in the HTML of the page
so it's actually in the form HTML yeah
so right obviously if the hacker was bad
keep at complete control of they could
define the browser code that's that is
information that's in the browser
somewhere but all the modern browsers
partition it so that that's kept in a
sandbox so they can't actually say that
okay there's some trick to how you
manage the tokens on the server and that
requires some sort of caching mechanism
you got keep it first enough length of
time and this is actually one of the
reasons why using one of the anti sea
surf libraries is great they all
implement that and they do it well so
they keep this cache and you can set the
expertise and there's nice policies
about that so as far as implementing
that I highly recommend looking at those
any other questions all right thanks for
staying late I really appreciate it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>