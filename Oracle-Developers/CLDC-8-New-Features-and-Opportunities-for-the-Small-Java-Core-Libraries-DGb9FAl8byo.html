<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CLDC 8: New Features and Opportunities for the Small Java Core Libraries | Coder Coacher - Coaching Coders</title><meta content="CLDC 8: New Features and Opportunities for the Small Java Core Libraries - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>CLDC 8: New Features and Opportunities for the Small Java Core Libraries</b></h2><h5 class="post__date">2015-06-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/DGb9FAl8byo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Mikayla golly I'm here
together with Roger Rick's and we talked
about CL dc-8 the platform we have been
working on as part of the java community
process effort kazar 360 i'm glad that
we have a couple of members of the
expert group also being participating
here and we take you during the
presentation through all the new
features that we have been including
into cldc this is the safe harbor
statement so we are outlining a general
product direction it's not intended for
its intended for information purposes
only and may not be incorporated in any
contract it's not a commitment to
deliver any material code or
functionality and should not be relied
upon in making purchase decisions the
development release and timing of any
feature of functionality described for
Oracle products remains at the sole
discretion of order crew so CL dc-8 it
has been the Java platform for connected
device since many years it has been in
feature phones since the year 2000 it's
a platform for devices with very limited
memory and CPU power and for those of
you have been in the keynote there are
bigger things there is a standard
edition there is enterprise edition and
here we focus very precisely on very
small limited devices we have been
working hard to update the cldc platform
with support of Java 8 language features
and new library ap is we define a
state-of-the-art runtime environment for
small embedded devices and we provide a
set of carefully defined and also
tailored and small libraries that are
most useful for resource-constrained
devices we target embedded devices with
the platform such as well as modules you
can see a company presenting at least
one company presenting and the democrats
a wireless module based on CL DC and
smart meters health care monitoring and
other m2m devices
see of the c8 as I mentioned is
standardized in the java community
process the number is jsr 360 and we
have experts from embedded in mobile
industry in the expert group we have
split our talk into three parts so we
start with a more common introduction
into Java ME and into the evolution of
the micro addition then we have one
section about the connected limited
device configuration and then we switch
over to Roger where we talk about the
generic connection framework the next
generation Java ME platform is the first
step in the alignment of Java me and
java SE it's a dedicated embedded
platform so it's a general-purpose
platform but it's a general-purpose
platform for embedded and smaller
devices it addresses increased range of
use cases and markets than its
predecessors which were yeah targeted at
specific markets and it combines a
couple of key features in the definition
so the entire area platform consists of
cl dc-8 where we have the updated vm and
the alignment with se8 there is the Java
ME embedded profile eight where there is
another talk at this conference about it
that's an embedded application platform
the key features include a value add as
a value add new and enhanced api's and
features for embedded and we improved
the configurability and optimize the
footprint for development and deployment
into a small targets so the smallest
blood well a small platform would be 128
kilobytes of RAM and one megabyte flash
and ROM and there's even a smaller
compact configuration that can go into
smaller Haram space target markets are
small to mid embedded devices with a
wide range of use cases and markets like
intelligent devices
for edge computing communication nodes
health care devices measuring your blood
pressure or general health status than
smart smart sensors smart meters and in
general Internet of Things and m2m are
the target markets for the platform if
you look at the broad range of Java
platforms for desktop and smaller things
we see in this diagram we see different
memory areas for footprint and we see
different CPU types and as we can
clearly see Java ME is not the smallest
platform there's even a smaller one
which is Java card for very limited
cases for smart cards and Java ME is
targeting yeah slightly smaller the
slightly bigger devices like there's a
pen there is a smart meter there are
embedded modules there are just embedded
developer boards and things like that
Java is e everybody knows so I don't
need to talk about that and while we
were doing the specification we have
been following a couple of key
principles so we have been very careful
to define a strict subset of Java is e
to make sure that code that gets
developed on Java ME is compatible to
the bigger Java platforms so when
developers use and create an application
for cldc they can take Kate can take it
on java SE and the application does not
have to be rewritten because you've
learnt the same API is due to the subset
um em II vs. izzy is a footprint and
functionality trade-off this means that
on the Java micro edition of course you
don't find the full wealth of all java
SE AAP is due to footprint
considerations we have been focusing and
stripping to
the essential functions that are needed
for multi-purpose programs the release
cycles of the platforms are in sync so
Java ME 8 and java SE 8 is going to be
released at the same time frame a
benefits of this unification and work
towards a same platform is that we have
first of all enemy a modern and flexible
platform for embedded software which is
state-of-the-art you use the same
development tools so we unify the
developer experience by having the same
tools that people don't have to learn
specific tool chains or specific tools
to write small embedded things you just
use your normal standard edition tools
you can use netbeans for example and you
can use DME SDK we have alignment on the
Java language and core ap is on
development and tools and we enable
there for the people who are familiar
with desktop Java to go into the
embedded space here's a nice picture
that shows the Java me a platform with a
set of different components and api's we
are in this talk just focusing on the
lowest layer of it which is the Java VM
the CLD c 8 and the generic connection
framework which is the common way of
establishing network connections over a
variety of protocols there are other
components I mentioned before the Java
ME embedded platform which is being
standardized is j's are 361 and of
course for those of you familiar with
Java ME in general there's a couple of
other JS ours that have been in the
field for quite a while that can be used
also on this platform like the secur
security and Trust services the South
searches are and some other chasers like
wireless communication messaging
location sensors and so on
when we think a little bit about
embedded an embedded device is not a PC
so you have typically a completely
different setting of that constraints
what you can do on the platform and that
also constraints the way how you develop
so normally you have a very low cost
platform with a small memory footprint
you don't have anything like a hard
drive or in most cases you also not even
have a display you have limited CPU
horsepower so platforms our cycles in
megahertz and not gigahertz normally
many devices are very limited also in
terms of user input so you don't have a
mouse or keyboard sensors instead you
don't have a pc type of user interface
no graphical things and your eyes of
often based on sensors or switches or
some a couple just a couple of keys and
not really adding a common UI type of
thing these devices also have very few
external interfaces and as I said before
small or no persistent storage so in
many cases there's no disk there may be
flash memory also they often run on a
very limited OS so you don't need linux
to run cltc you can do do a deployment
on a very small restricted or s or just
a set of libraries that represent your
operating system and also these devices
are typically low power this is a sample
board that we have also set up in the
demo grounds so we have any eight
running on that an early access version
this is support based on the SD micro
cortex m4 it's a 32 bit bored one
megabyte of flash 192k
from and it's really low cost so one
fifteen dollars if you buy the single
piece and it's scarce down if you if you
buy it in volume it has a couple of
sensors and a couple of buttons no
display nothing that could be used for
you I so just one example we have
another one Raspberry Pi which is
probably very familiar for everybody
also low cost twenty-five dollars based
on the 700 megahertz broadcom CPU arm11
core 512 megs of ram and so you see this
this type of devices and there are more
less DJ multi-platform whether also a
demonstration in the end the demo
grounds so please go there and have a
look at these demos and you get a better
idea from as we could transport over the
slides of what the devices are like so
now we see the scene of the devices and
now we go a little bit into the Java
side of things and then to the api's um
we're doing an evolutionary update for
cldc so cldc has been standardized and
has been around as a JSR before and we
have been adding additional api's to
make the platform more developer
friendly we have been doing a vm update
and we have been very cautious to still
remain small and enable embedded enable
footprint optimizations we are an
extended strict subset of java SE 8 we
have consolidated the generic connection
framework that has been spread across
different specifications and backwards
compatibility was kept in mind when we
did that you will see the architecture
of the whole thing so cldc the lower the
layer below you see a block in the
middle which is called compact
configuration so this is a subset of the
CLD c api set
that was tailored to fit on a device
with 512 kilobytes of flash and you find
very common and familiar packages so you
have java.lang you have Java I oh you
have Java util Java security and a
couple of exceptions from java.net as
part of the smallest possible
configuration besides that in the full
cldc configuration you find the niño
files channels and buffers and the
logging API as the additions here on top
of that we have the generic connection
framework with things that have been
around like HTTP HTTPS socket server
socket and Datagram and in addition the
new things are a multicast socket
extension for multicast datagrams secure
datagrams where we have a TLS protocol
for sending datagrams over UDP and the
modem connection which offers a way of
controlling modem lines and Roger will
address all these things later on in the
GCF talk so two configurations cldc is
scalable to small and very small devices
the thing that we call cldc
configuration is the complete set of co
dcap is which provides the maximum
functionality for applications with a
typical footprint of one to two
megabytes of RAM and the compact
configuration which defines a subset of
the cldc configuration for small and
very small targets where we don't have
the logging and nioh and resource
constrains our 512 care from
you can optimize the footprint even
further so there is a method or a
technology gods tripping on deployment
so when you think about a device that's
only running a single application you
don't need to provide the full set of
Java classes with it so you can just
strip the classes that you don't need
during the build process and just deploy
a subset of the API that you just need
for the application so you bundle the
application with the runtime and strip
away the things that you don't need
which results in the minimal
non-modifiable binary consisting of both
the application at the runtime now we go
into the new language features that are
supported on CL dc-8 so and they should
not be surprises for people coming from
AC so we have assertions which are a way
of statically testing conditions that
have to be valid to to ensure that the
constraints of an interface icant or are
kept then generics we as a consequence
also added could support for the
collections and extended the collections
there and adapted them to the generics
we have the enhanced for loop autoboxing
enumerations are supported variable
arguments a static import and
annotations on the annotations we have a
limitation because we don't support
runtime annotations but just source type
annotations phantoms annotations are
included but just not accessible but
that's a minor detail in addition we
have strings and switches so you can now
use a string as a as a case label
mmm binary literals with a separation of
an underscore to improve the readability
multiple catch on multiple exceptions we
have the improved type inference for
generic instance creation which is more
popularly known as the diamond operator
and a try with resource statement on the
library updates we added the service
provider a concept for service providers
over the service loader we added event
objects and event listener which are
commonly used in some frameworks that
are built on top of that we defined a
subset of the niño buffers and added ni
of us and NL generals we added a subset
of the SE logging API we had a string
builder and string for matter the
comparable interface and as a
consequence of the tribe with resources
we added closeable and auto closeable we
added new collections that have not been
in CL DC before so now we have the list
types error list and linked list we have
the map derived ERV collections like a
hashmap linked hashmap week hashmap the
set classes the queue classes it rebel
and iterator and the list iterator so
you can consider their the set of
collections a pretty complete set of or
pretty complete subset the only thing
that's really missing is probably sorted
sets and they can be provided by
applications a quick focus on the
service providers that's an extension
mechanism for the platform which allows
to provide services that are delivered
at a later point in time into into an
application
so they can be installed to extend the
Java platform a service is being defined
as a set of interfaces and abstract
classes and this service is implemented
by a service providers these providers
are not by default loaded but they are
located and instantiated on demand so
they are included in a jar file in a
specific directory and they are
identified via a configuration file in
the directory and then an application
has to explicitly load and load a
service and then it gets instantiated
this is a small example where we see how
this works so we define a service
interface that can which is called calm
XYZ service a and that can be satisfied
by three different services one service
would be provided by service provider
one another one would be provided by
service provider to and by service
provider through you would be the third
one by the way there's a mistake on this
slide the second box should be reading
service provider to service a provider
to sorry about that these are declared
in the resources in the meter in
services come XY set service file where
the providers are named and the service
is then loaded with the service loader
for service a in the instantiation SL 1
equals service load the load service
ated close so the runtime checks for the
resources finds a matching service and
is floating the service and then it can
be used and the services satisfies the
chrome XY set service a interface and in
the shaded background we see how this
could work for a service be as well with
two possible provider implementations so
this offers you a flexible way of
providing maybe at a later point in time
a different implementation of a service
interface and you can just reuse the
application and plug in the service that
might do different things and as long as
it satisfies the interface you don't
have to change anything and just provide
a new service reference in the resources
directory and package a different
service that has a different
implementation with it okay so updates
we have been talking about libraries we
have been talking about language now we
talked briefly about the virtual machine
so we support the Java VM specification
for standard editions 7 with some
limitations there is one up code which
is not supported which is called invoke
dynamic which would require to have a
huge set of additional metadata in the
in the runtime to be able to do
reflection and since we don't have
support for a reflection we also cannot
support invoke dynamic we have a new
verification scheme which is the
standard way however verifier works in
standard edition so we do the
verification by type checking if you're
not into vm if you're not vm specialists
that basically means verification works
as in standard edition and you don't
have to do a pre verifier which is
common to people who have been working
on CL DC and previous platforms so if
you use the latest tools and deploy on a
on a new platform you just don't need to
do anything specifically you don't need
to pre verify anymore you can still do
the legacy verification for class file
versions 48 or below
here's a list of unsupported Java as he
ate features these things have been
sacrificed to the footprint of a small
platform so as I said before we don't
offer reflection there is no
serialization we don't have the invoke
dynamic opcode and as a consequence the
platform does not support lambda we
don't have a native interface which
implies that there is no application
native code so you run all applications
in the sandbox we don't have user
defined class loaders so everything is
been included into the application and
give the user has no way of overriding
class loader we don't have threat groups
and demon threats no concurrency and no
support for big decimals in the mass API
we have limited security api's and also
on the collection api's we don't have
been sorted collections to wrap up on CL
DC we have language alignment with se8
we have aligned the vm with se8 and we
have aligned the library with se8 we
have defined a compact configuration as
a subset for very small devices generic
connection framework 8 provides flexible
networking and Roger it's just coming
into that and developers just can use
the tools and the api's and the
knowledge they already know so there are
no surprises in the platform in terms of
new API is that a developer would have
to learn or in terms of anything that is
working differently as in SE so
everything that you know of se you can
also know on an emmy platform with this
I hand over to Roger Rick's
and he will go into details of the
general connection framework we just
need half a minute to switch over the
microphone I'm sorry um that's yeah go
ahead please
can work on
you can run cldc applications on java SE
and we CLD c defines a subset so you
mean you mean the slide with it with the
two circles if we think about the core
library there are no packages
differently the I know I know the
sliding and that one with a bigger
circle so this is not related to API oh
sure so binary compatibility basically
always means that if you had written and
compiled and produce class files with
the previous version you'll get the same
behavior if you're running on the
current version so that's that's usually
that's always the goal with Java is that
you know we don't break things when you
move to a newer version sometimes
there's some subtleties and that we have
some duck discontinuities with cldc
eight because of the switch of the
verification format kvm and cldc one was
sort of took this innovative step at the
time to create a different way to verify
class files and they produced a
different class file format some extra
annotations to do that subsequently java
SE adopted the similar verification
technique that was very efficient but
they didn't just take the same file
format they created a new a different
class file format to do it so and
evolving the cldc spec we had to decide
how to deal with that difference and in
that particular case we support the old
class file version format for the older
version class file versions and for the
newer class file versions that are
produced natively
by the Java C compiler we support the
new format but they're also they're all
still supportive yes
right so well a sort of two levels so
we're talking primarily about the part
of the API that's been standardized
through the JCP and we we didn't as part
of cldc define a standard java native
interface Jay and I so Jay and I the way
it's defined in java SE we never
implemented that the Oracle products for
Java ME previous products had a
proprietary interface they called K&amp;amp;I
which is probably the one that you're
using and that's still supported in the
product but if we haven't tried to
promote that into the standard the the
JCP standard for for it so I think that
will continue to work
so we're using CDC or cldc because CDC
is is the other the other branch of Java
ME which had was a more provided more
capabilities about the java SE one dot
for level and did include J&amp;amp;I so that
transition maybe require a bit more sore
detailed conversation about how to help
you with that or java SE embedded i
think which is the sort of the upward
flow of evolution there yes absolutely
yep we can talk more later if you've got
more questions Thanks sure
so the the pre verifier was a build time
step that took the old class file
formats and annotated them with this
very efficient verification technique
that was linear time the same technique
is now produced by the standard Java C
compiler and this verification algorithm
is essentially the same it's a one
pretty much linear one pass over the
class file to verify that the arguments
for every byte code are correct so
there's no no additional startup time in
fact in most cases the verification of
class files is handled at the time you
install the application not at not when
you run it and so that's that's another
way that you can that it does not affect
startup time it's with the M the Java 8
platform when you install an app those
things are done once not yeah jazz we
haven't I hope we haven't made anything
worse that would be a bad idea so I'll
pick up here with see if this button
works oops find I went the wrong
direction you want to do find the GCF
side so the generic connection framework
existed in as of cldc 10 the framework
was there in subsequently there were
also there was mid p that introduced
connection particular connections for
HTTP and sockets and about the same time
there was another jsr 197 that applied
to java SE that created some an SE
version of GCF mid p later mid p
versions added more connections to it
and CDC also had a version of the GCF as
part of their specification so one of
the things we've tried to do in this
iteration is sort of unify all those but
primarily going forward GCF is supported
on on top of top GCF so some of the the
improvements that we've made have to do
with adding new connection types of
adding a more flexible way to
parameterize connector that open which
is used to open connections we as part
of the evolution of GCF we needed a way
to have a good security system for the
for each opening each of the type of
connections so we added per protocol
permissions and which actually happened
in CLE see one dot one dot one and we've
added some extra failure exceptions in
the to give make the failures be more
informative so I was on the new enhanced
protocols that the file protocol was
supported primarily by way of jsr 75 in
the mid p context at the mid p time
frame but it was a separate jsr and
we've pulled that into CLE see we've
added a connection type for multicast
we're upgrading the to get support for
TLS 12 according to the rfcs that it's
been a lot of increased emphasis on
making sure that the network protocols
are secure and up to standards we've
added a secure data gram connection and
some additional support for modem
connections so here's just I guess I've
probably talked through this already a
sort of a summary of the original
connection types that were in CLE c and
then the the migration to cle c 8 and
the things that have been added and i
want to talk about all these
individually a little bit in more detail
one of the other big additions was
making sure that ipv6 was supported
across sockets and HTTP and and Datagram
it sort of filters into several of the
protocols but now consistently supports
ipv6 with the the standard format for
both explicit ipv6 addresses and the the
various forms of Datagram and multicast
one of the things it wasn't in the
previous versions of the genetic
connection framework was support for
multicast we sort of see use cases in
and embedded devices for being able to
use sort of the popular protocols for
Rhonda going with other devices in the
neighborhood supported through through
dns and bonjour and so we've added a
connection type for to support multicast
both client and server aspects of that
so that you can as a embedded device you
can either be aware of other multicast
devices in the neighborhood and or you
can be a host for multicast and this is
just the basic layer there's you know
the application with with basic
multicast support can build MDS or or
interact with bonjour but we're not
embedding that excuse me embedding that
part in the specification I mentioned
earlier we're doing upgrades to the TLS
protocols to get come up to the RFC 4356
4256 one of those which involves
updating the crypto architecture being
able to add parameters to be able to
control things like the set of cipher
Suites and which cipher suite is used in
which protocol versions are selected and
make those visible to to the application
another popular request was being able
to do client authentication so that so
previously that GCF protocols allowed a
server or the client to verify the
credentials of the server which is sort
of the standard setup but there are also
use cases in which the server really
needs to understand that the client is
who it says it is so there's now a wait
of exchange or to validate a certificate
on the client and be visible to the
server also we added the two supporting
TLS protocol on top of UDP there's a
number of upcoming lightweight messaging
protocols that are built on UDP that
can't tolerate the overhead of tcp/ip
and they're all built on top of the TLS
on top of UDP datagrams so that's been
added with a similar kind of controls
and parameters
in terms of connecting clients
connections I think at the moment we
have omitted the secure though we have
secure datagrams I think we have not yet
committed to the or we're looking for
input on the server side of secure data
grams to see whether that's really an
essential feature and I think we've
gotten some input so far and will
resolve that before we close the
specification other little utilities
that have been requested are things like
being able to interact with DNS and get
the canonical hostname of some of a host
which involves the sort of round trips
to DNS and simple functions like it is a
paying function err is reachable
function that allows the the
encapsulation of is there is there a
tcp/ip path to this host and then sort
of get by name which will do
translations from name to IP addresses
the things that make some applications
will do easier to deal with previously
the way the GCF dealt with addresses was
pretty much as opaque strings and
without any really support for
interacting with the with DNS or the
name service that supplies in a network
so one of the the calm connection always
existed there existed in mid p2 and we
had an observation that there was no
real visibility into if you had a real
modem there with modem control DTF DTR
there was no visibility into that the
connect physical connection
characteristics so there's an additional
interface that can be opened on a on a
serial port to give you visibility into
the the modem lines and I think that
will be useful for some some
applications generally we there was an
observation that the connector that
opened call which had three you know one
two three fixed arguments wasn't very
flexible in terms of passing additional
arguments in and so as part of the API
updates we added this the notion of the
connection option which is a sort of a
name value pair that you can pass in a
set of them to as part of connector that
open and it's used to parameterize
things like the TLS parameters to
picking crypto algorithms and protocols
and it's kind of a general purpose
options for connected open here isn't a
little bit of an example of you know for
example setting the keep alive on a
connection by using the you know the
string keep alive and giving it a number
or setting the proxy port to port 80 and
then at the time you call connector that
open you pass the extra arguments and
the implementation will will use those
to condition the as it sets up the
connection the at the at present there's
still quite a bit flexibility as well as
to whether a particular implementation
sort of respects each of those things
like keep alive we have to figure out
whether there should be mandated or
whether the some of the options are sort
of hints to the implementation about the
right behavior so one of the other
notions that came along was that in the
context of devices there are frequently
different types of connections whether
you have you might have a wide area
network connection through some 3gpp
protocol or you might have a Wi-Fi
connection in some cases you might have
essentially a dial-up connection through
one of the old packet networks and there
was no way really to easily represent
that in in the GCF API so we created
this idea of an axe concept of an access
point which is a it's sort of the first
top of a logical connection to the
network where you can select what type
of network you're dealing with if you're
if it's a very specific thing like a
Wi-Fi connection you may want to specify
a particular SSID and be able to
essentially create or use an access
point in your application that
corresponds to a particular wireless
network and give visibility into things
like the authentication type and a
password that's needed so the this
doesn't sort of impinge on every
application developer to use it the
default mechanisms for finding the
active tcp/ip connection will always be
be there but if the developer ticular
developer in that environment needs to
know exactly this access point or this
SSID or this 3gpp connection needs to be
used to have a way to discover the
access points that are available on the
device in some cases create new ones
like for a dial-up type of networking
connection you need somebody needs to be
able to specify the probe the phone
number to call and or the the APN or the
access point name in the 3gpp Network so
here's a sort of a quick example of
using getting a list of the access
points are available on the particular
device mostly where 11 use cases is the
device populates the list of access
points based on its awareness of what
Wi-Fi networks are in range or which SIM
cards are plugged into the phone which
jeep gsm-r 3gpp stacks are available and
then in this example I guess another
features we added a listener on the
access point so that the transitions in
an access point from being connected to
disconnected can be monitored so if you
care whether particular access point is
or Wi-Fi network is available and when
it ceases to be available you can set a
listener on it in this example it just
sets the listener it adds it uses the
connection option to select the access
point and then responds to the changes
in the access point app when you open
the connection or as you open the
connections so the failure modes can
pretty much be the same at the time you
call connected I open the access point
may not be available or it may not be
able
be connected but that was that sort of a
pre-existing sort of natural case but
now you have application it's a bit more
visibility into the the network
connections we've gotten a lot of
comments on this aspect to it and I
think there's probably more more
development to do so one of the other
key features of the update was to try to
get to a place where we're using more of
the standard tools for for SEO and Emmy
defer eme development and I guess Emmy
has always had support in that means and
plugins and netbeans for supporting and
creating applications but we always also
had this extra step of the pre verifier
that had to be integrated into the
process with ALDC eight in the tool the
tool chain is is streamlined a bit with
using the standard Java C compiler and
there's some of the features that are
introduced and supported as part of the
language features that are actually may
not create the code you think they
create and so there's potential for some
warnings about at compile time to tell
you when things like that it was sort of
sort of advice about things that are not
very efficient at at runtime for example
enums they there typesafe enums are part
of the Java language and there are very
nice typesafe mechanism for doing for
doing switches you can zoom in switches
but it turns out under the compiler
under the covers the compiler creates an
extra class and some mapping of the enum
values to the switch values that you may
not be aware that's going on so it
creates some extra space things like
switch and strings actually create more
code than you think it creates because
it's not a you know it's not a trivial
operation to do that so there's some
advice in the advice coming from the
tool chain that says here are some
things that you may not really want to
use so there are you know there's a
potential to add other things in the
toolchain to try to optimize both code
size and performance Remy I think
none of those are going to be are those
by their nature are not part of the
standards the JCP standards but their
potential for the products and we have
obviously the tool chain for Emmy is
going to be integrated with the with the
NetBeans and the other IDEs so just a
little bit of history of cl dc-8 we've
been actually it's been a pretty quick
process even though we filed GSR last
fall we had come you know we'd been
working on the general approach to it in
the design and we came to the expert
group with a fairly complete draft in
the februari and and time frame and put
it out for early review in in May it's
currently in the middle of public review
running through I think the end of this
week and after that we'll take the input
that we've gotten in both internal and
external and do another update with the
expectation that will try to post a
final spec draft in December and Michael
also mentioned that there's the M eep
specification which is the sort of
application platform more of an
application platform that's going on in
parallel and so I think all of this is
coming together you've probably heard a
bit more of the big picture this in the
previous talk which unfortunately I
wasn't able to attend but we're on a
track to sort of get together get more
alignment with java SE it's been a long
time coming for those of us who have
been working on it and those people who
are want to use it it's still targeted
at very constrained devices though and
we've had to put more flexibility into
the structure of the specification the
API to make that possible or personally
it's given too much optionality from my
point of view but it is needed to to
target smaller devices and we've done
you know quite a few updates to the
api's and the
added functionality that we that I think
developers need and if I mentioned we've
sort of consolidated GCF and updated the
tool story so I think we have sort of a
set of things that we've done been able
to talk about today there are some
related sessions later in the week I
don't didn't put dates and times on
these and there are some resources on
the on the web for both for the
specifications in the java.net project
so I don't need to repeat that and if
you have questions it would be great to
hear what you think and answer any
questions that you have yes golly that's
kind of I think the the current view is
that Windows is still the predominant
platform for developers but I can
provide that feedback to the product
management folks your preferred platform
is the mac and linux so i think actually
one of the things that held that back
one of them sort of the most was the pre
verifier in in the previous incarnation
with the use of sort of the standard
Java C compiler which will integrate
very naturally with with netbeans the
sort of i think most of the processes
will be pretty straightforward I'm not
completely up to date on exactly but how
the project that's being integrated in
the NetBeans functions to know whether
that's a problem you probably can get
most of the way there on them on the Mac
anyway but if you let me know your name
I can get you a more detailed answer
later
the milestones now it's still like

I don't know the answer to the roadmap
question for the tool what
yeah I'm apologize i'm i'm behind the
times on that oh so I don't have an
answer for that obviously than the usual
you know we always seek to make it
better etcetera etcetera but we got to
file real bugs and get them fixed to
solve your problem so yes
well I don't think so Java ME has I
think there have been various
implementations that have been
customized for particular runtimes but
Java ME has never been never been solely
targeted at particular runtime we have
over the years done a lot of well our
own implementations the reference
implementation things they've been
released have been released on sort of
commodity platforms there have always
been vendor ports and specific ports to
specific devices mostly prototype type
devices but the basic specification and
the the AP is are not specific to any
operating system if you have a
particular port or target that you'd
like let us know and we can put you in
contact with Terrance or the PM's to see
where that where that fits
so the specification doesn't target
real-time behavior and the the
implementation that we have doesn't as
well obviously the sort of usual the key
point that comes up is is garbage
collection but believe the
implementations is not particularly
tailored to low pause times there is you
know it's been a consistent on the
implementation side it's been a
consistent question about well how much
real time do you need and what what
aspects do you need for real time trying
to think there's another session that
you might find the developers it is not
deterministic is harder because with the
dynamic garbage collection that piece of
it is harder to control exactly when it
gets triggered and how much work it has
to do so at present it's it's not
possible to make it deterministic there
is a special case our law because it's
far from final for the whole security
relevant environments that tries to call
some of this including more precise
timers that our support supported by
real-time wes's to any plans
so soon off of that word yeah I don't so
the original real-time jsr which was
actually just our number one of our
unique situation applies pretty much the
java SE i'm not familiar with the the
timing the real-time aspects of the
security GSR that you're mentioning but
it hasn't really come to play in in CL
dc-8 as a requirement you'll see a lot
of things other AP is including they
tiny VI in a different way of specific
environment so quite a bit of redundancy
hmm do you remember the number of the
good lots 302 all right take ok I can
take away any questions all right thank
you very much appreciate it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>