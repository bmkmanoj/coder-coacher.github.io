<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Small Change and Big Files: Retrospective on the Language and Some Library Features in JDK 7 | Coder Coacher - Coaching Coders</title><meta content="Small Change and Big Files: Retrospective on the Language and Some Library Features in JDK 7 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Small Change and Big Files: Retrospective on the Language and Some Library Features in JDK 7</b></h2><h5 class="post__date">2015-06-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/sbzRsUoQdPQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright good morning and my name is Alan
Bateman on my right here is Joe Darcy
and firstly my apologies about the
confusion today is and so we actually
had two sessions on jdk 7 and one on
project coin which is covering the
language features and one on the file
system API these talks actually got
merged together a couple of months ago
and for some reason they didn't actually
work their way into the session catalog
so my apologies about the confusion at
the door and here as we try to work this
out so what you actually have ended up
with here is a bit of a double bill and
it's primarily intended and targeted to
people that are working with jdk six and
older versions of the jdk and are
thinking about and looking at jdk 7 and
and and trying to learn and quickly come
back to seed with the language changes
and library changes so there's a lot of
material to actually cover in here
because we're covering both language and
library and we're not going to get
through everything so we're going to
skip over some things however we have
two baths tonight one under language
changes one on the on the the i/o area
that we can actually spill over into if
you've got other questions and issues
that we can bring up some of the slides
there this evening if if you want to and
okay so here we go here's the agenda Joe
is actually going to start us off and
actually quickly go through the the
language updates that the through
project coin that went into jdk 7 and
i'm going to follow them later in the
talk and talk about and the file system
API which is probably what you thought
you were coming here to talk about
before we do that is we'd actually
always want to talk about jdk 7 rolls
interested just to get a quick poll of
the audience just to find out what
versions of jdk people are actually
running with so and let me let me let me
just start as is with jdk 7 i'm just a
quick show of hands as to who's running
with jdk 7 now okay maybe about half the
people who are still on j TK 60 more
than half the people whose on jdk 50 4 5
and 14 or 114 to one guy
okay all right anyone on something
anything older than 14 all right one guy
put up his hand but he's got a smirk on
his face so III don't know whether he's
serious or not and what about JDK age
has anyone actually started playing with
the JDK 8 preview bills oh just just a
small number of people all right okay
and you want to talk about IDs or will
be we should move on on get started on
on coins so this is Joe Darcy he led a
project coin and we bring you through
all the language changes Thank You Alan
I just like to start by talking about
the general evolution policy we have
four for the JDK since people often
transition from one version of the JDK
to another and it's important to
understand what is and is not guaranteed
to stay the same across the releases so
compatibility has always been important
for the JDK evolution and it varies by
three different areas there's binary
compatibility that's a very strong
guarantee and that's defined is the
continued ability to link meaning you
take your class files from one version
of the JDK they link it run fine you
take them to the next version and they
still link that's binary compatible
source compatibility is due your class
sources still compile with the new
version this is actually a bit subtle
because it can still compile but compile
into something that means something
different say you have overall load
resolution changes but generally is does
it still compile or not and finally we
want to manage behavioral compatibility
that is what actually happens at runtime
sometimes the Javadoc specification will
state something like the exact order of
the results of this method aren't
guaranteed so if you're depending on the
order that's a bug in your program if
the order changes as opposed to being a
bug in the JDK and there's an example
that we'll discuss later on and we also
use this philosophy to keep on your
compatibility managed source
compatibility and minimize behavioral
compatibility changes both when we look
to evolve the libraries as well as the
language itself
and we have different policies for
different releases so for update
releases there's a very limited amount
of change that that's allowable for
something like the old maintenance
releases like 142 that's a much larger
change with the same specification
there's more variation there and again
no binary incompatibilities and an
update release and for platform releases
like jdk 7 compared to jdk six or jdk 8
compared to jdk 7 there's the largest
amount of freedom to make changes
including little slivers of binary and
compatibility to do things like fixed
security problems so in jdk 7 there are
some fields that should have been final
that we marked final that's technically
a binary incompatible change but since
it was dealing with security issue we
felt justified in making that change
anyway so up further ado I'll then start
talking about project coin so this was a
set of language changes to make things
programmers do everyday easier and to
make things easier by making code more
readable as well as more reliable there
were six changes you can grope group
them in different ways proving
consistent seen clarity two of the
changes actually dealt with various
aspects of generics to make generics
easier to use and to the features were
for better exception handling to make
programs more reliable so the first one
I'll be talking about is improved
literals now we have binary literals in
the language binary little literals are
exactly like hex little rules except
they're in binary so instead of having a
0x they start with a0 be and you can now
also have multiple underscores between
digits so very simple if you have you
know bit level constants now instead of
decoding the hex yourself you can just
write them in binary I'll be posting a
link to this the slides in my Twitter
account if so you don't need to take
pictures necessarily if you just get
that is the actual PDF after the talk
and with the underscores you can make
long constants more readable this works
in any base decimal binary or hex now as
with any feature you can abuse the
feature so for underscores and literals
this is now actually a legal java 7
program
so we Josh block pointed this out so I
don't hold like his brother so this is
legal but we don't recommend you make
your code look like this the next
feature is a strings and switch again
very simple there are strings now you
can have them as case labels and you can
switch on them so it means up pretty
much exactly what it looks like this was
a very small language change we managed
to distill down to changing one word in
the Java language specification so there
is a sentence which lists out the sort
of things you can switch on and now you
can also switch on a string and making
the language change that way also
answers a number of other questions you
might have so what's is switching on a
null value do well that throws a
nullpointerexception that's actually
implied by other parts of the
specification and that's the same thing
that will happen if you switch on say a
null a new mal you also get a null
pointer exception can you have an old
case label no you cannot technically the
reason is no is not a constant in the
Java language specification and the case
labels have to be constants so since
knows not a constant you can't have as a
case label of course strings are very
rich you can compare them in different
ways and if you want to do so that's
more of a localization issue and we
won't help you here so this is we don't
offer case incentive comparisons so you
have to do any normalization of the
arguments before you switch the
implementation working on this was fun
so people sometimes ask about the
performance it can be a bit subtle but
generally if you have more than about
three case labels it should be faster to
use this strings and switch as opposed
to doing the if-else checks yourself
safe varargs so how many people have
seen errors like this when compiling
your code so you're innocently using a
method in the core libraries like the a
doll method then if you can run the
compiler with warnings you'll get this
rather unfriendly uncheck message and
uncheck generic or a creation so on and
so forth and you're just calling a
method from the core library so what's
going on here this is actually a
compiler mandated warning message that's
submitted for this situation and the
summary is there's a bad interaction
between generics
and erase varargs are implemented using
arrays good old rays so if you have a
variable argument with a type variable
in it that gets passed as an array and
there's a mismatch between how generics
are implemented in the language level
and at the runtime so this is a
consequence of erasure if you're
familiar with that so it's rather
unhelpful to have every client of a
library especially the core libraries
get these you know noise warning
messages when really not nothing's going
wrong here so the solution we'd like to
have is that the library writer can
assert even though this varargs method
generates this unchecked warning by the
specification nothing bad is actually
happening this varargs method is
actually safe to call and if the
provider of the library says it's safe
you don't get the warning message
anymore so we went through the JDK
libraries and found the locations where
this was a relevant so mostly they're in
the core collections so we applied the
annotation there and that silences this
unchecked warning for all the people who
call these methods without having to
change the call sites which is the right
right way to do it if you want to look
to apply this your own code there's a
few things to keep in mind this is an
annotation annotations are not inherited
on methods annotations are only
inherited on classes not even on
interfaces so that means the safe for
our generation can only be applied to
static methods constructors and final
methods because they're not going to be
overridden so it doesn't matter if what
their inherited or not now there are
some additional limitations to when you
can apply say for args like it has to be
a varargs method for instance those are
laid out in Java specification if you'd
like to apply this technique in your own
code you can download an annotation
processor from this location that will
go through your code and look for
candidate varargs locations for this a
good rule of thumb is if you have a
variable argument that's generating one
of these unchecked warnings if the body
of your method is just iterating through
each element of the array that's
probably a safe
args candidate method so iterating over
the array is safe something that would
not be safe would be mutating the
parameter array itself so dymond when
generics were added back in jdk five
this became normal Java code we have not
just a set but we say what the set has
in it in the type declaration of the
variable so it's a set of list of
strings then when you go to initialize
the variable you have to say it's not
only a hash set the implementation type
but what is it a hash set of and
typically you'd have to repeat the type
arguments with diamond in jdk 7 you no
longer have to have the type arguments
over here on the right hand side because
the compiler will and forth infer them
for you so this is still strong typing
it's just that the compiler will infer
the arguments on your behalf typically
this is used in a straight assignment of
variable but that's not the only
location it can use them so very built
initially is fine since this is type
inference though and the Pilar notice
the types you don't have to have it in a
variable initiation if you have a
separation between the declaration of
the variable and a later assignment to
it that's fine the type will still get
referred properly also if you're in a
return statement because the compiler
knows what the return type of the method
is it can also infer the argument in
that location as well this is type
inference type inference is a constraint
satisfaction problem when we were
working on project coin we evaluated a
number of algorithms for computing the
type inference the one we chose was
validated to be very effective in
practice for the code bases we use we've
got rid of over ninety percent of the
locations of the explicit arguments in
the constructor call so we're very happy
with that and if you've been attending
the project lambda talks during javaone
there's a lot more type inference in
lambda so this in today IDK seven was a
step toward having more type inference
in the platform multi catch and
precisely throw these are some changes
to the existing
catch statement multi catch is pretty
straightforward instead of catching only
a single exception in a cache block now
you can catch multiple exceptions and
you separate them with a vertical bore
bar the same as the binary or the
precisely throw means we've made the
compiler smarter in how it determines
what exceptions might come out of a
catch block so where did check
exceptions come from well they have to
either behind by a cat's claws or you
have to declare them in the throws
clause of the containing method and you
can throw the exception from a throw
statement or you can wreath row an
exception parameter right so you're you
have the catch block you have an
exception that comes in and then you can
read throw it and we've made the Ken
thorough analysis smarter to take that
sort of information into account back in
jdk 6 and earlier if you threw an
exception parameter the compiler would
just say well you've declared your
parameter be say exception so that means
I'm going to assume that can be any
exception when you throw it now we've
made the compiler smarter if you catch
an exception and you don't modify the
exception parameter in the catch block
that means the exception your wreath
rowing is one of the exceptions that
came from the try block which might be a
much smaller set maybe you can only
throw to checked exceptions from the try
block that means when you re throw that
exception in the catch block you're not
wreath rowing any exception you're only
wreath rowing those two exceptions that
might have come from the try block so
the compiler can see that's happening
and then it knows that from the catch
block your only wreath rowing those two
exceptions and we'll see an example that
on the following slides so let's take an
example here future yet this is declared
to throw three different exception types
to be a perfectly proper and not have a
problem in the code here in jdk six and
earlier you'd have to try block and then
for each of the three exceptions if you
want to do some exception handling you'd
have to separately have cleanup and a
wreath row for each of the three
acceptance exceptions so this is pretty
verb
now you might be tempted to not have
that repetition by saying you catch
exception here this lets you only have
the cleanup logic grunts but
unfortunately you've lost information
because now the method is declared to
throw any possible exception rather than
those three exceptions that you know it
can possibly throw so in jdk 7 we can do
better in various ways the first way is
that we can collapse that repeated code
by having the catch block instead of
catching one exception catch all three
now if you're concerned about causing
bloat in the class file that actually
won't occur java sea compiles this down
to a single block of code so it's only a
little bit of the bookkeeping about
where the exception goes that's added so
this is a very compact compilation step
something else you can do is if you
don't want to have the three possible
exceptions written out here you can
catch just exception and when Yuri throw
it since Java Sea knows that alright you
have the try block you have those three
possible exceptions something out of it
each of those three exceptions will get
caught in a scratch block now your
wreath rowing this exception so you
haven't modified the exception parameter
that means the exception is coming out
here has to be one of the exceptions
that came into the cache block since
those these three exceptions are the
exceptions that came in when you re
throw it these exceptions are also the
ones that come out so note here that we
have the same precise throws clause as
before but we have the more more concise
code finally the largest of the project
coin changes is try with resources so
this is a variation of the try-catch
finally statement and the problem it's
solving is you have a resource that have
that needs to have closed called on it
so you have some native memory or fire
handle something like that and you want
to robustly make sure to call clothes
now this is a type of resource
allocation that is not handled by
garbage collection so we wanted to add a
language change to make the platform
more robust in this way so roughly what
happens is you have your code here with
the try statement now you have a
resource that's managed by the try
statement
and you have a catch and finally as
before the compiler translates this
internally into you have an internal try
you do your your logic in the loop here
and then there's a finally block where
you call clothes as long as the
resources not null and since it's in the
finally block it will be called no
matter how that block is exited then you
have the logic as before it's a little
more complicated than this the sugaring
here because there's also extra tracking
of exception information when you have
this kind of structure you can actually
have multiple exceptions being thrown
from the try block and we track those
now on throwable and with that I'll give
a quick demo of prior three sources
ok
this is NetBeans netbeans had support
for project coin for past few years but
if you're using in clips or IntelliJ
they also have had support for a long
time and the support is roughly
comparable in this case so here's a
simple method to copy input streams an
apple stream anyone see something wrong
with this code is there any exception
handling in this code so there's no
exception handling and also there's no
one calling close on the input stream in
output stream so while this code is very
short is not at all robust in terms of
managing the resources so if you want to
call close on the input stream in our
output stream you might be tempted to
write code like this is there anything
wrong with this code yes so there's a
problem here even though we have a
finally block around the while loop what
happens if out doc close throws an
exception we're going to exit the
finally block at that point which means
known will call close on the input
stream there's a similar problem at the
start of the code here right because
let's say the input stream constructor
go is fine but that the file output
stream constructor throws an exception
there's no finally block protecting the
input stream so that means you're going
to leak a filehandle at that point so
what you have to write to do this
robustly is something like this here as
as what suggested you need a tri finally
level for each of the two resources
you're managing and you know you start
out with just this two-line loop here
and now suddenly there's all this
scaffolding just to do the error
handling and this is not very nice to
look at so with driver three sources we
can really improve this so the IDE
detects the tribes resources can be used
to transform this code so we can go
ahead and apply that so that's catching
it down one level so we get rid of one
level of tri finally and there's another
level that can be applied here
so now this is what the output code
looks like with try with resources this
is nearly as short as the code without
exception handling but it is as robust
as the full code on the slide before the
end of the warm-up back to the Nile
portion of the talk I will point out
that you don't have to even write this
code at all now this particular code
because there's a method in jdk 7 that
does exactly this and without altering
the talk back over dallin
alright alright thanks Joe okay so
second part of the talk were covering
some of the library features in jdk 7
specifically the file system API which
and for those that arrived late is it's
a bit of a mix-up and the title outside
so okay so file system API is and just
give you some motivation and background
for why we did a new file system API so
for those that would be using the jdk
for a long time you know that the java
oh area was an area that did not get a
lot of love for a long time and the
support for files file input stream
fileoutputstream random file random
access file have been there since the
early versions of the jdk and and they
haven't they haven't really been updated
very very significantly and so there's a
lot of features and a lot of issues and
a lot of problems that a lot of
consistency issues that built up over a
long time so and finally bit the bullet
in jdk 7 and the GSR two or three and
developed a new file system API so i
just listed down just some of the
problems there that we had with
java.io.file and friends that just just
could not be fixed without risking and
significant compatibility issues so you
for those that the beauty of the talk
that put our hands up for jdk six and
older you'll probably recognize some of
these issues lack of useful exceptions
when when an i/o operation fails
consistency issues missing basic things
Joe just talked to their I give it a
little try resources example where he
was doing a file copy believe it or not
prior to jdk 7 we didn't have any way
that you could actually copy a file our
move a file consistency and there's a
whole bunch of other things their
performance issues would file with file
attributes of a missing support for
symbolic links and a whole bunch of
other things I could actually have
several slides here on things on
problems but I'll skip over those so the
new file system API is there in jdk 7
you'll find this API in the package java
and i'll file there's two other packages
that go along with it java.io.file
attribute and java niÃ±o file spi i'll
cover those a little bit but not not too
much in this talk it also updates and
java all a little bit and also because
it's nao it's it's the strong
integration with the channel support so
there's some
small additions to Java nao channels as
well important points about this API is
is that was designed to be really easy
to use and we didn't want to have a very
complicated API for accessing the file
system and we also need to have strong
interoperability with jovial and and
input stream output stream and friends
because there's so much code out there
that uses those those classes and types
today and we also need it and this is
this this is this is a difficult one to
deal with is we needed the ability to be
able to and make the API usable with
platform specific or file system
specific features so you can divide you
can easily create a lowest canal and
common denominator API but it's not
going to do the things that people want
to go and do when they wanted when they
want to deal with them files as more
platform specific features so we had to
build in extension points in many many
parts of this API to be able to deal
with these type of things okay this API
is is quite easy to learn and you really
only have to get two or three classes
into your head I've listed down for them
here and which is is the the path class
it's actually actually an interface and
at a high level just think about it as
something that you use to locate a file
in the file system there's the files
class which is a just just essentially
just file operations just static methods
that do things on files very very easy
to use there is a notion in here of a
file system and that one takes a little
bit used to getting used to it
essentially provides you a handle to a
file system that you get one of them by
default which is the default file system
provides access to the all of the
platform file systems any the hard
drives or memory sticks or any other
remote mounted file system that you
might have in your system which you can
also with this API create your own file
systems use other custom file systems
and I talked a little bit about that at
the end and there's also a file stored
here which is something that represents
the the underlying volume or our file
system for the cases where you really
need to get down to to the to that level
okay I'll just quickly go through the
first two of these so the path type is
then it represents either an absolute or
relative path you can create a path from
that string from a from a java.io.file
from a URI and it's quite easy to do you
just think about it I think of it as
essentially a sequence of name elements
which is like the the names of
directories in the file name and it can
Amina or may or may not have what we
call a root component root component
things like drive letter or or some
other representation to indicate where
the file is located and pats are
immutable and what they define is is
only path operations this is actually a
difference between java.io.file it only
defines operations that you can do on
paths which is you think of it as the
syntactic operations so they're their
methods access components of the path
and there's others methods to actually
combine paths together in different ways
to create other cuts so here's just just
some quick code examples here and we can
see here the the first line here just
creates a path called bar and it called
the get path method on the default file
system / fus and passes at the string /
food / bar and then creates a path to
represent that we call the get parent
which is actually a component of the of
the path and it returns you back the the
parent directory here which is which is
/ foo there's different ways to combine
pats i've just used one of them here
which is the resolve method you could
think of a resolve method as as a way of
joining pats and buts a little bit more
complicated than a joint in certain
certain type of cases in this example
it's very very simple we're going to
take bar which which is / food / bar
we're going to resolve Gauss you could
think of that is going down one level in
the file system and then and you end up
then with / food / bar / go so you think
of that as as a simple way of joining
pads there's also relevant eyes
operation which is essentially what is
the relative path from from this path to
this other path so I'm trying to find
here be with the relatives method on Gus
whistle gosses / food / bar such costs
how do i go from gus to foo well I have
to go dot dot slash data so it's
creating me a relative path and to go
from from gosta foo very very simple way
to do it so I don't have time to go
through all
the file opera of the path operations
but are just quickly just summarize them
there's methods to get at the filename
to give the parent like you've seen
there there's ways to actually to get to
sub packs which is sections are of the
path there's ways to combine paths
together i showed the resolve method on
the last pap is also results simply so
if alan or joe our files in the in the
same directory i could do a result
sibling on on on alan and get joe and
which is which is which is a nice way to
when you know that some file is in the
same directory as another file there's
different ways to test pads you can
quickly chess where the one path starts
or ends with another know that these are
not street this is not the same thing as
doing string and starts with our ends
with this is this is actually testing
whether the pats actually match this
ways of testing with our path is
absolutely and so on and this does
various other methods in there there's
normalized methods for actually
eliminating redundant components and
parts of a path there's ways to create
the the real path which actually takes a
path and actually tries to get the real
path to the actual file it's it's a more
robust implementation of
canonicalization that we have with
java.io.file so it does which the
primary difference being is is there's
no such thing as a real path if the file
doesn't exist and this ways to create
you arise from front pads so the files
the files method so i mentioned that it
defines the the methods to access the
files in the file system and this is the
one thing with this API that you'd see a
difference between java.io.file is is
that we have not combined the file
operations and paths are syntactic
operations into the one class we did
various iterations on this API and found
this was the the the best one for
evolving this API in the future so it's
just purely just static methods that
operates on files and you might say
static methods and how do I extend that
I'll talk about a little bit but but the
provider interface later on in the talk
most of the most of the the methods and
on files to take a path in order to
locate the path in the file system and
often the methods actually return the
path as well because m is no point these
api is just written and being being void
I think we've only got one method the
delete method that actually returns void
now there in this API em all of the meth
that access the file system throw IO
exception that is the one and only
checked exception in this API all other
AP is and are all other exceptions in
this API are unchecked exceptions the
reason for using IO exception here was
primarily just to keep consistency with
the everything else that's accessing the
file system if we did something if we
did something different then it would
very very awkward for actually migrating
code and using I oh and Java niÃ±o at
the same time and in terms of the class
itself it's very easy when you look at
the javadoc you'll see methods in there
for accessing regular files for
accessing directories for accessing
symbolic links and and and and so on
okay so here's just a quick quick quick
example just to demonstrate some simple
things first on using files so the three
methods in red there are new input
stream is just opening is you give it a
path and it opens an input stream and to
read and sequentially from that file
there's a new output stream which is
equivalent create a file and and give me
an output stream to that allows me to
write to that file very very simple
there is there's four very simple usages
is there's a read all bytes and read all
lines which are essentially one one
method to read all the bytes and when in
return me a byte array our read our
lines which will read all the lines of a
text file and return them as a list of
string they're very very simple methods
they're not intended the read all star
methods are not intended for large files
if you've got a multi gigabyte file then
clearly they are not the appropriate
methods to be using but there are many
many use cases out there we've got
simple little use simple little files
you just want to read it all in one
method not have to go through all of the
opening file reading and closing the
file yourself it's a very very simple
one thing just to point out on this is
the read all lines there is specifying
the char set because this is actually a
utf-8 encoded file and there's a new
class in jdk 7 which is java nao char
sets and standard chart sets that is M
defines all of the standard char sets
that that the platform supports and so
in this case I'm just picking you to
utf-8
yes it does there's an exception in
there for this I can bring up the
javadoc later actually just some
questions I think we were supposed to
take questions at the end ok some and ok
so just cover one or two simple methods
on files just to get to give you an idea
and so the Joe did the trial resources
earlier example where he showed copying
a file from and using file input stream
and file output stream and here's an
example just using just a father's file
copy and so it takes two parameters the
path to the source file path to the
target file and a cop is a file from a
to be one of the things you'll see in
this say in this API is many of the
methods take of our args and which
allows you to pass in additional options
to to to to the method you'll see this
pattern in quite a few places in this in
this in this case the files copy and
there's a file to move that does the
same thing that you pass in copy options
which tells it how to how to copy the
file so I'm Pat and I've imported here
the standard copy options which is the
in enum of all of the standard copy
options that deal with replacing files
and copying attributes and a few more
like that and you can pass those into
the copy method so in this example here
it copies the file normally a file copy
would fail if the target file exists
what I'd like to do in the second
example here is replace an existing file
if it exists i also want to copy the the
file attributes some passing in the copy
option and copy attributes and that will
copy the file permissions the file owner
the timestamps and all the other things
that i would normally want copied over
and so you see this this this kind of
thing in several of the api's the
important thing is is is all of these IP
eyes are very very simple to to see I've
just picked out the copy one because
everyone can actually relate to that if
you go through the Javadoc you'll see
more of these so just on text files very
very simple there's I did the read all
lines of the previous one you can also
get traditional and readers readers and
writers with the new bufferedreader and
new bufferedwriter methods ok so this
this API mmm beefs up the support for
channels so if if you're familiar with
java and io by a channel by channel
you'll know that it's and it unifies the
readable by channel and the writable by
channel we've now extended that in G
instance jdk 7 with something we call a
sequel by channel so it's extending the
sequel by channel with the notion of
opposition and a file size and that
gives us this that gives us an interface
that is the the channel equivalent of a
random access file so in this API you
can open a file and get back a channel
that you can use for reading and writing
an account and it is a sequel by channel
so that you can em you can use the
position and move around the file which
is which is is something that was was an
obvious addition that we probably should
have done a long time ago and when we
deal with the default file system then
the sequel by channel you get back is is
is is a file channel now file channels
is something that more typically only
more advanced applications will be using
and so you can cast if you want the
sequel by channel to a file channel or
if there's a new file channel open
method that takes a path and some of the
other options in this API so you can
open an open file directly with a file
channel which is really really nice so
file channel is something that is it's
been retrofitted to implement em sequel
by channel provides all the advanced
features like memory mapping file
locking on those type of things we also
have a new asynchronous file channel
that provides an asynchronous em
interface to the file system for doing
and reading and writing and then either
getting back a future or having a
completion handler that's invoked when
the file operation completes and I'm not
covering in these in the in this
presentation today is it but it's we can
talk about it at the bath tonight if
people are interested quick example then
of a single byte channel and calling the
Dubai channel method and passing it here
read and write by the way here again we
see an another example of that pattern
where we're using the Varick syntax to
be able to pass in the open options
every every method in this API that
opens the file so you're the new output
stream the Dubai channel they take a
varargs which is open options we define
a standard enum an enum called the
standard open options that defines the
the the all of the the standard options
that you would want to do when you're
opening a file
implementations can actually add to that
and add other and provider specific ones
which I'll cover later on okay i want to
just move on and talk about directories
and so directories in this AP are quite
different to java.io.file java.io.file
has lists and lists file methods I've
just returned you back an array they
have been really really problematic
methods the fact that they just return
null when they fail is a problem and but
the biggest problem that have we've had
over the years of them is that you just
do not scale to large directories they
also are very problematic when dealing
with remote directories because your
application just hangs there for a
couple of seconds as accesses the remote
file system gets the directory of the
full the full directory returns you back
is array so they consume lots of
resources and and and just generally a
problematic in many applications so the
directory stream and by the way ed
although it's called a directory stream
which should not be confused with Java
util stream stream which is new in in in
in jdk 8 this is not a one of those it's
not in with the stream API and although
we do have some support now for our
first four streams in jdk which I'll
talk about maybe it maybe this evening
so a directory stream is is what you use
to iterate over directory it's an
iterable so you can use it with the the
fifth the for each statement in the
language and it's also plausible so when
you open a directory and you iterate
over things you need to remember to use
to close it when you're done otherwise
you liek resources and that's why and
try what resources is is it something
that works wonderfully with directory
stream and many of the other closable
that are defined in this API the
directory stream has built-in support
for em and filtering so and we say it
supports and globbing syntax is to be
able to filter and bye-bye file names is
also reg ex syntax if you want you can
actually go and plug in your own pattern
language if you want to and you can also
use custom filters if you want to filter
iterate over directory and only filter
filter files out that are greater than
10k or something like that you can do up
to all that pretty easily so here's
here's an example this is using
trovit resources that Joe showed a
couple of minutes ago and I've got a
path to some directory I'm calling a
files new directory i'm giving you two
parameters the path to the directory and
i'm giving it a star dot Java which is a
string which is treated as as as as a
glob so this will actually match the
files at in with Java and it returns me
back a directory stream of type path and
and I then iterate over them with the
with the far each statement in this
example I'm just simply printing out the
defiled name which is which is which is
very very simple and but that gives you
an idea of how the directory streams
actually work ok I want to talk briefly
about file attributes so file attributes
and what I mean by that is metadata
that's associated with the file and
they're typically very highly platform
and and file system specific it's an
area where there's a huge amount of
differences between between different
platforms and providing an API for this
area is a bit of a challenge for a long
long time we've had people looking to
develop applications that need access
the things like the various timestamps
on the file file permissions file owner
and all these other wonderful attributes
that we've never had support prior to
jdk 74 so we've also had a lot of
long-standing performance issues in this
area with as many times where we've had
to look at applications and you see that
they're actually trying to get the same
attribute of the same file and many
times so I want for this file I want to
it's its last modified time I wanted
sighs I want to test whether it's a
directory and if you profile any of
those you'll see that that it's going to
the file system every time stats that's
that you actually get you to read the
attributes of the file and that's that
that's a big source of performance
issues in some applications you can also
be unlucky in that the file gets
replaced in the middle of that and you
actually end up returning the attribute
for a different file and then then
watching what you thought you were so
it's it's also a security feature to be
able to read the attributes as in bulk
so just one other thing just to say
about attributes is is is that the way
we've approached it in this API is to
group related attributes we define this
notion of a view and that will provide
access to those attributes at
as a group every implementation has to
support a lowest common denominator
which is called the basic file
attributes beyond that the API defines a
number of other views the POSIX view the
app of you and so on I'll show some of
that in a minute and M and an
implementation itself then can actually
support additional views beyond that so
this is one of the extension points in
the API is to is to is to be able to
read em attributes that are just not
defined by the API it's just basically
providing a framework for
implementations to support it so here
here we have a little here we have an
example and this this example is using
the read attributes method so we can see
their files of read attributes is passed
two parameters one is the path to the
file that you want to read its
attributes and the second parameter is a
type token this is this is basic file
activities that class and that's in the
the attribute M sub package and what
that is is is that's that's asking the
implementation to read these attributes
and return me back an instance of that
so this pattern is actually you'll see
this in the API in the in the
annotations API get annotation where you
pass in a type token and which is the
class and you get back an instance of
that type and this is where this is this
API works so reading the basic
attributes I'll show the interface basic
attributes on the next slide and it's
doing the bulk reader of the attributes
so one read we get all of the basic
attributes and that and the basic
attributes include the size the file
type various time stamps so it's it's
high performance and addresses the
problems i was talking about a few
minutes ago so there is the basic
attributes you see there the the basic
attributes define and 33 different time
stamps and this file size various
methods to test the file type and then
this other notion which is a file key
which is what which is used to be able
to get a persistent key to the file and
the reason for these XX methods there is
we started off in the initial
implementation within with anenome it
was pointed out that that doesn't work
with many of the file systems which can
be more than one file type at the same
time so that's the reason for those both
those methods
okay I'll just skip over this one
because I mentioned it earlier posix and
there's nfsv4 ackles based on RFC 3585
and the file store API which is
represents the underlying and volume our
file system has methods allows you to
test what attributes are supported are
not supported and one other interesting
just last thing to say about file
attributes is every method in this API
that creates a file also allows you to
optionally specify the initial
attributes of the file primary use case
there's file permissions you don't have
to go and create a file and then set the
permissions in another method call you
want the file permission set atomically
when creating the file to avoid a window
where someone else might access the file
before the the file permissions are are
set so symbolic links symbolic links and
are just basically special files that
are referenced to another file they're
actually supported in this API what we
do there's various different types of
links and symbolic link type of
implementations out there this API
defines them based on the long-standing
a Munich semantics they're followed by
default and in this API and but there
are several api's that allow you to
optionally say whether or not to follow
symbolic links or not because when you
do when you're reading attributes you
sometimes want to follow symbolic links
sometimes you don't when you're deleting
files you definitely most certainly
don't want of to and follow symbolic
links and so on so here's a good example
where we test the weather a file is a
symbolic link or not there's also a
method called is same file so given two
completely different paths you can
actually see whether they are linked to
the same to the same file or not and
that and that works transitively as well
so here's an example I've reused the
attributes a minute ago where I've
reading the bulk attributes of a file
and passing it again basic file
attributes and now I'm going to extend
this example with an option to tell it
not to follow symbolic links and that
option is called a link option and is
called and the the value to the enum
value to not follow symbolic links is
called nofollow links and that is very
useful in that now now you can see
whether this file is actually a symbolic
link
when you read its attributes in bulk so
that's really really useful recursive
operations so and we did that directory
stream in minutes ago just to iterate
over the contents of the directory this
API actually has a general and walk the
file system API called walk file tree
and you give it a starting point and a
file visitor a file visitor is basically
an interface defines four methods and
those methods get called as the files
get visited so there's this there's a
pre visit and a post visit on
directories because some recursive
operations you need to do something but
when you when you first see the
directory some recursive operations you
need to see it at the end of the
directory there's a simple file visitor
which is in which is a basic
implementation of our file visitor that
overrides implements all of the methods
and and it's it's much simpler thing to
extend when you only want to implement
one or our small number of the methods
the iteration is depth-first directories
are visited twice as I said and the
method simply the file visit methods
themselves return a value that indicates
em how the iteration should actually
proceed because this is this is all
internal iteration where the where you
can additionally then control whether
you want to skip terminate continue and
so on and when you if you use this
method of to follow to walk a file tree
and and follow symbolic links then it
will support am psychol detection so if
you've got a symbolic link to a parent
directory you do want to go into an
infinite loop as you as when you follow
links so they will get reported as an
error when you do your iteration so
here's a quick example of this and I've
just just to fit it all into the one
slide I've used an inner class here's a
little bit ugly when you look at it for
files have walked file tree two
parameters the starting point which is
some directory in the file system and
I've extended simplified visitor I've
ever meant it to the methods the pre
visit directory and the visit directory
f sorry visit file and in this example
it's simply just printing out the names
and we should just print out the file
tree and which is very very simple
you'll actually find in the samples
directory in the jdk several examples
that
recursive operations and they all end up
using files walk walk walk file tree
there's a file change notification in
this mapi in this I won't have time to
go through it all today essentially what
that allows you to do is to watch files
in the file system to see whether
they've changed or not the primary
motivation of this is to avoid the
performance issues that you would have a
in applications where you're forced to
pull the file system have you changed
every change have you changed avoiding
the auditing that polling by plugging
into the native file system and getting
events from the file system when the
file has changed and so this is highly
platform-specific how that is done
there's fall back of course for for
Dumber platforms where you don't have
have implementations but the idea is it
gives you an API that you can actually
build on to do the do these have
applications that need to be notified
when there are changes so in this API
it's minerally required that the
implementation support monitoring
directories so directories will be when
i say directories you get notified when
files are added deleted or modified in
the directory it's it seems reasonable
implementations and providers are are
allowed to actually extend that with
other events if if they want to one
warning about the watch service API and
watch services the type that you
actually use it's a quite a low-level
API so when you look at first you might
find it a little bit and difficult to
use that is because it's designed with
multiple masters in in mind it's not
designed specifically for client
applications would call backs and so on
it's intended for server type
applications as well to be combined with
the thread pool so that you have control
of the thread identity and things like
that one and when you're dealing with
events and at a high level the API just
works in to two phases and you register
a path to a file are two Atari to a
directory with watch service you get
back and a file key which represents
your registration and then you poll or
take from a watch service and it cues up
your file key when that file has changed
you'll find some examples in the indie
jdk to do it there's a the watch sir
example in there you can just point it
at a directory and you any as you change
or add files or delete files you'll get
events so it's all the sample code is
there
try it out final thing I just want to
mention is the service provider
interface and this is the means to and
develop or and deploy your own custom
file system implementations so right
back at the beginning I talked I just
pointed out that we have the Java nal
file SPI sub package that's the service
provider interface that is the place to
go to extend and plug in your own file
system implementation all of the methods
that are defined by the java.io.file
files class all delegate to the provider
so whatever the associated provider is
for for the file path it delegates the
provider so the provider has the hooks
in there to do anything specific that
that it requires so that what you do is
you extend the type qualified system
provider that is the factory that is the
that creates the file systems you deploy
it as a jar file and it's identified by
a uri scheme and there's there's the
different methods then in the file
systems class it allows you to create
and get references to these custom
custom file system implementations cool
thing about this is this is that the
default provider is actually using this
provider mechanism as well that means
that you have the ability to replace the
default file system if you really want
to or you can actually interpose on the
default file system so if you want to
interpose your own logging layer or
something else or some other virtual
layer over the files over the default
file system then you have to be
Institute with this with this interface
so we have a sample zip provider in that
Sherman Shen developed and and include
it into the JDK and this is just a
simple demo provider we include the
source code in the JDK and since jdk 7
so you can play around with it yourself
it's also deployed mm in the extensions
directory so it just works works out of
the box and essentially what it does is
just treats the contents of a zip file
or a jar file as a file system as it
sits a writable file system you can
actually modify jar files and things
like that and as well with it so it's it
serves as a useful proof of the the
provider interface and is also people
have found it actually quite useful in
their applications as well so here's a
here's one example and
of using the zip provider so I'm using
here the pats get method this is
shorthand for right back at the
beginning I did a file system get
default get path I pass it a string and
I got back up that's very long-winded
you can do that with the simple paths
that get passed out of pastoring gives
me back a pat on the default file system
so I'm calling here the file systems new
file system method and passing it the
path to the zip file it opens that zip
file as a file system and I just treat
it as a file system in this example here
it simply prints out the names of the
file in the top level directory of the
zip file it's very very simple and Joe
will be posting these slides after these
talk here so you can you can work
through these examples if you want ok so
just just just just to sum up I know
we've had to kind of rush through things
here a bit because we've had so much
material but and the important point
about is is is that the JDK finally gets
a a comprehensive file system there were
so many issues and so many shortcomings
in the API it's it's great that we
finally have and address most of those
things and you find this file system API
is really easy to use but it's also
quite powerful and I've touched on some
of the extension points in the API and
as go through this but there are others
and but the important thing is is it can
be extended and to to deal with with
other other other type of platform file
system issues that you that you need and
jdk 7 has been shipping now for more
than two years and so you can you can
actually use it and we've got a few
updates to this API coming in jdk that
links it in with the streams api and we
might talk about those at the baths
tonight i'll give a link to that in a
second so that's a quick run through of
coin and the under file system API so
we're just just just to wrap up and
here's some links to jdk download page
for those that were still on jdk six and
older earlier on and there's links there
to the enhancements page Joe talked a
bit about some of the constraints and
compatibility at the beginning of the
talk and there's a link there to the
compatibility page for those that are
concerned about upgrading to seven and
what issues there might be and two
points just to work to to highlight just
in the compatibility notes because
Jadakiss
having a ship two years and these are
just two of the things that have kind of
pop came back at us several times in 7
was released and we've run into several
cases where and the order of methods
returned by java.lang classes is
different it has caused problems for
things like j unit which tests would
make assumptions on the execution order
of the tests and also there's this
changes to differ tree map and tree set
dealing with null keys that seem to have
to expose bugs in a number of libraries
out there so they're they're just two
things that that after two years of jdk
7 shipping they're just two things to to
highlight okay so just to sum up jdk 7
is is ready to use today and lots of
benefits i think in terms of languages
and and and library features and it's
out for two years the latest update just
came out in the last two weeks which is
7u40 and which has a huge number of bug
fixes a lot of people have found issues
in the two years they have been
addressed in 1747 t40 also includes and
medicinal newer features for
serviceability specifically the mission
mission and Mission Control which is
part of the whole convergence with M&amp;amp;J
rocket and and hotspot and seven updates
if you want to track them we do all over
all the development 447 updates in in in
OpenJDK there's also download oracle
provides early access binaries for the
seven updates on java.net the links are
there and so i guess we have a one or
two minutes just for for questions if
you want to shout we need to remember to
repeat the questions for the recording
and and just just if we don't get time
to deal with your questions today
there's two baths this evening and
there's the meter language bath which is
are we an A or B here it's either in
this room or next door at five-thirty is
the language language talk so any
questions on language features Joe will
be there and as with others and from the
language team we have an ayoba here in
same rooms immediately after the
language buff and where we will take any
questions anything I owe related
file system related a networking related
and so you can bring your questions
there thank</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>