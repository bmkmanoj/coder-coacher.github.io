<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Just-in-Time Java EE: Provisioning Runtimes for Enterprise Applications | Coder Coacher - Coaching Coders</title><meta content="Just-in-Time Java EE: Provisioning Runtimes for Enterprise Applications - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Just-in-Time Java EE: Provisioning Runtimes for Enterprise Applications</b></h2><h5 class="post__date">2015-06-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/lqsvvldhIq4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to just in time Java EE and
thank you for being here so early in the
morning although for many of you may not
feel that early it certainly doesn't for
me just a quick introduction my name is
tim ward and i've been doing this sort
of thing for quite a while i've been a
lot of different conferences over the
years i'm a senior consulting engineer
and architect at peramis to the company
you may not have heard of but we do we
do fun things in in the cloud and with
distributed runtimes so I've done quite
a lot of stuff over the years I worked
for IBM so I've had quite a lot of
cutting my teeth on implementing things
like ejb containers jpa containers load
of low-level bytecode weaving and
engineering of stuff that people don't
normally play with that much and I've
also written a book about osgi called
Enterprise osgi in action it's a
heart-rending tale of human suffering in
the siege of leningrad it also tells you
a little bit about how you might want to
use osgi components to do the kinds of
things that you're used to doing in a
Java EE server but maybe you want them
to be a bit more modular so web
applications persistence using jdbc or
JPA accessing message queues doing
remoting that kind of thing so it's
pretty useful if you're looking to do
that sort of thing in an osgi
environment so what we're going to cover
here today is why we need more
modularity just in general but also
specifically when we're looking at the
cloud why it's important to make things
modular how we can use osgi to provision
applications how we can deploy external
processes that are actually nothing to
do with osgi using an open source tool
called packager and then how we can
actually dynamically wire these systems
together so we configure them to run
even though we knew nothing about how
they were going to be laid out until the
very last second so start by looking at
how we can build the maintainable system
using modular components so true cost of
soft
where is not the thing that people often
think of but actually hardware is really
really cheap these days I mean if you've
looked at how much it costs to run
instances on ec2 it is not expensive but
maintaining your software is really
expensive really expensive and over time
they'd shifted away from the big box
that was really expensive and you had
one in your University and you're
waiting for your time slot at two in the
morning to actually everyone has a
supercomputer on their desk now yeah
computing is cheap people or not so to
reduce costs we need to focus on making
things more maintainable not actually
making the hardware cheaper because
that's not going to help so modular
systems maintainable systems so you've
got three different things really that
modularity is going to give you it's
going to allow you to manage complexity
you've got these little boxes and each
one has you know complex stuff going on
inside but you can treat them as black
boxes and you can drop them in places
and they will do something and you know
what they depend on and you know what
they provide so you can stick them
together you know it's your big box of
Lego's modularity enables parallel work
and it's tolerant of uncertainty now
what do we mean when we say tolerant of
uncertainty it means that actually if
you've got a modular system you can make
changes after the fact because you know
what your interface is and that's that's
your contract and how you choose to
implement that contract is properly
hidden from everyone else I don't know
if people are at the the jigsaw talk
earlier when they were talking about
finally hiding some of the the Sun
packages that people have been able to
depend on and that's because actually
the JDK wasn't modular it you had access
to all of the internals and people were
able to go and get things like Sun misc
unsafe and do things that they really
weren't supposed to be able to so cloud
platforms can benefit from all of these
things enterprise cloud applications are
inherently quite complex things you know
they're big they're distributed and they
tend to have to do an awful lot
huge volumes of data huge request
volumes that's that's what you've got
the cloud for so it only really works if
you can scale well if you can't scale
well then the cloud is not necessarily
going to be that helpful to you I mean
fine it'll give you a machine that you
can just not worry about someone else is
going to manage it but you're not really
gaining anything from the fact it's the
cloud you're just gaining from the fact
that someone's managing a machine for
you but the thing about cloud is it's
quite an unstable place people don't
think about it but you know data centers
do go down there have been a number of
big news items where bits of ec2 or one
of the Amazon data centers has just gone
bang and you know people people are in a
lot of trouble when that happens and
also VMs do get moved you know there
aren't actually such strong guarantees
as you might expect to say yep your vm
is going to be here and it's going to
stay here if you if you stop your ec2
instance and started up again it could
be in a completely different place it
certainly got a different IP so VMs is
the unit of modular cloud deployment
because this is what a lot of people do
yeah deployment management it's the big
deal in the cloud you've got to be able
to get your application there and
running and you do that by shipping
around VMs mostly you have DevOps stuff
which is there from managing these VMs
you know when they get laid down you
then have to do some introspection about
your environment and do some
configurations set up they're also
pretty big so I don't know where I don't
know how many people have have been
using VMs for cloud deployment but you
know tens of gig sound sound crazy you
know I've certainly use some that have
been a good 30 or 40 and that's a lot of
data to shift around and if you want to
make a one-bite update you've got a
whole new VM yeah it's not like you
submit small patches you see ya here's
my new big vm there you go s3 so let's
do a little bit of word association now
the first one's kind of come for free
because I've told you VMs aren't small
but Sir do what do we think do we think
vm deployment is it fast is it slow
or any of us had our coffee yet are they
dynamic or are they static here if
you've put your vm up there is it is it
something that it's it's going to change
and react or is it something that you've
put up there and it's you know you're
nice static thing that you build on yeah
so I mean it does depend a bit on your
VMware but if you've got your vm image
it's not something that changes you're
not unless you replace it completely
with something else or you re right back
and you've got something that's mutable
but if you're sharing it as the common
deployment for your platform then you
probably aren't saving stuff back to it
because you know when you get conflicts
it's going to be a bit of a mess but ok
so our vm is really modular I don't
think that they are so I think that
they're pretty classic monoliths you
know a vm pretty much if you ship a vm
around your kind of expecting it to
contain everything it's got your
operating system it's got a whole load
of base stuff that you're kind of
expecting to be there or you're going to
have to ship around scripts with the vm
every time to load all the common stuff
that you need like unzip so
fundamentally you've got this thing that
you're moving around and it's got to do
same set of stuff every time and you
know you use devops to try and reduce
this maintenance costs and you might
even have a single base vm that you used
to provide as a platform for lots of
different things but if you're changing
any single component of that you risk
breaking all of those applications so
you've just kind of made your
maintenance problem even worse but yeah
by having the one vm for all of your
apps you've now got all of those
combinations to test that you never had
to test before and it becomes scary
doing these updates so what would what
we need we need a clever new solution
but you know really something new
haven't isn't this a problem that's been
solved so cloud applications are really
big but size is relative because clouds
are also really big so if you've gotta
really be a pond
really big cloud is it you know which is
which is big or is it just kind of we're
looking at something that's a
resource-constrained system you know an
application server contains hundreds of
jars and hundreds of thousands of
classes if you look at the original
websphere think the liberty profile is a
bit smaller but you know hundreds of
thousands of classes and if you've got
duplicates it's horrible to diagnose you
know here's we've got a Class A and
we've got another class a and if they're
not exactly the same then stuff is going
to go wrong so Java EE vendors didn't
you know create the solution to this
problem either they they borrowed one
that was already out there it was way
back in jsr 8 which is a long time ago
now and it's called the open services
gateway and it was an embedded server
for running java on home automation
gateways and things like that I was
designed to work really well in
resource-constrained systems which is
what we're really talking about it's
pluggable it's extensible and it's the
OSGi framework that you know and
possibly love how many people here use
osgi in any way at all okay that's good
where do you think do you like it yeah
so how does osgi manage all this
complexity well osgi modules are called
bundles bundles are jars and they're
just this little bit of a little bit of
something different but they are jars
and it's that the manifest has some
modularity metadata in it so where you
can see here that we've got three
bundles and they fit together because
they've got a shape that's described in
the manifest so we know that a has these
two lumpy bits that stick out and in
this case it can be it can fit together
with something that's shaped like C and
D that also locked together but you know
you could also have a be that was the
same shape as see indeed combined and
plug that in and it would all still work
and it's because bundles list the things
that they depend on and the things that
they expose and if you don't export it
you can't import it yeah it gives you
the jar private stuff that Java really
lacks
your bundle can only start once all of
its dependencies are there and because
of that you've got a good guarantee that
you're not going to get
classnotfoundexception you're not going
to get no class they've found error
because you know that stuff is there
before you begin and exports and imports
have versions which allow you to make
guarantees of compatibility and it's
important that you do some kind of
semantic versioning the OSGi Alliance
have a a semantic versioning scheme that
works really well but there are others
but you if you use semantic versioning
then you can manage change and you know
that you can evolve api's without
breaking people so osgi is good and it
gives us the ability to resolve but it
also gives us the ability to provision
using metadata so deployment in osgi is
kind of similar to deployment in a cloud
you've got like a little cloud in a vm
as it were so you've got this kind of
base thing and you want to stick stuff
onto it so a collection of dependencies
has to be installed yeah okay but unlike
in a lot of cases osgi bundles are
self-describing you can look at an osgi
bundle and know what it needs which you
can't do with a lot of other
applications so the osgi resolver can
use this information and it'll say you
can run now or no you can't run now you
can't be started but it'll give you a
reason why and it won't be some some
runtime exception that you find you know
3-4 hours into your production system
getting a storm of requests and until
your bundle resolves it's totally inert
you've got no risk of stuff going wrong
so the resolver really is looking at the
context of the environment around it
it'll say I've got a bundle and I want
to make it work what's available to me
but you could add a repository and
there's a standard repository format and
when the resolver has an unsatisfied
dependency it can go and ask the
repository do you have anything that
looks like this and the repository will
give it back some answers and then the
resolver can carry on so what you can do
here is you
you can ensure approved dependencies are
there but you can also pull them down
and that's kind of cool the eventual
solution here you're going to get
various things pulled down which are
your dependencies and the runtime is
going to work even though to start with
all you all you did was you installed
your application bundle all of your
applications dependencies are just going
to appear as if by magic so the thing
about requirements is that they can be
quite complicated and historically there
was no there were no repositories
resolver was kind of an implementation
detail of how frameworks worked and
there wasn't really any kind of
provisioning you just had package
dependencies and bundle dependencies and
that wasn't great you know it was good
for osgi but it wasn't great as a
general solution but since the release
five there have been generic resources
and a generic resolver API and you can
see here that you can just have a
repository and it can have pretty much
anything you want you can describe a
various different kinds of steamed
puddings and they're all in there and it
doesn't really matter whether they're
osgi bundles like the one on the right
or whether they're actually puddings
even if they share a name you can still
identify them by what type they are so
requirements and capabilities are pretty
cool you can express pretty much
anything because you've got namespaces
and what the namespace means is kind of
up to the namespace so osgi itself has
some new types and indirect dependencies
on runtime services can actually be
expressed and you can say not only do I
depend on this code you can also say I
depend on this this whole runtime
service so you can use attributes to say
sort of specific things like not only do
I need a web container but I actually
need it to be tomcat because you know I
use some tomcat API or maybe I need it
to be jetty and you can also talk about
directives for determining say when
something applies so this this
requirement is effective at runtime or
this requirement should prevent me from
resolving at all because I can't do
anything useful until it's there
so just to show you that this is a real
thing got a fairly simple demo that I
can do so what you can see here is some
information about an osgi bundle and you
can see it's called web as a web context
path which is the osgi way of saying I
want you to make me available on this
context route right
as that okay so what you can see here is
got a web context path and we're
requiring a capability and the
capability is osgi extender and we're
saying that we need an osgi extender
that is a web container and then we've
got some version information here this
is just a standard ldap filter it's not
anything hugely special and we're saying
that we want the aversion to be greater
than or equal to 1 but not greater than
or equal to two so between one and two
but not including two so you know this
is this is all very interesting but one
of the cool things we can do so this is
a tool called bear B&amp;amp;D tools it's kind
of something you can plug in on top of
eclipse and it gives you some really
cool integration with osgi repositories
so you can see here I've gotta run
descriptor and the run descriptors
basically listed the repositories that
I'm allowed to use and I can say in here
that I want to take my java one web demo
and you can see in here there's a run
requirement which is basically just
saying give me javaone web demo and I
can ask it to resolve and it's going to
go away and look and you can see it's
pulled in quite a bit of stuff it
doesn't actually matter that you
probably can't read that as well what
you what you can see in there is that
we've got among other things jetty
because it's a web app and it needs a
web container so if we click finish and
we save then we can go and we can even
run this directly and you can see it's
now running down here in Eclipse and if
I
see now I forgot my context route
javaone web
so there we go we're now hosting this
really simple servlet and it's there
that's kind of interesting but it's not
that difficult to see how that would
work and it's all on my local machine so
yeah we'll come back to the demos later
and hopefully I can show you something
that's a little bit more impressive yeah
that will certainly so just to repeat
the question for the recording a
question was by not including stuff with
your deliverable and just using the
dependencies will help to reduce the
size of the things that you deploy and
the answer is yes it decreases them
massively if you're just deploying your
web app and it reaches the server and
then the server knows it needs to pull
down just jetty because that's all you
depend on you don't need jetty and maybe
also a database and maybe also some you
know no sequel store and all the rest of
it you can dramatically reduce the
amount that you actually have to ship
out to all of your servers
so the question was having seen the
version range was that was that
something that to do with the with osgi
or is that something that's the app
server itself now what that version
range is doing is it's saying that I
depend on this capability that exists
and that capability is versioned so it
is it's down to the individual
requirement namespace to determine what
the version means i would recommend that
you use osgi versioning semantics but
you don't have to it's just saying I
depend on this capability and it's in
this range of versions so if someone has
a capability that matches that version
then you know that that's okay that's
what that version range means so what
about my existing code you know it was
all great i'm showing you some little
bundle that i've put together but
fundamentally as i said existing
software is a big cost software
maintenance is there big cost we can't
afford to rewrite everything or at least
unless your company's really rich but
and what if we don't want to write osgi
bundles or what if we don't even want to
write Java you know there are lots of
really good things that are written in C
C++ or you know other things that don't
even run on the vm so you can't just
kind of install them on top and hope
polyglot osgi it's real you know you've
got scholar modules which does run on
the vm there's active work on
standardizing for c c++ in native osgi
and yeah javascript is something else
that's currently quite active and there
are there are people doing that so it
doesn't just have to be Java but you
know all of those things still require
that you run in the osgi framework which
actually isn't necessarily what people
always want so we could use our SGI to
do this provisioning and lifecycle
management but actually not running the
osgi container and that without that
would potentially be quite an
interesting solution so this is where we
start to look a little bit at packager
so packager basically aims to create
self-describing osgi bundles because
they
is a good thing and it allows some
dynamic resolution assembly which is
another really good thing you can
semantically version these things which
I would suggest that you do with all of
your modules regardless of whether there
are SGI or not you can leverage osgi
alliance specifications which means that
you get a common life cycle and api for
how you interact with these things you
get dynamic configuration and you get
really easy access to local and remote
services because osgi has the service
registry where you can communicate with
other modules and you can communicate
either locally or remotely and it's
transparent to you so the other thing
that we really want to do is we want to
make sure that existing code can be
packaged up and used with packager
without having to change that code
because if you're having to change that
code then we've kind of failed the whole
point is that you shouldn't really know
from the code perspective that your
process is being managed by this osgi
framework and there's an open source API
for doing this so you can write your own
package components there are already
quite a few that have been written and
it allows people to write competing
package or implementations as well so
the approach is basically you wrap your
native artifacts in an osgi bundle and
then you take that artifact and link its
life cycle to osgi so you've got bundle
install starts and it's kind of that
install onto disk so kind of deploy and
make sure there are binaries there and
then you use services to determine
whether you should start or stop this
external process and then you if you
uninstall a bundle then you take away
the binaries and it's no longer there on
disk so it's a pretty simple kind of
cartridge model if you've used Google
Play Framework but you know it's it's a
way of shoving in function but also
being able to take it away again later
and you can link to the standard osgi
services for the kinds of things that
you might want so configuration admin
allows you to push in arbitrary
configuration you can use meta types to
describe defaults and the types that
your configurations supposed to have
you've got centralized logging if you
want it there are lots of other things
that you can do and what we've got here
is really simple system description
which is basically saying I want to take
a back-end mongodb and deploy it and
it's just got a thing saying deploy
Mongo and make it run on the port 20 70
17 and that's basically it that's saying
make make Mongo run and one goes there
so the separation of concerns argument
is kind of well if you've got this block
how do you how do you make that kind of
work so you've got a package type
service which determines when when we
should start what configuration and
properties we should be using sorry with
package type service which is what we're
running the process guard service which
is what we configure and how we
configure it and then the guy who
actually runs the start-stop scripts is
the watchdog process so the package type
usually has the native binaries in it so
if you were deploying Mongo or Redis it
would have the native dll's or
executables for your platform if it were
say you were packaging up an EE app
server it would have the installer for
the e app server in there and it
installs the native program and then
configures it based on the configuration
that it's given if then gives scripts
back to the packaging manager which
tells it how to start stop ping to see
if it's still alive you know that sort
of thing and it's usually platform
specific because if you've got native
code then you depend on your operating
system and you depend on the underlying
processor architecture that sort of
thing so what you've got here is a
description of how you could provide
capabilities for Mongo you can say I
provide a package type that is Mongo and
it's Mongo 22 but I also require that
I'm running on 64-bit linux because
that's what this Mongo was compiled to
do so that will not deploy on any osgi
framework that's running on a raspberry
pi for example it also won't deploy on
my Mac but it would deploy on my linux
vm on my Mac because that's 64 bit
so the process God's service is there to
gather config and it basically is there
also to say you should start this
process now so if you if you provide a
process guard service it's saying right
now run it receives some state change
events so you know when the things
started you know when it died you know
when it's been restarted and it
advertises the running package so you
know this is optional you don't have to
do it but yeah advertising that you're
running is a good thing to do and it's
usually platform-independent so in the
case of in the case of say Mongo you'd
have a number of different package types
that were for various different
platforms but you would have a single
guard that knows how to configure well
knows what configuration properties
Mongo needs and knows when Mongo should
start and stop which is kind of
independent of whether you're running on
Linux or whether you're running on a Mac
or whether you're running on a raspberry
pi yeah you don't really care so you can
see the interactions here we've got the
package type for mongodb and so you can
see here this is a MongoDB for mac and
that communicates with the packaging
manager via a service and then you've
also got the MongoDB guard and that's
got a process guard service and when
both of those things are there the
package manager will request config from
process guard pass that config to the
package type and receive some scripts
it'll start running those scripts and
then it'll publish events back to the
the guard to say yes this thing's
running and so what that's done is this
is this has allowed you a kind of
central guy who knows how to run scripts
but not necessarily how to configure
every every particular package type and
you've got another guy who's saying yeah
it's time for us to start it's time for
us to stop and they can collaborate
together to manage this external process
so process garden a package type means
start me and process guard is queried
for these conflict properties package
type then creates configuration which
may be on disk or it may be built into
the start
gripped and creates those start scripts
stop scripts ping scripts and pass them
back the watchdog which is the packaging
manager then actually launches this
thing and starts polling it with the
pings grip to see are you there and then
it notifies the process guards but this
thing has started all this thing has
died or you know the various lifecycle
events you might expect and then if
either service goes away then the
watchdog process its job is to stop it
it's got to stop scripts and it's like
no one of these has gone which means
that someone's either completely
uninstalled the whole application and we
should stop or the process guards gone
away which means it's no longer
appropriate for us to run so we should
stop and wait until the process guard
comes back and then one thing I did say
optionally you can publish an endpoint
so endpoint information is useful
because you can have an is marker
interface but you've also got a URI and
that you are I might not seem like it's
particularly useful but it can be used
to establish that the process is there
and that's more useful than you might
think because it can also trigger other
things if you've got remote services it
can trigger things remotely so we're
what you can see here is we've got our
Mongo clients which is running on some
node and then potentially it could the
Mongo database could be on one of three
different servers and we don't know
which those are but because they publish
this endpoint to say Mongo's here and
that gets pushed through via remote
services we know that this guy is
available and we can run so our client
can start up fully and start using Mongo
that's on some remote server and if
later Mongo moves our client gets
notified that mongos moved and can start
pointing at the new Mongo so this is
this is all very cool but we can
actually make packager do even more cool
stuff by using something that's called
the OSGi extender pattern so an extender
is able to do things with requirements
and capabilities so earlier we saw the
following and we've got a package type
that is Mongo
we depend on Linux 64-bit so where this
is this capability allows us to infer
things about this system but we can also
use this to do automatic provisioning
because you can depend on the process
guard which requires the package manager
and it requires a matching package type
so you deploy this it pros this system
independent process guard and it will
say okay well when when Tim's asking for
it he's running on his mac so he needs
the mac version of mongo or maybe I'm
doing it from my Linux VM so I need the
limit the Linux 64-bit version of Mongo
and it'll pull down the correct one and
I don't have to say I need this
particular Mongo it will just tell it
will just find that out for me so
application bundles that depend on this
process guard can depend on it and it'll
pull in everything you need you can also
grab the guard directly and that's also
fine but what if you need more
configuration than that so the extender
pattern it's a really powerful tool
basically an extender bundle is one that
looks for other bundles and helps them
to do something so there are quite a few
examples you've got declarative services
which is an osgi specification which
will go through look at your metadata
and publish services on your behalf and
manage dependencies on your behalf so
you don't have to write that code you
can just provide essentially it's a bit
like CDI you provide a managed bean and
the life cycles managed by somebody else
for you and you get dependency injection
and lots of good stuff so it's usually
marked by some kind of requirement or
manifest header and what if we use the
extender pattern to configure our
process cards so our process guards
need-to-know information about what
they're doing but that's going to come
in from somewhere it will be really nice
if we could provide that in a
self-describing way so we want to extend
self-describing bundles so we know
that's it so Java EE applications need a
java runtime that's pretty obvious and
we can use packager to install and run
this but
java applications often need more than
just a java runtime so we can use the
extender pattern to infer the
configuration for this and that'll be
great we can fully configure a jpa app
with this so what we've got here is a
capability saying i need java ee at
version at least six yeah i'll work with
java ee 7 but i need at least java ee 6
and i'm going to provide a web app with
a context root of so this is the jboss
kitchen sink it's one of their sample
apps but it uses jpa so it depends on
having some data sources it needs a JTA
data source which in this case we're
declaring to be ex a false because we
don't actually need XA but it also needs
a non je t a data source and you know
that's something else that you need in
order to configure hibernate properly so
in there what we've defined is where the
where we expect to find these things in
jndi and what they are in this case
database endpoints so I said the
endpoints can be used as triggers so
this java application the java
application needs the database endpoints
so we can actually gather the necessary
configuration data from the Java EE
bundle and then we can wait until the
database endpoints available so we can
sit there quite happily not installing
your application until such time as we
know the database is ready and once that
is ready we can register the process
guard things will start and run and
isn't that great and because we've
waited until runtime we didn't actually
need to know where the database was or
what its implementation was we can just
pointed it dynamically at runtime and
that's pretty cool because it means that
however you lay out your application in
the cloud whether that's you know stuffs
moving around because of elastic
balancing or you need to tear down a
server and produce a new one you don't
need to worry about reconfiguring
everything it will just configure itself
that's great yeah it's nothing more
annoying than trying to work out why you
can't talk to the database
and it's because somebody moved the port
it was on or somebody put moved it to a
new host so now we've got another demo
and this one is going to be done Niecy
too so don't know how many of you have
used ec2 but you can see here I've got
some servers running and what we can see
here is I've just got something here
which is going to deploy out onto some
nodes so you can see I've got two
applications here and this is running
two of the on two of the ec2 servers and
they're both using Java 7 and just to
prove to you that there aren't any
tricks what i can do is in the admin
console i can actually show you here
that we've got something saying deploy
our jboss sample app and it's just
deploying the app it's not saying deploy
jboss or deploy glassfish it's just
saying deploy that app so i can deploy
and we can see on the monitoring view
this guy's gone green and he's been
deployed to you see that at the bottom
gray you can see he's been deployed to
some server in easy to now that's 94 so
if i go here and see currently there's
nothing there and that's because we
haven't started the database yet and if
i go here and deploy my database and we
go back and this guy jerking you can see
he's on 52 it's yellow for some reason
and it's because the vm is currently low
on heap which I'm not that worried about
so now if we reload you can see
glassfish is running so this is glass
fish for which is you know recently
released but java ee 7 app server and
actually if i go here now you can see
this is the jboss kitchen sink app and
if I register you can see this has been
persisted to the database I can access
it via a rest URL yeah that's great
that's all been wired up dynamically at
runtime the database you can see if we
go back here all we've done is we've
said that we want to create a database
called test and that it's going to be
stored in / temp because we don't really
care about the data persisting very long
but we've not declared what port it's on
we don't know which system it's going to
end up running on but it all still wires
together and actually if we look we can
see that this guy is running on server
52 so that IP address ending in 52 and
this guy is running on 94 so they're
running on different machines but they
were still configured and can talk to
each other I think that's really cool
but the thing that's actually even more
cool is that we can do this again on
java 6 now the thing about java 6 and
this is a pretty much identical aside
from the fact that they're running on
java 6 is that is that glass fish for is
a java ee 7 app server so that's not
going to run on java 6 categorically it
will fail so what's going to happen if
we if we try and run here so if we again
deploy our application deploy our
database they're both red at the moment
because it hasn't reported where they
are they've gone green so you can see
that the database is running on 45 and
we're running on 72 for the app server
itself so we're not running glassfish
anymore we're running jboss and we're
running jboss seven because jboss seven
will run on java 6 because it's a je 6
app server so and if we look again
you can see we're here obviously we
don't have the same database thing in
there because it's running on a
different server doesn't have access to
slash temp but if we if we had put the
Derby in a central location obviously it
would have been sharing that but we can
just prove to you that it still works
and there we are I've got access to this
thing that's been persisted in our
remote Derby yeah because it's been
successfully deployed the bundle is
there but that that isn't to say that
all of the endpoints are ready what it
means is all of the bundles have been
installed and started and are rated
waiting and ready for work so what what
would actually happen is when the when
the app server starts up and deploys the
app you'll receive an endpoint service
will be registered which will say this
application is available and it'll tell
you what the what the URL is for getting
to the root of that application and that
what you would normally do then is
publish it into a load balancer like
engine X which again has a package type
and that will automatically configure
engine X 2 root requests to that
application and then engine X will only
will only ship come green when it
started up because it actually blocks to
bring up the engine X service so from
the monitoring perspective what you
would do is you would go and you would
look through the log which has probably
been overwritten by previous data by now
but yeah so that's got some dispatch
requests because I've got the the
logging level turned up too high but you
can view the log for the server and see
what's happening or read if you want you
can actually put bundle in that will the
block and report that the service isn't
there but it's not necessarily a narrow
state which is why it's not report
as an arrow state because it's perfectly
acceptable for your bundle to say I'm
going to sit here and wait and do
something and when the service is
registered I'll make a call and then
when it goes away again I'll go back and
sit and wait it's it's very much a
reactive pattern with respect to when
services are registered Oh question over
there okay so the question was if you're
doing builds with maven how does maven
fit in with this so maven has a plug-in
called the maven bundle plugin which
will allow you to build osgi bundles and
what you can absolutely do is you can
build with maven and you can do tests
with maven and in your test environment
I would suggest that you're probably
going to have integration tests that you
run on slightly more static
configurations than this you're unlikely
to say go out into the cloud provision
me 10 servers that could be anywhere and
throw everything in and you're going to
have something with a bit more control
because you want to be able to diagnose
when things go wrong what actually went
wrong so but you can absolutely use
maven to produce these artifacts so the
the let's get this right the jboss one
we use B&amp;amp;D but i think that yeah the
GlassFish one was built with a maven
build and you can test it you can their
own maven tools for running in an osgi
framework like pax exam is an example
there are a few more listed in the
testing chapter of my book and the names
escape me for the moment but packs exam
is the most popular one so it does that
answer your question
so this were this works with pretty much
anything you like so you can package
Tomcat it was as you saw we had jboss
and we had glass fish but you can also
packaged up jetty you can run jetty
embedded in an osgi framework and you
can run tom cat in bed in an osgi
framework if you want so the first
example I showed use jetty but if I
pointed it at a different one of our
repositories it would have used Tomcat
running in the framework but externally
you can also run them as standalone
processes if you just want your tomcat
to be outside of an osgi framework and
run as normal tomcat that's doable
so the question is how do you bootstrap
osgi and what I'm going to do is find
right here we go so these are just some
really really simple scripts which I use
to start up my Amazon service so this
goes in when when you're asking easy to
create your instance you say update
linux install unzip in in the case of
OpenJDK seven if you don't install the
desktop schemers then jdk 7 doesn't work
even headless that's about in OpenJDK 7
it's not a bug in anything else install
OpenJDK 7 and then pull down the fiber
zip which is basically just the service
fabric runtime from s3 it's about 6070
meg and you then unzip that create
something which is going to point it at
this here which is our elastic IP
because it needs to be able to find
other members now all you need to do is
find one so you have one elastic IP and
you're fine if you aren't running an ec2
and you're allowed to use multicast then
you don't need that at all you can just
use multicast and they'll find each
other but obviously amazon doesn't allow
multicast in ec2 so here's where you
basically say point at this elastic IP
and then start up the fabric in the
background you complete the server is
running you've got a similar one so this
is for the the infrastructure fiber
which is kind of the one that you talk
to you to manage you can create more of
those and one of them will take over if
this one dies but fundamentally once
once you've made contact with the with
the one elastic IP you'll then find out
about all of the other peers because it
uses peer-to-peer messaging model and
you get control messages which will
occasionally say I know about these
people so that's that's how we do it and
it involves as say about 70 Meg coming
down from s3 rather than the whole VM
image
and then once you've got that you're
away so we've still got about five
minutes left any other questions okay
one more
yep yep absolutely if you if you don't
want to so the question was if you've
already got an environment and all you
want to do is deploy and manage changes
to say the war file and not the database
then can you do that and the answer is
absolutely yes the so whilst in this
example i was using using packager and
the fabric to manage the deployment of
the database i could equally have put a
single marker endpoint and published it
and said my database is over there
somewhere it doesn't have to be managed
by packager because all it is is a an
endpoint service which is effectively a
pointer to where the real thing is so
you could you can have your database not
in the cloud you could have it somewhere
in the cloud but not managed by this
system and it doesn't really matter what
you would then do is simply deploy
changes to your web app and so the the
fabric is model driven so effectively
what you do is you you give it a new
version of your system descriptor and
the fabric will then attempt to take
what it has already and migrated to the
new model that you've requested so if
you if you say I previously had my web
app version 100 and now I wanted at
10101 it will look it will find the
places where it's at 100 and it'll say
okay take that away put the new one in
at 101 and it's a if you then say you
want to roll back it'll look it'll find
the ones at 101 and put them to 100 and
it will also then pull in the
dependencies that may have changed
between those versions and all you do is
you list what you want the system to end
up looking like and then the rest is
handled for you okay another question
begginer reminds me of it what we get
with substance a check for the vector
because they're waiting to collect them
I'm typical but and already your shirt
off a bit process today so the question
was about whether you can integrate
packager with puppet and chef and so
effectively packager is very much an
osgi based thing it needs to run in an
osgi framework and it expects to manage
processes but you could very easily use
puppet or chef to lay down to grab an
osgi framework and install the packager
in and then push other bundles in that
the packager will use so yes it will
integrate in that way it just involves
you putting an osgi framework in there
which is not that difficult to do not to
my knowledge I certainly haven't written
one other people may have it's an open
source thing but I'm not aware of I've
whereof one so just to go back we've got
couple more slides
so just to wrap up platform should be
both modular and they should be adaptive
because things change over time you know
your ec2 instances aren't always the
same sometimes one of them will go down
and you won't necessarily know why and
the Amazon will and they probably won't
tell you so you've got tight coupling in
environments and that's where you get
catastrophic failure or cascading
failure also known as Black Swan event
so one thing goes wrong and then that
causes something else to go wrong
because it starts producing invalid data
that's that's just a URL in the bottom
you don't need to read it it's for
people who want to go and look at it
later so if you've got a deployment
mechanism that fails to acknowledge that
things change then you end up with a
really brittle solution that when
something does change things go really
badly wrong and that drives complexity
that increases the amount you have to
spend because when someone makes an
update to your core banking system have
no idea whether this will translate to
the US but in the UK there was a bank
that upgraded one of the IBM mainframes
it had that was running about half of
the core transfer service for accounts
in its banks and they lost service for
three weeks they couldn't make any
single bank transfer and you know
businesses went bust people were you
know people were out on the streets it
was terrible and this was all because
there was this one catastrophic failure
which just cascaded through the system
and they couldn't rewire anything so
thank you for coming I know it was an
early start but I hope you felt it was
worth it for more about osgi then you
can go to the osgi Alliance website
there's obviously my book which will
talk to you a bit more about how you can
use our SGI to do these things if you're
interested then there's a discount code
that's currently active at Manning com
which will get you nearly half off and
if you're after more information about
packager then there's a URL there if
there are any further questions then
feel free to grab me now or outside
otherwise thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>