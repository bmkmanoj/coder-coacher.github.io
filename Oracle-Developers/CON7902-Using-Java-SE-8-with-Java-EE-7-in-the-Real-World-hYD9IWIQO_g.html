<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CON7902   Using Java SE 8 with Java EE 7 in the Real World | Coder Coacher - Coaching Coders</title><meta content="CON7902   Using Java SE 8 with Java EE 7 in the Real World - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CON7902   Using Java SE 8 with Java EE 7 in the Real World</b></h2><h5 class="post__date">2015-12-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/hYD9IWIQO_g" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning guys thank you for being
here certainly after a depreciation
event I guess it took an excerpt from
you so I appreciate it and goodbye to
everyone hi to everyone who is watching
but I read it's not that fast so hi to
everyone who is watching the live
streaming so today I really want to do a
real-world talk and I'll give you my
background so you understand what I'm
talking about right so if you don't know
me
I'm Michael Mercer mentor centers and I
helped in several jsr over time I helped
to produce Java time I helped to get
Jerry sixes back then being validation
so forth
so I have a very very technical
background but also I'm the head of
development operations in the company so
we have like 30 people in the department
including developers including people in
doing DevOps so and I have been managing
people for 14 years so while I'm a very
technical guy I'm also a manager so some
things that I would say here you look
and you say no but that's a stupid but
people sometimes do it you know so
that's why I'm worried some others we
are going to read part of Brian's code
today during the talk to make some
points here on the other hand so I hope
it'll be more useful for you in some
points if you're just a developer if
you're a manager it's going to be useful
for you in other points but you get the
full perspective so that's my my idea if
the stock today okay as I as I talk I'll
probably discuss one one one topic at a
time
so then after each topic you make
questions you know to make sure that
you're that you are following that we
come to a good conclusion about whether
a feature is good or bad to use or how
hard that is if it is worth for you to
use this feature in your own projects
okay so let's get started so where how
what we're going to discuss today first
going to see what decision process you
should go through to decide where to run
your java is e seven applications on top
which ever see eight then I'm going to
discuss good and bad usages of lambda in
the context of Java EE 7 applications
then we are going to see how good it
really is to use parallel string when we
are talking about Java EE right or the
good old computer C until it is by the
way who here knows concurrency till this
race are two three six minutes right
factory not named people okay then we
are going to see how we can use Java
time with some of the specs here we
discuss a little bit about parameter
rotation and multiple annotations show
and then about default and static
methods and interfaces i guess that for
the last for this last one the advice is
a little bit more general than java ee
but that's a powerful tool for design so
i don't you cover that as well so first
where do you run where you deploy your
application there are many so many cool
engine ease that you could choose right
but at our our company we use it least
most of the time when we when we can
choose we use open source application
service that might not be your your case
but what we did since we can choose is
let's try to make the best choice and
for that we saw what is the best
available in terms of compatibility and
performance right so the idea here is to
tell you a little bit about the journey
and to give some general advice on how
you can do that right keep in mind that
when we did that that was the end of
2014
right so some of the information the
application servers need to be retested
I kind of know what changed but anyway
so one thing that I recommend to anyone
who actually move into any version of an
application server is to always have
something that is basically what you
expect to work but it never works which
is coming
of the different technologists in that
particular set so the first thing that
we did to ensure because we were
upgrading applications right to existing
applications terms of them was to write
the test shoot right and that combined
everything with CGI HB JDBC JPA in so
forth right so we wrote lots of
performance tests combining JSF with CDI
making sure that maybe this view access
scoped component really gets cleared
after you switch to another view so we
we had all this type of problems before
we had post construct bottlenecks in our
applications and we wanted to make sure
that that was going to work with Java EE
7 even in it being on top of Java si
it's just made it a little bit more
peculiar you know of a scenario to test
so that's something they recommend you
guys should do you know so we tested all
these combinations and many many more
every time we have a problem we add
something to discuss suit because the
way that we do things at my companies
that we try to keep to the latest and a
great to the latest as soon as we know
it's safe and by having it a suit we
know when it's safe or not to do so
right at that time what were the options
that we had right
we had Jerry what flight Tommy in
GlassFish at these versions at that time
right and but then told me unfortunately
at that time it didn't support Java 7
they were in the process of producing
the support that they are talking about
now so we had to exclude it doesn't mean
you you have to now now you have a
different scenario and we also wanted to
try let's see if we can assemble a jet
environment right sure and every 7 on
top of it because it would be cool
however then for a GPS you have to use
open ghb that will require open web
beings that will require that you
integrate a lot of things so in the end
that proved not to be so such a great
idea it would consume a great deal of
time so
and we faced a lot of errors so he had
to drop that path so that basically
limited this to
GlassFish in wildfly there were lots of
little glitches at first I was very
happy though because for very very few
things the problems that we found had to
do with the EE technologies working
together not with a seven
a CH which is it's not exactly what I
expected but if it said very little
problems in that regard right actually
the problems that we found we form later
because they were very very very
specific on the on the first part of the
building of the test suit all problems
were limited just to the different
interaction the combination of use of
those technologies on top of e7 right
the there was not such a great
difference in performance for our use
cases right so performance you always do
based on your use cases the particular
set of combination of technologies you
really plan to use together in
projection right and there was a slight
advantage for GlassFish especially after
a certain number of requests right but
we have been using J Baz AES for quite a
while you know and we he because I saw
that the difference was mini-me then we
decided to go with wildfire you see
that's when I remember I'm a manager
because I want to reduce the work and if
the difference is very little why should
we try doing the switch so it have to
make practical decisions that's what I
so that's what this talk is all about
you you know it's not only about the
technical side of it but the difference
yeah I was I was glad you know because
before you you when you tested those
things when they were just out there
would be so many bugs and things would
perform so badly you know in your you
would have to do lots of upgrades of
specific components to get things going
and so forth but really application
servers from 2014 onwards they're in a
much better shape so thank you open
source community
now that's it's really improving right
so the first lesson I want you to take
is you want to do this you want to run
e7 on top of a c8 right tests that cover
your usage patterns that's the first
step you don't want to grow to then be
cut into problems that you have no clue
whether it's something related to Java
EE 7 whether it's something related to
seh through the different interactions
between them where there is a code that
was always broken but just now you
realize it is you know for some for some
other reason so first make sure you're
stepping on solid ground so that's
that's easy so do that you know them
don't believe me selection don't believe
what I said here you know the server's
have very different versions now right
we aren't we are on the process of
deciding where to move forward
next right so we are going to do this
this all over again so that's what I
suggest that you guys do right now let's
move to the very first feature right
London
I guess now the last day of Java 1
everyone knows lambda right just make
sure I do some people don't know it
already sleepy or it's my accent because
not everyone who raised their hands I'm
pretty sure most of you guys do you know
ok so I want to show the kind the kind
of code that I've seen being produced
with lambda and I then I asked what you
guys think about this right so what we
most of most customers in my company
most products that we we do they are for
the automotive industry right so some
one thing that we do for instance is to
take license plates information you know
of which cars have been licensed where
you know and when should produce some
statistics graphics and so forth I'll
try to because it's going to be very
hard to read but it's going to be very
hard to read anyway because of line
wrapping in the size of phones we have
here
so I'm gonna show you something that
sometimes you need to do right and what
people feel tempted to do once they know
that they have lambda at hand right so
this is some sort of summarization it's
going to produce this map full of
parameters here let me move that to the
top right so they're talking about the
very first line so it's easier for
everyone in the back to read right so
the the idea here is to summarize the
the count of cars that were licensed
right per model per state per year right
into a year to date comparison right so
we are on October I want to compare the
number from January to October this year
to January October last year right I
want to do this this comparison so what
I do maybe right in my first attempt is
to simply write a query that reads oh
the last license plate information
having my database right then I'll maybe
I'll try to use here month right to get
the current year the current month then
I'm going to create a variable to move
to get the reference here which is the
last year right up to the current month
and then I might try to use string like
that right so from from the result of
this query let me try to move it to the
top okay
from the result of this query I'm going
to create a stream you know I'm going to
apply a filter to see whether this this
this car was licensed got its license
number from the reference year and month
onwards right and then I'm going to
group it by year so that I have last
year and period here they're not going
to group it by state by model right and
call the collectors counting and I have
my shiny map with the information that I
need
now I wondered the do you think that
that's a good use of London which every
7ny
any gas anyone could you follow the
example that I gave do you think it's a
good example would you do that in your
code base what do you guys think
yeah it's getting everything from the
database you start with but that's what
people feel tempted to do because Java
developers you know general people don't
like even sequel that much right they
don't they don't even like JPA but that
much in JPL right so that's something
you should be aware of so that that's
right you you're Nagle did write the
factory have lamb this has nothing to do
with us not going through the database
right so just be careful because now
that we have a very way to do queries in
grouping in the language this doesn't
mean you should do that everywhere you
know and I guess that for some of you
you say yeah of course I know the
problem is does your colleague you know
you know that he's not supposed to do
that so maybe you did so it's very
important when you do so that's probably
my silliest point here maybe for some of
you but it's very important and you do
this kind of migration that you educate
your people you know so that as our
friend here contributed you don't get
don't read everything from the database
just because now I can use lambda Jeff
is very near on and I know Java way
better then jpq l or then then I know
SQL or whatever right so be very careful
with that because that happens in
practice right so lambda is not a
replacement for GP q l for SQL wherever
you all have to use on your systems does
it mean you shouldn't manipulate large
data sets with it that's also not such a
simple answer right so what are some
good scenarios are doing that maybe you
have to do lots of processing with the
same data set right in doing it and ran
with the the tools that we have in
lambda might be cool so that's actually
what happens in our case right so the
idea of reading is because you're not
doing
single kind of grouping we are doing
several of them and eventually we'll
touch almost fields and then even so we
do a projection you know we're selecting
you in GP QL and then we do the several
types of grouping you know and ran
because then it makes sense you see but
or if you have complex business logic
for which you have coded method already
right it might be very tricky then to
write it again in the query language or
if for some reason the elements are
naturally available in red so that was
the very last part is the general
principle for the use case of lambda
right so if you have the elements here
and of course it's a good idea to
summarize to do everything you need to
do with it
in red is that okay did you guys have
any questions about that that was the
silliest message but it's really
important and I've seen this being done
already you know and I wanted to give
that warning she start does anyone have
any questions up to this point no we're
good okay now I'm going to discuss
something very polemical given this talk
in Brazil before and that's a very plain
complaint parallel string right or or
confuse civilities so let's assume let's
go back to our code let's assume for a
moment right that doing this was a good
idea okay it fitted one of the use cases
that I had before so by now you guys
also know that turning this into code
that uses parallel stream it's just that
now everything's going to execute in
parallel right and you might or not get
better performance but let's assume for
it let's assume that you would write but
when should you make this switch do you
think it's a good idea to use parallel
string with Java EE applications in
general why because it hogs all the CPUs
that's a very good reason but it's just
one but it's a very good reason
what else do you have any good reasons
for maybe not using parallel stream
only on your application I mean Java II
remember talking about Java EE 7 so
there are reasons connected to it with
being a Java EE application that make it
not such a great idea
No okay so the thing is the whole
mechanisms that we have in the container
for a German injection they or even to
tying jazz to the security context of
the call and everything else that is in
the container it's built on top of class
loaders and threads right and what
happens when you do this right so let's
check what happens when you do this
right so if you call parallel string
right and of course in a future version
of Java Jesus Jennifer I eat a potato 6
which was the most current that listened
to a couple of days ago I'm not sure if
they released one during the conference
anyway but uh so you check on your own
right it's going to create a stream on
top of string support then it's going to
create a reference pipeline here right
and just to make things simple let's
analyze just for each and not that very
complex operation that I did because the
principle applies everywhere ok so how
how is for each implemented if we are
talking about the parallel stream right
it's going to call super foreach that's
of course is two different
implementation then it's going to create
for a job ref so for everything you have
a class and let me see if I didn't
yeah then eventually it's going to call
evaluate parallel right for reach it's
going to create this this 4-h task here
I'm just yeah and when it didn't folks
it it's going to do this that we're
seeing here see so it's basically going
to
use for execution the fork joint pool
right lots of you are are aware of that
right so that's how that's how the the
the invocation here is going to to
proceed right let me find the exact
point that I that I wanted here yeah
that's going it's going to go to the to
the comm fork/join pool right and as our
friend here in the front row said we are
talking about a single pool for the
whole application which means that now
you have no control over priority
between different business operations
right so that very important thing that
you are doing maybe which is the core
mission of your application it might not
get enough time to execute on the server
because there is something else of less
importance running but that takes a lot
of items and processing power so it's
going to hijack the pool to itself so
it's not even just a mem it's not even
just the fact there is going to consumes
lots of CPU because maybe it was
something you wanted but the problem is
that something else might hijack the
pool and the pool might not even be
available for you to run what's really
important in your application and how
can you control that basically you can't
if you if you read with a little bit
more of attention to code here however
you saw that if you started with if the
current thread is a for join worker
thread then it's going to use its own
pool right for this thread that's not
the common pool so maybe you have
attempted and I did that in 2013 when I
started doing my my testing for this
when lambda was assuming developed maybe
you've attempted then to execute your
code in a fork joint working thread
right because then you have control over
the poles but even if you do so again
is basically built on top all the
segmentation you know and all the
injection everything is built on top of
threads and class loaders and
application servers don't really support
for joining pull or work it thread right
so how do you think there are requests
scoped CGI dependency is going to work
if you send the call through the pool or
if you call nhe be here by means are
echoed you know or even if it's safe
today now if people change the
implementation of any of the methods
that you used in the lambda to know
which I now call a new injector
component or two to invoke an 8gb or so
forth it's going to break miserably in
your face right and if you guys are
disappointed I'm more because in 2014
and if you looked at in the lambda
mailing list I was having the discussion
this discussion with Brian and what he
said is that this API is not suited for
that so you can look in the mailing
lists when Brian get says that it's not
suited for Java EE yet let's see if a
Chava e8 they are able to get this fixed
you know but basically unless you were
doing the kind of thing that you see
being shown in most examples which is I
have like a collection that I only
process using pojo methods you know then
it might be might be a good use but only
if you have one case because if you have
several again there is no way to balance
it so that the real important one gets
the priority you know to execute instead
of the others you know and then maybe
for that use case if you create your own
fork/join worker thread with its pool
maybe you can balance somewhere at some
point but then you see we are really
trying to bend it you know they're
really trying to put the square into a
round hole that's what we're trying to
do here so actually unfortunately my
advice to you is that don't really use
promo spring with javi
right because it's not going to work
properly there is no process isolation
there is no pull configuration you can
make you you might get all your CPUs
taken as our friend said here injection
is going to fail miserably at some point
if it doesn't today tomorrow somebody is
going to change the goat somewhere
through through the calls that are made
on your part of the code and inject
something in it to break I need to fail
miserably right so what options do we
have well we can see your string right
the screen is still pools and and I I
can tell from experience that it we
really really really improve the quality
of your code but if you need to do
something parallel I saw that most of
you don't know concave utility so you
still gotta learn that you know because
that that's not by means of parallel
streams that you're going to do that so
you'll have to inject either manages the
cuter service from Felicity luyties or a
managed thread factory to create your
own executor pools but then you don't
have to go back to the old fashioned way
of creating tasks and submitting it to
the pool you know so you lose most of
the coolness that you have of streams in
Java CH but that's life maybe you wanna
write a different implementation of that
you know for Java because there is
nothing that's interesting there is
nothing in the Java doc that says this
is a frog joint pool you know that's an
implementation detail so if you want to
hack the JDK let me know when you do it
because it's going to be useful for me
to you know but at this point this is
not really going to to be helpful in
your Java EE 7 applications because of
all those things that I talked about if
you still think that maybe it's just you
and another developer you know what
you're doing you're just using it in one
point you're you're sure that you're not
injecting anything or you ever will do
it is at your own risk
no but I tell you so when it goes around
does anyone has any question about that
because that's really something polemic
all right you have been hearing about
parallel string for the whole conference
and say yeah
you sorry this is I said that's
real-world Todman that's how it works
please how does it break this injection
because everything is again plus loader
brace thread based so when you call
parallel string you were sending your
code to be executed on a different
thread so how does how does for instance
weld implements support for a request
scoped right
it basically binds the object to the
current thread right that's that's how
it it does it right so now if we're is a
Keating a new thread and it's going to
recover that instance is going to look
and say ok different different instance
I need to create a new instance of this
request the Scopes injection so even as
you are running because you are
switching between many threads you not
only you're going to to not be talking
about the same object you're not
referencing the same object that you
were referencing outside the lambda code
but it will create several instances for
every thread in the pool and next time
you execute it to make matters worse
it's going to reuse them now because
it's bound to the Fred there see how it
breaks now if it does that because if
you use haven't tested it right but in
the previous versions of WebSphere this
thing was also very much tightly closed
bound with threads and colossal rich to
the point that you'd get an exception in
the first attempt it would make to use
it because it was going to say which
threads is that what do you want me to
inject here crazy no I didn't create
this thread that's basically what the
applications ever did in the case of a
wild fly or if you probably at least
when I I was doing that with Tomcat
trying to do the Tommie experiment it
will not complain but then you'll be
surprised to see that because probably
since it's a crisis copter it's a like
love it it's not like you're going to
get maybe no pointer you're going to get
a different result than you expect
because now it's a new instance it's not
the one that you start your process with
you know so that's
it might be hard to track especially
when at first you don't have any
injections and then you simply you know
let's refactor this and move to a
different dependency you know we're now
injected here you know so the alter
method conceded should be the same but I
injected instance which is a quest scope
it's going to be a new one when it is a
kids there so that's what your problem
is see is it clear for you now okay this
is the problem of the CDI
implementational the CDI assumes that
you're not supposed joffrey rule number
one don't create threads rule number two
read number one you know that's that's
how it works so you create the threads
you cannot complain of what happens you
know the the container is it's prepared
to deal with the fact that you're making
a a sinkhole or that you are now calling
something by means of a managed thread
from from curacy utilities because these
are the bill doing the butene ways of
creating threads in java you know the
container has to manage it so it can
provide security in the other services
you know and all all the context
interceptors and so forth so it's not
broken
that's how it suspect you know and this
I mean parallel streams not broken
it was just brian says that in the main
list when I was arguing with him he says
that's not the user case it was aspect 4
so that's a problem both technologies
you know they were designed with a
different poll Java EE was design of the
go that you don't create threads on your
own I do you know and this solution was
made thinking I will execute or whatever
I'll know in whatever way I feel like it
with threads you know so that's why you
cannot really combine them so that's
that's a problem you see so say they are
is simply doing something according to
judge a very spec you cannot say it's an
implementation problem you see maybe in
Java EE 8 which is supposed to be a line
which are AC 8 then you can say it's a
problem you know but for the crew
expects
actually it's following this fact pretty
strictly and that's what you expect
really when it creates a different a
different threat for a quest scoped
injection point you should have a new
instance that's there in the spec that's
correct
it's just that known our minds it
doesn't make sense but it's correct
that's the saddest part you know it's
good and it's about it's good when you
can blame it on them morally this time
sorry does it make sense for you I said
as sad as it is but does it make sense
it shouldn't be the way it is yeah
so that makes two of us okay but that's
the way it is and it's correct sorry
right I can complain you know cuz I
complained too bright when it was time
two years ago it was it hasn't been
released yet but you know not that
there's none of you were doing the list
help me support me there you know to in
this matter so we lost sorry you see
that's why you should be supporting
openjdk in standards so that I don't
have to give this talk now but then I
wouldn't be here anyway go back going
back to the talk does anyone has more
questions about this because I think
that that's the most important point of
my talk and it's a little bit
disappointing you know in a on the other
hand I want to make sure that really got
the message of why this is for 99.9% of
you that's not a good idea
now you gotta use concurrency until
ities but that's a construct that you've
had you know for quite a long time now
that I could see the lots of people see
we're not aware of and it will continue
to work but that's you know the the
oldest acuter service just robbed by the
container so that it knows how to inject
the dependencies and do things properly
that's the way you do it but then
there's no string there you know there's
no not a shiny and cool thing that we're
playing with here you know but that's
the only way out at the moment at least
any more questions yes please there's a
spring has been probably probably this
you know even even if it doesn't when
never use use anything and there are
lots of things there thread bound for
instance let's say that you're doing
that of spring when you use the static
methods like in phases context if you're
using JSF to get the current instance of
face context it's going to throw a new
pointer on you because that's a
different thread I don't know which
faces context you're talking about it's
simply to break maybe it's not going to
break as bad as this but it's going to
break in several cases too and again a
coordinate respect that's the sad part
you know several parts of java ee take
us you can make this assumption because
that's how java is built you know so
it's not just injection per se there are
lots of static methods and lots of other
tricks there but you do in the libraries
because they know that you cannot create
your own thread
so whenever so much not only for
parallel screen rate when whenever any
of you guys is creating threads on your
application you you were asking for
trouble you know that's going to happen
to you at some point if you simply
create it naively you know without using
a thread factor i managed to read
factory and and so forth you know it's
going to break so
you should wrap the parallel I'm not
sure I follow your suggestion so sure
please yeah I'm not that bill great no
no in this again in this example I'm
using everything from from REM so as
it's running now this is going to work
what I just like I said but you don't
know what this method does resistance
right which is a method that I used to
filter right the year and so let's say
that for any reason I do any injection
here at some other point you know or I'm
using any injected instances some other
points you know and my unit tests are
going to pass only my integration tests
are going to fail later on and I have no
clue that I just broke something else
that also using parallel string and
maybe depending on the quality of the
test the test will pass but later on you
figure out that's wrong you know because
it usually doesn't produce an
opportunity exceptions it just switches
the instances we're talking about so
that's really see yeah I'd be thinking
about it for two years it's hard it's
hard you you know you can hack it I've
hacked it just for fun but not for
production use you don't want you don't
want your company's product to be built
you know this way with terms of hacks
with tons of hacks you can make it right
here I I did it but I don't recommend
anyone do I I didn't do that in my real
protection code in my company you see I
just saw how can I work around it and
they pull tons of tricks I solved the
faces context problem in a different way
by doing some phrasing injection around
in any way but you should not do that
really I didn't like the recommend
that's right again okay
Perla string only with drums productions
available it might it yeah it might not
reach the parallel on some case why this
when okay okay why does it switch the
problem this content if it's bad because
this was not built this way this is not
built thinking that interaction between
Java C and Java EE that's why you know I
again you are using something you
shouldn't use the word we're not
designed to work together by design both
of them so that's why it's going to do
something it's going to break because as
I said there are still like one good use
case you can have you know which is I
have only one place which is the most
important place in my application for
reach I know for sure I'll never do
injection not of those things you know
I'm just working with poachers and I
want that part to really take advantage
of parallel stream and to be concise in
history read if you happen to be in that
place I'm not you know then for this
single instance symmetry is prevalent so
it still has its use its just niche for
Jerry this any more questions
how does the icing work that's
implementation detail but basically
because it's because the container now
knows that you are creating your turn to
do something at synchronous then then
it's a but you figure out that it's
going through a new tread and it's able
to wrap everything so it works no here
you are doing it in a way that the
container has no control the container
has no control over parallel stream so
it cannot possibly work that's that's
the difference any more questions oh
yeah so yeah guys I'm sad it's been two
years I'm set sorry it's it's shallow
for me to hear I could just hear a
synchronous
as you could hear yeah but I guess you
were asking if there are any other plans
to create some annotation to replace
that a little fix that not only
annotation level yes you know we have
some smart tricks you know not only how
this is implemented in knowing how
containers application servers are
implemented it's possible to maybe pull
the trick by by changing the way that
the fork the fork joint pool is
implemented on the container it's setup
you know so the application server
vendors will probably do that for Java
EE 8 but that's going to be tricky
that's why they're talking to right it's
not easy but it's it's possible to to
fix if you have also accepted the whole
code base of your application server
it's going to be an application server
specific solution so each one of them
will have to have their own Puma
fracturing pool implementation for that
to work and I still wonder how they're
going to segregate you know the
different types of business cases so
that you don't have the pool hijacking
you know that oh hijacking part is hard
as yourself even then the injection part
and the other things that I talked about
more questions know so really
differencing in time so let me so sorry
for the bad news ok again but don't you
the messenger you know don't don't click
read when you go out just because I told
the truth ok yeah so let's talk pop
quickly because I also I also saw that
other two other talks discuss that how
can you use Java time with the existing
Java EE technologies that we have one
good part now is that even though with
Java e7 basically there's also port for
them their hooks basically in every
technology in Java EE that allows you to
implement support for it right so if we
start simply with JP a just as an
example right so it's been a while that
JP a has added attributes converted
right so the attribute converter allows
you to map your own custom types to
to the the types that would be returned
by JDBC and to use them directly right
so you can simply phrase this if you
want to have a local date/time instead
of a timestamp you know Seco timestamp
you simply write a converter you
implement the interface right so the
left side is the type you want the right
side is the the type that JDBC would
return to you right you do converter of
apply true so you don't have to use the
converter everywhere explicitly right
and then you just overwrite the two
methods convert to database column
convert your entity attributes right and
then depending that's that's something
funny if you are using if we're using
like well the version of whitefeather
i'm i'm using this works you know that
you simply call the method and convert
so that's that's why it's important that
you guys do your testing because start
with hibernate for three laughs and
something you know as which was not in
wildfly true but it's on the next
version then this code will break with a
loop no pointer exception before if the
timestamp was no it was simple assume
that the converted object is no you know
now they changed hibernate so that it
will invoke your method when it's no
actually the spec doesn't say if it
doesn't say I guess it was correct all
the time to evoke Cornell's
right because it doesn't say if it's now
it's not going to be invoked to you you
should expect it to be invoked but
before this would work you know it with
the latest world five version this
doesn't work you have to check that's
why again it's important that you see
where your step you know so how does an
attribute converter works on this on my
application server in this particular
version right a test then your code
won't break but see it's very simple
right just two lines of code now you can
use local this time anywhere that you
have a time stamp in the database you
could do that for the other types there
are some open source projects there is a
deuterium and there is last time I
checked there were two other and github
in there like 15m sirs and stack
overflow already on how to do that but
it's very simple you know do that for
the type that you want to use hibernate
five I don't know
about the clips link but in hibernate 5
they already support this
you know so if you use if you want now
to try about fly 9 this will work for
you out of the box you know so they did
the support on their own but that's not
part of the spec you might need to write
it there are other types that at least
in my company they are very common which
are not supported even by hybrid 5 like
here month you know we do lots of things
based just on ear month and also you
want to map it to qu an int in the
database you to make it efficient you
know and then do some math as we convert
because it indexes nicely if you put ear
mouth later you know so you might you
might still need to do that for the very
specific types that you you need even in
the future I'm I'm pretty sure that when
Java e8 comes out they might not be
supported the way you want you know so
it's nice that you do you know the
string so let's just quickly show
another example so okay what about JSF
again you have four years now you have a
faces converter right so you you
annotate it will face converter you
declare the target class you want to
convert you implement converter and then
you see how you're going to convert it
right so in this very naive example I
use the date pattern that is used
everywhere else but in the USA and sorry
foreign joke we cannot I could not hold
myself
sorry and then you just convert that
everything is one-liner you know the
real the real question is which type you
want to support and how how you want
encoded in your application you know for
several reasons we want different types
should be coded in different ways right
and for some technologists as hibernatin
orders that say that you're doing jax-rs
with jackson you know it's a common
choice so sometimes you have already
support for it
in the framework so for jax-rs you could
also you have a standard API for to
conversion or if we're using jackson if
that's an option for you and you want to
go straight to the implementation you
can simply for instance
with Jackson implement provider for
context resolver in register the job the
Java time module that was written by
them which is an extension and voila
everything works you know of jax-rs so
just look carefully in the if you can
bind yourself to the to the
implementation may be the implementation
now has support for general time if not
it's very cool every technology now in
java year at least every one I can think
of that I needed they have a wage for
you to write your own converters they
are all one-liners you know it's very
easy to write very easy to test and you
just need to do that right and it will
work in your project now now we can use
it in your JSF components you can
persist a database you can eliminate
Java util date for on your code base yay
that's easy any questions about this No
okay so you see sometimes it bring good
news so sometimes things are easy in the
to work not everything's that broken
right very quickly about parameter
retention this we're kind of running out
of time
about parameter retention in multiple
annotations let me just show one example
then to save some time the only thing is
that we you don't have support in the
API but in wider we are talking about
interceptors whether we are talking
about events from from the CGI container
all of them are going to give you access
to the method right and from from the
method so when you have like a CDI event
you have an annotated member which is
the type then you you have a get Java
member if you cast it's going to be the
methyl then you just need to call get
parameters right from the parameter now
from this new method you have the name
to do whatever you want so if you want
to have that famous in famous not
logging interceptor now you have the
parameters name too
nice logging right and there is
something that it might be important for
you depending on what you're doing
especially if it's trying to do magic of
injection which is calling this is
implicit right why is this method
important because one thing I'm not sure
all of you are aware is that parameters
name parameter names are not available
by default right you have to go to your
palm and you have to do this you have to
add this compiler argument
- parameters then it's going to preserve
the parameters name why did they do that
because it significantly increases the
size of your classes not for further for
most of us they'll say okay don't care
all right but for some people it was
important so - in order to retain
compatibility not to increase jar size
you know by at um it will not preserve
parameters named by default but this
should be the new default if you're
writing Java SE e8 code you know or is
that this option so that if someone
somewhere else wants to have access to
the parameter names of your API so they
can okay so always do that they know
only time you're able to to to read it
but then to make sure that in that
particular library the names that you
are getting and the real names because
otherwise it's going to fall back to our
X 0 argh argh 1 you know the car is not
going this always works
you know parameter get name always works
but then it simply produces generated
names you know argh zero arg1 arg2 which
are pretty useless you see so if you
want to something meaningful you have to
check with is implicit and the new best
practice is to always have that switch
on you know because you never know what
kind of cool things people are going to
do if your AP ice so you want to
preserve the parameter names for that ok
any questions here I had more examples
but I don't really have more time to
show
yeah I I have yeah I have to do it with
compiler arts and to arts because I
always do excellent our to give all the
warnings except for zero which I'm not
really interested in Java so it's really
aligned 53 there is important another
one I stepped on right so you have to
use that switch when compiling to
preserve the names okay otherwise you're
going to call the API and just cr0 arg1
arg2 so that's kind of worried okay any
any questions no okay so for most
politicians that are some cool uses you
you can do the only advice I'd like to
give very quickly is that while you're
processing annotations maybe with CGI
and all it's not it's not going to be
smart at this point depending on what
you're doing with your annotations your
you have to get the wrapper annotation
you know because when you have most
politicians you have the regular
annotation that's how you do it to Java
8 and you have like a wrapper container
annotation whose type is an array of the
other annotation and that's how the
compiler will wrap it you know the
multiple currencies but the IP the API
knows how to unwrap them you know but
not here not in Java EE 7 so then you
have to deal with both you have to deal
with the simple annotation and the
wrapper annotation that's the advice I'd
like to give you guys since we don't
have time to go through the the examples
if you didn't get it you check how how
much politicians work with Java CA to
you understand right so there is the
simple annotation there is the container
annotation so with Java EE 7 since it
some are aligned you have to treat both
okay the city I made metadata is not
going to be that smart to be but you
should say no just give the unwraps a
notational times you know whichever
years they're going to fix that okay but
it works it works fine it just gives you
a little bit more
right then you can pull your trick
tilton and static and interfaces this is
something I wanted to leave more time to
discuss because it's very useful but
there's nothing very particularly useful
in Java EE per se you know it's used
when design and the design guidelines
are the same so this is this is probably
the the part that is least Java EE is
specific of my talk right so I'm going
to leave it here these are basically the
good use cases that you have for these
new features right so default when
should you use it in your Java EE
application do you have an existing
interface for which you have other
clients api's on your organization you
know not overcome you're not in control
of all the implementations so that's a
good way of using it you know you create
the default method in the in the
interface you're involving so that the
old code doesn't break so that's the
same principle they apply in the JDK you
can apply in your codebase now but see
when you have to do that and you have no
control over the other implementations
otherwise that's not a good argument
enough it's better maybe switch unless
the others apply you know like if you
have behavior that is possible to
implement without state right just by
means of calling other methods right so
that you give a simple JDK example naive
though you can do a removal on top of
palling the interrater and removing one
by one for instance right so that's a
good example of a method that you can
implement without having access to this
state in the interface you can write the
algorithm with the other methods you
have in the interface so that's a good
case because probably if you can do that
efficiently which is better you know or
if there is only one canonical way of
doing it it's better that you do that
now with a digital method also this
allows you to have a flexible class
hierarchy right so sometimes it might be
a compelling reason to do so because
most for inheritance you know we are at
Java 8 it's not going to happen right
some people still ask sometimes in talks
I find it funny so this whenever you can
go
with interfaces it's better sometimes
you have to resort to abstract classes
because that was the only way now we
have the option of having different
methods and interfaces this will allow a
more flexible as hired he but you have
to watch out that might get you into
trouble you know so use it sparingly for
this reason use it sparingly and also
that's how you enable em the right Stube
to have a functional interface for which
you can write the lambda instead of
implementing in your class you can only
have one one abstract method on your
interface which means that all the other
ones have to be default methods right so
if you want if you have that interface
that you want to be used with lambda and
there is really one method that people
will usually need to override the other
ones probably they can do away with the
default implementation then you you use
default in the other methods and now
it's a functional interface it's always
good to annotate the the interface with
the annotation though even though it's
not required an aesthetic
I would say it's mainly for factories
right so basically if you have a factory
method that reproduce the instances of
your of your interface then you should
have a static method there one thing
though that sometimes make this the user
shift is a little bit should cluttered
is because so you you remember we are
talking about an interface so you cannot
really reuse code right because you have
no private methods but they are solving
that for Java 9 so you have private
methods it will be possible to refactor
the implementation of your different
methods and keep it clean nowadays
probably as you go past one method you
see the leads of creating a package
level implementation right that you just
keep to keep code clean and all the
methods in the interface are going to
call those helper methods in that
package private class so that you don't
have to repeat yourself in the interface
code but with Java 9 they are adding
private methods that's going to be to
make that even cooler and nicer to
implement ok do you have any questions
here do you want
mother advice or when you use it or not
what happens with a class that ok that
implements interfaces with the with
different default methods if I'm not
mistaken because it's been a while that
I don't have that problem I don't
remember if I had this problem after
Java c8 went final I did it during my
tests it failed
don't know if it fails anymore but it's
not the kind of thing that you want to
know so don't do that that's that's my
advice but I I don't really remember if
the final answer for Java CH final you
know I remember that at some point it
would fail to compile sorry fail compile
I think it's still this but last time I
encountered this it was before they
final release so I cannot say for sure
but I guess our friends are right any
other questions are on when you use it
this is really cool this is really
useful you know but that's more of a
architectural advice out have to give to
you guys any order
no ok so the summary here is that there
are lots of stuff here some of the stuff
we considered they are going to bring
immediate value for us already you know
even if you are using Java 7 so lambda
is and streams they're going to be
useful just teach people to use it
properly you know we still have to use
typical you know don't don't bring
everything into memory different let's
take static methods and interfaces they
are really great you know it's something
you want to try you see how it's going
to to make your life easier as an app
that as an engineer other things will
require some effort like using Java time
but it will work you know very easily or
parameter retention or multiple
annotations you know it's it just
requires it that you know that oh yeah I
have to do something extra here but
they're probably worth the price others
better not like parallel string sorts
disappoint you again today but that's
the I guess that's the main take over
from the
the stock you know and be sure the Java
e8 will improve things I have to thank
some of my co-workers you know a Texan
opsi that helped me through this journey
of migrating and testing we have been
doing this since 2013
now end of 2012 actually you know we did
testing while they were writing them
than in the test of the code and they
haven't just summarized the journey here
and I'd like to thank you all that's my
email that's my Twitter handle yes we
it's it's it does contain two
underscores it's odd I know but that's
how it is and actually I'd like to take
my company for it personally my my my
trip here but that's my last time with
them
actually so if you want to coach you to
hire someone who knows how to do this
I'm available that's it guys
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>