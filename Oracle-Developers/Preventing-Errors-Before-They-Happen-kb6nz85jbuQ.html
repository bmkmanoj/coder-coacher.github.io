<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Preventing Errors Before They Happen | Coder Coacher - Coaching Coders</title><meta content="Preventing Errors Before They Happen - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Preventing Errors Before They Happen</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/kb6nz85jbuQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning everyone and welcome to my
tutorials tutorial the doll is
officially closed so I guess it's time
for me to start the point of this
tutorial is to introduce you to a tool
that will help you to prevent runtime
errors at compile time it's a tutorial
so we'll show you some code that you can
follow along it's not the workshop so I
don't expect you to follow along on your
computers but it should be introductory
enough that you understand all the steps
that I've descent and if you have any
questions about the slides that i'm
using about the code that i'm presenting
please just place a hand and it's
getting dark and dark there's a wave
that i see you a shout and i'll try to
answer your questions ok so what am i
going to talk about barks barks I know
software bugs used to be these tiny
little wheel bugs that prevented some
relates to switch nowadays if you have a
park in your software and its mission
critical software you have a market that
explodes so bugs getting more and more
important and the cost of software
failure is astronomical so the last
number that i found was that the global
impact of software defects is three
hundred dollar bill 300 billion dollars
so it's a huge impact that the software
industry has on the economy there are
always these few high-profile cases
where you hear that yet another rocket
exploded or yet another NASA mission
failed and that's not because NASA does
pets after development they are one of
the most vigorous of the developers and
still bugs happen on a more serious note
software is also more and more in life
scattering of life supporting situations
what's even more important that we
support or create correct software so
here a few famous incidents where a jet
crashed into a mountain because of a
beta misfunction very famous are the
Terek 25 incidents where software was
moved from one version of the hardware
to a different version of the hardware
and wasn't adapted correctly which costs
by the Asian burns and deaths for a few
4,000 people and in 2003 there was a
famous power outage that was caused by a
variety of levy different functions
impart also the control software for the
northeast power grid and very
interesting is also that a quarter of
all the medical device recalls nowadays
caused directly only by software
mistakes so it's a huge economic impact
that software connectedness has on our
societies and more and more life's
depend on it now obviously I don't want
to sell you snake oil I will just be
sent one tiny tool that can help you in
ensuring correctness of your software
obviously there is no silver bullet we
cannot cure that nobody in research can
but we have one tool that we hope helps
you in ensuring correctness of your
software so i will present this idea of
pluggable type checking which is a type
system that allows you to improve the
quality of your java code i'll jump into
with a quick demo and then give you an
architecture with you highlighting the
java 8 language features that support
this tool and then talk about the
different features of the checker
framework i will shortly go through how
you can write your own type system using
this tool so it's a framework so it
allows you to express your own
properties succinctly and one of the
most popular checkers is the knowledge
checker which is allows you to ensure
that your software doesn't contain now
pointer exceptions and in the end that
talk a little bit about the experience
with the tool and what we are using it
for any questions about the setup for
the tutorial everyone in the white
tutorial not in the wrong room okay then
let's go so first what is pluggable type
checking what is this technique that i
want to use so chavez type system is
very nice compared to other languages we
are guaranteed that we'd never get a
message not understood mistake and
genetics improve that even further and
in many situations we are guaranteed
that they don't get a classcastexception
so if you have an integer variable I and
you try to assign a string to it you get
at compile time and era but the type
system is not strong enough and by
design not strong enough because there
are many many different people that have
many many different properties that they
want to enforce for their software so
here three examples and let's do this
interactively so we have the system that
cancelled that we'd line in one of our
applications we run all the test cases
we never have a problem we deploy the
application to a client and the client
come back and has I have the stack trace
does anyone know what might have gone
wrong what might be the difference in
the setup could you speak up I heard
some yeah exactly so at the client setup
you ban it from the GUI and there is no
console attached so in all your test
cases you vent it from the comment line
system that council we turn the console
and all the test cases work perfectly
you deploy it to the client and at the
client you started it from the GUI and
system that console is now and they're
the client gets a nullpointerexception
and that's one of the property is one of
the biggest properties that cannot be
expressed in the Java type system is
whether reference is now always always
guaranteed to be attached to an object
the second example is collections that
empty lists that add some element now
hopefully nobody fights code like this
but it might generate a new empty list
pass it around in your application and
somewhere else you add an element to
that list does anyone know what might go
wrong with this
exactly so the empty list returns an
immutable object and as soon as you try
to modify that empty object you get an
unsupported operation exception so
immutability is another property of
objects that sometimes some objects are
modifiable and it's expected that you
can add an object an element to that
list but the empty list is a special
object that's always the same and you
cannot add an element to it so that's
the second property that you cannot
express in the Java type system and the
third one is a database application I
have my database statement and try to
execute a query any queries some input
string that I got from the user what's
the problem with this yeah coding check
from sequel injection attacks so I have
a user data string and now the user can
probably do whatever they want they have
the little Bobby tables that modifies
the database so it's another property
that you don't have any information
where certain information came from so
you want to know this string was
validated and I'm sure that it doesn't
contain any sequel attacks or this
information came from the user and I
still need to validate it so all three
have different properties the first to
at least give you an exception and at
least it stops the application at one
time the third one is even more severe
because it might just modify your
database and it takes forever until you
notice the problem so one of the biggest
examples is null pointer exceptions
languages like Java have this idea of
references either being attached to a
real object or being that special value
null now in this simple example we have
a method up that takes some input data
and produces a string representation and
we just transform the input by getting
some calling semester than the input and
returning that as the result and now we
just want to use that method somewhere
to get a string but we pass in now so
where's the other in this code
so the problem is you can't really say
so without specification who says that
the javadocs of this method might say
don't call me but now so and at the
moment there is no enforceable way to
guarantee that your method is called
correctly so you might have Javadoc that
says okay this method always expects a
real object and then this color is the
problem so you should not call this
method with no on the other hand the
specification might say that I am
expecting now so it might might be
specified as accepting an arbitrary
value and then this implementation is
one you shouldn't call get F without
verifying that the object is real so
they are basically two solutions either
you document that this parameter is not
know then the implementation is correct
and you don't want to add additional
checks just to defend against misuse and
if you have a tool like the cheka
framework that I will talk about we use
these additional annotations to document
these assumptions and then we have a
static tool that helps you to enforce
the correctness of these annotations so
it both gives you the documentation
benefit and also the static checking to
ensure correctness so if we say that the
parameter is none now this compiler tool
can tell us that this invocation is
wrong we verified that the
implementation of the method is correct
but the color is to blame so it also
helps us assign blame in who who needs
to change their code the second
alternative is that the implementation
needs to be more general the parameter
might be a nullable parameter and its
really an implementation mistake that
you called get f without verifying that
the parameter is really none not and
then the compiler won't complain about
this call about using now so it depends
on what the specification is what the
expected behavior for your application
is to decide where to assign blame and
who to change whether to change the
implementation of
your method or whether to change the
color of your method so there are many
benefits of type systems that are
highlighting here the biggest one for me
is finding bugs in your software so how
to determine that the software really
implements the specification that you
want now less is a very simple
specification but tony hoare the
inventor of now called it this
billion-dollar mistake so it's one of
the mistakes nettings after like java
and c and all the other object oriented
languages is very easy to make because
no programming language provides nice
support for it and what's nice about
type systems is that they also guarantee
the absence of errors so it's not
heuristic back finding tools that give
you some idea that there might be bugs
but it's really a static analysis tool
that gives a guarantee about correctness
so it gives you a guarantee if I say
there is a there is no other I'm
absolutely sure that there is no error
it doesn't give you the reverse idea if
it gives you an error that might not be
an error but that's always the problem
with static analysis tools the second
benefit which is equally important is
the improved documentation if you try to
use a static analysis tool and use these
annotations to document the behavior of
your application in a machine checked
way you have a much better documentation
you can see it in the in the IDE when
you look at the signature you see that
it's a nominal parameter and the video
of an API can much more succinctly see
what it means it doesn't have to read
through a dozen different formulations
to say that this parameter is none now
there's one standardized way and
everyone uses one annotation for this
another benefit is that you improve the
design of yourself when you go to a
static analysis tool you have to make
the software in a way that is
understandable for the tool now these
tools are all very powerful and provide
many analyses but at some point your
code might be too convoluted
and the property why no less holds or
why some tainting property holds might
be too complicated to express statically
in a type system and then if you
reformulate this off the refactor
yourself in a way to make it statically
analyzable you also get nicer software
so documentation and improved code
structure are to benefit the less
benefits might be for a compiler so if
you have the additional property that
some reference is numb now you might
remove nominal checks in the virtual
machine depending on what property you
have you might have additional
optimizations that you can perform if
you know that is that some static
property always hoped so these are the
three different kinds of benefits that
you might get out of using a type system
the possible negatives of the checker
framework end of any other static
analysis tool is that you have to add
some documentation for the tool so in
our philosophy it's a good thing to add
this documentation because it makes
explicit what you expect that the
software does we try to minimize the
specification by using defaulting by
using advanced techniques to infer these
annotations but at the end of it the day
some annotations in your code might be
what might be necessary but we're
working our people everyone is working
on techniques to minimize this
annotation the second disadvantage is
false positive static approximations
might not be correct and you might get
errors in from the static analysis tool
that don't really happen at one time so
there's a mismatch between the
conservative assumptions that we make in
the tool and what might happen at one
time so you might have false positives
as I said before maybe if you structure
your software a little bit differently
you get easier to analyze software
removing these false positives the
second approach is you have some
additional verification approach where
you make absolutely sure that this is a
false positive you added a test case you
made sure that this doesn't happen at
one time
then you suppress the warming so these
are the two ways that you can attack
false positives cool so over the years
there have been many many different type
systems I don't know is anyone from the
research community here that might have
written their own type system so these
are a few type system that I and my
collaborators worked on that try to
express many different properties in the
source code so it's null pointer
exceptions is one of the biggest
examples we worked in a type system for
energy consumption to ensure that you
have a minimal energy consumption for
mobile devices unwanted side effects is
another very important property where
you have the empty list that is not
modifiable and you want to be able to
express properties like that so you want
to be able to say this is a list but I
cannot modify this list so you have side
effects and you want to document these
side effects this lecture of the heap is
another property that many researchers
have looked into at the moment in Java
the heap is one big tangle graph where
every object can reference every other
object this makes Java and heaps how to
verify because you never have a static
int who can modify whom and type systems
that help you express static
abstractions of your heap giving you
beneficial properties for verification
the few other properties and mouth and
input validation you I actions and
information leakage in Android
applications for example so they're all
these different research papers the
problem with all of them is that it took
very long or takes very long to get from
the theoretical results into practice is
anyone of you using a programming
language that uses known as type
annotations nobody so the first papers
were in the early 2000s and there have
been a few language prototypes that
support no less annotations
and it would be really nice if people
would use them to prevent these null
pointer exceptions but unfortunately it
takes very long until this mindset
spreading to Interactive's because it
usually means that you have to switch
programming languages you can't use Java
you have to switch to I think Dee has no
less annotations so if you perform the
switch to a different programming
language you would get the benefits but
it's a huge cost to switch programming
languages so that's what we're trying to
do with the check of framework so the
check if framework is a tool that
implements this idea of pluggable type
checking it wants you to continue to use
Java but uses annotations to express
these additional guarantees so it plugs
into the standard OpenJDK compiler the
comment line usage that i will use in my
demos just cause the standard jealousy
and then uses an annotation processor to
run a particular check on your software
we have an eclipse plugin that makes it
nicer to use we have amped and maven
integration so all the different build
tools that you might be using supported
by the tool for the demos comment line
is still the best approach I hope okay
so let's just see how this works the
demo that I want to show is some input
format validation so I want to make sure
that regular expressions are used
correctly and that we don't get one time
exceptions from them so let's switch to
the kilt for a second so the application
that i have is this very simple regular
expression program that has a main
method that make sure that we get two
arguments the first one is the regular
expression as string and the second one
is the content that we want to match
against so we have the regular
expression string and the content string
is the fun big enough for everyone yeah
good text so then we create a pattern
matcher by compiling the regular
expression string we match the pattern
again
the content that we received and then if
it matches we output the first group in
this string from the metra so let's see
what Java Sea does java sea is happy so
Java Sea compounds this application I
didn't have any type of in it and that's
just to Java beg X and let's do maybe
this and ABC boom we get an exception so
the first exception is that on this line
so we have to follow the few stack trace
we get all these methods net are not
from us the problem is on vaca X line 12
where we call pattern that compile so in
this pattern that compile we didn't make
sure that the input string that we got
from the user is a valid regular
expression so we just take whatever the
student at the user typed on the comment
line and pass it to the compile method
it's a string that's for sure and that's
the only thing that this standard Java
compiler cares about but then at one
time the pattern compile method make
sure that it's really a regular
expression and then here the other
message dangling metacharacter star so I
made a mistake in how how to use the
regular expression pattern okay let's
fix net what i wanted to type was a dot
store that should match now and now i
get an index out of bounds exception so
the second problem is tected traced is
much shorter so the second mistake is on
line 16 so in this line I access the
matter that group method so we compiled
the regular expression successfully now
we called the match against the content
the content matches but then we make the
mistake of accessing and the first mega
like smashing group but in the string in
the regular expression data passed in
there is no regular expression group
there is no match and again it's a not
checked statically because statically we
don't know how many parameters now might
be and the Java compiler simply says
okay there is an integer integer is the
right type for this method so these are
two one time exceptions and wouldn't it
be nice if we had a tool that helps you
to prevent these other statically and
that's exactly one of the check is that
we have is a regular expression check up
so what this tool does if I run this
against let me see I have that comment
line so the comment line for that is
that so we call our version of Java
sea's so if you download the Cheka
framework zip file from the website you
simply unzip it and you're good to go
you use this chava see replacement that
we provide in this archive and simply
call one of the processes that we have
so we have in the released zip file we
have a script called Java Sea for the
obvious reason that passes all the
classpath elements that we need for the
Cheka framework and after that it's a
standard Java compiler if you don't pass
any arguments it's behave it behaves
like the standard 1.8 compiler now what
we want to do is run out type champion
and as I said before a type checker is
simply an annotation processor so we
call the chalice e with dash processor
and pass in its probably actually harder
to meet or check your framework check
your bag ex back extractor so this is
the regular expression check that
ensures that the pattern not compile and
match that group are used correctly so
let's see what it has to say we get two
errors which is exactly the two
locations where the user made a mistake
so the first teller is an argument type
comfortable error in comfortable types
in the argument and the problem is that
in patterns of compile we passed this
regular expression string which is a
string but we expect the regular
expression string so we can't just pass
in an arbitrary string without making
sure that it's actually a regular
expression so that's the first time that
we kept the secondary that we get is
about this match at group method which
the group camped invalid ever it's
ensuring invalid group parameter 1 all
the civic groups are guaranteed to exist
so we statically have no idea how many
groups behind the string we just
compiled an arbitrary string we already
told you that the string might not be a
regular expression but let's assume it's
a regular expression I don't know how
many groups they are so and you're
trying to access the first group in that
string and that's an that's probably an
error so we get these two others out of
out of using the regular expression
checker so now how do we fix the agarose
does anyone have a idea but everyone on
the same page with the example okay we
can just try that
so let me import the regular expression
utilities and
don't get that one yet so let's say we
simply say it's a backache string and
you won't see what might happen if you
try this that's just
okay let's see whether that fixed it
so now we don't get the other at the
pattern that compile anymore now the
pattern that compiled this eve /
expression spring but we just moved the
problem around we assign the arguments 0
to this regular expression string and
there is no guarantee that this argument
0 is what we wanted so what we actually
need to do is verify input so to do this
there are multiple ways how you can
ensure that your swing is is a valid
regular expression spring one way that
we provide is to simply call a utility
methods and let me move this code up a
place somewhere around here so if the
vague legs Padma I need to do that here
somewhere so if the regular expression
swing is not a regular expression with
one capturing group we should output
some nice at a message and then we
return so we don't need this one anymore
and now let's see whether the compiler
is happy with the code and it's happy so
now what will happen if a pass invalid
input this test will fail and the pump
comment will hopefully I should add some
system out print line give you a nice at
a message and tell the user what went
wrong yes exactly so you're there
multiple ways how you can do it yes I
think we do so that we have a very good
control flow model and as long as we are
sure that you really don't reach that
point it should capture yes and because
in this test we pass the one so we say
only validate if it's a regular
expression that has one vac capturing
lip so that's the semantics for that
utility method any other questions
so what we achieve by doing this is that
we forced the user to validate the input
we don't wait until one time to fail and
give the address at the user stack trace
the force the user pointed them to all
the places but it didn't validate the
input and then the program is
responsible for doing the sensible thing
so do output a user message how to use
the tool correctly output that this is
Miss formed input and that you have to
pass valid regular expression so that's
the basic idea behind the Cheka
framework and there's not a single
annotation in this source code so one
nice thing about the checker framework
is that it provides a lot of defaulting
a lot of flow sensitive refinement of
these type annotations and actually what
this if test does it refines the type of
this regular expression variable so
initially it's declared without any
annotation but because we see this if
statement and if it's not the regular
expression we would quit the program so
at the point when we reach this patented
compile the type checker is sure that
the regular expression variable is a
regular expression string so the program
it didn't even have to write that
annotation tap down the tool is clever
enough to see from the capital flow that
this property holds and refines the type
accordingly so yeah what we did before
is add that annotation explicitly you
can do that if you want it for the
plantation but the tool performs a lot
of flow sensitive type refinement to
minimize the amount of annotations that
you need to write explicitly ok yes
so no so you could refactor your code
and say that you have you mean move this
this part of the code yeah hmm let's do
that so let's call this method to match
bag X and content and we have a private
static static void too much but what we
can do now is see that this is a regular
expression swing so now in the method
signature there is no flow sensitive
refinement because the method might get
called for multiple places so here we
now say this is the regular expression
parameter and the content is an
arbitrary string so now by documenting
that this is a regular expression spring
we made sure that we verified this
argument here so if it didn't make a
type for this should type check now I
need that qualify again
so now I only said that the parameter is
a regular expression I didn't say that
the parameters a regular expression with
one capturing group so luckily our
annotation takes an argument that gives
you the number of capturing groups so
here I say it's a regular expression and
it has to be a regular expression with
one capturing group let's see whether
that works now now there's no error and
if you forgot to do that validation so
if we remove this code again so if we
didn't verify that the regular
expression variable is like that we get
an error in the call so we call this to
match method and the first parameter is
said to be a regular expression with one
capturing group but you I will obviously
don't call it so you can still
compartmentalize these checks to one
place and then your document exactly
these these assumptions so in the do
match method we now assume that you get
a regular expression with 11 capturing
group good point yep oh yeah so dash a
ones so if you passed a she wants all
the others that we would generate the
warnings which is exactly for people
that want to use it on existing and
probe basis they want the warning
messages but don't want to abort i
bought the build okay any more questions
about the demo I've no clue what time it
is okay very good yeah yeah
and the same as Java it so it's a Java 8
compiler because we use this type
annotations feature which I'll talk
about in a little bit so it's a standard
Java it well it's a pretty standard Java
8 compiler the only thing that we do in
that script is basically add some things
to the class path so that it finds the
author checker framework classes
otherwise it's a pretty standard Java
compiler I explained why i say pretty
standard in a second any other questions
don't you think this is cool ok so let's
just quickly repeat what we just saw so
we have this macular expression example
we get one time exceptions and by using
such a tool you turn them in to compile
time exceptions so we get this pattern
syntax objection and the index out of
bounds exception and by using the Cheka
framework you get this static empty that
you don't have these problems in your
source code and again you get the
documentation benefits are saying to
match assumes a regular expression with
one capturing group and you can enforce
even if you don't want the check your
framework you have the added benefit of
the documentation and you clearly
delineate where you expect checks to
happen and where you make assumptions
about your code and then the fix there
are multiple fixes how you can do it the
simplest one is to use this regular
expression utilities methods that
performs this magic of verifying that
some input is actually a regular
expression internally it just compels it
and see whether there is an exception or
not and you can do that explicitly
yourself and it should work explicitly
awesome ok so let's just look a little
bit about how this Tool Works so we all
know how type checking works in Java Sea
we have a source code we run it through
the compiler we get others back from the
compiler and we have to fix them so one
thing we don't we never get a binary
until we have fixed all the compiler
error
and usually it means either we actually
have a buddy no software all we need to
change the types whether we are not
precise enough in our types then once we
have no compartments error messages
anymore we have a binary and we can run
it and we have exactly these problems
that they are one-time exception that
might still happen but we have our
binary that that's good to test now the
idea behind optional type checkers is
that we add the second loop so we have
the binary we can do all our testing we
can ship it to the quality assurance
department and they do whatever they
want to do with the binary and we can
one approach we have the second loop
that once the optional type checker like
this regular expression type checker
that i just showed and either generates
mornings and others and we perform
exactly the same thing we would do with
the java error messages we fix them
either by changing our code maybe we
really didn't have the validation code
there and there's something that we need
to change or we'd add annotations so
maybe we say okay this to match method
actually assume that we have a regular
expression so we add this annotation to
the code and then document this
assumption and have the checker verify
that actually all invocation satisfy
this assumption so maybe in one path we
made sure that the code is correct but
there was a second caller that we didn't
verify so we do the same thing that we
do with the standard java type system
and just verify additional properties we
can always execute the program and once
the checker is happy once the type
checker doesn't give you any warnings
anymore you have it i can t about the
behavior caveat is the standard caveat
so if you implement something you might
make a mistake if you implemented your
type system incorrectly the guarantee is
not long enough but assuming that the
type system is implemented correctly you
have a guarantee that you don't have
certain kinds of 136 sometime exceptions
and I said before that there's a good
reason why Java
doesn't enforce all these additional
properties the thing is there are many
different people many different
programmers and we all have different
properties that are dear to our heart
hopefully everyone cares about now less
exemptions but regular expressions maybe
it just doesn't matter for your coach
and maybe you don't want to bother with
verifying at the moment the nice thing
about optional type system is that you
choose which type systems you want to
enforce you always get the executable
you can always go to production and just
have monton exceptions and if you care
about the particular property you use
this advanced checker and you put in the
effort that is necessary to get a
guarantee about your code and then you
can model multiple you either run them
on the same comment line or you have
different targets on on your code base
that ensure different properties of your
software so that's one of the nice
things about these optional or pluggable
type systems is that you choose which
properties you enforce its not that java
sea forces you to make sure all these
properties hold it's the programmer is
empowered and can choose which
properties are important for you so in
with the checker framework you get about
18 so I think accounted yesterday it was
18 different type systems that enforce
different properties about your code so
we have this now lets check which in the
simplest idea is these two annotations
nominal and malleable if you have time
later on we'll talk a little bit more
about the knowledge checker and quite a
few different annotations that you need
to ensure the correctness of your
software they are basically for all the
different type systems that I described
before a check that ensures that
property so we have a mutation and
scientific type system we have at the
moment that rather simplistic
concurrency type system we have attained
ting and encryption type system we have
type systems for aliasing string
concatenation a string localization
interning and so on so the Cheka
framework is the framework
it provides the basic infrastructure but
it also comes with a set of people
checkers that enforce certain properties
and the nice thing about a framework is
that you can write your own checkers and
that's one thing we do in a moment let's
just quickly look at some of the use
cases that we have over the last several
years with very successfully use the
type checker at the Cheka framework on
one hand in our scientific publications
many of the type systems that we present
our implemented as check the framework
plugins it makes the research much
easier if you can develop your prototype
using this big infrastructure so in
academic conferences always try to
encourage researchers to use something
like the cheka framework because it
enables them to vary to implement
prototypes for their programming
languages so instead of developing a new
toy language that has one particular
feature you use a pluggable type system
and you can test your program on the
huge amount of open-source software that
we have so in total I think we went well
over six million lines of code to the
checker framework and we found tons of
user visible mistakes so user visible
mistakes that we reported to the open
source developers and also in the code
that we built ourselves where we talk
food that check is on we improved the
documentation and the code quality so it
just improves the quality of our own
code by running for example the
knowledge tracker and the incoming
checker on daikon one of our separate
code projects and one other thing about
the checker framework is that the
annotation overhead is quite low so as I
showed in a regular expression example
you actually didn't need to write a
single annotation everything well in the
first part of the demo so not not a
single annotation because everything was
done automatically by the type checker
it just ensured that you have the 110
check the van team Bella Dacian of the
input and no other modification
necessary if you break up your code into
independent methods you need the
annotation but that's exactly the kind
of annotation that you want it's in the
interface of a method that documents the
behavior of that method and so in one
experiment in 2011 we measured the
annotation overhead and it was something
below 3 annotations per thousand lines
of code so the annotation overhead in
typical soft is quite low so in academic
conferences I would not talk about the
formalization of them yeah go ahead what
do you mean that yep
so the overhead I'm talking about is
really just the static overhead it's
what annotations you need to add to your
source code there's some additional
compile time but it's not much at one
time it really depends on your type
system so in the regular expression type
system you need to verify that input at
some point so there is some performance
hit that you need to do because you need
to verify your input but there's no
additional overhead up from the type
checking themselves so it's really just
compiled time checks of your software
that ensure that the property holds and
then to ensure that the property holds
you might need to change yourself twere
so you might need to add the additional
input validation but that's independent
of the type system so the type system
the type checkers don't influence the
one time at all so it's really you
improving the structure of your software
and then you have to decide how to fix
that part back but by default the
annotations so the overhead I'm talking
about here is really just in the source
code so how many of these annotations do
you need to add to your source code ok i
think the muslim no good ok any other
questions cool so formalization type
systems all of you with university
education there is a lot of theory
behind type systems but for you as the
users of these type systems it becomes
second nature it's a very natural
extension of the java type system and
just instead of seeing it's a string you
see it's a regular expression string so
for you as the user of the tool it's
very natural extension of the java type
system if you want to develop your own
type system you need to make sure that
you do something that's meaningful so
then you would have to do a
formalization but normally as the use of
the checker framework you don't so and
that's the big picture some of you of
what we want to achieve at the Cheka
framework is move type systems from
giving you only low-level guarantee
and where you still need a lot of
testing to this upper right corner of
being both practical and giving you a
lot of guarantees so making it possible
for you to document and then force your
properties in your source code and doing
it in a practical way so doing it in a
way that you can use still use Java you
don't need to switch programming
languages you can enforce all the type
systems that you care about instead of
being forced by the new programming
language what you can use ok this was
the first overview and demo let's look a
little bit at the details so there are
two aspects i want to talk about one is
the chava eight type annotation feature
which enabled this whole project and the
second one is what the Cheka framework
provides so since Java 5 we have
annotations in java source code so you
might have seen at deprecated at
suppressed warnings you might use
project lombok annotations like this is
a getter and set or Quetta and the septa
should be generated for this field so
the thing in Java 5 is we have
annotation syntax we have the basic
syntax annotations the problem is we
cannot express a lot of type system like
qualities so we cannot say this is a non
null reference to my data we cannot see
it's an internal string we cannot say
it's a non null list of English things
it's a read-only array of non empty
arrays of English things so there are
all these more complicated usages of
type annotations that the built that the
channel 5 annotation syntax doesn't
support because channel 5 annotations
are only allowed on declarations so you
can write the annotation on a class
declaration on a field declaration and
on a method declaration parameters and
local variables but not on every usage
of a type so using Java 8 type
annotations previously known as jsr the
specification request po8 you can now
use an annotation
on every occurrence of a type in your
code so wherever you have a type you can
expect to use a type annotation on it so
you can now say it's an unwell data type
of nominal data is the type and the
field is my data and if it's a type
annotation it's really attached to the
type you can see it's an intern string
you can see it's another list of English
strings and the semantics are the the
logic is that the annotations are
directly in front of the type that they
modify in particular for arrays we have
the added component type first so we
have an English string of a video the
array of non-empty average so this
syntax puts the type annotation in front
of the type that they modify so if you
see something like this it's a type
annotation the annotation needs a simple
modification to the target type to tell
the compiler that this new location is
allowed that's it so the basic support
that Java 8 adds is the syntactic
extension so everything that Java 8 adds
is allows you to use the existing
annotation syntax in all these different
locations so everywhere where you can
write the type you can albeit the type
annotation so you can say in a genetic
argument position where you couldn't do
it before in a cast in an implement
class wherever you see a type in Java
you can write the type annotation this
is exactly what we want in a type system
where they might need to add an
annotation to every occurrence of a type
in the code the java compiler takes care
of all the important stuff so it passes
the AST puts all that information into
the bytecode you see it if you use java
p to look at the bytecode you see it in
the javadoc so all the basic tooling
infrastructure is provided by jealousy
the higher-level assigning semantics to
these annotations is done by any
separate tool for example the Cheka
framework but over time there will be
multiple tools that use this annotation
syntax to assign meanings
these qualifiers so the other example
might be the most complicated here the
basic syntax is read it from left to
right the type annotations are always in
front of the type that they modify so if
you have something a read on the array
of non-empty averages of English strings
in Java we have that idiom that the
component type is the first element in
the type so we have the string first so
we have an English string and then the
other dimensions are left to right so we
have a read only array of non-empty
image so the modifier is always directly
preceding the type that or the every
dimension that they're modifying one
thing that I want to just briefly notice
is that to enable type annotations in
all locations we also added explicit
receiver types so one thing in an
instance method is that an instance
method always has at this point the
receiver of this method call and
typically called this self depending on
your programming language and in Java
there was no nice way to add a type
annotation to this receiver type and so
one other modification in Java 8 is net
now you can add the receiver type as an
explicit first parameter in your code so
if you have a see code that has a
parameter called this it's a Java 8
feature to make the receiver type
explicit the obvious restriction is that
the receiver type has to coincide with
the enclosing class type and you should
invite it if you don't have a type
annotation so you can use it without
type annotations but there is no point
in doing it there is no difference in
method binding you don't see that
additional parameter it's just the
syntactic location to add type
annotations to the method receiver and
yet
so if you have an instance method you
call it on an instance of this my class
that's the receiver of the method and in
a static method you don't have a
receiver so there is no point in making
it explicit and you cannot use this
within a static method yeah about any
other questions so with inner
constructing a class constructors this
gets a little bit more tricky because in
the in that case the construct of a
class has appointed to the outer
receiver are out there class and so the
syntax is that you have outed of this as
a possible miss eva for an inner class
constructor but that's just if you see
code likeness in your source code it's a
new java 8 feature and you should only
use it if you need type annotations if
you need annotations on class
constructor receivers or method
receivers you have this additional
location luckily with the checker
framework I don't think it ever needed
to write one of these down so it's a
very rare feature but the syntactic
support is there so one thing that is
important for us in the check your
framework so this is a syntactic
extension of the checker framework to
the compiler so in the beginning that
was this question about which compiler
we use we use the Java 8 compiler with
this one modification so the monk
modification is that people that use the
Cheka framework wanted to use the future
but the teammates didn't want to use it
yet so they didn't want to switch over
to Java 8 so we needed a mechanism to
allow them to write down these type
annotations without forcing everyone in
the team to use these type annotations
so what we did to enable this is have
special comments so we have if you have
a type annotation directly included
enclosed in a comment the checker
framework compiler still interprets it
as an
for the stock Java compiler it's just
the comment and they don't see it at all
so it still say stay is java 6 and 7 and
backwards comfortable but if you want to
use these type annotations in your
source code you can put them into these
comments for these more advanced usages
like the method receiver type we
introduced a more complicated pattern to
enclose whole blocks of code so if you
want to import the qualifiers in your
source code you needed to put the whole
input statement into this special kind
of block so it allows you to use this
feature use the extended syntax only
with the tchenka framework compiler so
it makes it easier to transition your
team from the existing Java 7 code base
and gradually use Java it features the
second feature that many uses of the
Cheka framework required was to use
existing libraries for which they might
not even have the source code so it was
an important goal for us to provide
mechanisms how these annotations can be
specified the we have two basic
mechanisms one is as a text file where
you have the annotations for a software
for a library as an external text file
it's a basic java file without method
bodies so if we call that the stop file
that contains annotations for a library
so for the regular expression checker
for example we have well let's just look
at that
so for the regular expression check it
for example we needed to add annotations
to the jdk pattern and compound pattern
and string classes so what we have is
this separate text file that contains
okay I want to use my regular expression
qualifiers in the package java.util
magics there's this cat in class and I
know for the compiled class I require
regular expression string and I get a
regular expression pattern that if I
compile within flags I also require
regular expressions it documents all
these assumptions i have about the
library without modifying this library
so i can use the standard jdk and
provide this additional documentation
for the external dependencies so we can
use that for any library that you have
you just might down what assumptions
that you have what now let's assumption
what regular like special assumptions
you have you just documented in this
external text file that's one
possibility the second possibility is
that you provide a jar file and put that
jar file earlier in the compilation
process and then in this jar file we add
the type annotations explicitly and make
it possible to document the interface in
this separate jar file which is just a
little bit more efficient than passing
the text file at compilation time so
it's two basic mechanisms that allow you
to specify the behavior of your code
externally to the kilt so you don't need
to touch your libraries you don't need
to convince your vendors to add these
annotations one framework that some of
you might be interested in is the
dataflow framework that's one component
in of the Cheka framework that we used
to build the control flow graph of the
software so we have the Chava program
and we needed a feature to implement
this flow sensitive type refinement that
notices if there's a conditional that
exits if there's a try block that throws
the exception we needed a very precise
of the control flow graph of a Java
program and the standard Java compiler
doesn't provide that so the standard
Java compiler gives you the ast of the
program but there's no infrastructure to
get the control flow program for the
sauce for the source code so we
implemented this data flow framework
which some people already using to build
external tools separate of the Jacka
framework so the basic idea is it takes
your abstract syntax tree for your
travel program translates it into a
control flow graph and then provides
mechanisms to apply arbitrary data flow
analysis of it so you have you define
your abstract values define how the
different operations in your source code
modify these abstract values and they
have mechanisms to carry this abstract
store for particular values so this is
the feature that we use to implement the
the type refinement in the regular
expression checker for example so we
have the control flow graph we see that
there's this if statement and if the
condition doesn't hold we return and
only then do we perform an operation so
we need to exactly know we only reach
this point in the control flow if this
condition holds so it needs a quite
sophisticated analysis to understand use
of them it also helps in just looking at
your code once in a while so it
generates nice control flow graphs about
your program and shows you all the
implicit operations that you have in
your code made explicit so then the
biggest part of the Cheka framework is
the framework aspect so it implements
all the common aspects that you would
expect out of a type checking framework
so it's a framework that provides the
basic infrastructure of providing
defaulting providing the traversal of
the abstract syntax tree ensuring the
consistency of your type annotations so
it basically helps you in providing
implementing your own type system so it
helps you in have a king ante
it makes sure that if you override a
method it overrides it consistently it
helps you in implementing generosity we
have all this flow sensitive type
refinement implemented in a generic way
to allow you to very simply reuse that
feature as i said before defaulting is a
very important topic so we provide many
different mechanisms for how to decide
what defaulting you want in a particular
scope so you can specify that defining
on one particular blocks we support a
limited version of pre and post
conditions we can say if this method
returns true this other method is
returning nominal if this version is reg
ex returns true the first parameter is a
regular expression so it's this genetic
mechanism of providing p &amp;amp; co's post
condition in your code we provide a very
flexible mechanism to suppress warnings
and we have a very nice testing
infrastructure so these are all the
thing back feature that we provide that
we used in implementing your own type
system and also make it hopefully easy
for other people to implement their own
type systems and the third component is
the Cheka framework comes with a set of
built-in type systems so the one type
system that I will talk about a little
bit later is this now let's type system
that makes sure that your code doesn't
contain null pointer exceptions we also
have these mutability type systems in
turning types dis down the regular
expression type system and so on so the
Cheka framework comes with this big
package of individual components that
might be interesting for you to use okay
any questions about this part of the top
basic motivation of the Cheka framework
should we modify the regular expression
example a little bit and try something
yeah
so the thing is everything we do
compiles with Java 7 so the length rules
that we use the whole check a framework
infrastructure only requires java 7 so
you can compile everything with Java 7
the resulting compiler is each other
aight compiler but if you don't use
lambda you can still use Dashiell 7 and
generate java 7 source code app ID code
so the whole infrastructure still builds
we require 7 now but all the length of
features all the Cheka framework
features are implemented with Java 7 so
you can do everything with Java 7 and
with these annotations in comments you
can just if you need an annotation is in
a syntactic location that's not valid in
seven you put it in comments and then
I'll check a framework picks up the
annotation but the best of your team
just ignores them so all the
infrastructure is charter seven code so
you don't need so it's each other each
compiler but the policy is always that
the each compiler compiles with seven so
everything you need at the moment is jdk
7 yeah
that's Griffin's little
so I would say it's still complimentary
you still want unit tests just to make
sure and test driven development the
basic idea of writing down the
interfaces before you implement them is
still a good idea the thing i would do
now is that instead of just writing the
interface i would use the type
annotations from the beginning because
it's so much more useful to to know that
this parameter is a regular expression
to know that this is an unlock parameter
so if you have that flexibility to stop
with a project from scratch you should
use the type checkers from the beginning
because it just helps you guide the
structure of your softer to make it an
amenable to static analysis so if you
have that flexibility it's a lot easier
to use the type junkers from the
beginning and make sure that everything
is analyzable it documents your code
better you get a nicer design in the end
it's a lot harder to have your existing
without hundred thousand lines of code
and then try to make sure that the now
lists you don't have a
nullpointerexception so doing
test-driven development using also type
checkers i think would be perfect so
detailed analyses whether there's a
different methodology of how big that
impact is we haven't done yet but yeah
if you can use it from the beginning
that would be perfect and should have
the biggest benefits yeah
i use
yeah so are you using guava or using the
Java eat optional guava yeah so we
didn't look in detail into how to
integrate the guava library and the Java
8 the optional yet but I hope they
intact nicely so I don't see why there
should be a problem so in principle I
think it's nice so in principle I think
it's nice if you use type annotations
because you don't have that additional
level of indirection of the optional so
because you just have to swing and you
have the type annotation which is a
purely static thing so you don't have
the one time interaction of using the
optional so I like type annotations
better because you don't have this
additional introduction but with this
interaction you just have this
additional assumption that ok it's
optional and then you either it's not
null or not
it's not just one
so but that's a one-time thing yeah so
you couldn't do something like that in
the static quite qualified yeah yeah so
one thing with reflection is always that
there are loopholes to the Java type
system and obviously also to the Cheka
framework what we did in one recent
research paper is try to analyze as much
of the reflection as possible so the
typical use cases of deflection is that
you somewhere know the string of the
class name you pass that around a few
levels and at that point you us off your
method so the typical use cases are
quite safe and so we have a reflection
analysis that propagates the string and
class information through your program
and allows you to document what
information you assume at a certain call
case if you're not that flexible for
example in the library you can simply
enclose that method you can say okay
this is my reflection method this does
this kind of magic and these are the
assumptions for the parameters so that
you basically push it down to the
smallest level which you should do
anyway so you shouldn't use reflection
all over the place you should
encapsulate it in some method and then
for the type system you just say ok the
assumption is that whatever method I
call cakes nullable parameters but
return something normal and that you
verify that property log locally
something similar applies to more
complicated properties like the
encryption type system i will talk in a
moment if you have encryption alcohol
with the tchenka framework is not to
verify full functional correctness so we
cannot when don't want to verify that
your given for encrypting something is a
correct implementation of AES 512 or
whatever so we want to say okay this is
a magic method that performs encryption
and you have to guarantee with some
cryptography that this method in
encryption all we make sure is that the
information that flows into and out of
this method is of the correct type and
this makes it possible to be lightweight
if you wanted to ensure full functional
correctness and really verify
cryptography algorithms you would need a
lot more annotations so the point in the
checker framework is this lightweight
pluggable type systems that ensure the
information and your program is
consistent or as you would expect great
question any other questions yeah
or say to our side
in our firemen building using six or
seven for them
hmm so the build if you download the
checker framework from a website it's
built for Java 7 so you only need a java
7 virtual machine and all the software
that we write for the Cheka framework is
Java 7 software so you only need a java
7 compiler to compile the checker
framework so you can't use them in the
type annotation locations because that's
not the valid location 47 so then so
these these so the feature that you can
use annotations in comments is part of
that compiler so the Cheka framework
comes with a separate compiler that
enhances how we pass comments so that's
a feature in the Jacka framework but it
still only requires a java 7 virtual
machine 21 ok ok so the next part that I
wanted to show you is how you can write
your own type system and one part of the
Cheka framework is that we want to be
extensible and there are many properties
that application domain specific so this
painting it depends on whether you have
a sequel database and you want to make
sure that the sequel string is not
tainted or you have some other library
and you want to make sure that the
JavaScript engine or whatever doesn't
get tainted information so it's very
application domain specific what kind of
property you want to express in your
software so what I want to show quickly
is how to write this type annotation
called encrypted where we want to make
sure that this scent method only takes
encrypted strings and then if I have an
encrypted string from somewhere I can
call send with it if I have an
unencrypted string and a call send on it
I get an error message so I want this
basic distinction between a high and a
low value and encrypted and an
unencrypted value and make sure that the
usage in our code is correct
so functionally all that we want all of
it that we need to do this is three
lines of code and the input statements
and the package where you want to put it
but the content is really just three
lines of code and let's look at it at
the slide and then implement it for real
so the three lines of code is the first
one is the target meta annotation so we
specify a annotation type so it's this
ad interface encrypted so this is
defining our own annotation that we can
use in our software the target met a
notation tells the compiler that this is
a type use annotation so if you know
Java 5 there's the type element location
element type which is a class and
interface declaration and type use is
the addition in Java 8 to make it
possible to use an annotation and all
these new locations so what we say with
the first line this is a type you
sanitation the second met annotation is
from the checker framework so the Cheka
framework provides many mechanism
declaratively meaning that you add meta
annotations to an annotation that you
define and you declare the subtyping
hierarchy in this case so what we say
here is that the encrypted annotation
should be a subtype of this separate
annotation called unqualified so what we
want to do with this is build up this
high bahi between the qualifiers and
qualified is a built-in annotation from
the Cheka framework that says ok the
user didn't write an annotation locate
in this location just use unqualified
and encrypted is a subtype of this so we
have one qualifier on top unqualified
and encrypted as the specialization
giving us this property that if the
method requires the subtype we cannot
pass the supertype in so let's look at
the wheel shop then
so this was the back x so here is
everything to make it compile we need
the to import statements one to import
chavalon annotation to get element type
and target and the other one is to get
these framework classes to get subtype
off and unqualified that's everything
that we need on the compiler level so
what we do as the first step is compile
this encrypted class and hopefully that
works so then what we have is the use
use case of this is this encrypted demo
class where we have one special method
that requires an encrypted parameter so
what we say here is only call this
method with a string that is encrypted
and then we do something special with
that string and then in our demo we have
this encrypted string that for the sake
of argument comes from the argument
argument array we call the scent method
with that and we expect that to work and
then we have an unencrypted string and
if you call the same method on that we
expect a warning message so let's see
whether that works and now the Cheka
framework comes with one special checker
that uses these declaratively defined
type qualifiers and applies them in your
source code so what we do now is use the
checker framework Java C compiler as the
processor as the type checker we use the
special checker called the subtyping
checker so the subtyping check takes a
set of qualifiers and ensures that the
subtyping relationship between these
qualifiers is correct as an argument so
dash a is always arguments to annotation
processors
we say okay the qualifiers that you
should check against is encrypted that
one qualifier that we just defined and
the framework qualifier called
unqualified which the framework uses as
the top qualifier if there is no other
qualifier defined so that's all the
setup that we need and then run it on
this encryption demo application so what
does the compiler warned us about we get
to expected what what I expected them so
the first one is we declared our local
variable as encrypted string and we
assign this argument to it and again we
didn't verify it so we cannot be sure
that the argument that we got out is an
encrypted string but we note that the
the call of sent message of send with
that first message string doesn't call
sinaga because the variable is declared
as an encrypted string so for all late
the type checking we assume that it's
this encrypted string it's just at the
initialization point we try it
initializing it with something incorrect
the secondary is the expected data that
we want we have this message to string
which is declared as an unencrypted
string and we get the expected error so
we found a string and we require the
string encrypted string so to build a
simple type system like that where you
want to say okay this is sequel tainted
sequel untainted the only thing that you
need is this declarative approach of
saying these are my two type qualifiers
one qualify as a subtype of the other
one and then the subtyping checker
implements the basic iteration of the
abstract syntax tree to make sure that
this subtyping relationship holds so
obviously this is the simplest case if
you only have type qualifiers and only
one simple subtype tests like in a
standard object-oriented language to
implement something like the knowledge
check you need many more features you
need to encode that in this place you
need to make sure that something is non
lo and the ID and the Cheka framework is
to make it easy
to gradually expand your type checkers
so we provide these declarative
mechanisms to cover the easy cases to
declare the subtyping relationship to
declare what defaulting rules that you
have and so on and then if you will need
advanced features you can switch to an
imperative mode and overbite type
visitors or EST visitors that go through
your abstract syntax tree and say in
this particular place when you de vence
a method make sure that the receiver is
non long so that's something that you
cannot specify declaratively you
implement your three visitor and have
very simple mechanisms to say give me
the type of the receiver make sure that
this receiver type has this the receiver
type has this qualifier and what you
already get with these things is the
very basic flow sensitivity for examples
if we have if you change this into
something like this
so when we have the parameter declared
as an encrypted string and then we
assign it for whatever reason to a local
variable and in the local variable we
didn't declare that it's encrypted and
the other is gone so we have
automatically out of the box this flow
sensitive type refinement that through
this assignment we know that the
right-hand side was an encrypted string
we assign it to a local variable that
didn't contain an annotation but the
flow sensitivity looks at all the
possible paths and see is okay at this
point I can be sure that the property
holds so if I have a second string II
and then for whatever reason I do
chemistry one if five in Chrome's line
oh my salon because in
so let's see what methodist is what i
would expect so we have some conditional
we assign the variable we're sure that
it's an encrypted string to this local
variable so i would expect that this
method invocation works but then we have
an else branch where we assign something
that is possibly unencrypted to this
local variable and we have an other call
outside so outside now we cannot be sure
that this is an encrypted string so I
would expect one error message yeah so
we get an error message online third
team that is this invocation so on the
first invocation type refinement knows
ok it's a dead branch don't worry about
that if this assignment happened I know
that my message one local variable is an
encrypted string that's the only way
that you can reach this part in the
program in the else branch we assign
something unencrypted so after the
conditional we statically cannot be sure
but it's an encrypted swing or an
unencrypted string so the type checker
basis that ever again and that's a very
simple kind of mistake that you might do
you had your validation logic in your
code but you should have in the l's
plans you should have put your program
or do some other thing to make sure that
you don't feature reach the point after
the program so now if you add a return
here we would expect that the error goes
away again and it does the Democrats are
good with me today and so we see that in
the control flow the only way that we
reached that point after the merge of
the conditional is that we had an
encrypted string so it does a lot of
analysis of the control flow of your
program to give you a guarantee about
and minimize the annotation overhead
that you have and in general our goal is
that within method bodies you shouldn't
need to write type annotations so you
want it on the method signatures to
document the expectations of your
application but in within
metal body we try to infer as much as
possible yeah
ok
maybe you do
Oh
validate mother yeah so I am a bit
afraid that I would need five minutes to
bite that so we provide all the basic
mechanisms that you need so we have a
precondition annotation where you can
say if some method returns true then add
this type refinement and so you can you
should be able to write if is vector is
encrypted method add that precondition
annotation to it and then automatically
get that feature so if we have time in
the end we should do that afterwards we
try that so I mentioned these pre and
post condition annotations that are
exactly for this purpose you want a
boolean method that tests for a property
and you don't want to verify the body of
that property of that method but you
still want the documentation of the
behavior from that interface okay and
any questions about writing your own
type systems so one thing that's usually
fun at this point is how the defining a
type system so i think is that most of
this so we provide these declarative
mechanisms to define your own type
system in an easy declarative way in
particular the qualifier however he and
the type introduction wall so the
defaulting rules are declarative and
then if you are specific type walls
extending the subtyping checker by
additional code in a in a new visitor
and then for the really advanced type
systems where you need additional flow
refinement you add yet another
implementation of one of the visitors in
the framework that allows you to specify
additional logic for the flow refinement
so more than just standard pre and post
conditions let's get that one so one
thing that's usually fun is to
brainstorm a little bit what properties
you
to enforce in your code so and to do
this I think the the three guiding
questions that that help in determining
what you want to to check is what one
time exceptions are the most bothering
in your code base so what one time
exceptions have your clients complained
about ordering testing what one time
exception have you won in the most so
which one time exception would you want
the tool to prevent then from that you
can decide what are the basic data
properties that you want to enforce so
the basic assumption is it encrypted is
it not encrypted is it a regular
expression swing is it not the regular
expression string should it go from the
one-time exception to properties about
data and then two properties about the
behavior so to say pattern that compile
should only work with a regular
expression string or this scent method
with encrypt should only take an
encrypted string so that you break it
down okay the van time exception or the
behavior that I wanted to prevent is
sending unencrypted slings I make the
distinction of the two sets two separate
sets encrypted or unencrypted and the
behavior I want to enforce is adding
this annotation on the scent method ten
force that only encrypted strings can
work and as examples from what you
cannot do is out you should depend on
the values not on the program structure
so encoding timing information is a lot
harder to do in a type system there are
some advanced systems but for the basic
idea it's easier to think about the
properties and properties of values okay
who has an example idea yeah what is
cheap here again what exception are you
running into
so che PA and attached and detached
entities okay
okay so i don't know JP a solo is there
a method where you would say okay this
method can only be called with attached
to entities yeah so that sounds perfect
for a type system where you can say okay
this method make sure that something is
attached to it creates attached objects
and only these kinds of objects should
be passed into the jpa API can you speak
up a little detached okay
okay so that becomes a little bit harder
to encode because you have this change
of the type of a time but maybe you can
encode it as as a simple system and then
it's the flow refinement so that you
have the genetic type on top once you
know it's attached you refine the type
to attached and from that other methods
you remove that information again okay
good example yeah so stream like in the
Java 8 stream so in the normal
filestream yeah that's another example
of a simple type state system where you
want to make sure that the file you open
it first you perform read and write
operations and in the end you close it
again yes okay so when do you receive
them in collections in genetic correct
code
without the warning shouldn't there be
an unchecked warning you feel otherwise
you shouldn't get a classcastexception
hmm wha but then just make the unchecked
warning into an era now that the the
standard Java compiler but it tells you
that you do something else out there so
I'm not quite sure would you want the
arrow at a different point
okay and so I'm not quite sure how they
could would look and wider Java compiler
wouldn't give you a warning okay
but they would just say use the standard
java compiler because it already does
all these raw type warnings and tells ok
here the heat might be polluted so I'm
not sure what the checker framework of
what annotations would help you with
that and then you cast it
ha
and
huh
yeah so one general comment there is
that you shouldn't abuse type
annotations so if the standard java type
system provides genetics and all you
need to do is instead of God types use
generic types you could use type
annotations to say this is a list of
strings instead of the wrong list but it
seems a bit strange to instead of just
using the standard Java feature trying
to use type annotations but maybe that's
an interesting use case to say you
cannot transition to genetic code and
you want to use type annotations to to
add that additional information so that
net would be interesting to think about
yeah
so in the generic case I'm not quite
sure but if it's for a specific property
yes so the nice thing about type systems
is exactly the model of behavior that
you specify your interface and you
enforce that interface at all the usage
points and so if you from the other
direction yeah so i haven't used the
type system for that kind of logic but
that would be interesting to think about
how you could say okay this is a
business logic data object and there's a
subtype and then you can assign it to
the application layer but not the other
way around so it should be able to
encode a property light like that as a
simple sup and super type relationship
yeah oh yeah can you repeat that if i
have the same class
now
that
so I'm sure you can write the static
analysis for it but I don't really think
it's a type system because you wouldn't
want to add that as a property in your
method signature you want to document
that in your code
so yes I will don't quite see how a type
system would help with that because it's
really the class part that you use at
one time and I don't see what property
you would want to document in your
software okay well maybe it helps so
that's always good okay so there are
many properties that you can enforce and
many runtime exceptions that you could
express as a type system the thing that
I wanted to do next briefly is to talk a
little bit about the non life tracker so
the knowledge checker is one of the the
basic idea for the knowledge check is
very simple you just want to ensure that
the reference is either null an unknown
but then in reality there are many
corner cases that you need to think
about so let's talk a little bit about
that so we have two annotations in the
basic case nullable and none now when
nullable is the Super K at the
applicator super type where you don't
know what it's not mulla now so it's the
the generic case and the F nominal as
the specific case where you have the
static guaranteed that this is a real
object and what might be surprising is
that the default is actually non mulled
in the checker so in Java programming
you always have to guard against the
case that something is now so by default
in Java you would expect nullable being
the default but there has been a study a
few years ago that analyzed defaulting
phenomenas type systems and determined
that it's actually the common case is
that you expect a real object so the
common case is the null annotation and
by using this default you'd use the
annotation all the hat that you have so
by assuming that the that the common
case is the default annotation you only
document the exceptional case you say
this annotation this field might be
nullable highlighting that this is
an exceptional case and hopefully you
use it in in fewer cases then the
defaulting logic is that within method
bodies we use this climb to top logic
meaning that a local variable is assumed
to have the top type so the default for
local variable so if I cast local
variable instance of and implicit bounds
is the top qualifier giving you type
refinement so if the local variable we
had none no as the default you couldn't
assign null to it and that's a common
pattern that you have the local variable
you first design know and then you do
something with it by using the top type
in local variables we can rely on flow
sensitive type refinement to assign the
most specific type in a particular patch
then if you create an SL and you object
and assign it to your variable that
tight pitch we find so let's just yeah
this shows it so if we have this check
that X is not equal to now we don't need
to create a new local variable and
assign it to that new local America so
the common pattern in Chaves always you
test something for an instance of then
you need to create a new local variable
assign the result and downcast it what
this flow sensitive type refinement
gives you is that you just test for the
property and the type system is clever
enough to refine the type of X so here
we have if X not equal to null we can
directly call X dot hashcode because the
type of the local variable was refined
to this the same with the regular
expression example that we saw before if
from the capital flow it's clear that
there a better value holds we don't need
to write out the type unfortunately no
and several different properties about
type systems make it not good enough to
check only once does anyone see what
might go wrong in code like that I have
if my fear
is not equal to now I call some utility
method and then call my field that hash
code so do something with the object yep
exactly so the problem with fields is
that many people can modify them and
it's not enough that I check once that
the my field is not now because I call
this separate method and this separate
method might wake our assumption again
so what we need in addition to just the
basic non null and malleable is
mechanisms to describe what side effects
methods have and the Cheka framework or
in particular the knowledge check
provides three different ways so one is
to specify the side effects which is a
general mechanism to say what might
change if you call a method the second
approach is now less specific it's
monotonic normal which specifies once I
tested this property I can locally
assume it so it might not hold initially
but once I'm sure that the property
holds it holds this is useful for fields
that you use for lazy initialization so
they might not be normal until some
point in your program but once that
point is reached and you ensure that you
initialize that field you can rely on it
and the third one is pre and post
conditions where you can say okay method
1 ensures that this field is not mal it
might even set it to mal in between but
at the end of the method you are sure
that this man that this field is still
again none now let's have a quick look
at each one of them so side effects is a
very interesting topic and there's a lot
of research in deciding what side
effects and how local are side effects
what a good side effects what are not
none good side effects so for example
caching is a big issue because if you
catch something the method modifies the
data structure so how do you decide
whether a cache is a positive side
effect that you want to allow or whether
caching is a negative side effect that
want to allow at the moment we have
three annotations that is described
three separate properties whether
something has a side effect meaning
whether it modifies the heap but it's
deterministic meaning if you call it
with the same arguments you get to the
same result and the combination of both
which is commonly called pure and then
if you declare this method one from
before a side-effect free you can rely
on the field still being nominal you
tested for the property you call a
method that is guaranteed not to have
side effects so afterwards you can still
rely on it so that's one way to make
that example work the second one is lazy
initialization which is called monotonic
normal when you say this field might be
null initially because I didn't call my
init method but I checked that the
property holds at a certain point and I
have to guarantee that nobody assigns
now to it so i can already initialize
the field I can never uninitialized the
field so it helps you for lazy
initialization patterns we can say okay
it's not just the constructor that
initializes this field you also need to
call this eminent method and then you
can have as post condition for the init
method that the field is initialized and
you build up this dependency chain of
seeing okay I told in it or I know that
this field is initialized and so this is
the the second way of ensuring
correctness and the last one RP and
postconditions where you can say that
this method requires that a field is not
now so even though it's declared as a
nullable Field you say for this method I
assume that this field is not now and
then the call of the method has to
ensure that so whenever you call that
method you have to statically know that
this field is normal which you might
know because you just call the init
method and the init method has as post
condition that it sets that field so
that brings us to post conditions where
you can say this field ensures
something is nominal and so by adding in
the in a nice way the preconditions of
one methods and the post conditions of
another method you build up this
dependency that something was
initialized correctly and then the final
complication which is actually very
interesting to discuss is initialization
so even if you say that the field is
none now during construction of the
object is the field is null initially
and then you need to make sure at what
point the field becomes actually valid
to use and it becomes tricky because one
constructor might depend on a field from
a different object and you need to make
sure that all of these dependencies are
met that it can only say an object is
initialized when all the fields that it
depends on uninitialised so now let's
initially seems like a nice and simple
property but now unless is one of the
most complicated type systems that we
implemented and it just has this
ingrained semantics that Java assigns to
know us and the Cheka framework grew a
lot by trying to handle all of these
corner cases in a nice syntactic simple
way and still be sound so still we don't
want to say okay in its allies ation is
too complicated we don't want to do it
we want the sound way to give you still
the guarantee that you handled it
correctly yes yes so with this
initialized in an initialization you can
exactly say the frame tells you this is
this constructor the super constructor
was constructed and then you can specify
that you remember that slide about
receive annotations so you can specify
that this method actually can take an
object as we see but that's under
initialization you can already call it
so you can use these features to build
up all these all this information
so unfortunately for things like
encryption you can never prove it in the
type system it's you need a
cryptographer who verifies that this
algorithm implements encryption and you
need to suppress warnings on that local
method so we use the standards a pest
morning's mechanism but we also support
an assert statement that you can add to
your source code and if you enable
inserts you get the one-time benefit but
it also suppresses the warning for the
type checker so it it's just double duty
in in what you get out of the asserts
and the suppress warnings do I still
have time I should quit some okay um the
basic idea is think about the
specification so if you think about what
do you want the application to do where
do you assume now let's these type
annotations can help you even if you
don't want to use a type system having a
standardized vocabulary getting all the
developers say this is the encrypted
annotation that we are going to use okay
we are not bothering with the type
system yet but standardizing on
specifying that in something other than
English already helps you a lot and then
as a second step you can run the
knowledge check to make sure that these
annotations actually consistent and then
you can have one part of your team
running the checker and other parts of
the team only passively trying to not
break your code let's skip through that
so finally I already highlighted some of
the relations net we did so we in our
experience we find important parts so we
found we rented on a few million lines
of code pinal and for many different
type systems and for each one of them we
were able in open source code to find
mistakes that caused the crash so its
really user visible mistakes that you
can reduce to to an aero india code for
most of the type systems the annotation
overhead is low so in one study that we
did it was too
when six annotations per thousand lines
of code which is a lot less than trying
to make your code generic for example
for the now let's type system it's more
it's I think about 10 annotations per
thousand lines of code but it's still a
manageable overhead that you need to add
to your coat I think for knowledge it's
about 10 but i'm not sure but it's
something like that yes so the default
of using none now and doing all the type
refinement within method signatures
within method bodies we tried it in a
few classes and have first year computer
science students use the type systems
and if you explain it in a
understandable way first year students
they get induced to type systems and
it's a natural extension of the existing
type systems and finally we had a few
new clad students join the team and for
one of the papers that we vote we had
each new grad student implement one new
type system and they were able to do
that just using the manual that we
provide ok the two other case studies
that we do or to other applications
where you use the checker framework in a
research one is spotter the static
program analysis for reliable trusted
apps where the idea is that in Android
Android uses Java which is good fast and
you have all this private information
that might go wherever your mobile phone
phone goes and to all the Internet
domains permissions in Java don't give
you a lot of guarantees they just tell
you it uses the internet but it doesn't
ensure how it uses the internet and what
information is used so we have an
information flow type system that in a
fine-grained way says this is an address
book entry you drag it throughout the
program and you see that this address
book entry goes to the Internet and then
we have a separate policy file where you
see address book to Internet is ok or
it's not ok so you have in your source
code documented
these sensitive information flows are
and the type check you can statically
enforce these properties the second
research project or was just like
mentioning briefly is using games for
very so verification needs a certain
kind of nerd and they're very few of us
and if we get the verification task into
a game we can have everyone play a game
and by playing the game they do do a
real scientific effort and give us
verification condition proofs so that's
one other project and there are two more
sessions that I want to mention tonight
we have a bird of a feather where you
can discuss more additional uses of type
annotations I will briefly present the
Jacka framework and matuko speakers get
Ian and Constantine will talk about
their ids uses for type annotations and
it will be a very open session about
what I use is that people see for type
annotations and tomorrow days I talk
about enhanced metadata in java SE 8
which talks about a few other editions
in SE 8 which is repeatable type
annotations and parameter name
reflection so that talk is tomorrow ok
in conclusion and I think somewhat in
time is java 8 add something other than
lambda so that is type annotation syntax
that allows you to specify your
properties in a more fine-grained way
and the Cheka framework is a tool that
allows you to write feature full
effective easy to use and scalable
static analysis tool for your java
source code and we hope I convinced you
that it's easy to use them to prevent
bugs in your software and you can write
your own custom checkers very easily ok
with that I think we have 5 minutes 47
minutes for any concluding questions yes
all of things so the basic idea
so but you don't have to run the checker
yeah
so but the backwards compatibility is if
you've under standard Java 7 compiler
you don't get any additional warnings
and it works as before only if you want
to check your framework you might get
these additional errors
never said yes so you could introduce
rules like nap that if only if you make
the usage wider do you allow it without
changing the version number yes you have
to look at the subtyping relationship so
you for each qualify you see whether
it's a super sub type so it would be
possible to do is simple static analysis
that tells you exactly that so there you
have the two versions and you see for
each annotation change whether it goes
up or down we don't have net at the
moment but that's that's a nice use case
any other questions I'm not sure what's
it supposed to us insolent yeah the
standard one it doesn't so the standard
java compiler if you have source eight
it requires target eight so in our check
if framework version we support that use
case but it's exactly and so that the
hack that we do in that regard is that
we allow source eight to support type
annotations but we require that you be
allowed target 7 and then we still have
the type annotations in the bytecode
because Java is clever enough to ignore
sections that it doesn't know about 70
80 k just ignores the type annotations
so it's just this additional clock in
the bytecode that it ignores but you
need to use the checker framework
compiler for that if you use the
out-of-the-box Java 8 compiler as soon
as you say its source ate it requires
target eight
okay with that thanks luck for your
attention and I hope you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>