<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Post JavaScript Apocalypse   Douglas Crockford   Keynote at Oracle Code San Francisco 2017 | Coder Coacher - Coaching Coders</title><meta content="The Post JavaScript Apocalypse   Douglas Crockford   Keynote at Oracle Code San Francisco 2017 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Post JavaScript Apocalypse   Douglas Crockford   Keynote at Oracle Code San Francisco 2017</b></h2><h5 class="post__date">2017-07-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/JbjpBs0QaUc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so good morning it's time to talk about
the post JavaScript apocalypse
so who's heard of JavaScript anybody in
hands and that's a few hands went up I'm
not surprised a tech-savvy crowd like
this one JavaScript it turns out is has
become unexpectedly the most popular
programming language in the world it's
taken over the browser obviously it's
starting to take over servers it's
moving into other niches it's everywhere
and so I've been thinking a lot about
what happens after JavaScript what's
going to be in the next language and I'm
an optimist I feel there's got to be a
next language because if it turns out
that javascript is the last language
that'd be really sad and we got to do
better than that for the kids right we
can't let it end with JavaScript we have
to move on now this title is
controversial there are some experts who
think that it should be called the put
JavaScript apocalypse and others think
it should be called the patched
JavaScript apocalypse this confusion is
due to a feature of HTTP the hypertext
transport protocol which is what we use
to move documents around in the World
Wide Web it contains three similarly
named commands which all do pretty much
the same thing but there might be
instances where using the wrong one
could lead to disaster and so I look on
this as clutter that in a well-designed
system there should be one way of doing
something and it should be obvious what
that one way is and this other stuff is
just noise it creates problems it
creates a noise it makes it harder for
us to work together and communicate so I
would like to figure out a way to remove
clutter from all of our systems at the
next language for example I would like
to have less clutter than our current
languages so the world's greatest expert
in removing clutter from things is Marie
Kondo or Kumari she's a brilliant
Japanese woman who is really good at
organizing house
homes that she'll figure out how to
organize the things that you have in the
place we live and make everything really
nice and efficient and she has this
really wonderful technique for getting
rid of clutter because we think of we
spent our lives accumulating stuff right
we go to work we get money we use money
to buy stuff and we have all this stuff
and we used to say that whoever dies
with the most toys wins but it turns out
clutter having too much stuff that stuff
can have negative value you may have
stuff that you really want to use but
you can't find it because other stuff is
in the way sometimes some stuff that
said on top of other stuff is actually
destroying crushing or leaking on to
lower stuff and so kanto teaches us that
we can improve the quality of our lives
by getting rid of stuff not which
identify things and if we don't need
anymore we should sell it on eBay or we
should donate it or gift it or recycle
it or find some way of having that thing
create value because it's creating
negative value for us so she has this
brilliant technique that she teaches
where she'll go into her room and she
pulls everything out of the closets
everything off the shelves everything
out of the drawers she sets everything
in the middle of the room and then she
has you pick up an item and you hold it
and you ask two chemical deskah
which means does it throb does it
vibrate and if it does then and I want
to keep it and if it doesn't when you
want to want to discard it know how when
she is teaching in English he doesn't
say throb or vibrate because it makes
some people giggle like that kind so
instead what she says is does it spark
joy which is really lovely right you
pick it up does it spark joy if it does
if it means something to you if it has
some value to you then you keep it other
ways to get rid of it and I would like
to apply this idea of spark joy to the
features of programming languages and
the essential parts of systems but we
can't and the reason is that everything
sparks joy that we have accumulated crap
going all the way back to Fortran and
we've loved it and so just asking does
it spark joy is not sufficient and we
don't have enough practice at
understanding what actually causes joy
so I want to go through some examples
you know show you how it's done so we'll
start with ASCII the American Standard
Code for information interchange ASCII
was originally designed to be a teletype
communication standard but it eventually
became a computer character set standard
and is still exists as the first hundred
twenty-eight characters of Unicode so
ASCII contains two characters the tabbed
character in the space character the
space character was inspired by the
spacebar on typewriters it's something
where you push it and it dances a
carriage one increment and if so
pressing that that creates the inter
word gap tab was based on the tabulation
keys you push the tabulation key that
would free the carriage so that it could
swing freely until it was mechanically
instructed by a tab stop which is old
piece of metal which would keep the
thing from moving any further and that
was a feature of typewriters to make it
easier to type columns of numbers and
similar sorts of things so both of these
were incorporated into ASCII but in tab
was added but tab stop was not so
there's no way in ASCII to describe
table stops and there's nothing in the
ASCII standard which says what the
how many default characters a tab stop
should be so that's problematic but a
bigger problem is that we argue about it
all the time that you can get a group of
programmers together and ask tabs or
spaces and they will have very strongly
held opinions and no data to support
those opinions and so we spend a lot of
time arguing and having problems
interoperating because of this clutter
so who's seen Silicon Valley if you
haven't well even if you have by HBO
stop stealing it you need to by HBO
because you need to incent these guys
for having made the best show ever about
programming it's the story of Richard
Hendricks he's a brilliant programmer
and his adventures in trying to start a
software company a few miles south of
here he's a brilliant guy he works
really hard and because he worked so
hard he doesn't have time to find a
girlfriend maybe you know the type or
maybe you are the type but in season 3
he finally finds someone and she's great
she's mark she's nice she's a programmer
but she uses spaces instead of tabs and
this makes Richard crazy it turns out
his affection for an invisible control
character is greater than anything he
could ever feel for a human being and so
he explodes the relationships so clearly
having both spaces and tabs creates
enormous human misery and the argument
is never going to stop but it should
stop because having both of these is
creating no value for us so it's
creating a lot of negative values so we
should get rid of one of them because we
don't need both of them and having both
of them is causing problems so the one
to get rid of has to be tabbed right
because we need space I can't get rid of
space so we get rid of tab no more tab
okay agreed okay
tab does not spark joy
a ski has single quote and double quote
and JavaScript uses both of them
interchangeably so you can start any
string riddle with either a single quote
or the double quote and I tried to make
sense of that now why do we have two of
these I tried to discover cases for
where you should use one where you
should use the other and I saw other
people who had different rules which
also made sense and also see people who
rely on personal preference which
doesn't make any sense at all and in
trying to reconcile that I finally
determined that we don't need both of
these so we should get rid of one of
them and so the one we should get rid of
is the single quote because it's also
overloaded as the apostrophe and so it's
problematic anyway so single quote does
not spark joy ' does JavaScript has in
as of es6 it has a let statement and it
also has a bar statement the difference
is that var allows you to declare a
variable in a function and let allows
you to declare a variable in a block and
generally i provoke of them i've seen
some people who try to use them
interchangeably or have come up with
rules for when you use one or the other
and we shouldn't we should just get rid
of one entirely so the one I would get
rid of is var because it confuses the
Java guys they don't understand how
block scope works and so if we just use
let then they don't get as confused and
getting rid of confusion is good unless
you have to run on ie6 because that is a
syntax error on ie6
we're on IE 7 or 8 or IE 9 or a 10
let's just stop doing IE altogether
right let's just yeah
Edge's all kalyan edges all right but we
should stop doing ie es6 also introduced
Const which is like let except you can't
assign to it that's actually even better
so wherever possible I prefer to use
Const JavaScript has to bottom values
null an undefined
now there's an argument among language
designers should we have bottom values
at all but there's nobody who thinks you
should have two of them javascript has
two of them and so we don't need two of
them it's not clear we even need one but
certainly we don't need two so I
recommend not using one of them and the
one I would get rid of is null usually
when given a choice like this I'll pick
the one that is fewer letters but in
this case there's some terrible design
errors associated with null we can avoid
those errors if we simply don't use it
now the idea of null as a special kind
of pointers a future of a programming
language is due to Tony Hoare a
brilliant British programmer who has
since regretted this invention he has
called it a billion dollar mistake he
came up with that figure by accumulating
the total of all the damage that's been
done by null pointer exceptions since
their invention so no pointer is not
something we want to see in the next
language but Moniz maybe is so I would
recommend instead of having null as a
pointer to nothing instead it's in a
mutable empty object in the way that
Java Script talks about immutable empty
objects it's something where you can
extract a value from it and if it's not
there you get Mol and so you can write
long dotted expressions this dot dot dot
dot dot and if any of those things isn't
there at the end of the expression you
will get null which is just what you
want and that would be easily
implemented in some future language
where we declare a constant which
contains an object that mechanics
nothing which is immutable how
functional programming has become very
very popular in the last few years
because it is the solution to some
really significant problems that we have
and beyond that there's a school of pure
functional programming in which we're
using functions the same way mathematics
uses functions although on mathematical
functions a little different they're not
about computation they're about mapping
about mapping one set of values to
another set of values but it were to
income computation so it's a a similar
thing but a different thing so one of
the things that you can identify about
pure functional programming is that any
input to a function will always yield
exactly the same output which is a
really nice property or having a
function so you can have no mutation no
side-effects the only thing you can do
is produce a value and return it so this
provides huge benefits in testability
because functions now become really easy
to test if you've given anything input
you're guaranteed you'll always get the
same output no matter what else is going
on in the environment that's a really
good thing so you can't have spare your
spurious errors show up later you get
very nice composability you can take
functions and put them together in
really interesting higher-order ways
that you can't do of side-effects are
going on and finally maybe the biggest
benefit is parallelism the problem we
haven't with threads is that if you have
two threads that try to read modify
write the same memory bad things happen
we put locks on that to try to prevent
that but that causes other bad things to
happen
and performance degradation but if the
functions never read-modify-write which
they can't because they can't mutate
they can't have side effects everything
runs full speed and so you can get huge
improvements in performance so we can
turn javascript into a pure functional
programming language just by removing
the impurities so for example we need to
get rid of date because it turns out
every time you call the date function
you get a different answer that's not
pure so that's got to go how random same
thing every time we call random you get
a different answer that's not pure so
that goes the delete operator removes
things from an object that that's a
mutation we can't do that object at the
sign and other functions which modify
objects they have to go three dot splice
and all of the other array methods that
modify arrays they have to go array dot
sort could have been a pure function but
it isn't it should have produced a new
array in a different sequence but
instead it mutates the older way so
that's not pure so we get rid of that
the exact function has to go assignment
you can't do assignment anymore because
that's the thing that cause of
side-effects so that's got to go of the
VAR statement we gotta get rid of that
and all that statement constants okay
though constants very compatible with
pure functions for loops have to go
because four is trying to change the
induction variable in each iteration
that's a mutation users turns out every
time a user got something it could be
something different that is not
mathematically pure so they have to go
and the network every time you read the
network something else is going to
happen so you can't that's not a
mathematically pure thing so that's got
to go as well so the difficulty with
doing pure functional programming is
that the universe is mutating and if all
of your program does is computation
that's not a problem but if it's
interacting with the universe in any way
it is so I recommend that we try to be
as pure as possible as much
as we can but ultimately there's some
part of the program maybe an isolated
part and it has to deal with the reality
one of the new features in es6 was
generators which i think was a mistake i
don't think that it should have gone
into the language it's a very strange
construction with very odd-looking
syntax and it turns out it's completely
unnecessary but much easier ways of
creating generators in the language for
example here we've got a generator
factory it's a function that will make a
generator it has some state variables
and it returns a generator function
which will compute the next value but
the generator will return and update the
state variables that belong to the
factory so here's an example this is the
element function we'll pass it in array
and it will return a generator in each
time we call that generator it will
return the next element of the array so
this is a really a straightforward thing
you don't need loops we don't need
yields it's nice I think that's how we
should do it
callbacks are a really important feature
of modern languages because they help us
to manage a synchronicity they're like
the primitives in a language that that
provide that and there are two ways in
JavaScript that you can write a function
that will take a continuation it could
either be the first argument for the
function or the last argument of the
function and JavaScript doesn't care
it'll let you do it either way and
because you can let you can do it either
way people will do it either way and
then they will argue with each other
about who cut it right and for a long
time we didn't know who was right and so
we just have these arguments going on
and code that doesn't get together well
because of these different conventions
but es6 finally teaches us which one is
right and it's because of the ellipsis
operator which allows us to have
functions that can take a variable
number of arguments and that only works
at the end of the parameter list and
that means that the callback has to be
first so everybody who's doing it last
got some code depicts promises were
added to es6 and I think they were a
mistake they were originally invented at
a company that I founded many years ago
for a different purpose and while they
can help to manage a synchronicity that
is not the thing that they are really
good at and then unhappy with the wave
promises turned out in es6 but you don't
need to use them if what you need to do
is to manage ASIC Cammisa T there is a
package that I wrote that's available on
github called RQ which deals with the
kinds of ASIC Cammisa T that you need to
manage in real life it's really
straightforward and it's all about
functions syntax is the place where we
get most romantic in our in our
languages we get these irrational
attachments - bit of noise which
ultimately caused us problems and we
don't care because we just love the
stuff so much it's a really abusive
relationship so let me look at some
syntax over the years I'm starting with
Fortran 4 this was my first language
that's how we wrote an if statement
Fortran was developed before lowercase
was discovered so everything was all in
uppercase one of the interesting
conventions in Fortran was that spaces
were not significant so if you removed
all the spaces from the program it would
mean the same thing to the compiler and
so to keep if' a distinct from IFA
parentheses were required around the
condition of an if statement it also
established the very bizarre convention
of using the Equality operator as the
assignment operator which I think was a
big mistake and unfortunately it's been
copied into lots of subsequent languages
BCPL was a lovely little language it was
the first good parts language it was a
the good parts of a much larger language
called C PL and it was the first
curly-brace language and
had a very nice if statement so one
thing it corrected was the parentheses
around the condition were now optional
and the curly braces around the
consequence were required which was
exactly right
BCE PL was a big step forward
syntactically it's also using the
convention that I think was introduced
in Khalid all and some earlier languages
where spaces are now significant so the
space between the if any a is meaningful
in separating tokens JavaScript and
virtually all of the C languages
unfortunately fell back into the
JavaScript pattern so the parentheses
around the condition are now required
for no good reason
and the curly braces around the
consequence are optional which turns out
to be a really bad thing because there's
a important class of errors which get
made everyday by the omission of curly
braces so I recommend always put the
curly braces every if every else every
time get the curly braces some people
you have to go so hard but it's not it's
really easy to make the code much more
agile which we like these days L go L
Val sixty was the best programming
language designed by committee in
history it turned out so well they
decided let's do it again so they got
together another committee of extremely
bright people and unfortunately they
produced a level 68 not not nearly as
brilliant as as its predecessor but I
like their if statement but the language
itself is a cluttered mess but the if
statement I think has a really nice
elegance to it which is dude they
brought back the algo assignment
operator and equal is used for equality
with you know they corrected that
mistake and the government of blocks and
instead they use five and Balan see if
the nice thing about that is in a
language like JavaScript
we've got nested functions and nested
blocks and nested
objects everything is ending with a
curly brace and you go looking at a
program and you see this big long list
of curly braces and it's hard to
distinguish what does that match but if
some of them are matching functions and
some of them are matching its statements
and the five just makes the program a
lot easy to read so I like that and I
think we can improve on that even a
little bit more so maybe the next
language could look like this I think
Python has told us the value of having
line breaks be significant I think we
can get some benefit from that and there
was a lovely little language called
rebel which used colon as its assignment
operator which i think is just lovely so
maybe the next language would look like
that I hope it doesn't look like this so
this is a try statement from Java
obviously or c-sharp also obviously it's
a very what we want to have is to have
some code which might fail but we don't
want to have to test all the possible
failure conditions and so we end up with
quite a complicated structure and at the
end we have a thing that's called
finally which means that there are lots
of paths that you could take through
this code and no matter what path you
take we want to do this a little bit at
the end and the reason you need it
finally was because Java did not have
functions and so there is no place where
you could take your clean up code and
put in a thing where you could call it
from all the places that need to get at
it so there's an even bigger problem
that's being caused by the type system
all of these caches and the reason this
is going on is because the type system
is working against us that it turns out
that these things are not really
exceptions they're just other things
that could happen there are lots of
things that could happen but the type
system doesn't allow us to communicate
that so instead we're burdening the
exception system and using that as
another
control paths through which stuff can
flow because the type system is not
allowing us to write our programs
correctly and so we get really
complicated stuff because in most cases
these are not exceptions these are
normal things which we just can't we
don't know how else to do it
fortunately JavaScript does not have
these problems javascript has a very
nice type system which does not get in
the way of writing good programs and so
we do exceptions very differently we'll
try something and if that fails we don't
even care why it failed we just know
well that didn't work so let's try this
thing instead and it just gets so much
cleaner and nicer and you know I like
that we can see other places in Java and
in JavaScript where badness in the type
system leaked into api's so the index of
method if it fails to match the text it
should alert us somehow that it didn't
match but it's designed to return an INT
and it can't return something like null
something more meaningful that might
tell us that this didn't happen so
instead it returns minus one which could
be a problem because it looks like an
ordinary number which could get then
rolled into an ongoing computation and
bad things happen javascript repeated
this error even though it didn't have to
javascript has a type system which would
allow this to be designed correctly but
it didn't so let's look some more types
so we're going to add two 32-bit
integers what should be the type of the
result anybody any guesses anyone
yeah so what would that be it'd be a
1033 right I'm talking about truth here
we're talking about truth and the truth
is that okay let's try another one
so in 32 times 32 what's the correct
answer close it's in 63 in 63 is the
correct answer
so with plus Java is a little bit off
and with multiplication it's way way way
seriously off so the mythology about
types of students is that they're
protecting us from the formation of
errors but clearly in these cases the
type system is the cause of the error
that we see these sorts of errors and
they are really nasty errors where
something so much significant vanishes
and we're left with something wildly
negative and wrong without detection so
this is maybe our most reported bug in
JavaScript one plus point two is not
equal to 0.3 and this should be shocking
I mean listen this is outrageously wrong
but it gets even worse than this because
it breaks associativity so that the
order in which we add things can change
the result which is horrible how can we
reason about the mathematical
correctness of our programs if the types
that we're building on top of our
undermining of so radically so that if
the inputs to plus and it's output if
they are not represented exactly than
associativity is broken but these values
should be represented exactly because we
live on a planet that uses the decimal
system this is how we count our money
and it's really problematic that we're
using binary floating-point which cannot
correctly do this computation so I
proposed to fix it so I'm an advocate of
a new number type called Dec 64 it's not
a new invention it's based on a practice
that was developed in the 40s when the
first lemon machines came online
this is how they represented
floating-point or the invention of
floating-point happen in exactly this
format we've got a number which is
composed of two numbers a coefficient
and exponent and the coefficient times
10 to the exponent is the value of a
number so I want to bring that back
because it it solves this problem
correctly and doing it this way where
I've got a 56 bit coefficient and an 8
bit exponent is makes it very efficient
to do in software so there's a reference
implementation of it on github and I'm
hoping that anybody who is thinking
about designing the next language I hope
that you will incorporate this as the
only number type in your language that
in this package most integers can be
added in five instructions which sounds
like it's five times worse than ordinary
hints except that you also get Mane's
and overflow protection which are really
really valuable in a hardware
implementation adding two numbers with
the same exponent should happen in one
cycle so the excuse the performance
excuse justification for having in
completely goes away so and it works the
way we were taught to do arithmetic in
school and so we don't have surprising
results we don't have phantom precision
and the other problems we get with
binary floating-point so let's talk to
more about numbers so what is 0/0 any
guesses yeah so a lot of people
particularly if the mathematicians are
likely to say it's undefined which isn't
undefined in the silly way that
JavaScript means undefined it
it literally is not possible it's not
meaningful to ask this question stop
saying that it's not real it's not real
we can't do that but computers might do
it anyway so what should happen well the
machine can catch fire you know if you
decide to divide by zero it should catch
five because you should never do that
and so it should never happen right but
we know it will happen so we have to
deal with that there's one theory which
says it should be man or some other
sentinel value which says this is not
meaningful that's not a bad thing to do
there's another school that says it
should be zero in fact there are a lot
of business applications which really
want that you know if we didn't sell
anything this week how means we made no
money our profit per item was zero right
let's make sense in business there's one
school that says it should be one right
because n over N is one I would support
our mainframe where zero divided by zero
was - it was a mainframe that was
designed by Seymour Cray maybe the best
computer designer in history and I can
imagine had the control data if someone
came to see more and said Seymour we got
this poem with the division unit 0/0 is
too and he said if I imagine what only
an idiot would do that and if I fix it
it's going to add more circuitry to
divide it's going to make the machine
even more expensive and it's going to
add a cycle to division division is
already the slowest thing the CPU can do
making it slower for everybody to
protect us from the idiot who's going to
do that it's just not worth it I'm going
to leave it alone
and it worked as far as I know I'm the
only person who ever discovered that so
why do I bring this up it's because I'm
actually more concerned with this case
what is 0 times n
any guesses I would say it's zero I
think it makes perfect sense to say that
zero that there's no value and for which
that could be anything but zero
unfortunately the I Triple E floating
point standard says if n is man then the
result must be man the reason that's a
problem is that there were compiler
writers who knew enough about
mathematics to know that anything times
zero should be zero so if they have an
expression and at compile time they know
that one of the arguments is zero they
don't even have to generate the code of
the other argument if it is pure if it
has no side effects and that means not
only does the code get faster but the
compilation gets faster which is really
good but all of those compilers were in
error when this floating point standard
showed up because it says you have to go
ahead and evaluate that stuff anyway
just on the chance that it might turn
out to be Man which I think was a
mistake so who writes code like that
often
Youmans don't so much but code
generators do and not quote processors
partial evaluators and so all of those
things are going to be slower now
because we can't multiply by zero
correctly also they're non conditional
idioms where we'll say it turns out that
conditional branches in our modern
highly pipeline CPUs have become really
really expensive and you can avoid those
if you can multiply something by
something that might be a zero or one
and add it to something else which is
one minus that thing and so we can
actually make our programs go faster if
we could fix this so I would fix all of
these to do the same thing if we have
zero in any of those positions where n
is let's say it's a zero
Fitzgerald zero
I'm not so concerned about punishing the
wicked I just want the programs to go
fast and in fact the deck 64 format
requires all of these things we have
reserved words and our programs around
our programming languages and the reason
for that is that they made things easier
for compilers in low memory situations
so the first compilers were written in
machines with only you know 8 or 16 K
and they had to make everything work in
there it was really hard and having
reserved words meant that the compiler
didn't have to spend time or space
trying to figure out what the meaning of
some word was unfortunately there's a
hazard for programmers not if you
declare a variable or something which
accidentally has the same name as some
feature the language that you weren't
mindful of then your program fails it's
a problem for language maintainer is
because they can't add new facilities
which might collide with words that
someone might be using in the in the
field for example in exception handling
originally raised was going to be the
word that we would use but we're going
to raise an exception but we couldn't
because the word raised was being used
for other purposes
so they looked for a word that nobody
was using and they came up with Rho
which was a really odd word to use now
we've been doing it for so long that for
most of you throw probably looks right
because you've never seen anything else
but believe me it was wrong but it was
the best we could do so we can fix this
recognizing that we now have way more
memory than we know what to do it I
recommend a different reserved word
policy in any function a word may be
used as a language keyword such as if or
as a mean like a variable but not both
not both in the same function and the
programmer gets to decide which one it's
going to be this is good for programmers
because they will not trip over features
they don't use and it's good for
language containers because they can
introduce new features without breaking
existing programs
so here's another one of those things
camelcase or under bars again you can
throw this question in to a group of
programmers and they're going to scream
at each other and it's going to go on
forever
and there's no way to resolve the debate
because it turns out everybody is wrong
the correct answer is names with spaces
right yeah so um why don't we do that
again it's because a long time ago
compilers had to fit in that much memory
now we got that much memory we can fix
this now so I recommend a policy where a
name is composed of one or more text
atoms separated by spaces and starting
with the initial text atom will combine
text atoms until we make the longest
name that makes sense if nothing makes
sense when we just use the first one and
so that will allows to have names with
spaces which again I think is the right
way to do it there's a brilliant thing
that was introduced in the Eifel
language by Bertrand Meyer programming
by contract so he allowed for the
inclusion of preconditions and
postconditions in a function or method
the preconditions would be would be
assertions which could be evaluated as
the function is called and so it can
guarantee that everything that this
function needs to be true in order to
work correctly is in fact true and then
there post conditions where you can
state everything if this function worked
correctly then these things should also
be true the preconditions do a much
better job than types in helping us to
identify if things are written correctly
because these contracts can be much more
specific and types will ever be and the
post conditions provides a really nice
way of thinking about testing where much
of the testing apparatus
is built into the program itself and we
can turn either of these on or off I
think generally you want to leave both
on all the time because they really
don't take up that much time and our
computers of God was so so fast if it
ever turns out that that's not the case
and you can turn them off but I doubt
that that's ever going to happen
I would really this was one of those
ideas that was so powerful in and so
valuable that somehow I've got forgotten
when we went chasing objects we
completely forgot this I'd really like
to see this incorporated into the next
language we need to get much much better
at security we've got all these
distributed systems and and our systems
are touching everybody now in all
aspects of our lives and we still see
these ridiculously unnecessary security
exploits happening almost every day and
it doesn't have to be that way we should
have security built into the structure
of the language so that it's much harder
for us to do things which are smart or
dangerous or bad so I would like to see
the next language whatever it may be
deal much better with this problem and
then distribution so since most of our
languages there are only a few
exceptions like Erlang and maybe Scala
most of it and go most of our languages
are sequential languages basically the
Fortran model where we do one thing
after another and that's if that's what
the program does that's not how the
world works anymore we now have lots of
cores available to us which all want to
be running at the same time on our
sequential programming model really
doesn't fit on that and even more than
that we now have our computations
potentially going out over the network
into the cloud or whatever that is and
so the program wants to be distributed
over many machines maybe over thousands
of machines and we're real angwa jiz are
not good at that we do not have
effective tools for writing that kind of
so I hope that the next language
whatever that is is not just going to be
new syntax on Fortran but will
fundamentally help us to deal with
distribution so those are my thoughts
about what we should be looking for in
the next language I hope that the next
language sparks joy and doesn't do
anything else so I want to leave you
with this warning please be careful out
there
the web is cluttered can full of errors
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>