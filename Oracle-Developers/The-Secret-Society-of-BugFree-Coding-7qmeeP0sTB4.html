<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Secret Society of Bug-Free Coding | Coder Coacher - Coaching Coders</title><meta content="The Secret Society of Bug-Free Coding - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Secret Society of Bug-Free Coding</b></h2><h5 class="post__date">2015-06-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/7qmeeP0sTB4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you for coming my name is Lauren
drew and I'm the product manager for
NetBeans and with me here is martinet
Laika he's in the software engineer from
developer tools organization based in
Prague so before I start just very
curious how many of you're already
members of the secret society of both
free coding all right thankfully yeah
that's good because we kind of just
instituting it now kind of made it up so
it'd be a little scary if there's
already a society in place but there are
quite a few societies like the secret
society if you've gone to Wikipedia or
the web does help launch secret society
so that's took me down a track that was
quite interesting anyway in this session
we're kind of looking at is bug free
coding a myth or a reality and and I
think the first question I have take it
off the table right absolutely but free
coding is definitely gonna get met but a
sense I think of this whole session here
is can we prorate a now ourselves or at
least inculcate some habits that comes
close to it and how do we do it easily
and in what way so that's kind of what
we're going to be talking about the
focus will be on trying to see how what
you can do in trying to eliminate bugs
and well how do tools help you with that
that's pretty much primary purpose we're
going to do a little bit of kind of a
talk on this on the processes and we're
gonna have some demos from the tools so
with the obligatory legal slide kind of
indicating that anything we talk about
from a roadmap perspective cannot be
used for changing information with I
don't think it's going to be the case
we're going to talk about all the stuff
that we already have today let's get
into this
I kind of said the membership for the
society is really about being exclusive
and it quickly reserved for those who
have the single-minded you know passion
for delivering bugs for the least but
delivering software with the least
amount of bugs right so that's pretty
much what the whole emphasis about is
can we go ahead and try and do this and
how do we do it by the way that image
over there the bug free image is
actually taken from a website that's are
actually too software for algebra
learning algebra and they have an algae
barn cockroach kind of game where you
want to eliminate as many cockroaches as
possible as long as you do your algebra
right that's a pretty cool thing but in
I like the image because I don't know
how many of you know what was the
earliest bug any any ideas about what
was the earliest bug in what was bingo
thank you sir the answer over here I'm
sure others hadn't it's actually was a
moth you know in any kind of an
electronic mechanical computing device
right so it was coined by Grace Hopper
and it was actually discovered by her
and in 1946 this was literally the first
kind of bug potentially in software
development
so with that interesting factoid aside
why do I want to talk about it I started
my career in the mid 90s developing
software for in the defense industry
command and control systems
predominantly using a DES any aid our
users yeah all right still using a DES
not recently
okay and a large part of the emphasis
for us you know the metrics that we used
was pretty much coming close to zero
defect code all right I mean we didn't
want our systems failing when you're
trying to shoot down Amaziah that's
coming at you at Mac 22.0 and things of
that sort so there's a hell of a lot of
emphasis on with that but there was also
some issues with that model right
the overall deaths offer delivery
process you know Spaniards we did you
know design work for three years before
you even started doing any prototyping
we pretty much actually put it coded for
about a year or so and then there's
another four to five years of testing I
mean that's kind of some of those cycles
that we have clearly not something that
we can replicate in the commercial side
so when I move to the commercial side I
realize you know time to market is an
absolute issue right you've got
something you've got an idea you want to
deliver it and the focus has been on
trying to get that software out pretty
quickly but interestingly when you look
at actually managing the course there's
so much a cost associated with not doing
things correctly and just trying to get
the software Earthquake we can kind of
probably get into that a little bit more
in the next couple of slides but the
long run is you know we've seen with our
own project working with NetBeans I'm
going back to NetBeans three and so on
and so forth we were trying to get out
products we were trying to get out the
IDE with a lot of features to compete
with some of the ideas in the market and
three to five there's a lot of
performance issues
we got features out we realized there's
a lot of performance issues and we
realized that was one of the key
indicators in terms of adopting and that
means itself we then went through a
really techniques we actually went to
redid all of the stuff that we had to do
to make it more performant it was
fantastic we got a really good NetBeans
for release of 5 and pretty much we
spent a lot of time but we actually lost
out a little bit on the mindshare so
that's a cost associated with not being
able to kind of put in practices and
processes and using the tools to provide
software without many bugs and I don't
know how many of you are familiar with
this this is again publicly available
information this is actually a slide
from Barry Boehm in 2007 but there are
lots of studies letters I brought this
up because this is kind of a general
generic representation of really the
software cost but it's it's very very
this was ingrained in
to us during our development days as
well early in the 90s I mean literally
if you could actually detect a bug or an
issue in in early in the phase it's very
easy to fix
as you start designing it gets a little
you know the cost associated gets more
why because are more people involved the
most often
plat morph software modules are involved
and so when you catch bugs in the coding
phase that's pretty much quite a very
quick fix and it's a cheap fix as soon
as those bugs get out into the jungle
available versions of the software then
there's so many things involved there's
escalations there's issues of people
manpower required to fix it and quite
frankly a lot of bugs that get in these
days it's hard to get that out of the
system they may not be priority one
button spritely to bugs but a lot of
things that essentially affect the
quality of the software it's hard to get
out of the system it's a it's it's a
tough battle for us within the NetBeans
organization to fight that you know
we've got we've got constantly who we're
trying to set up our metrics to kind of
get some of some of those bugs that have
gotten a few years into the cycle out of
the system so there's a massive cost
savings involved in trying to do this a
little better spend more time and
effectively probably invest a little bit
more early in the cycle when you talk
about the entire cost associated with a
life cycle of yourself a product that's
hopefully that's something that was
really vital I think it's some it's an
experience that I've kind of gone
through with my 10 13 years with the
NetBeans organization in various roles I
think it also is a matter of credibility
I mean just the same thing about you
know if you have some a really good idea
and you build that in and that lots of
bugs in it you lose you get the
mindshare initially but you lose a bit
of credibility somebody else comes in
and makes a bad quality software with
the same thing and the customer
satisfaction needless to say is an
important aspect of all of that so what
is my basic
you know what's my basis for you know
talking about this it's actually very
simple right
it's there's nothing very complex about
it something's that we know but there's
certain things we can do better and
apply the processes to it now from a
pure source software life cycle stage
there's a lot of emphasis you can place
in in each of the phases right so when
even the life cycle you choose whether
it's gonna be waterfall or whether it's
gonna be the spiral model at these days
it's a child development all of them
especially with agile the emphasis is on
time to market getting smaller features
done but they'll essentially also expect
that you place certain value in ensuring
that you're developing real high quality
software so it doesn't matter which
lifecycle you pick I have these
discussions with people were saying you
know with agile development time to
market is important but it's okay
because you know sometimes we might get
in some bugs that can be fixed later and
the methodology itself is not suitable
and I I think that's not necessarily the
case and as you know a good requirements
management system will help and it's
essentially making sure that whatever
you're trying to address you know meets
meets the requirement that you had it
there in the first place and the design
phase for me is also very vital I've
seen a lot of teams starting to
prototype but in essentially doing a lot
of refactorings after you've got your
first versions out because there are
certain design issues with with with
whatever you got there in the first
place so a little bit of additional
effort there not to the same level that
we probably did back in our defense days
or my defense days at least
but somewhere in the middle would save
you a lot of course but having said all
of that my premise is that the bare
minimum you need to do as developers is
kind of focus on these two areas right
coding and testing and what you would
have to do in essence is to be able to
leverage some of the best practices and
tools in this space so
I wonder this is an interesting kind of
website it's actually sponsored by the
department of cybersecurity and
communications you and the US Department
of Homeland Security it's kind of geared
towards security related issues and
software but how many of you are
familiar with this all right okay so
it's kind of clear that many a time when
we were when you're trying to kind of
create software we kind of ignore some
of the basics that you might do and
sometimes you don't learn from
experience so this website essentially
is trying to capture that it's got a
whole listing of different types of
errors or issues of wrong ways of doing
things when you're when you're writing
software and how do you prevent it it's
it's pretty useful and and there are
lots of other tools that we're going to
talk about that kind of leverage some of
the principles from this source to flag
it in your development environment early
but this kind of learning from
experience is what an IDE provides now
fundamentally the other thing that I've
we kind of noticed at least is that many
of many times rightfully people expect
the idea to be really intelligent editor
which is good but more than that they
wanted to be efficient and fast there's
still a lot of people who said you know
I would love to use just sublime or some
text editor and I'd write really quick
code the point here being that's all
fantastic
and that probably allows you to deliver
code very quickly but as we as we talked
about earlier if that code has bugs in
it in a sense until those bugs are fixed
that's that's pretty much when your job
as the the contributor of that software
is done right in reality in a
theoretical mindset in a practical
mindset you just probably dump it in it
goes in and somebody else is trying to
fix it through you know to support
maintenance in elsewhere in the life
cycle so and I did an IDE brings a lot
more value than just being a very
efficient editor
and I think it's it's important that we
take advantage of it
so most people expect this this is
pretty a pretty much simple and you
would kind of definitely I would you
know exceed anybody here saying oh this
is relatively simple stuff it can point
out but what we're going to see is there
a few definitely cases where as you're
writing your code you're can actually
leverage the experience of the industry
which is provided to you by these tools
like NetBeans unlike the other IDs as
well that point out a few things I mean
for instance as you'd I mean you could
get hints about the fact check for null
point access the fact that you try to
know that you could probably use a
string but you know little swim before
the stringbuilder all these enable you
to kind of stop getting that experience
that bit of know-how into your code as
you as you're writing it so that's one
of the things that we look at the next
aspect of it from the stand point is
really about static analysis tools how
many of you are using static analysis
tools over here alrighty so fine bugs
for me is one of the things that we've
integrated there are other two tools
that we have PMD is a project that's out
there and fine bugs is an open source
project and what we what we have done
essentially is to leverage the open
source project and try and make sure
that more of these more more of these
learning from experience aspect of it is
in the IDE so what does it do it
essentially identifies things for bad
practices security that they're some of
the issues that's outlined in the
website that I showed earlier and also
many other aspects of performance
related issues that that it's it flags
so with that being said when I did these
and I did this talk in a couple of years
back one of the key feedback that I got
was it'll be great to kind of see some
of these tools in action so I've dialed
down a little bit more on the process
aspects of it as I did last year and
I've kind of wanted Martin to kind of go
ahead and show us some of these things
in action and we'd start slowly and move
through some of the tooling so however
we look at a little bit of the static
analysis and find bugs
you know now we use it okay I need to I
need to apologize that I will not be
able to look into it into the audience
because I had a problem with monitor
mirroring here for I do not see what's
actually on the projector so I need up
with challenge to turn around okay the
static analysis is in that means the
first thing how you notice this is are
the hints in the editor it's always best
to correct the issues immediately during
the development when you still have your
intentions in our mind and when you need
to make some corrections after several
weeks or months you initially need to
refresh how the core works and what did
you had in your mind when you wrote it
before you can do any changes therefore
as soon as you write the code you get
notifications they are displayed as
small yellow light bulbs and the two TV
show you the problem which was found you
can when you click on the on the hint
you see the description and you can do
several things with this you can either
apply the hint or you can disable this
because you might not be interested for
example in this this particular hint is
about exchanging generics generic type
with the amount operator it was
introduced in JDK 7 and this is a kind
of new language feature hence so if it's
not really important for you you can
disable the hint altogether
or you can configure the hint it will
navigate you to the options where you
can see the hint and several options
that you have this these options also
lists all other or other hints that are
in that means ID that you can use you
can not all of them are turn on by
default because of performance reasons
and and usability so this this is some
suggested set but you can customize it
of course you can go there at any time
from two options
navigate to editor and hints and another
option what you can do is with the hint
is to suppress this warning it will
automatically generate the suppress
warning connotation with the proper with
the proper text here if we go back we
can we can apply the hint right here a
next legs and from from this set of new
language features hints are is multi
catch when you have a code like this
when you need to catch several
exceptions and all exceptions are
handled in the same way it's much more
readable when you use multi catch which
was introduced in JDK so on therefore
the hints will help you to use the new
features which were introduced in in New
York JT case and the code is also much
more readable and when you need to
change it you need to change it only on
one place therefore it prevents you from
further issues for the box that can be
introduced next we have somewhat more
important
hint when you work with streams you need
to catch exceptions that are thrown from
the streams from the operation performed
under streams and you use try and
finally books for that it's very easy to
forget to close the stream in the final
book
therefore in starting JDK 7 you can use
Triwizard resources which when we
applied it the final book is gone
because when the try accepts closeable
which assures that the tribe with
resources assures that it's closed after
some problem of course or after the
block is finished so again it's a it
prevents you from further problems or
for from some omissions I have prepared
this simple application which is some
address book very simple address book
application just for the purpose of this
demo and now let's forget about other
hints we have there and try to run it
it should start ah
it started on there on another monitor
I'm sorry okay here we have it and is we
see that there no no people in state
although we have already put there some
therefore we see that there is some
problem in the application so let's go
to the code again and see if there are
some more hints that will help us to to
find out what's wrong there here we see
that there is another hint that local
variable hides a field this can cause
problems when you when you actually my
reference by a mistake the local
variable and and the field we see now we
can see that this is actually reference
from a field and this this is the local
variable so to prevent from this very
name the local variable it's a person
name so for example B name and because
this has reference the field value it
didn't trim rename so we rename it as
well and now we see the problem the
error that this doesn't exist in this
context because it's local variables
defined inside the scope inside a cycle
so we need to copy the declaration it
can be here doesn't matter
put it yes it's better to have it here
we did this okay so we have found out
the problem this has cost an infinite
cycle in in the code simple bug and
thanks to the warning we have found it
out there is a similar similar issue
with the phone so we can rename it as
well okay now when we run the
application yes again started on the
other monitor we see that now it works
that it displays the two two people that
we have had already there and it but it
displays their phone numbers so it looks
like it works but let's look at the rest
of the warnings we have here the next
one is the forensic possible node
pointer it's about P variable and now we
see that we have a condition for P being
now but when we added the login code
later we completely forgot that we can
be now and we just call some name on it
so we but but the application worked
fine so we can look at when when this
happen where is the code called from
it's some instruction listener and we
see that when the selected value is now
this this fires a problem here so when
we run the application we see that when
it's selected it's okay but when we
unselected exception is around here and
we see that it's really in the logger
code therefore we have found out some
real problem
in the application which didn't reveal
during testing which can occur under
some special occurrences - to the users
so we fix it again by testing the the P
here like this
okay and we also see the warnings that
are defined in the file in this right
strip so that it's easy to to find if
there are some remaining the last one is
performance it's about stringbuffer
which is used in one thread and since
sing string buffering synchronized it
adds an unnecessary overhead and it can
be safely replaced with string builder
here okay so these are the built-in
hints that we have in that means we have
also integration with findbugs
it can be found from sources inspect
when we have several analyzers when you
select fine bucks it will automatically
install the find box plugin and when you
inspect the code it finds some some
further problems this is a reliance on
default encoding this makes problem when
the application is used on different
systems with different encodings than
the files that it can exchange will not
be able to be opened in a hundred
different encoding so this can be fixed
by adding adding stream reader with this
and encoding
Oh
there is some yeah there was the problem
okay so now we're inputstreamreader
that takes file streamreader and we will
define some encoding for example for
example utf-8
there's
yes so it's corrected and the next
problem is inconsistent synchronization
fine box found out that you have this
field accessed from two methods one is
synchronized and one it's not and this
can cause erase conditions in your code
this kind of bug is not really easy to
find out because it caused random
behavior of your program for things to
find bugs we can correct it and make
this synchronized as well we run this
inspection again and okay now it's empty
there are no more problems
when static analysis doesn't find any
further problems it doesn't mean that
the program is without any issues it
doesn't file found problems that occur
on real time for example when you
calculate some array index and you
reference an array is that index it
cannot be found during static analysis
that this index it inside the bounds of
the array so issues like this cannot be
found by static analysis but it helps a
lot
to find out of many many problems that
are easy to overlook
thanks Martin so I guess one of the
things that we have found out from our
own analysis of the stuff the the bugs
that we've had a lot of the stuff that
that's out there and that it's taken a
lot of time for us to fix later on could
have been prevented with better use of
the tools like an ID such as this I'm
not making I mean clearly from my
perspective will be great if you try and
netbeans out if you haven't already
tried their pins out but it's really
about any integrated development
environment there are some simple things
that you can focus on and that means a
lot of bugs actually can be prevented
getting into the system because it takes
a lot of effort to do that so we will
come back to a couple more demos so what
we've looked at is really why you're
writing code how do you leverage
experience and experience is being
provided through the analysis as the
hints as well as through things like
static analysis tools now this is
something everybody wants and knows I'm
not making any presumption that this is
new right but there are some interesting
things that we've done with the
debugging environment in NetBeans that
we would like to show you but also we
want to kind of highlight the fact that
dominantly a combination of this and the
next topic that I'm talking about is
something that's missed by a lot of
teams might we were for instance I was
so used to actually be owning my unit
set of my code or my module and provide
pretty much gross 100% code coverage
from a testing perspective profiling
that in its own unit and and looking for
performance related issues or any other
kind of issues including deadlocks
that's not really being done by a lot of
teams people just actually put that in
and then it's you know you expect to do
you know figure those things out at
system testing or during even sometimes
even closer to customer acceptance type
of testing right so if you do that
earlier on there's a lot of benefits and
that's kind of what we will show you the
debugging but more importantly profiling
now many of the ideas including us have
a profiling capabilities inbuilt
it's an excellent idea to actually
leverage this to be able to profile at
the unit level what you're doing and
then be able to figure out some of the
issues that might that might be there
sometimes it's very architectural in
nature so some of the some of the issues
that we find you could not just be a
simple issue of the code that we've
written it could be because of the
design and if we catch that early we
could actually probably figure out what
needs to change and it typically means
that some of the software or the
designer other aspects of the system has
to change but that's something that you
can do earlier on in the cycle and it
becomes harder and more expensive to do
later on in the cycle so from that
perspective I guess we'll just switch
back on and have Martin go ahead and
show us some things that pretty useful
okay interesting things that we've
learned from thinking probably everyone
knows how the bugger works and most of
the developers have some debugging
experience therefore I don't think that
it's really necessary to repeat that
debugger essentially allows you to step
through the code avoid variables or
expressions examine call stacks and etc
but I would like to show you some
advanced debugging that is possible with
NetBeans and which which help you to get
better insight into the code into how it
works probably everyone has ever written
a code with some long expressions like
this and when you are writing it it's
perfectly clear what it does but if you
need to get back to it after some time
it can be hard to recall how it really
works or in other cases that you need to
deal with code that was written by
someone else this this is a simple
method that calculates intersection of
two rectangles so we have a simple my
method for it
and try to go through it if if it to
find out what it does so run it on to
under debugger it's it's double here so
let's step into this method and when we
use step over we see that it just goes
over the whole expression so it didn't
help us at all to see what's going on
inside
step over on the next expression goes
out of the method so so step over is
unusable in this case so we try to debug
it again and to step into in this case
most debuggers have a possibility to
select which method you would like to
step into but usually they compare it
just by the method name in that means
you can really select which particular
method you would like to step into and
that wean steps into it regardless of
its name you just find out the the
correct location in in the in the
expression now the reason why some
methods are blackballed and some our
gray is that there is a condition and it
indicates you that this method might not
be executed because it depends on the
result of the first expression but
during this the power of you know that
it didn't return now here therefore the
whole expression was executed when my
goat try to work try to go into for
example this garrix here and it get gets
us into the rectangle when you go to
local variables we see the rectangle is
this one which is the which is the art
too so it's it looks like it's in the
correct method it's it didn't go to the
r1 which is different so now we go out
from this and we see that we are stopped
Freeway at the place where we wanted to
be and we see the return value from this
method therefore it's easy to find out
how the expression is executed and what
individual methods are doing in in the
expression when we do further step into
we see that the rest of the methods is
suggested first step into but you cannot
go back anymore because these methods
were already called for example you can
go to get ex wrecked on back you see the
direct own values you can also see the
return value here in in the variables
okay so that was the first expression
and now we have again something that
looks but not really nice if we would
use this approach and to you step into
into each of these method it would be
really painful and we would probably
need some extra notepad too
to mark the resulting values of the
methods to be able to comprehend how it
works
that means has a special step for for
these long expressions which is step
over expression it will automatically
when used it will automatically select
the first method that is going to be
executed you can see the list of
arguments if there are some in this
method there are no arguments and when
you go across this method call it will
automatically find out the return value
and it will select the next next method
call if you do it again you are here on
the max you see the two arguments and
you can also verify the return values
from these methods so you can
efficiently go through this method
through this long expression it it's
like if it were to be written separately
on each line that you would you step
over in ordinary debuggers here you
cannot use the power but you can use
this special special stepping - that
helps you to find out how it's going how
its executed if you go through the whole
expression it's finally on the
constructor of rectangle and you see all
arguments and you can verify all
intermediate intermediate results so
this is what what helps you during
during bug fixing and also during
development if you would like to verify
that what you wrote is actually correct
you can do it very easily and you do not
have to do some some other
special special things also the it's
it's also good when the debugger detects
deadlocks data that can occur in your
code
I have just a very simple example for
this just to show you that the network
detection works is just simple simple
application that I have that has two
logs and they are taken in different
order when we run it under the debugger
it doesn't proceed any more when we just
pause it we should see
yeah it it has shown that the drug was
detected here and it lists the blocks
which which it acquired and which it is
waiting for okay so it's deadlock
detection and for UI UI stuff that means
has a nice tool which is a UI designer
it looks like this and you can
efficiently design UI in in this using
call swing and AWT components and it
will generate essentially a bug-free
code but if you cannot use this for
example if if your UI is created
dynamically during runtime or when you
are dealing with some code that was
written by hand without such a tool you
can run run under debugger you can use
location is here you can use special
camera icon cover action that will take
UI snapshot of of this application when
you use it it will create a snapshot and
you can see the individual components
that are in your application here is a
layout tree of components and when you
select some you can immediately see
where is it in the UI and also you can
see the list of properties for every for
every component there are several
navigation actions you can go to the
decoration where this component is
declared in your code when we use it it
automatically navigates us to the to the
field where the where the component is
declared
and we can also go to the component
source this is a jtextfield therefore we
are navigated to the to the jtextfield
and we can also find out where this
component was added to a hierarchy
therefore if the component there is some
problem the component should not be here
or there is some layout issue you can
use this to be navigated to the place
where it would actually edit to the to
the structure here we have group layout
so it's it's just wrong one quest of
components at it the our component is
added here
therefore we immediately see how the UI
is was created there is some also other
other things for example you can view
listeners that are attached to to the
component here we have only some swing
listeners but if he sucked for example
this Add button we see that we have
encode this listener this inner class
and we can go to the component source
and we immediately so see the place in
the code where the action is handled so
it helps you to grasp how how the UI
works how the individual actions are
handled and and so on ok so this is the
but about debugger so I will proceed
thanks Martin I guess you know
the whole point here was that it's
really a simple thing and I still
earlier in the cycle early on the
presentation that it's it's really about
ensuring that you firstly figure out you
know where you want to spend some more
time on understand that there's value in
spending more time in a little bit more
than in the design phase itself because
the earlier you catch some of these
issues the better and while you're
coding leverage the experience and also
be able use these tools you know much
more effectively it's quite surprising
to me to have seen a lot of people use
an IDE just as a you know an editor so
to speak is writing quick code but not
necessarily make leveraging the
profiling capabilities and things of
that sort but Martin you didn't have
something assure profiling as well yes
yeah that's the one last aspect that we
wanted to kind of highlight was you know
that although this is probably a little
bit more difficult for everybody to use
on a regular basis it's I think a key
thing that you can focus on is to make
sure that you're able to profile your
code specifically I thought if I fax you
forgot that you had to do that okay so I
have a very simple program again just
just for the demo it it generates some
some lists of persons and it it does
some tests on them and there is also
some some caching of the result of the
test so when we run this under profiler
let's let's see if there are some memory
leaks in this application for example oh
let's use the advanced instrumented
profiling with recording of stack traces
so so that we see where the objects are
created from when we run the profiler we
can use the results to see which which
classes and how many how many objects
for each class is there
and there is a nice thing number of
generations when we sort this according
to number of generation we see that it
essentially split it into two parts one
is weak this big number of generations
and one part is low number of
generations what it means that when the
number of generations is low it means
that these objects were garbage
collected very quickly these are quite
new objects which were generated but if
you are looking for a memory leak you
would certainly want to look at objects
which with high number of generations
which survived the GC so this reveals
some problem that we have increasing
memory consumption by by these long-term
objects we can also look at the
telemetry overview we see that the
memory is occupied still more and more
and that the garbage collection have
problems too
to clean up the heap so to look at
what's happening there we can dump a
heap it takes a while to to create the
heap dump and then we open the hip dump
in NetBeans to see yeah it was created
and now we will open it now we can close
the application so that the CPU is not
consumed by by running application
and when we go to classes we found out
the classes which were problematic as we
found out from the number of generations
so one was this person class we can show
the instances of this class in instances
view and when we select some random
instance we can see back references it
takes a while to compute them here we
have a progress bar for that yeah now
they are computed and we can find a
nearest GC root this is the actually the
place where is the object held in memory
this also takes some time especially
when the heap dump is big but it's going
on and the GC root will reveal the
problem why this didn't why this is not
freed from the memory so here we see
that is this filled in in this class we
can navigate to the source code so that
we see that this this is causing some
problem this set we can show this in the
instance view to see how it's actually
big it has a map and when we look to its
size we see that it's really quite a big
quite a big size therefore we have found
out that this map is simply growing too
much and it starting to occupy all all
the memory therefore the problem was
that
we we have some caching here for
performance reason why we didn't realize
that the cache can occupy too much
memory and in some cases it it can be
enough just to do the tests again and do
not do caching when when the number of
objects is so large therefore when we
comment this out we'll try to run this
again under profiler we can write on the
application here again we open refresh
outs and sort it by the number of
generations and now you'll see if if it
go down after some time it's again
slightly split but yes if after some
times the number of generations is
reduced that means essentially that the
objects were garbage collected and then
it doesn't grow indefinitely anymore
we can see the overview of the heap and
we see that now it's flat that it
doesn't grow and we can see this also
from the number of generations that
there is no more no more leak we can
also run the garbage collection from
here it was it was reduced therefore we
have solved the memory leak just looking
into the profiler ok ok so to kind of
wrap this up taking advantage of and any
kind of an IDs like this allows you to
write efficient code emphasis you know
that you can place on is just not just
about writing code quickly but you know
you know
with higher quality and it has a longer
term impact for the software for time
tomorrow well time to market is a bit of
a challenge but in terms of customer
satisfaction and credibility and so on
and so forth and mostly the cost it
would be fantastic so if you if you look
at it from that standpoint we do have
some other capabilities that that's more
in tune with you know making sure that
you're doing that unit testing
effectively this is a separate domain on
its own I think a lot of you are
familiar with this anyways but we do
have support to genuine it a test energy
and one of my pet peeves is that people
don't place a lot of emphasis on doing a
fair amount of code coverage when you're
doing the testing so play some more
emphasis on that try and get to see that
you do a lot more code coverage I love
the concept of essentially writing your
tests before for all the requirements
that you're that you need to address
writing the tests beforehand and and the
ID helps you do that actually so that
generates the test for you and and work
with it but that's kind of it it's as
simple as that
I mean if you can leverage that
congratulations you kind of now you have
all the required know how to join the
secret society about free coding it's
really not nothing anything beyond this
just apply the tools that's on hand and
just focus and spend more time and that
would be it so thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>