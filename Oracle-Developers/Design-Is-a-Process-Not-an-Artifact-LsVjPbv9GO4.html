<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Design Is a Process, Not an Artifact | Coder Coacher - Coaching Coders</title><meta content="Design Is a Process, Not an Artifact - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Design Is a Process, Not an Artifact</b></h2><h5 class="post__date">2015-06-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/LsVjPbv9GO4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good afternoon and welcome everyone I'm
Trisha gee I'm a Java developer for
mongodb I work on the Java driver and
not that surprisingly however this talk
is not going to be very much about
MongoDB who's using MongoDB anyone Rosie
were you expecting some MongoDB code ok
because if you are you can leave that's
ok I won't be offended and it's also not
actually going to be very much about
Java don't tell the organizers of Java
one because I sort of snuck it in it's
about software design and hopefully this
is a subject that we all care about as
software developers / architects /
vaguely technical people now if you've
done any sort of formal study on the
software delivery life cycle maybe at
University maybe as part of your job
mainly some sort of certification you
might have seen a sentence like this
design translate the requirements in a
specification that describes the global
architecture and the functionality of
the system and maybe if you got to the
end of that sentence you'll be thinking
that the idea of design is to take some
set of documents the requirements
documents and translate them through
some mystical process into a set of
technical documents and then once that's
done you can get on with the fun stuff
the actual coding of the system forget
about it and this is from the white
paper which sort of effectively spawned
the waterfall methodology hence the nice
waterfall e-type picture please don't
try and read the words because it's not
the point the point is that at each one
of these stages there's a set of
outcomes a set of artifacts at the end
of it for example the described
operating procedures for example and you
look at something like this and you get
the idea that at every phase of the
software delivery lifecycle the output
of that is a set of documents or a set
of artifacts and so we kind of this felt
a bit heavy weight and we realized very
quickly that as soon as you've written
that document when you start writing any
code it gets out of date almost
immediately so we come on to agile
design
well we didn't really do a lot of design
when we were doing agile when we did we
did it but we stopped talking about it
so we did things like live in
evolutionary an emergent design we have
self documenting code so that word we
don't need documents who actually has
self documenting code by the way
excellent the rest of you have documents
or no documentation and so agile design
we stop talking about design we don't
talk about how to do a gel design we do
do design we just don't talk about it so
I I posit that design is a process not a
document it's not something that you
write once and dumped in a corner
somewhere and then forget completely
about it it's something that we're
always doing is we're writing code when
we're making a decision over what do we
call this variable where does this
behavior live what does this method look
like should I put it here or should have
put it here that's the process of us
developers doing design and we're doing
it all the time just because we don't
write it down in a document it since of
word format and share it amongst our
colleagues so that they could not read
it ever doesn't mean that we're not
doing design Oh incidentally this talk
on the agenda is called design as a
process not an artifact until I found
out that the Americans spell artifact
differently to the Brits and it got bit
confusing so I changed the name of the
talk right so I want to walk through a
real life example of of this process of
design now I've worked in both the agile
world where we had self documenting code
and an emergent design and have worked
an environment where we had very formal
design process with actual physical sign
off so we had tech specs and so forth
I've worked in both of these sorts of
environments and I was trying to sort of
bring all of my knowledge and expertise
such as it is into designing and helping
to develop the new MongoDB java driver
now the good thing is this is open
source so you can download it look at
the code and decide whether I'm any good
at design before you decide to do
anything that I save today
so I joined MongoDB about a year ago and
are well my job is to work on the Java
driver I made the same sort of situation
that a lot of you guys probably have had
whenever you join a new project so I'm
on a new project new domain new team new
everything and I have confusing
architecture I have code that IntelliJ
is screaming at me think please don't do
that that's not cool I've got a set of
defects and bugs like any software and
and feature and requests and
enhancements which need to be
implemented it as part of the new driver
or the existing driver and of course all
the time the server is is constantly
evolving so we have new features going
into the server so i have to add new
features into the driver as we go along
otherwise you're not going to upgrade
your server if the java driver doesn't
expose those things and of course we
have all the normal constraints you have
whenever you're delivering anything so
we have you know limited time resources
expertise knowledge of tools so on and
so forth but the main constraint that we
had was this one of backwards
compatibility is there anyone here from
the Java language team because I think
these guys probably know quite a lot
about backwards compatibility are trying
to retain it I've never worked on a
library before I've never worked on an
open source tool that you download and
someone else uses out in the wild it's
quite a different skill to working in a
large corporate environment where either
you can't make changes or you can make
whatever changes you want this is
something that you create this library
and someone else somewhere else that you
don't know about uses it and runs it and
you can't just go around breaking that
for them you can't just go around adding
a new feature or changing the method
signature because you don't like the
name of something you need to be aware
of the fact that probably some big bank
somewhere is going to upgrade to your
version of the driver in about 20 20
maybe when they get around to it and
then they're running it on Java 1.5
despite the fact that really I should
move slightly ahead with the times so
given all these constraints given the
fact that you've we've got bugs that
need to be fixed we've got features that
need to be
we've got this confusing architecture
we've got a code that perhaps IntelliJ
would prefer us to write a slightly
different way where do we go from here
what do we do next and given my
hypothesis that design is a process its
journey then perhaps what we want from
this process of design is a as a map to
show us where to go at the very least we
could use a map which shows us the
landscape of our problem at the moment
it shows us that somewhere over there we
want to be on time and under budget and
somewhere around that space there's bugs
and defects and new features and
inconsistencies and our own lack of
experience and unclear objectives and
then design will tell us that given that
we are here then this is how to get to
where we want to be right design should
be a sort of sat nav to get us from
where we are to on time and under budget
but it's not really like this though is
it you can't really do a map that shows
you where you are a map of all the
unknowns a map of all the obstacles
which are probably in your way except
you're not reassure if they are or not
because you're not just here you're also
here and here and here and here and here
and and you're thinking how am I
supposed to get to where I want to be
when I don't even know where I am and
the question is where do I start not how
do I get from A to B so it's less like a
landscape that you can map it's less
like a way of plotting to get from where
you are to where you want to be it's
more like knowing where i am here and
now right here right now i am in a
cluttered codebase everywhere you turn
you see different peoples styles there
are bugs to be fixed and new features
that must be implemented some users has
just improvements to your product others
will kill you if you change anything
what do you want to do go north
so what you have when you're actually
developing you don't have an idea of the
landscape you have an idea of where you
are right now you have an idea of the
obstacles which are in front of you
right now and possibly one or two doors
you can take or possibly 150 doors that
you can take and so then you're worrying
well which one do I take how do I know
which one has the pit of despair behind
it versus which one leads to riches I
don't know they're all there's just too
many things and what we really want is a
set of signposts that help us make those
decisions do I go this way which is
going to get us closer to consistency
but perhaps might make us further away
from performant code do I go this way
which gives me maintainability but maybe
my immutability is lost and this way we
have an idea of which direction to go in
and perhaps which trade-offs were making
when we're going in that direction are
we getting closer to where we want to be
or are we actually picking and you know
following local minima if anyone's done
in ease of search type stuff and so we
came up with a set of design goals for
the Java driver our design goals were
consistency this is important for us
because we have users and they expect
certain consistency from the API but
also as an open source project it'll be
a lot easier for us to get contributions
from people like you guys if our code
acts consistently if it looks
consistently then that will just make it
easier and it'll be easier for me as a
developer if it could at least do things
in the same way we want a cleaner design
whatever that means everyone wants clean
design right we want to clean a design
we want an intuitive API for our users
to be able to user that was having to
document it we want understandable
exceptions so we don't get people asking
well what sort of exception did I expect
if this happens we want it to be test
friendly because tests are our friends
we should all be writing tests and most
importantly we wanted to be backwards
compatible so this is not big upfront
design this is not a design spec which
someone gave to us as the developers and
said implement a new driver so it looks
like this this is a set of signposts so
that when we're making those decisions
do I want to make this classroom
suitable or do I want to make it or do I
want it to look this way I can look at
the design goals that we decided were
the important design goals and figure
out which which trade-offs are okay to
take and which ones are not okay so
anything which is going to break
backwards compatibility for example we
definitely can't do no matter how much
closer it gets us to high-performance
code for example ok I'm going to try and
get a little bit interactive in this
talk I don't really know if it's going
to work if you guys are up for it or not
may be ready all right so what I'm going
to do is I'm going to go through some of
the situations that we face when we were
doing the design for the driver I'm
going to talk about the problem it was
facing us and and hopefully get some
ideas from you guys on how we should
have fixed it and then if you've got
really bright ideas if you could then
invent that the time machine so I could
go back in time and do it differently
that'll be awesome but in theory
hopefully we'll get a load of ideas
going and at the end of this we should
have some ideas when we come out of the
session of you know what possible
solutions for various design problems so
the first problem I've mentioned it a
few times and this might be because I'm
a little bit OCD is the lack of
consistency in our code base and what I
mean is methods might not always be
called the same thing sometimes we
prefer with sometimes we have method
overloading sometimes we have method
chaining sometimes our fields are named
in one standard and sometimes they're
named in another sometimes the bottom of
the class sometimes there are top of the
class and you know all these sorts of
things and to me as an OCD person when
IntelliJ just basically marks the whole
classes being yellow I can't find the
bug in that class because I'm too busy
trying to reformat it so what what would
we do if we're faced with an
inconsistent codebase any ideas from you
lot yes so have coding standards for the
for the whole code base yep yes
so templates and star checks yeah in
fact that yep huh code reviews yes small
changes whenever you access something so
so if you're fixing a bug just make sure
that that's clean it just okay so a
little bit more not just the bare
essentials a little bit more than that
in line with the coding standards that
we've all decided on refactoring okay
but refactoring what the whole lot or
what what sort of things the piece
you're working on so we factor it
towards some better saying while you're
working on it yep I like that one turn
off the IDE warnings forget it right I
mean is it it's a good point right why
bother maybe it's just a distraction
maybe it's just something which me is an
OCD person I'm just thinking I don't
want to think about big problems of
refactoring or architecture I'd rather
just reformat it because that's easier
right so maybe we maybe we could just
say no let's not worry about consistency
let's just let's accept that we have an
inconsistent code base and just move
forward that's a possible solution and I
have well obviously as an OCD person
that was not acceptable but and my
argument for for this sort of thing oh
sorry OCD obsessive-compulsive disorder
so but only in a very minor way
obviously it's not like I to turn the
light on and off five times or anything
like that it's just that you know I want
it I want to have my curly braces on
them in the right place I don't
necessarily care whether it's on the
line below or the same line it just has
to be the same way every time otherwise
I'm going to go crazy so my point is and
this comes back to the code of use as
well if we're doing a code of you if we
spend two days doing backwards and
forwards on code reviews over did you
use tabs or spaces or did you put your
curly brace on this line or did you put
the fields at the top of the bottom of
your class then that's a bit of a waste
of time of that code view we should be
talking about design we should be saying
did you put it in the right place did
you fix the bug did you think about this
race condition so my argument here is
that this inconsistency is like this
kind of fog of war getting in the way of
our ability to talk about design and
anyone want to say anything else about
the lack of consistency way we could
tackle it do a global reformat yeah but
just do that one big global reformat
check that in and then that's done yeah
because there's an argument against the
incremental changes which is that every
time i do my code review i'm looking at
new features but i'm also looking at the
fact that all the white space has
changed and all my curly braces in a
different place and that's quite
distracting as well ok so the solution
that we came up with is pretty much all
of those things we're already doing code
reviews but we're introduced static
analysis so we had checkstyle running
fine bugs running PMD running and we
integrated that with with Gradle
actually introduced Gradle as well as
part of as part of the new driver and
this is all well in good running check
style by the way if you've got 6,000
errors on textile and just consistently
ignore them it's not really it's not
really doing what it's supposed to do
right though the other thing you have to
have is you have to have discipline and
commitment then agreement amongst the
team that this is something that's worth
fixing this is something we will fix
there's no point me going around fixing
200 checkstyle warnings if you go and
introduce another 75 that week it's just
going to be a continual battle
and there might be a good reason that
you introduced and spent 75 new
checkstyle errors because it might be
that you prefer that way of working we
all need to buy into it we all need to
agree to it and the way that we also did
it we did it incrementally as well so we
did a couple of big reformats but we
also do things with some of the warnings
of just incrementally making sure every
class that you touch will not have any
ide warnings in it and will not have any
checkstyle warnings in it you have to do
that every time so we did this gradually
we got down from 6,000 checkstyle errors
20 checkstyle errors and then we turned
on the flag in Gradle which says anytime
you see a textile error break the build
so that now everyone is bought into it
and even if we have open source
contributions they have to conform to
the rules that we've all agreed with so
that way we get fast feedback this way
it means that we don't have we're not
having these discussions in our code
reviews about you know should your curly
brace beyond this line on this line our
code reviews are now talking about is
that really where that responsibility
lives does it really live there we
actually so we introduced checks I'll
find bugs and PMD and we fairly recently
backed out PMD because once we use those
three checks to get our code into a
cleaner space we found there's quite a
lot of overlap between PMD and find bugs
so actually now we're in a much better
place we don't necessarily need all the
tools running all the time maybe we
might change our mind on that we'll see
so the next scenario we have other
adventurers coming to take away our
treasure other adventurers like morphia
Justin and Morpheus spring data the
scholar driver these are all libraries
which actually live and work on top of
the current Java driver so the Java
driver shouldn't be too surprisingly its
job is to sit between a java application
and MongoDB and it turns your beautiful
Java objects into beasts on objects that
can talk to MongoDB now we sort of
originally thought oh I originally
thought in my naivety that most people
most Java developers who working with
MongoDB will be working directly against
the fully supported Java driver
but in actual fact they're not
necessarily there they're using morphia
which is an odm it's a little bit like
hibernate they're using spring data they
might be using the Skylar API which
wraps the Java driver and all of these
other things they all depend upon the
Java driver but they all provide a
different API out to the outside world
and if you end up looking at stack
overflow for example for people who
might be having trouble using MongoDB
with Java you'll find they're using all
these different things and grails and
and and all you know spring or whatever
and they're they're kind of looking to
us as MongoDB to help them with the
problems with all of these different
libraries that we didn't in vain and
don't officially support so given these
other adventurers who are there to steal
our treasure what do we do about these
guys but what should we do to try and
combat this problem is it a problem yeah
how did you get the answer straight away
I'm going to come to that I'm not even
going to say that answer out loud
because I'm going to come to that later
but yes that's the right answer tell me
that later anyone else who didn't hear
the answer
fine and so the idea is that they're not
they're not other competitors they're
not there to steal our treasure right we
as mongodb the more users who can
interact with MongoDB the better if
they're not using the officially
supported Java drivers API we still want
them to use MongoDB we still want them
to use Java and mongodb and we want to
make it as easy as possible for them to
interact with us which ever way is right
for them so if they're using spring it's
going to make sense for them to use
spring data if they prefer a more fear
style way of working they might want to
use more fear so what we did is we kind
of consider them all as our friends not
as our enemies they want to get these
guys on board and we want to provide a
way for these guys to interact really
nicely with the Java driver we don't
want to say okay we're going to just
make the Java driver the one true driver
for all of them we're going to make it
something which is going to be useful
for all of those guys I'm going to come
into that in a bit more detail later and
so we're going to get those guys on
board we actually had conversations with
some of the guys from spring data we
gave more fear a bit of love brought it
in house started actually updating it a
bit more and we've got our own guile on
that now we are we also the scholar
driver we want that to be our guinea pig
we want we want the Java driver to
support other JVM languages we want to
provide something which does the heavy
lifting was allowing other AP is to plug
onto the front end of it so if we use
the scholar driver which we support in
house as a way of seeing how easy it is
to do this then we can figure out
whether we've made the correct design
decisions we can figure out whether
we're we're exposing the correct things
to other people who might want to do
this and the major major benefit of
having these other frameworks is that
they all have their own test Suites they
all have functional tests which run
against MongoDB so if we get them on
board and we play nicely with them we
can make sure that the brand new driver
which is going to have our brand new
clean architecture still does what it's
supposed to do still does it correctly
make sure that we haven't missed
something so that's and that means that
even if our test coverage wasn't perfect
get extra test test coverage from those
guys um and one of the other things we
did is every time someone said you know
I've got a problem with my grails app
and I want I want to work with the mongo
Joe the mongo driver in this particular
way and I might download growls right a
little girls a pin it get to know how
you work with mongolian side Grails and
then that would give me a different
insight on it on what features I should
support as the Java driver and it made
me realize that we have three different
types of users we have the users who I'd
originally been thinking about who are
Java developers using the Java driver
directly but we have also have we have
contributors who are at the open source
contributors who kind of they use it
because they want to write their code
but we have these other guys who are
consumers of the driver as well and
they're our allies because we can go to
them and say what is it you want to
achieve what features do you want we
don't have to go out to every single
person who's ever downloaded MongoDB and
say what do you use how does it work
what do you hate what do you not like as
the same as hate and we you know we can
actually just talk to these libraries
two or three of these libraries and they
can give us the feedback from all of
their users so it's really important to
get these guys on board and have
conversations with them scenario 3 all
the time this is going on we have the
problem of backwards compatibility every
time we wanted to make a change one of
the main things we want to do is create
a new shiny more modern API and that's
pretty much impossible to do whilst also
retaining backwards compatibility but we
really we really do need to retain
backwards compatibility we've got
thousands of users I don't know how many
thousands of users it's free years open
source I don't know who they are what
who downloaded it or what it does
they're using the they using the library
and they're using it in the wild and and
we can't break those guys especially if
they're in an organization where maybe
they can't download the new driver
straight away but even if they're
working on a tiny startup we want we
want to give them a good
a good experience so we don't want to
alienate our users but we really want to
be able to create a new API and retain
backwards compatibility any ideas on how
we could do this create a separate API
for the old backwards compatible API and
okay and yeah so start gradually
deprecating things and implementing new
the replacement for that yes an easy
upgrade path so if you are going to do
something like that with the deprecation
for example you need to tell people
where to go and how to migrate we need
to do that anything else so this comes
back to the point that you said earlier
about the helping out the third party
libraries which is you can have a
separate API which allows these guys to
plug in and you can have this tiered
architecture this this was what we ended
up doing we ended up basically we have
this core architecture which does all
the heavy lifting so it does connection
pooling it does figuring out which
server you want to connect to MongoDB is
horizontally scalable so you're not just
talking to this one server you have to
figure out which one to connect to we
have it doing serialization we have it
doing all this complicated stuff we have
that in a in a core layer this is the
reusable stuff there's reusable between
the two different API is the old API
that we want to retain the backwards
compatibility for the new API which is
going to be modern and shiny and it's
got generics because they've only been
around for like ten years and and we can
have these two different api's off this
office core but we can also have perhaps
more you're running off the core or we
can have the scholar driver and spring
they can all basically plug into the the
core which will do the heavy lifting but
provide very a very thin API
and the fact that we could do this
architecture which will give us
backwards compatibility and let us play
nicely with the other children made us
think that maybe we've made the right
decision here this must be the right way
forward because the API really I've been
thinking brand new API that's the
driving factor for how to design the
whole driver and it's not the API is
just the tiny tiny little thin layer on
the top which is what you're exposed to
people it's like your UI it needs to be
well designed and it needs to be
intuitive it's not your whole
application you can design the
architecture of your application so then
you can be designed it right you can put
your API over the front of it and expose
the stuff that you want to expose so we
have this architecture that supports
both api's and all the other api's as
well and the automated tests comments
here is how do you know that your
backward compatible oh I didn't mention
duplication yes and deprecating stuff
from the old things that we actually do
want to get rid of at some point but
providing a links to which methods
you're supposed to be using instead
because doesn't it drive you crazy when
someone puts deprecated and doesn't tell
you what to use well thanks for that
Cheers try to be mad so yeah deprecating
stuff and having a plan for when we're
going to delete it and telling people
when we're going to remove the
deprecated methods and telling people
what they should be using instead so we
have the two api's we have deprecation
still on the old API for the stuff we
definitely want to get rid of and we
have automated tests which tell us where
there are backwards compatible API
running on our new architecture is
actually doing what we think it's doing
because like that's not always the case
right so we have our series of automated
tests and we can also build our
compatible mode driver and give it to
the spring data guys and run the morphia
tests against it and put it in a scholar
driver and make sure all those tests
still run as well then we're kind of I'm
not sure we can say we're definitely
backwards compatible but we're
definitely a lot closer and we can also
run clear tests over as well I went does
anyone go to the back of a practical
talk yesterday Monday
no one knows what I'm talking about
because I've just made it really fluffy
someone was talking and I've forgot to
write his name down about how to do
backwards compatibility and he's saying
if you want to be binary compatible you
can actually run a tool called clear
which will tell you what you've broken
in your binary compatibility so we did
that as well to make sure we didn't do
anything really naughty so speaking of
this shiny new public API this is
another one of our challenges that we
had to we had to overcome we want to be
able to design this this new public API
for the Java driver we we have an
additional challenge so I talked a
little bit about the lack of consistency
inside our its other Java classes I
talked about method naming and fields
and things like that we are slightly
bigger consistency opportunity which is
that we have 12 different language
drivers we support Ruby and Python and
Perl and Erlang and C sharp and all the
others that I've forgotten and they've
got to come and lynch me when they find
out I didn't mention their driver we
also have a JavaScript shell and which
runs on the server so whenever you want
to actually query MongoDB as if you were
writing sequel you can you can use the
shell to figure out does this query work
and all of those different language
drivers and the shell they all work in
slightly different ways and a lot of the
documentation is for the shell because
that's going to be consistent wherever
you're installing MongoDB you're going
to get the shell so the documentation is
based off the shell but the way you
interact with javascript is not really
the same way you interact with Java
necessarily and the stuff we've done in
Java is it you have to sort of go
through a translation layer between oh
I'll do it this way in the shell which
means i need to do this there's this is
Miss and then it will look like this in
Java so we have this problem of
consistency across all of the different
ways of interacting with the server
itself and the other thing is the API
like I said is a little bit like a UI
and you show someone a UI and you say
what do you think I thing I say don't
really like that purple did spell that
right
everyone's got this because it's public
facing thing everyone has an opinion on
whether it's any good or not or how you
should do it or how you could do it
better and I don't just mean inside
Mongo I mean you know it's an open
source thing and the rest of the
community says I don't really like the
way you use generics here or you know if
you were more like the C sharp driver
your life would be easier well yes but
we're not so we can't we have this
problem everyone has an opinion and n
tastes differ and we have to be able to
get consistency across different idioms
different languages so how would you
design a new shiny public API which is
going to be nice and friendly for 12
different languages and and it's going
to be accepted by the wide world out
there ok so should comply to some sort
of standards like REST API or something
that's well known an idiom that people
are used to using ok yep so it should be
somewhat fluent so it's a more natural
language style have you seen my other
presentation yes that's a very good
point i think it should be very fluent
so yes it should be a way that and that
way it's kind of self-describing in
pretty much any language should be self
documenting anything else this is great
i'm glad you lot are just as stumped as
we were this is great it turns out that
actually the approach that we sort of
followed to do design for a public api
is a little bit like big upfront design
we actually have a committee because we
need people who represent different
types of languages dynamic languages and
Static languages and the server side
inlet and the client side will the
inside and we have a document we have
spreadsheets where we kind of try out
different api's and pass it around and
say does that look right does that feel
right does it work for your language and
people have had been shuttered in
meetings and made decisions and we've
actually done we did like actual
research rather than just hacking like
we read stuff about lambdas and about
the new collections stream API
and way back because we thought we want
the Java driver when we put in our input
for what we want the public API to look
like we want the Java drivers API to
look as close to modern Java or even
more modern Java because it's not even
come out yet we want to be ahead of the
curve because this thing's going to take
a while to to bed in so we actually did
research reading papers and stuff now as
an agile person all of these words fill
me with fear I just think well that's
fine and we could spend two years trying
to decide what I shiny new public API
could look like at which point our
research is completely pointless and
old-fashioned and dead and buried but
how do we know what users really think
about the API how do we get the fast
feedback that we're supposed to get from
lean and agile so those things you can
do as well around getting fast feedback
and around being a bit more lean and
iterative and so we did things like
we've run a couple of tutorial hack day
things we've sort of made people sign
things saying we won't use this in
production definitely not we know it's
going to change it's not finished yet
but we can get real developers to have
to code against it and say whether or
not they like the API or what they do or
don't like about it what was intuitive
what they had trouble with and I stole
this idea actually from the guys who
were doing dr. Jay sarona dr. OpenJDK I
was in a hack day for date time for the
for the new datetime that's coming into
Java 8 and Stephen colburn was there and
he was enriched Warburton and they were
saying like hack against the API and
tell us what you think and tell us what
you find is difficult as a developer
that's quite tricky actually because we
like to think we know everything and
when you're actually coding against
something and you don't know the answer
you don't assume as the api's fault you
assume it's your fault for being a bit
of an idiot right but if you can run
safe environments from running hack days
and get feedback from people how why did
you stumble over this why did you
implement it this way then you can go
back have a bit of a rethink and think
about perhaps how to make your API a
little bit better and that's without
having to publish new shiny 30 go and
download it and use it now and then have
everyone say on hacker news how awful it
is and how dreadful is so we have enough
of that we don't need anymore
and and we've it's available online so
if anyone want to download it and play
with it it's there they can give us
feedback they can submit pull requests
even because it's on github and so we
can have some of this fast feedback as
well as and this can feed into the
committee's and the documents in the
spreadsheet so it's a sort of continual
feedback loop and conference talks like
this so that if any of you feel really
strongly about the public API go and
have a look and let me know what you
think so I'm gonna I'm an agile person
and I'm going to have a quick
retrospective on my my feelings on how
the design process of the new Java
driver went and I'm hoping that Justin
might go back and tell everyone what I
really think I wish I'd asked more
questions I joined a company I didn't
really know the domain that well I
didn't know the team I didn't know the
technology I was I had a lot of
ignorance and I assumed that everyone
else well everyone else did no more than
me and I assumed that everyone there
knew exactly what was going on and knew
the right way forward so I kind of let
other people drive when every now and
again I should have been saying but what
about this or what why are you doing it
that way and I don't need more questions
like that's stupid why did you do that I
mean questions like but why why are we
doing it that way and that way you can
trigger these sorts of useful design
conversations about well the
requirements are here and the service
spec says this and the API looks like
this and maybe the conclusion is the
same as the one we came to or maybe we
managed to have a discussion where the
conclusion was something slightly
different because in my naivety I've
actually exposed something that's useful
to feed into the design process I wish I
say I wish we'd better understood our
priorities I mean me we had those
different goals that there's different
design goals and it would have been
nicer to know for myself if I if I'm
trying to make a decision between I
don't know consistency and backwards
compatibility which one's the most
important backwards compatibility
obviously but
if I'm trying to make a priority trying
to make it call between shall I fix this
bug should i implement this new server
feature or should I try and create the
better design for the new driver got all
these competing requirements if I had
understood the requirement the
priorities a bit better that would have
made me feel slightly less stressed and
the whiteboard thing I wish we could
have used the whiteboard more this is
this is really a design thing for me I'm
a very visual person and the whiteboard
is really important for me to be able to
do design because I need to be able to
see it in boxes and lines and I'm in UML
because I'm not masochistic I mean I
mean just freeform drawing or this is
here and it talks to this and it goes
over here and then oh those lines
crossed that probably means that I've
got some sort of interdependence II I
shouldn't have and this is because we
weren't remotely so it's a little bit
more difficult for us to have these
white board discussions but it's really
really important and I wish we'd solve
the whiteboard problem earlier when I
say earlier we haven't actually solved
it yet but I have a whiteboard in my
study now so it's it's getting closer at
least I can white board now um and even
though I've talked a bit about tests I
wish we took focus a bit more on tests I
kind of came from a very test-driven
background and I feel like instead of
being driven purely by design this is
the design we want therefore we will
code it if I'd been more driven by
requirements and now write the test
specification for this Collins loving
this he loves test if I had been driven
by requirements now right test
specification now write the code which
actually passes that specification I
would have felt a little bit better that
what I was writing was the right thing
to write if you do test afterwards then
yeah sure it passes the test because I
wrote the test to pass after I wrote the
code and it's not really the same thing
okay so in conclusion I'm going to get
back to my tenuous adventure analogy
because I like that like the adventurer
who is on her journey and she she maybe
she starts with a stick and then she
picks up a sword later on and she gets a
shield she has things in her inventory
she has tools in her inventory
to to help her on her on her journey to
help her through this process and some
of these tools so you have tools as well
c10 us an allergy time you have these
tools tool and some of these tools in
your inventory in your own personal
inventory you have obviously you have
your technical skills things you already
learnt when you come and join a new team
this is the thing you bring I know
spring I know mongodb I know Java you
have your domain knowledge so you might
already know the domain that you work in
and you bring that as a tool in your
inventory or you might bring a lack of
domain knowledge which is just as
important a tool as well because you can
ask those great questions which is why
why do you do that what is this you
bring your life experience as well so
you might know how to play nicely with
others because you play on a football
team or you can manage 15 things at once
because you've got five children they're
always all over the place and and you're
also the most important tool in your
inventory i think is the questions you
can ask especially the stupid questions
you also have this idea of an
environmental inventory when you get
there and the the team that you work on
all the team that you're in right now
the place you are right now the you have
this inventory of the domain you're
working in the people you're working
with the hardware this stuff has to work
on and your chosen technology and of
course any existing code or application
or platform that you're working with
these are more like constraints i guess
that rather than tools but they're also
tools you have to leverage to get what
you want out of where you are but the
important thing here is that this is not
static your your inventory like the
adventurer in the stupid adventure games
which drove us crazy as kids your
inventory will grow when you find a
better sword you will drop the stick
that doesn't do what you want when you
find something which i don't know the
bag of holding you could put more stuff
into I'll show myself that the real key
key here is bad and then you pick that
up and you can use that and in your
adventure now as developers and as
developers / architect / technical
people our inventory grows and changes
as well
neurol at this conference so I assume
somebody learnt something somewhere i'm
hoping so there's probably some
technique that you learned so for
example for me I went to geek on in May
this year and i went to talk about Spock
and in fact he'd forced me to go to this
talk about Spock and I was like I don't
want to learn about Spock I don't want
to do my testing in groovy because we're
a Java shop and I need the Java tests to
be in Java so that our users can read
them and understand what's going on now
I went to this talk about Spock and I
was like this is amazing this is exactly
what we need the tests are much more
descriptive groovy is much more succinct
and in actual fact even though I'm a
Java developer I find this way of
documenting what our code is supposed to
do much more obvious and so I kind of
picked this up in my inventory of tools
and I took it to the team and we started
using spot and now we're kind of halfway
through migrating are functional unit
tests to Spock and I love them and every
time I come across a Java unit test I go
oh no this is it's got so many words in
it so this is one of us this is one of
the tools I've picked up in my inventory
so yet tools you research as well you go
online and you figure out new tools that
you could use and so I learn about
Gradle for this project because the
alternative was maven and so
so I went with my with grave them so I
did a bit of research on Gradle and we
implemented Gradle and that was just
that was not something I knew about but
it was something that I had heard of and
then your inventory changes as your team
changes and people come and join your
team and and people leave the team and
you can learn off people and the people
are not just the people who are SAT
there physically in the room these are
people you've met at the conference here
these are now part of your team team you
yay these are people you can call out to
and you say okay I saw you in that talk
about Spock and did you understand
anything that Spock can you help me with
a Spock stuff and these are people who
can help you learn and grow as well and
they can add stuff to your to your
inventory to your team and this is a bit
of an abstract talk and the problem with
abstract talks is that this is a gross
generalization I apologize for for
making such a generalization but
developers generally want to know an
answer want to something to take away
with them the takeaway point of this
talk should be we should be thinking
when we do development but the you guys
do that already right so I'm going to
give you some more solid things like
more tests is good you can never have
too many tests look at Spock Spock is
amazing you should totally look at that
and groovy is quite cool as well
actually and static analysis and
consistent standards things like that
will help you be able to have design
discussions instead of formatting
discussions just take all that
destruction off the table find some
standards implement them put them in
your build file forget about them with
code reviews now your code reviews can
be of much bigger discussions much more
important discussions an automated build
is nice I assume you're using Jenkins or
equivalent right anyone not doing
continuous integration okay two brave
people put their hands up well done the
rest of you are too ashamed to say
anything and so an automated build
preferably an automated build and
release process because then you can get
your quick feedback then you can find
out whether you know people hate your
API or whether you've broken any tests
or whether you've broken any third-party
tests
and bug or feature tracker I put some of
these things in and some people look at
them and go well of course it's obvious
of course you need JIRA or bugzilla or
or whatever probably there's probably
some vendor in the room saying mention
my bug tracker I can't remember them all
okay but there are plenty of people who
aren't using bug trackers there are
plenty of people who are just writing
down I mean even Trello right charlie is
not a proper bug tracker but at least
you're keeping track of what you want to
work on next you need that because
otherwise how are you supposed to decide
whether you're going to work on some
refactoring or whether you're going to
work on a feature whether you going to
work on a bug how are you going to
remember in three months time what that
bug was if you don't write in the bug
track of what the bug was preferably
writing a test of course to fail when to
prove that bug that's a bit much and and
related to that this idea of visibility
of work in progress this is something
that I think is really really important
this is something that kind of comes
more from the lean side of things than
just agile but if you can limit work in
progress then at least you'll get stuff
done if you've got 150 things in
progress right now and you can feel like
you're extremely busy you are extremely
busy what you are not is extremely
productive you're constantly working on
this and then this and then this and
then this it drives you crazy and if you
can't see the visit but you don't have
the visibility of your work in progress
you don't realize that you didn't make
any progress on this bug because you are
actually working on this refactoring or
because you came to talk at a conference
and didn't do any work for a week I did
work this is work and so this visibility
of work in progress can at least help
you figure out maybe you know what
you're working on and what you're not
working on these are all not necessarily
related to design other than if you do
some of this stuff it's going to easier
to talk about the design of your system
rather than getting tripped up all the
time on the stupid little things that
should be automatable so design is a
process not a document or an artifact on
RT fact however you spell it it's not
uml it's not a word document it's not
even a wiki page that of course you
update every time you change anything
it's a process you go on when you're
evolving your code and this is why your
code is supposed to be self documenting
because the code is it's the embodiment
of the design but what that means is not
just about writing self documenting code
with nice long method names yeah I've
done that it's about the fact that when
you're writing your code you are also
designing you are thinking about the
responsibilities of the system you're
thinking about the domain in which
you're working you're thinking about if
I put it here and all this behavior
lives here then when someone has a bug
in this area I know which bit of code to
go to more importantly when a new
feature comes up to do with I don't know
connecting to the database I should be
able to go to a class called connection
and add it there instead of putting it
in some spaghetti code somewhere else so
we're constantly doing this process of
designers we make these decisions and
the design process you're not just
giving to the project because of course
we're all working we're constantly
giving to the code that we're writing
it's also it's coming it's giving back
to you into your career because you're
adding these things into your inventory
you're adding these additional tools
into your inventory and you're you're
growing as you meet new people and learn
new stuff and decide that this is a
stupid project I'm going to go and work
over here where they using groovy
because it's awesome I'm any questions
at this point I'll take questions on
pretty much anything especially if it's
quiet yes of what Oh excellent it's an
excellent question how do we get rid of
the worst enemy the worst monster that I
didn't put up there which is the ego I
don't know I'm standing up here
preaching about design to you guys I
can't talk about removing the ego I
don't know
as a very good question yeah so I'm
going to expand it to a bigger more
fluffy question which is that the the
team that you work with the people that
you work with this is going to help you
win or lose some of these design things
so you're going to have maybe a person
with an ego who says I'm going to go
this way and this is what we're going to
do or they're not even the boss and
they're going to disagree with what the
boss says that's going to make things
difficult so working within the team and
working out the team dynamics is an
important part of the design process too
and you're right I didn't cover that at
all I think someone else had a question
first I fire them you can't really do
that in the UK yes
yeah so the the question or statement
was I talked a bit about white boarding
it doesn't have to be about UML it could
be an informal whiteboard process do it
seems sensible to write down some of the
early decisions that we took not just
the design goals so that we don't go
back on them later or don't have that
discussion again and again and we
actually did do that we've got a google
doc where we wrote down some of our
early design decisions I dug it out
because we haven't listed for a while
but it is there an google doc is
arguably a little bit better than a word
document which lives on a shared drive
because it's much easier and lower
maintenance to go in and change it and
we're not doing that anymore and you can
track those changes so we did do that
yes yeah
okay the quest this the question is that
what I've said is there's loads of
developers making loads of decisions all
the time and how do you sort of help
them make the same the right decisions
or enforce it or or police those
decisions I guess to some extent yep so
it's not just it's not just you can
enforce the decisions around things like
formatting because you could put that in
check style but how do you make sure
that you're following an oo style rather
than a functional style law that you're
you follow the method naming conventions
for example which you can't you can't
codify I'm and so we use coatings we use
code reviews for that but there's only
three of us on the JVM team so that's a
lot easier in my last place where it's a
much bigger team and we were split into
smaller teams we did pair programming
and there pero gramming worked really
well for enforcing the standards because
as you pair with different people the
current you kind of get this hive mind
of knowing the right ways to do stuff
and knowing the the good ways to do
stuff and you're also in a much safer
environment to either say to someone
that's not the way we do stuff and also
to receive that criticism and go oh yeah
yeah I was totally off on this path here
and it's not like someone saying to you
even in a code review I don't like this
don't do it like that it's much more
constructive yep do I write my own tests
yes we don't have any
so if i'm going to write my own tests
what's the difference between me writing
the test first and me writing the test
afterwards matter whole talk actually i
will get toilet colander come up and
talk about that now that's a whole
nother talk in its own right but for me
personally i found that if i write the
test first for a start I'm starting from
the assumption of the requirements which
is that when I write when I do an insert
into MongoDB I expect it to look like
this I expected to behave this way I
expect to get these things back I expect
to see this error if i do that if i have
that in my head don't write the test
have it in my head go away and write the
code then i will usually this human
psychology come back and write the test
that prove the code does what i wrote it
to do not what it was supposed to do
just because that's just human
psychology so but if i'm thinking up
front before I've written the code okay
I don't really know what I'm doing I
don't really know what it looks like I
know that insert statements should fail
on with duplicate key exceptions or they
should pass when I do this or they
should fail when there's no database
there and I can think of all those error
cases because it's the error cases that
kill you not the success cases think of
all those up front then when I'm
actually writing the code I know I've
finished implementing it when all those
tests pass yep so actually I actually
write the test first I do I don't write
them as much first as I used to when I
worked at my last place almost always
used to work the test first but I do
because there's no UI right so I'm a
very visual person and there's no UI to
prove it did what I did so I write the
test so that when it goes green I can
see it did what I did I don't thinking
code if i write the code all I can see
is I wrote a load of code I can't see it
works the way i think it works whereas
if i write the test first I can see it
works the way i think it works or wanted
it does what i wanted it to do I have no
questions from this side at all I'm not
ignoring you guys have you got anything
you're the quiet end of the class four
minutes for any more questions if there
is anything yes
yes then went right so okay so the
question is there was a there was a
presentation from my dear friends Ben
and Martine at Jay clarity and they were
not terribly flattering about mongodb
they did warn me in advance so they
weren't being trolls or anything and the
question is how how do i or we as
mongodb deal with constructive feedback
and so on don't feed the trolls right we
get a lot of stuff on how can use them
whatever and we have a policy of just
don't reply because it always just gets
worse we also we had we had someone
notice of an idiosyncrasy in the Java
code a little while back in it it was
all over the place and it's like and
that's kind of fine because it's a small
fixable problem it was not a critical
production issue and we fixed it and we
put it up there and we didn't say
anything apart from its fixed just don't
you don't get involved in these really
big debates so that's one thing but
another thing is to you have to listen
to all that stuff so then I martine in
particular made some very valid points
about features they would like to see in
the server so then I put that into JIRA
and i hope the server team implement it
at some point that's just you know and
in fact at MongoDB we've got quite
because we have we've got people like me
who come into the developer community
and so I do write code but I also hang
out with you guys and I can hear what
you think about it as developers and we
have people like the solutions
architects you go into actual on client
site for our plank paying clients and
hear what they want or don't want in the
server and we have a environment of
bringing all that feedback back in and
that feeds into our product development
cycle so you know we we either if it's
nothing we can do anything about and we
ignore it and if it's if you're
something we can do something then we do
something about it yep
how much do we think about the future
all the time I'd like to retire on a
beach in Spain in terms of API yeah so
we're currently looking at the next so
we're working on 30 we're looking at 30
and we are looking at Java 8 because
that's going to be out by the time we do
20 we can't be to future-proof
necessarily because we need to support
java 1.5 1.6 so we can't look too far
ahead in terms of that sort of thing but
in theory in my experience if you've got
a decent design especially if it's got
separation of concerns and it's got
tears and stuff then when new features
come in especially from the server
because it happens a lot right that's
what it's supposed to do add new
features if you've got a properly domain
driven design and it's modular then you
should be able to plug stuff in wherever
it wants and you want shouldn't have to
do in all this big rewrites for
something that's coming down the line in
terms of stuff on the server we get
quite a bit of visibility of what
they're working on and where they're
going and we can help evolve the driver
in parallel rather than then springing
on us and say by the way you need to
implement authentication because that's
quite hard to think about do we think
about where we're going to be in two
years time from a cloud point of view
not really we think about trying to
write code which is going to is going to
be future proof but personally I think
this kind of this is a personal opinion
this is not the opinion of MongoDB but I
think that looking two years in the
future is really pointless because two
years ago we didn't know that other JVM
languages are going to be this big we
didn't know what frameworks are going to
be out there we didn't know you know the
way the people are already going to use
stuff we didn't know what sorts of
companies were going to be using MongoDB
and for what sorts of use cases you
can't see that far ahead all we can do
is try not to prevent growth in the
future I think that's my time up so
sorry thank you very much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>