<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Clojure Made Simple | Coder Coacher - Coaching Coders</title><meta content="Clojure Made Simple - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Clojure Made Simple</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/VSdnJDO-xdg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I want to thank everybody for coming
the title is talk is closure made simple
on the brochure they left out the comma
so it's not closure made simple in other
words a tutorial in closure or an easy
explanation of closure it's not actually
a comprehensive explanation of closure
at all but a look at a slice of what
closure is about a way of thinking about
why you might want to use it so I'm the
person who made closure I currently work
on a database called de Tomic which is
kind of a functional database it's
written in closure and runs on JVM
architecture I'm a co-founder of daytime
of cognate equi build stay Tomic and
sponsors the development and stewardship
of closure but the main point I wanted
to make about myself to this audience
was because in this talk I might seem
somewhat skeptical of Java and
object-oriented programming is that I've
done an absolute ton of that that's what
I did for two decades before I said if I
still want to be a programmer I don't
want to do it this way anymore so I know
exactly how apps are built using Java
and C++ and C sharp because that's what
I used to do that doesn't mean what I
think about them is correct but that's
my experience but I'm wondering about
you how many people program in Java here
how are you happy about that how you
were actively unhappy about that looking
for alternatives okay great how many
people have tried closure at all great
how people never heard of closure and
are in the wrong room okay how people
have tried closure and are trying to get
it to use it at work but not yet a few
maybe this talk will give you some some
ways of talking about closures value
proposition that could help you how you
will actively use closure and somehow
are accidentally at JavaOne okay
and the rest couldn't get into Brian
gets a sock I shouldn't even mention
that Brian gets us to talk right now
because we could have people filing or
maybe you're just tired of Brian gets
talking about immutability in which case
you're definitely in the wrong room now
I like them Brian's a good friend and
his talks are great so I appreciate your
bringing this one so if you know very
few people had never heard of closure so
I'm not going to spend a lot of time on
oh I had one more one more question how
many people have seen my talk simple
made easy and people not okay a few so I
made spend a minute describing what I
mean when I say simple closure is a
programming language it runs in the JVM
and JavaScript and pretty much a
substantial a subset of closure runs on
JavaScript so it's a program lines with
which you can target both but originally
it only targeted the JVM and the CLR
it's they're still a port to the CLR
that's maintained but does not seem C
wide use released at first in 2007 it's
had you know surprising adoption
especially from my perspective since
then given given its characteristics
because it's a lisp it's functional its
data oriented and it has a lot of things
that make it seem not like the kind of
language that would succeed and this
talk will really be about the data
orientation of closure so a lot of the
best programmers and the most productive
programmers I know are writing
everything in blank and swearing by it
and then just producing ridiculously
sophisticated things in a very short
time and that programmer productivity
matters so Adrienne Cockcroft was an
architect and Netflix now is the battery
ventures how many people think Java goes
in the blank okay
so we know we know this
there's something about Java that makes
it not suitable for this blank - maybe
we can tease that apart yes of course he
was saying closure and this talk is
about maybe why like how could this be
true what is it that makes closure
different and possibly a better fit for
that blank so the first thing I want to
talk about is is that I think we have
this tendency in programming to think
about ourselves just a ton and our
languages our tools and our techniques
and me me me me me us what we're doing
whatever we lose track of the fact that
we're all working for somebody else
who's or ourselves but for a business or
an organization that's trying to
accomplish something in the world and
the software is completely secondary to
that task right it should be measured
always in terms of the cost-benefit
ratio the return on investment right how
quickly can we get a product to market
and is what we're doing profitable right
if we're not doing that we're not really
being good participants on our in our
businesses or organizations so what do
the stakeholders want they really want
two things they want something good and
they want it soon so something good we
think we know it's something good we
have you know we know how to make things
good right we have these techniques and
some things things are good when the
techniques are successful with them
right so when our types check on our
test pass we have something good but of
course we all know that with our best
efforts in those things which are I'm
not saying they're bad activities by the
way but no matter what we do there we
end up with programs that don't work we
all know we have programs of type check
and test pass and they don't work and
when they don't work from the
perspective of the stakeholder in other
words they don't do what the program was
supposed to do and what's supposed to do
was something that was conveyed between
people or through documentation or
papers or things that are not in program
languages they have to meet operational
requirements and they have to be
flexible okay now there are some times
where people just want something soon
and they don't want something good there
are actually better languages enclosure
for that right just give me something
fast that I'm absolutely definitely
going to throw away will not grow will
not expand will not will that take me
further so these first two things are
means right they're good but they're
only good insofar as they help ensure
the latter three things so we break it
down what is it supposed to do again
it's a prospective thing if the
stakeholder thinks assume what's
supposed to do they're fine of course
they're going to have expressed concerns
about software what it's supposed to do
it should do this when I push this
button and they're going to have
unexpressed presume things like it
should be secure it shouldn't you know
cause the computers ago on fire because
it's so slow it shouldn't require three
new data centers it should keep running
and not stop for an hour every day those
are sort of the unstated presumptions of
something being good but it ends up that
if you build large elaborate stateful
programs it's extremely difficult to
ascertain whether or not they are going
to do what they're supposed to do and in
fact if you build any one of those
things if you just build a very large
program or a very elaborate program or a
very stateful program it will be as hard
to figure out if it's one if it's going
to do is supposed to do so one of the
things closure is oriented at is making
it easier to understand whether or not
your program is going to do it's
supposed to do mostly by making it
substantially smaller and also by making
it more functional in terms of
operational requirements is a boatload
of things as a boatload of unstated
requirements of software you know - are
you cantide apply it in the normal way
with all my stuff with the people who
know how to run my machines and
everything else and and that's one of
the targets of closure closure was meant
to be hosted it's just a jar it runs in
the environment it's easy to sneak in
right let's just add this to one more
jar and then we're and then we're
running but but it's not a small thing
right if you wanted to adopt calm
lisps a or Haskell you would be asking
your urops team and your deployment team
to start manipulating something
completely alien whose characteristics
they don't understand in terms of
security everything that's available
from the JVM for security is available
via closure and there are performance
and other concerns a very important
thing though is that now we can also
reach the browser so I think you know
how many people write applications where
some part of the overall system touches
a browser yeah so right now you use two
different things
I almost definitely use two different
things and I think it's a strength of
closure that we're delivering the same
value proposition in both places both on
the server and in the client even if
they're separate devs the value
proposition is necessary I'm almost more
so in the browser which is one of the
most complex places ever in terms of
performance you know a lot of times you
might look at a dynamic language and say
you know how could it be whatever but
you know closures right down there with
the fast languages on admittedly the
benchmark game which is a benchmark and
a game so but it says we can reach that
on JavaScript we have a very interesting
result here so ohm is a closure script
library so closure script disclosure on
on JavaScript and ohm is a library that
actually wraps react which is the new
hotness what's the really interesting
things here ohm wraps react and then
spanks it in performance how's that
possible
it ends up that that ohms use of
persistent data structures which we'll
talk about in a minute make it faster
than react because the big part of react
is doing change detection and change
detection for immutable things is
identity comparison so it's super fast
and in fact they are reacting their
whole thing to use persistent data
structures in JavaScript now the react
dev came up to me at strange loop and
said shook my hand and said you're
saving us a ton of money
because we're switching to that strategy
so the other part of the value
proposition I said was flexibility right
people that that you know have a stake
in software know that they're building a
system now but tomorrow things are going
to change requirements going to changes
we have to do something different change
is inevitable
so can we change the program can we make
it more flexible and ends up there's a
lot we can learn from bigger system
design in the small to make the sub
components of systems more flexible and
of course this is old this is the oldest
thing right loose coupling right but we
talked and talked and talked about it we
continued to use techniques that thwart
it like every single day you pull out a
technique you do something that's that
makes this harder so what makes it
easier so the my talk was done and
somebody said you know I have this quote
from Walmart Labs guy you might want to
put it in your talk and it was like wow
this is great
because he's telling my story right with
closure we get to market faster with
better quality we avoid unintended
interruptions in java apps from code in
one area impacts the application in
another closure shrinks our code base to
about one-fifth the size it would have
had we written in Java right and these
are the points of my talk all right this
is what I want this is a stakeholder
saying this is what we get by by
choosing closure faster time-to-market
better quality right we avoid coupling
problems that make it difficult for us
to change and we have a smaller code
base so how does closure do this there
are many many different characteristics
to closure but I only want to talk about
sort of two today mostly one one is and
because this is one I think that sets
closure apart it makes it somewhat
different is that it has data
orientation through and through and the
other is simplicity so when I say
simplicity I mean the opposite of
complexity I do not mean ease and I mean
closure is an easy language that's easy
only you know your type and everything
magically happens or some sort of
easiness metric
complex things are intertwined and
simple things are not right they're more
independent they're separate even if
they have as many things going on this
is simpler than this right for things
like this is complex and for things like
this is simple so that's what I mean
when I say simple unentangled so the
thing is that you know all these
languages can do everything right we can
do the same stuff and people are like
why you know I know I can do the same
stuff in c-sharp in Java and and Scala
and and closure and you know anymore any
general-purpose language you can
accomplish the same things at the end of
the day right so what differentiates
languages is what they make practical
and what they make idiomatic and in
closure we focused on something making
something idiomatic that I think is not
and should be more so that's this before
we had all this high fluting you know
opinions of ourselves as programmers and
computer scientists and stuff like that
programming used to be called data
processing how many people actually do
data processing in their programs you
can raise your hands we all do right
this is what most programs do you take
some information in somebody type some
stuff somebody sends you a message you
put it somewhere later you try to find
it you put it on the screen you send it
to somebody else that's what most
programs do most of the time sure
there's a computational aspect to
programs there's quality of
implementation issues to this but
there's nothing wrong with saying
programs process data because data is
information information systems I mean
this is should be what we're doing right
we're the stewards of the world's
information and information is just data
it's not a complex thing it's not an
elaborate thing it's a simple thing
until we programmers start touching it
so we have data processor processing
most programs do this there's very few
programs that don't write and data is a
fundamentally simple thing data is just
raw immutable information so that's the
first point data is immutable if you
make a data structure you can start mess
with that but actual data is immutable
so if you have a representation for it
that's also immutable you're capturing
its essence better than if you start
fiddling around and that's what happens
languages fiddle around right they
elaborate on data they add types they
add methods they make data active they
make data immutable they make data
movable they turn it into you know an
agent or some active thing and at that
point they're ruining it at least
they're moving it away from what it what
it is and in object orientation I think
this is rampant because our fundamentals
construct the object conflates two
things it doesn't give us two separate
ways to talk about process for which
objects are an okay approach and
information for which they're a terrible
terrible terrible approach right but
every time we have a problem we pull out
an object we make a new object we make a
new class we make a new instantiation of
something right and and this makes our
programs more about themselves again and
less about the information programs are
more increasingly about code and
decreasing lis about data and I think
that's a mistake so closure embraces
data that's like the simplest idea of my
enclosure it's just there's nothing
wrong with data data has these great
properties let's use it in fact let's
make it a really important first class
in your face kind of thing so closure
embraces it first and foremost by having
strong data literals which I'll show you
in a minute
and they're plane right plane it just
means flat level unadorned no extra
stuff code and this is an old listing in
closure is represented as data that's
important for a lot of reasons it
enables macros and a lot of
sophisticated program transformation
things but it also means that you don't
have different stuff right the majority
of functions in closure just take data
and by data I mean immutable unadorned
stuff and they return that same thing
giant library functions hundreds and
hundreds and hundreds of data
manipulation function
ready to go they take data they return
data so if you have anything that's data
you can use all those functions on it
which tends to press you towards making
everything data because then you have
this giant library which you learn once
and you can apply to every problem you
have and in particular every time we
encounter information in closure systems
because there's different parts of
systems right there's a part of your
system that manipulates information is a
part of your system that's sort of
plumbing right or the machinery of your
program like you know a socket or
communications endpoint is more like a
machine than it is like information
right so there's going to be active
parts of your program but whenever
you're dealing with the part of your
program that's just about representing
facts and information we will always
enclosure choose plain data to do that
so there there's a small set of data
literals enclosure they're relatively
obvious right you can write integers in
the normal way and doubles the normal
way and big decimals with an M at the
end there are ratios and these are
proper ratios that don't lose precision
strings are in double quotes and strings
are java.lang string when you write that
you get a java.lang strength and so it's
just a literal for a string there are
the rules for characters because we use
data structures for programming right
there's a couple of extra things we need
but if you look at Java code is it
written all with quotes around every
every word no so job I need something
besides strings in order to be a
successful programming language it needs
symbols and it needs identifiers so if
you're going to properly represent your
code as data those things have to be
first-class
data structures or atomic data types
that are different from strings so there
are two in enclosure one are symbols and
the other are keywords and they're use
in closure which I'm not going to you
know dive into is that symbols are
generally used to reference something
else so like variables and things like
that they name something and keywords
name themselves then we're like enums if
you want they're very useful as keys in
maps for instance
that's why they're called that there are
true or false boolean literals and
there's nil which is not it's the same
that's a Java null and those boolean's
are Java new Java boolean's those
characters or Java characters etc etc
and there's also literals for regex and
then we have data structures some
fundamental data structures we have the
singly linked list right it's in parens
those are all lists their list of
numbers a list of symbols a list that
has a symbol and then some numbers
that's okay can be heterogeneous and
they grow at the front and they have
linked lists kind of performance
characteristics which means it's fast to
put something at the front and it's slow
to find the 57000 thing it's linear time
to find stuff in the middle then we have
vectors there in square brackets right
again they can be heterogeneous this
aims to be one with numbers and one with
symbols but you can intermix them they
grow at the end in constant time but
they also offer fast access anywhere in
the middle so they're different from
linked lists then and then there are
maps their key value key value key value
the commas are optional the keys not
need not be key words so this first one
uses key words mapping to integers and
the second one uses integers mapping to
strings but you can be heterogeneous in
both the key and the value and then we
have sets which are just Curly's
preceded by a hash and you can have sets
again heterogeneous of anything and all
of the stuff nests one of the important
things about this is that these maps
they scale and are efficient from the
very small all the way to the very large
so you can use them as sort of pseudo
objects and the small and have you know
four or five fields if you will or
entries or you can have a giant map that
has you know millions tens of millions
hundreds of millions of things in it the
same data structures used throughout
that range enclosure we don't
distinguish those two uses at all so all
of the data structures I showed you are
immutable there's no way to change them
just like there's no way to change 42
there's no way to change a vector what
you can do is make a new vector that's
slightly different from the vector you
started with and you
both vectors and there's a technique
called persistent data structures which
makes this making of a new slightly
different version efficient the two
versions will have a substantial amount
of structural sharing going on under the
hood and that's possible because they're
immutable right they can share structure
because no one can change them and
that's what makes it practical to use
immutable data structures all the way
through the range from tiny things
through very very large things it's not
copy-on-write right these new
modifications that you make still comply
with the big o expectations you have for
the data structure in hand and this is
the key to practical functional
programming is having this so the idea
behind closure or one of the ideas
behind closure is just this right I'd I
had done so much object-oriented
programming and like it's just so much
busy work and so much extra stuff and
when I finally later in my career
learned Lisp I saw people building very
very interesting systems out of much
much simpler stuff and I tried it and
guess what you can build exactly the
same systems out of much much simpler
stuff and I said well I can't repeat it
but I was very unhappy basically
something to the effect of I have been
wasting my time in my career doing what
I've been doing I need to do something I
need to change what I'm doing because
I'm wasting my time I'm wasting my life
doing it this way because you can build
programs the same programs better
programs that do the same things with
substantially simple stuff in fact you
can build them out of the data
structures I just showed you plus pure
functions that take those things and
return those things most of your program
you can build that way a little tiny
bits of your program you'll have state
you'll have communication you'll have
the other the other aspects I like
runtime polymorphism enclosure has it
I'll talk about it in a second but you
can build programs out of this and you
can build big programs out of it you can
build databases out of it right I've
done it I've built a database out of it
when I made closure I was targeting
being able to do everything that I used
to do in Java and C++ so I'd built
broadcast automation systems scheduling
systems yield management systems
election projection systems and exit
poll systems in although you know C++
and Java and c-sharp I believe that I
could have used closure to build
anything I ever built right with maybe a
tiny little bit of lower-level code in
small places but that's the target for
closure
I wanted to replace what I was doing I
think the programs are substantially
smaller they're simpler and they're much
more robust than an object program or
address oriented programming I was doing
to accomplish the same jobs so the idea
behind closure is let's make that de
Matic let's make that the first customer
we do things so the syntax of closure
there's no more that you just saw it
it is those data structures that set of
data structures and knows those
fundamental things are a format called
Eden which stands for extensible data
notation but it's just a grown up
version of s expressions which have been
used in the list community for years
basically you build programs out of data
structures and I'll show you some of
that in a second so the data structures
are the code the syntax is not based
around characters it's based around data
structures you know the definition of
what a function is is the list whose
head is a symbol called you know fun and
whose next thing in the list is a vector
of arguments which are themselves
symbols etc etc but the syntax is
described in terms of data structures
it's not like there's no syntax but
that's that's where the interpretation
happens and everything that would be
special in an ordinary programming
language declarations control structures
function calls operators etc etc they're
all just represented as lists with the
verb at the front that's it
that's the Lisp way also everything is
an expression and that's typical of
functional programming languages that's
about all I'm going to say about closure
the language but I'm going to show you a
lot more about the use of these aspects
of it I have a little bit more later so
Eden this extensible Data notation I
showed you some built-in things there's
also a way to extend it to
new tags that are namespace to allow you
to describe something new in terms of
anything that's already known so you
can't make up arbitrary stuff you can't
say we'll build a new parser to parse
characters and get this thing but you
can say I have a new interpretation of a
vector of two numbers and we're going to
call that a point and so on and so forth
and you can cascade these extensions and
build richer things but one of the
important things about Eaton is it's
meant to be useful as for data and code
so you saw in a previous slide I said
commas are optional that's kind of
critical imagine if in between you know
for add line in between everything you
said in Java you had to put a comma who
would like that that would be awful
right so you can't have stuff like that
so I mean how many people have ever used
any system that tried to encode
programming in like JSON or XML yeah how
fun is that
yeah so this is a little bit of like AWS
cloud formation has some functions in
there syntax which is normally
declarative so this is a nested function
call but we can't you can't do this
right you can't program like this so you
get a program using data structures you
have to have a data structure format
that's amenable to that so this is what
closure looks like I don't really expect
you to be able to read it but I just
told you before that's a list right Kirk
you know a paren defin right it defines
a function the name of the function is
words takes an argument called text and
there's implementation and so on and so
on and so forth so this is a port of a
Peter Norvig spy thong code it's as
short as the Python program right and
and that's not like a contest right it's
it it's more about this everything
that's in here is about the problem like
all the words you're reading and
everything it's all about the problem
there's no extra stuff there's no static
import blah type this type that yadi ah
extra control stuff it's all about the
problem 100% about the problem
and that's what you want right so it's
short it's free of ceremony but most
important is it's about the problem
which means it's a lot easier to look at
now and later and see what you're trying
to do what you're trying to accomplish
so once we have this format Eden and we
use it for code and we can obviously use
it for data you use it for everything
right so let's say you want to have a
DSL to represent HTML right because we
know HTML on its own is kind of gross
to generate and manipulate because it's
XML plus some randomness so this is one
of many dsls for representing HTML
enclosure but it's Eden this is the same
stuff that the program was made out of
the same reader reads this if I if I
call read which is available a la carte
enclosure I get a vector that has a
keyword that then a vector that has a
keyword a vector blood I get data I you
know exactly what I'm gonna get the data
structures I'm going to get I have a
special thing I have a Dom blah blah
blah you know I get data when I read
this and that's great
it means it's easy for me to process
this it's easy for me to write a program
that produces this so I can produce HTML
without an extra special different thing
of course we would use this for our
configuration files right why not we can
read it we can generate it we can
process it we can manipulate it
everything we know all those hundreds of
functions we know how to do we can use
to do this now add up the stuff in Java
how much have you got you have syntax
for what you use I don't know what some
parcel thingy right for that from Java C
or something to manipulate you have
annotations right you have JSON here you
have XML there right maybe for writing
your own DSL you use antler something
keeps adding up more and more more
different things and if you read stuff
with an API what do you get some API
authors idea of the Dom for this kind of
thing right what do you get when you
read XML well it depends on how you read
it but you could get this you know
machine right that calls you back every
time it gets a new element Wow
this is a Hadoop programming Netflix has
quite profitably used closure to build a
very succinctly DSL
doing Hadoop and big data processing it
looks exactly like closure it is closure
sort of embedded in closure and the
thing is you can run this locally and
then push a button and it will
distribute it over your Hadoop cluster
and run it there same thing and you can
run your own closure functions there too
and they'll ship them and everything
else so we just do this we do this
everywhere everywhere we want there's a
type annotation system for closure that
uses data there's a schema language for
closure that uses data there are many
kinds of logic dsls that all use data as
their as a representation and and this
allows you to do something that's very
interesting which is to write an
embedded DSL now how many people have
written a DSL and had more and more
pressure to make it taurine complete and
you know general-purpose alright you
start with the DSL and it did X&amp;amp;Y and
then people like could use e could you
have conditionals could you have case
could you have blown you know they
always want more stuff so one of the
cool things about doing dsls in a
language like closure is that you can
sort of you know co-opt all of closure
inside your DSL it's like oh you want to
do arithmetic well sure you know all you
have to do is expose something that
you're going to you're going to flow
through to closure and let close your
eval --it so it's very powerful you keep
doing this the other big point of
programs as data is that allows you to
write program generating programs and
that takes a few forms in the small
there's a you know capability and
closure and other list was called macros
they're nothing like C macros from from
your past maybe depending on how old
your there are functions of data
structures to data structures but
basically it says the compiler for
closure says if you declare something as
a macro then if I see that in the
program I will call your code I will
give you the form as data that I
encountered and you give me back a
different form you can do any
transformation you want which is you can
build your own syntax you can build your
own constructs you can extend the
language however you want you do not
need to wait for me or for anybody else
or for the Java jsr whatever you just go
so we're doing all this stuff with raw
data structures and and how do we
contrast that with objects right this is
the ranty part of the talk just warning
in advance so objects are like
marionettes every has their burrito
analogy but I couldn't
connoisseur not like burritos objects
are like marionettes okay they have all
these methods on them right and anybody
who has access to the object it's like
they have that that control stick thing
wikipedia says that the person who has
that is called the master mind ER I
couldn't find anybody else who agree
with them but that's a cool name like
you can remote control the object which
you can write if you have a reference to
the object you know it's type you can
call any of its methods whenever you
feel like it and whatever thread you
want right just have at it you can do
anything you want because you can call
those things so whoever writes the
object their class they have to defend
against that because what's going to
happen well in the real program you can
start passing around references that
object well now you have more than one
master binder now you have as many
masked reminders as you've shared
references to the thing and anybody can
call something at any time and what do
you end up doing the end up saying well
maybe they're friends and they're
standing next to each other and they're
like okay let's make the fancy horse you
know dance and I'll do the front legs
and the back legs and that happens in
puppetry right but in programming you
know sometimes they just go off and like
somebody's trying to make the front of
the horse go this way and somebody's
trying to make the back of the horse go
that way and it doesn't work and so you
have to have all kinds of protection and
you can't you actually can't effectively
do this Java and languages like it don't
give you an effective way to do this so
you're suffering from this constantly as
soon as you have a reference leak you're
suffering now I know you say oh I use
value objects some level you know you
don't everywhere you could but you don't
and it's not ego Matic and it's still
hard and you still don't even know like
if somebody gives you a reference right
to an interface can you know that it
will start dancing on you is there
anything in Java that will tell you
it's not going to move around it anyway
any construct anything that type system
anything no nothing so every day you
have this unhappy face and then write
the final problem right we how many
people write a program it's just the
program I like it sits by itself and it
reads you know standard and spit
standard out right compiler writers
right that's that right and they write
these great languages are really good at
that right but that's not the real world
right how do people write programs I
talk to other programs routinely yeah we
do that all the time how people put
objects on the wire Wow that is
terrifying
all right but just so you so you know a
long time ago we decided that was a bad
idea so I don't know you got the memo or
whatever but yeah objects don't travel
on wires so you can fake it you can
pretend you can make all these elaborate
things but most of most of these things
have have failed in practice right you
can you can get away with it in small
circumstances but it's not how things
work right we don't actually give
somebody a reference to something allow
them to sort of remote-control us right
so you know this is why I was saying
before if your API takes an object
especially by a reference to an
interface right so you don't have the
concrete classes definition to sort of
make you feel better about it not
changing do you know if it's going to
mutate right can your type system help
you with this which is really it's such
an important thing for the robustness of
your program to control this the answer
is no you're getting no help at all so
your default idioms leave you completely
on your own to deal with these problems
and really in a position to encourage it
encourages you to create these problems
just by accident right the other thing
is so let's say you know let's say RMI
is not allowed at your company how many
people are not allowed to use our my
intercompany everybody's allowed to use
our Wow
götze yeah that's actually not as bad
but but let's say let's say you're
allowed right and somebody says I want
you to service eyes your thing how many
people would choose RMI over something
else like HTTP or anything else
all right nobody nobody would right
because and then what do you have to do
right you have this interface you said I
took an object I expected all these
methods on the object and now I have to
talk over a wire what do you have to do
map mapping right object relational
mapping object blah map object something
map every time you want to get to and
from the outside world especially stuff
you're not writing so RMI is out of the
question right you're not going to get
like some webs website to like accept
your are my calls or make our my calls
to you right anytime you have to go
outside of your box out of your world
view your object world view you have to
map right so you know at Java
programmers and object-oriented programs
have been like you know kicking sequel
saying oh it requires object relational
mapping and that's like a problem with
sequel no it's a problem with objects
right that's objects are not the way the
world works nothing in the world works
that way people do not hand their
strings out to other people to like
start yanking on them and like that's
how we're going to build this is that so
we're going to have like a soccer team
right it's like I'm really gonna have a
reference to somebody else and like you
know and you call pass to me and like we
build this big spaghetti nightmare
that's not how the world works it's
completely not the way the world works
it's not how physics works so we say
objects on their way to model the real
world it's not at all
it's a complete programming fabrication
it's not very realistic it's not a good
fit for almost anything that's in the
outside world so you can build your own
world where all this stuff makes sense
but it's inherently I would call it
idiosyncratic but in particular it's not
the way that systems work right systems
in the large right so what are systems
well the word system means to cause to
stand and I love that idea I mean I
always think of
with these legs sort of self-assembling
to try to make something that stands up
this independent parts that you connect
together substantially independent parts
right right because you don't need to
cause something to stand that's like one
thing that already has three three legs
you're not you're not causing it to
stand up
it's the independence of the things that
matters and in general we try to build
systems in a way that makes them
independent right do we want to care if
another server is using the same
programming language that we are or the
same runtime in the same version of the
Java Runtime or the same type system do
we want to build a system like that
where we care no we don't why because
it's going to be brittle right it's
going to be hard to make changes we have
to agree with the other person right
tomorrow we're going to have this thing
and everything's going to be different
you know three to one you know we don't
do that the internet does it work that
way no right we don't we don't do
specific stuff we do general stuff and
we try to be as independent as possible
most things that happen between systems
use one of two techniques right
they use RPC with plain data out and
back or they use queues where you send
data and somebody shows up later and
gets the data you just send and you just
flow data around this is the way that
systems are built big systems big
successful systems like the internet and
most systems right and those systems are
flexible you measure their flexibility
in terms of how much independence they
support can you independently develop
these parts of system can somebody
upgrade they are part of the system and
not mess up the other person right
because like Twitter is not going to
tell your web browser when they change
their homepage and like Safari you know
do something special that's not how it
works
right everybody has independent
development independent time frames then
the other thing that's critical to this
is that if somebody else on the other
end is going to change you have to be
tolerant of things being different but
you can't say well here's our contract
you know the nine hundred things out to
be exactly this way and then I'll work
and then you'll work then if we're going
to change anything we have to you know
have lunch and have a meeting and and
and decide this stuff again you have to
be tolerant and accepting
some more things so we don't have to
change the lockstep and so these systems
are inherently dynamic and they're
inherently extensible right that's what
it that's why I just said systems are
made with dynamic types extensible types
right they can accept data that you
weren't expecting to see and it won't
make them fall over and hopefully
they'll do a good job of propagating it
right they're all made this way so this
is the other fundamental idea of closure
we should build the insides of our
systems like we build the outsides of
our systems all those value propositions
that accrue to systems we want them how
many people want to have a meeting every
time they change a class or a subsystem
how people have meetings every time they
change your class yeah you have to write
this go break stuff is going to break so
we should we should communicate using
immutable data inside our systems for
the same reason we do outside it makes
our systems more robust it makes them
easier to change it makes the
independent parts separate it makes it
easier to move them around right we get
loose coupling we get subsystem
independence we get flexibility and
what's the mapping well there's no real
mapping right this doesn't need mapping
right RPC becomes PC right we can we can
call functions we were calling functions
before there was our right then they had
our we had PC before we had our PC we
can go back to PC we can do that right
we can pass data to functions and get
data back we used to be able to do it
then we had all this elaborate stuff now
I forgot how to do it right and we can
implement queues and flow inside our
inside our programs using queues or
channels or things like that so that's
the other key idea now there's going to
be process and state closure is not a
closure as a practical language of
course you can have processing state or
there's no reason to run your program I
just make the computer hot and you go
home right you're going to have state
and effects but this is another area
where we're left just totally with
nothing in in object-oriented languages
like Java you have nothing here like
there are very fancy functional
languages that have purity although they
will force you through this
system to identify and isolate all the
parts of your program that could do IO
or have any kind of effect they'll
either do a vie a purity or V effects
systems right and then there's the
alternative to that is nothing by Muslim
most people have is absolutely nothing
and then you could also have reified
constructs that at least make a state
change explicit and that's where closure
sets because in Java and C++ and C sharp
you have nothing
we just have nothing you have some
really raw constructs like mutexes and
you know a pat on the back and good luck
buddy and read Brian's book so so
closure doesn't have any purity to it
but it has explicit constructs for State
these are like you can imagine them
being variables that have semantics to
them so it's not just like anybody can
come in and whack on this variable at
any time instead you say I'm going to
give you a function and you somehow
apply that function to that variable to
move it from one state to another but in
doing so you can ensure it's free of
conflict and free of races and it's
never going to become half of a thing
and these variables always refer to
values so you're always able to observe
them or dereference them and get out a
value there's nothing else there's only
these reference cells that point to
values and values
there's no mutable object that half of
which could be whatever or you know like
a date class that you could set the
month or things like that right a date
is a value you can have a reference to a
date you can make that reference point
to another date you can't change a date
and see things you can change which are
references and you have values which are
not you can't change dates anymore you
can change 42 maybe you can change these
references but their atomic they just
point to one thing so between those you
can get a whole bunch of different
variants right Kaz implements a
successorship model you say only make
this new thing if it was the thing I'd
you know if my presumption is still
valid right since the tiniest version
enclosure has a construct that wraps
that so you don't have to write the
right to loop or anything else say
here's my function apply it to the
inside of that use Kaz do the loop for
me and I know I'll get
a clear successorship there with no race
and no conflicts there's also an STM
enclosure that allows for bigger
transactional kinds of modifications to
occur but the point is this construct is
doing the job and the construct is
calling out here is where the mutation
is in the system here is where the state
is and the thing is you have a way to
get out of it right if I give you
something that you don't know if it's
going to change how can you save its
value like if I give you a reference by
an interface to some composite type you
don't know if it could mutate how can
you save its value what's the safe way
to do that you don't know the clone is
going to work at all sorry does not work
what else
what's role that gets ok this get that
you got nothing you have absolutely
nothing so this is like a critical thing
for making a system that works you have
absolutely nothing to do this with you
have to build up your own convention
around this so like I think you should
pick right you should either have
explicit constructs or go all the way to
Haskell because everything in between is
catastrophe and then we have a enclosure
we have something called core async
which is a channel model it's a little
bit richer than queues because you have
to set up the threads and do all the
micro rights they have semantics that
are based around something called
communicating sequential sequential
processes but the basic idea is that
you're going to try to encourage
especially when you're trying to convey
values through a system instead of
saying I'll put the Acorn behind this
tree and you come by later and find it
behind the tree
you say I'm going to put the Acorn on
the conveyor belt and you can take it
off the conveyor belt and this is a big
difference between those two things
because if you put something on a
conveyor belt and then go back to it
what do you expect nothing comparable
it's moving then that's that's it that
flowed so you can't write kind of the
logic you can write with variables going
back and re-examining a place to update
it in place and you know try to read it
again
it flows and so flow is a much more
robust way to build a system data
clothes a much more robust way than
variables so we want to emphasize flow
over places so program size matters
right smaller is better right there
there's app this is one of the few areas
where we have like research right people
have done research and said smaller
programs have fewer bugs it's just that
simple it doesn't matter what
programming language of this smaller
programs are fewer bugs write bigger
programs have more bugs longer time to
market they're harder to maintain and
they're more brittle right but what I
think is interesting is that there's two
flavors of small a lot of languages
focus on concision writes which is size
in the small like how small is your if
statement you know how small as a
function call how you know tiny are your
constructs how much overhead how much
syntactic stuff is there and there's a
lot of languages that focus on that Ruby
and Python
a lot of languages are actually very
good at concision but the the bigger
impact on a program overall right it's
not moving from you know 42 characters
to 20 characters that only gets you to X
right the biggest thing is moving from
more specificity which bloats your
program to more generality which shrinks
it that's the big payoff that's the kind
of that's the area where you're going to
get a payoff much higher than 2x so one
of the other things I think we suffer
from in object orientation is death by
specificity right all the time we have a
new thing we have a new idea a new piece
of data boom we have a new class get
this get that get whatever I don't care
if their value types whatever right it's
just a glorified map except you can't
even use it as a map in Java right
there's no generic way to manipulate
something that says get this get that
get that so new type new language gots
own little vocabulary right so you're
going to have more code you can have
much less for use you can have more
coupling right because essentially
what's happening is every object has its
own little language my class my
interface my own language this is the my
biggest pet peeve I want to get away
from this when we saw it right and get
this get that it's like this is there's
no purpose to this
this is just life-sucking so let's look
at life sucking in there in this is this
is just a tiny part I actually skipped
this is just the servlet request and I
have a little bit of httpservletrequest
which really doubles the size of this
thing
but my question to you is how many maps
do you see here we're like give a name
you get a value I got 100 I actually
can't do the auctioneer thing how many
got yeah alright so first of all this
game is hard right there there's some I
got I got three inside and the overall
thing is a map too so I got four right
off by you know picking it apart what's
really interesting is look at these map
interfaces they're all ad hoc guess what
else they're all different one has
setting one you can actually get the map
when you can get a list some you can get
out with types there's four different
maps in this one class this is crazy
right in closure we just use maps right
this stuff came over wire in HTTP as
text how did we turn it into this what
happened what happened why you know this
is crazy now who can I told you the
curly braces are maps who can see how
many math you want to you know you see
all the maps there's like there's
because there's still maps right if
you're going to write code that
manipulates that other stuff every
single line of code you write is going
to be special has to you know use
whatever Java X servlet bla right and
your rank codes explicitly to this thing
if there's another way to do HTTP not
that the risks or if what's will
probably the only way it sort of to HTTP
but if there was another way to do HTTP
will you be able to reuse that code know
it's all written it's all hardwired to
this person or persons idea of like what
an HTTP request is right so you
okay this is a tiny little benefit right
dot works in your IDE whoo oh my
goodness because I could never remember
that so I bet something better happen
when I press stop because I'm doomed
otherwise of course I could look at the
HP spec and you know like we could agree
on these names and I just don't get it
you know you can tell a kid not to put a
spoon in a blender and turn it on and
like they will remember that for their
entire lives they will never make that
mistake but grown-up adult programmers
like weed we need protection right for
from this stuff but the protection we
get is really minimal what's the cost
it's huge right that's an idiot in
inconsistent interface it's incredibly
idiosyncratic the interface is huge so
if you wanted to like have a second
implementation you know get to work
there's a ton more code to consume it
you can't use any of the libraries you
already have right with the closure
version all the math code like I said
those hundreds of functions they work on
this you can create this with them you
can read this with them you can merge
two of these with that and like you have
no new code to manipulate this no new
code all the functions you already know
manipulate HTTP requests as soon as you
represent them as data which they were
by the way before we map them right the
testing right it's easier to test data
can you make a program that makes this
yeah can you make a program X one of
these yeah okay and then certain the
other problem is your typical Java
program has two to three orders of
magnitude more of that more of this
right 100 classes to a couple hundred
how many people programs with more than
a thousand classes yeah that's a party
all right so some closure programs are
smaller in both ways they're more
concise and they support generic
programming because we just program with
these data abstractions we represent
information as plain data so I mean this
is always the biggest reservation I love
my types I like my dot I like my IDE you
know I I can't I can't deal with
something
and it's true right if you have the
types of Java right now fancier types
fancier type systems can do more but if
you have the types of Java you can you
can catch you know typos and pressing in
so when you're supposed to pass strings
but it's really likely that your tests
or your ripple interaction is going to
catch that stuff that is not a quality
metric that is not sufficient for
quality it's part of quality right no
typos right but it's not sufficient for
quality right the quality is and all
this other stuff you have where did we
say we have no way to deal with state
management we're encouraged to write
highly coupled programs we're inflexible
we're not meeting the customer
stakeholder quality metric at all in
fact we're pointed against it time and
time again we're pointed at the wrong
thing and because our code is so huge we
can't even really understand what it
does anymore so the biggest source of
bugs and programs which is
misconceptions right everybody gets it
wrong I talked to the stakeholder they
told me this I didn't think of one of
the situations when I wrote the program
that's the act those are the real bugs
and programs by everything else their
superficial bugs those are the real bugs
they're harder to see so I think this
default idioms are a big one unlike I
spend much time on this but it was
interesting to me because I always like
to look up words what this economic mean
and actually means relating to household
management right so the idea of home
economics is kind of redundant it's what
the word means and I would say that you
know sort of our programming house is
just like it's like a hoarders delight
everything there's too much stuff in it
everything is too big we need too many
people to do basic things there's a lot
more to closure this was not a tutorial
on closure but the important thing is
that most of it is in libraries closure
grows file libraries the core is really
pretty vigorously protected against
growth it's not like a you know an
experiment and language design so the
one of the part of closure I'd like to
talk about is polymorphism and it just
because it's another example of simple I
haven't talked a lot about simple but
one of the cool things about closure is
that polymorphism is independent in
other words it doesn't require
inheritance you can imagine has
something called protocols they're a set
of functions
work together there polymorphic on the
first argument so that's like the same
kind of single dispatch you have in Java
so you can imagine them as interfaces
but they don't require inheritance and
the beautiful thing about not requiring
inheritance is you can have a protocol
and you can extend it to something
that's finished you know something that
son wrote a long time ago and is never
going to change and certainly is never
going to implement your interface right
you can also take stuff from two vendors
right right because what we usually have
we have the framework problem there's a
privileged framework in Java the one
that comes with it and people implement
those interfaces but if you have a piece
of software from vendor a that has an
interface and stuff from vendor B like
objects from vendor B that you want to
use how do you get vendor be to
implement vendor A's interfaces it just
doesn't happen which is even worse than
the C++ world but in Java we still have
this problem there's a privileged
framework that people invent the
interfaces and otherwise implement
interfaces are parochial or small so we
have polymorphism enclosures is a la
carte and that reduces couple of
coupling because you don't need to
derive alright I know
Mabel maybe closure seems more
interesting now so it's not just about
technology right it's not even about
these programming things it's also about
ecosystem things like that and the first
thing that's great about using closure
is that you get to keep connection to
the ecosystem you already know not only
the runtime and the deployment
environment but those libraries right
the interrupts in both cases is
extremely good all those closure data
structures I showed you they all
implement the appropriate Java util map
whatever they all implement all the Java
interfaces you can just take one of
those things you wrote in square
brackets that was pretty easy and pass
it to something that expects a Java util
list that implements random access right
that works ready to go the closure is
also very stable you know I value that
in Java I think it's important part of
why Java grew and closure takes the same
approach is not like kids on github
hacking away adding every new idea or
it's not a think-tank experiment and
it's made for production use and it's
very stable all the programs from a long
time ago still run there are books if
you wanted to get started there's a lot
of books now
foreclosure you know I spoke here last
five years ago and people have never
heard of closure and now does plenty
there are tools oh look does an IDE that
looks like eclipse with code
highlighting foreclosure and like
structural NAB and oh that's IntelliJ
same thing breakpoints look and you type
and it starts popping stuff up this is
good we're good and you have a ripple
down there which is even better once you
get used to that there's a ton of tools
in various areas there are lots of
libraries that says 12,000 repos on
github there are lots of users the
mailing list has almost 10,000 users on
it and they're all happy nice people
I promise now they are I think that
matters if you've ever seen the old list
community they weren't all happy nice
people but close your users are happy
and nice people
that's where closures add in red monks
where our language is that like way up
there this functional Lisp what is
happening in the world look at it there
it is on the tech radar adopt it's
actually gone off the tech writer the
like of course you should be using
closure already and and there right
right people are using closure already a
lot of people are already using closure
banks use closure plenty of startups use
closure plenty of analytics houses use
closure so people are being successful
with it so I think that's the short
message for today
the idea behind closure is to get you to
better and more flexible programs sooner
and the way it approaches that is by
being data oriented and simple and I
really appreciate your time thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>