<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CON6710   Safer and Faster: New JDK Security Features and Performance Improvements | Coder Coacher - Coaching Coders</title><meta content="CON6710   Safer and Faster: New JDK Security Features and Performance Improvements - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CON6710   Safer and Faster: New JDK Security Features and Performance Improvements</b></h2><h5 class="post__date">2015-12-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/8W_8Vp6IVE0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everyone welcome to my session on
safer and faster new jdk security
features and performance improvements so
my name is Sean Mullan I'm the tech lead
of the Java security libraries team at
Oracle I'm also the lead of the openjdk
security group and if you want to follow
me on twitter my handle there is Sean J
Mullen I tweet quite a bit about Java
security also also a tweet a link to
this slide this later today so you can
download them if you want to ok I need
to show the obligatory safe harbor
statement start things off so here's my
agenda first of all how many people are
familiar with Java security raise of
hands ok at least half so I'm going to
start off with a very sort of brief
overview of Java security which will set
the stage for the rest of my talk
hopefully this will be you know for the
people that aren't that familiar be
useful rescue hopefully would be a nice
refresher I'm then going to talk about
secure by default and some of the
improvements that we've been doing to
make Java more secure by default out of
the box and also some of the challenges
that have that were associated with that
and then I'm going to talk about some of
the amazing and I mean pretty amazing
performance improvements that we've been
doing especially in the area of
cryptography and I'll wrap that up and
talk about some of the pretty cool
security features where we're going off
at JT canine it's about seven of them
and they're coming out next year and
then we'll wrap it up with a conclusion
and a QA okay so this is my one slide
overview of Java speci security let's
see if the laser pointer works yeah it's
working ok so java SE security can
basically be broken down into three
different areas at the bottom we have a
lot java language and runtime security
then above that we have a large set of
api's and libraries and then at the top
we have a small set of tools so let's
let's talk about each one of these a
little bit more detail so Java language
and runtime security component
those are the things the security
features that are built into the
language to help you write more secure
code so things like access modifiers
automatic memory management no pointer
is so forth and then at runtime there's
additional security controls things like
the bytecode verifier that ensures your
byte codes are well-formed have not been
tampered with and then optionally you
can run your application with the
security manager and the purpose of the
security manager is to guard access to
your sensitive resources and not allow
any malicious code to do any damage so
above that we have a large set of
libraries I don't know if this is orange
or red but looks more orange to me so in
probably the most prominent component is
JC that stands for the java cryptography
extension and those are our api's for
cryptographic operations things like
digital signatures message digests
ciphers and so forth to the right of
that we have a pki component which
stands for public key infrastructure and
here we have a P is for parsing
certificates validating certificate
chains building certificate chains and
so forth above that we have our jsse
component that stands for java secure
socket extension and those are our AP is
for SSL and TLS to the right of this we
have a probably less commonly used
component it's an API for the secure
authentication and session layer that's
a standard another standard for
establishing a secure transport between
client and server and then finally at
the top we have api's for validating and
generating XML signatures we have an API
for the the standard gssapi and kerberos
and the last one is an API for jazz
which stands for Java authentication and
authorization service and that allows
you to do things like plug in different
login module modules you can build up a
single sign-on solution and things like
that now all of these api's are designed
to be abstract in that you can implement
service providers which implement
different cryptographic algorithms or
other algorithms associated with these
components
so the JDK itself includes a number of
service service providers which support
all of the well known algorithms so we
support sha-256 you know a yes all that
all the the recommended algorithms and
and many more but you as a developer can
still implement your own algorithm plug
in your service provider or as a user
you could choose to use a different
service provider if you want so it's
very flexible and extensible in that way
and then finally at the top we have a
small set of tools we have key tool
which allows you to manage key stores
create certificates secret keys public
keys or all that kind of stuff we have
jar signer which allows you to create
and verify sign jar files policy tool
which is a graphical user interface for
editing policy files and we have we
shipped the three standard Kerberos
utilities k in it k list and k tab so
that's java SE security in a nutshell
okay so i'm going to start with my the
first main topic in my in my talk today
which is secure by default and some of
the challenges that are associated with
that so first I think it's I think it's
necessary to take a step back and ask
ourselves what what does secured by
default actually mean so I went on the
internet and I found a couple of
definitions the first one is from
Wikipedia and it says security by
default in software means that the
default configuration settings are the
most secure settings possible but which
are not necessarily the most
user-friendly settings and then there's
another one from OS which stands for the
open web application security project
and they say something similar by
default the experience should be secure
and it should be up to the user to
reduce their security if they are
allowed they both go on to say something
different something interesting
wikipedia says in many cases security
and user-friendliness are evaluated
based on both risk analysis and
usability tests
this leads to discussion of what the
most secure settings actually are as a
result the precise meaning of secure by
default remains undefined nos says it is
important to understand that by no means
to secure defaults mean turning off all
possible network applications or sockets
and services and neither do secure
defaults mean a hundred percent secure
environment but they should ensure the
least number of possible loopholes and
fewer drawbacks so what can you take it
away from this I think it means that
getting to a hundred percent secure
environment is just not realistic and
there are certain challenges associated
with this usability being one so what I
want to do next is look at what what are
some of the challenges that we face when
trying to provide a more secure by
default environment so challenges first
and foremost is probably compatibility
we try really hard not to break
backwards compatibility but it's not
always practical or possible if you have
if there's a security vulnerability we
have to fix sometimes we have to break
compatibility if there's a week
algorithm that's completely broken
sometimes we have to break compatibility
so what do we do in those cases we try
to give advance notice to customers or
we try to come up with a phased approach
to give you more time to adapt to those
more secure settings I'll give an
example of how we've done that in the
past a little later probably closely
related interoperability so we may want
to introduce a stronger algorithm as a
default but if most of the servers on
the internet still don't support that
stronger algorithm we usually have to
wait till the interoperability risk gets
a little lower now thankfully usually
there's pressure from the industry and
other vendors and so forth so usually
that interoperability risk goes down
quite rapidly and we're able to to make
it secure by default with not too much
too much time in between and then as
mentioned previously is usability is
always this push and pull between
security and usability so finding the
right balance is really tricky
and then there's one size does not fit
all so Java is used by millions of
applications we basically provide a
cryptographic toolkit so what we're
tried it what we see later what we try
to do is we try to keep the lower layers
as flexible as possible but make the
higher layer layer is more secure by
default phased approach which I'll talk
a little bit about later some of some of
our ideas for using a phased approach
and then finally it's just we have to
incorporate the ability to quickly adapt
to changes some of these new
vulnerabilities happen overnight so we
have to really react quickly and
sometimes we have to take into all those
other concerns I I noticed i talked
about previously but we really don't
have a lot of time we really have to fix
that vulnerability really quickly so
it's always a challenge okay so let's
talk a little bit about the history of
Java secure by default if you go way
back to maybe JDK 11 and 12 our initial
focus was to provide protection against
untrusted code so unsigned applets were
all the rage and we wanted to make sure
those applets when you run them in the
browser couldn't do any damage to your
system so we came up the idea of a
security manager and a default sandbox
policy that only granted permissions
that were were safe that wouldn't do any
damage to your system the security
manager also restricted access to
internal packages so it didn't allow
those applets and applications to use
internal AP is that were they weren't
meant to use and hadn't hadn't been
weren't standard so just to set the set
make make this point protection against
untrusted code is just as important
today as it was back then but over the
years as the scope of security API is
expanded so that orange red layer that I
showed before as those API is expanded
we realize that new defaults were
becoming necessary cryptographic
algorithms or weakening or becoming
broken
was secure back then was no longer
secure now how to do something about it
and especially in the last few years TLS
has been increasingly under attack
there's been a lot of high-profile very
visible TLS vulnerabilities and we've
had two acts we've had to go into
emergency mode act quickly and provide a
more secure experience when you're using
TLS both on the client and the server
side so going forward the module system
in jdk 9 will actually introduce
additional safeguards i'll talk about
them a little later and this is not just
for code running with a security manager
so those safeguards are going to be
enforced regardless if you're running a
security manager or not
okay so let's talk a little bit about
cryptography and and the defaults that
we provide there so as I mentioned
earlier direct access to cryptographic
algorithms by a JC we do not restrict so
this ensures long-term compatibility if
your application wants to use met md 2
which is totally unsecure go ahead but
you do so at your own risk we're not
going to stop you we do provide
restrictions at a higher layer which
I'll talk about a little bit player
however in the era cryptography one
thing we do is we have a set of required
algorithms which every java SE
implementation must support these are
evaluated each major release and we look
to industry recommendations and
guidelines to sort of come up with a
list of what should be available on
every se platform so today if you want
to use shot 256 it's guaranteed to be
available on every job SC implementation
it's part of the tck we test for it so
if if it's not there that that s the
implementation is in violation of the
tck and then some API is actually have
defaults so a couple of examples
keystore has a get default type method
that used to return jks but in jdk 9 we
are changing it to pkcs12 which is a
more secure key store format it offers
security benefits I'll also talk a
little bit about that later so we look
at these api defaults over time and we
will change them if it makes sense
another example the default api is
secure random to get instant strong
method so there's a lot of secure random
algorithms Brad could probably tell you
there's probably a dozen or so it's hard
for the developer to remember every
single secure random algorithm which is
the best I don't know so we have a new
method we added this in jdk 8 called get
instant strong and it actually reads the
secure random strong algorithm security
property which could the value can vary
per platform because some platforms have
different secure random implementations
and it returns the strongest secure
random implantation on that platform so
you can use this method and be assured
that you
using the best that's available on that
on that specific operating system or
platform okay so I mentioned earlier
that we do provide protection at higher
Laros and i'm going to give some
examples of both the pki and TLS layers
so we basically do this via security
properties we have three security
properties that control algorithm and
key size restrictions and the values
here are shown for the just-released JDK
8 you 65 the first of those is JDK cert
path disabled algorithms and that
contains a list of algorithms and key
sizes if any of your certificates
violate those algorithms or key sizes
then it will be blocked basically the
certificate validation will fail and you
won't you won't be able to authenticate
the certificate chain it also applies to
revocation information like crls and
ocsp responses and this these
restrictions are enforced by any other
component that uses the sir path API so
TLS when it's validating certificate
chains it uses the surpass API to do
that as well as when you're running
signed applets and sign webstart
applications it uses the sir path API to
to validate the code signer certificate
chain and the second property is JDK TLS
disabled algorithms this is similar to
the one above it contains a list of
protocols algorithms and key sizes if
any of those are used within a TLS
handshake or negotiation the TLS
handshake will fail the connection will
complete and then the last is JD ke less
legacy algorithms and that's a list of
algorithm cipher Suites and so forth and
in this case the algorithm and cipher
suites is suites listed loop can be
negotiated but only under a couple
conditions only if they're enabled by
default or explicitly enabled by the
application this is kind of a last
resort mechanism so it's if you're
connecting to a really old server and it
only supports this really old algorithm
then as a last resort you'll still be
able to make that connection the idea is
that over time many of these algorithms
will move up to the TLS disabled
algorithms when the interoperability
risk has gone down a bit or the
algorithm is yeah I can take a quick
question but I'd like to really lead
them to the end if that's okay okay okay
so here's our restricted algorithm
matrix as of jdk 8 and 9 for the SERP at
and TLS components on the list cioth
that's working again on the left we have
the algorithm protocol so we have md to
md5 sha-1 so forth and then whether it's
been disabled insert path whether it's
on the TLS legacy list or with us on the
TLS disabled list I'm not going to go
through this in real detail this is a
good thing to get on the slides later if
you for future reference we continue to
work on this list so it's it's not fixed
or anything it'll will be adding more
algorithms to this over time one thing
to note is md5 it's been disabled a nine
and it's targeted to the next release at
you 71 so hopefully none of you have any
dependencies on md5 anymore but be aware
that it's coming in January so make sure
you're prepared for it and that's
disabling it in certificates sha-1 is
known to becoming insecure especially in
digital signatures so work we're looking
to industry guidelines and and and we're
working on a plan for that we hope to be
able to share that to you with you over
the next few months okay
okay so you can extend those properties
if you want but it's a little awkward
you have to go into this security
properties file and extend them or
there's another way you can override
them another way you can do it is
through the algorithm constraints API so
applications can use this API to
implement their own application specific
restrictions and here's an example of
extending TLS to restrict certificates
with sha-1 signatures first thing I do
is I create an SSL parameters object I
call the set algorithm constraints
method pass it in an instance of
algorithm constraints and then I
override the permits method it permits
method takes three parameters a set of
crypto primitives so this is actually
this is what's being checked whether
it's a digital signature a message
digest and so forth the actual algorithm
that's being checked and then an
optional algorithm parameters object
it's very simple here we just check if
the primitives contains crypto primitive
signature and it starts with sha wan if
both of those are true then we return
false and when TLS if TLS validates a
certificate chain containing sha-1 it
won't be allowed so pretty simple pretty
basic
okay so because TLS has been
increasingly under attack those
properties are simply not enough we had
to do more things to make it more secure
by default so let me go through those in
a little bit more detail first thing we
did was we just well not the first thing
but one of the things we did was we
disabled but sslv3 by default that is
pretty much known to be a totally
insecure protocol not recommended for
use anymore and we do that in January
2015 and we added that to the JDK TLS
disabled algorithm security property rc4
was a trickier one the interoperability
risk was quite high there was still a
lot of servers using rc4 at the time and
we wanted it sort of we didn't want to
turn it off overnight because we knew
that would break a lot of customers and
a lot of customers would be unhappy so
we did that we used a phased approach to
disable rc4 first thing we did was we
lowered the position in the enabled
cipher Suites this was done in October
2014 in jdk 8 you 25 so that meant that
higher higher cipher suites and enabled
Cypress suites we'd be tried first and
rc4 would be tried towards towards the
end if nothing else can be negotiated
above that second phase we removed it
from the default enabled cipher Suites
so now an application to use our c4 had
to explicitly enable it by either using
the set enabled cipher Suites method of
SSL socket or SSL engine at the same
time we also added it to the JDK TLS
legacy algorithms property which
basically meant it's going to be used as
a last resort
and then the third phase in August 2015
we disabled it by default we added to
jdk TLS disabled algorithms property so
there's an example of how we used a more
of a phased approach for a high-risk
high-risk change like our c4 and we
believe sha-1 is going to be we're going
to have a similar phased approach that's
a high risk supposedly 25% of SSL
servers out there still use sha-1
certificates so it's that's that's a
pretty high percentage okay we also have
see also try to create secure defaults
for our security tools so when you're
using our security tools you often
creating security artifacts like
certificates signed jars that have to
last a long time maybe a few years up
maybe up even more than that up two
decades so we want to be able to we want
you to use more stronger algorithms at
the time that will survive those those
years so for key tool we have the
following defaults for DSA keys our key
size in jdk is 1024 but we bumped that
up to 20 48 in jdk 9 similarly the
signature algorithm for DSA sha-1 with
DSA and we bumped that up to a stronger
algorithm in jdk nine-shot 256 with tsa
so RSA the default keith's key pair size
is 2048 bits and the default signature
algorithm is shot 256 with RSA so those
are still acceptable algorithms to be
used as the dike defaults and then
finally for elliptic curve keep keys we
have 256 bits as the default key size
and shot 256 with ecdsa as the default
signature algorithm char signer is
similar we have digest algorithm that
shot 256 the default and the signature
algorithm defaults are the same as key
tool
okay so a little bit about the module
system and some of the security features
that are coming in there in jdk 9 so
first is strong encapsulation with the
module system a modules packages must
now be explicitly exported for its
public types to be accessible to other
modules so here's an example the java
dot security death sazzle module and it
exports the java x security dot sazzle
package to all other modules that means
all other modules can read the public
types in that package now it may have
other packages with public types but
those can no longer be accessible by
default by other modules which is which
is a new security feature JDK 8 they are
still accept with accessible but not
with the module system building on that
qualified experts allow you to explore
public types to one or more modules so
here's an example of again module java
dot security of sizzle exports the comm
Dotson's security sazzle util package to
jdk security jg SS so only that specific
module can read the public or access the
public types in that package so that's a
nice security feature that provides an
extra layer of security so building on
that feature the module system is going
to be encapsulating most internal ap ice
and that more details is defined in
jeptoo 60s so with a few carefully
considered exceptions all internal ap is
inside the JRE will be inaccessible by
default that's even if a security
manager is not enabled when a security
manager is is disabled you'll get an
illegal access error at runtime if you
try to access one of those those classes
or types if a security manager is
enabled you'll get an access control
exception and the reason it's different
is we want to preserve compatibility so
today if you do that and those packages
are restricted you get an access control
x exception you want to make sure that
applications that were already expecting
that exception would continue to work
so here's a little example demonstrating
how this works I have a simple test
which tries to ax instantiate a x509
simple object which is inside a package
that has not been explicitly exported if
I try to compile this I get a an error
that package does not exist I can then
use the there's a new X at exports
option to to basically tell the Java
base module to export that package to
all unnam modules and the test the test
program here is inside is part of the
unnamed module because not part of any
specific module so I get it to compile
okay I'm all set now I can run it
without a security manager and I get
this pretty long exception it says
exception in thread main java.lang legal
access error class test in module Monday
module cannot access class son's
security x5 and I and X behind sir
dimple in module database Sun security
XO and I've is not exported to the
unnamed module so that's a really long
error message but it's actually really
useful tells me exactly what's going on
exactly what what the problem is so I
personally like it and then just for
just for kicks we can run it with a
security manager and we get an exception
in thread Java security access control
exception access denied because we don't
have runtime permission to access that
class in that specific package
so one other really cool security
feature the module system is the feature
2d privileged modules that do not
require all permission so prior to jdk 9
in jdk 8 if you run your application
with a security manager everything in
the job of runtime RTR is granted all
permission so that's a huge attack
surface money most of that code doesn't
really need all permission it don't
probably only needs a few permissions if
anything so what we've done in a module
system is we've moved a number of
modules into be loaded with the
extension class loader instead of the
boot classpath loader and what that does
is it enables us to grant them only the
permissions that are needed and not all
permission so the list so far I believe
this could be evolving is the following
list of modules that have been d
privileged and this really allows us to
apply the principle the well-known
security principle of least privilege
and only grant the permissions that
those modules actually need and this is
a real example the jdk crypto EC module
and we're granting it just the
permissions it needs just a handful
permissions and it's much more secure
than granting it all permission
okay so that I hope that helped talk to
a little bit about our challenges and
some of the things we were going to
continue to make Java more secure by
default I'd like to now switch gears and
talk a little bit about the performance
improvements that we've been adding to
Java security components the last couple
of releases so in jce since Jake JDK
we've implemented major performance
improvements to several cryptographic
algorithms most of these leverage JVM
intrinsic so who here knows what
intrinsic Tsar okay not many ten percent
okay so I myself I'm not an expert on
JVM intrinsic but I'm going to just kind
of tell you what how I think it works if
you want more details definitely go to
one of the the compiler at JVM sessions
and they'll be able to tell you some
more about it so how do intrinsic swhrt
the hotspot JIT compiler can compile a
bytecode in two different ways normal
compliation or it can use intrinsic and
these are actually handwritten assembly
code for specific methods that are then
embedded in JVM code generation logic so
for some performance critical code
normal compliation is not able to
generate optimal code or use platform
specific instructions so what happens is
before compiling a method the JIT
compiler will check if there's an
intrinsic defined for that method and if
it is it uses it instead and basically
intrinsic Silao jce to leverage isis
specific hardware accelerated
instructions and there's quite a few of
these for cryptographic operations and
this is how we're able to get dramatic
performance improvement on different
types of architectures
so a little bit a bit of history of all
the improvements that have been using
intrinsic first one came in jdk 8 we
added intrinsic for the aes block cipher
on x86 systems that was done as JEP 164
and the title was leverage CPU
instructions for aes cryptography then a
little bit after that and JDK 8 you 20
we added similar intrinsic but this time
for spark systems that was for a s again
AES block cipher on spark systems t for
systems and beyond I should say in 8 you
40 we continued on this trend and we
added intrinsic for sha wan and shot to
message digests on spark systems that
was done as Jeff 207 and the title of
that was leverage CPU instructions to
improve Shah and for JD canine we're
continue on this trend again and we've
added intrinsic 4g hash used in the ASG
cm mode for both x86 and spark systems
and we've also added intrinsic for RSA
on x86 64 bit systems that's being done
as part up to 46 by Tony right over
there and it's already been actually
pushed to jdk nine so you can actually
try it out today so everybody wants to
see performance charts so I've got a few
so my first performance chart is for
sha256 on spark in this chart what we're
doing is we're comparing the speed or
the throughput of three different
providers in the blue is the Sun
provider which implements the shot 256
algorithm without intrinsic in the green
is the Oracle you crypto provider so the
Oracle you crypto provider is a provider
on solaris which is basically a J&amp;amp;I
bridge that then uses the native shot
256 implementation on solaris and then
in the red is the Sun prob rider
provider using the intrinsic I'd shot
too
56 algorithm so as you can see the
intrinsic I'd implementation handily
beats the blue one and it also beats the
Oracle you crypto Oracle you crypto
almost catches up at larger data sizes
and that's probably because at that
point the J'naii overhead becomes less
of a factor so this is pretty cool and
I'm not showing sha-1 here but you
should see similar performance
improvements it's using similar
intrinsic and the nice thing about this
is that anything that then uses shot 2
or sha want and it's going to is going
to have a performance improvement for
example secure random algorithm sha-1
prng algorithm shows a forty-eight
percent improvement in performance
ok the next performance chart I'd like
to show us for HTTPS and this is the
performance on spark we used a HTTP
servlet benchmark that was developed
in-house response size was one kilobyte
cipher suite use was TLS EC DHE RSA with
aes-128 cbc sha number of users was 90
now there as you can see there's a lot
of different algorithms associated in
that cipher suite is elliptic curve
diffie-hellman RSA a yes and sha and
that means that in order to provide
all's algorithms we need more than one
security provider so in this chart below
we're comparing the performance of
different security providers that that
we've tested against so the first row
we're using all java providers and none
of them have intrinsic and as you can
see that the performance of that is is
the the slowest throughput the second
row is we're using you crypto for I
believe Shah and AAS and then Java for
everything else that's a little bit
faster than then using the providers
without intrinsic the third one is we're
using Java providers with AES intrinsics
and Java providers for everything else
without intrinsic that's a little faster
but the fastest one is using Java
providers with a s and Sean trinsic and
Java providers for everything else that
that is the fastest performance so
basically to summarize this AAS and Sean
trinsic significantly improve
performance of HTTPS ninety-nine percent
faster in throughput over fear Java and
much less CPU usage which is also
important
my third chart compares the performance
of RSA using a standard spect JVM 2008
crypto RSA benchmark and is on solaris
on the left we're comparing it on where
we're using measuring the performance on
sparc systems and on the right we're
measuring it on x86 64 bit system now if
you remembered earlier we haven't
implemented intrinsic for spark but this
chart shows that the performance is
already pretty good this is you know
it's a pretty fast system but still it
it kind of proves that we don't really
need intrinsic seer it's it's it's
pretty good performance overall on the
x86 side we can see that the intrinsic
I'd algorithm is only fat slightly
faster than you crypto but they both
handily beat the implementation without
intrinsic they're both at least two
times as fast now for those of you that
don't use Solaris you'll be glad to know
that these intrinsic Tsar for x86 64 bit
system so if you're using Linux or
something like that you're going to see
a similar performance boost by using RSA
somewhere around two times as fast or
greater
so one last chart is a SG CM performance
and this is again this is using the work
that's in jdk 9 the the g hash intrinsic
so on the chart we have we're comparing
three different providers the Sun jce
provider in jdk 8 GA that has no
intrinsic for GCM and then we're
comparing the blue or the purple which
is eight youth 60 that includes some
performance improvements for GCM but no
intrinsic and then in the yellow is the
jdk nine with the intrinsic and the jdk
nine implementation is 62 times as fast
as the 8g a up to 62 times as fast as
the hea implementation I think earlier
or later last week I tweeted that it was
34 times as fast well I actually
underestimated that it's good thing I
didn't overestimate so the good thing is
if you're using eight you 60 you're in
pretty good shape you're gonna you're
going to get a pretty good performance
boot but still when JT canine comes out
you'll get even a much much bigger
performance boost there so that bug will
tell you about why I 80 60 performance
has improved if you're curious it's all
pretty cool a lot a lot of good stuff
cryptography isn't slow anymore it's
it's getting faster and faster so one
other performance related improvement
I'd like to talk about is one that's
going at JT k-9 and that's improved
secure application performance what do I
mean by that that means applications
that are run with a security manager
enabled so over the years we've had a
lot of users complain well I don't want
to run my application of the security
manager it slows things down you know
it's just I can't take that hit so what
we did was we decided to focus on that a
little bit for JT k-9 and see what we
could do to make it better so the area
that we focused on was the policy and
permission checking area much of that
code was written many many years ago he
had not been adapted to take take take
advantage of things like concurrent
collections you know new things like
that so in a multi-threaded environment
there were lots of bottlenecks and
hotspots and that was that was affecting
performance especially in server
environments so we went through the code
we reduced or eliminated a number of
synchronized blocks and then we also
adapted synchronized collections to use
concurrent collections to cache
different security objects we also
improve the speed of the check package
access method of security manager that's
used quite a bit inside the JRE and
finally we eliminated the name service
look up from code source hash code
that's more of a start-up performance
improvement but it's still a nice nice
performance improvement nonetheless this
overall increased the speed and
throughput of permission checks there
are a couple of the hot spots that are
remaining we know that a stack walking
and access controller do privileged are
both known to be hot spots we have some
ideas how to improve that probably not
in jdk 9 but we're looking at it
definitely in the next release so here
are some results different methods we we
use the spec J enterprise benchmark
that's a standard benchmark for
measuring performance of java
application servers so we measured that
with a security manager enabled both
before and after the changes and we note
we noticed some nice speed up in the
inclusive CPU time of different methods
22.7 percent on Access Controller check
permission sixty-four percent access
control context check permission
sixty-five percent on protection domain
applies 35.9 on permission implies and
29.6 improvement on security manager
check package axis and actually the
overall overhead of enabling a security
manager in response time is only four
point six eight percent so you hear
people say how it's ten fifteen percent
that's not what I'm seeing I'm seeing
four point six eight percent which is
pretty reasonable if we can get down to
like two percent I think there's
a lot less excuses for not running a
security manager we're never going to be
able to get 20 you know you can't get
anything for free but we're getting
close okay so the moral the story do
running team intrinsic he wins the race
okay so I'm going to talk about my last
topic which are some really cool
features that are coming in jdk nine in
the next next release of java so hope
you find them interesting so here are
the 1 2 3 4 5 6 7 features that we're
targeting for the next release in jdk 9
each of them has an Associated JEP that
you can find out more details about them
I've gone over a couple of these before
all right previously so I won't go over
them in more detail but i'll talk about
the ones that that i haven't talked
about yet so the first Jeff 229 create
pkcs12 key stores by default the overall
feature here is we're going to
transition the default key store type
from jks to pkcs12 this has two benefits
improved security and flexibility jks is
based on a proprietary format it's never
really you know been an industry
standard p kc s is an industry standard
it evolves it's supporting stronger
algorithms so we really think that's the
way we should be going forward and it
supports it's fully featured at sports
secret keys and attributes certificates
and so forth and it's it's also based on
a standard so you're more likely to be
able to interoperate with other
platforms that support pkcs12 we've
tried really hard to maintain
compatibility because we knew that
people would have all these key stores
that they've created in jdk s that are
already jks and now we didn't want
everything to break overnight so we did
we added compatibility hooks such that a
jks keystore can now recognize a pkcs12
key store and vice versa so things won't
break if you if you have different key
stores that that are already jks or
pkcs12 and vice versa
so basically the get default type will
now return pkcs12 and another really
cool feature this is we've added new get
instance methods that will automatically
probe the type of key store and then
return you an object of that type so you
no longer have to know that this is a
jks key store is a peek assist we will
figure that out for you I'll show you
example how that works so here we're
creating our default key store type
specifying the default type if we print
out the type and jdk nine it's going to
say pkcs12 we then continue to load our
key store pass it the file name and then
we specify the password and now we're
loaded and ready to go now we can do all
of those previous lines except that
print mine with a single call just call
getinstance pass at the file and the
password this will automatically
instantiate a keystore of the pkc s12
you'll be fully loaded and ready to go
so it's quite nice so he's good to get
rid of redundant code
okay so the next feature it I've already
talked a lot of it about leverage CPU
instructions there's actually a really
small feature there that's really
significant and really cool and that's
called improved provider configuration
so some of you may be familiar with how
you order security providers today so
it's in the Java security list there are
property is called security provider top
one security provider two three four or
five so forth and the JRE algorithm the
JRE algorithm when it's searching for a
specific cryptographic algorithm all it
does is it erate through each of the
providers says do you support this do
you support this first one that supports
it wins so most cases that's fine but
there are limitations with that approach
it's insufficient for providers that
offer large performance gains for some
algorithms but not for all algorithms so
a perfect example is in jdk 9 we're
intrinsic i AST see em algorithm is son
jaycee provider but the son jaycee
provider is not as fast as other
algorithms that are in the oracle you
crypto provider so there's no way we can
order those providers right now to get
the best of both worlds we're going to
get some we're going to have to take a
hit either we have to hard code the
provider name in our code which is not
really recommended so jdk nine we have a
solution we've added a new JDK security
provider preferred property which will
allow specific providers to basically be
nominated its chosen before others it's
a simple property it takes the name of
the algorithm and the name of the
provider that you want to always use
first and then once if it doesn't find
that algorithm and that property they'll
just fall back to the regular search
order so it's quite nice will actually
be shipping Solaris with a default value
for this property that will give you the
best performance overall
okay another feature is drbg based
secure random implementations here we're
adding implementations of the three
deterministic random bit generator
mechanisms described in nist 800 890 AR
1 so these are new random bit generator
mechanisms they use modern algorithms as
strongest sha-512 and aes 256 each of
them can also be better configured to
match user requirements and support for
these mechanisms are becoming very
important in some environments such as
the US government so it's it's it's
something we definitely want to support
going forward to do that we had to add a
few new methods to secure random to
support new drbg style operations and
we've also added new AP is for specific
specifying enter V input so here's an a
simple example this one is still under
discussion hasn't been pushed to jdk 9
so it's likely that the API will change
a little bit before it's before it's a
final so here we create our secure
random object and we specify one of the
three new mechanisms one of them is
called hash drbg optionally then we can
figure that drbg if we don't it's going
to use sensible defaults will document
what those defaults are so to configure
it we create a new drbg spect object
with some additional parameters and then
we call this new method that's been
added to secure random the configure
method pass that in and then we generate
our random bytes as usual so pretty
simple
datagram transport layer security that's
probably our most significant feature as
far as size and scope that's going into
JDK nine so here we're extending the
jsapi and implementation to support DTLS
which is defined in RFC s 43 47 and
63-47 now non Datagram based GLS or
regular TLS as i call it must run over a
reliable transport channel such as TCP
DTLS on the other hand allows
applications to use TLS over an
unreliable transport channel such as UDP
and an increasing number of application
protocols are using UDP things like sip
co-op srtp so it's really important that
we evolved Java to support dtls and
we've done that to use dtls you'll use
the familiar SSL engine programming
model that there's an examples of that
in the JCC reference guide a lot of time
to show an example today but over time
we're going to be updating those guides
to include examples for DTLS as well ok
I have a couple more features to talk
about they're all in the TLS area Jeptoo
49 will add support for OCSP stapling to
TLS and that's one that's been on my my
list for a while so I'm very happy this
is going to be implementing the TLS
certificate status request extensions
RFC's 6066 and 69-61 so if you're not
familiar there's basically two ways to
tech if a certificate has been revoked
the first is crls and the second is ocsp
ocsp has advantages over C or elles
takes up less bandwidth and a crl and
you can often get a more up-to-date
revocation status than crls however
client-side ocsp checking incurs
significant performance overhead with
client-side checking the client has to
make a request the ocsp responder wait
for the response then verify that
response potentially for every
certificate in the certificate chain so
you can imagine what kind of
network overhead that adds two to a TLS
session with OCSP stapling the server is
now responsible for obtaining and
sending the ocsp response to the client
and this has several benefits the most
obvious is performance these responses
can now be cached by the server and
periodically refreshed every so often
and then sent to all clients it's
instead of each client making that
request the server makes it once and the
client just has to verify the response
that comes in it also has security
benefits so if many of you are staying
in local hotels you probably use the
captive portal to access the internet
where you type in your hotel number or
name and you get access to internet that
way the problem with that is with
client-side ocsp checking you can't
check if the certificate has been
revoked there's no internet connection
yet so you're kind of get this chicken
and egg problem so Who am I really
talking to I could be talking to a
server that's using a revoked
certificate I don't really know for sure
I OCSP stapling addresses that so it
allows that stapled response to be sent
by the server and then the client can
verify it it also avoids client-side
privacy leads so with client-side ocsp
checking the osseous ocsp responder
knows the server you're talking to and
potentially your IP address now the CAS
may say they don't do anything with that
information but you never know ocsp
stapling also addresses that to use OCSP
stapling it's it's pretty actually easy
on the client OCSP stapling is enabled
if revocation checking is enabled and to
disable it if you want you can set this
system property jdk TLS client enable
status request extension to false so
there are basically two ways to enable
revocation checking and TLS first thing
is we get our ssl context then we create
a trust manager factory we want to use
the P kicks type which is the more
secure one and then to enable revocation
checking we can do either two things if
we're using the anit method of the trust
manager factory which takes
keystore of our trusted root
certificates we want to set the property
comms on net ssl check revocation to
true before we do that alternatively if
we're using peak expelled or parameters
wrapping that in manager factory
parameters and then passing into the
init method it's automatically enabled
by default you don't have to do anything
so revocation checkings enable a default
and you're ready to go on the server
side it's even easier all you have to do
is set a single system property jdk TLS
server enable status request extension
true and yes that's really it the server
will actually start contact to the OCS
shondor cashing those responses and then
if the client requests them it'll start
sending them back to the client
optionally you can set other system
properties for advanced users is you can
set the cache lifetime or you can set
the cache size and there's a few more
we'll be documenting those in our
security guides going forward okay have
one last feature to talk about and
that's TLS application layer negotiation
extension it this is basically we're
adding API support for the a LPN TLS
extension defined in RFC 7301 which
provides the means to negotiate an
application protocol used over a TLS
connection and important or a critical
consumer of this feature is the hd2
client which is defined in jet 110 RFC
70 40 did anyone go to Michael McMahon's
talk before this about the HTTP to
client okay Brad did oh he did mention
this extensions that's something that
they need and just a very simple example
of how it's probably going to work it's
not quite in jdk 9 repo yet but we're
hopefully you push it in soon so on the
client side we're going to get our ssl
parameters from the socket we call this
new method set application protocols and
we specify the protocols that we support
that the client supports in this case we
support hiv-2 and HTTP one dot one
optionally then we can set other
parameters cipher Suites and so forth
then we set those SSL parameters back on
the socket we start our handshake then
after the handshake completes we call
this new method get application protocol
to find out what application protocol
was actually negotiated between the
client and server so if it's HTTP two we
might do one thing HTTP one dot one we
might do another thing if it returns
null that means the no protocol could be
negotiated then you know you either have
to throw an error or something like that
okay so conclusion security is still
really important you know we continue to
take it seriously we continue to make
Java more secure faster and incorporate
new security features and we really want
to let you guys know what is important
to you that's how we we actually use
that data to help us decide what to work
on so I encourage you to participate on
the OpenJDK security dev alias that's
where we do all our work we do all our
reviews of features and code reviews and
so forth and definitely if you're
interested in contributing you can you
can look at that link at the bottom
which will tell you how to you know get
involved and eventually become a
committer and so forth just a few
acknowledgments I'd like to acknowledge
the Solaris performance application
engineering team within Oracle for
providing some of the performance charts
I showed earlier and of course my fellow
members of the Java security libraries
team Julie fan Frances ho jameel Nima
Jeffrey night swagger Valerie Peng
Vincent Ryan Antonia scarpino way jun
wang and bradford wetmore these are the
people that worked on most of these
features and I would not be able to give
this presentation today without them so
thank you
questions three minutes if you can speak
loudly I can maybe answer them here or
you can come up afterwards it's up to
you
yeah if it's a if it's if it's if it's
an algorithm that's yes export
controlled yes encryption algorithm yeah
yeah those are still in place any other
questions well feel free to come up and
ask questions afterwards I'll I'm free
to hang out for a few minutes</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>