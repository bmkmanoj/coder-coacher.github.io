<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Toward an Evolutionary Design and Architecture | Coder Coacher - Coaching Coders</title><meta content="Toward an Evolutionary Design and Architecture - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Toward an Evolutionary Design and Architecture</b></h2><h5 class="post__date">2016-09-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/cTyMhjyZvOs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright let's get started welcome to
this session on towards an evolutionary
design and architecture my name is
Venkat Subramanyam
I want to talk just a little bit about
architecture talk a little bit about why
you want to evolve and and what are some
of the risk of evolving versus not
evolving and then I want to get into
some practices that can help us to
create an evolutionary design an
architecture best time to ask questions
or make comments is when you have it so
please don't hesitate anytime is a good
time if you have anything to share bit
delighted to listen to you so I want to
first start with the very first question
what's architecture we all like to work
with architectures and the question is
what's architecture well as it turns out
to be there's no really one good answer
to that question what's architecture you
could just randomly walk up to people
and ask them what's architecture and and
the first response you would get is
silence what that usually tells you is
architecture is something we can feel
but we can't put into words so so that
is something that happens quite often
and then we can get into more details we
will tell you well it's a way things are
interconnected they work together well
then we ask the question what's the
difference between architecture and
design well then we realize there's
really no good definition of
architecture and we all struggle with it
which is not unnatural well for me one
of the arc articles that I really
enjoyed a reading and I usually
recommend this to any developer that I
come across and and that is a phenomenal
article it's a very short article about
three and a half pages long and it's
called who needs an architect and this
is an article by Martin Fowler and and I
absolutely love this article for a few
different reasons the first is in this
article he talks about what is the role
of an architect but he also tries to
give a definition of what architecture
really is and and you can see the
struggle to really put words into this
particular and define it and and he
defines architecture in different ways
but one thing he codes really what I
like is a definition from Ralph Johnson
and he says an architecture is a shared
understanding of essential details of a
system and I really like it because
it's a shared understanding so it is not
something that's held by an elite group
it is something that's got to be shared
by the entire team of essential you know
details so we're not really interested
in esoteric details in the system what
is really common and essential we want
to really look at it so from the
architecture point of view and and
design point of view we want to be able
to create a fairly good architecture but
why do we want to evolve architecture
well I will start with the very first
question who here things architecture is
important of course the hands go up why
would be here if not right how important
is it is it somewhat important are very
important or very important absolutely I
cannot agree more I completely am with
you
so architecture is extremely important
when do we normally create architecture
at the beginning sometimes in the
beginning sometimes even before the
beginning right I had a kind of mine who
called me and said we want you to work
on a particular project but we want you
to know there are two very important are
key architectural concerns the
application has to be concurrent and
it's got to be on the cloud I said wow
that's awesome so you want concurrency
and you want cloud absolutely if you
cannot deal with concurrency in cloud we
don't want to talk to you I said this is
awesome this is awesome thank you but
can you tell me something about the
product and they said we don't know
enough about it but it's got to run on
the cloud it's got to have concurrency
right so this is something we hear often
is it's a foregone conclusion these
things are really essential well how
could we live without it so we do this
quite often we decide architecture even
before we even understand what the
problem is
so absolutely you're correct and we do
this so if we were to take this line and
imagine this is a time line for a minute
if you will and apologize for this being
a little low here and we all decided
that we're going to create the
architecture in the beginning that
that's perfectly fine we'll leave the
thought aside for a minute now I'm
hoping you would agree something like
this is a what I want to call us a
knowledge curve at the beginning of the
project we don't have a clue what we are
doing we sometimes pretend that we do
but most of the time we don't have a
clue what we are doing
and towards the end of the product is
absolutely hindsight is twenty-twenty
right I used to work for a really
wonderful a developer manager director
he used to use the word our ad anybody
knows what our ad stands for rapid
application development that's what I
thought before I met him
he said our ad stands for the
requirements after delivery right I mean
you could never be wrong afterwards
right so that's absolutely phenomenal
you define what your product does after
you finish it how could you be ever be
wrong about it well so the point really
is we know a lot about a product when we
are done with it and we don't have a
clue when we begin to implement it it
becomes really frustrating well if this
is true and most of us can agree that
this is true what we are telling now is
that architecture is extremely important
you better not mess it up and we're
gonna create it when we have the least
clue what we are doing this is
predictably irrational isn't it how
could we be building something and
designing something that's so important
when we don't have a clue what we are
doing so bye-bye the realities of this
we already are wrong in deciding
architecture so early so but why is it
that we want to create architecture well
one of the reasons is if I get hired as
an architect in your team what is the
company what is the team what does a
manager want me to do they're gonna look
at me and say we hired you deliver the
architecture well I'm under pressure to
deliver an architecture so I want to
deliver architecture but it takes a bit
of a courage on my part to say well
thanks for hiring me as an architect I'm
not gonna deliver an architecture for
you because I don't have a clue what I'm
doing alright and that is important to
be able to say that and what I would
encourage architects to do instead is to
actually take a very proactive step and
create what I would like to call as an
architectural draft rather than creating
an architecture and let the team evolve
the architecture over the period of time
and then of course as clarity emerges
from things we can put things together
into the perspective so let's not try to
set things on stone in the beginning but
let's try
to really have a vision for architecture
but not commit to it in in the beginning
so because it's a high risk for doing
this we definitely don't want to be
creating a lot of things in the
beginning when we have the least clue
but let's talk about the risk of doing
this versus the disgust not doing it
well what are the risk of not evolving
the architecture well the risk of not
evolving the architecture is we end up
creating an architecture that often
becomes rather irrelevant to the project
realities there are two things we often
face on projects now if you really think
about the waterfall approach now we all
kind of thrown upon waterfall today but
why is waterfall so bad well I want to
say that there's actually only one
reason why waterfall is actually so bad
and the reason is by the time we are you
know implementing waterfall we create
our kitchen we create design we move
through and by the time we get to the
coding aspects of things it becomes
clear to us that we have a lack of
understanding a lot of things and so in
other words the feedback loop is too
slow in the waterfall approach so by the
time we find out something is wrong that
opportune moment I I am under the belief
that almost every project can be turned
around in the right direction but that
opportune moment to turn it around
very rarely comes towards the end of the
project if you know things are not going
well in the beginning or early on you
can change it what happens if you come
to know something is wrong towards the
end there is only one thing you can do
about it
which is called panic so the panic is
the one that attacks us in the late in
the game and there's not a whole lot of
thing we can do about it so the problem
with waterfall is the feedback loop or
the lack thereof that really becomes a
problem well the problem with not having
an evolutionary approach is twofold one
is that team may end up actually if you
have a very dominant architect who is
very adamant about or she is adamant
about having an architecture being
implemented by the team the team would
end up implementing the shrug their
shoulders and say what can we do we got
to follow the authority and they end up
implementing an architecture that
becomes quickly irrelevant and the
consequence of this is the project
begins to suffer in the long run
and when arc and some architects like
this are dominant on a project the
project eventually becomes a problem for
everybody including the architect but
the rest of the team takes the burden
more often the other thing that could
potentially happen is the architect may
not be really involved in the project
you may not be writing code and when
that architect
well the architects on a software
project who don't write code I have a
special name for them I call them the
power point Architects and power point
architects are very dangerous people
they write really draw pretty pictures
but they don't really take the project
of the right direction and the team's
often are very smart in this case they
would talk about architecture and design
to the architect because the architect
is in code anyways they'll have pretty
pictures on the wall but the minute that
architect walks in they'll close their
monitors and point to the picture on the
wall so they go implement something
totally different from the architecture
in that case of course the project is
evolving in a different direction but
the architecture didn't really guide or
serve the need in both cases the
architecture didn't really help us a
whole lot
it's usually a problem in this case well
so those are some of the risk of not
evolving where it is irrelevant and also
may be ignored or are maybe sidelined
well but let's not be naive about it
when there is I'm I'm usually a person
who likes to be objective I don't want
to play something a lot or you know
berate something a large it's got to be
a balance well pretty much we can argue
there is risk in our evolving
architecture also and we cannot be naive
about it well what are some of the risk
in evolving an architecture well to
understand what the risk are I'm going
to talk about this in two phases I'm
gonna say a planned are known feature
and then I'm gonna call about this a
surprise feature I'll mention what this
means in just a few minutes so one of
the
we often run into one project says hey
what if I'm into the seventh
sprint or seventh iteration and I want
to implement this particular feature and
all of a sudden I find out my
architecture does not permit this
implementation now I have to make so
many changes
I got a delay in this by two or three
Sprint's because we got to go correct
all these architectural concerns before
we can implement this feature while we
definitely want to avoid it well yes
that is definitely a concern we have to
be very aware of and if we don't we
would be in trouble to deal with it so
what do we do about it well here is one
one thing to think about when I say
planned our known feature well at the
beginning of the projects you have some
idea about very major things you want to
do you are really refining to find finer
grained details about these particular
features and stories but you have some
idea of what those are and when it comes
to planning your sprint it's important
to think about two things so planning a
sprint is not taking random stories and
beginning to implement it now what I
would like to do is I would like to look
at every single story let's say story s1
story
s2 story s3 and so on and I want to take
these stories and I want to look at what
I would like to call as a business value
but I also I want to look at the
architectural impact as well so you want
to take the business value of a story
and let's say this business value of the
story is let's say 10 the architectural
impact let's say is nine and this one is
another business value of ten but the
architecture impact is five so we can
keep putting these numbers around so
maybe this is five and maybe this one is
is a five as well well when you look at
all these business value and
architectural impact you again you won't
be correct about a lot of these things
but it's not a question of being correct
about it but at least thinking about it
and and evolving it and refining it now
what I want to do in the beginning is in
the in the beginning of the project is
in the first few sprints I want to work
on the most business valuable and the
most architectural ii-in
full stories now there is one problem
with this and the problem with this is
if I take on a very difficult thing to
do in the beginning my velocity is going
to be rather slow and I think velocity
is a really bad name because velocity is
really silly if you really think about
it what is velocity how fast are you
going well I'm sorry it shouldn't matter
to you how fast I'm going because I
could be going really fast in the wrong
direction what's the point in doing that
so I need to be going in the right
direction first of all and in a fairly
good speed and the time you really want
me to be fast I'm sorry is not in the
beginning of the project the time you
want to be really fast is in the end of
the project because that's when it
really matters so any time a team shows
a high velocity in the beginning I
always ask them where are you going to
take me now right where are we gonna end
because towards the end you're gonna be
slowing down tremendously if you don't
really practice enough discipline the
beginning it's gonna catch up with you
in the end so it's important that the
directional component be not just the
speed component in looking at so
velocity is a really bad measure for
that
so yes we'll be a little slow in the
beginning we are trying to do the most
important thing we are trying to address
the are crucial concern but how does
this really help with the problem
well come eight iteration or eight to
sprint well we know one thing everything
we have done so far is more important
than what we're gonna do now which means
you can compromise a little bit on what
you're gonna do now because what we have
done before is extremely important
because you did go through this notion
of prioritizing based on business value
and because you really looked at the
architectural significant ones you
probably address them well that's one
way we can mitigate the risk in
evolutionary design and architecture but
there is also this other thing which is
I call as a surprise feature well your
company your management you were the
salespeople marketing people they go to
this conference they are sitting in a
talk when they hear
a competition doing something and they
are making this frankly call that
happens sometimes right and they're
telling you the world is coming to an
end if we don't provide a feature and
you ask them why do you want this
feature yours they're saying because our
competition is working on it we have to
provide us well these are the surprise
features but there's one thing beautiful
about surface or price features the
surprise features don't come to your
project and say are you guys
evolutionary are traditional if you say
we are traditional the surprise feature
says okay I'll leave you alone I'll go
to the next door right
no the surprise features are gonna
attack any project it doesn't care
whether you practice evolutionary or you
practice traditional my argument is when
you are dealing with traditional project
you are in big trouble and surprise
features come in with evolutionary
project you are better to handle this of
course the question is okay you say that
but why well that's the rest of the
stock so we gotta see how we can prepare
and one on what way we will prepare so
that the evolutionary approach can
actually help us in the long run so we
talked about prioritizing this these
stories based on the business value and
the architectural impact so we talked
about a little bit about what
architecture is we talked about the
reasons to evolve architecture we talked
about the risk of evolving versus the
risk of not evolving but I want to
really get down to specific practices
these practices have been extremely
valuable in in developing systems and
developing architecture iron and being
able to produce systems that can be
maintained over time so I want to talk
about some practices what can we do the
very first thing is almost a trade
because we keep hearing this so much but
it is called keep things simple now
almost everybody you go to them and say
what do you think should I make things
simple are complex they would tell you
that things have to be simple there's no
doubt about it but when it comes to
practice of creating things it doesn't
happen that way well here's a simple
example for you just try this out you
just turn around to somebody during the
break and ask them what are they working
on you probably will hear them say I'm
working on this large enterprise system
with
is 8 million lines of code how many
times do you hear that
a lot of times isn't it right nobody
wants to tell you I'm working on this
simple application that is small and
maintainable everybody wants to tell you
they have a monster they are dealing
with that work why because it feels so
proud to say we are these warriors
fighting these monsters every day right
and I ask the sky one day why are you
working on an application who's just
eight million lines long and it's a very
large enterprise applications yup that's
right and I said what does it do he says
it gives me sleepless night it's given
me all certain and not to you
but what does it do for the company he
said we haven't gotten there yet so it
is a monster we are building and we love
building monstrous applications but what
if we build applications that are simple
and cost-effective and they produce
value and week make revenue how cool
that would be so keep it simple but what
in the world is simplicity well it turns
out most of us do not know what simple
really means yeah we know what simple is
in kind of a term as simple as but when
it comes to the details it's really hard
one day I was sitting around with a
group of developers and I was
complaining how much duplication of code
they have in front of them they had
about you know hundred 50 lines of code
every six or so lines duplicated in the
function and the function was very very
long and I kept complaining that this is
complex and unmaintainable
well a few minutes later one of the guys
couldn't take it anymore he said I'm
really sorry when could you keep using
this word complex we collectively think
this code is simple my jaw dropped I
said you don't want to call this simple
explain to me why this is simple and he
said well notice the first six lines
it's a simple if statement and we just
have that repeated about 30 times so
what's wrong with that and that's when I
understood the word simple doesn't mean
the same for a lot of us so simple well
the complexity actually came from the
duplication of code in this case the
complexity came from the knowledge
that's been spread out through this
function rather than being cohesive and
so lack of cohesion
leads to complexity and not simplicity
so what is simple the first thing I'm
gonna say is a simplest intuitive you
just get it you look at it and you know
what's going on right say intuitive Ness
is very important simplicity is
intuitive
well the simplicity is also where you
have fewer moving parts in it when you
look at this code there are fewer moving
parts than it you don't have mutable
variables and state change everywhere
you're trying to scratch your head try
to figure out what's going on simple has
fewer dependencies it is not a very
heavily coupled system where you have to
start it up you got to set up 30,000
things before he can run this it's got
too many moving parts through coupling
for example a simple code fails less it
is robust it stands together fairly well
and it is easier to work with it's
easier to you know configure and stuff
like that
so we want to keep things simple so how
do we make things really simple well one
way we can make things simple is to
remove unnecessary parts from the code
or not bring in in the first place
one other way to make things simple is
to make it cohesive we want to make
things focus narrow and do one thing
well and we can make things simple when
it takes on a single responsibility and
focuses on what it does one of the
things we should also be very willing to
do is do continuous refactoring of code
now this is something we have to do
almost constantly is the refactoring the
the red green refactor mantra but I'm a
huge fan of a mantra which I try to
follow and I'm not a big fan of sitting
down and saying we got to write a
perfect code it's really hard to write a
perfect code in one sitting so we want
to first get something working we want
to get the feedback going hey does this
make sense is this what we want to do so
I'm a huge fan of this mantra a make it
work make it better but I want to add
one more thing real soon I want to add
that real soon to it not in the next 7
months but maybe in the next 7 minutes
or a few hours so make it work make it
better real soon he's a mantra that I
follow quite often so
I don't care a lot about stuff when I
start doing things I want things to kind
of you know come together and once they
come together take shape then I would
spend time refactoring to make it better
so that I have a better understanding of
what I really want to do it seems to
serve my purpose now let's make it
easier to understand easier to maintain
simplify it and get going forward from
that so I want to be able to really
refactor this code along the way and and
make it better in a way I would actually
argue the way I want to write code is
something that I really learned as a
child observing my my dad my dad was not
a programmer but he taught me a few
things by doing things so one of the
things we would do is we would put me a
fixer maybe a shelf or a cabinet or a
chair we would do things together and as
a child it was fun to watch my dad do
this and he would let me you know
participate in it and one of the things
he taught me kind of stuck to me after
these you know several decades now and
and that is when I was trying to let's
say I want to put together this this
desk I would as a child take one plank
and I would tighten it really well
before I came to the next part
my dad would quietly watch me do this
and by the time it came to the next one
it would be in a completely off angle
and it wouldn't fit at all and then he
would then show me well the reason is
you perfect at one part really well
before you give a chance for the other
part to even come in and this was a
lesson that stuck to me because nowadays
you know I teach my children to do this
and I told them hey look what granddad
taught me taught me and you just tighten
this enough and then you tight each and
tight in each of the component and then
you go around and tighten them well a
software is a lot like that the more you
perfect one area the other things become
misaligned you kind of have to evolve
them and then start really tightening
them along the way that becomes really
helpful to do well we don't call it
tightening around we call it in a fancy
word refactoring so we can refactor the
code around and make it better this
gives us a little bit more capability
for us to be able to do this well given
that one thing that I admire the most
when it comes to software
is this ability for a reversibility
reversibility is extremely important so
what is a reversibility a reversibility
is our ability to back out of design
decisions back out of any decision
reversibility is phenomenally important
so if I'm gonna make a decision today
how much can i back out of the decision
how much can I come to you and say never
mind that we don't want to do it that
way let's go back and do it some other
way
so reversibility is extremely important
now let's say for example you decide to
choose one type of parser and three
months from now you realize that parser
is not really performing well or it's
not doing the job really well how do you
back out of that parser and use a
different parcel
well reversibility is not always
guaranteed and there is a cost
associated with a reversibility also one
of the things I would ask developers to
do when they make decision is to make a
very explicit question to the team how
reversible is your decision if they can
answer that question explicitly it's a
very important question to answer if
they tell you this is very reversible I
don't have a problem making that
decision now because I can back out of
it later if I have to but if they tell
me this is a very irreversible decision
once you commit to this it's expensive
to change it I'm gonna tell them hold on
don't make the decision now I want to
wait until I can no longer postpone this
so reversibility is something I value a
lot so to give you an example and I've
learned a few lessons about
reversibility this was way back in time
when I used to work with different types
of databases we switched a particular
database and it took us a long time to
make code change to it and when somebody
told us throw away this database and use
a different one we basically said I'm
sorry we cannot do that we are we have
no way to do this unless we do a total
rewrite of the application so what why
does why is it so hard to do reversible
one thing that makes a reversibility
really hard is coupling and I want to
use the word surface area
what is your surface area of your
coupling if a lot of your code depends
on this particular piece of library or
software well if the surface area is big
you are going to be in trouble when it
comes to diversability
because detaching it is expensive if you
lower
narrow the surface area and you do
decoupling and you do loose coupling it
becomes easier to reverse out of those
decisions now there are certain
decisions that are very expensive to
reverse out of one example is the
language that you are using if I come to
you and say change your programming
language your project will laugh at me
because programming languages are almost
irreversible that is not to say that you
can use a different you cannot use a
different language in your application
in bits and pieces and parts you can but
the predominant language is really hard
to reverse out of that's very incredibly
difficult but just because you want
reversibility doesn't mean you should do
it
you have to also ask the cost of
reversibility how expensive is it to
reverse out and also just because
something is reversible in theory
doesn't mean it's actually reversible
for example here we are using JDBC or
DBC whatever technology to talk to our
database so we should be able to swap
out the database right oh yes of course
oh thank you but what do we do about all
these stored procedures oh darn it never
mind then so the point really is just
because something is reversible doesn't
mean it actually is reversible so when
it comes to designing ask your team how
reversible is this particular design
decision if the reversibility is pretty
high well then make the decision and
move forward if it is really hard to
reverse out delay the decision to give
you an example a client of mine wanted
me to use a third party software and I
had not heard about this before and that
was a risk for me because I don't know
what I'm getting into and I asked them
how important it is for them and they
said it's very important and so
thankfully this is what experience
teaches you write experiences somebody
said experiences where
you can make all your mistakes before
your luck runs out so in this case I've
learned a few things over the years and
what I did was I wrote the application
in a way that I am very loosely attached
to this library they wanted me to use
and when I got it done we did a fairly
good amount of demo and the performance
was horrible
we sent a sample of the code to the
vendor and and eventually they came back
and said no you're not using it for the
right purpose this tool was never
intended for this and with that I had to
go to the client and say look the tool
you guys wanted me to use he's not
working but Who am I to tell you that
I'll release with this but if the
performance really sucks
don't blame me anymore because there's
clear evidence of this and at that time
they came back and said oh gosh you know
what never mind then can you reverse out
well that's that's basically what I get
paid for if I tell them oh yeah I can
reverse out but I need another seven
months that's not going to be fun for
them definitely not fun for me so as a
result yeah sure no worries we can flip
it out you know very quickly and change
it because anticipating this potentially
is going to happen you reduce your
surface area and and you be couple and
and work with it so reversibility is
something we need to really think about
but I did mention a few times about
postponing things so I want to talk
about this thing called last responsible
moment I want to emphasize I'm one of
those guys who is never associated with
procrastination a lot of times people
will look at me and say well why don't
you just wait a minute why do we need
this now I'm the person who is always
eager to do things and I'm not a lazy
person I'm not somebody who
procrastinates in my life but when it
comes to software decisions I'm the
complete opposite I would always say we
don't need to do this today we can
postpone it let's do it later let's do
it later let's do it later now why do I
want to postpone it well I'm gonna ask
you the question how many of you here
think that you are smarter tomorrow than
you are today
well okay hence go go up uh that was one
guy who disagreed he said I was smarter
yesterday and today nobody liked him so
everybody of course likes right we're
smarter tomorrow than we are today why
well because here we are little
sir as in being a little older very
little but still and IELTS of course we
got more information in front of us we
learn a little bit more about things
than we do today
clarity begins to emerge as time goes on
in that knowledge curve we are better
off in the future than we are in today
right
so by postponing decisions to a later
time we can definitely make a better
decision
there are times you may decide you don't
have to do something or you can do it to
a minimum what you need to do or in a
better way so postponing is extremely
important well so the last responsible
movement is not procrastination
procrastination is when you have not
done a decision that you should have
done already
last responsible moment is doing it and
earlier is too early doing it any later
is procrastination so that is the last
moment can beck says courage is
postponing the decisions of tomorrow -
tomorrow I think that's a wonderful code
to think about because it's courage to
postpone the decisions of tomorrow
tomorrow we often do it eagerly because
we are afraid to postpone things but to
develop that courage is very important
so the postpone the decisions is is very
important now if something is going to
cost about the same to do now as in the
future I would rather do it in the
future because I would know a lot more
about it and I can implement it if
something is gonna cost a lot less now
than in the future well if it's gonna
cost a lot less in the future then now
certainly I want to wait for it if it's
gonna cost less now than in the future I
would then ask the question what's the
probability if the probability is very
high that I need it
I might implement it otherwise I may
just risk that and wait until I know
better to implement it because I can do
a better job later on but when it comes
to last responsible moment we cannot
treat that in isolation so I'll give you
an example about this I had a a six
months window on my hand and I had to
implement this project in six months I
just gave a very severe cutoff time I
got six months on my hand well okay what
am I going to do in six months I'm gonna
implement these features I'm deploying
it and I want to release to the market
well I started the very first day and I
knew one thing extremely well I don't
have a clue what I'm doing so I need to
be changing the schema I don't know
maybe thousands if not hundreds if not
thousands of times I'm gonna change it
in the six months I want to be able to
trash my schema and recreate it as my
understanding gets better so what I did
as I created this project is in the very
first week I sat down on what's a very
one of the very first few things we need
in most of the applications if it's a
crud application I know it's a foregone
conclusion
I need a database now almost everybody
in this room will agree with me nobody
in the right mind would ever release a
product with SQL like three as the
database well but there's one thing I
love about sequel i3 I can blow away the
database because it's a silly file and I
run the application again it creates it
I don't have a database management
system I don't have a service I don't
have a daemon running it becomes
extremely fluid to create this so I
started building the application with
SQLite 3 on the day one well remember I
said this is a six month project I was
to the end of the fifth month and I had
not chosen the database I was going to
use and that day I remember clearly I
was about two weeks away from deployment
now you may say why were you so
reluctant to pick a database there were
two reasons one is I really don't want
to deal with the database right now I
can blow away the file and run it again
this flexibility was just amazing less
friction more mobility the other reason
is this application had to run on the
cloud honestly I had not chosen which
cloud I'm going to deploy it in well
depending on the cloud you were select
there are a lot of decisions that go
into it what is the cost for deploying
on the cloud
what kind of databases are available
what are the prices you gonna pay for
this it's an economic decision that
comes too well by this time I had
decided where I'm gonna deploy and what
databases are available to me and I
remember clearly that morning I came to
work and I said ok this is the last
response moment
really was not but it felt better to say
that well I've got two weeks more and to
be honest my heart is little pounding
here saying okay what if things go wrong
you got only two weeks more I don't even
have a database you know integrated yet
so I remember coming to the office turn
off the phone
you know told everybody that need to
call me don't call me I'm gonna work on
this so I start at my desk and I said
okay here's the database I'm gonna use
so I have the database installed locally
on my machine for the test purposes and
I then change the Quran all the
automated tests I've got thousands of
automated tests I ran all of them
everything worked I flipped the
configuration do not use SQLite and use
the real database I ran all my tests and
I watch in front of me about three or
four tests miserably fail that moment is
called the moment of panic I'm like
where's mom I want to call her I need
help right because you're two weeks away
and something is failing and I remember
telling myself calm down venket and I'm
not making this up all I did honestly in
true honesty is I was panicked I copied
the error message from the console paste
it on Google the first stack or flow
message said if you see this message
your database string.format
needs to change I'm like I can handle
this so I go in there roll back the
configuration to sqlite3 make a change
the database schema and run all the
tests all the tests are still running on
sqlite3 with the change to the database
a type of the record then I flip over
make the change again all my tests are
passing that's the last day I used
sqlite3 on the project comic the code
move forward now this is a lesson learnt
in several ways for me to have that
courage to postpone the decision until
the last responsible moment gave me the
agility to focus on the problem then
change the schema to my heart's content
but there is one thing that I did not
realize until that point about last
responsible moment
why don't people wait til the last
moment and that is the other missing
piece if when I did this you can ask me
what actually failed well what actually
failed in my application was a
particular page that users who are new
to the system will actually never hit
once they've used the system for a while
they would get to that page
now imagine had a manually tested the
code I would have flipped that database
over I would have done some testing at
the high levels for things that users
would normally go through and the bug of
this not working for this data type
would be a ticking time bomb in the code
and I cannot even imagine flipping the
database and checking in code for this
ticking time bomb waiting for it to blow
up a few months after I go into
production that makes me really you know
scared well the fact that I had
automated past it immediately revealed
to me a problem in the system and so it
dawned on me the reason why people don't
want less responsible moment is in a lot
of applications we do manual
verification of software well when
people start testing the software early
on yeah they go through and manually
verify it so many times the testers run
the code every time you make a change if
you make a decision early on there is a
lot of time for that to be tested over
and over and in the end if it doesn't
work you can blame them for it well we
have had it for a long time you guys
didn't take the time to test it if you
make a decision later on and if it
doesn't work they're gonna blame you for
it
well you guys just made this change
recently you never gave us the time to
test it so I dawned on me well you
cannot use last responsible moment if
you don't have a fast feedback loop I
wouldn't dare to make this decision of a
data base later on had I not done
automated testing on the project so it
kind of goes hand in hand if you want to
be able to postpone your decisions to a
later time you definitely won't have
that feedback loop that
and tell you that things are still
working and if we don't have that
feedback loop it's really hard to make
the decision later on because it's a
high risk often time so that is
something to think about in terms of how
these things relate to each other the
next thing to think about in project is
to use this principle called the yagna
principle the agni principle stands for
you aren't going to need it and I would
normally put a little Y in the end to
say you are not gonna need it yet so it
makes people feel a little bit better
maybe I can do this tomorrow huh so you
can just postpone it until you don't
have to do it
so the yakhni principle is very valuable
now yakhni principle simply says don't
do stuff you don't really need to do
postpone it to the point where you can
avoid doing it now to give you an
example of this I was working on a piece
of code where I was writing a test and I
was pairing with the developer writing a
test writing code and the middle of
writing the code I said to myself oh
wait we need to handle this edge case
and butter I write a little piece of
code he elbows me and says aha or in
you're not supposed to write minimum
code to make this test pass and then go
write the negative test and then come
back and write the code like yeah you
were right so I removed the little code
I wrote made the test to pass and now I
wrote the negative test which is
supposed to fail because the code
doesn't handle the condition so when I
wrote the negative test and ran the test
to both the first surprise the test
actually passed he said venket are you
that good that you sneaked around and
wrote the code when I was not looking
it's like no no no you told me not to
write it I you respect that I didn't
write it so I open the code and sure
enough there is no code to handle this
case so he both are kind of stumped me
like wow how does this work and that's
when we realized that the underlying
library you were calling was already
handling this situation and had it
written this code that would have been
an absolutely useless code the test is
very important because tomorrow we may
change the library and the code should
tell us whether that condition is being
handled or not but that code was
completely useless the more code I write
the more useless it is but this also
something we do quite often is we
implement code if implement features not
because the users tell us that's needed
because we developers sometimes feel
that that is needed that feeling is what
gets us into trouble a lot of times so
just to go over and ask the developer do
you need as the customer do you need
this is it relevant to the problem can
help us quite a bit well I'll relate
this to how restaurants serve food I can
only talk about the u.s. here in the US
a week you go to a restaurant it's an
insane amount of food they service and
oftentimes I go to restaurant order food
and they put this you know plate of food
in front of me sometimes I'll look at it
and say why aren't they serving me so
much food is this my last meal and I
don't know this right so it kind of
makes you wonder well a restaurant serve
a lot of food and I remember one
experience I went to a restaurant after
a very long international trip I sit
down and the waiter comes to me and says
what can I get you and I said I want
this this this and this and he kind of
bit his lips and he looked at me and
said who else is eating with you today
I said it's just me I'm just hungry I
want all these food he said no I'm not
gonna serve you this I got a little mad
for a second is what do you mean you
won't serve me this you said well here's
the deal
you pick half of what you ordered any
half you pick it's yours and if you
finish it the other half is on me I
won't charge you I'm like this is cool I
like this offer already so he serves me
half the food and I only managed to
finish half of that food and he comes
back and says you want more like no
thanks for bringing sense into me so
this is something we don't realize often
times but a lot of times restaurants say
can I get you more right because they
want to take your money and not serve
you the right way
well programmers write a lot more code
than they need to do like restaurant
serve food so we need to have the
courage to say I'm not gonna implement
this feature now because I don't need it
just to give you an example of this I
worked on a project where I had a
feature list I send it to a group of
people they looked at it and said yeah
these things look good go ahead and
proceed with it well when I finished it
and I released it one of those people
who looked at it really saved the list I
sent originally and came back and said
AHA I saw what you have done here I
looked at your application in production
and I compared notes to what you have
there to what you said you're going to
do
I'm surprised you only have 40% of the
features what about the other 60%
why didn't you implement it and my
answer was you know I had only so much
time on my hand so I had to pick and
choose what I can implement during this
time and I rejected the other things
well five years later I can tell you
what happened five years later there are
some features I had in my old is in a
list that do not exist in this project
today and the short reason is nobody
cares nobody ever came to me and said
would be so cool to have it that's first
thing second there are features in the
product that I never ever thought about
on initially but these features directly
came from active users they came back
and said it'd be so cool if you can make
this happen hey if that's what you want
you're a paying customer I'm gonna do
this for you now so there were features
added driven by the customers and the
third thing there are a few features
that are in there today that were in the
original list but the way that I
implemented now are very different from
what ordinary thought about because I
have more understanding of the system
today than I did you know when I started
out so by postponing things until the
point where we don't need it we can
benefit quite a bit and we come back and
do it but what about extensibility well
accessibility is so important we want to
make systems extensible but my argument
is if you can't do a lot less today it's
easier to come back and make changes to
the system tomorrow then when you do
more Ralph Johnson said this is the best
way possible I think he said we built
hierarchy of classes and interfaces and
we built all of these with good
intention for providing extensibility
but in doing so we have created such a
monstrous hierarchy that when it comes
time to extend it it becomes really hard
to extend it so a lot of times what we
set out to protect us comes back to hurt
us in the long run so by keeping things
very minimum we can make a better deal
and that's exactly where parsimony comes
in so what does parsimony parsimony is
being very stringent and do absolutely
the minimal thing you can do to
implement what you have on hand so want
to combine these two together one of the
things I want to emphasize is that
postpone things and do the minimum thing
you can do to get away now and come back
and extend it later on when you know
more about it so for example let's say
you're implementing a piece of code well
to make this extensible I gotta
implement an interface
I gotta implement a hierarchy of classes
well you know what you're right but you
can you can do it now or you can do it
later so wait until the very first
change comes through and when that
change comes through go ahead and make
it extensible than doing it in the first
place and if you do that you end up
having a lot less code to deal with in
the long run and you can quickly make
the change at that point writing the
cohesive code is more important than
making the code example on day one
because it can be extended fairly easily
so this brings back to one thing that
kimbuck talks about is called
triangulation and triangulation he says
well when you are creating a hierarchy
of classes you get this monstrous
hierarchy you have to maintain it
becomes very expensive one of the things
I've learnt is I don't start by writing
interfaces I don't start by writing
abstract base classes when I want to
implement something I just write the
class and be done with it and that might
be in the system for a few days to a few
weeks and then comes the day when I
gotta do something very similar to word
but not exactly the same at that point I
would implement the second piece of code
there will be quite a bit of duplication
between the two pieces of code you may
say wait a minute isn't duplication
really bad well it's only bad when
others see it so as long as they don't
see it that's pretty cool so you have
this duplication in front of you but
this duplication gives you the
opportunity to see how these things are
relevant respect to each other once you
realize remember to make it work make it
better once you realize these things to
are doing what it's supposed to do then
you extract the commonality to a
abstract base class so this is
triangulation where you take these two
and you pull it up and you triangulate
this commonality and
oftentimes when I work with developers
this is a cause of tension a lot of
times there would be eager to create the
interface it'll be eager to create the
abstract base class I'll be the one
saying don't do it now let's wait until
we know more about it let's pull it up
later on well it's a little bit
difficult for them because the concepts
you have learned the theory of learn
says you got to build a site Archy and
once they go through this they realize
that the interface or the abstract base
classes they create often ends up being
extremely practical the method names are
very relevant based on the real use than
the hypothetical names we think of from
a distance so it leads to a better
quality code as well when we triangle it
and so by doing this we want to also
make the code extensible and easier to
evolve and this is where Paul stills law
comes in so what is parcels law say
parcels law says be very generous about
what you receive and be very
conservative about what you send so this
is a very important mantra to keep in
mind I'll give you an example of this at
the code level so I say that I want to
do inventory and I'm gonna say here is
our a list of books and I'm gonna say
you know books well if you look at this
if I don't have an array list with me if
I have a link to list
I gotta convert the linked list to an
ArrayList and send it to you you have
very rigid about what you receive in
this context well we can do a little bit
better about this
why don't we receive a list rather than
and are a list and not better you are
telling me you're happy to receive a
list well that's great if I have an
ArrayList I can send it to you have a
linked list I can send to you oh wait a
minute I have a set with me I can't send
you a set now I have to convert a set to
a list and send it to you well what
about a stream of books well this is a
lot better because a stream is not tied
to a particular implementation heart
this could be an iterator if you want to
think about that because an iterator
could be on a list or a set so
this is an example of how you can be
very generous about what you receive but
of course when you send it you want to
send you a specific type this is at the
code level but a system level we can do
this too imagine I'm a micro service or
I'm a I'm a service endpoint and I'm
going to receive a data from you and you
are sending me let's say a JSON data or
whatever data it is well at the gate I'm
gonna ask it to verify Torelli the
format of what you're sending to me at
the first thought this looks like a
brilliant idea ah this is awesome you're
gonna stop this at the gate verify it if
the data looks good pass it in otherwise
rejected well let's say I implement the
service and you are the you know client
communicating with the service
everything works fine
here's another client committing of the
service everything works fine three
months goes by he comes to me and says
hey why don't we do this I want to send
you an extra piece of data I want to
send you a piece of data that's not
currently handled can I send it to you
hey that seems great why don't you send
it to me well now we are modifying the
schema so you can send me a little bit
more data well all of a sudden his input
is no longer valid and we got to go
through the schema evolution and trouble
with it right but if you really think
about it the part that he is modifying
he is very different from the part that
he is really interested in by being so
broad in what we are verifying we are
actually making it worse
so the pub the the pastas law says try
to be very generous about what you
receive don't bother
validating and verifying stuff that
doesn't really matter to you just it's
kind of the general rule mind your own
business right so don't try to police
through the system and say I'm the
guardian of the data format well keep
your focus on the data you care about so
the rest of the system can really evolve
without affecting you so this data
actually may be flowing through the
system but you don't become the
bottleneck because some part you don't
care about has changed and you can be a
lot more easier to evolve it what about
reusing this modules well reuse is one
of those Holy Grails
and and Grady boots says
first use a system then come to reuse it
well the problem is this for something
to be usable it's got to be very
specific for something to be reusable
it's got to be general there's a tension
between these two we have to fight all
the time and it's incredibly difficult
to create something that can be reused
and we end up actually creating
something reusable and in the process we
end up creating something that's not
even usable anymore so if you really
look at the track record of systems that
are very reusable there is a very common
property they never set out to be
reusable they started using it they
refactored it and then they reused used
it in another project then there he
factored it and they ended up using so
many times it automatically became
reusable over time so what are the best
ways to make something reusable is to
actually put it to multiple uses and
extract that from it and the last thing
I want to mention here is something
that's near and dear to me which is to
minimize the libraries and frameworks
now this is what I'm not going to say
that the past was better than now but
there is some aspect of past that
protected us when I was a very young
developer there was no internet this is
always fun to tell my kids they look at
me and like where were you from Stone
Age well there was no internet when I
was a young developer and thus the
systems we used software literally came
on tape drives so yes I have done that
I've got a lot of gray hair but because
of that so when I wanted to use the
library I first have to go look up and
find out what's available then you get
an approval to purchase it then you send
out a purchase order to get it
eventually a tape drive arrives you then
install the tape drive and install the
software from the tape drive when you
have to go through all of this you can
really really want the software to use
it well today you can download it while
you're downloading it you're downloading
a different version because you don't
like this already well the fact that
software is available for down
Lord leads to some issues as well we
have to be very careful about recently I
was working with the team and the
developer complained to me they used to
run a lot of automated tests but they
quit running it I said oh my gosh why do
you guys quit running your automated
tests and and he said well that's
because we got so many dependencies we
upgraded some of the JavaScript
libraries and that tests quit working
and I said okay how many libraries are
you using he paused for a second and he
said in this project we only use 150
libraries I said are you kidding he said
no and he opens up is a package.json
file and shows it to me through the fact
there are a hundred 50 dependencies and
I asked him I mean these are not
internal dependencies are direct
dependencies right and I asked him why
are you using all those libraries he
kind of shrugged and said because we
found them so that is so true right
people just helped that's nice I'll use
it well the more you use the more burden
you carry with you and and the more
things you depend on the more brittle
things become harder to maintain over
time and I have a principle do not so
I'm going to use the word by but it
plays the word by with download for a
minute buy and download treat them as
equal for a minute so I'm gonna say
never build what you can buy or download
so there is no reason to build what you
can buy our download never buy a buy our
download what you don't need and and
that is something extremely important if
you work with me on projects you'll get
to a point where you're angry because I
will ask you to defend why you need to
use something because every dependency I
bring in I vetted really hard because I
don't it's easy to bring in the
dependency it's so darn hard to get rid
of it and that is something I would work
really hard to give you a recent
experience I was working with a project
and I wanted to do a little feature I
googled and there are libraries to do it
so my immediate reaction
I can download this library in five
minutes I can have this working and then
I ask myself if I'm gonna do this for
myself
I don't need all the bells and whistles
this gives me I just needed one small
part how much time would I need it and
my answer was you know what I need about
30 minutes to build it and I put a clock
and said okay at the end of 30 minutes
if you're not done you're gonna just use
it and thankfully I was able to build
this in 30 minutes how about three weeks
later I have to make one more change to
it which took me another five minutes
but today the beauty is I have automatic
test running on it I've upgraded my
frameworks a few times already but that
code has not been affected but the times
when I have dependencies I can't move
forward how many times you hear
developers tell you we cannot move to
Java 8 because fill in the blanks what
you know server-side technology are
using well III worked with the quite a
few clients in Europe and they zip it as
if they just upgraded I asked them hey
my American colleagues are just waiting
for a long time years how come you guys
are upgrading to Java 8 and other things
so quickly and the answers are we don't
use those libraries and frameworks that
most people depend on by keeping their
dependencies small it gives them the
agility to move forward as well and that
is something we have to evaluate moving
forward so to summarize what we talked
about there are risk to evolve
architecture there are risk to not
evolving it but we can mitigate the risk
in evolving by planning the project in
terms of selecting features that are
very critical business value driven and
architour impact architecture is
something we have to really evolve over
time and add for it to stay relevant and
there are things we can do to make this
evolution rather easy one thing is to
keep things simple as as much as we can
to remove unnecessary details and
complexity to continuously refactor
consider reversibility if a decision can
be backed out then be willing to make it
so easily if it's hard to reverse out
postpone it until later time well last
responsible moment really has a great
value but to achieve it we really need
to improve our fast feedback loops
without it it's really hard to achieve
that as well I'm a big fan of the yagna
principle to avoid doing things until I
can know
are avoided so we can develop code
minimalistic alee with the extensibility
of course we want to really focus on
creating minimal code so it can be
extended
that's where parsimony and triangulation
comes in parcels law says when you have
interfaces communicating across make it
less brittle by being very generous
about what you receive and use it
several times before you can think about
reusing and minimize what you depend on
by by following some of these things we
can promote a lot better
evolution of architecture and design and
and we can then come back and evolve it
and and improve on it based on the real
needs of the project then high positive
things we can think about in the
beginning of the project that's all I
have I hope you found it useful thank
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>