<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JavaFX 3D: The Third Dimension | Coder Coacher - Coaching Coders</title><meta content="JavaFX 3D: The Third Dimension - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>JavaFX 3D: The Third Dimension</b></h2><h5 class="post__date">2015-06-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/rFJXRFT_B0c" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right well welcome everybody this is
our I guess third talk that we've done
for the last three years on JavaFX and
3d and we've got some new stuff to show
you this year I'm Kevin rush fourth this
is my colleague Chen yang and so we're
gonna talk about what we have in the way
of 3d features in JavaFX
go ahead next slide our lawyers make us
put this here go ahead next slide we
have a few things we want to cover in
this talk the first few minutes are
going to be I guess a recap if you're
familiar with Java FX and the scene
graph model and transforms and JavaFX
but I feel it's necessary to set the
stage just a quick show of hands how
many of you have programmed Java FX
applications before so it looks like
most of you have so I think for most of
you this the first part will be a little
bit of review I hope to go through that
fairly quickly and then get into the
meat of the talk where weíre talking
about the specific 3d features that are
already there in FX 2 that would be the
camera z-buffering and the 3d transforms
and then and we're gonna start talking
about the bulk of the talk will be on
the new 3d features that are in JDK 8
that they're out an early access now and
they'll be shipping when JDK 8 ships
next slide please
so we have a number of things that we're
going to be talking about and adding in
FX 8 for 3d so this is just a sampling
of what we have for the 3d API we have
geometry attributes picking and I'll go
into each of these individually and then
finally we'll leave some time at the end
for question and answer okay so for
those who are familiar with Java FX this
will be pretty basic
JavaFX unlike some of the other
immediate mode api's is a same graph
based API by that what you do is you
create nodes in a tree where you have
grouping nodes that group things
together and provide transforms
positioning and orientation and scale
and then you have at the leaf node
of the tree your geometry objects group
nodes can have attributes such as
opacity or transforms and then leaf
nodes will have all of the other
properties on the node go ahead and go
to the next slide so the various
capabilities that JavaFX gives you our
transformations which we'll talk about
in a little more detail animations so
for those who have seen some animating
demos and Java FX we provide a framework
that will do automatic interpolation of
data points to give you smooth motion to
be able to run actions of your own on
every frame and then we have a number of
2d filter effects like blurs and drop
shadows various things we won't spend
too much time on that because those are
more of 2d operations and then we have
various rendering attributes and we will
extend those for 3d ok next slide so the
primary graphical nodes in 2d really far
and fall into four categories and that's
we either treat things as a shape like a
rectangle or a circle text which is a
special form of shape and takes some
special processing to render and make it
look good and then we have images in
media this is a block diagram of the
JavaFX
software system we have some UI controls
which are things like sliders buttons
text tables various things that you're
used to in swing and if you've
programmed it FX there they sits on top
of the JavaFX scene graph and then below
that line we have the prism renderer and
we have two different hardware
accelerated pipelines depending on
whether you're running on Windows or an
on Windows platform on Windows we use
DirectX on non Windows platforms we use
OpenGL if for some reason your platform
is not capable of running the prism
hardware accelerated pipeline we have a
software pipeline particularly embedded
devices we'll run into that but some
desktops as well this is an example a
graphical example of a simple scene
graph and we've got at the top level we
have a stage a stage in Java FX is much
like a.j frame in Swing if you're
familiar
that we have a scene which is the
content of a stage we will fill it with
a color it has a root node which is just
an ordinary group node in this case and
then we have a single image view that
we're going to show so why don't we go
ahead and go to the code on this so
every FX application inherits from the
application class and overrides and
defines a start method this method gets
passed in with your stage you don't have
to create it and this allows you to run
either inside a browser or on a
standalone desktop application
and then we're going to create our scene
graph so we first start out by creating
our root node which is a group we then
will create our scene with a specified
size in this case just 800 by 600 we
will create a single image and then
attach it to an image view and add that
to the scene graph but before we do that
we're going to set a drop shadow on it
so this is the one time we will show you
a 2d filter effect and then we finally
position it because we're not using a
layout manager in this case so we're
just positioning it with absolute
transforms and then eventually we will
add the node into the scene and then
show everything so go ahead and run that
quick demo okay so that's just a simple
image program that's all the code you
need to do that the entire code will fit
on that page so go ahead and and go to
back to the slides so the 3d features
that we already have in the existing
Java FX 2 which is shipped with JDK 7
include 3d transforms not just the 2d
you'll move in X and move in Y but we
also have 3d rotations and 3d
translations and scales we add in a
depth buffer which allows us to do
automatic sorting of objects in 3d and
then we've defined a prospective camera
in addition to the default parallel
camera 3d is an optional feature it does
require the prism hardware-accelerated
pipeline so one of the two opengl or d
3d pipelines are required in order to
run 3d and so we have several other
features in
facts that are optional we have a an API
called platform dot is supported and
there are various conditional features
you can query one of them is seen 3d
which means we support 3d if you query
that it will return true or false
whether you support it if you choose to
ignore it or don't call it and try to
use 3d features it will just be ignored
ok
the hardware support that we need for
prism on Windows is via DirectX 9.0 C
and it requires pixel shader 3 by now
any machine in the last five years
should be capable of this sometimes we
will run into older machines with either
down Rev device drivers or actually
occasionally hardware that doesn't
support it and so that's why we ask you
to check whether it's supported alright
on Mac we support 10.7 which is Mac OS X
Lion or later and we use opengl 2.0 on
the mac to support prism and anything
that supports mountain lion officially
10.8 will also run prism so we very
rarely will need to run the software
pipeline on a Mac Linux is is kind of
the opposite story on Windows most
things run on Mac almost everything runs
on Linux there's a lot of machines that
do not yet support it that can be for
one of two reasons first of all today in
fx8 we support nvidia AMD JavaFX 2 only
supported nvidia and the other thing is
we require a vendor supplied driver so
the open-source driver that comes with
your standard Ubuntu distro will not run
it however you can force that with the
prism force GPU option that's a
developer option just to see how well it
will run in the future we hope to
support more so that we will get better
coverage ok next slide for embedded we
also run OpenGL but we actually run
OpenGL embedded ES 2 currently 3d is not
officially supported but we have an
experimental flag that you can turn on
as a developer and it requires a machine
with
non-power of two texture capability so
for example the Raspberry Pi which
you'll see some demos of at this
conference
does have the necessary support it's
just that we don't have the software in
a state where we're really ready to
commit to it and so that's why we we ask
you to set a flag to enable it okay so
for the transform properties most of you
are familiar with this so I'm not going
to go over the 2d transform properties
rather I'll just highlight the places
where we've added 3d so each node has
some convenience functions to do
translation rotation and scale and so in
all three of those cases we've added Z
to them we have then go ahead to the
next slide sorry we also have a list of
transforms that you can add your own
rather than using the convenience
functions and each of those four rotate
scale and translate have a Z component
to them okay this is the order of
transform operations and it's very
careful or very necessary to be careful
about the order especially in 3d it's
easy to get things backwards where when
you move it one way you'll think it
should move that way and it'll move the
other way because you don't have your
order of transforms right so for the
convenience functions we set the order
for you for the ones that you put in the
transforms list you define the order
yourself go ahead depth buffer the
reason we need a depth buffer is that in
2d the depth of something the apparent
depth or what's on top is just
determined by render order and that's
fine for 2d because you decide okay I'm
gonna paint my rectangle first and then
my circle and then my text on top of
that and that that's fine for you for 2d
so go ahead and go to the next slide so
in a 2d scene graph you have these four
nodes if this was your graph a would be
rendered first D would be rendered last
and thus D would be on top because
whatever his last gets drawn on top for
3d though the render order it's worth
noting does not equal the Z value of the
object and so as you either set
different Z values translate objects
around or move objects around relative
to each other unless you reorder the
scene graph they're not going to be in
the right order
and so if we take the same scene graph
in the same order but assign Z values to
them such that a should be on top and
then B would be last in this example
instead we're gonna get it drawn the
same way we used to before so a should
be on top but B will be I sorry D will
be and then the way we solve this is by
adding a depth buffer
this requires GPU support but any GPU
that supports prism will will support a
depth buffer to construct a depth buffer
to use it there's an optional attribute
on scene that tells it that you want a
depth buffer every node has a depth test
property and by default will inherit it
from its parent and so the root node
will inherit it from the scene and so if
you create a depth scene with a depth
buffer enabled everything will will get
Z buffered at that point okay so we'll
go ahead and run a quick demo here okay
so right here we're showing an example
of using the conditional feature check
and so this particular program will
check scene 3 D and it will find it has
nothing useful to do and will just throw
an exception and exit you might choose
in your own programs to do something
else like disable a 3d panel or
something along those lines so here
we're defining three rectangles red
green and blue the blue rectangle should
be in the middle the green rectangle
should be in the back and the red
rectangle should be upfront but you'll
notice we're rendering them in a
different order because we want to
illustrate the problem go ahead and run
it please so in this case you'll start
out noticing that even before you move
it you'll start out and noticing that
blue is on in front even though it
should be in the middle and red should
be in front but it's not okay go ahead
and rotate it around and you don't
really get a good 3d effect no matter
how you rotate this group of objects
blue stays in front so now we're going
to go ahead and enable depth buffering
so he's gonna create a scene with a
depth buffer by default it doesn't have
one
and now you'll notice red is in front
and blue is in the middle like it should
be and then when you're rotated around
the backside Green is in front just as
it should be because you're rotating
everything around okay back to the
slides
okay so we've got one more demo that
that will illustrate what you can do so
so far oh go ahead sorry question the
depth buffer itself is on a complete
scene but depth testing can be turned on
and off per component so you can only
turn depth test on for your 3d objects
if you would like there are other things
in fact we'll talk later about another
technique that you can use for that but
yes that that is supported so that this
one is not really a cube it just looks
like a cube what this is is it six media
view faces translated and rotated in 3d
to make it look like a cube and right
now depth buffering and depth testing is
turned on if we turn depth testing off
you can see you kind of lose the 3d
effect they are different faces go in
and out of each other now let's turn it
up testing back on and it looks correct
okay let's go on to the next slide okay
so it's worth spending just a couple of
minutes on the camera class and on the
coordinate system that JavaFX uses
JavaFX started out as a 2d API and it's
still a 2d mostly API though we've added
some 3d as a result our default camera
class is a parallel camera and our
default units are in pixels and why is
going down and the origin is at the
upper-left that's pretty much how most
people familiar with 2d drawing packages
are used to doing it for prospective
camera we didn't want the second you
added the perspective camera to have
everything change out from under you so
by default if you have objects at Z
equals zero or just throw a bunch of 2d
geometry 2d buttons other UI controls in
your scene you could switch between a
perspective and parallel camera and you
will see no difference because our
default coordinate system is the same
it's just that it Z equals zero
everything a pixel is a pixel at at that
Z depth we have added a few things to
our perspective camera class you have a
field of view so you can control how
much of the 3d scene that you see we
have a default of 30 degrees and that's
pretty much it for the perspective
camera class but as I already mentioned
our origins in the upper left and Y is
pointing down so go ahead and let's show
this so one of the things if you have
typical 3d content normally you'll have
it origin to zero where zero zero is
supposed to be in the center and Y is
going up so the way you would compensate
for that in our current JavaFX 2 is by
adding a coordinate system convertor
group or some other technique like that
and then having transforms that will
translate rotate and scale it from how
you've defined your model into the
default JavaFX system so we'll run a
quick demo to show this
so in this case I just want to highlight
one thing quickly before we run the demo
which is we were creating this chord sis
converter group which is going to be the
root of all of our content or 3d content
and we've created a translate rotate and
scale when we first run the program
those are going to be the identity and
so they won't actually do anything and
then we'll populate those with
transforms and have them correct for the
coordinate system okay go ahead and run
the program thank you okay so as you see
we've got a coordinates or we have an
axis up here we have a red for an x-axis
a green for a y-axis and though you
can't really see it blue represents the
z-axis but it's in the upper left corner
we'll go ahead and add a model to this
but we've defined this model so it's
supposed to be in the center and by up
so you don't really see much of it so
the first thing we want to do is we want
to translate this into the center and
then we'll still note it's upside down
so let's rotate it about the x-axis by
180 degrees and now we have it up and
let's not give Duke a headache so we'll
take the axes away from him and we can
rotate Duke about is access there so I
just shows you what the coordinate
system that we use is we'll go ahead and
now everything that we've talked about
so far with the exception of Duke
himself which is a 3d model everything
else is something you can do today in
JavaFX too with JDK 7 now we're going to
talk and spend the bulk of the talk on
new features in JDK 8 so one of the
things we're adding in JDK 7 with FX 2
cameras were fixed they could not move
you defined a camera and the only
control you had was the field of view if
you wanted to move that if you wanted to
appear to move the camera you had to do
an inverse transform yourself and move
the world in some way to approximate the
moving of a camera we're also adding new
3d geometry you saw a little taste of it
with Duke in the previous demo we have
various attributes to control lighting
and material properties because we are
adding in 3d primitives we have to be
able to do picking in 3d to allow you to
select and manipulate objects and then
finally we've added API to do
anti-aliasing and something called sub
scene which will allow you to mix 2d and
3d content as well as other things but
the primary thing it does is allows you
to more easily mix 2d and 3d content so
the only thing to note here is that
camera now extends from node otherwise
it's the same ok next slide because
camera is now a node you can add it in
the scene graph in the it's a leaf node
so you added in the scene graph in the
place you would add any other leaf node
as such it inherits transforms position
orientation and scale from the scene
graph just as another node does you can
position and aim the camera using those
transforms either in the camera class
itself or in any of the group nodes
above the camera we added the new fixed
I mode which is useful for 3d scenes
because the normal camera that we use if
you just create a perspective camera is
geared towards making it look just like
it's a 2d scene so it's centered not at
0 0 it resizes itself such that when you
stretch the window we actually move the
camera to keep the apparent size of all
the objects the same none of that is
very conducive to 3d and so what we
wanted to do is add a new mode for that
if you're not gonna move the camera you
don't have to add it to the scene graph
but if you are that's that's how you'll
end up manipulating it and then we added
properties for near and far clipping
plane but we're not really going to
spend much time talking about those so
this is the same code you'd use today
this is how you would create a camera
today you just create a new perspective
camera set the camera on the scene but
if you want to create a moveable camera
you will instead typically want to
create it with the true attribute which
says you're gonna use a fixed camera or
sorry fixed eye position which is good
for moveable cameras we're then going to
in addition to setting it on the scene
we're going to create a group node to
enclose it and then we're actually going
to add the camera into the scene graph
as a node so that
positioned in the scene graph and then
that just shows it an example of how you
would then manipulate it pay next right
so what we'll show a demo of that here
okay so in this case we're going to
create the perspective camera with fixed
eye we're going to create a set of
transforms on the camera itself and then
we're gonna do the same thing we usually
do which is set the camera into it but
then down at the end there we're going
to add the camera in as a node in the
scene graph okay so I'll go ahead and
run the program oh yeah go ahead both
well yeah so set it well you set the
camera on the scene so that that's a
camera is a an attribute of scene that
says which of all of the cameras I may
have created is the one that's going to
view this scene so I can create and add
four cameras in the scene the one that I
call set camera with that camera on is
the one that will be used so that that's
why it's there
twice so yes it's the same instance so
in the one case you're actually adding
it into the scene graph in the other one
you're just saying hey scene please use
this camera to render yourself with sure
and then in so in this case we're gonna
load the Duke and it looks kind of the
same as what we left the last demo with
but how did we get here so if you create
the camera and don't add any transforms
or you make them the identity this is
kind of what Duke's gonna look like
because you're sitting your cameras at 0
0 your models centered at 0 0 so you're
like right inside your model and it's
still upside down too so let's first
pull back so we're gonna pull the camera
back a little ways but we're still
upside down so you can see the axes
there if you rotate the camera around by
180 degrees we're now this is how we got
to where we were so in this case let's
out a couple of other objects in there
we're gonna add a few other primitives
and then we can zoom the camera in and
out because the camera is now movable we
can zoom in and out we can pan up and
down and and then we can still rotate
the camera around so now when we rotate
this we're not rotating Duke
we're actually rotating the camera and
so all of the objects appear to move
the opposite direction the cameras
rotating because we're just panning the
camera around okay oh actually could you
run that again I wanted to highlight one
more thing one other difference between
fixed camera and are they sorry the
old-style camera and the fixed eye
camera is can you add the objects in
again resize this to be full screen and
see if you can see that and then maybe
resize it much smaller so in this case
because we're working with the more
typical 3d camera as you resize things
because we're not trying to match
physical pixels we're in a - one-to-one
coordinate system centered about zero
your object will get bigger or smaller
but you'll see the same thing with the
other camera mode as long as your
objects are at the zero plane you'll
just see more or less of it but the
objects will stay the same apparent size
so that's that's another difference
between the two modes okay so it we can
go back to the slides now okay so in FX
2 we only had two DS shap s'
we transformed them in 3d but you know
we had rectangles we had circles and
that was about it for FX 8 we've added
two different types of 3d shapes we've
added user-defined shapes and we've
added some predefined shapes okay shape
3d is the base class of all 3d shapes it
has mesh view which is our user-defined
shape and then we've in innate at least
we've added three different types of
predefined shapes which are just
convenience functions so that you can
you don't have to do the geometry
yourself for user-defined shapes the
mesh view class we have a triangle mesh
which forms the basis of the geometry
triangle mesh consists of a set of
positions texture coordinates and then a
set of faces that describe the topology
of those vertices smoothing groups are
how we specify whether the geometry is
supposed to be smooth or have hard edges
so if you're defining a cube
each quad or pair of triangles in the
cube would have a hard edge
distinguishing it or separating it from
the other edges if you don't specify a
smoothing group which is optional then
we assume the whole mesh is one smooth
surface so if you're just defining a
sphere or a part of a curved surface you
don't need to use smoothing groups mesh
you use again this is just an example of
code defining an array of floating point
positions and texture coordinates and
then the faces are just an array of
integer indices and then we just use the
set methods on the triangle mesh to
create the mesh itself and then we can
construct a mesh view with that mesh so
let's go ahead and show a quick demo
this is a triangle mesh it doesn't look
like much there but if you turn it to
wireframe you can see it's actually we
can create it to different resolutions
either a high res or a low res mesh and
we can deform them so he's got two
different ways of deforming the mesh
depending on whether it's high or low
resolution and that's probably about all
we want to want to show for this and
then you can turn it to wireframe or or
solid and we'll show you more examples
of that a little later
okay so using the predefined shapes are
a little easier than defining your own
meshes in fact I think most people would
not want to write their own code using
their own meshes usually we would expect
that that would be done by reading data
in from a file that you've already
constructed elsewhere but you can do it
with your own mathematical shapes but
for just simple things where all you
want to do is just show like a molecular
model with a stick and ball figure well
we give you cylinders we give you Spears
and boxes you can specify both the
radius or size and then also the
resolution yes question we'll get into
that later we don't actually have in the
core API any file formats directly
supported but we provide several file
formats in example loaders and will show
us some examples of that a little later
I guess one other thing to note is that
all 3d shapes again because that's
pretty common are centered at zero zero
zero so we'll show a an example of some
3d shapes since we only have three
predefined shapes that's pretty easy to
show yes question
so right now we only have surface
primitives in 3d so the the closest we
have that that is something that in the
future we could add and and I'll have a
slide on futures a little bit later but
today for fx8 we only defined surfaces
and so you can turn the edges of a solid
into wireframe but that's not the same
as defining lines I realize okay so I
did oh yeah
yeah if I did why don't you go ahead and
run that program if you want to
so I guess before we get into the
predefined shapes this is an example of
a mesh with deformation so we're we have
little drops of rain hitting this
surface and we're deforming the the
vertices of the mesh to give you that
effect but now let's go into predefined
shapes really quickly and this just
shows you the different the three
different shapes we have so we've got
cylinder and we have two different
resolutions of it so we can we have a
high-res version which you just saw and
then we have a lower resolution version
but really you can define your own
resolution at all we just happen to
define two for this demo same thing for
the sphere we've got a higher resolution
sphere which looks pretty smooth and
then a lower resolution one which if
you're going to draw a lot of them very
small you might use them to save
triangle count and make it render a
little faster and then we have a box
okay the various 3d attributes that we
hope sorry there is not CSS support that
that's actually something we hadn't
considered although I know some people
have asked for that in the past there's
no reason we couldn't add some CSS
support so maybe that's something we'll
have to add to our to our list of things
for the future it's a good question no
it's it's not style in fact that's
actually pretty true of most of our just
graphics primitives so a rectangle
actually I guess you can style a
rectangle with some things but a lot of
our even 2d primitives if we're just
talking about that the geometry isn't as
style as you might want so some
something we could add though in the
future materials are used to specify the
appearance of a 3d shape they include
things like textures bump mapping
specular maps and then we have face
culling which we won't show that
basically just determines whether or not
you're gonna show the back faces of a
polygon or not if you have a solid model
our default is to not show the back
faces because it's faster and you can
turn it off that's all we're saying and
then we have two different types of
lights
we have ambient and point light lights
are defined as nodes in the scene graph
just like a camera or anything else
although they're not rendered they
affect other objects so every light that
you put in the scene graph will
influence the objects in the scene graph
by default they influence every object
in the scene graph but you can scope the
lights to only affect a certain set of
nodes by default though it affects
everything that's oh it's whatever the
thing to note is that if you don't add
any lights at all we will provide a
default light for you so that at least
it if you just throw in a box or a
sphere you'll at least see something
okay this is just an example code of how
one would do that so we're not going to
actually show the code in NetBeans for
this one
it's just a pretty standard API for for
doing light similar to other Java three
or JavaFX attributes go ahead
so this is a same demo we saw last time
but you'll notice there are two spheres
representing lights up there and we can
animate the lights and we can change the
color of the lights so we're having one
light that rotates around so that the
position of that red circle I guess is
reflective of where the light really is
in the scene and so that just shows how
it affects the objects around it okay
okay materials we only right now to find
one type of material it's a fun material
and so that's the the lighting equation
that we'll be using for fx8 it has
attributes that you can define which is
a diffuse color or map or both and
similar for specular that the map is
just an arbitrary image that's used as a
texture normal map is an optional
attribute that would be set with the
bump map API and then you could have a
self illumination map which is just some
a you know additional color that would
be added to the object that's not
affected by lighting just like mesh view
objects or yeah I guess just like mesh
view objects are shareable among
multiple shaped 3ds so our material
shareable so you can define one material
and use it for a hundred different shape
3ds in your scene okay you define
materials by passing in image objects
into the diffuse or bump or specular map
properties and also by setting colors on
there and then finally you set the
material on a shape 3d okay so why don't
we go ahead and show an example of some
materials so same demo as last time but
this time we're gonna add some materials
on it on the cylinder you want to zoom
in there thanks so there we've we've
defined both a specular map and a bump
map so this is using the high resolution
version of it and then same with the
sphere where we can use the same texture
for the sphere on the box as well and
then this is just showing using a
different texture on the box which shows
a little of what you can do
okay
for 2d we use shader based anti-aliasing
it's using alpha blending and it relies
on rendering in order in order for it to
look right so for 3d is just not very
suitable when you're using depth
buffering so what most applications most
graphics cards do instead is you render
it without any shader based
anti-aliasing and no alpha blending and
instead you render it at a higher
resolution and use filtering of some
form to smooth the edges around and so
what we do is we give you a new
attribute just like we had depth
buffering turned on on the scene for FX
to an FX 8 we will allow you to create
one with a an anti-aliasing buffer if
you set anti-aliasing on a scene then
what we do is we'll tell the graphics
card create a multi sample buffer render
it with multiple samples per pixel and
then when we go to present that to the
screen when we actually draw it onto the
screen for that window we will filter it
we don't do all that ourselves OpenGL or
direct3d provides that we use that
capability ok I'll show a demo so if any
of you have run any of our 3d examples
before you'll know how Jaggi things can
be and so in this case we have we're
creating I guess we'll just run the
program so you can see the one on the
Left I don't know I don't know how well
those of you in the back can see but if
you want to highlight with your mouse
and the jaggies so if you look up at the
top there on the left hand side you can
see quite a bit of jaggies and it's
smoothed out quite a bit on the right
hand side and so what we've done is is
created two different scenes in here
actually sub scenes which we'll talk
about in a bit and one of them was
created with anti-aliasing enabled one
without ok
oh go ahead it is available in the
latest builds and that's I think we've
had reports that some people have used
it successfully we've had at least one
report on one card where it didn't work
but every one all the ones we've tried
it on both D 3d and OpenGL work fine
that's what you're seeing right now that
this is basically if not the latest
build it's close enough to the latest
build that's available out on java.net
sub scene is another new feature that we
added in primarily to help us solve some
of the problems that we have when you
mix 2d and 3d you have a number of
problems so we've already talked about
some of them or hinted at some of them
one is that you're gonna want your 2d
scene not anti-aliased by the scene
anti-aliasing but we want this nice
higher quality alpha blended shader
based anti-aliasing another problem is
that z-buffering doesn't play nice with
2d you will get z-fighting if you take
some 2d objects and try to mix some 3d
objects you're gonna get Z before
fighting between them also z-buffering
just doesn't work well with transparency
so whether it's transparency because you
have seen anti-aliasing I'm sorry the 2d
anti-aliasing or because you actually
have alpha blending you end up not
wanting to use depth buffering at all
for those things the other thing is now
that we have moveable camera if you have
a 2d UI and you start flying your camera
around the last thing you want to do is
to have your UI just fly out of the
screen for you so for that reason we
created sub scene and so we use sub
scene mainly to separate 2d and 3d
content we also can use it for overlay
or heads-up display because it just
allows you to define separable overlay
planes so each sub scene we basically
render it acts as the route of a scene
in a way where we render everything into
that sub scenes buffer and then that sub
scene can be added as the node in a
scene and it just acts as an image at
that point and so they get blended
normally to
there's images okay go ahead let's run a
demo so it's first of all go back and no
go back to the previous one so we won't
actually run this again because you've
already seen it but I just wanted to
highlight that we actually did use sub
scene in our last anti aliasing demo the
reason we did that is because msaa or
anti aliasing is on a per scene or per
sub scene basis so in order to actually
show things we didn't provide an
attribute to turn it off so in order to
show both anti aliasing and not we had
to use two sub scenes so now let's go to
our actual sub scene demo so I don't
think we're gonna show any code here I
think we just wanted to run this so here
we have a 3d scene this is the same
thing we saw in our earlier demo we have
Duke with our three predefined shapes
and then we're gonna go ahead and add in
a background so that's actually in a
separate sub scene the 3d content so
what we've done here is we've made our
2d scene the primary scene we've added a
group with the image in back there and
then we've added the sub scene with the
3d content you can rotate that around
and you'll notice it doesn't affect so
we're moving the camera here but because
we use a different camera for the main
scene than the sub scene it doesn't
affect it you can go ahead and put a
floor on there and rotate that around
too so now we have that so the floor is
also part of our 3d sub scene so
everything blends nicely you can see in
the background there we can also put an
overlay on top of the the 3d content and
that has so if you want to zoom in a
little bit you can see that's just a
transparent rectangle with some text on
it but it all blends together nicely at
that point and you can try the other you
can show the other overlay if you want
so it's just any number of things you
can do and then rotate the 3d around and
it just all works together so that's the
main reason you do sub seeing this for
something like this okay yes question
absolutely yeah we could have just put a
standard you know UI control based
labels panels whatever anything you want
there in JavaFX - because we had 3d
transforms we actually did have to deal
with ray based picking so we had most of
the code already there to do the pick
ray generation what we had to add in fx8
is the ability to pick the new 3d
geometry in addition to that we added a
new API to provide the intersection
point
okay so we'll show a short demo of that
oh did you have a question not probably
not what you're thinking of are looking
at right now we just fire array and we
pick the closest thing what we don't
have is we don't have an API that would
actually allow an app to do anything
cleverer than that so it's all based off
of the same event system that our
current Java FX API is which basically
is every time we move the mouse we
automatically do a pick you don't have
any control over that you can control
what things are pickable and what things
aren't and then it will return you the
closest picked thing which in some cases
isn't what you want so so at least for
this version that's what what we're
providing if we you'll notice on the
future slide that's coming up in a
little bit providing an actual picking
API is on the list for a future release
okay yeah maybe we can chat about that
later
okay do you want to yeah okay so anyway
that was an example of the of the
picking demo and what we can do with the
current API so now in the model loaders
which somebody asked about earlier we
support in JavaFX the core only meshes
and materials but it's possible and we
have existence proofs because we have a
3d sample it's actually released an open
source so if you look in the apps
experiments 3d viewer
a project in the source code of JavaFX
or we released the jar file as well
there's a 3d viewer program which has at
least obj and Maya and I know they've
got some sample versions of 3d studio
Max and and then we're working on
actually AMD is working on a colada
loader with us so we're gonna make the
sample code available for these again
that'll be through the sample
applications but we're also encouraging
anyone else who wants to write a loader
to do that you know you'll have some
sample code that you can look out and
borrow and if you have a favorite file
format we haven't supported that you can
write a loader okay go ahead so while
he's bringing this program I thought
just let you know that you've already
seen an example of one of these loaders
the duke model is a maya file so we've
we've already been using the maya loader
in our demos so this particular one is
just an obj file it's one of the old
dusty models that everybody's probably
seen who's seen any 3d models we just
have a sample little viewer so this is
the program that's actually available
out on java.net ok
that's pretty much it for that one
okay so now just a few things about
futures before we get into our final
demo and then QA there's a number of
things we know that we're missing this
is not a fully featured 3d API yet if
any of you views Java 3d which Chen and
I were both involved in this doesn't
have everything that has in it this is
designed to give people who are Java FX
programmers enough 3d that they can do
some interesting things but there's
things that we know we want to do
differently for one thing you can't
define your own normals right now you
define the faces and we define the
normals you can control with smoothing
groups where we break hard edges but
that's the only control you have so we
know we at least want to add normals
there's also been some thoughts that we
would add additional texture coordinate
sets once we have more shaders and so
additional lighting and shading models
we have some different geometry types so
that's where lines and points would come
in as well though I didn't list it there
that that was exactly the kind of thing
we're thinking of when we said more
geometry we want to add a real proper
picking API and then there's been
considerable interest I would say in
mixing native rendering particularly
OpenGL with Java FX and in fact we I've
got a pointer to a talk that is remember
it's later today or tomorrow that goes
tomorrow that where one of my colleagues
will go into some demos of how to do
that okay
accelerated mesh animation so you
actually have seen some examples of mesh
animation and will show you another one
right now we're doing that by on the
host reading back we're keeping a copy
of the vertices and modifying them as we
go to do that
there are hardware accelerated
algorithms that we would like to provide
some support for in a future version and
then loaders as we've talked about
actually providing them as part of the
core API and supported is something we
are looking at doing at some point in
the future and then various geometry
utilities in and to this we could add a
few other things that this is something
where if you have a good idea you can
either
on the open jfx mailing list or file a
request in our bug database system okay
so we'll end with a 3d demo that shows
but written by people who are far more
clever than I am showing what somebody
with some artistic talent can do with
this API so some of you may have seen
the keynote demo but for those that
haven't this is a an animated chess game
this is actually a real game apparently
played between David Letterman and Garry
Kasparov you can guess who won but all
of these animations this is actually all
running in real time this is reading the
data out of a file for each of the moves
but then just the JavaFX program is
animating the pieces in corresponding
correspondence to those moves yeah I
like the knight movement the best and
also the way the bishop takes pieces
you'll see an example of that in a bit
anyway we'll just let this run for a
minute let's see if we have enough time
mm-hmm yeah I won't really let it run to
completion or maybe I will while I take
questions and answers
so each of the chess pieces is a Maya
file that was loaded in and then they
animate the the meshes I think what they
did is they loaded in several different
versions and did some character
animation between the different frames
all right well while this is running
since we we have about ten minutes left
why don't I take a few questions if I
haven't answered any already we can yeah
I'll take questions now or maybe okay so
if I've answered all your questions
let's just finish watching this oh I'm
sorry I can't say oh yeah you go ahead
and turn the lights up now that's
probably okay yes
so you you either need to do that or you
could provide separate transforms to
JavaFX so you can have several different
transforms in a single node and they
will be applied in the order that you
specify them I don't know if that
answers your question but oh okay I'm
sorry input device I didn't hear that
I guess if I understand what you're
asking is do we or should we provide a
reverse kinematics package and the
answer is yeah that might be nice I if
you don't actually go back to the slide
but on the previous slide when we talked
about the futures that's one of the
things we could think about for a
utility all right I think we're we're
about I think this game is just about
over I'm gonna guess why it's gonna win
all I'll spoil it here for the end why
don't we go ahead to the the other
sessions yeah so I thought I'd highlight
a few other sessions that might be of
interest mr. David Hill who's right back
there is gonna do the making your JavaFX
application fly on the Raspberry Pi and
without putting him on the spot are you
gonna show any 3d I didn't think so but
that that's what I thought I did but
yeah actually it's you can't compete
with Jasper and Alexander and John
they're the ones who did that demo I
could never come up with something that
clever or creative anyway we have AB off
at 4:30 today which is meet the Oracle
Java client and Java FX teams just if
you have some questions and we'll I
don't know what we'll do well we'll sort
of figure that out when we get there we
have tomorrow morning there's a talk on
Java FX using canvas and image view and
some of the other applications API is
with 3d the integrating JavaFX with
native technologies that's the one I
mentioned earlier that will talk about
some research that's been done to
integrate OpenGL with JavaFX right now
it's just a prototype but it's one of
our most highly requested features so
you know at some point it'll make it
into the API there's a talk about open
source that'll be Steve Northover and
Richard bear telling you where we are an
open source and how you guys can get
involved I think you he wants that to be
a call to action for people and then
we're going to
a deep dive into the internals for those
you know three or four people who might
be interested in walking through what
the prism actually does to get all this
stuff done and then on Wednesday morning
John Yoon who's the one who did a lot of
the modeling in that chess set that you
saw will talk about modeling texturing
and lighting in JavaFX and that's uh
it's a pretty good overview of that are
there any last-minute questions that I
could answer for you or anything that is
on your mind if not oh yeah go ahead can
JavaFX I'm sorry be integrated with web
applications in two ways yes one is we
actually have a web component so you can
take something where you read in a web
page either off the web or from a file
it will process the HTML and render that
in a node so it's a web view node but
the other way you could integrate it
with a web application is that just like
any other application that's written in
Java Java has a very rich network API
that you could use to integrate that
with a web server for example in fact
the chess game was an example of that we
were running a GlassFish server and
talking to that through web interfaces
the restful web interfaces I'm sorry no
the second one is really just using the
Java various java api is both in the
core and provided by third parties so
like if you download NetBeans or the any
other Java EE platform development
they'll have a number of restful web
services or other web service API s that
you can access alright any other
questions all right well thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>