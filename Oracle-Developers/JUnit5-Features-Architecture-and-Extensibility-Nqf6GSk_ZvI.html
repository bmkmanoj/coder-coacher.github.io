<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JUnit5: Features, Architecture, and Extensibility | Coder Coacher - Coaching Coders</title><meta content="JUnit5: Features, Architecture, and Extensibility - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>JUnit5: Features, Architecture, and Extensibility</b></h2><h5 class="post__date">2016-09-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Nqf6GSk_ZvI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome I'm a little surprised there's
so many people interested in testing not
that testing isn't a good thing but
until now if you bought the O'Reilly
j-unit pocket guide 10 years ago it's
mostly still right right that's gonna
change with j-unit 5 there's breaking
changes so today we're going to talk
about the features architecture and
extensibility that's built into j-unit 5
and a lot about why it was done and
we're gonna make up for a lot of the
sections of the keynote that didn't have
code by putting code past you so fast
that you won't catch it but then we'll
give it to you at the end okay so our
parting gift I'm Steve Moyer along with
my colleagues
Steve seltzer and Neriah Ramesh and
we're all from Penn State we're
developers there's about a thousand
titles for developers at Penn State but
we mostly write code and so testing is
something that's near and dear to our
hearts because that gives us the
confidence to change code faster right
so static code analysis makes you a
better programmer but testing makes you
fearless right our group mostly writes
code that you don't see so api's parts
that tie systems together we just merged
in with the Identity and Access
Management but all the pieces that all
the departments use under the under the
hood to keep track of students a little
bit and to connect their websites in
through DNS things like that so we kind
of do the parts that nobody sees but
that are still required to keep the
university running today we're going to
talk about the rationale for this
rewrite it's been a long time since
there was a major version change in
j-unit the architecture behind it the
principles that were used
the features that you can expect now and
in the future J unit fives not done it
still has three more milestones to be
released and I'm guessing they'll
probably be some more lots of code
examples future direction and references
so most of what you see up here there'll
be links to at the end and like said all
the code is yours to take it's all out
on github and in fact you can probably
go look at it now since the bitly link
is on the bottom okay so the main thing
that was trying to be accomplished or
the first thing is that right now when
you put the J unit jar on your class
path you get the whole thing until
jigsaw comes about you can use private
classes things that are supposed to be
internal but are visible and you can use
whatever happens to show up on your
class path with J unit 5 you can let the
test developers write to an API and put
separate jars on your class class path
while you're running the tests and
actually decouple those that also means
that the test engine is a black box so
as long as the API doesn't change nobody
actually gets broken when there's major
changes to the engine and the reality is
you can even switch engines out right
now there's two ways of extending J unit
there's rules which works at certain
points and there's also runners and
right now there's a big limitation in J
unit 4 and that you can only have one
runner I like a project called J unit
params and if you include that runner
and you don't get another one which
until mockito could be used via a rule
that was always a fight in my head right
I want mocks but I want parameterised
tests with milestone for I think it is
we should be able to have both
and of course there's a lot of new
language features that have happened
since j-unit four came out some of those
changes have kind of migrated in slowly
but not many and so lambdas streams etc
are now included and this project was
originally marketed there was an
IndieGoGo project to fund it and it was
called j-unit lambda it ended up being
called J unit 5 because they didn't want
to tie it so much to Java 8 because the
changes that are being made in the
engine really should allow for
extensibility with Java 9 Java 10 Java
11 and so um let's dive into the
architecture so as you can see there's a
lot of packages in J unit 5 compared to
the single jar that you're used to
seeing the real key is that if you want
to write a geniune at five tests all you
need is the Jupiter API if you want to
run them then you have to pick some of
these other parts to put on your runtime
class path but for writing tests all the
public classes are here when jigsaw
finally comes out there'll be more
formal definition of what's considered
public via the modules if you want to
run existing tests there's also a
vintage engine which uses the j-unit
4.12 package right now and then the
entire engine is built as another set of
packages that are largely invisible the
parts that you pick out of here depend
on how you want to run the tests and
whether you're running J unit for tests
J unit 5 tests or both and there's
facilities for plugging extra engines in
I believe there's a spec c1 that's in
the works right now the Surefire plug-in
and the Gradle plug-in are being
supplied by the J unit 5 team I've moved
those out and kind of ghosted them
showing that eventually that they they
hope those go over
the Maven surefire plug-in group and the
Gradle plug-in group surefire has a
plug-in architecture called providers
and so this implements the surefire
provider and plugs right into the
existing maven infrastructure there's a
console runner just like there is in
regular j-unit not many people use that
right and then the platform runner
allows you to actually run j-unit five
tests from within j-unit four so four
systems that haven't migrated over yet
Eclipse is working on it I think
IntelliJ is pretty far ahead right now
but in order to run j-unit techni five
tests within eclipse you use the
platform to run them under the j-unit
forerunner there's a few inconsistencies
there which you'll see in some of the
demos so what do I need to compile your
test classes as I said one jar it's a
pretty small jar and it's a lot of
interfaces too if you want to run those
tests you need the j-unit jupiter engine
if you want to run j-unit for tests
under j unit 5 for those with large
tests that's obviously that's going to
be important because you got to be able
to run what you've got now right but you
use the Vintage engine for that if you
want to run from the console there's a
console runner it's a platform runner as
I said is for running J unit 5 tests
under J unit 4 and the maven and Gradle
plugins so setup we have some examples
in here this is how you add a provider
into sure-fire the reality is you can
put the rest of your engine components
in here for J unit 5
the other interesting thing is this is
the new pattern convention for J unit 5
and as of
surefire to 19.2 that'll actually be one
of the built-in conventions so that'll
automatically be picked up in the
configuration section we'll be able to
disappear this is the normal
dependencies and then the principles
behind this rewrite is to prefer
extension points over features so
there's certain parts of J unit five
that are actually written and included
in these jars as extensions already an
extension point should be good at one
thing so they tend to be small extension
points if you've ever written a runner
you know that can be quite a bit of work
depending on how much of it you rewrite
from the base one it and it should be
hard to write tests that behave
differently on different systems or
depending on how they're launched and
that's one of the nice things about the
architecture was everything ends up
going through the platform so there's
one point at which the tests actually
start executing and tests should be easy
to understand and for the tests that
I've written anyway I think the tests
are shorter less lines of code per test
and just like the original J unit they
try and minimize all other dependencies
there's one library that's used for the
console to parse command-line arguments
why we write that right and there's a
another separate jar they've created
called open test for J and the intention
behind that is to align all the
different test systems behind some
semantics for what should be in a test
and with that I'll turn it over to new
Raja okay so the features we're going to
show in the code today are meta
annotations there's a lot of declarative
test capabilities but you can actually
extend the annotations so if you have at
test you can actually turn it into
something completely different and it'll
still be caught as a test tags and
filtering which are similar to the
categories that were included in J Unit
four point seven dependency injection
it isn't really CDI as you would know it
from Java EE but you can inject
parameters into your tests tests are
allowed to have parameters now that's
obviously a feature you can run tests
from interface default methods so if
you've got multiple classes that inherit
interfaces you can write the tests right
in an interface and it'll run them
dynamic tests are generated at runtime
and as we talked about a little bit
extensions the API isolation we talked
about it's really all about hiding the
classes that shouldn't be shown that'll
get easier 9 and they also have defined
API evolution so right now just about
every method that's exposed within all
of these packages has one of five api's
or annotations internal deprecated
experimental maintained and stable since
we're only up on milestone 2 there was
an alpha milestone one if you watch the
trajectory the number that are marked
stable has been increasing slightly
there's a whole lot that's marked
experimental and there's a lot in the
platform parts that are marked internal
and will probably never be exposed
and now it's time for neeraja all the
features that we discussed a few minutes
ago we have written some examples
pertaining to the students course
registration at Penn State University if
you will so this will be the type of
test that we will be going through in
our presentation today first one will be
the assertions which is the same concept
as from before in the previous versions
of j-unit they have added a couple of
new ones like assert all is targeted
toward group assertions we will go over
that now exceptions are part of
assertions we used to do it with
creating rules for the thrown exception
to be caught and examined further now we
can simply have an assert throws or
expect throws that's part of the
assertion package then we look at the
assumptions and also go over go over
when to use assumed vs. annotations on
how to create our own custom annotations
inheriting the behavior of the existing
ones in the Jupiter API then the new
feature added in jail J unit 5 is
dynamic tests that's created by a test
factory method and generated at runtime
another key feature is extensions we
will look at all the available extension
points and see a few examples on how to
write our own extension class
implementing those extension points then
we look at the group tests with the word
starting with the traditional for loop
and contrasting it with the factory test
method that we just talked about in the
dynamic tests and also the assert all
that comes out of the assertions
targeted toward the group tests nested
tests or the same concept we are just
using it in an example
to create a kind of a test suite until
j-unit five team is creating their test
suite classes that is coming up in
future releases first let's look at
assertions they have just moved the
package we used to it used to be in J
unit tests I believe now they are
available in J unit Jupiter API if you
are working in an IDE with an auto
import that's not a problem otherwise
that's something to be mindful about
let's look at some simple assertions we
start with an assert equals to see if
the student wanting to register is the
last name with builder if not we add an
failure message that used to be the
first parameter in the previous versions
now in J unit 5 they moved it as the
last parameter just so to keep the order
not messed up when you when you choose
to add one and not to add one other than
that the @test annotation as before is
the same that makes the runner recognize
this is a test method yes Bob the
Builder we have identified him who's
willing to register for some
construction courses maybe I want to
bring up your attention to this display
name annotation that you can include a
custom name that will appear in the
results if we did not have that
annotation it would have appeared as
check student last name so this is a
neat little method to include your own
wordings for the final report the same
thing what if we expect a Cooper instead
of a builder it's going to fail instead
of the green check that we saw in the
previous slide it's coming up with the
blue X meaning it's a fail test the same
with a test and display name
the wrong one it also gives a failure
trace that displays the message even
otherwise it's going to give you more
information on what's expected and
what's the actual just wanted to show
you how the disable tests look in the
results with a crossed-out circle no
symbol this is now considered a disabled
test with the annotation this replaces
at ignore annotation from J unit 4 we
are going on to the assert true to make
sure that the student has no courses on
his list put in a lambda to create and
the error message just the extra one
that the display name can take special
characters that way the results and the
report she can include what does your
custom name that you gave it to it here
is the new one that is added assert all
we are looking at the individual fields
of the data element student for the last
name first name the number of courses so
now when the runner runs it will go
ahead and run the each of the tests and
produce the results if they if there are
any failures they'll be reported in a
group together in this case it happens
to pass the test I know the code is a
little small but I want to show you this
is the class that we that has all the
code that you've seen in the previous
slides and we are even able to annotate
the whole class with special characters
including emojis of course as he
mentioned we have all the code available
in our github repository under Penn
State this representation we took from
the Eclipse IDE J unit view results yes
question
know if one of them failed the result
comes out as a failure but when it
reports it will show like say if you did
a 10 test it will show one failure and 9
success but overall the assert all will
come out as a failed failed test I think
you may even see an example of that when
we attack the grouped test in further
slides what we saw in the previous slide
was that I was saying that from the
Eclipse IDE now if you have to run it
with the maven test the console output
simply gives the number of tests run the
counts on how many failures and how many
skips we have skipped is the same as the
disabled it used to be the ignored ones
in the previous version the maven sure
if i plug in that he talked about
produces a text file and also an XML
file for the output text file is very
similar to what you see on the console
the XML file will have a little bit
extra information that we can extract we
will be using the IDE version just so
it's clear all through the presentation
we looked at a couple of assertions
available ones fail is an assertion now
it can it can make the test fail with a
supplied message we looked at assert all
the last two or the ones that are going
to pertain to testing exceptions assert
throws we are doing a bunch of code by
registering the student for more classes
than he could possibly be allowed I just
wanted to walk through walk you through
what these methods do just because it's
going to be the recurring theme in all
of our examples of how we obtain a
student get the course and register the
students get new freshmen resides in
sample students class that you can see
here
it returns either a freshman or
full-time student here we want a student
with no courses already existing on
their list bill tests courses has a
bunch of courses with details on
shortname longname descriptions credits
and if the course has a prerequisite if
it does have one then it also mentions
what it is for example stat 401 requires
that the student has already taken math
141 and this is a utility class that
defines the maximum allowed credits and
it also has a method that registered the
student for the given course it throws
an exception if the student exceeds the
maximum allowed credits and this is the
exception we are going to catch with the
assertions in the next one this is the
same code that we started out with now
that we saw what the everything is doing
now we know we are registering the
student for more courses that's going to
throw the exception here we supply the
expected class and because it is going
over 25 credits the assertion passes we
can do the same thing with expect roles
except we can we'll be able to catch the
returned exception in a local variable
and do something with it with an assert
equals here with the message or we can
do whatever we want to with it
we're moving on to assumptions
assumptions are useful in stating that
thing yes question
this is the expected we don't have this
is the expected this is the actual we
don't have a failure message yeah I know
it's throwing us off I know we talked
all about the switching the placement
and yeah so this here is the expected
one the utility class was throwing
assumptions simply are useful in stating
the conditions under which the tests
will be meaningful or valid therefore
when the assumptions fail it does not
mean the test is a failure
it simply means the test will become
meaningless or invalid
therefore the runner will recognize this
as a disabled test of course it was
ignored and marks it with our no symbol
the assumed true assumed false is what
it says it was there before
if the assumed true condition is true
then it allows the method to continue
assuming that is a new addition it just
takes in an executable and if the
condition is true it executes
executables whatever the code is if the
assumption in the assuming that is is
false then it will simply skip the block
of executables and continue with the
rest of the test method
say that again yes it well here we are
doing the assumed true to see if it is a
student affiliate is a type of it's a
datatype representing anyone associated
with the University say student as an
affiliate staff is an affiliate faculty
is an affiliate we are simply checking
if student if the given affiliate is the
student here and to simplify things we
are going to look for the method name if
it contains students then you're going
to consider the affiliate as a student
therefore this returns true it's a
successful test did I skip the assumed
false looks like it if the assumed falls
then it's going to show a blue X with a
failed result assuming that already we
know it gives the condition and the
executable is within this curly braces
now that it's a student it passed
therefore it printed the print
statements within the curly braces it
will go on to add this to add the course
to the student and also will continue to
execute the next one outside of the
assuming that block in case the assuming
that condition failed it would have
skipped the block and still would have
printed the last statement we do have
those cases available in the code if you
want to check it out at a later time yep
I think the order of skip here is the
assumed false one that shows the
assumption has failed because it's
expecting a false but it is true was
this the one that someone was asking
whether it'll show it skipped that shows
the cross code symbol
now we move on to the meta annotations
we are able to inherit the behavior of
the existing annotations and leverage it
to create our own custom annotations the
example here we are constructing a
custom annotation using this interface
that's going to inherit the behavior of
AK test therefore although we do not
have the AK test annotation on this
method it's going to inherit and
consider it as a test to run it are you
able to see you the next one is these
both or they are trying to do the same
thing we're trying to tag a method by
the way at tag is a replacement for a
pack a category from J Unit four
so you can tag a method but small or big
or fast or slow and try to filter it
while running that's what we are trying
to do here creating a custom annotation
putting it on another test to run it by
the way we could have included the
artist in creating our custom annotation
that way we could have skipped this one
in providing the other annotation all
right the new type of yep this one or
one more
oh okay we were wondering I think the
highlight there sort of blocked it out
it's the same as user ID test here it
says at user ID test a new type of test
that is included in J unit five is
dynamic test that's done by a factory
method it's actually returning a stream
of dynamic tests that'll be recognized
by the runner and will be run in group a
test factory will be the annotation that
makes the Runner recognize this is a
this is going to be a factory method
returning expecting expect a stream or
collection of dynamic tests when you
construct a dynamic test it will contain
a display name and an executable an
executable being a functional interface
can be provided as lambda expression or
method references which we have been
seeing already because of its dynamic
nature life cycle callbacks are not
applicable meaning we cannot use at
after all annotation on the on the test
class to reset the data when this is run
so that's something to keep in mind
while writing dynamic tests this is an
example the a test Factory declares that
the runner to expect a stream or
collection in this case via returning or
supplying a stream of dynamic tests
creating a new stream but numbers one
through ten and mapping it to create
dynamic tests the display name being
input plus I executable being assert
true I naught equals four except for the
condition where 4 is not equal to 4
everything should pass in a for loop it
would have exited at this point but all
the tests are run in a group and the
results are given in a group
now Steve Shelton will walk you through
the extensions hang on try and not
channel my inner auctioneer here and not
go too fast so you there's a lot to
cover the extensibility some exciting
stuff that they've added here here's the
extension points that they provide for
us we're gonna cover all except the test
instance post processor which is the
last one the first column just think of
that as post construct it'll insert
inject code there right after the
creation of the test class so first
thing we'll look at is the test
execution condition first thing we're
gonna do and what this will do is this
will determine whether or not a test is
going to get run so let's start by
creating a class we're gonna call it
fill light detector this class is going
to implement test execution condition it
needs to have a method evaluate this is
what's going to determine whether or not
the class gets executed and it takes the
test execution context parameter which
will get automatically passed in for you
our method is going to look to see
whether it's going to get the method
name and it's going to check to see if
the method name contains the word
affiliate if it does contain it it's
gonna return true if it does not it's
going to return the test is disabled so
there's our explanation we're looking
for the word affiliate all right now
we're going to create a class classes
extension disabled tests it's going to
extend with the affiliate detector that
we just looked at also within our
extension disabled test class we've got
another method
just in order to demonstrate additional
ways to skip tests we have a boolean
method that's going to also look at the
class or the method name and if this one
does not contain the name the word
student it's going to disable the test
so it has to contain affiliate and a
half's contain student in order for the
test to run so let's start looking at
some of the test methods that we have in
this class so the first one is checked
student affiliate yep
contains affiliate so it passes the test
execution condition yep it contains the
the word student in the student detector
method so it passes the first one and
then you'll see on line 30 we haven't
assumed true checking this that it has a
student and our test is run and passes
just fine so the next test we're looking
at is check affiliate yes it passes the
affiliate test so the test execution
condition passes but it does not pass
the student one so if you're into the
icons you can see the first one executed
completely the second one began to
execute but exited or hold at execution
when the um the assumed true failed our
final one says just to check student
well that one doesn't have a filly in it
affiliate in it so it never executed at
all it was just skipped and it would
come up in the final analysis as having
been skipped the next extension point I
want to run over quickly is the result
of parameter resolver let's start by
saying there's there's two built-in
parameter resolvers that you get for
free with JUnit test and that's because
they're used a unit five is the test
info that is a parameter anytime it
finds test info type it's going to
resolve resolve it for you and it will
supply an instance
that allows a test to retrieve the
display name the tags the test class and
the test method that belonged to it also
a test reporter this can be used to
inject logging information or other
information into the output of your
tests into the test report but that's
not terribly useful for passing
parameters so here's what we're looking
for parameter resolver now again I'm
gonna let you know that we just skinned
this one it's you can go pretty in-depth
and we have a little more in the the
github example that we've that were
supplying so go ahead and take a look at
that but we've got a class here this is
a parameter resolver class we're gonna
call it user ID parameter resolver and
it's going to implement the parameter
resolver again we need to implement two
classes for this one the first one is
supports and again it's just gonna be a
test for you that you can put in there
to determine whether or not this class
or this method is actually supported by
this parameter resolver in our case I'm
not going to show the code but it's
gonna look to see that it has an at user
ID test annotation as part of that the
the method is annotated with that and
then the second part is the resolve this
is where it's gonna actually put
together the parameters and resolve them
and pass them back in to the method for
our example it's just going to return a
string and a boolean so here's our our
extension test so again we've got our
public class user ID test cases we're
extending it with parameter resolver and
we've got our our tests there on line
well line 12 is the annotation that I
spoke of where we're looking for user ID
test and line 13 we're saying is our
method and we're passing in user ID and
success as a boolean we want to know
this would be I'm passing in a user ID
do I
affect this parameter to pass or fail so
that's what the boolean is now this is
jumping back to the parameter resolved
our class this is the code that's
actually looking to see whether or not I
can this is the code that's actually
resolving this is the resolver that's
actually resolving the the parameter so
you can see it's checking line 34 we're
getting the parameter type line 35 we're
checking to see is the parameter a
string if it is we're gonna pass string
SGS 1 1 6 the other option is a boolean
if it's a boolean it's gonna pass back
true in this case and okay this is
overly simplified there's other options
available position is going to be the
other big one you can actually check
which position the parameter is in so
that will allow you to do a lot more
complex decision-making as to what
parameters are received so in this case
it just are just showing that they both
get through and resolve yes for methods
or
it's just you can yes you can put it on
the method as well callbacks or the
other piece that we wanted to show you
another piece so these are the before
and after callback methods and end
stacks so just to point out on this one
um they will execute in an order in a
reliable order so of course the before
all will all come first and it will they
will execute in order from the super
class down through the parent and to the
child in order and so you before each
superclass then your parent then your
child or before all and then your before
each superclass Parent Child the whole
way down to test and then after the test
executes it'll go in the opposite order
child so it'll it'll work its way back
out child parent superclass of the test
execution child parent superclass after
each and so on so again look at the code
example for this that we've supplied
just very briefly outlining this we've
got a super class called all callbacks
it's going to implement all of our
callback types we have a parent that's
going to extend with the all callbacks
and then we have a child that's going to
extend the parent class and each of
these are going to write out or put out
the available methods within that class
it's just going to put them out the
extension so here's here's the the
pronoun this is what we wanted to show
you that is going to okay that we are
going to go from the outer class from
the parent from the superclass to the
parent to the child and the before all
and then it's going to do the before
each and then on the after the tests
execute that's going to everything kind
of in the reverse order
with the child first then the parent and
then the the callbacks question yes
other annotations provided for what yeah
yeah and and that's he's right we
clipped a lot of code out on this and I
believe they're still there so yeah
again we really don't didn't have the
time to go in depth as we like to and
just blast you with a lot of code so we
have provided the full classes available
that you can go in and look at and you
know just really was showing some
experimentation you know tweak your
messages and see what comes out my
career
the anthill turned on there's currently
not annotations for the before and after
test execution callbacks but the before
all and after all are roughly equivalent
to the before class and after class and
the before and after are before each and
after each so those are analogous to
what was in J unit for the next set of
code I'd like to go through demonstrates
grouped tests and different ways we'll
the execution order and and how things
are executed so we're gonna do the same
block of code for for three different
ways same set of tests in this one we're
going to line 37 we're getting a list of
courses for a student line 38 we're just
going to simply put out a print line
statement so we can see what's happening
39 we start into a loop that will assert
that there's no prerequisite with the
course that the students trying to
register if the third prerequisite then
the students not gonna be allowed to
register for the course
and finally in line 43 just shows that
we've finished the loop entirely without
exiting so here's our execution you can
see that stat 401 has a prerequisite so
at that point execution was halted and
we exited the test so you see the first
print line there but you don't see the
last one because the test they exited
before completion and that's not too
surprising so here we get to assert all
same-same courses you'll see that line
75 through 82 are building assertions
and there rather than the assert all
statement so here you can see all of the
tests were executed even though we had
three that were not null and would cause
a failure so again we see the first line
first print line printed out but not the
second one because once we found the
failure line 74 the assert all then
halted execution after that was after
found the the figure so it does run all
of the tests that are within the assert
all brackets but then evaluates not to
find if there any failures it'll at that
point exit and it will show you which
ones exited or which ones failed after
completion and again if you run the
examples that we have you'll see in the
output you know these three listed that
they failed the test so the final one
that we wanted to look at was the
factory method and again it's the same
set of tests line 56 57 to 58 are all a
single stream our single statement we're
building the code that's going to create
the test the list of dynamic tests and
then we're going to pass them off to be
executed so again it's going to execute
all the tests regardless of whether
they're any failures we're gonna see the
first system out and we're gonna see the
last one because of course it executes
everything within the factory test code
before it executes the tests so it
generates the factory generates the list
of tests and then exits from there and
one thing to mention at least at this
point with the factory tests if you're
running them from within Eclipse they're
gonna show is unrooted they do not
currently associate with the parent test
they'll just show up as unrooted tests
but they all do execute individually and
will list as failures or successes
the final piece I want to go over is the
nested tests and she's gonna hear this
very briefly you can see line 21 and 24
we've got annotations for at nested yeah
nested will let you provide an inner
class within the code we just for
simplicity rather than declaring the
inner class directly there and with
brackets and filling it in the way
normally that would we just extended
another class to make it easier to see
but this is a way that you could do test
Suites and run a series of tests from
within within a parent class like that
let's Steve finish up on our future
directions I mentioned at the beginning
that J unit 5 is a work in process and
we've got three more milestones to find
at the moment and three is due at the
end of this month and that has some
quite a bit of bug fixing some
additional discovery selectors and the
documentation has gone through an
upgrade they're working on enhancing J
unit for interoperability m4 is probably
my favorite
it puts parameterised tests back in I
had mentioned that I was a fan of J unit
params and enhances dynamic tests an m5
is due at the end of November and at
that point we'll be able to write test
scenarios ordered tests special
parameters or annotations so you can say
this one runs first this one run second
and if your testing does say acceptance
testing and you want to run through a
user story what better way than to
actually execute tests in order
the final thing I'd like to say before
we take questions is the the J unit 5
team takes a lot of input if you're
willing to give it and this is really
stable enough to start using so I'd I'd
recommend you go out play with it kick
the tires and right now I
a little bit greedy I have been putting
in feature requests and bug reports and
so forth for what I want in it and to
have a well balanced library you really
need to do the same thing so at this
point we'll take questions it looks like
we have about ten minutes yes yes you
can have the vintage engine and the
Jupiter engine both running the test at
test annotation that we had through our
slides here is actually in a different
package and so it'll tell the difference
between the tests by whether you use the
traditional at test or the new one which
of course only really becomes a problem
if you put them in the same class you'll
need to give the fully qualified class
name yes I have no idea my understanding
is that there's been quite a bit of work
done on it but I haven't seen it I hope
so because I'm an Eclipse user too which
if you went by yesterday everybody's a
NetBeans user right but yes for right
now there's a couple things that if you
run the tests that we've included you'll
see that in the case where the assert
all found three failed tests you'll see
output that actually lists those failed
tests and there's actually a new
structure for the test reporter that
isn't really implemented by anything yet
but the test reporter you can actually
insert key value pairs into your test
report using that test or the test
reporter parameter resolver and so if
you want to add extra key value pairs
and your report engine actually knows
how to read them you can do custom
in there - yes there is a the beginning
of a mockito extension that does work
I'm using it right now and that's
another one that right now is built into
the J unit five samples project on
github and we're hoping gets moved over
to the mockito project yes
I would tend to use a logger in that
case and be able to set the logging
level for simplicity purposes we put
system doubts in there and I think in
the future there may be an injectable
logger that will put messages into your
test reports or the facility to add an
extension to do it right yes
right now the hamcrest matcher x' are
compatible with this the assertions that
you see in here are other than exert
assert all are pretty similar with the
exception of switching those parameter
orders around and I usually use assert J
so the fluid assertion engines and so
forth work as well and really those are
all doing the same thing right if the
test passes it allows or if a line
passes it allows the execution to flow
then the next line if a line fails then
a assertion is earlier an exception is
thrown and that's how the test exits
which is why the one the one loop test
we showed you never see the last line
which says it basically got to the end
of the loop because the assertion was
thrown in the middle of the loop as
opposed to there being a break in there
right anyone else yes
there's no reason there couldn't be ant
execution but I don't know that there's
anybody working on it
so if there was somebody who wrote ant
tasks and wanted to submit that I'm
willing to bet that would be accepted
anyone else yes the tags are most
similar to categories yes so those were
added in J Unit four seven right and the
the way they operated changed somewhere
around four ten but yes right now those
tags are equivalent to the categories
the Gradle Runner allows you to include
them the console runner does as well the
there's a pull request waiting for a
little bit more work to get the include
tags exclude tags in the maven plug-in
and then you'll be able to make profiles
to run them from there as well yes other
than it's a meta annotation where you
can actually make your own you know at
small at medium at large if you work at
Google right well that's what they
define them as right so they're pretty
much the same thing and there's quite a
few places before each before all where
they tried to change some of the names
around to make it clear from what the
names were what they did so I think I
think tags labels categories you know
they're kind of all the same thing
anyone else yes
No
and there's a caveat to that because
right now with the way the the Maven
runner works disk because of the Maven
provider has a separate discovery phase
and execution phase and so during test
discovery it runs through and produces a
list of the tests that it's going to run
and then it basically runs through that
list again to do the execution as far as
the extensions go there are added in by
the engine at the beginning of each test
so when you are when your object or when
your test class instance is actually
created which right there's one of those
before each test is run within the class
so at that point the extensions are
loaded up and depending on what portion
of the life cycle that extension runs in
it's just executed as part of the life
cycle so it's it's more like a rule from
that perspective of course rules kind of
can creep further out so that they're
longer lasting than just the instance
but in this case the extends with those
are all created with the exception of
the before all and after all I guess
those are all run at instants time yes
what do I use in some cases it's still
Java I we tend to use I think selenium
for you eyes I'm one of the projects
that I was kind of sad to see kind of
died on github is called rest fuse for
testing rest api's and so one of the
things that I want to do with J unit 5
is actually make declarative style rest
testing framework using parameter
resolvers and extensions and
parameterize tests so that you can kind
of explode the number of endpoints that
are tested in any given test there's
really no reason that frameworks that do
intermediate style testing can't run on
here
I used DB unit for a long time as a way
of setting up a test case and basically
running as close to end-to-end as I
could any of those things will still fit
on top of J unit 5 just like they did
before anyone else yes
right now we pretty much are using
selenium for the acceptance test we have
we still have a lot of manual acceptance
testing and I think that will probably
use straight J unit 5 for a while for
some of that am i over one more okay
thanks for coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>