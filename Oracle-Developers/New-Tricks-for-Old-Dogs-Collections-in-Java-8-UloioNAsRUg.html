<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>New Tricks for Old Dogs: Collections in Java 8 | Coder Coacher - Coaching Coders</title><meta content="New Tricks for Old Dogs: Collections in Java 8 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>New Tricks for Old Dogs: Collections in Java 8</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/UloioNAsRUg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi I'm Mike do we go I'm one of the
developers in the Java core libraries
group I've been working in the
collections area and on the lambda
libraries that were provided for Java 8
for the last couple of years hopefully
now you've heard quite a bit about the
streams libraries that were developed
for Java 8 this is a presentation about
the other extensions to collections that
aren't part of streams in Java 8 most of
the new stuff is stream focused but we
had the opportunity and there's some
overlap with what streams had provided
to the collections that we can in fact
use independent of streams so this will
hopefully look at some of those things
that have been added and give you some
tools new tools that you haven't
previously had with working with the
collections classes that you're all
probably very familiar with already so
one of the issues that existed before
Java 8 was that it was impossible to
extend interfaces the problem was is
that if you had an interface and you
added a method to it all the
implementations that were out there of
that interface would in fact break
because they were now missing a method
that was required and there was no way
to get around this because we actually
fairly want wanted fairly deep
integration with the collections for the
streams feature it was necessary to add
a new language feature default methods
and hopefully you've heard about default
methods from Brian ket's in the
technical keynote or elsewhere in other
presentations but this is the main way
in which the collections were extended
in Java 8 is through default methods so
along with the stuff we added to the
collections for streams we also added a
bunch of other minor that more minor
things and some enhancements that have
been around for a long time now that we
had the capability of default methods we
could
to add things so a bit more detail about
that default methods I'm going to go
through this part pretty quickly
hopefully you've already heard about
default methods as I mentioned there was
this problem of not being able to extend
interfaces well we now have a solution
for that and the solution is if we wish
to add a method to an interface we now
provide a default implementation of that
method and there's a new keyword default
you can apply that to methods that you
provide an implementation for in
interfaces and if an implementation of
an interface doesn't have a particular
method it will use the default if
necessary and Brian gates like gets
likes to characterize this you know with
the public defender from a law thing
that if you know if you don't have a
method one will be provided for you
that's essentially what a fault methods
are doing implementation wise you guys
mentioned you use the new default method
attribute on your omlet on the method
that you provide an interface so now
there can actually be code inside
interfaces separate from the the trick
of doing static inner classes in an
interface you'll actually see method
bodies on interface methods
I want these what can these method
bodies do well they're somewhat limited
these aren't full traits or multiple
inheritance you can really only call
other interface methods and there are no
you don't have the ability to find any
new fields so this doesn't introduce
multiple inheritance but it does provide
a way to provide some default for a
functionality that would otherwise not
exist and these are some simple examples
of default methods that you could write
so for example if there was no is empty
method defined on an on a interface and
we wanted to provide that we can
construct an is empty by using the size
method which
already-existing and just comparing it
against zero so the things that you can
call our other methods on the interface
you can call constructors like we're
constructing a new square and you can
throw exceptions you know example would
be that if you have an iterator or
starting an iterable not sorry an
iterator there was always the remove
method and it was necessary to provide a
throws unsupportive operation exception
if when you every were implementing an
iterator well we now provided a default
implementation for the remove method on
iterator that in fact throws on
supported exception so you know whenever
you're writing your own iterators you no
longer have to provide that boilerplate
of throws on support of the operation
exception in every implementation of an
iterator things that default methods
can't do that may not have been talked
about thus far they can't implement any
of the object methods this would include
two string equals hash code etc the
reason you can't write a default for
those particular methods is is that the
interface hierarchy is search for
default methods only after the class
hierarchy is is searched so if you have
a class implementation it searches back
through the parents for a method
implementation to satisfy the the call
and in the case of the object methods
they're always available so that the
default that was on an interface would
in fact never be executed so there's no
the compiler actually prevents you from
trying to provide a default for one of
the object methods as I mentioned
there's no way for them to access or
create State on the given instance you
could do gross things with reflection I
recommend against it but you can't
access any fields the only thing you can
access on the object is other instance
methods other things to point out is
that when you write a default method
it has no knowledge of this in Croatian
protocol so for example if you were to
write a default method that was on that
was going to be used by vector that
default method wouldn't know that every
method on vector should be synchronized
and in the jdk implementation one of the
big areas that we've done is we provide
overrides for all of the default methods
on cases where synchronization is in
fact needed like on vector on hash table
etc the other part is is that the
default implementations may in fact be
suboptimal the example previously we had
of is empty calling sighs imagine if you
had a collection where determining the
size of the collection was actually an
expensive operation let's say it's a
tree structure the tree structure may be
able to figure out that it's empty by
just checking a single pointer to say oh
there's no head node to the tree
therefore I'm empty but the default
implementation would in fact have to
traverse the entire tree through the
size method in order to decide whether
or not there was anything available so
it is possible that you know the default
methods fulfill the contract but there's
not they're not necessarily particularly
efficient in doing so so those are some
caveats about default methods in general
if you have the opportunity to override
a default method you should probably do
so because you can probably do better
than the default so where does some of
these default methods show up the first
place we're going to start is on
iterable which is kind of the base of
all of the collection classes and we
have two pretty useful methods here for
each which is a replacement for using
the for loop iteration and you can
provide a consumer so this replaces for
loops and the main advantage to this
over for loops is that if the consumer
consumer lambda that you're providing is
actually coming from somewhere else or
is behavior that's actually captured in
a existing method so if your for loop
was doing nothing other than calling a
method on each of for each of the
elements in the loop you can now call
for each and provide
method as a method reference to the to
the foreach method the second method is
provided is in fact splitter Raider
which is used by the streams libraries
as part of its decomposition strategy
when it's doing parallel streams so
we're not going to really talk about
that that's a kind of a subject for
another talk and in fact you won't even
see splitter rater discussed in most of
the streams talks it's more of an
internal implementation detail one
interesting point that may be a bit
surprising is that the interfaces don't
include the stream or parallel stream
methods and you might kind of wonder why
that is and the reason is is that you
might want to specialize the type of
stream that you're returning if we in
fact declared the result or a stream on
iterable and said it returned a stream
of whatever the type of interval was if
in fact it was a stream of int or double
or some other primitive type we would
want to return an int stream or other
specialized primitive stream and by
avoiding putting on an herbal we give
implementations the freedom to return a
different stream type so that's why
there's no stream or parallel stream on
an interval there is you know further
down the hierarchy on collection than
elsewhere but not on iterable so the
default implementations that are
provided here should be in fact
overwritten and we already talked about
why you'd want to override the
implementation of a method for vector
and that vector has a synchronization
contract so vectors implementation of
for each does in fact synchronize on the
vector object before doing the for each
operation on each of the individual
elements the default implementation
doesn't in fact do that and so it's very
important that that override our sorry
that overrides are be provided for
classes that have a particular
synchronization protocol
one more bit about the for each method
so we now have bulk operations we have
the ability specify some operation
that's executed for all of the elements
of an iterable
well what happens if the operation
throws an exception this can result in
inconsistent state if in fact you were
mutating the objects as you were
iterating through them you won't
necessarily be able to tell by the
exception stack trace where the
iteration stopped so it's generally
advised you know advisable to avoid
providing consumer functions to bulk
operations or other you know besides
consumers other functions or lambdas to
bulk operations that that throw
exceptions or that propagate the
exception outside the lambda the reason
is is because your your results is gonna
be left in an inconsistent state you
won't know what had been processed and
sometimes that's not particularly
harmful if you were doing you know two
strings of as per this example where we
have a null in the middle of the list
all it's going to happen is you're going
to see the null pointer exception being
thrown for the second element the data
structure isn't damaged your your thread
is possibly stopped if you didn't have
an exception handler else we're catching
that null pointer exception or a runtime
exception but we didn't damage the data
structure again the basic idea is is
that you don't want to write lambdas or
or provide method references that
propagate exceptions outside so that's
one thing to be cautious of in all the
bulk operations so moving on from
iterable to collection we gain some
additional methods the parallel stream
and stream methods that we talked about
we now have enough hierarchy defined
here and enough other functionality that
we have to define the stream
implementations
the problem of wanting to return a
different stream type there's no way to
really address that in this particular
case because we don't have specialized
versions of the collection classes for
the primitive types so in fact if you do
a collection of integer you will in fact
get a stream of integer rather than an
in-stream object back but these two
particular methods are of course topics
for a separate presentation and there's
quite there were quite a number of them
at this at the conference the
interesting method that we do have that
we're going to talk about is the remove
if method and this is an alternative to
using a raw iterator and the remove
method on that iterator and we're
allowed to we're able to provide a
predicate to the remove method which
says which which element should be
removed from the collection if you have
in fact used remove all or retain all in
the past this can be a much more
convenient form or way to invoke that
functionality because you no longer have
to realize the collection realized means
create a collection just in order to
remove things you're two choices
previously were to either have a
collection of things that you actually
wish to remove or retain and provide
that to either remove all or retain all
or do the iteration yourself and pull
the remove method on specific things so
remove all provides a new alternative
for removing things from the collection
from the collection so that's what we've
added to that's what those are the
methods we've added to collection you
may kind of wonder well that's it
there's there's nothing more added to
collection itself the reason that
there's not more added is is that the
bulk of the functionality we want to add
to the libraries is through the streams
interface and the remove if method is
kind of odd and in a particular way in
that it does mutation of the source
collection the streams libraries their
general characteristic is is that they
don't modify the source collection so
they just take elements from a
collection do some operations upon them
pass it along further than the stream
the original stream is not modified
remove if and in fact modifies the
collection in place so that's why remove
if must be a method on the collections
themselves it doesn't really have a
streams analogy the closest streams
analogy would be something like filter
on the source collection
you know filtering out the particular
elements you were interested in but the
result of that kind of the best thing
you could do would be to put it into
another collection if all you decide if
all you desired was a new collection at
the end so since the new style is to do
less mutation in place we've only really
added just the one remove if method you
know kind of the counterpart to remove
if would be adding and in fact there is
a way to do bulk adding to a collection
which is a bit of an inversion we do the
operation on the collection we're adding
from with a method reference to the
collection we're adding two which is
kind of a needed version and we in fact
use it for each method in order to do
that so it's kind of cool that we're not
calling a method on the collection we're
adding to directly it that goes that is
actually invoked through the for each on
the collection we're adding from
so list list you know as a more
specialized version of the classes than
a collection that it gains a bit of
additional functionality the two methods
that are interesting here are replace
all which allows you to replace in place
all the elements of the list and there's
some examples there I've got of things
that you might want to do like trimming
all the strings in the list or in
turning them or if you have integers
using the value of operation to do some
canonicalization so that the the cached
integers in the in the very low range
will in fact be used rather than
uncashed essentially an internal
operation for integers this doesn't
allow you to change the type of the
elements so if you have a list of string
you can do something like trim on it but
if you wanted to go from list two to
integer or from you know list of integer
to list of string doing a two string
operation you can't use this method to
do that in fact you do have to go over
to the streams a API and use something
like start with foo map it to a string
and then add that to a new collection
and return that so if you do need to
change type that replace all method
isn't really the thing that you're
looking for the other very interesting
method is sort now previously you're
probably used to sorting lists by using
the collections dot sort method and that
implementation used the same strategy
for sorting all forms of lists it would
and you're going to be a bit surprised
by this if you when you hear the
implementation it called to array on the
list to take all the elements out of the
list and transfer them into an array
sort at that array and then set the
elements of the list back to the sorted
contents of that array now why did it do
this the reason is is that it had to
support all list types including linked
lists which sort would be very
inefficient
on the new implementation using a
default method if in fact you're using
the default uses the existing
traditional collections dot sort
approach if you've overridden the sort
sorry if you've overwritten the list
sort method like ArrayList does it in
fact sorts the elements in place that no
longer has this copy step so ArrayList
dot sort is more efficient than the
old-style
collections dot sort incidentally the
collections not sort actually now just
calls the list sort method so it gains
the benefit of those optimizations as
well the only place where the
inefficient method is now used is if
it's in fact using the default sorting
method for collections that don't
provide their own override so that's a
pretty nice enhancement to list if in
fact you have a list like array list or
even vector
they both do optimized versions of the
sort method
what about set sortedset navigable set
queue of all those things well
unfortunately they get nothing that's
not quite true they do get the methods
that they inherit from collection and
iterable so there is some new
functionality on these classes are sorry
from these interfaces and one nice thing
that we provided is there were some
missing wrapper classes in the
collection set you know the unmodifiable
checked and synchronized wrappers that
are provided by the collections well
there now are now specialized wrappers
for navigable set and queue available
from the collections which is pretty
nice bit of missing functionality that
we've added back in where things get
really interesting though is on map this
is where with the most significant bunch
of new methods have in fact been added
to the
to the interfaces as well as the methods
we've actually added to the map again
like the sorted set etc they also gain
the key set the entry set and the values
collection on map gain the benefits of
the collections new methods as well
where did the methods that we've got
from map come from well some of them
were those very useful looking methods
that you could see on concurrent map but
weren't available on map that have been
there since Java 5 unfortunately because
of the fact that there was no default
methods prior to Java 8 there was no way
to extend the map interface so there was
a bit of that mapped to behavior in
concurrent map where concurrent map had
a bunch of useful methods that we really
would have liked to have added to map
but didn't because there was no way to
do the extension so with Java 8 and now
having default methods we've in fact
pulled those methods back into the map
interface and then there's been some
stuff that was added entirely new to
Java 8 that's new to both concurrent
maps and regular Maps so the one that
you've probably been missing for the
longest time and I know I missed as well
was put if absent this avoids
particularly for synchronized maps the
need to do explicit locking on the map
and then checking to see if an element
is there and if it's not there then
adding it you can now do this as a
single operation and that's kind of a
hooray and the synchronized maps is
provided by collections will in fact do
this as a single atomic operation which
is pretty useful there's one bit of
behavior which is highlighted which is
that if the map has a mapping from the
key to null that's treated as same as if
the key or if there was no mapping at
all so a mapping to null is treated as
the same as if it was absent and we'll
have a bit on that in in a moment why
this this kind of weird behavior
existing null values are in fact ignored
and there's some solutions to this one
of the easiest of which is just don't
use null values don't put null values
into your into your map and then put if
absent won't have this this this problem
of treating mappings to null in an
unusual way and if you must have nulls
in your map or null values in your map
unfortunately you're not going to be
able to use put if absent because it
will treat those null mappings as if
they were absent
unfortunately because put if absent is
used by computer if absent computer
present and merge you're not going to be
able to use those methods either this is
you know been a bit of confusion for
people when they encounter this as to
why things are like this it's just kind
of an unfortunate wart and this is
unfortunately this is the least weird
set of semantics we were able to come up
with essentially it's a a bit of an
impedance mismatch between the map
implementations which don't support null
and and those which do and some of the
behavior of some of the new
functionality in how it treats a result
from a method returning null meaning
remove the entry it just started to get
very weird so we ended up with this
slightly strange behavior of treating
mappings to null as being absent more
the additions from concurrent map
besides put if absent we have atomic
versions of remove and replace these say
that remove the entry only if the key is
mapped particular value again this
avoids the need to do explicit
synchronization on the map to check to
see if it's you know then call get see
if it's the particular value you care
about and then call a remove only if it
is these atomic versions of remove and
replace are you know avoid some
boilerplate coding patterns that were
pretty common in the past
so they're gonna help you know remove
some of those warts that you have in
your existing code and some of the
boilerplate by using these particular
methods the first of the methods it's
not part of the coming from the
concurrent interface is I think what
most people are going to really like
because it solves the problem has been
long-standing in in most Maps so if you
have a hash map and you call get on a
key and it returns null what what do you
know it is the is there it is the key
actually present in that map or is it
mapped to null
you can't tell the difference
unfortunately get or default allows you
to work around this particular case by
if the key is not if the key is not
present in the map you'll in fact get
the default value back and if you have
the foresight to not use that default
value as a value in the map you can be
absolutely sure that the key is not in
fact present in the map so for maps
containing all this is this is a
particular particularly useful feature I
apologize I'm recovering from a cold
here so I'm a little dry and coffee the
fact that you can now finally
unambiguously know that a key is not
mapped is it is pretty useful without
having to do a separate contain step and
you know if if the map was synchronized
doing an explosive synchronization
around that other things that are
entirely new to Java 8 we have for each
and replace all methods these are map
versions of the ones we already talked
about on list of therefore each on the
entries of a map you can also in the
case of the for each if you prefer use
the
entry set and then call for each on that
entry set to get the entries in a
slightly different form the one reason
you might want to use this method rather
than using the entry set for each is
that some map types particularly new
maps don't actually have mapped entry
for the entries in their map so when you
iterate on an entry set for any new map
it actually has to create those map
entries synthetically as you're
iterating so this for each it is
possibly more efficient the same is true
for the replace all the where because
you're getting both the key and the
value and no map entry is being made
synthetically it might be slightly more
efficient one key point about both of
these methods and also this is true of
the list method replace all and for each
is that you can't you Tate the what's
called structural mutation of the map
you can't remove or add entries to the
map as part of the iteration you can do
in the case of replace all modification
of the value that is mapped but adding
or removing entries is just not allowed
in here you'll get a concurrent
modification exception if in fact you
try that
so now we get to some of the really
interesting methods that were added for
the streams library first of these is
kind of the the most immediately useful
which is compute if absent and this says
that if the key has no mapping call this
function to find out what the value for
this is and this can be used very
conveniently for caching type cases
where if you have some expensive
operation that you wish to add to the
that if the key isn't if there's not
already a cached value then compute it
otherwise just return to me the cash
value computer fasten it is quite useful
for that the other thing that's really
useful useful for is the multi map idiom
where you have a mapping from a key to
an ArrayList or a set where you check to
see if there's already a mapping to an
ArrayList and if there is then you just
add the item that you're you're adding
to that ArrayList or set and if there
isn't then you create the new ArrayList
and add that as the mapping for the key
it's not much more convenient with
compute if absent in that you you just
construct the ArrayList if it's not
already present and because it's
returned from the computer absent method
you then just do the add operation
afterwards so the ArrayList will be
created as needed by this operation one
bit about this is that the addition of
the ArrayList to the collection is in
fact atomic but the manipulation of the
ArrayList is not done under
synchronization so in this particular
case we have let's say that the map was
in fact a concurrent map
and it returned the ArrayList that we're
supposed to be adding elements to and
the add method is called if in fact this
is being called on multiple threads we
now have a sinker unsynchronized access
to the ArrayList in this particular case
with this with this simple example with
this simple example so rather than just
calling the ArrayList new in the
concurrent case you'd have to add a
little more complicated lamda that
called the ArrayList constructor and
then wrapped it in the in the
collections not synchronized list method
in order to ensure that you weren't
doing anything in a unsynchronized
fashion the alternative the reverse of
compute if absent is compute if present
and this says only do only execute the
function if there's already a mapping
for this particular key this can be used
for situations where you want to only
process certain results so that I would
only add the keys to the map that I care
about and if I'm processing a whole
bunch of data elements and they consist
mostly of the keys that I don't care
about whatever one of those keys is
encountered
nothing's executed and in fact because
the compute if present function has the
option to ask for removal of the element
after the compute function is over by
returning null I can do things like you
know find out when I processed the
hundreds element for a particular key
and after that don't process any more
elements for that particular key that
that's the kind of thing that compute if
present is is typically used for the
more general case which is or the most
general case is the first a second got
going the wrong way here is compute
which unlike present or absent just
calls compute on the
just calls the function regardless of
whether there is an existing mapping or
not it treats the case where there's no
existing mapping or the mapping is to
null by providing null to the function
this is another case where null is kind
of being used in multiple ways you can't
in fact tell in the compute method
whether or not it was previously mapped
to null or there is in fact no no
mapping this is the weird corner case
where then if it returns null did that
meant that I really have to remove a
mapping from this map or momentum with
the previous mapping to null so things
just get too weird around null so try
and avoid that and like the other
methods the addition of the value to the
map is concurrent but operations on that
value aren't synchronized so that you
should be careful about things that
mutate the value in place in a lot of
cases rather than using compute you
should consider using streams and reduce
or collect for group by often compute is
used for group by and the streams
approach of using grouping group by
collectors is probably better in most
circumstances than trying to use compute
in place another one that's similar to
compute but slightly different is merge
this the canonical example for this is
string concatenation this is primarily
added for completeness that there's not
a whole lot of use at least that we
found thus far for using merge but it is
nonetheless available for you know
specific cases where it might be useful
you know it Doug Lee wasn't content to
let concurrent hashmap just a what it
was particularly since now all the
unique cool stuff
had been added to concurrent map was now
available on the map interface so some
new additions were added to a concurrent
hash map first of these is that you can
now find out how many elements are in a
concurrent hash map when it has more
than two billion elements and in fact
there are concurrent hash maps that have
that many elements in them so there's
now a new mapping count access or that
lets you find out the true number of of
elements in in a concurrent hash map
Doug's also provided a new key set view
which is a specialized type of set that
that allows you to do more set
operations on the key set in particular
you can add to a key set that was
something that wasn't really possible
with the set return from a the set
returned from a normal map in that if
you added to the set what value would in
fact be used for that this key set
object allows a particular default value
to be associated so that you can add new
keys just through the set view there's
some additional functionality that's
here for this is mostly used for for
parts of the stream implementation
parallel versions of for each allowing
you to specify the amount of parallelism
to be used in a few cases if you're
using streams the streams interface
doesn't really let you control how deep
to go or how deep not to go with your
parallelism selection for an operation
upon a concurrent hash map viewed as a
stream if you need that level of control
you can access that directly off of
concurrent hash map for all of the keys
values and either entries as as the s
mapped out entry or as we've seen with
the replace all as a bi function
so there's some you know useful things
on concurrent hash map that go beyond
what's available an existing map and if
you need better control over the
parallelism then you can get through the
streams interface you might want to look
at this as well the other place that
this would be applicable as algorithms
that work in place on on the map these
methods would be useful for that
situation
so the in addition to the collections
libraries there's always been a arrays
utility class as we mentioned with the
sort method the sort implementations
were in fact on the arrays method
previously and there's been some new
things that have been added to the
arrays class the first of these is
parallel sort if you have a very large
amount of data you can now use a
parallel sorting routine that's
available as part of the array utilities
and it does provide some slight amount
of additional tunability than the
streams implementation then it also is
political if you wish to do the sorting
in place so that you retain the data
structure or the array afterwards for
and are copying it to some other data
structure as would be more typical in
the streams usage
Java's our arrays have always had a a
fill feature allowing you to fill the
array with a particular single value
there's now a more flexible versions of
that in set.all and a parallel version
of set.all which lets you fill the array
with a result of a function that
function actually gets the index value
of the array that is being asked to fill
so this can be used in all kinds of in
all kinds of useful ways so the simplest
of course would be to fill in an array
of integers with the index value that
it's being filled so you'd end up with
an array where the index where the value
of the int in the array is the same as
this index value but you can also do
more interesting things like clone so
you could provide a deep clone of an
array with this in parallel if your
clone operation is particularly
expensive it might be it might be much
better performance to do that clone
operation of all the elements of an
array in parallel and you should be
cautious about using this you know as
has been suggested in the streams talks
going parallel is not just you know
magic fairy dust that you can sprinkle
about just add the parallel keyword and
everything will go faster for the
parallel sort parallel set all on
parallel are you you should really only
use this when you're sure that the
payoff is going to be in a sizable
percentage of the time if for example it
was something like that clone operation
where the inherit operation is
inherently expensive it's probably gonna
pay off pretty frequently if it's
something you know really lightweight
unless you have a predictably very large
number of elements it's going to be less
clear payoff and the advantage to going
parallel main or if you explicitly
request parallel when it's not needed in
fact it may go slower than the serial
version parallel prefix is doing prefix
some operations this is a specialized
utility for some type of algorithms I
got an example here of how to use that
provided by my colleague Stewart Marx
who's here in the audience and this is
an example of something that can't
actually be done fairly very efficiently
by streams as well the reason that this
can't be done efficiently by streams is
in fact refers to elements at a relevant
position in the same sequence so we're
doing a moving average across a array of
integers
the moving average is of the last and or
capital end elements and this particular
example uses both parallel set and
parallel prefix so the first thing that
it does is set up the array such that it
has a calculus Peschel e calculated
value which is the each index is the
particular number where were which was
previously in the array of integers to
be averaged minus the value with the
index that's moving out of the moving
average window okay so we could pre
calculate all those things in the first
parallel set all step and then we call
parallel prefix sum across that to
calculate the sum of all of the prior
elements in the array but because we
specially calculate with the with the
the leaving element of the window we end
up with a sum of just the previous end
elements in the array in each index in
the temporary array and then we go
through and call sent all again to find
the actual averages by dividing by the
number by the size of the window it's an
example of that you know you know you
might actually use there's not a lot of
other examples that we've been able to
find of using prefix parallel prefix
that people are likely to actually use
but this is kind of interesting and like
I said it's not something that's done
terribly well by by streams related to
to collections I'm very closely
associated as comparators and the reason
for that is is that they're used for
both sorting and ordering of
elements within sorted collections so
there's some new utilities that have
been added to Java eight with the new
ability to have lamda methods and method
references and these are utilities to
construct comparators and there's two
key ideas here what the first is using
an extraction or having a method that
returns a comparator with a extraction
so we can provide an existing method
that all it does is return a comparable
such as student get last name which
returns a string which is comparable and
comparator dot comparing will return a
comparator that uses that method to
extract the last name from students and
the second part that that's new in Java
eight is ability to sequence comparators
by using the then comparing chaining and
we'll see it an example that in a second
so this is you know the bad old days of
writing a comparator and no one enjoyed
writing comparators historically and we
have a fairly simple problem statement
of given a list of students sort of them
by age then last name our and then first
name and this is the comparator that
we've got and and that feels like
horrible boilerplate to write if you're
writing comparators and it's possible
that there could be errors in the
comparators that you wrote particularly
if you're you know incremental e
modifying it I don't believe there's any
errors and in this particular example
but who knows there could be the easier
version that you can use do with Java
eight is now just say comparing int
extract the age field and then say that
if the ages were identical then compare
the last names then compare the first
names this is much easier to write than
the traditional comparator that we had
to do before it's very fluid and much
more succinct straight statement of the
problem with all oils boilerplate
mechanics that traditional comparators
were and and it gets it gets better
because the problem was comparing
comparators were that the more detail
the comparator you wanted to write the
more difficult it got so if we add just
that you know oh this is this is a very
easy extension to the comparators we had
to write already as a new requirement
what if last name and first name are
possibly known well as it turns out this
is only a third of the actual comparator
required to do and you know at the point
where says kill me now I consider
changing my career to be goatherd
because it was certainly better than
writing comparators like this
however with Jonathan eight all we had
to do was in fact add a small extension
which says you know if there's nulls
than they're sorted last this is way
easier than the prior thing and more
importantly it's it's read more much
much more readable and descriptive of
the logic you're trying to achieve and
it's also less likely to contain errors
if you're writing a 70 line comparator
you know involving lots of conditional
logic
the chances that an errors are going to
crop in especially over a period of
maintenance is pre di so this is
hopefully going to avoid a lot of those
particular those particular cases the
last way in which we'll talk about new
ways to use collections in Java eight is
collection methods as references so you
know a lot of the talk about Java eight
is the ability to use lambdas well one
source of existing lambdas is the
methods you already have
so rather than
writing a very simple lamda that all it
does is call a method there's an
alternative syntax you can use for that
which is called a method reference and
the collection methods are in fact
particularly useful for use as method
references and you can provide a few
examples of that and I'm sure you'll
come up with more ideas on your own the
three forms of method references that
can be used in in Java eight are static
methods where you just refer to a method
by name and that should generally be a
static method or constructor an instance
method which is called a bound method
reference where at the time you provide
the AR sorry an unbound this is the
first one here is an unbound method
reference so that the collections dot is
empty method if I provide this as a
reference for a case like predicate what
if I provide collections is empty as a
predicate the collections that will be
the collection that will be tested to
see if it's empties in fact provided at
the runtime when the predicate is
evaluated the last type is a bound
reference where I would be providing a
particular collection and it's contains
method as the as the predicate so that
when the predicate is invoked is invoked
for particular collections to see
whether or not some element is in fact a
member of that particular collection and
some cases where you can see this used
already mentioned contains so you can
filter based on the the membership in a
particular set that's pretty useful an
example here you know slightly different
from the set case is if in fact you're
not using a parallel stream or you're
using a concurrent set you can do a map
with remove to get the single case of a
element from a
from a set and then filtering on the
naal no lock on the non null object so
what this would do would be that
anything's not in the set would return
null and then you just ignore those but
as you as you're passing through this
only once for each element that was
contained in the source set would the
stream result contain the the element I
mentioned when we're talking about if
compute if absent that that particularly
cool trick for doing something that's
like multi maps it is pretty cool so
we'll mention that here again hopefully
this will remove a lot of boilerplate
from your applications and then the
thing we had originally for adding to a
collection where we reverse the sense of
it so that we're taking the things we
want to add to the target collection and
provide that target collections add
method as the as the consumer and a 4h
statement so you know you can use the
collection methods as method references
to various operations there's some
caveats in doing this that just because
a particular method has the correct
signature to be used that doesn't
necessarily make it a good idea an
example would be iteration using that as
a supplier the problem with the supplier
interface is is that it doesn't have any
way to describe the end of the set of
things to be supplied so nobody is
checking the hasnext method on the
iterator to see if in fact there are any
additional elements and so at some point
a no such method element exception is
going to be thrown it if in fact you're
using an iteration iterator as a
supplier if you can guarantee that
you're not going to call the iterator
too many times or call it exactly the
right number of times it's fine to use
an iterator as a supplier but in kind of
unbounded cases where oh no I'll just
hand this off to where somebody wants
the supplier from iterator well you're
gonna get a no such element exception at
some point
anna has kind of mentioned on the the
very beginning with bulk operations
that's gonna happen in an unpredictable
way you're not going to have the context
to know how far along your operation got
when in fact the error occurred but
that's a you know you know a fair
warning on cases where you're providing
elements from a collection the counter
example where we've already you know
used collections dot add as a consumer
of elements
that's generally more safe because
overflowing the capacity of an ArrayList
or some other type of collection is very
unlikely so some cases like that are you
know generally quite safe and not
particularly problematic and we have a
few minutes here for questions actually
finished a minute or two early so sorry
about the obscure references of
subheadings this is in fact one as well
from the traditional unit source code
UNIX kernel source code sure go ahead
right mappings count it will return a
value I'm sorry
the question was about mappings count on
the map enter on the concurrent map
interface or sorry it's on concurrent
hash map actually if the number of
entries in the map is more than 2
billion max long or sorry integer max
value it will return the correct value
because it's actually returning along so
write the return the return of mappings
count is in fact along any other any
other questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>