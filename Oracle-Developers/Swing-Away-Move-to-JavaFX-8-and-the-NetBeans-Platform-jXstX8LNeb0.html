<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Swing Away! Move to JavaFX 8 and the NetBeans Platform | Coder Coacher - Coaching Coders</title><meta content="Swing Away! Move to JavaFX 8 and the NetBeans Platform - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Swing Away! Move to JavaFX 8 and the NetBeans Platform</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/jXstX8LNeb0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right want to welcome you all to our
tutorial it's too loud isn't it is it a
little bit too loud here test one there
we go that's better I could talk a
little bit louder to that good for
everybody all right want to welcome
everybody to our tutorial swing away
moving to Java FX and the NetBeans
platform my name is Paul Anderson this
is Gail Anderson and we're with the
Anderson software group and there's our
website address and we'll be working
with you today this morning on this
tutorial so who are we well we're a
training company and we're based in
Southern California and we've been in
the training business for a long time
so we have been working with companies
and in private government helping them
with teach just software courses and
programming languages for developers so
we teach to developers like you guys and
and and Gail and I have an extensive
background before we got into the
training business working as developers
as well and we've been in the Java
business for quite a while I actually
was a C++ guy way back when but I've
been in I've been involved in in Java
and so is Gail and and so we have an
extensive set of Java courses and also
we teach Java effects too
we're also authors we have a book that
is out here at the show and you see it
here JavaFX
rich client programming on the NetBeans
platform and that's what will tell you a
little bit more about the book and our
book signing that's going to be coming
up later in the week
we're also the authors of essential job
effects which was a book that we wrote
when JavaFX was a scripting language so
Gail and I have been involved in JavaFX
since since its inception actually so we
have a lot of experience with it I also
have some live lesson videos that are on
Safari and you know and my new one
that's coming out later this year is on
Java FEX programming and then we have an
existing one on Java reflection that is
available and and both of these are
available on live lessons through
Pearson and also on Safari
ok so a question that I get a lot from
people is wow so you guys design courses
and you write books you must have some
really interesting dinner conversations
and actually I say not really are at
dinner who easily say okay whose turn is
it to take out the trash okay so let's
let's uh start telling you what are you
learning objectives are this is what
we're going to be doing today well our
plan is to show you how to port swing
applications to the NetBeans platform
which I think a lot of you will be
interested in learning about and then
also will show you how to port a Java FX
out to the NetBeans platform as well and
then you'll see the benefits of what the
NetBeans platform brings to the table
and and how it can benefit you will also
show you and discuss some of the
important Java FX features that will
help you design rich client applications
and we'll get into the areas of job
effects that are interesting like
binding and properties and animation
because this is what you know you can do
very easily in the NetBeans platform and
then as you'll see the end result is
some really interesting applications
will also emphasize the fact that you
should use F XML for your UIs
it turns out that F XML is a very good
choice for the NetBeans platform because
it fits into the philosophy of
decoupling and keeping and having
modular designs and then we'll also talk
about scene builder which is getting a
lot of interest these days because scene
builder will generate F XML code for you
as a drag-and-drop tool for for doing
UIs
and then we'll have some CSS that we'll
have in our applications as well now a
very important learning objective that I
think you'll be interested in today is
that we'll discuss and show you the
communication strategies for integrating
Java effects into these kinds of
applications there are thread issues and
we'll talk about that and as long as you
follow the rules and the approaches that
we'll show you here you're going to be
fine but it's important to understand
what you have to do and how the thread
issues will will be involved we'll also
along the way leverage some of the
really cool NetBeans platform features
so you can see how those will work and
then at the end of the demo or at the
end of the talk we're going to actually
demo one of our our Java FX charts
program that we
showed at JavaOne several years ago
another great example of integrating
JavaFX into a NetBeans platform
application okay here's our agenda and
so here's here's basically what we're
gonna do this morning okay we're going
to start off with a standalone swing
program and we're gonna just present
that to you so you can see how it works
and then we'll port it to the NetBeans
platform and we'll show you how to do
that and along the way you'll learn
about these topics and some of the
basics in the NetBeans platform so you
can see how that works and that would be
modules setting up top components
declaring a service looking it up and
also the window manager that you get
automatically with an FBX platform for
you for your windowing code and then
after that we'll get into Java effects
and we'll go through some some basics of
how you how you can use F XML and scene
builder to layout your UI and how you
can integrate it in with Java effects
and then we'll talk about Java effects
properties and we'll talk about binding
and we'll talk about how you do
animation and we're going to apply all
of these things in in the examples that
we'll have later on in this talk after
we get through the Java FEX we'll build
a Java FX program on native one like we
did with swing and then you'll get to
see how that works and then we're going
to do the same thing we're going to port
that Java FX code over to the NetBeans
platform and then you'll see how easy it
is to take FX ml and the Java FX code
that you've that you've done with
properties and binding and animation and
be able to integrate that in to a nap
beans platform application and this is
where we'll talk about the communication
strategies that's important to to learn
about ok and then after that we will
leave some of these small demo programs
that we have and we'll move to a program
that we discussed in our book and that's
the family tree app and this program by
the way is available on java.net so some
of you will probably want to download
this program and look at it and see how
we approached you know a real example
application that the youth leverages and
uses all these things that we're going
to learn about today and and then we'll
and we're hoping
have time at the end which I think we
will to show you our JavaFX charts
program which is another one that is a
NetBeans platform app that leverages all
the important things that you see here
okay at the end of the talk will tell
you how you can get the code so you can
download it and we encourage you to go
through our code and and so you can
learn more about it we only have as much
time today to go through it and then the
other thing I'll tell you is that all
the code is in Java 8 with Java FX 8 so
you will see some lambdas today and
you'll see a lot of code that is very
current with the current Java release at
the end of the talk will will have a
wrap-up and then we'll help we'll take
some questions for on QA ok all right so
we're gonna start off with a very
rudimentary but simple swing application
something that you guys will all all
know about and what we'll do is is we'll
we'll have a simple UI that works with
people so you can select a person in in
the left window and then you'll have an
editing form in the right side and we'll
do this all in swing we'll show you the
the organization of the program so
you'll get a feel for it and then we'll
take this application later and we'll
port it over to the NetBeans platform
alright now what does our application
look like it's pretty simple right we
have a J frame with multiple J panels
the left side of the UI will be a J tree
so you can select a person and on the
right side we'll use these swing
components to interact with a form and
modify the person object will have a
model class in person Java and will have
a family tree manager which is not very
sophisticated in this program it could
use a database but we're just going to
have it when you update a person we'll
just have it store it in a and a little
hash map that we have all right now the
features of this very simple swing
application is that we will have
property change events but it'll be more
coarse-grained right so the person class
won't be sending out I mean you'll see
property change events in the person
class but will be just using them in
this program of the family tree manager
when we update a person in a persistent
store once again the J tree will provide
the selection on the
and then we'll have a swing UI form on
the right that allows you to edit that
person and we'll have an update button
so you can update the information about
that person okay at this point we'll
have Gail switch over to our swing
application she'll go to NetBeans right
now and we'll show you really quickly
what this does it's it's not going to be
very fancy but it's what we'll have okay
so this is what the UI looks like and on
the Left you've got a J tree with people
and on them on the right side you have a
form that you can use so if Gail selects
a person she'll be able to modify like
the middle name of large I think Gail is
doing there and and and if she clicks on
the the top node the Update button will
be disabled and if she selects and if
she and if she goes ahead and selects
another person and doesn't update the
Update button will become enabled and
then she'll be able to click on that and
that would update that person and notice
that when she did that we have a
listener over in the other window so
that the you know the name will be will
show up there okay so we also have some
radio buttons that you can see and we
have a very small text area that allows
people to put in notes about a person
okay so let's take a look at this code
and what we'll do is we'll show you a
few things about how this is organized
okay if Gail expands the source packages
you'll see that there's three files here
and we've got them tabbed up above here
right and those are going to be the ones
that you see there and let's start with
person Java okay
and as gail shows this to you remember
this is just a standalone swing program
right when you look at this person class
you'll see that it has just fields and
it has some property change strings as
well define and then if she Scrolls down
a little bit more you know you'll see
you'll see the person the constructors
that are initializing the fields
yeah you're gonna make it there we go
make it a little bit bigger yeah okay
and as she Scrolls down here you know
you'll see the constructors are
initializing the fields there are the
property change events but again we're
not using these in the person class and
then the setters and the getters and
notice that when you look at the setter
is like on set notes right there that's
where we're firing a property change
event okay so now let's take a look at
the family tree manager the family tree
manager is going to be a singleton and
you'll see the hashmap here in a second
right there that has a key for a
person's ID and then the person object
itself for using hash map there there is
property change support in the family
tree manager and you can see that it's a
singleton since we have a get instance
showing up there and then as she Scrolls
down a little bit more you'll see that
we have the property change events that
are that are being fired there and we
have the ability to you know update a
person when the update button is clicked
okay let's look at the last file now
that would be the jframe and when gail
clicks on the design button right there
you'll see that we used Matisse and
NetBeans to do the layout for this and
that'll be important because when we
when we port this to the NetBeans
platform you're going to discover that
all the work that we did to do this is
just going to carry right over right
okay so if she switches to the source
now and and Scrolls down you can go down
to like line 105 and we'll just quickly
show you where we're building some of
the where we have the build data
function there the build data method and
then we have create nodes up above that
and then if she Scrolls back up to line
77 you know you'll see where we're
configuring the listeners and then she
Scrolls way down to 320 we'll show you
where we update the form
there it is okay and then a little bit
further then we clear the form down here
okay and then finally around line 407 we
should show you yeah there it is right
there this is the action listener for
the update button and you can see that
we update our model in the person class
and then we use the family tree manager
to do the update and fire the event okay
so that's our swing program and now what
we want to do is we're going to port it
to the NetBeans platform but before we
do that we're going to talk a little bit
about some basics of the NetBeans
platform so you can see what's going on
so let's go back to the notes and and
we'll do that
all right so the first thing that we're
going to do is that we're just you're
going to see when we port this program
the NetBeans platform is you're going to
see some some nice features that you get
for free you got a toolbar and a menu
bar and then those panels that you saw
that we read that we did was swing are
going to become windows that can be
detachable you can float them around and
resize them so you got all of that code
for free when you when you work with a
net beans platform you don't have to
write any of that and then we're going
to show you that we're going to take our
swing program and divide it into modules
and when we do that we'll define a
service for the family tree manager and
then we'll use a very simple lookup for
the selection and communication that is
required between the two windows but the
code that we have in there for the
property change listeners in the drape
j2e selection will will stay there
okay so let's bring up the program first
and show that to you and demonstrate it
for you and then we'll show you how we
did this
now remember this is a the NetBeans
platform version of this swing program
that you saw so Gale is running it right
now
and here's what it looks like now it
looks pretty much the same right except
that there's a some things here that are
different for example you see a menu bar
you know above our two windows there so
you know you can use these very easy to
interact with this menu bar and create
your own menu buttons and work with it
and there's also a menu at the top that
you can use this is all provided for you
by the NetBeans platform framework and
then the windows that you see here are
actually detachable so Galle can go and
float this window and move it around and
resize it okay and then put it back
which is called docking and she can do
the same thing with the right side
window and remember in the NetBeans
platform we're not writing any code to
do this it all comes as part of the
framework all we did was take that swing
program and put it into this framework
and they would give these additional
capabilities right okay so the behaviors
are the same right I mean Gale can type
in a middle name and she can click on
the Update button and then you can see
that the the left window here the left
top component actually updates as well
so the behaviors are all the same and
and now we'll we'll talk about how we
did this port and and what the issues
are so let's go back to the notes and
learn a little bit about the NetBeans
platform so that you can see how we did
this and then we'll go back and show you
the implementation okay so let's go to
the next slide and talk about the
NetBeans platform now why would you want
to use the NetBeans platform I think we
just gave you some of the reasons right
there you know you get the window
managing and the window scaffolding code
all all for free it's part of the
framework and you know when you design
with the NetBeans platform you get to
leverage a lot of those nice features
there's also plugins it's modular and
extendable there is a service
infrastructure that is built in that you
can use and there's lifecycle management
so you can over ride
methods in your programs to hook into
the framework at various cycles well as
your windows are being brought up and
dealt with in the framework and then you
have a chance to do some things during
that time in your own program a major
concept in the NetBeans platform is that
it's loosely coupled ok
so it really encourages you to to not
have interactions between all the
modules and there's going to be this
concept of module dependencies that
you're going to see shortly the whole
idea behind this is if you learn the
NetBeans platform it'll reduce your
development time and you'll get platform
independence along the way and there's a
very active community behind the
NetBeans platform so you can get a lot
of help and a lot of ideas about what
you can do and you when you use the
system now as far as the architecture
goes with a NetBeans platform it's
really based on a module concept which
is a collection of related classes and
these specifically our public interfaces
or library wrappers and then you have
you make up module dependencies which
will show you how to do when we get back
into the into the program again this
concept of having loosely coupled
designs is really a major theme in the
NetBeans platform and then the modules
are your basic building blocks for
building any any application with the
NetBeans platform the distribution
itself that you get is quite rich these
are just some of the things that you get
you get the modules subsystem you get
the windows subsystem that you that you
saw a little bit of a minute ago you
have the ability to look up and you have
file system API S nodes api's explorers
and property sheets and an action
framework and you also have a rich set
of dialogues that you can use as well as
UI utilities a visual library IO api's
and a built in progress bar now I want
to say one more thing about Amata module
actually is it's actually just a jar
file with special metadata and that
metadata lists public packages and any
dependencies that you have and all of
this is actually managed by a runtime
container so let's talk about that next
now the runtime container in the NAP
beans platform does quite a bit for you
it loads modules dynamically as you need
them and it enforces these module
dependencies that are very very
important when you work with the
NetBeans platform the runtime container
also unloads and stalls and uninstalls
modules at runtime and it bootstraps
your system helps you configure your
startup and the module and file system
API is the lookup and utilities I'll
give you the the features that you would
need to implement a sophisticated
Windows application the NetBeans
platform also has a class loader system
a separate one from maybe what you know
from Java this is part of the NetBeans
runtime container and it helps support
the encapsulation of your modules and
also enables class loading and the
integrity of your namespaces now this is
a this is a diagram for out of our book
that shows you in a diagram basically
how modules set dependencies on each
other a module dependency is a contract
between two modules in the NetBeans
platform where module a declares a set
of its packages public and then module B
sets a dependency on those modules and
what this does is it enforces that loose
coupling that's so important in the
NetBeans platform and we'll show you how
that works when we get into the code by
the way Gale will show you how to set up
those module dependencies it's all done
through dot wizards and dialogue so it's
very easy to do but when you when you
set this all up the NetBeans platform is
really helping you make sure that you
don't have any accidental things that
happen or any circular dependencies as
well we mentioned to you that you can
set up services in the NetBeans platform
so if you have a service then you would
think you must have a way of looking it
up and that's what this is there's a
very sophisticated lookup mechanism in
the NetBeans platform that allows you to
set up communications between modules
and you have a global look up which is
application wide and you have an
instance content lookup that you can use
as a container force lookups that you
want to do separately the reason why you
want to look look use the lookup in the
NetBeans platform is that it helps you I
enforce the loose coupling that you that
you have between the
modules and also the context sensitivity
for your windows and your data and they
can be queried and listened to and of
course it's very nice map of the service
providers that are available to you in
your system all right now those windows
that you saw Gale you know detach and
move around those are called top
components in in the NetBeans platform
it's the basic unit of display but you
might be interested to know that it's
actually a swing component it's extends
J component actually and it's
automatically integrated for you into
the Windows system so all you have to do
is go through a wizard to create a top
component and place the code in there
that you want and then the system itself
takes care of all the other details
about integrating it into your Windows
system you can set up a top component as
a singleton which is the default or you
can configure it as a non singleton if
that's what your system requires
obviously when top components have all
the built in code in the platform to do
docking and undocking maximizing
minimizing and so forth and you can also
configure a top component to open up its
startup or not and you can have a top
component persistence properties between
starts so the platform is really good
about remembering the size of the window
that you had last time and where it was
on the screen and all this is done
through Java annotations which are
generated for you by by the NetBeans
platform when you build the top
component but of course you can go in
and configure them yourself all right so
now that we've learned about some of
those basic things let's show you how we
to move a swing program to the NetBeans
platform and what we'll do is we'll take
that standalone swing program that we
showed you a few minutes ago and we'll
we'll we know we moved it over and we
showed it to you and now we're going to
tell you how we did it so very quickly
before Gale goes into the code what we
did was we created a NetBeans platform
application and then we created modules
and the modules were going to be top
components for the 2j panels that you
saw right so on the Left we'll have a
top component that will be called person
view
on the left side and that'll be a module
and then we took the form from the swing
program on the right and called it a
person editor module and then we created
a service for the family tree manager
and you'll find out a little in a second
here how we did that and then of course
we just copied over the swing code right
and but it went through the Wizards to
configure it and we have the same basic
behaviors that you saw okay so you guys
saw how the program operated and it and
what it looked like now let's go through
and show you a little bit of about the
code and what it looks like ok we'll
begin with the top component in the
person viewer okay that'll that would be
the left side of the window okay
and if you look at the at this at the
design view first hang on yeah can you
do that okay oh there we go
okay now remember we told you that when
we did the swing program that we
designed it with matisse this comes this
this comes right over you know we didn't
lose any of that and it's still there if
gale goes to the other top component
which would be the person editor and
clicks on the design view you'll see
that side and so remember these are both
top components right but now they're in
separate module but now they're in
separate modules so that's the first
thing we did was we took those J panels
and we created modules for them and we
put them in top components and then it's
all in the NetBeans platform system okay
let's look at the family tree manager
the family tree manager is interesting
because it's now an interface if you go
down to line 14 and can you select that
line there go
we now this is the this is what the
loose coupling was about that I was
telling you about right what you do is
you take this the family tree manager
that was just you know dot Java code and
you make it an interface okay and when
you make it an interface then you have
these public abstract methods that will
now be implemented in some
way in another got Java file so if Gael
goes over to the other dot Java for the
family tree manager this will be the one
for the implementation okay now you'll
get to see the the same code that you
saw in the swing program where each one
of these methods is implemented and and
you see the advantage of this right
because right now the family tree
manager just uses an internal hash map
right to store the people but I could
very easily convert this to a database
could not write very easily because it's
organized this way and that's exactly
and that being said if you created a
separate module to implement the
database you could substitute that
module for this module your client code
would behave exactly the same because it
goes through the interface and it looks
up a service and the NetBeans plan
platform will hand it the implementation
that it has right and and can you can
you click on on the line for the service
right there go oh right yeah okay now
this is the other thing that happens in
the NetBeans platform is you make the
family tree manager a service okay so
that way the NetBeans platform records
it you know in the service map and now
it can be looked up ok so now let's go
to I'm gonna turn it over to Gale and
let her show you how she did the module
dependencies and how do you East uh how
we use the NetBeans platform to do that
okay so in that diagram that we showed
you previously we're module B depended
on module a in this case we have a
family tree model that is its own module
in in this module
there's several source there are several
classes that we want other modules to
use the family tree manager so we can
look up the service and tell it what
service we want to look up as well as
our model which is the person code so we
put this code in something that we want
to be able to expose and the way that we
do that is
I can't get to the bottom what do you
know I can't get to the properties menu
yeah because the display is weird huh
it's gotta be a way
yeah can you get it from the top yeah so
with the display we can't we can't get
to that swoosh uh - I want to get to the
properties menu ah thank you yes
thanks okay so thank you gear time so
when you want to make a publicly module
have public packages it's the API
versioning and then you can you can't
see it over here but these are the there
we go you specify that you want this one
to be a public package and that's pretty
easy now both the person editor and
person viewer model need to access both
the month the person editor and the
person viewer module need to access the
person class and the family tree manager
class and they do that again by saying
that they want to declare a dependency
on the family tree model so they do that
here where they specify all the modules
that they depend on now included here's
the family tree model but the only
reason that we can say select that is
because it has some public packages and
you'll notice that the person editor has
some other module dependencies the
window system because it is a top
component and it's integrated into the
window system lookup so it can look up
services and these are utilities and
settings but the dependencies that you
declare are deliberate there's no
accidental or circular dependencies and
the runtime container that Paul was
referring to enforces these so you can't
get around it and that really helps keep
your code isolated from each other and
loosely coupled okay okay all right and
once again you know if you look at the
service provider line the annotation
there in line 19 you know the
saying that we'll show you in this
example is how you would look up that
service so let's go to the top component
for the person viewer and and what does
show you this really quickly look will
click on the source button and if you go
down to line 105 you'll see a look up
there it is right there yeah if you want
to well you can see it in line 1 if I
think they can see the lookup right
there
so this is where you're looking up the
family tree manager in the person viewer
top component and then if she goes over
to the top component for the person
editor you'll see the same lookup that's
done there in that top component and
that line number is 303 hundred yep
there it is right there in line 300 so
you could see there that's where we're
looking up so when each one of these top
components needs an instance for the
family tree manager to do something they
just look it up in there in the service
and get it back from the cuz the
NetBeans platform provides that for you
and then the goal there's one more to
show you that's the global lookup and
that's down before we go to that I just
wanted to point out that do it when you
do this lookup and you get an instance
back for a family tree manager it's the
implementation it's automatically a
singleton so you don't have to have code
to make it a singleton and this module
doesn't have any dependencies whatsoever
on the family tree manager
implementation and that's why you can
substitute you can get back a group of
instances and if you want to like do
several processes with something by
calling different implementations like
string processing doing one thing doing
you can get them all
you yeah I I can't know what it's I
think it's get all instances yeah look
at all just look up look up we'll give
you one but look up all we'll give you a
list good and there's also a global look
up to you want if you go down the line
if you go down a line 300 you can see
that right there - that's that's the
global look up that's being done there
and and we used that to when you select
a person on the left hand side in the J
tree viewer that component makes
whatever you select available and then
the other module can listen for changes
that so there's no direct dependencies
between those two modules at all it's
all done through the lookup and that's
the NetBeans platform selection
management system good okay so we did we
did some very simple things here too
with a simple program but we we took
something simple because we wanted to
show you how how easy it is to pour it
over to the NetBeans platform but of
course we have a lot more to show you
and we're going to have a lot more
sophisticated programs that are doing
coming up later so right now what we
want to do is go back to the notes and
we're going to switch gears here to talk
about Java effects and you want to close
those projects yeah because we don't
need them alright so the next stop on
the agenda is so we'll talk about Java
FX and we want to talk about F XML and
scene builder and then we want to talk
about the really cool things in Java
effects that help you design rich client
applications and that would be
properties binding and animation okay
now most of you know by now that what
the what job FX is all about and the
fact that it's a richer toolkit to be
using than swing besides all the
controls that are there there is a
thread that is used with Java effects so
most of you are familiar with working
with the EDT so right away we should
tell you that Java FX has a separate
thread from Swing ADT and we'll have
more to say about that later and how to
work with the with this thread itself
and how to work together with Swing
when we get into this talk later on the
other difference big difference between
JavaFX and swing is you have a scene
graph model much much different than
you've used in Java 2d or in swing
because you have nodes in a scene
heights in graph hierarchy that you can
manipulate and a node is a very very
cool thing in Java effects because you
can apply effects to a node you can do
you can do transforms you can do
rotations you can move them and you can
do animations Java effects as you know
it's bundled with the JDK so it's all
ready to go it's directly accessible in
the NetBeans platform without you having
to do any configuration at all and one
of the things that you want to do with
Java effects is you want to choose it
for in windows in the NetBeans platform
where the visualization is it's really
what you want and and that's what we're
going with all this too because later on
in our applications we're going to have
top components some of which with swing
components in them and some that have
Java effects and that's what's great
about the NetBeans platform is that you
could put both of those in or you or
separate ones or or and architect it the
way you want ok the reason why you want
to use Java effects is because the scene
graph hierarchy is so nice to use and so
flexible you have a node structure that
you can work with too and I mentioned
you know effects here are some of the
main ones that you can use there's a lot
more than this
but but just having gradients you know
on backgrounds for your UIs is so
pleasing to the eye we're used to seeing
that on the web but we don't have that
user experience of swing you know we
just don't so and and if you do that
sort of thing it's really hard to do
it's very easy to do in Java effects you
can also have reflection effect effects
and also drop shadows you know drop
shadows on buttons and text boxes just
gives it more of a 3d feel that's
pleasing to the eye very very easy to do
these things and effects hard to do in
swing the other reason you want to use
FX is because of properties and a lot of
you guys have written a lot of code
where you you know you implement an
interface you override a callback method
you set up a listener and you have two
callback method and it turns out that
you know with FX that you have these
cool things called properties and a
finding system that simplifies all that
and and allows you not to have to write
that Louis listener code and we will be
showing you that here shortly
save a properties finding system and
then the other reason to use FX is
because the 3d is so nice now we're not
going to actually do any 3d in these
examples but it is another reason why
people are using FX these days and we
have done a small 3d and in the NetBeans
platform so it does integrate well into
the NetBeans one right okay so let's do
a little Java FX application okay and
what we're going to do is you know since
we're sticking with the same kind of
approach that you saw let's redo the
swing program that we did in Java
effects so you can see what it looks
like and how it can be it can be put
together this time we'll use a stage and
a scene approach and then we'll use a
split pane control right between the
left window and the right window and
this is not going to be an FP ins
platform application this is going to be
a standalone java effects program we'll
start with that first and then we'll
move this one to the NetBeans platform
so you get to see again how to do that
we'll have a tree view on the left side
right tree view as Java FX's J tree and
then you see these are all Java FX
components on the right-hand side for
the UI and you'll recognize that those
are the counterparts for swings
components and the model class you know
the person Java is going to be pretty
much the same and we'll use the same
family tree manager to store our person
objects but the big thing that we'll do
in this program is will show you F XML
and we'll show you how to use scene
builder and and and we'll show you the
importance of doing something like that
and how easy it is to port that over to
the NetBeans platform same features
swing only application is going to look
exactly the same and behave the same
will have property change listeners that
are coarse-grained the tree view will
provide the selection of people on the
left side and the Java FX UI on the
right side will do the editing and the
updating okay so let's switch over to
NetBeans and fire up this Java FX
application for you
so you can see what it looks like okay
now remember this is a standalone JavaFX
program that implements the same UI that
you saw earlier and right away you know
if you haven't seen some of the JavaFX
before you know you can see there's
different packages and and so forth okay
so the first thing you notice is you
know we have a gradient applied it isn't
showing up really really well here on
the screen but it looks nice it looks
nice up here okay and and don't
underestimate you know important this is
and it's in you eyes right and when you
have something like this it's pleasing
to the eye people go to the web and they
get this experience but they don't in
swing and that's the point right so we
have some gradients going on in the back
but we have a split pane between the two
so so Gayle can take the split pane and
move that so that's a nice to have in
the and the effects control there and
then we have a J tree on the right so
Gayle can go and select I mean a tree
view on the right sorry we're in FX here
and and so Galle can select an update
person and the update button works the
same as before so you know we're going
to show you how we did this but remember
when we did the swing program we used
Matisse right - for the drag-and-drop
tool and Matisse generates Java code
right but what we did here what we used
F XML which does not generate Java code
it generates an XML code that we'll show
you
and that made this very easy to
implement so let's let's go back to the
notes now and show you how we did that
and show you a little bit about FX ml
all right now what is f XML F XML is a
declarative markup language that you can
use to describe a UI it's not Java code
its XML okay
it treats your UI basically as data and
in Java effects you can build a scene
graph dynamically from your F XML file
that you can do you can do your F XML
files yourself and if you have very
small programs that's not difficult to
do but there is a very very nice builder
tool out there called scene builder
which is downloadable and and wired into
NetBeans it's not part of the NetBeans
IDE but it but it does the NetBeans IDE
does have selections that allow you to
access the scene builder NetBeans knows
about it and that beans knows about it
and the great thing about about scene
builder is it's a drag-and-drop tool so
you can build your UI and it generates F
XML code that you can then access from
Java okay obviously what this is going
to do is it's going to keep you from the
very tedious work of doing a button and
then calling setters to configure it and
we've all done that and it's very
tedious to do those sorts of things well
we can do is we can we can declare the
button in the F XML and then we can have
declarative statements that set those
properties and then the amount of Java
code that you're writing will become
reduced and that's a good thing
and the Java code becomes more control
oriented behavior oriented and the F XML
is your view or presentation right helps
you separate doing the MVC design
so obviously seen builder is a great way
as a as a prototyping tool to put at UI
together and discuss it in meetings for
things for what you'd want to do but
we've also found out that F XML works
really well with an MP's platform so we
think it's really one of the best
structures that you can use for building
sophisticated applications so that's
what we're going to show you how to do
today all right now you know this is the
tutorial so we're going to tell you a
little bit about F X ml maybe you know
about it but if not here's how its
organized you basically work with three
files you work with an F XML file that
defines and configures your UI
components and like I said you know
we'll show you some snippets in a second
of this so you could see it but you'll
be defining what your UI components are
and you'll be specifying their
properties for what they're going to
look like and then you're also in the F
XML file going to specify where the Java
controller is that that is going to
communicate with the F XML file and that
Java controller is the second thing that
you work with and what you do is you use
annotations the at F XML annotations to
access the UI components in your F XML
file and then the controller is going to
allow you to override an initialize
method where a callback can come back to
you and you can do some custom behaviors
that you wouldn't be able to do or want
to do in the F XML the main programs end
up being very very short here because
all you have to do is is build the scene
graph from the F XML file and then once
you have that set the scene in the stage
and you are ready to go all right
so let's show you some snippets of what
this looks like very very
straightforward to do right in FX ml you
would have these two components as an
example I'll label okay with just text
and you can see how this works right I
mean somebody is going to read this file
and then they're going to instantiate a
label and then they're going to call the
set text with the string first it's all
going to be done for you
on the other component is a text field
right where we specify the name with an
ID tag first name text field and then we
wanted to show you that you can also in
an F XML file specify a an event handler
in this case for releasing a key and the
hash little hash tag there on that says
that the name of that of that event
handler in Java code is going to be
called handle key action so once again
when this F XML file is read we'll know
about the text field it'll it'll create
the text field component it will give it
a name that can be referenced in Java
and we'll know where the event handler
is to call it when when the key is
released now if you go over to the java
code in the controller this is what it
would look like you don't instantiate
label you don't do a new you don't do a
new on the textfield you use FX ml
annotations and notice that the names
that you're showing here the first name
text field and the handle key action are
the same names that you see in the
corresponding F XML file okay all right
if you want to see the operations of how
this works a little more detail it's a
three-step process the main program in
step one will invoke the F XML loader
and in step two the F XML loader will
parse the F XML file that you just saw
an example of that and build a scene
graph
step three is where the F XML loader
will instantiate the java controller
class and invoke the controller's
initialize method and this will be the
callback to you so that you can do
custom type behaviors if you want okay
so the next thing we're going to do is
we're going to show you a very small
Java FX program that is going to
demonstrate how you use FX ml and we're
not going to use seemed older for this
because well we want you guys to see
what it looks like in a very simple
example and then when we go back to our
example will then show you how scene
builder can be used okay so why don't
you go ahead and run this program
very very simple program right it's this
is an FX program now that has a you know
light yellow background and it has a
blue a light blue rounded rectangle with
a text string in here that is fading in
and fading out and this is a Java FX
animation okay and you know we're gonna
use a stack paint layout for this it's a
very simple program but but I use this
in my in my Java FX courses to show
people how FX ml can be used it's very
simple to follow and then once you
understand this you can move to more
complicated examples okay so let's go
into the code right now and and show you
a few things
okay so the first thing we want to do is
we want to go into the hello job F XML
file and we want to want to point out
that that the three files that Paul
talked about are all here the F XML the
controller code the controller class and
then this one is the main program right
so now we're going to F X yeah now when
Gale right clicks on the F XML she has
two options and what we're gonna do is
we're gonna take the edit option here
and we're going to show you the F XML
code for this very simple example so you
can see how this is is set up okay
in fact this all fits on honest honest
on one screen maybe maybe not on this
screen yeah I think it all fits there so
this is easy for people to follow right
okay so you see what's going on we have
it's declarative right so we have a
stack pane layout we're inside the stack
pane we have the rectangle that you saw
and then we and then we have a text
component on top of it you can very
quickly see how this is all set up right
the rectangle has an ID and then it has
the arc height and arc width that's what
does the rounded corners and then we
have a fill color that's the light
sky-blue that you saw and then we have
the width of the rectangle and the
height of the other words author has a
lot of built-in colors 140 something
yeah yeah that's pretty incredible
yeah it's really really nice all built
and fillers yeah
notice that we can apply a drop shadow
and I don't know if you notice that but
we had a drop shadow on that blue
rectangle to see how it's embedded right
inside the rectangle we have the effect
tag and then we define a drop shadow
with with a color and an offset you know
in the y-direction that gives it the the
drop shadow effect and you can very
easily see like I said that somebody is
going to read this and they're going to
new the objects for you and they're
gonna call the setters and you don't
have to do any of that right the text
component is going to be on top of the
rectangle because it's a stack pane
layout and we have a fill color of dark
slate grey you know we have all and look
at this we were able to access the same
drop shadow that we defined up in line
12
we can do that with a little dollar sign
in F XML and there's the text string
that you saw and then just like we
applied a drop shadow effect to the
rectangle we can also have an embedded
font tag on the text that says oh I'd
like this font to be bold and 32-point
size okay all right so now let's go and
look at the controller so you can see
what that looks like and you're gonna
make that big alright now this is kind
of what we you saw in the snippet right
this is Java code now right but it looks
different than what you normally see for
example we are not going to instantiate
the rectangle we are not going to
instantiate the text but we still need
handles to it right and that's what the
F XML notations give you there right the
ability to access those in case you need
them and then we override the initialize
method because we want to do the
animation right that's the fading in and
fading out and we're not going to talk
about that code right now because we'll
we'll talk about that later when we get
into more sophisticated applications but
the fading in and fading out that you
saw of the hello from job effects is all
being done here with this animation and
I'll and I'll show you guys how to do
that a little bit later and the
animation is applied to the text field
so that's how you do that okay the last
file to look at is the main program
which is incredibly short now that's the
point all right so here's the
application and you know if you haven't
seen a job effects program it extends
application and then you override a
start where a staged object is passed to
you and and this is it right all you
have to do is go invoke the the load for
the F XML loader and direct it to where
your F XML file is and when you get back
a route there as a parent type you have
a scene graph that's completely built
for you and then all you have to do is
put it into the scene configure the size
of the window and the background color
and set the title set put the scene on
the stage and your gun you're off all
right now this was
very very simple program to just show
you how F XML could be used and and how
it could be wired into Java but now what
we want to do is want to show you more
sophisticated uses of doing this so
let's return back to the notes and tell
you a little bit more now about scene
builder because scene builder is what we
used in the application that we showed
you earlier to build the the F XML
because the F XML is going to be a lot
more complicated right in this example
now what scene builder scene builder is
an open source tool that gives you drag
and drops for a building you is very
quickly and it generates F XML not Java
you're successful by the open selection
in the NetBeans IDE and there's also a
make controller option in the NetBeans
IDE to help synchronize your controller
with your F XML file this is very nice
right because you could come up with
your UI in an F XML and have the
controller be set up to work with it and
then you could go in and decide to add
another button or something else into
your UI you can do that in scene builder
you would rewrite your F XML now you
could take this make controller option
in NetBeans and it would automatically
modify the controller file for those new
components that you added or deleted
obviously the reason why you wanting
scene builder is because you can build
real gooeys with it and without writing
much code and it's a very fast
prototyping tool it's also a great way
to visualize your scene graph structure
okay so let's go back now into our
program not the hello job effects
program but the you know the the person
program that we did earlier and now what
I want to do is I want a gale to go up
and right click on the FX ml file and
remember when Gale took edit before and
we saw the FX ml now she's going to do
an open and when she does that watch
what happens
right what's going on
well it's it's the resolution yeah the
resolution so there it is
sorry about that okay so yeah this
wouldn't be a very good way to sell
scene builder to somebody now would it
yeah this is too bad because you know if
you haven't seen scene builder it's
really really nice you know it's
drag-and-drop tool with component
palettes there are some of them there I
didn't do it it's it's not too different
than working with Matisse and that you
select controls you have a hierarchy
below here in this window you have a
library of controls that you can select
and drag and drop and the inspector lets
you set properties and configure it so
like a prompt xfer field the text label
the font size whether or not a text
field is editable in these inspector of
course is dependent on which control
that you're selecting so it's really
hard to see it in this resolution sorry
about that but it is really nice yeah
okay so let's go let's go back to let's
go back to NetBeans here and instead of
bringing up scene builder now on the F
XML file let's show you that what the
code that it generated now remember this
is the nice part about scene builder is
it is that created all this code can you
make make it bigger there we go
okay and there it is alright now you a
lot more complicated UI then yeah and
you can see why you know I showed you
the smaller program first right but
there's no difference right and remember
we didn't we didn't write all this right
we had seen builder generate this for us
but the same idea right you know it
defines the UI that we have it's it's
easy to change it's easy to move things
around and add new new controls and the
F XML file will be updated automatically
for you and then you wire it into your
Java code
in the same way okay so what do we want
to do next year we should show you we're
gonna put the hello Java effects right
from that platform actually what we want
to do next I think is is we want to go
back to the slides and talk about the
JavaFX properties and then I'm going to
show you how we're gonna go back into
our code here and show you how we did
this so now that we've now you've seen a
scene builder that that built our UI for
us right now let's start look talking
about Java effects because that's what
we're using here and and then we'll
we'll show you how that's done okay now
in Java effects you have something
that's much much better than fields
right you have things called properties
and properties are observable which
means that you can have somebody respond
to a change that's made to that property
and they can be notified for it in other
words these these properties follow the
publish/subscribe pattern the reason why
you want to use properties and Java
effects is it encapsulates data with the
event delivery and you can be used
binding expressions to to work with them
it's nice to also know that all the
JavaFX controls provide properties for
you and this makes it very very nice to
design and work with the UI's with with
these JavaFX property concepts at this
point now let's go back into the code
and let me show you some of the
properties that we put in to our our
person effects program and we'll do that
you're let's say we're in the person F
XML program now right so we want to we
want to go down let's look sorry yeah
yeah let's look at the family tree
manager first
okay now when Galya Scrolls down here
right you'll see one of the first
properties that's used in our family
tree manager okay there it is right
there
okay see you see in line not 30 I think
it is or is it 20 yeah the unobservable
map okay see what we're doing is
remember that we had a hash map before
in the swing Apple application now in
job effects we have an observable hash
map which means that if anything if we
can set up listeners so that if anything
changes in there we can have somebody
else be notified automatically without
us writing any listener code or anything
like that the other thing that we can do
is we'll show you more properties let's
go to person dot Java and you guys will
remember when you saw person dot Java
and swing that we had fields right but
now when Gale brings this up you'll see
that in the person Java we now have
properties okay right there okay we
recall from the swing program that we
had fields for first name middle name
last name and suffix now in Java effects
these become observable properties
particularly strength properties okay
and finally down if you go down to line
95 we wanted to show you that you still
have javabean capabilities here right
with setters and getters yeah I want you
to go to get notes right there okay so
we still have setters and getters right
like get notes and set notes but now
note that there's something new in Java
effects with properties and this is
called a property getter cenotes
property and there's also going to be a
first name property and a last name
property and this is part of the job
effects component javabeans JavaFX beans
protocols so it's similar to what you
already know except that we now have a
property getter and the notation for
that is to take the name of the property
and then have the word property after it
with a capital P just like we do and in
it's nice that the naming convention is
the same as with Java beans
so if you have code that does like get
notes or set notes it's the same but if
you want to use the more sophisticated
features of JavaFX properties that's
what this is for and you'll see later
that it's the property getter used with
binding expressions and it's binding
that really helps you write okay let's
let's go back to the notes now and talk
about the next important topic and job
effects that we're going to be using in
this program all right now this is
binding you know this is Java FX's claim
to fame here is the ability to define
these properties and then have them
participate in dependencies with other
property values and this is very very
often what we do in the UI's is that
something changes and what we're used to
doing is things like firing property
change events and having to set up
listeners I'm sure of a lot of you have
done that and although that's you can
still do that in Java effects there's a
simpler way through binding mechanisms
that'll make it a lot easier for you to
write code and for you to make less
errors one of the great things about
binding is it allows you to very easily
synchronize your UI control state to
your model data and you can have them in
one direction or both directions you can
set it up any way you want the reason
why you want these binding in Java
effects is because you won't have to
write event handlers and listeners
there'll be a very concise syntax that
you can use and you'll you'll make less
errors so we're going to show you some
of that right now all right now Java
effects there are four binding
strategies that you can use and you pick
the one that's appropriate for what you
need
okay the simple bind is one direction
where you say I want to update a
property when another property changes
that I listed as a dependency okay and
that way you've got to listen our
concept right but you just don't have to
write a lot of Java code to make that
happen if you need it to have
bi-directional updates between two
properties there is a bi-directional
bind in job effects that's your second
strategy and this will update a property
in both directions when you
set up one property and independent
property as another and I'm going to
show you some examples of these coming
up the third one is a fluent API and the
fluent API is a very large set of
libraries of binding expressions in Java
FEX that folk that that the Java
designers have done for you guys and you
can use these fluent API is instead of
writing your own it makes it a lot a lot
easier and these are quite extensive you
know they have bindings for strings and
boolean x' and even a generic object
binding that you can use to to work with
any type okay however there may be a
situation where you just have to do it
yourself and that would be the last
strategy now it's the custom binding and
here you're at a lower level you specify
one or more property in dependencies and
then you can get a callback and now you
can do sophisticated things for example
you might have to go read a database or
you might have to read a file write
something you can't do with the fluent
API but you know you're in java code and
when you get that callback on the custom
binding you can do whatever you want
okay all right so let's show you some
examples of these and then we'll show
you how we're using them in our
application okay all right let's do the
one way binding first okay this is
unidirectional and that means that you
set up a dependency in one direction
okay specifically it's a it's between a
property object and an observable value
so let's look at our example here this
is actually in our code so we don't
actually have to go look at it we can
look at it right here alright we have a
label in our code and then we have a
text field and what we're doing here is
we're saying that I want to bind the
text property of the label control to
the text property of the text field
control now what does that mean what
that means is that if the text changes
in the text field the labels text will
automatically update too so you have a
listener set up and you have a callback
and you don't have to do anything except
one line of code but remember it's in
one direction right if the text property
in the text field changes it updates the
label right now labels aren't
to update unless you do a setter on them
right but but you know it's one
direction that you have to have to go in
but so you have to decide you know how
that's going to be set up since it's
uni-directional but I also want to
emphasize since I just mentioned the
fact about calling a setter on the label
is you can't actually do that because if
you took the label after you do this
bind statement and you called a the
setter on it to change the text property
that would be a problem because you're
already bound to a property of another
component so my bullet item there says
cannot explicitly update bound
properties
JavaFX will you know generate the code
to give you a runtime error if you try
and call set text in this example with a
label because your you know that text
property is bound so you might say well
wait you know maybe I want to do that no
problem there is an unbind that you can
call and release the binding and then
you can call the setters if you want but
all this is checked for you to make sure
there aren't any unwanted side-effects
or anything like that okay all right now
you might want to weigh binding okay
dependencies in both directions where
properties will update automatically for
you in you know in either side this is a
binding between two property objects
where updates will happen automatically
and here's our example which again is in
is in our code that that your that you
saw already this is bind bi-directional
where we're saying that we want to bind
the text property bidirectionally for
the text field to the first name
property of the person object all right
now what does this mean
very simple if the first name property
changes in the person class the text
property updates in the text field
conversely if the text property changes
in the text field then the first name
property and the person updates so do
you guys see that we're we just have a
way of synchronizing our UI and our
model right the person is our model
right so in Java code if somebody goes
in there and says person dot set
first-name and they change the name the
text field in our UI will automatically
update
and conversely if somebody goes into the
UI in the text field and type something
in then our model will update
automatically one line of code with a
bi-directional bind and yet we're doing
very very common things that we do in in
UI designs okay and this we have this in
in the code that we just showed you when
we ran it a little while ago okay the
next one is the fluent API okay and
remember that the fluent API is a very
large library of binding expressions
that you have access to okay
categories are boolean 's and numbers
and strings and and generic objects you
have quite a bit that you can work with
here a very simple thing that we did
just to get around you know just the way
it's set up is in in the api's for the
buttons is we made up in our own
property a boolean property called
enable update property okay and we
created it with the class simple boolean
property and there is a constructor that
will say who it belongs to
what its name is an initial value so
we're using this to say if the Update
button is going to be enabled it will be
true and if it's going to be disabled it
will be false
unfortunately it's just the way it is
but the update button and Java effects
doesn't have an enable property it has a
disabled property it's the opposite
right no problem you know we want to
keep these in sync right so we just do a
bind and we take our custom property
enable update property and we just use
the dot not in the fluent API to say
that if it's false then it's true if
it's true it will be false one line of
code to do that and it makes the Update
button behave properly it's a great
example and a very simple example of the
fluent API and obviously you can do much
more sophisticated things within this
with the flow and API but we're you know
we flew an API also has a lot of methods
for formatting strings and doing if you
have a number property you can do number
operations add subtract multiply divide
a great example
is creating a conversion between
Fahrenheit and Celsius you could do that
all with fluent API binding yes no no
you but you could use custom binding to
do that yeah so again you know you can
always drop the custom binding and do
exactly what you want to do everything
does have to convert to a method but
there's also a a ternary operator that
you can use on buying called called when
when if it's true do this else if it's
false do that so and you know what we
use that for that's really nice you know
how you can have a button that says
start and then when you start something
it says pause you know in one line of
code with this when that Gale said we
can change the label of the button from
start to pause depending on the state on
the state of say an animation it's
really awesome it's one line of code and
you know if you've written code like Ted
and you know in regular Java you know
that it's a lot more complicated than
that okay let's show you one more
example now of binding and that's custom
binding and and this is the most
powerful one that you can work with
because you know this one is a
lower-level one it's more flexible you
can do anything you want with it and in
a lot of cases it will give you better
performance too but you know if you can
stay at the higher level and work with
the bind statements that we showed you
that's really the way to go but
sometimes you have to do custom binding
the custom binding is very useful but
the syntax is intimidating the first
time you see it so this is the format
and we're going to show you an example
in our code here in a minute but let me
just go through the format what you're
doing here is you're newing and xxx
binding which means that you select a
series of abstract classes that are
available to you that are type dependent
for example if I want to do a string
binding I would put string binding in
where the put string in where the xxx is
if I wanted to do a boolean binding I
put boolean in there if I wanted to work
with paint paint color I would use an
object type with with the generic type
being a pain but you select the abstract
class and put it in there and
then you get an anonymous inner class
that's generated from that and this is
the part that intimidates people is the
super dot bind but actually what you're
doing is you're just inside the
anonymous constructor and you're calling
the super bind to declare what your
dependencies are and remember those have
to be properties in there
you can have one dependency in there or
you can have a comma separated list and
that will be the dependencies that solve
any of those properties change then you
get a callback to a computer you okay
and inside compute value you can do
whatever you want to do as long as you
return a value that is the same binding
type as the type that you chose up for
the X X X's for example if I chose
string binding then compute value would
return a string and if I chose boolean
binding then compute value would return
a boolean and so forth okay all right
let's show you an example of this now so
you can actually see it because the
other examples that we had up here were
our in our in our code and this one is
too but we're going to show you a real
one at this point so let's go into the
person F XML app here and we want to go
into person dot Java and we'll go down
to lines 37 when you can make it big so
you can see it
okay so Gayle scroll up for a second
here so I can remind them about these
properties okay remember no fields here
right Java FEX so these are observable
properties for first name middle name
last name and suffix right okay now
here's where the binding is it starts in
line 37 okay see the format that we just
talked about see there's the new and
instead of xxx binding that I showed you
have a string binding so we have a
string binding after the word new and we
have a string binding after the word
final and those are that's an abstract
class but we get an anonymous class that
that extends that and then we call super
dot bind and specify the dependencies
now wouldn't the dependencies be you
know the person's name their first name
middle name last name or suffix so right
anytime any of those for change when
anytime they update we'll get a callback
to compute value and in compute value
we'll use string builder to go through
and build the person's name from those
properties and we'll build it as long as
they're not empty and we'll use string
builder to do that and remember that
since I use string binding I'm going to
have to return a string that's back so
that's why we convert the the string by
a builder to a two string down there in
line 57 and that that comes back so
remember now all we did was we defined a
custom binding but we haven't actually
used it yet so we're we just interrupted
this is where if you wanted to do any
kind of range checking you could put in
any way we're doing range checking
because we're saying if the string is
empty don't include it so it's so that's
where you can do anything in compute
value so I think you guys see that you
know when you use the dot bind statement
you know it's nice and a lot of times
it's it's simple enough for you what you
want to do but if you have to do
anything else where you have to check
you know range checks or any kinds of
things like this then you can always
drop to a custom binder okay let's let's
show you where this is used this is
actually used in two places in line 77
we're going to define it in the
constructor so that when these you know
when we call the setters on these fields
that will do the bind and notice that
we're saying
that we're gonna bind the full name to
our full name binding custom object so
it's still a bind right but inside the
parentheses for the bind instead of
picking a built-in property for a text
field or a or a label or some other
control we're just using our own binding
expression and then we have another one
down here in line 88
and that is also the same thing so this
is where the full name binding is used
and it's a good example of how you could
use custom binding okay let's go back to
the notes and move on to our next topic
in the agenda and that would be okay so
now we know a lot about job effects
right I mean we know we don't know
everything about it but we've seen the
important things that we have so now the
question is
we'd like to integrate Java effects into
the NetBeans platform so what are the
issues for doing that and we do have
issues because there's going to be swing
based you know code and swing based
things that we're going to be working
with so we need to talk about these very
important communication strategies and
how you do this so let's do that next
all right now there is a there is a
component out there that is your best
friend in this world if you're going to
be working with swing and Java effects
together and that is jfx panel okay and
you can see that that's in this package
but it is it's your friend because it's
going to allow you to embed JavaFX
content into a swing based app alright
and what will happen that's so nice with
jfx panel is that any of the input or
focus events that happen are
automatically forwarded to the scene and
not intercepted for you so they so they
go on through and that means that you
know you're not going to disturb any of
the of the swing stuff that you already
have out there the other thing that
happens is that when you create an
instance of jfx panel
it starts the JavaFX runtime
specifically the separate application
thread that we were talking about now
it's very easy to create a jfx panel
here's some code snippets that show you
how to create one and then simply add it
to your J component let's say with a
boarder layout that's centered now this
is another diagram out of our book that
shows you how all these things fit
together in the NetBeans platform with
top components and jfx panel and F XML
all right now this is the way to design
large UI's complicated you eyes you take
us an approach like this right and
that's what we're going to do with some
of these new applications that are going
to come up so here's how it works right
the NetBeans platform has top components
you guys know what those are right those
were the windows that we showed you that
we did in our application and what the
top component is going to do is it's
going to create an instance of the JFX
panel and then the top component is
going to invoke the F XML loader to go
out and read the F XML file and build
the scene graph now you guys know what
all this means because I I talked about
F XML and I talked about the loader and
you saw that once the scene graph is
built by the top component the top
component will only interact with the
scene graph by going through the JavaFX
controller and invoking the public
methods on the JavaFX thread and if you
take this approach everything's gonna
work great right because you know the
thread stuff is going to be exactly what
you want and the top component is you
know it's going to be decoupled from the
scene graph and all the updates to the
scene graph are going to go through on
the application thread and go through
the controller there's not going to be
any direct interactions with the F XML
seeing with the yet with the scene graph
from the top component after it's built
and we'll show you in code how to do
this and that's what I just wanted to
add that this is why we really recommend
using the F XML with controller class
structure because it just fits really
easily into a top component all
automatically your Java code
is in the contour manipulating the scene
graph is in the controller class and
it's separate separate file you know
okay if this is code that's gonna be
manipulating the scene graph it's in my
controller code I'm doing this on the FX
thread and if I need to call one of the
if I create a public method to
manipulate my scene graph I know that if
I call this from the top component I
have to call it within the JavaFX
application thread okay so the next
thing we're going to do is we're going
to go back to this hello Java FX program
that I use in my courses to show people
something really really simple let's
port this to the NetBeans platform and
it's so easy to do that we're gonna
actually do it right up here right now
for you and we'll show you the steps to
do that and then after we do that you
know then we're gonna get into more
interesting UI examples and start
building on all these concepts that
we've learned here in this tutorial ok
so I'm gonna walk through the steps to
do this let's see you've got the you got
everything set up yeah okay good alright
so step number one is gales going to go
up and create a new NetBeans platform
application so she's gonna the NetBeans
modules will be there and she'll select
the NetBeans platform application and
click on next and then she'll give it a
name and we're gonna call it hello FX
app and we'll click on finish and what's
going to happen now is we're building a
NetBeans platform application that's
empty and doesn't have anything in it
yet at this point and however you know
it's but so it's ready to go right but
but we have to build modules right and
then so that'll be the next step
so Gale is going to right click on
modules and select add new and then
she's gonna put in a project a project
name there
hello FX module and when she clicks on
next she'll need to put in a codename
base so she's gonna put in ASG teach
basics this makes it easier for us to
copy over the code we're matching the
pack yes that's why we're kind of we're
not promoting our company well I guess
we are but anyway okay and and now we
have a module there right so the next
step is that we have to change the
source level and the reason for that is
the reason lambdas okay so what gail is
going to do can you get to the
properties yeah there you go the source
level is 1.6 but we're using lambdas so
we're gonna bump it up to 1.8 click
click on OK right there alright and now
the next thing to do is to create the
top component so gail will right click
on the package name there and say so the
top component is going in the module
that we just created okay
so she'll say new and then we'll select
window and there'll be a drop down there
for what window position you want and
gail is going to choose the editor there
and then she'll click on the open on
application start so that means you'll
see that top component window come up
when the program starts out and then we
have to put in a code name prefix so
you're gonna you're gonna put in the
hello FX right there good and then we'll
click on finish oh before she does
though you can see that you know the
wizard is going to be creating the top
component and that will be the name of
the file that you saw and you guys saw
these top component files in our in our
example we're just showing and the floor
is is what Matisse uses so it's creating
a you know a swing component here right
ok so gail click on finish and now we
have you know the the source view comes
up by default and all we have to do now
and the codes been generated for the top
component but now what we have to do is
we just have to transfer our Java FX
code that we wrote in the original
program over to this top component and
this is one reason also if you are
designing with FX mmm
you're the F XML and the controller code
can pour it right over you don't really
need you don't do anything to them right
so we're gonna do that I'm gonna copy
and paste the F XML and I'm gonna put it
right in here and if the package name
did not match you'd have to do a little
bit of refactoring there because the
there's strings in there that says the
name of the controller that's based on
the package but that's the only other
modification you would have to do okay
now we're ready to yeah now you're ready
to take the code snippet we already have
a the code stored somewhere in a little
file so we can just copy it over so the
snippet now is the code that we'll need
to generate the JFX panel call the F XML
loader to read our F XML file and and
generate the JavaFX scene graph so yeah
so this will be quick way to do this
right is she'll copy all that and show
replace this constructor that code was
generated right and she'll paste that in
and of course it's gonna get a lot of
red lines right because we need to fix
the imports so she'll do that now and by
the way I'm just before we go farther if
you do this sort of thing please take a
second to go through and make sure that
it's bringing in everything that you
want because you know can go
you could go out the job is match
between job effects and swing like
rectangle yeah um we're not using a
rectangle so or it's and if you don't do
that yeah if you don't do that you can
get really strange errors and be very
confused so but these are all okay so
they all go away and yeah we're good
so let's run it okay before I run it I
just wanted to point out the code you
Paul showed snippets of it before but we
have a border layout that we put in the
top component we create the JavaFX panel
we add it to the boarder layout and then
we haven't talked about this but this
set and
that exit false that if you closed all
of your top components that have jfx
content by default the JFX runtime
thread quits and then when you want to
open up another window you don't have
your runtime system anymore so this we
always put this asset in plus at exit
falls in front of it to make sure that
the runtime sticks around if we close a
window and I'll show you will close the
window and then we can open it back up
and that's because of this and then this
platform dot run later is the JavaFX
thread that we create the scene and this
is a little bit more complicated than
the code you saw before but that's we're
just reading the F XML and generating
the scene and assigning it to the panel
so I mean now let's run it so now let's
run it
okay so it's say map we didn't really
have to do anything too too much and
like I said you you can close the window
and then open it back up and still there
and because it's the NetBeans platform
you can do cool things like float the
window and you have your toolbar and
everything else so this shows you how
straightforward and easy it is to put
JavaFX content into a top component
window in the NetBeans platform okay so
let's go back to the notes and go to the
next topic and oh did you close scene
builder - yeah good okay so we already
showed you those steps we just did that
and now we'll be at this point where we
have you know where we're going to show
you the code that we use to move our
program that we showed you in how we
moved it to the NetBeans platform this
is the JavaFX version of our program
we're going to divide it into modules
we'll have a tree view on the left side
we'll have the job effects controls on
the right side well our model class will
be the same as before the family tree
manager will be an interface with an
implementation that just stores things
into a into a hash map that we talked
about and the behaviors will be the same
and we'll integrate the JavaFX component
code into the top component and again we
use scene builder to create the F XML
with minimal changes so let's run this
now and you will see the same Java FX
program now running in the NetBeans
platform and Gail's gonna bring and
you'll see there's yeah you can see
there's four modules there
and here it is okay we don't you know we
don't have to spend too much time on
this because you guys have seen this
many times by now
it's a NetBeans platform application but
it's JavaFX it's a Java FX version of it
and again you know Gale can select
something in there put in a middle name
and the Update button will be enabled
down below and then we'll get an update
over to the left but remember that this
is all being done you know with binding
expressions right as opposed to the
listener code that we had to wire up in
the swing version okay so let's talk
about the thread issues now that go
along with using Java effects in the
NetBeans platform and you know we wrote
about this extensively in our book and
we're going to give you guys some some
strategies to use if you decide to go in
this direction alright so here's the
story right and we know that there are
we know about the the swing threads we
know that when we create a control and
swing and we update it we have to do
that on the EDT because a single
threaded you ought okay JavaFX has the
same approach it's a single threaded DUI
but it has its own separate application
fret thread so it is important to to say
okay I'm going to need to know when I
need to update a swing component if
something changes in Java effects and
vice-versa but before we show you the
strategies we do want to point out to
you that there is a JDK eight option out
there that is experimental but will
combine these two into one API call
where you can update the proper thread
and it it's supposed to simplify JavaFX
swing coding and I believe that is a vm
option it's a vm option that you can
apply to an application and it merges
threads so that the swing thread and the
JavaFX that are the same thread and
depending on your application that may
be a benefit because it a does a limb
eliminate a lot of boilerplate code for
calling platform dot run later or swing
utilities dot invoke later okay so well
you know we we want to show you how to
do it separately so you'll understand
what the issues are so let's do that
besides they said experimental and that
kind of scared us
yeah okay now there are four strategies
that you can use in this world where you
have job effects and swing working
together and here they are if you have
self-contained JavaFX content you know
where you have a top component where you
have just Java FX code and it doesn't
need to interact with swing at all then
this is a very simple thing to do right
because you have everything that you're
gonna do within the Java effects scene
graph and there's not any issues that
you have to know about the second
strategy though is the one-way
communication specifically where the top
component needs to make a change to the
JavaFX scene graph now remember the top
component is a swing based thing and
your scene graph is all job effects and
those are on different threads right so
what you do is there is an equivalent in
Java effects to the swing utilities run
invoke later that you know it's command
in Java effects it's called platform dot
run later and then when you make this
call I'll show you how to do this in a
minute you'll wrap you know what you
have to do into a runnable and then
you'll be on the proper thread which
will be the JavaFX thread in this case
now you might think it's all there is to
it unfortunately there might be some
synchronization issues and we ran into
those and that would be a situation
where you have to have some handshaking
due to timing and we found out a really
cool way to do that and that's with a
countdown latch in the Java concurrency
a API library okay and if you know how
countdown latch works it's like a
semaphore except that you have a
separation of of a countdown and a wait
so you get a handshaking that's going on
there and we're going to demonstrate and
show you the code for how to use that
because in some cases where you have
one-way communication you might you have
to use you might have to have some
handshaking with a wait there and we
would suggest using a countdown latch to
do that and we'll show you how to do
that in a minute
now the more complicated one is the
two-way communication and this is what
happened if you have a
Burtie change event to communicate from
java effects to listening top component
code and you know you know this is a bit
more complicated you know we're going to
talk about how we're doing that in our
application but you know for more
information on this you know we're free
refer you to our book and some examples
in there okay
so let's show you some code snippets now
of how you do this this is one that
you're not going to have to worry about
too often and that would be to update a
swing component from JavaFX but if you
do have to do that then you obviously
have to be on the EDT because you're
updating swing so you'll wrap your code
in a runnable object and then you will
call invoke later and notice that we're
using lambdas here that reduces a lot of
boilerplate code so it's as simple as
this so you just say invoke later and
swing utilities and then you call the
swing method and that will run it on the
EDT now the one that you're going to
need the most is this one and this one
is the opposite direction which is where
you need to update something in java
effects from a swing component okay
because remember you know that's gonna
be on the scene graph and that'll have
to be done on the other thread okay it's
not bad right you wrap the code in
runnable and you just call the other one
platform dot run later where the my java
effects method represents something
that's going to change the scene graph
once again when you do that and the
lambda which really reduced the
boilerplate code here right when you do
this that will invoke that JavaFX method
on the JavaFX
application thread all right now that's
a simple case right you know where you
don't have any synchronization that's
going on okay so now what we want to do
is we want to go and show you in our
code how to use the countdown latch yeah
so let's do that okay so what we're what
we want to do is
the family tree is that we're gonna do
this okay okay
all right now I'm gonna explain this so
let's see if you can follow this this is
really pretty easy to do once it's
explained to you okay here's the story
right what we need to do is we need to
call we need to create the scene in
JavaFX by calling create scene they're
in line 79 okay now if Galya Scrolls
down to four create scene there's a
there's an issue in line I think it's
308 or a 208 108 sorry it looked like at
the angles wrong here you can see that
we're and you guys have seen this code
before where we call the F XML loader to
get the scene graph do you see that
we're storing it back into a controller
reference that controller reference has
to be there by the time that we're ready
to use it otherwise we could get a
nullpointerexception if we try and use
that control the reference before it's
initialized so if gale Scrolls back up
now right to here okay remember that
when you call run later what you're
doing is you're scheduling that create
scene call to be done at a later time
and you're going to return right away so
if you just zipped right down to the
point where the controller is showing up
right there
you're gonna get a nullpointerexception
if you don't wait until that is done
okay
so this is where the countdown latch
comes in all right so what you do you
have to scroll up Gil there we go okay
so what you do is you create a countdown
latch from the Java concurrency library
and you initialize it to 1 and then in a
try block where you have the create
scene right
you put a finally block in there and
then you count down on the latch now
what actually happens here is that when
you do the create scene right
you know the your Vil ultimately going
to go down and wait on that latch and
waiting for it to countdown and so
you'll know that when the create scene
finishes the controller reference will
be set and therefore you can
use it when the await returns and this
is the handshaking that you have to do
and you don't have to do this very often
but sometimes you do and we found out we
found that a countdown latch was was
really the best way to do that okay so
we actually have enough information now
and to have conveyed across to you guys
to ramp this whole thing up now and show
you some more sophisticated applications
that are built on all of these concepts
that you've learned this morning okay
so what we'll do now if we go back to
the notes is is will bring up the family
tree application yeah let me tell them
about it first okay so what we're going
to do now is we're going to give you
guys a much more sophisticated NetBeans
platform application right now that's
built on all these concepts that that
we've learned all right and here's what
we're going to do we're going to build a
brand new guy now that's going to be a
lot more sophisticated it's going to be
an FPS platform application and it's
going to have a database it's going to
be implementing a full create read
update and delete model you'll not only
will you be able to work with persons
but you'll have events and you'll have
timelines we're going to use Java
effects and animation to make it
appealing to the user we're going to use
JPA and java DB for persistence we're
going to have all the database access
performed in background tasks and we're
going to integrate java and swing
together and enhance the whole user
experience now like I said what you guys
might want to do if you're interested in
this program is you go and download it
from Java net and take a look at what we
did here and we'll give you all the URL
for that when we're finish up here okay
so at this point let's go and open up
this family tree application which is
really a real application now because
we've been doing a lot of toy stuff up
to this point but it's going to be using
almost all of the things that we learned
about this morning so go ahead and run
it Gale here it is
splash screen right very easy to do in
the NetBeans platform family tree okay
and here it is it's kind of yeah scrunch
together isn't it boy okay alright so
right off the bat you know we're using
some reflections up there on the title
we have some icons that were showing and
let's see maybe you can just walk them
through really quick about what it does
I wanted to just discuss a little bit
about this program in terms of what
we've learned about the NetBeans
platform and maybe things that we
haven't been exposed to yet but what our
approach has been is to use Java effects
where it seems appropriate where it
seems easy and keep the NetBeans
platform features where that is
appropriate so for example on the left
side this is an events viewer window and
all these people are stored in a
database and they are all related to
each other by events life events except
the course Abraham Lincoln he's not
related to any of these people but Homer
and when I click on him okay let's said
let's do this kind of float it yeah yeah
probably good thing we do
there we are so when I click on him he's
all of his life events appear and I can
this events viewer window here on the
left does not use JavaFX at all it uses
the NetBeans platform nodes API and
explore views API is a very flexible way
to present your model so I can expand
this there is Homer's parents and I can
click them like expand this there is
Homer spouse and he's got three children
and they're each there and I can
actually expand Marge again and her
events appear here and expand marriage
and as you can see we can just go on and
on or not so what what I want to have
you take away from this is that
sometimes it's better to use the
NetBeans platform features which is the
nodes and API but the this timeline here
that's JavaFX the Welcome window here is
JavaFX am i showing them any of the
animations yet yeah you know what let's
do that because we won't have time to
show them our charts program too
yeah so let's show you a little bit of
the animations that we're doing this is
the Welcome window and this is an
example of one of the communication
strategies that I was talking about
where we don't have to communicate with
swing at all right everything's
self-contained right so let's deal yeah
if Gail just clicks out here right now
you'll see all of the family disappear
that is all done well do it again you'll
see them all disappear in parallel right
with a fade transition out and then they
all come in with a serial transition on
anytime when it one at a time okay and
this is all Java FEX very easy to do and
there isn't any interaction with swing
because this top component window is
just FX face there's also Mouse stuff
too right because you know when Gail
puts the mouse over one of the icons you
see it scale up in the scale back down
this is called a scale transition okay
and these are all job effects
transitions and animations that make
make things very nice same thing down in
the timeline window right if if gale
goes down with the mouse here and puts
it over Homer well you get homers icon
and you get homers each of the
individual events so if you want if you
were talking to someone and you wanted
to highlight something look at this
child and then you can put it over the
text and that will get bigger too right
so these are all animation techniques
that are very easy to do you can put
them into applications like this and it
gives a lot of rich user experience for
people but the timeline window obviously
does in interface with the other
structures of this application whereas
the Welcome window is a standalone just
a fancy little window but the timeline
window is sensitive to selections so the
top component here will have a selection
listener and when you change the
selection in the events for your window
or even in the person window the
timeline window responds to that and and
then the top component has to call
JavaFX controller methods to update the
displayed person because this is a
JavaFX
display okay good so we've got a few
minutes left here on before we wrap this
up let's show you our other program and
so Galle is going to close this one now
and this is going to be another
sophisticated NetBeans platform
application that shows you how you can
leverage Java effects and swing together
so gales going to close all these things
and then open up our charts program and
this charts program is something that we
showed it at JavaOne a couple years ago
and we thought you know we throw it in
here too because you guys could see some
of you guys probably didn't see it and
you want to take a look at another nice
application that of using the NetBeans
platform with swing and Java effects
together another splash crane that you
just saw now one of the great things
about Java effects is it has charts all
built in all free ready to go ok so what
we did was we took smartphone data sales
out there it's got off the web
and we implemented all nine of the
JavaFX charts in separate top component
windows
you know once again very easy to do
because we showed you guys how easy it
was to put JavaFX code into a top
component so we have a pie chart for
example when gail selects a year you'll
see the pie chart change using
animations and that's done by default by
the charts package okay and then if she
goes in the middle to where the bar
chart is if you can do that yeah do it
that way that's good and maybe you can
spread it out so you could get enough
there I'm really being challenged yes
this is pretty pretty crazy here it
looks maybe you can get it can you get
it to show can you float it yeah let's
do that and make it make it bigger now
this is another nice thing there we go
okay this is the other thing that we did
very easy to do in FX is when you look
at a bar chart you know I wonder what
the number is because you have to look
at it and tilt your head and so what we
do is we put in the numbers and orient
them so that they fit inside if they
don't fit inside we put them up above
once again you know you might want to
take a look at our program here to see
how we're doing all these things because
FX makes it very very nice and that's
good right
okay let's let's can be redock that and
go back to the regular program here get
that pie chart bigger there we go
and it's getting all contorted isn't it
okay all right now one thing I didn't
tell you is that in the bottom here that
is a swing J table in that top component
so we actually have swing down below in
that table of data and then all the
other top components are FX and gail can
go down there and edit that swing J
table in fact she's going to put a
number in there and you know it's going
to happen all of the charts all nine of
the charts completely update with that
new data so once again you know we've
got bindings setup in here and we've got
it all wired together so that these we
these windows are talking to each other
and we're using those communication
strategies that you saw earlier yeah
Mike no right that the all the chart has
a dependency on a on word how to get the
data but and then they have listeners to
respond to changes in the in the data
okay and we have one more thing to show
you if Gail clicks on one of the wedges
in the pie chart it not only tells you
the percentage but you know we have that
little animation that's going on there
too and this is a great example of you
know using binding right to calculate
you know the percentages and also the to
translate and move the wedges there too
and if she clicks on one of the bubbles
in the bubble chart we do some rotates
this is all really really easy to do in
FX because charts are nodes in a scene
graph yep and a node in a scene graph
can be animated can have reflection and
you can get the individual nodes from
the charts out and do things to them
okay let's go back to other notes and
we'll take questions in a minute let's
go back to the notes and wrap this up
and then we'll take some questions first
thing I want to do if you go keep this
go to the summary yeah we're on to do a
quick summary of everything that we did
here yeah okay there we go we just did
the charts okay so what did we do this
morning we showed you guys the benefits
of easing the NetBeans platform a very
rich stable modular framework with built
in winds windows system in service
providers in action frameworks we showed
you the values of using fx4 as a rich
Google GUI approach with bindings and
animation and how easy it is to
integrate into the NetBeans platform and
then we discussed techniques for
communications with threads and keeping
the the swing and the JavaFX code
isolated okay and so we're ready to wrap
that up we want to thank everybody for
coming here's how to contact us emails
and Twitter if you if you want to we'll
leave this up as we do the QA but this
is where the zip file is for the code
that you saw
and remember that the family tree app
that was the one with the Simpson family
that's the one that's going to be
available on java.net and you if you go
to that URL it'll tell you how to access
it and also how to configure the
database that goes with it because it
has a database there's the last slide
we'll put this back up here in a second
we want to remind everybody that we do
have our this is what you saw today is
in our book that just came out using
Java effects on the NetBeans platform
yay you 900 pages but it's not a real
thick book right but yeah there's a lot
here here it is yeah yeah our editor is
using special paper because we're you
know well actually it got to be 900
pages because Girton kept saying oh you
got to put this in you got to put that
in and by the way Girton wrote the
foreword thank you very much for our
book that's 500 pages right there yeah
and then and when you read the foreword
you find out about the dude so you know
do that right so anyway no no no how
much book signing yeah so we have a book
signing if you're interested in picking
up the book we will be at the digital
guru bookstore tomorrow between 3:30 and
4:00 we'd love to see you if you come by
and now what we'll do is let's put the
code back up and we'll take some
questions we've got a little bit of time
here left yes yes online yes that
through Oracle's website okay yeah go
ahead
can I couldn't hear you
rain checking oh right um I don't I
don't know what you mean well I mean a
library I mean for validations Oh for
like like on on a form Oh we'd like you
would do in JSF for something oh I see
well I mean we just if if if you want to
do anything like that you can you can
put it either an event handler or in a
computer so if you're just doing binding
right I see where I see where you're
coming from then if you're just doing
like bi-directional binding then you'd
have to have your validations somewhere
else okay that's a good question yeah
next question okay that's really a
question for Oracle the question she's
asking is do you think that FX will
replace swing no it's not this is not
the point of all this the you guys have
written a lot of legacy swing code out
there and no one is asking you to throw
it away what we're saying is is that
what you can do is you can keep your
swing code but you can add effects to
your applications and make them work
together that everything is a pretty big
word okay
some of the developers that I've talked
to you know swing has been around for a
really long time and you know that you
can get down to a very low level in
swing to manipulate components and
layouts can you do those kinds of
low-level operations and JavaFX yet no
but you will be able to and what's
happening is and this is the reality is
is that Oracle has has telling everybody
that you know eventually you should move
to swing I mean move to the FX from
swing because swing is stable Oracle is
putting their resources into FX they
will continue to add
to the toolkit to make it behave like
like swing but you know at this point
right now you know it's true that you
can't probably do everything in FX that
you can in that way don't you will be
able to Java effects relies on GPUs
graphic processing units and is as grass
graphical processing units become
cheaper and faster
JavaFX will you will see that
improvement so you able to be able to
use Java FX on smaller and smaller
devices where I don't think swing can
make that transition yes
ah got you know deploying it to the
cloud I are there is it for the NetBeans
platform are is are there some plugins
that help you deploy to the cloud Girton
do you know because because it's a
desktop application you know it's not a
web thing when you talk about Java
effects are you talking about the
NetBeans platform yeah yeah so he's not
talking about that okay okay yes I mean
there's uh I don't know the details but
there's there's a way to to deploy Java
FX so you can get it off the internet
yeah so that's why I how about that late
we haven't done that yet but I think
you're right I think there is an option
that lets you do that but I think you're
more interested in FX right and putting
it in a cloud right yes people are using
job FX on iOS and Android right yeah
yeah you know talk talk to some of the
job FX like Steve Chen or James Weaver
that are doing more Java FX alone stuff
we've been more concentrating on the
integration yeah
with integration but it you should be
doable but you want to talk to some of
those guys about that yes
I mean like just drop me like dropping
the swing app completely and moving to
FX well I mean we if you could do that
and and tolerate the you know the
situations that you have at your company
or your product or whatever it is that
would be probably the best long-range
solution for you to do because you you
don't I mean the one thing that swing
and JavaFX share is that neither one of
them has an application framework built
around it so if you need any kind of an
application framework I mean the
NetBeans platform gives you modules and
I know that jigsaw will have modules but
that's still at least a year away you
can have modules right now with if those
types of things if it's sophisticated
desktop application you're there's a lot
of features that are going to be missing
if you only use Java effects but you
know that's a decision so if you want to
put your programming resources into
building menus and action frameworks and
things like that then you can do
everything in Java effects but you're
going to be spending a lot of time doing
plumbing code right ok we have time for
one more question any any others though
ok yeah over here
no we haven't really we've been
concentrating the question was have you
done any performance metrics comparing
swing and Java effects we haven't you
know we've been concentrating more on on
integration techniques and designing it
just in casual observation the startup
time for job effects seems slower than a
startup time for swing so if I have a
those two standalone applications the
swing comes up much faster than the Java
effects but in Java effects you can do a
lot of complicated UI stuff very you
know the animations and things like that
that I I mean I don't do animations in
swing but if you did I would think that
that would be more of a performance
issue so it depends on what you're doing
ok all right we want to thank everybody
for coming
and we'll see you guys around the show
thanks a lot</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>