<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Modular Java Platform and Project Jigsaw | Coder Coacher - Coaching Coders</title><meta content="The Modular Java Platform and Project Jigsaw - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Modular Java Platform and Project Jigsaw</b></h2><h5 class="post__date">2015-06-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/iAHII3Us03k" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Mark Reinhold and this
session is an update on our work on the
modular Java platform and project jigsaw
so I've given an update every year as
some of you know that we've been working
on this project for a while this year I
thought it would be good to focus on the
more immediate impact of the changes to
the platform that we're working on the
more immediate impact they will have on
developers so rather than talk about you
know what a module system is and how it
should work and and and how it's all
implemented I'm instead going to going
to focus on the benefits as well as some
of the costs because I think those but
both of those are much more immediate
interest than details about a model
system so amongst our goals our three
main goals it with with jigsaw are to
improve the scalability of the platform
this is all part of the the long-term
effort to converge the Java ME and se
platforms improve the performance of not
just the platform but of applications
running upon it and also to improve the
security of the platform let's take
these in turn every implementation of
the SE platform is is a big monolithic
thing right it's always been delivered
at it's always been specified as a
monolithic thing it's always been
delivered by every implementer as a
monolithic thing and this doesn't work
so well when you're trying to fit it
onto a small embedded device now these
small embedded devices have you know
they've gotten big enough that yeah you
actually can put a full se on something
like a raspberry pi but as embedded
devices go go's a pie is actually fairly
large and static footprint is a a major
concern for for people who are designing
a device that's going to be manufactured
in quantities of hundreds of thousands
every every every penny matters
so they prefer to keep things as small
as possible because they need room for
Java manager for their application and
data and and whatever else you know so
so there are limits it doesn't suffice
to say oh well here your here's your 54
megabyte JRE just stick it in there and
you'll be fine and that's kind of where
we are today the the base JRE for Linux
our clocks in at 54 megabytes you know
and that's and that's with some stuff
tossed out that's with a special
configuration configuration of the
hotspot virtual machine that has only
one garbage collector 21 runtime
compiler very limited serviceability
features so you know some other things
left out but that's the full Jerry with
you know JavaFX and swing and duck top
and korba and everything else and it's
often not confused so that's often going
to be a lot more than you need so in se8
we have made a first step towards
addressing the scalability problem since
we weren't able to deliver jigsaw n8
we've got the sort of introductory baby
step and that baby step is to default is
to divide the platform into a set of
profiles so these profiles are there
it's it's basically like an onion right
we've got a a profile at the bottom
which we call compact one it it has not
a lot of stuff in it and it clocks in at
about 11 it's 11 megabytes for a Linux
aren't building so if all you need is
the basic stuff in Java lying io util
you know TLS and some logging few other
things contact one is all you need above
that we have compact to note that not
the creative names one you can guess the
next one right so compact two adds a few
useful things it's got JDBC and our mi
and Jack's p so if you need to do XML
processing or talk to a database then
then compact to is
one for you compact three that's right
come back to is 16 megs compact three
add some more stuff instrumentation
authentication naming jdbc rosettes the
compiler 8di xml digital signatures
prefs cut a few other things that aren't
on here and compact 3 is 30 migs and
then everything else well everything
else that isn't a tool everything else
is part of the JRE fits in this 54
megabyte circle
so with profiles we have a layered
platform and that that certainly helps
but it doesn't go far enough for our
goal of having a truly scalable platform
you know this this this is it's a
band-aid it will helps to help some but
it's not a great solution suppose you
want to write a you know some sort of
graphics application that's going to run
it an embedded device and to do that you
want java sa javafx are a mike is going
to do some sort of communication and and
not Soren because you want to script it
well to do that you you you're stuck
with this 54 megabyte monolithic Beast
which includes all sorts of other highly
useful things like korba jax-ws can
detect WS and swing and awt which you're
not going to use and and other things so
that's that's not very good so this is
this is where modules come in at force
rather than having layers of the
platform let's divide it into modules
that you can more more or less picket
pick and choose as you need so there the
names I've shown you already are our
modules I'm here I'm filling and filling
in the rest of them and we actually have
this modular ization of the jdk working
in our prototype today the very bottom
is is the base module that's the one
module you always have to have it has
java.lang.object in it but a bunch of
other stuff TLS logging of the scripting
API are are broken out as separate
models so that the base module is a
little smaller than the compact one
profile not a lot but a little and then
all the rest of these things are
freestanding modules now with one of the
nice things about profiles from a
conceptual standpoint is well they're
just concentric layers just these rings
right the relationship between any pair
of them is is very obvious with modules
we we have to do something more
complicated because in general you know
the models don't layer like this the
relationships are more complex when
module cans opinion here the in general
will depend
on one or a few other modules so rather
than having a layered thing what we have
our modules every model contains some
number of API packages and every module
depends on one or more other modules oh
they're the jdk volumes by the way so
the tools are outside the very so what
we've got is a mapa graph
so there are about there about 40
modules here I don't know if it is 60 or
60 or so edges and the way the way this
works is when you know you need a couple
of modules to figure out what other
modules you need you need to take the
transitive closure of that initial set
in this graph so to continue with our
example if we've got javafx we want
javafx we want our mi we want osborne
that's easy enough and now we need we
followed the edges and go down go down
to base and figure out what are the
other modules in the transitive closure
well RM is going to drag in TLS and it's
going to drag and logging and nas horn
is going to drag in the scripting module
and of course the base module is always
there because it's the one you can't
live without so that's all we need for
our hypothetical application and
everything else just falls away poof
Scott
so that's all well and good it's
reasonably simple to understand the
question is how how do we make how do we
make this happen how do we how do we
implement this or in other words what is
the developer experience that you see
well what we've done in our prototype is
we've deliver the JDK when you do it do
it do a jdk build in the jigsaw
prototype you get a pile of files with
the j mod extension we call them Jai
Mata files java modules there there zip
files like jar files are we didn't call
them jar files because they usually have
some native code to them and in jar
files there's no standard way to talk
about native code so you know it's just
it's just a different format it might
not be the final format but it's you
know it works well on it for now so
we've got Jai Mata files one for every
white one for every module comprises the
both the whole JDK we want what we're
trying to do for any particular
application is is take just the modules
that it needs and take those 3mon files
compose them into a custom runtime image
it looks a lot like a standard Jerry
image it's got a bin directory in a Java
command in the lib directory with a
bunch of stuff in it right but it only
has the stuff that you need it doesn't
have one giant art dejar with the entire
world in it and a bunch of other cars
that have the rest of the world in it so
we want to transform some code in one
format basically into code in another
format now many programming environments
have a tool for this Java so far has not
had a standard tool for this so what
should we hear what should we call this
tool any suggestions
huh yes it's time for Java to have a
linker so we have a new command called
j-link creatively enough you tell j-link
what modules you need it does that
computes the transitive closure spits
out a custom image example of a command
line is here so jailing takes takes us
dash mods option continuing with our
hypothetical example we want javafx rmin
as horn we tell it HD destination is
some directory dollar JRE run it and out
pops a Jerry and then given that we can
run our appt FTR appt de or whatever
other arguments it has with our custom
Jerry now as a development time tyty may
it be kind of clumsy if you had to go
through this step every time you wanted
to work on your app that's only going to
run on a limited set of modules so to
make development easier we're also
adding the dash mods option to Java C so
Java Sea when it starts up if you give
it that will do the same transitive
closure computation or logical graph and
configure things so that the classes
you're compiling will only see the
classes that will be available in the
custom runtime image later similarly
whoops you
all right too many
similarly you can you can give the mods
option to the regular Java launcher so
if you have the Java launcher for the
full JRE but you only want it to run
with a limited subset of the module
graph you can do that in exactly the
same way when you run a PR it will only
see the classes in those modules and in
the transitive closure of those modules
okay
so let's talk about performance so
performance in in Java today is is it
pretty much depends almost solely upon
your runtime the virtual machine at
runtime and there you know many and
engineered decades of effort have been
have been poured into making java
virtual machines run well and do all
kinds of clever things at runtime but
doing doing things at runtime you it's
limited you can't do arbitrary
computation because then you'll slow
down the program so there's always this
tricky balance when you're working on a
Java Virtual Machine of oh I'd like to
do more analysis here but I can't do too
much because that will impact the
program and so forth and there are some
things we'd like to be able to do that
could really speed up performance that
just don't don't fit it among them are
faster class look up yes it is possible
to cash in to look at a class path
that's got a hundred jar files on it
cash that and and cleverly used later
after checking files time time stands
and things but it would be far better if
we had some digested form of the applica
of an applications classes so that we
could just build a fast be tree and be
done with it aggressive in lining in in
the early days of Java there were there
was actually an option on Java see that
would do a little bit of optimization
that was sometimes useful when the only
virtual machines were were straight
interpreters but those optimizations
were they were kite there were kind of
confused and ultimately when we had when
we got them having modern VMs that
compile the native code they were they
were unnecessary but as as the platform
has evolved we've we've reached a point
where it's useful to think about
inlining again not necessarily in Java
Sea in fact Java Sea would be the wrong
place to do it but sometime before
runtime enlightening is especially
interesting for lambdas there are that
there's some straightforward inlining
optimization
that we could do for lambdas across
across classes even the it between an
application class and a platform class
that will make lambdas consume less
space and and be faster to create so
that's definitely something we'd like to
do another one is ahead of time
compilation there been you know cert Sun
slash Oracle we've done experiments with
with a ot over the years it's it's kind
of tricky to get right in one of the
reasons it's tricky is well where do you
put the native code you don't go stick
it in the Applications jar file or
somewhere so you wind up with some
complex captions game and it is good to
confused another another scenario where
ahead of time compilation is interesting
is on devices like this it has a piece
of fruit on the back devices like this
where you actually aren't allowed to
have a jib so running interpreted well
yeah it works but it's kind of slow but
if you could compile your Java code
ahead of time and ship native code into
the App Store package that would be a
lot faster jvm specific memory images
there's the VMS do a lot of work to
parse class files build up internal data
structures and say several of it will
certainly but both of the the more
significant virtual machines have the
ability to predigest some number of
usually a system classes sometimes user
classes and build the memory structures
dump them out so that the next time the
vm starts you can memory map that file
in and not have to build them all up
again let's get this can improve starter
performance significantly but it's you
know it's something that you find with
to get to you need done to use a bunch
of non-standard options and figure out
where the file goes and and it's it's a
little tricky but if we have if we had
some way of talking about a Java program
at some intermediate stage between
compile time and runtime you see where
this is going
then we could make one of these and
finally if you really want to be
aggressive we can do outright removal of
unused fields methods and classes so
this is actually an old old idea was
done in Lisp systems in the in the 1970s
but basic idea is look at the
combination of an application and your
and all your platform classes do a bunch
of static analysis and if you if you can
determine with high confidence that a
method or field or an entire class is
never used throw it out now with the
language like Java it's a little tricky
because static analysis can't figure out
everything if if you do if you do random
things like construct strings and then
use reflection to go find the class that
was you know that's named whatever that
that resultant string was then it's
impossible in general to do that kind of
static analysis but a lot of programs
never do that or they do it in
constrained ways where maybe we could
invent an annotation so that you could
tell the static analyzer yes I'm
constructing a string here and username
reflection but it will only ever ask for
classes in you know these three packages
or something so you know this is this is
fairly aggressive but but it's actually
it's kind of the ultimate way to get rid
of stuff you don't need
so how do we do this well we already
have a pipeline here where we take
classes we transform them into another
format for execution so let's generalize
the linker the linker can take
application jar files heck you can even
take class files that's more convenient
it can construct an image custom Jerry
like it did before it can constructs a
JVM specific image that doesn't it
doesn't contain the JRE but it's that
memory dump that I mentioned that you
could then run on a full Jerry that you
already have installed we can also
generate other things we can I mean heck
if if J link is going to do something
like static inlining then we could just
use it as a transformer from jar files
to jar files right and we can even use
it to create the J mods themselves and
that's that's ultimately our plan so by
introducing the linker we have this
general purpose transformer that runs
between compile time and run time lets
us do some optimizations they're too
expensive at runtime and those
optimizations can look at the whole
combination of your application and the
system and do up and optimize across
that boundary rather than just being
moved into looking at one class or or
method at the time or 11 type hierarchy
at a time
okay here's a command line kind of the
obvious thing j-link gosh mods give it
def sleepy option where's your
application jar it makes a custom Jerry
and then you've got a launcher in in the
Jerry's bin directory called a / or
whatever in them because it runs you're
out you can't run anything else but you
can run your out similarly jailing could
to make a java java application image I
just invented this extension will
probably it'll probably wind up being
something else and and you know this
thing is very much
implementation-specific you won't be
able to take a java application image
from the works with one version of
hotspot use it with another version of
hotspot you certainly won't be able to
use it with a version of j9 is like you
know it's specific to the vm that makes
the image that you change your vm you've
got to make another image and that's how
you run it all right so we can scale the
platform we can improve the performance
of application of the application the
platform combined but you know there's
there's no gain without pain so the pain
that that we're going to have to put up
with in order in order to get these
benefits among others in our that we're
going to change the structure of the
Jerry runtime image okay that that
structure has has not really changed
since Java 1 dot to at least for the
Jerry's and JDK that son and that and
how oracle should
that structure has included among other
things a file called RTR and a file
called tools jar variety of other jar
files and properties files and things in
order to make this up the scalability
and optimisation story work those are
going to go away so if you have code
that looks in you know Java home / lib /
Jerry or Java or travel home / lip /
tools jar it's not going to work now
would be an excellent time to go find
code like that or find libraries you're
using that do that perhaps without even
you knowing about it other things will
change in the structure of the runtime
image our current thinking is it looks
look somewhat like this there will be a
bin directory as there is today that's
where you know launchers and executables
will be we're going to move user
editable properties files of which there
are quite a few currently in the lib
directory we're going to move those into
a separate comp directory so that is
very clear what is meant to be user
editable and what is part of the system
that you shouldn't touch will will
continue to have an EXT directory but
we'll move that up out of the lib
directory for the same reason well
having an include directory for the dot
e trials if you need to compile native
code the lib directory will continue to
exist it will have our architecture
specific s 0 files as a files for the
virtual machine or empty ll if you're on
Windows and the lib the lib directory
will have a module some dirt
subdirectory with you know the stuff in
it for Matt TBD but whatever that format
is it's not something that any
application should ever rely on because
we will we will evolve it over time and
we will not be shy about doing so so it
is not a it is not a committed internet
okay so every with me for every benefit
there is a cost all right let's switch
to and talk about security as most of
you probably know security has been a
bit of an issue for the Java platform
recently we've done a lot of work people
throughout the community I've done a lot
of work in the last year year and a half
to make the platform more robust to make
it more difficult to attack with the
modular platform we have an opportunity
to implement some defense and depth
techniques that we that we think are
very important let me explain what I
mean if you look at the base module is
these are all the API packages in the
base module well all but a couple that
didn't fit there's a bunch of stuff that
you that you more or less expect okay
we've got all these java package yeah no
no not some java x packages you know
these are all specified in in JCP
standards you know they're there
obviously they're supportive there's
something that you can use there are
also some things that are outside the
scope of JCP specifications and they're
generally not meant to be used by
applications you know all kinds of stuff
a lot of it's under the Sun the Sun dot
prefix here's the reflection machinery
some security stuff networking protocol
handlers you know there's jigsaw itself
sundog invoke has has some stuff for in
both dynamic various text resources more
security stuff various utilities and
probably the most popular one is the
famous Sun disk which has some cognizant
unsafe in it
which lets you do all kinds of magical
stuff so to make a long story short much
of the Java platform the Java platform
is the stuff that just starts in in Java
right or Java X it stops there all the
rest of this is implementation of the
platform it's not part of any of a
standard spec it's not code to any any
any application or library should ever
use and it's also be because there is no
way there has been until now no way to
protect it the fact that all of the all
of the public classes in these packages
are public and you can go use them it
has been part of some of some of the
security issues that we've had to fix in
the last year and a half you know
they're there were some some issues in
in sudden vote for example that you know
a clever hacker could exploit in
combination with a couple of other
exploits in order to get get get the
running java code out of the sand box
inside a browser so we want to beat this
up now we've we've kind of you know
point patched as many as many of these
these things as we can find but what we
have to do better one of the reasons
that the current system is so brittle
you know as I said there's there's no
way to you know to really protect these
things and prevent them from being
exploited there is a mechanism for doing
so but it's it's it's tricky to use
because there's been no way to have a
kind of protection at the vm level
there's a method in the security manager
class called check package access check
package access is a method that should
be invoked by security sensitive code in
order to check that the code base on the
running thread it can actually access
that package over there
so if you're if you're running code in
the sandbox and and everything is is
implemented correctly in the platform
check package access will be called
every time you try to do something like
use reflection to get hold of you know
son mis gun safe when you're running in
the sandbox the problem with the
mechanism like check package access is
it's a method that has to be called
anywhere in the implementation of the
platform that might do something like
that and guess what sometimes it
sometimes we forgot or sometimes it was
invoked incorrectly and that's that's
where some of these vulnerabilities have
come from so we need something stronger
than that well gosh if we have a module
graph we have a basis for doing
something stronger we have about we we
have a we don't have about boundary
around these modules but we can make one
each module for each module we know what
the packages are that's in it if we
extend the definition of a module to say
well these are the packages in this
module and this subset are the packages
that are available for other modules to
use and optionally by the way only those
only these three named modules are even
allowed to use me nobody else is then we
can make the entire system much stronger
so what we're what we're thinking of in
particular is is implementing and
basically doing away with check package
access as a method and security manager
it'll be deprecated it'll still be
around but it won't be used in the JDK
implementation anymore instead every
module will be well defined and we'll
use a low level access control mechanism
in the virtual machine to enforce those
boundaries and alan has already
prototype this it's it's it's
essentially the same mechanism that
keeps a private method or field private
you know
it's implemented in one place in the VM
it's not code that's that's scattered
about that always has to be invoked
correctly it's one place easy to verify
and also easy to make fast so that's
encapsulation in other words
again there's there's no there's no gain
without a little pain and a pain as you
as you probably figured out is all those
sunglasses all of these packages that
have the word internal in their names
and and a few others are going to go
away now there are a fair number is if
there's a quite quite a lot of existing
code out in the world that reaches into
these packages and uses them about a
year ago Mandy Mandy did cloned maven
central and looked at all the artifacts
and constructed a lovely list that's
quite long of all the internal things
that the libraries and maven central use
now some of them are things that weld we
should have made those into you know
public classes part of the platform
years ago and in in Java 8 we've
actually done a few of those base64
encoding and decoding like why wasn't
that just part of the platform and in
1998 I'm not sure but it so as a result
people went and used son mis got base64
or whatever with me affordable api's but
in Java a we now have you know actually
well designed one that's part of
platform it's in India I oh and it it
works so we're going to we'll keep going
through Mandy's list to find internal
api's that are more like oh ok that's a
utility class looks like a lot of people
are using it it makes sense to have a
public supported version of that in the
actual platforms back but there's going
to be a lot of stuff that doesn't fit
that I mean there there are libraries in
maven central that reach deep into the
guts of the XML parser now I'm sorry you
know that that is just not going to work
anymore if you need to reach deep into
the guts of an XML parser then you need
to carry your own
so you know I I have I've no sympathy
for people who have written libraries
that do things like that you know I do
have sympathy for people who use
libraries like that without necessarily
knowing that that happens but in order
to to move forward we're going to have
to do this and and there what there will
be some pain associated with it I'm
afraid to make it to make a little
easier to predict that pain we've put a
tool a new tool in in jdk a it's called
jade eps mandy wrote that you can point
jaidev set an existing application jar
file or like a library jar file whatever
and we'll go and analyze all of its
static references and and and give you a
listing of any internal platform classes
that that code is using so you can be
aware and and plan ahead and go and fix
it well well ahead of time okay so
that's that's the big story scalability
performance security I think now we're
going to try to do a demo of the basic
function at functionality hopefully the
demo will crash so let's switch to that
demos never crash huh get this mic on
could we get the table mics on this one
all right so so Marcus are shown and
some of the pain that might happen with
the code that is using some misc so i
think i'll start off that's okay well
with that and I also showed jdubs okay
you hear me now alright so I'm going to
start off looking at an application that
is e is where someone has been lazy in
this case me and is using a son that
star API in an application and I've
actually modified and just the one of
this one of the swing applications the
notepad application I've modified the
Save button so that when you attempt to
save a document in there it actually
attempts to save it in Bay 64 format and
it's using some misc base64 encoder so
what'll happen is is is is that in art
and when you're running with normal JDK
one all the way up to well one dot to
all the way up to seven then it just
works as normal but when I run is here
because of the new access control or
that we've prototyped that mark talked
about is we will now detect that someone
is actually trying to access something
that's internal to a module it isn't it
this is not an a this is not a supported
API and so I've repackaged up the the
notepad application i'm going to run
data eps first so this is the tool 'it
is in jdk age which does the static
analysis i'm going to run it on the on
the on the jar file and will quickly see
what the dependencies are that this jar
file has so this is this is this is
using it as default mode where just
prints out at the package level what its
dependencies are and so this sowed so
when we see down here I'm highlighting
it son mis is used and its flagging it
here as an internal API in RTR and so
this is I can tell now that this is this
this is this is going to be problematic
and we can get more detail on this this
this this tool has lots of different
options for getting em any amount of
detail I can look at things at the class
level and idols
scroll back up here and I can see that
there's a class in here called no pet
open action one is clearly an inner
class and it's using son mis base64
encoder so this is useful to you have
this in jdk today so you can actually
give it your classpath and quickly
analyze what your dependencies are okay
so let's go and just run this and see
and see how how it works and I'm a user
of this application I don't know that
it's using some misc so and we will run
it the notepad starts up as normal I'm
going to type in something here and now
i'm going to try and save the document
and boom something has happened behind
over in my terminal window I'm going to
flip back to this and what's actually
happened here is we've got an illegal
access error on the awt event read
because we're using if you look at the
exception it says this class here no pad
save action one cannot access its
superclass some misc base64 encoder so
in this class here we've gone an
extended Sun misc base64 encoder and now
my application actually failed so this
is part of the pain that mark was we're
showing on the slide up there so so this
is this this is why it's important to
have tools and understand what your
dependencies are to see that you're not
using any JDK internal api's just to
mention again that that exception came
out of the virtual machine from a very
low level of there was no java code
involved sensing that that exception
should be thrown it was
the vm so incredibly difficult to get
around if you're an attacker this is
this is a jigsaw prototype so that's
right what we're talking about here is
something is prototype 449 future
version of Java but the tool I show
there Jade EPS is in jdk so you can
actually looking at your applications
now and to see what their dependencies
are and prepare for some of this pain
okay so there's a em let's see I can
show you the jail in command and
generate you a custom image and which is
just as a number of modules in there and
I can also run I can actually run java
and actually restrict the set of modules
that we have on the run time so that no
pad won't even start up so maybe I
should first just just run a command
here list modules so the this is this is
a prototype runtime where where the
entire platform is is a set of modules
and I'm just using Java list modules
ignore the details of the option name
i'm sure this will change over time and
what we actually see here is all of the
modules that that are in this runtime
there is a java compact one compact to
compact 3 these are essentially
aggregator modules that correspond to
the profiles that Mark showed in some of
his earlier one of the early slides and
then there's all these other modules
here that that that make up at the GRE
and then J and the JDK so when I'm
running when I'm running java here as
normal and around that notepad
application these are all of the modules
that are available to me at runtime I
can restrict that list and so we have a
prototype Josh mods option where I can
just attempt to run the notepad
application just as if I was running
with the minimum runtime and compact one
what will happen there is it'll it'll
look at what compact one is figure out
what is what all the transitive
dependencies are and set up the run time
so that you have only access to those
modules so I'm going to run here the the
notepad application again and what
happens is it fails immediately a
start-up because this is
swing and awt application and is
attempting to access and java.awt
component I am at startup and fails
because we've restricted that we've
restricted access to everything that is
that is that is not part of compact one
and its dependencies so very very simple
okay and so that's that's what I should
actually do here is is there's a dessert
just just to make this one a little bit
clearer I can actually run with a
verbose mods option and this causes it
to print out what modules are actually
accessible to this application in this
case the compact one is an aggregator of
the modules that makeup compact one
which is the base module logging
scripting and TLS so that's that just
gives you a quick look at what modules
are there ok we should run on the jail
in command now and just just just to
generate a custom image for for this for
this application so I'm going to use
this the jail in command this is just a
prototype m and M command it's not doing
the whole program optimization that mark
talked about earlier on doesn't have
many of the it's it's it's really just
about building a runtime so I'm gonna
run the jail in command and I'm going to
give it some options here last path i'm
going to run with the notepad jar i'm
going to call it and i'm going to call
it nope i call it app and it's going to
run the the notepad class i'm going to
generate it as an image so this is what
this format command is yeah ok we will
fix that one thank you and we're we give
it the list of modules start that we
want because this is a desktop module is
using swing and awt i'm going to say
that the runtime is going to include the
desktop module and again this will just
run the resolver generate the transitive
dependencies we know so to figure out
exactly what modules the desktop
requires and we will call it
app and I will just call it my image for
now because it might be confusing to
call it app and an image called app so
we'll run J link this is now generating
me a runtime solely for my application
and that's that's running now and just
like the command on marks and slide a
few minutes ago in the bin directory
it's generated me now a custom launcher
for this application so when I run it it
starts up the notepad application that i
had a minute ago so this is this this is
not the full GRE that's in here this is
solely just the runtime that has the
desktop module and its dependencies I
can generate another image in a few
minutes that has has less modules and
you can see that the generated runtime
is going to be much smaller just look at
the size of this one here just to see
what its size is this one is generated
this is this is on Mac it's not the same
figures that mark talked about earlier
with Linux arm so this is this is this
is that this is Intel and 64-bit so it's
a larger image so it's generated a 40
mega mega byte image here to to run this
application very full Jerry we can
generate it and see because I don't know
offhand yeah and so it just runs that so
we can generate with of with the well
let's get rid of my image and let's do
it with the fall jdk and see what the
full size comes out is full Jerry yeah
and we see what size it comes out it
this is an old machine so it takes a few
seconds to churn through all of the
modules and build image and that came
out of 57 megabytes so we went from 57
to 40 but we can do better than that
wait and the desktop module is huge yes
wait as we modular eyes the platform we
got the swing awt and 2d and it's just a
spaghetti ball so
it's a it's the desktop module has all
that stuff in and I can generate the the
minimal image that you would have this
is not doing an analysis on the notepad
application so it's not going to
recognize that it's using a WT so we
could do something generate something
like the compact one to see what a
mineral runtime is if that's works view
and that one comes out as 19.4 megabytes
but that says this is a 64-bit it's it's
not the 11 megabytes that was the early
set of the full hot spot with with the
server via the garbage collectors in G
yes exactly so it's so but that's just
quick demonstration of jailing that's it
ok thanks could we get the lab mice back
on please
that might thank you so we've got a
little bit of time for questions if
there are any there's all we also have
AB off right here in the same room at
four-thirty if we run out of time now so
so the question is if you're if you're
using something small like a compact one
or just bass do you have any amount of
serviceability like the attached API
that's largely a question of how your
virtual machine was built and that you
know that's something that we we haven't
addressed with Jay link at least not yet
I don't know if and if that's the right
place to do it but you know you can you
can well as well imagine a you know a
delivered entire JDK could have tooling
in it maybe it's jailing maybe something
else that will let you say okay give me
a vm that only has this garbage
collector and this compiler and and and
the serviceability because i want that
too but not the other compiler and then
the other GCS so yeah it's it's kind of
kind of hard to think about well how do
I treat a garbage collector as a module
because it's a completely different kind
of code yeah
so I think the question is how is how do
you create your own modules for your
application that's an excellent question
I think we're actually we're actually
we're actually struggling with that one
and a lot a lot of it boils down to well
if we put a standard module system into
Java to what extent would it actually be
used when you know when we started
working on jigsaw many years ago there
there were there were a lot of reasons
you some of which were specific the sun
for having a general-purpose module
system as part of the platform that
everybody could use you know nowadays if
you look at the general practice well
people build java applications using
maven or Gradle or IV that handles all
the all the dependency management you
know these tools for sure have their
issues but but there but they're broadly
used i know i understand it doesn't
handle handle protection so we could we
could put a model system into the
platform you know I I think from from a
purely technical perspective it's the
right thing to do it's a shame there
wasn't a module system in the platform
in 1998 you know you know all the things
I've described here you know as you
applied you know apply equally well to
application code if you're writing a
large application you know modules
within caps with encapsulation and
dependences you know and well-defined
specifications make total sense and
while jar files aren't modules so if we
put a module system into the platform
you know it's not the sort of thing that
everybody's going to adopt overnight you
know we won't we won't wake up a month
later and find that maven central every
jar file is now a beautiful module and
all of its dependencies are exactly
correct and it's versions are correct
because well guess what especially the
version information in maven central is
almost never right so I think if we put
put it in there it would the adoption
curve would be quite long it would be
five or ten years so you know with your
theoretical sense i think it's worth
doing I'm actually curious to know
from developers you guys is it something
that you want would you actually use it
yeah right right yeah yeah yeah and so
in case you've been following this or
well if you haven't I'll explain it with
a bit of background the first jigsaw
prototype which we started working on in
2008 it actually replicates a bunch of
this the dependency management
functionality we re-evaluated what we
were doing earlier this year and
realized well you know now that was
important for son of 2008 it's not
important now everybody's using maven or
something similar let's say the build
tools do dependency management well
enough let's just let them do it but you
know I agree from a technical
perspective having this this ability to
put boundaries around around code is is
pretty valuable for building large
software systems
yep
I I completely agree pay packages are
too small that the wrong granularity and
packages were never meant to be program
components they were just a way of
giving structure to a complex namespace
organizing code when the language itself
says oh by the way put your go here this
guy can't see it right so it's just yeah
i would i would say i would say that's a
it's a consequence of incomplete
language design in the early days right
it was useful but you know it pretty
much everybody knows that you build a
component that's non-privileged as soon
as you have more than one package you
wind up in situations where oh I want
you know this private thing in this
package be able to talk to this private
thing in this package but I don't want
anybody outside to depend O'Connor
because I won't be able to evolve it and
now you have a problem and sometimes you
can use reflection hackery to keep it
hidden but that's gross technically it's
probably not hard our take is is it
would be pretty difficult to use you
know level friends relationships get
very it can get very difficult to to
reason about when you have a whole bunch
of them having having a higher level
concept of oh here's a module it's got
some packages in it and some subset of
those packages as export it gives you
it's the right granularity for composing
a software system out of components okay
another question
yes
no so super packages were super packages
were jsr was a failed attempt to to
create a module like concept and add it
to the language it was yeah it it was an
intellectual exercise that arguably
never should have made it to be to be in
cacia sorry they're just a number of
flaws with the approach here on the
hedge
so the question is if you've created a
custom image for your application and
then you later realize that oh you want
to you want to download some more code
but it needs a module that you didn't
link in can can you then retro actively
go and add it I think that's that that's
a big open design issue there there's a
lot of simplicity to be had by assuming
that the module graph never changes
after you've linked it on the other hand
there are some times when you when you
do need to make at least minor changes
to it like if you if you start running
your application with some
instrumentation that needs a module that
wasn't you know part of your app so I
suspect we will have to figure out how
to add things to the module graph when
when after linking that won't obviously
we won't be able to do a lot of
optimization but we can make it work I
think in general you know sort of lazily
downloading stuff and and and
conglomerating it is it's kind of beyond
the scope of what we're trying to do you
know if you need to do that kind of
thing then you need something like an
app server you know or rich a lot richer
module system and lifecycle framework
like osgi or or one of the other
frameworks that's around yeah
so the so I think the question is how
would this impact osgi and frameworks
like it hopefully it should you know it
shouldn't impact them at all right you
should be able to have an application
that has you know osgar or whatever it's
just it's just more code you can run it
through the linker you get whatever
platform modules you need and those two
I should run perfectly well on top about
you it would be a bug in this if osgi
didn't run now there's there are
certainly opportunities for having
deeper interconnections between the osgi
module layer and and the platform
modules and there's actually another
project in OpenJDK called Penrose where
there were they've been doing some
initial thinking about that but you know
if we can enable that yeah that's great
too but at the very least I was Jerry
will just work like it always does
always has jailing Tilda Julia
yes they do without having to type job
give it a terrifying yes yeah that's
actually what now I'm demo I mean hear
that that app was a was a native
launcher me it refers to stuff in the
parallel Lib directory so it's not a
it's not a it's not one self-contained
file but you know some of the somebody
you we can push that further and and we
very well might to have allowed a link
to have you know plugins for different
backends so you could actually make a
mac you know d package file that you
could just maybe installed in the normal
way or make an RPM or a Debian package
you know that just has everything in it
you installed in the normal way and and
and it just works anybody who hasn't
asked a question yes sir
so how would this impact J&amp;amp;L p yeah I
know I know what it is so my expectation
is that the JRE that you that you
typically find on end-user desktops
where you to which J&amp;amp;L p but and
applications are deployed those will
continue to be full jerry's in most
cases there's no reason for them to be
anything else so it won't impact channel
fees is the short story any other
questions
why not distribute jade eps with jdk 7
instead of j decayed so you can start
finding out but you can start finding
out jdk java.net go download it jdubs is
there please use it and if you find any
bugs in jdk 8 let us know the sooner the
better i need to save it again any other
questions
we have enough we have not finalized
what j mod is right now it's a zip file
with a classic directory and a native
directory and a tiny bit of metadata in
the first jigsaw prototype we actually
we were in amongst our early goals now
tossed out was to have a very compact
distribution format and so there's a
there's a format called J mod in the
first prototype that uses pack 200 and
tries to make things in you back 200
bzip2 and lzma point to make stuff as
small as possible that's just doesn't
seem to be important to anymore so we
will we will probably not carry that
forward and Jai Mata it might still be a
zip file it might be something else if
it remains a zip file I'm determined
that unlike jar files it will have a
magic number of the front so you can
tell what it is you know it was it was a
mistake in jar files not to have done
that there will the gem on format be be
documented or be some private format you
know in general i prefer i prefer
private formats but certainly if it's
still based on zip it will effectively
be a public forum at and so we would
document document it and define it you
know if we want a private then we'll use
it then we'll use a different format
okay we might be out of time yes we are
out of time so if you have more
questions think about it for a while
come back at four thirty will be here
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>