<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Inside the CERT Oracle Secure Coding Standard for Java | Coder Coacher - Coaching Coders</title><meta content="Inside the CERT Oracle Secure Coding Standard for Java - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Inside the CERT Oracle Secure Coding Standard for Java</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/FnzIinpedhw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thanks everyone for coming to the last
session and last day I I ran into a
Milton Smith on the line for the event
last night so I said oh why did you
schedule me for the last talk on the
last day and he said well Robert I want
you to anchor the track so you know
people would want to stay around to see
or talk so I learned that under pressure
Milton is a really poor liar so I've
been talked about the cert Oracle secure
coding standard first I'll just kind of
give it overview and talk about the
relationship with scale so the the cert
Oracle's could come standard we we
actually started this effort with sun
microsystems way back when so it's been
something that's been going on for some
time we published the first version in
2001 and it was built mainly around Java
7 we're now doing you know we continue
to evolve all these things because
because one of the things you find out
about creating coding standards and
we've been doing this for about a decade
now is that it's it's a lot harder than
you imagine and and you mostly get it
wrong at first and then you have to kind
of iterate iterate until until you've
got something reasonable so we're also
doing a little work with the sub setting
for Andrew development with some Android
specific annexes and and basically the
standard the rules of the standard meant
to be sort of normative requirements
that you can hand to your developers and
say you know please try to write your
code to conform with the set of rules so
we have something called the source code
analysis lab or scale which is basically
collection static analysis tools that
can be used to do conformance testing
against against those requirements we
also published a 2013 last year the java
coding guidelines also for the SC 7
platform and this is basically all the
stuff that didn't fit into the standard
rates this was the leftover i don't want
to say garbage this because a lot of
these things were actually more powerful
in a bunch of ways right so it's very
good advice but
it wasn't that catch where you can say
that if you violate this guideline your
code is defective right it's just a
better it's just better advice for
writing code so so following the
guidelines can often result in you know
great improvements but not following the
guidelines doesn't necessarily indicate
you've got a defect or a conformance
issue so again the the use of the the
coding standards defines defines a
prescriptive set of rules and what we do
in scale is that for each of those rules
we examine the code and we try to
determine if a the code is provably
non-conforming mean we find the
violation of a particular rule
alternately we we determined that the
code is provably conforming to that rule
and we basically never do that so that's
there to differentiate between provably
conforming conforming so conforming
means you know we looked at the code and
we couldn't find any errors so we mark
as conforming so it doesn't mean that
there aren't violations it doesn't mean
that the code is secure it just means
that using the suite of static analysis
tools we had available weren't able to
find any violations so that seems like a
really low bar but in fact it still is
still quite a high bar to achieve and
I'll show you some statistics on some of
the systems that we've we've looked at
in a few slides so the rules of the
guidelines they they have a they'll have
a structure to them so we have a start
with a concise but not necessarily
precise title then we that's followed by
a precise definition of the rule so they
so the paragraph between the title and
the first example is the definition of
what you're supposed to do and then the
rest of it is examples which in you know
feuding international standards which we
do quite a bit of examples always
considered non-normative so we have a
non-compliant code example on the wiki
we put that in pink and the ideas
don't copy and paste that into your
system and then sue carnegie mellon
university because you know they would
fire me in a heartbeat if they thought
you know i was going to be the cause of
a lawsuit against the University and the
compliance solutions are in blue so
those are things that hopefully you can
take it and reuse in your code and for
the rules we also provide a risk
assessment and you know the reason for
the risk assessment we create the coding
standard in you know immediately the
feedback we got was well gee Robert
there's a whole lot of these uh huh you
know which ones do we have to do and and
so I said well how many you know how
many vulnerabilities do you want to have
in your system and they they never
appreciate that response so so we try to
prioritize and the idea behind the
prioritization is if you have some
legacy code limited resources you can
start with the more critical ones so the
way we do the risk assessment is on
three criteria one of severity so for
severity a high severity means running
arbitrary code remotely the medium
severity is data integrity violation
unintentional information disclosure and
low as denial of service attacks and and
so that works good in the abstract but
for example the heartbleed vulnerability
was a medium severity because it wasn't
it was an information leak so it turns
out that if your information leak is key
information you know that's that's extra
bad so the likelihood is is that how
likely these these rule violations are
going to result in a vulnerability so
not in all cases you know that they
don't in all cases so we try to give
some probability that this one is going
to be in and that's very hard to do it
is based on attack surface and how
you're deploying your applications and
so forth and the cost because we're
focusing on remediation if you're
building new code hopefully you
understand the rules you write code that
conforms with a rule but we factoring
costs for remediation
basically you know the way to think of
it is if you have some a rule that has
high severity high likelihood of being a
vulnerability and it's inexpensive to
fix that's the no-brainer type of rule
that you should go after first so we we
multiply those out put them in levels
that's mostly not not particularly
interesting but it makes a kind of nice
graphic there so so the source canales
lab what we've done is we've collected
commercial open source analysis and also
analysis coming out of research
laboratories analysis that we built on
the secure coding team and we've used
this to analyze a a few dozen code bases
over the past four or five years where
we try to provide value to developers
but also we we instrument the whole
thing and we use it to research the
effectiveness of the analysis we're
building and no don't worry we're syrtis
close you know your specific
vulnerabilities to anyone so so the way
it works the customer gives us there the
code for analysis we we install it onto
the machine and analyze it with whatever
analyzers we have available for that
environment we then go through with
human analyst and look at those results
because static analysis tools tend to
generate high false positives and you
know we don't want to bother people with
you know results that aren't real so the
way that we then provide a detailed
report to the customer to help them
guide their repairs we give them a you
know six months so every time they need
to repair the issues you know not
forever and they can then resubmit and
then we'll reassess the code and certify
it give them a certification if the
system now conforms so this next slide
I'm really proud of because I I managed
to talk CMU council and the sei CEO into
letting us give people you can form and
tested seal if their code passes
conformance testing and and most of you
probably don't work for universities but
a lot of universities have this thing
called an endowment and and so it's a
big pile of money that they don't want
anyone to take away from them so so you
know protecting the endowment drives all
decision-making at a university so the
fact that they were open to me doing
this I think showed some confidence in
our process so so the idea behind this
is you know you you're developing a
product and you know you tell your
customers well you know I know the
competition has a system out and it's
got more functionality and ours is going
to have but you know just wait a little
while and we'll deliver something that's
secure and so basically you just you
know shot yourself in the foot or really
do that through the through the you know
forehead you know so so part of the
problem is you know this word secure
right so we work with a lot of defense
contractors and and and when the
government asked them to build a secure
system basically they say well okay you
know we'll we'll do that will charge you
five percent more and basically won't do
anything different because you know it's
secure doesn't mean anything right so
you have to convert that into something
meaningful and conformance to a coding
standards actually a meaningful
requirement against which you can
evaluate conformance so so basically we
have some virtual machines running ESX
servers connect it to a storage a our
network and we just installed the code
on whatever the the appropriate
deployment environment is for your your
software we then right run these Suites
of tools and a lot of these tools report
a lot of you know kind of stuff that's
not that interesting so we we filter out
the results from the different analysis
tools and only report on specific
violations of secure coding rules we
then create those
we then merge those results from
different tools and then we have a human
analyst look at the look at the results
and so recently David Svoboda is this
guy sits to my left he went out and put
together a series of videos
demonstrating how source canales lab
works because prior to that it was just
something that he did down in his
dungeon you know on freaky fridays
between three and four in the morning I
don't know the details exactly but they
were there so secretive so now it's out
you can go and and watch the YouTube
playlist so the four of the tools were
using Coverity findbugs fortify eclipse
and this kind of gives you a sense of
the rule coverage we're getting so a
couple of the things we found in general
is that static analysis tools have non
overlapping capabilities some of them
are good at some things and some of them
are good at other things so you do get
quite a benefit from from using multiple
tools but sometimes it's impractical
because a lot of these guys want you to
pay for these tools and then you wind up
pay for multiple tools and also the
overhead running each of these tools can
can eat up a lot of time so here's the
results that we've seen and as usual
I've remove the name of the customers to
protect the guilty and you know so so we
do find a significant number of issues
that the case against of significant
lines of code not including comments and
and blank lines and you know you'll see
sort of a range here there's this so the
the red in each column is the is the
worst case in that column and the green
is the best case so the worst software
we saw had about 81 violations in when
Diagnostics per thousand significant
lines of code
and the kind of the highest quality
system we saw had about just under eight
so some of these you know smaller
systems you see that there's sort of a
possibility maybe of eliminating all
these issues right if they work at it a
bit you know these larger systems you
know Eva there's very large system of
six hundred and fifty-three thousand
lines of code you know even though the
code quality is pretty high it's got
quite a lot of defects to sort of retro
actively extract so this is this was my
comment earlier that even though we're
not proving anything and it seems in
substantial in some ways it really is
kind of a high bar of quality to to
obtain and maybe too high you know I
mean if this thing progresses anywhere
over the next few years it's going to be
us backing off of some things to make it
easier to build conforming systems okay
so now I'm gonna talk about some rules
so I'm going to do a couple and then
I'll hand it over to David Duke up more
so so serialization can be used
maliciously you know I think the the
oldest vulnerabilities i remember in
Java go back to problems serialization
so there was a particularly nasty one a
couple years back 2012 we used to
compete with my turf or different things
like CVS and and over time what happens
is a anyway from minor here in the room
but thank God is being taped so they can
get me later so so we build really bad
technology I'm sorry we build really
good technology and market it badly and
my door sort of does the opposite and
they beat us every time every time so
you know get the marketing paper
marketing guys a lot of money so so this
described an exploit that bypass job is
applet secure sandbox to run malicious
code on a remote users machine so that's
a that's the highest severity in our
in our in our metric so deserialized
malicious object that subverted java's
type system and infected more than a
half million Macintosh computers mostly
in the US and canada and i think that's
the point at which mac user stop saying
nanana not vulnerable to to you know
that was the moment that happened saudi
serialization is equivalent to object
construction any and all invariants that
need to be enforced during object
construction also have to be enforced
during deserialization and the default
serialization you get if you don't
implement it is lacks any enforcement of
those class and variants so creating a
new instance of a class without invoking
any of the classes constructors the any
input validation checks will be bypassed
and the program has to must not use the
default serialized form for any class
with implementation to find invariants
so there was this at the core of this
particular vulnerability was the atomic
reference array class and so this
supported an array of object references
in which the elements could be
atomically updated it was introduced in
Java 5 is part of the concurrent atomic
package it's a parameterized type that
implements serializable ax t
serializable but has no customized read
object method which is a violation of
this rule well assuming it has class and
variants which this does so so here's
here's some of the code and mostly this
code is quite boring I threw a little
bit more code in here then then you you
may need it to have seen but there's a
there's a private final object array so
that's basically the object array for
which atomic reference rate performed no
valid validation during d serialization
the
sing this array field offset that's just
a that's a variable that's used in the
fix so I want it to show you that that
variable is just a it uses the unsafe
class which we just went to a lecture on
and apparently son is is trying to get
rid of that I just said son didn't I you
know sorry man sorry about that but
people who know me will like plug in the
right words so you know you just have to
play along at home with that so okay and
and really the key to this class is
what's not there which is there's no
read object method so really that's the
violation of the rule so so the I'm
going right to the fix i should yeah i
should talk more about the problem but
well I talked to a bit about the problem
on Monday this was the contents of my
anatomy of Java zero-day exploit yeah
here was a David presentation on Monday
okay so that's the consequence that will
set your basic so basically the attacker
in this particular exploit was able to
you know get a get a hex editor and
modify deserialize object on the disk so
that when this was red in there was no
checks meat on it and then they were
also able to leak it out from the object
because they had a handle to it so there
were basically those two problems with
the class so here's here's the fix and
the fixed very simply added a read
object method and so this you know this
added the the appropriate checks so it
starts by doing a get on this array
field that was problematic and storing
that is an object it then performs a
test to see if that object is not array
and so if it's not array it throws
exception that's the end of story there
in the next the next conditional test to
see
whether the dynamic type of the object
is it an array of objects and if it's
not it makes a defensive copy so we have
another rule that's actually violated
this is a twofer another rule that was
violated by this vulnerability which was
the deserialization method failed to
make a defensive copy of these mutable
inputs and so here if it's not an array
of object they make a defensive copy of
it and cast it into a array of objects
and then if it is it just goes ahead or
you know if it is an array of objects it
just goes ahead and writes it to this
offset field that I showed you on the
previous slide again using the unsafe
method so the interesting thing about
this fix is that it still violates our
rule making defensive copies so you know
in the case of an array of objects it
will fail to make a defensive copy so
you know your homework assignment for
next year is you know right next wait
for that and send it to David and he'll
presented next year so I was chatting
with the Sun guys and they don't think
it's a problem so you know it's a it's a
good it's a good challenge
uh it did fix the exploit yeah it solves
a problem right and and so that's that's
a little bit of my concern here right
because a lot of times when you have a
vulnerability and is given to the
development team they'll write a fix
that eliminates that particular attack
vector that particular problem and this
does eliminate that exploit so I mean
what it's doing is if the the runtime
type is class loaders or array of
strings or something else it will make
this defensive copy it's only in the
case where it's an array of objects it's
copied straight in and so the question
is how much fun can you have with an
array of objects it's see it seems like
a poor decision to me I suspect it was
for the sake of efficiencies to not
duplicate array objects but there's a
lot there's a little performance benefit
there clearly and so now if if the codes
perfectly safe you know they made the
right choice it's a little bit faster if
there's still a vulnerability there then
they'd probably be the wrong choice so
you know we'll know next year stay tuned
stay tuned all right so let's see so I'm
going to go on to the next one so this
one this rule is not quite the same as
the one that's in the book we have we
have the book versions which are nice
because they're static and you can hand
them to someone they don't change and
then we have the things on the wiki
which are nice because they're they're
up to date but you know it's hard to
it's hard to tell your developers you
know right to this set of evolving
changing things you know so you serve a
slightly different role so so we've
recently updated this and now it's got a
hardly long name which is do not pass
arguments to certain Java collections
framework methods that are a different
type than the collection parameter type
so the Java collections framework was
introduced in Java one to include it raw
I'm farm-fresh types list
vector etc that don't type check their
elements in Java 15 generic parameterize
types were added such as a and I how do
you say that on a vector of object or
something type vector of element of
unknown type list of element of unknown
yeah it was looks like a like a Death
Star to me right now Death Star the the
tie I'm still not getting this the TIE
fighter yeah TIE fighter but not the one
that Darth Vader rach's yet the Darth
Vader have the straight ones he had
those yeah the door okay Darth Vader TIE
fighter thank you I need to be on my
game here I'm sorry so raw types are
deprecated but still available and you
can convert between raw and parametrize
types so the interfaces of the Java
collection framework generally use these
generic elite i prioritized methods when
you're adding or putting something into
one of these collections to add objects
into the collections and of course that
means that you can only have objects of
that type of the franchise type in the
collection but they also accept an
argument of type object they also have
methods that accept an argument type
object rather than parametrize type such
as contains remove or get so those
methods can accept an object of any type
and the reason for this and I just came
from the Java 8 smells bad talking this
to me smells bad from a security guy
kind of perspective so the reason for
this was backwards compatibility you
know so I think what happened was when
they they were building these generic
types they they made the contains and
remove methods and get methods take
parametrize types and then they ran a
bunch compiled a bunch of legacy code
and a lot of it broke and so they looked
and what they found was that people
would have collections of random stuff
and then they would iterate down the
collection of random stuff and say you
know remove everything from this list
from this other list you know as
appropriate and
if if things were different type they
didn't really care as long as the things
that were the same type got removed so
they so the the job a development team
had to back up and say okay well that
didn't work let's just use a raw type
for the remove and contains methods
because they didn't want to break a lot
of existing code so so that means now
that programmers have to ensure that
arguments passed to these methods have
the same type is the parameter s type of
the corresponding class instance so I'll
give you this short example and to me
this is a very obvious sort of piece of
code to write but you you just sort of
say for into i equals you know 0 to 10
I'm going to add some things and then
presumably you'll have some code that
processes list and then later on you'll
have another loop that removes them I
combined them into one loop and then
you'll remove it and then your
development environment will say oh not
so fast your you're passing an int to my
TV ad method but it only takes a short
right and so you like yep right so you
cast it too short and then everything's
hunky-dory so now compiles and it runs
and there's no obvious problem but when
you go to print the size here can anyone
tell me what the size of the the the
hasit will be at the end of the loop
will be 10 yeah very good so the problem
here is that we're still trying to
remove an int and there are no ends in
the in the hash that there are only
shorts and so there's there are some
ways you can get to this problem but I
think I i think that the scenario just
outlined is a very likely one right it's
kind of somewhat lazy programmers
letting the compiler drive the
development right instead of thinking
about and I'll do that I you know get a
head cold you know sleepy after lunch
those things happen so anyhow once you
know the problem the solution is quite
simple and that's also
cast the value to trying to remove too
short also so it's of the same type of
the object that you've added and that
last example also violated another one
of our rules which is don't ignore
device return by method so the remove
does return false if it failed to remove
an object so you you could have had some
indication at least but a lot of times
you're not going to write that okay and
then the import comes in at the last
second really weird reason all right
it's that print 0 so the one exception
to this rule and a lot of times we have
exceptions to the rules you try to like
I said they're hard to get right and a
lot of times you know you write a rule
and then you get a lot of false
positives and you have to kind of tweak
them but will but the collection
framework also has an equals method that
takes an argument of type object and in
our sense is that people understand the
contract for equals stipulates that
objects of different classes will never
be equivalent so that's not something
that we would diagnose is a violation of
the rule okay so I'm going to turn
things over to David to take it home
thanks Rob okay so our what's our next
rule here prevent heap injection so this
is similar to the or prevent heap
pollution sorry injections pollutions so
many things that can go wrong so he
pollution is actually a term provided by
the Java standard it's in the Java
language spec provide up here and the
spec specifically restricts it to
container classes I actually stole the
this diagram from a C++ book which
talked about the same thing if you have
a list of apples and you match a stick a
banana and the Apple in the list of
apples that's heat pollution so so the
fundamental problem heat pollution is is
it possible to actually stick you know
to actually put an element of one type
into a class
container class that's supposed to
contain elements of another type and the
answer is it's quite simple here is a co
example that does precisely that it has
an add to list function and the edge of
this function takes a raw list type not
a parameterised class the raw this type
of course doesn't care what type it's
element objects are but it is invoked by
this main function which passes it in a
list that is supposed to contain only
strings and as you can see we
nefariously add an integer to this list
so what how does this code behave when
we actually build it and run it first of
all if we build the code we will get a
compiler warning here the compiler has a
knee-jerk reaction of pushing out
warnings whenever it sees you mixing
generic and weight raw and parameterised
types because it's afraid that heat
pollution can occur but it can't really
prevent it as Rob said when the Java
development team added parameterised
types they didn't want to break all the
old code so they kept raw types in so
you could keep your old would still work
and you can clearly convert between the
the new and old systems with the main
problem being this compiler warning and
the consequence being that you can have
heat pollution so so here's the
definition clearly the system will let
you actually add it imager into a list
even if it's a list of string and it
should prevent this edition so anyone
care to guess what actually happens in
this program what how this program will
behave exactly the catch is that the
class has exception happens not when you
add the nefarious integer to the list of
strings but when you actually try and
pull it out because the this get
function will pull out the list element
and implicitly cast into a string
normally that's a no op because this
list only has strings but as a last
round of protection they always the cast
will catch if there is something in the
list that is not a proper string and
therefore throw a classcastexception so
what's the big deal clearly the program
caught the caught the problem the
problem is that the catch occurs I
shouldn't say catch the problem is that
the air is detected not when the element
is added to the list but when it is
actually retrieved with the list and
while that only happens that while it
all happens in the same page in this
program clearly you could write a really
large program where the list addition is
done your way over here and the
retrieval is done way over there or it's
done even much later at some later point
and so when you get the classic ass
exception you have no idea what caused
the list to be polluted in the first
place so so what we really would prefer
is something that is that would be fail
fast that would detect the heat
pollution as soon as it occurred and not
at some later point so the best
mitigation to do this is simply not to
use raw types now that we have
parameters types replace all your raw
types with parameterised types and life
becomes good you get no compiler warning
in this case and the program works well
in this case the you get no compiler
warning on the on the switch there but
the system the compiler will determine
that you are actually trying to stick to
add a integer to your list of strings
immediately and it will fail to compile
and so you can easily mitigate this by
replacing the integer with a string such
as the string 42 and the system will not
only compile properly but it will work
properly it will give you no error
because your list of strings is
unpolluted all right so clearly they
left raw types in the code in the core
library because there was already a lot
of legacy code I think the fundamental
rule whenever you're building a
programming language is you know don't
mistakes to the beginning because
anything you missed you any behavior
that your language provides will have to
be supported throughout the throughout
its entire lifetime so you know 20 years
from now if we're still using Java we
are still going to have raw lists and
vectors and you'll still have heat
pollution maybe you'll have more checks
on them but it's still going to be a
problem so so the big problem here often
is well I have legacy code for whatever
reason I can't change this add the list
maybe it is legacy code you know maybe
this function is buried somewhere in a
million line code of program or maybe
this add to list function I could change
it but I will break lots of code and
cost a lot of cost my developers a lot
of time and money so what do you do if
you can't mix or if you can't convert
your rod types to generic types so in
that case the best mitigation we can
suggest is the check collection items of
methods so here we have here we have the
same program mitigated without changing
our add to list function so again we're
still mixing raw types and generic types
we still get this morning but this
program this program uses a check list
and a check list is a list that simply
adds runtime checks into any
modification or addition so that in this
case this program will again compile
with the warning but when we run it we
again get our classcastexception but
this time we don't get it when we
retrieve the element for the list we get
it when we add the element to the list
so so once again this is a fail fast
method way of mitigating heat pollution
preventing it from happening and we do
this at a performance cost because the
checklist clearly has to do a type check
on every element that gets added to the
list but it does save you this
maintenance problem of heat pollution
causing your program to die some point
far away from when you actually
committed the sin of
putting of polluting your heap thou
shalt not pollute by heat alright so a
one footnote I want to add to this is
well a race have been around longer than
generic types what about arrays can I
raise had this problem so what I have
here is a simple code example that tries
to do to to pollute an array taking
again a what we have here taking again a
list of strings and trying to replace
when the elements with an injured so I
can tell you that this code compiles
perfectly fine because you know that
we're convincing the compiler that we're
doing something proper can anyone tell
me what happens when we run this code
very good we actually it's actually
called a race tour exception I never
heard of it before I actually tried to
build this code so so even though this
object array is officially declared to
be a array of object elements there's
some time information where it knows
deep down that it's really an array of
strings and so when we try and stick and
put an integer into our rate strings
then the the assignment operation will
actually throw this erased or exception
and cause the program to crash in
particular the program will fail at the
point of heat pollution and not later
when we actually try and print in other
words in other words arrays are immune
to heat pollution in a way that lists
and vectors which they were okay okay so
the last rule that we have listed here
is this input input data sanitization
rule do not pass untrusted unsanitized
data to the runtime exact method IDs 07
J so this rule actually is an instance
of a more general rule we have I think
it's what I DF 0 0 J which basically say
which can be summarized as prevent
injection that includes SQL injection
cross-site scripting format string
injections and ids 07 is simply that
rule applied to the runtime exact method
and when we've thought about this we
realize that these are all examples of a
very general problem and that is that
you have different trust domains and you
have trust boundaries and this is a
problem that's actually rather unique to
Java the main the main thing that Java
was endowed with in the early night
before anyone had heard of the language
was the ability to run code with
different levels of trust after all you
know we could run
java applets all the time and a Java
applet is force is restricted from doing
things that many programs can do an
applet can't normally write to the file
system well unless you write an exploit
but that didn't happen in the 90s never
mind that and you know consider see if
you run untrusted code in the sea then
you're pretty much as good as pwned
because she has no no mechanism for
preventing untrusted code from accessing
the file system then that work all the
rest of your sensitive memory you your
sensitive passwords and everything else
but Java you'll provide this these
differing levels of trust so you have
different so some code in your jvm is
more trust than others for example the
code in the GBM is all normally trusted
it pretty much has to be so is the
locally available code and then there
are various other levels of trust you
can give to other other code code
libraries an applet for instance will be
run under a restricted security manager
that applies to the applet code but not
to the JVM or library code um you can
basically create I think what what the
wii newest world calls jails so the
point is that you have differing levels
of trust that you can apply to code it's
simply sort of an extension of
modularity and clearly you have some
code that you need to be able to run
which you can put under our very
restrictive sandbox such as your applets
so anytime you have code with multiple
like classes with differing trust levels
you have a trust boundary and this trust
boundary not applies knowledge in just a
java code say between a java applet and
the JVM it applies to many other
scenarios it will apply to say your c
code say if you have say if you have a
program that runs with elevated
privileges and has has you know accessed
eight to say your user database that
runs at a different level of trust then
your your game program
so you would identify that you could
simply say you know there's a trust
boundary between these two programs
where this program has extra trust in
this program has little trust maybe this
program also has is your web server and
therefore has access to the wider
internet and this program does not and
of course trust boundaries occur in the
physical world as well I'm going to
guess at each and every one of you has a
trust boundary around your wallet you
know you have inputs rules about how far
your wallet may leave your person or
what stuff can come out or when when
cash comes out of your wallet you're
very careful about when that happens
anyone who doesn't have those rules that
come and drop your wallet up off up up
here at the end of the lecture please so
so the point is to identify trust
boundaries in your code and usually it's
pretty simple most code runs at a sink
most individual programs even in Java
will run at a single level of trust and
you'll have multiple trust levels in
different systems you know separating
say your web server from your servlet or
your web server from your login manager
and and so on so the the ultimate point
of this rule and of our injection rules
is that when you have improperly
sanitized text it doesn't have even have
to be texting with any data the Texas
runs across a trust boundary you know
take heart bleed for example where where
a web server leaked memory to a any web
client that was definitely a trust
boundary because the web server had
elevated levels of trusts there was an
elevated level of trust around what the
web server maintained it can maintain
multiple people's passwords and credit
card information and it'll it that
information should have never left the
web server it should only use that to
authenticate clients but but I'm sorry
yes I would I'll come to she'll talk in
a moment but that's another example of a
of a trust boundary being violated in
fact thanks for pulling me back to focus
because so let's actually talk about
shell shock in that case so the problem
with that that occurred in the bash
program which has been in unix for what
20 it's more than 20 years old but the
shell shock the shell shock bug itself
as 20 years old and it have you ever as
anyone ever said this is not a bug is
the undocumented feature shell shock was
actually an undocumented feature it was
an extra capability added to bash I
haven't looked at the bash source code
I'm bettin there's lots of
vulnerabilities that shell shock is not
a vulnerability is in the sense it's not
a coding error if there isn't code that
that behaved differently than it was
expected to the program was behaving as
designed and it was designed well to
have this extra feature where you could
put a function inside an environment
variable and the program would learn
that function bash would learn that
function allow you to call it and any
commands that were in that environment
variable after the function would be
executed it occurs to me that if if this
had been documented say in the bash man
page and everyone who used bash was
aware of this thing we wouldn't be
having a problem today people would be
more careful about what environment
variables go into any bash invocation
but it wasn't documented people didn't
know people therefore used bash and used
bash environment variables in their dhcp
servers their web service there's many
CGI scripts would pass their parameters
along through environment variables so
in fact you had a so this is an
interesting case actually because you
know bash itself has is like all C
programs it's one level of trust but and
there may or may not be a trust boundary
around that you know around bash you
might just invoked
to yourself on the command line and the
bash program has the same privileges
that you add but if bash is invoked from
say a web server and it can receive data
that comes from a malicious user the
malicious user can therefore execute
arbitrary commands shell commands in
your shell and so that data went from an
untrusted user you know across a trust
boundary into bash and was executed by
bash and now I'm coming now I have to
come to the other part of this which is
improperly sanitized data if the you
know if the untrusted user doesn't send
a malicious environment variable no
problem so this and again this not only
applies to bash it applies to any
program that say uses some specialized
subsystem like like a bash or any unix
thing it also applies to a database so
you can send the SQL and it applied to
the web itself so a web browser can can
be subject to cross-site scripting so
this is of course a lot simpler than
bash and all we're doing here this
program just simply execute this this
shell command in fact this shell command
might invoke bash but it doesn't have to
if you say if you're running say i think
a bunt or debian they use a they use a
program called dash which doesn't have
the shellshock vulnerability as a lot
simpler and more limited a shell than
bash but this program whether invokes
bash or not still has a improperly
sanitized string in that this dear
string comes from the deer property and
that might have been set from an
environment variable but whoever runs
this Java program can specify all system
properties and a program that will say a
desktop app you know can't usually
cannot trust that the variables that
come in the system settings are
necessarily secure
okay ground if you're like the root the
root user and you're the only one who
can run this java web server but then
okay maybe you maybe you can trust
yourself or you can trust you know who
you were six months ago when you
actually wrote this thing but if you
can't then you know this deer might
contain a nasty command gets passed from
this from the system property into the
string and then gets passed into the
shell command which command which
combines with LS you know normally LS
will simply list the contents of this
directory and move on to the next thing
but here is an example of a scenario of
a value passed to the through deer that
would do something really nasty in this
case in this case what we have here is a
command that ultimately dumps the the
etsy shadow file on UNIX systems the
shadow file contains the username
passwords back in the old days all the
username passwords back in the 80s were
in a plain text file and they were
predicted by encryption back then
encryption was so good that it was okay
if anyone could read the past be
encrypted passwords because no computer
in the world could brute force them at
the time times have changed a little bit
and so nowadays while most of the user
information is in the etsy password file
the actual encrypted passwords are now
in the etsy shadow file and only
elevated users can read FC shadow so in
this if we assume that the Java program
has this ability to read elevated
elevated to root privileges and by the
way Java program should probably almost
never have root privileges but well
humor me for this example so this string
starts off with this bogus command bogus
thing which is simply past LS we're
asking LS to list a bogus directory
which it will fail at but then this
semicolon says okay now start a new
command and the new command we have here
bassy creates a string to send the f
TP system where that it simply tells a
string to connect to an evil site and
upload the contents of Etsy shadow to
the evil site and then quit and there's
a couple of commands there to make sure
that ftp doesn't actually prompt the
user for a password or let the user know
that anything nefarious has taken place
so it's a very simple program and it's a
very end it's a fairly straightforward
way of boning this simple program and in
fact if you want to if you want to
exploit shell shock and you have a
vulnerable Sheen this would presumably
be a be the way to do it of course
replace this site this is not a real
site sorry I don't use that use some
real side of your own sorry I'm not
going to help you with that part that's
an exercise of the student so so the
last thing I was talking about is that
you completely have to accept some user
input that program clearly was supposed
to accept a directory from the user and
the user need not be trusted and clearly
you need to be able to send arguments to
your CGI script without worrying about
Oh without worrying about shell shock
you need to send elements to your
database without worrying about SQL
injection so we have several there's
lots of ways of making sure that that
you're safe and we divide them into
several several categories here of which
the two most important our validation
and sanitization and 4 i'm going to
gloss over the details here because
they're in the rule which is in the book
you know by the book please but here's
the quick big picture of these two
things validation is specifically
designed to make sure that that your
untrusted input will not cause an error
in this case this code does validation
because we simply make sure that what
the user provided is a valid directory
there's nothing to make sure that the
say that the command doesn't have a
semicolon or some other something else
that is it can be interpreted as shell
code
shellcode usually means code that's used
to take over buffer overflow but this is
code that is that would run in your
shell so I guess that sort of qualifies
a shellcode hmm but the point here is to
make sure that the this list LS cabanne
would not actually give it fail it would
produce a legitimate directory so we
call that validation and in contrast
sanitation is something here where we
simply is a security measure where we
don't care if the LS command succeeds or
not if the user gives an invalid
directory well that's on their own ed
and aren't in this case we're simply
trying to prevent a command injection so
we make sure that this is simply a
regular expression that says if there is
anything here that is not an
alphanumeric character then then we
throw an exception there for now this
actually is a bit paranoid because this
clearly prevents us from specifying a
directory that has say a period or some
other odd character in it so well I can
weasel and say this you know better safe
than sorry but you know in this case I'm
just simply trying to show that this is
that we're not trying to prevent an
error from having here we're just trying
to prevent the user from doing something
malicious and
even skating for dot slash um well Don /
would be would be caught by this thing
and clearly you know this is killing too
many it's catching more things than it
probably should you know the validation
would be in practical terms the
validation would be a better option in
this particular example a better option
would would be to not use the shell at
all since all we're doing is listing a
directory why not just use Java zone
file API to list a directory and in that
case since we're not using this shell
nasty shell commands like FTP don't
apply the system the string can only be
interpreted as a directory even if it
has semicolons and the nasty FTP sites
buried inside it so in fact the best
solution is to avoid these subsystems
when you can and only rely on sat
ization validation when the directories
when you have to use one of these
subsystems by the way sanitation is also
specific to each subsystem if you want
to sanitize you know something like a
file name then you need to watch you
need to be very careful you need to
watch for things like dot slash things
like symbolic links sanitizing for
correct file names is we have what an
hour hour to hour long lecture on how to
do that in our course and if you're San
tising say format strings that's another
lecture if you're sad if you're
preventing a SQL injection I don't think
we have a lecture about that do we yeah
yeah someone has those lectures and I
think hTML is the hardest one of all
because HTML contains several different
subsystems you know in addition to you
know the in addition to the sgml like
features of HTML you have javascript to
worry about you have CSS tags it's
really actually quite complicated
okay so that is the set of rules that we
were going to go over so I'll just wrap
this up quickly by making a PR
announcement and as the contents the the
Java guidelines have been available in
book form for a while but they are now
we've now made them available
professionally on online so you can
actually go down to this this website
and view the Java guidelines and are
these guidelines as well as our Java
rules and our see rules lnr C++ rules
and our pro rules they're all available
to view online and we encourage you to
actually go there look at them and at
the bottom of each each rule is a
comment section if you find a problem
with our rules please log in and post a
comment them to their or send robin
email if you discover a problem we we
answer mail and we responded we doing
pretty quickly we also have a couple of
plans for improving the Java guidelines
and the Java rules the so the certain
Oracle secure coding standard for Java
this Rob said it came out in 2011 when
java 7 still had that new car smell with
it and clearly Java has moved on since
then Java eights been out for what a
year now some point we need to update
our rules to include Java 8 and to
include Java features new to java 8 i'm
sure there are a couple of rules about
how to use streams properly and how to
use lambda that that still need to be
added to our to our standard ok do you
want to add anything wrong yeah that's
good so so we definitely encourage
people get involved and tweeny process
anyone can view them you can create an
account and comment and normally what we
do is like if you're we know you and
you're an expert you know will give you
edit permissions we also like occasion
we see people who make really good
comments consistently over time and then
we just invite them to be editors and
then there you know other folks right so
so there there are some really smart
people who've got some very unique ideas
and
we like them to comment but we don't
give them the keys to the car
necessarily because you know we want
these things to be we don't we're not
trying to be a groundbreaking here right
so we want rules for which there is a
consensus and if you want and not
everyone has to agree but people know
what they're talking about have to agree
and you know you have to kind of sort
that out but you know if you're
interested in getting involved just just
let us know you can send email to this
account or contact either of us directly
at any of his contact information and
you know we've got linkedin group and
newsletters and all sorts of stuff any
any questions before you fly back to
wherever yes sir every moment got a copy
you read it and beyond the rifle round
I know you mentioned some fools unloved
so what is your recommendation well you
know so so we offer we offer some some
training and and you know in the sea
space we're a little bit more advanced
we have some instructor-led we have
online training but we're trying to do
that for job as well because because the
right time to fix these problems is when
you're coding to begin with you know I
mean I you know I mean I sorta do a guy
can dream daddy you know and and I mean
something I would maybe advises you know
send at least a person from each team
and then if you've got some some culture
of code inspections at least someone on
that team has has some training and can
spot things and can communicate other
people on the team and sort of
disseminate the information out like
that you know but the thing about
security you know we just mentioned
vulnerably ambassa there 20 years right
so so someone could program for their
entire lifetime and retire and never
realize that the trail of
vulnerabilities they've left and so the
problem is that on the job training
doesn't work for security you really do
need to have someone tell you you know
what the issues are and kind of build
this awareness that so so training or
education is definitely necessary part
of part of the equation you know pass
that you want to you want to use you
know so to solve security have to throw
everything at it you know so you need to
train you need to you need to adopt the
rules cisco an oracle have both adopted
the secure coding standards for their
internal use and oracle guys get a lot
of miles out of it you know like so
there
um you know they they they want training
and they want more training you know
they've kind of estimated masses for
video training because they've got young
people out of school who can some some
reason absorbed six or seven minutes
worth of material in a video format
That's not me but that's some kids I
guess and they have you know they have
some of their own static analysis tools
then he's like parfait but you want to
use static analysis you want to use
dynamic nest as you want to use a wide
range of things but but you have to
start with I mean it's nice to adopt a
set of requirements tell your developers
we want you to do this Cisco had brown
bag lunches or once a week they get
together and go over a rule so that
people understand what it is in detail
so it's just it's just a full-court
press all around anyone else okay time
to hit the bars</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>