<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CON2306   Writing Microservices in Java   Best Practices and Common Mistakes | Coder Coacher - Coaching Coders</title><meta content="CON2306   Writing Microservices in Java   Best Practices and Common Mistakes - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CON2306   Writing Microservices in Java   Best Practices and Common Mistakes</b></h2><h5 class="post__date">2015-12-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/4wtupt-Q5sQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Derrick Ashmore and we're
discussing micro services specifically
micro services written in Java this
won't work for the people who are
viewing the stream but by show of hands
who has seen at least one presentation
or write at least one article about
micro services Oh most of the group okay
I did notice a few that hadn't so for
them I'm gonna include a short
definition section the level sac but
it'll be short essentially that's move
on to Who I am
I'm a professional geek I started
working as a geek professionally in 87
which puts me at old but not quite
ancient I've been involved in Java
technologies since 1999 and I've moved
around a lot I do in addition to being a
developer and architect I've taken tours
of duty as a project manager as a Oracle
database administrator as a db2 database
administrator as a UNIX sysadmin
translation is I get bored easily and I
move around a lot I'll I'm also a little
bit weird as I spend my off hours
writing and basically I've got the
architect's handbook out now the
microservices book is forthcoming circa
february most likely all right let's
talk about presentation resources I see
a couple people like taking pictures of
slides and whatnot
you don't have to do that I've posted
this slide deck on SlideShare the only
Earl you really need to remember is the
first one and you don't even really need
to remember that if you type Jarek
ashmore Java or Derrick Ashmore
SlideShare it'll come up all these links
are active most of the samples I'm going
to draw on our open source and on my
github
and I do have this this talk is a little
bit more higher level but for people who
want to get down and dirty into the code
I do have a sample micro service written
in Java and that's also posted let me
get Pub basically I see people taking
pictures beyond this slide you shouldn't
have to take pictures it's available
let's talk about the agenda I'm going to
have a short definition section upfront
for the people who didn't raise their
hand and the first question and then
we're talk briefly about why we get into
micro service architectures and why you
might want to use that I then go into
design considerations yes we have coding
patterns we've got coding patterns for
everything under the sun microsystems of
them out there I have I don't have time
for all that so I have cherry picked
what I consider the most important and
that's what I'll go over that being said
I also have links to additional reading
at the end of the section so that you
can pursue this pursue some of the other
patterns if you like then I'm going to
talk about cross-cutting concerns I'm
talking about things like you know
monitoring some of the things we get
into with micro services tracking
transaction IDs security some of those
some of those things that are specific
to micro services or where micro
services tends to change how we approach
those versus traditional web application
architectures we'll get into in that
section every every paradigm comes
complete with marketing fluff yeah
Micro Services is no exception and the
when to use micro services segment I'll
try to separate the wheat from the chaff
a little bit tell you what's marketing
fluff what what what isn't and you're
going to find out that to get the
benefits of
micro-services architectures there's
some fine print you need to observe to
get those benefits I'm going to try to
tell you where that is and we'll have
some summary and some QA ok all right
the short definition section to irritate
everybody who didn't raise their hand
basically micro-services has no real
concrete definition as geeks we like
concrete definitions micro-services
doesn't have one the way to think about
it is services that adhere to some
characteristics and there are exhaustive
lists out there I've kind of narrowed it
down to the few I consider the most
important and by far the most important
is micro services basically fill a
single functional purpose by functional
I mean business they do one job and it's
business specific they do one job they
do it well and they don't do anything
else alright they're very focused
analogies that people draw on are UNIX
utilities for instance LS the file list
utility does lists directory entries be
they files or directories and that's all
it does lots of options for formatting
but it does one job does it well I
prefer as an analogy to use my stereo
system even though it's hardware
it'll illustrates some other points the
idea is that in my stereo system if I
swap out my speakers none of the other
ponent components care alright
microservices is the same way you're
supposed to be able to swap out one
micro service for the other and they're
supposed to be self-contained enough
that none of the other services need to
care as long as it did what its
predecessor did so the micro services
aren't dependent on an execution context
they don't care whether they were
initiated by a user in a web app
someplace or by a batch job or
some sort of mule USB flow they don't
care if they get their instruction they
have their resources they do their job
that's it basically it keeps them very
loosely coupled they run as an
independent process all right in some
shops
it's common for licensing considerations
to bring up multiple web applications in
one container micro-services you
typically don't do that
it's basically an independent process
independent JVM and it typically uses a
standard interface
most people use web service rest but
that isn't strictly required what's more
important that is that the interface is
standard and everything uses it okay
micro services normally people don't
start out with developing an app and
using the micro services architecture
what usually happens is a traditional
web app gets too large and too complex
to maintain and they start breaking it
up into smaller services and that's
usually where micro service developments
come about what usually gets left as a
cohesive unit unit is the user interface
there's a business reason business
advantages advantages to the user to
have a cohesive user interface web
frameworks aren't our notorious for not
playing well together
as an example let's take JavaServer
faces and spring MVC both viable web
frameworks but try to combine them and
you'll quickly find out that you're
going up you know upstream swimming
upstream so usually you leave the
presentation layer alone we're going to
talk a little bit more about that later
in the program what's important is that
instead of that presentation layer
basically using database connections to
marshal data from databases and that
kind of stuff it farms all that out to
your micro serve
library all right and each one of those
microservices are independent and to be
independent and not couple with anything
else they have to have their own
database which is another kink that as
next VBA that's the hardest part of this
pill for me to swallow but essentially
it's recommended in a micro-services
architecture that basically each service
has its own data store that oh it and
only it uses now that gives you a
problem all right most organizations
have data that's common throughout the
enterprise and I'll give you an example
I spent several years in the higher
education market anything a university
does any University built system has to
have a knowledge of what campuses that
University has and to deal with that
common data you've got two basic choices
in this architecture one is you write
one service to maintain campus
information and everything else calls it
or you make arrangements to copy that
campus information to the services that
need it I prefer the service call option
that's just me
most people be concerned about
performance of such a thing but there
are ways to mitigate the performance
effects of that so I'll talk about that
all right let's move on to benefits why
do this besides the obvious indication
and of you know modular ization breaking
a big problem up into smaller problems
one of the benefits that people go
through or go for is the fact that
there's very little or there's no
technical stack lock in all right if
you're organizing services at a service
level it doesn't matter whether the
services that you're calling are written
in Java six Java seven Java 8 Drive a
nine or whether they're written and go
or whether they're
than anything else that you care to
write a service for and what that does
is that gives you the freedom to use the
technical tools that a particular
service needs with no impact on on
everything else try doing that with
contrast that with what happens in a
very large traditional web-based
application you know you want to upgrade
from hibernate version 2 to hibernate
version 4 you know you can you can see
that you know the the ripple effects on
your code base are going to be fairly
significant and that's not a
twenty-minute kind of a conversion in
this world you can more easily upgrade
what a particular service is using
without affecting anything else that
said just because that barrier has been
removed doesn't mean you want to go
crazy organizations have economies of
scale interests right it's easier to
support three database platforms than it
is to support 20 right so just because
you can choose anything that you want
doesn't mean that you should anything
that you're right somebody's probably
going to have to come along and maintain
it so it makes sense to be smart about
the technology stacks that you pick but
this constraint that was there under
traditional web-based application no
longer is there's some fine print to get
to it but then one of the benefits that
people go through or go for with
microservices is higher throughput
higher higher velocity all right the
idea is is that since you're breaking up
the work into small independent problems
you can basically set a small number of
developers on each service and because
they've got such a focused target they
don't have to talk to anybody they're
basically heads down development alright
so the communication overhead that you
get with large traditional Web Apps as
far as developers arranging
coordinating their changes with um teams
and other people that doesn't
necessarily happen in a microservices
world if your service boundaries are
drawn drawn fairly well so that's one of
the benefits people people go for let's
move on to design considerations before
I do that for the people in the room any
other remaining questions on what micro
services are yes sir no okay the
question was for the people who are
attending via streaming wouldn't you go
for the convenience of bunching several
micro services up into one JVM and that
defeats the purpose of micro service
architecture that by definition ties
them to one particular version of the
JVM if you want to upgrade from version
7 to version 8 any micro services
bundled in that JVM would be affected
right same thing happens is you get
effects from from other services
something goes awry and one of those
services in the JVM in that scenario
it's possible that other services
besides the one that's having the
problem get affected right so you really
you really don't want to do that
later in the program we're going to talk
a little bit about packaging options
about how to make it easy to publish an
individual micro service in one JVM in
one process there are tools to do that
okay
okay if you if you want to put multiple
contracts to the same service you can do
that typically people don't but yeah I
don't see anything wrong with that but
yeah that's the question was and my bad
for not repeating it was could a micro
service publish multiple contracts and
my answer was of course that you know
you typically don't but you can alright
I'm going to go on so that we don't get
caught short on time design
considerations I'm breaking up into four
basic categories I'm going to talk about
service boundaries and by that I mean
figuring out what this mission statement
for micro service should be turns out
that's deceptively hard I see I see
development teams basically agonizing
over that so I'm going to provide some
guidance on that service call failure in
a world where a user action could lead
to a micro service call calling other
micro services calling other micro
services service call failure or calling
a service that's not up is a very real
possibility and there are some ways we
can mitigate mitigate that data
integrity we're all used to in a
traditional web application architecture
the safety of the database transaction
exception happens rollback happens your
data is left in a consistent state in a
micro service world that's a lot more
dicey because you don't have one
transaction guiding the entire user
action so there are some ways to deal
with that that we're going to go over
and
of course performance when everybody
first hears about microservices the
first question is well doesn't perform
and suck and the answer is is that there
are some ways we can mitigate that so
we're gonna go through some of those
alright service boundaries I kind of
break out break down the kinds of
services into two main categories one
I'm calling core services basically crud
like features let's take a higher ed
example sooner or later a university has
to record the fact that student John
Smith is attending and this is his
address and this is his name and these
are the particulars about him that we
care about sooner or later that's got to
make it to a service that stores that
somewhere in some type of database that
crud like service I'm calling it a core
service it basically records records
facts process services basically address
complicated business processes that
typically use rely on other services to
do their work and I've got some higher
ed examples like processing student
applications or you know debt collection
for deadbeats or whatnot or doing
something like disciplining a student or
recording you know producing transcripts
things like that that are that are more
complicated and typically involve
multiple services on calling process
services partitioning is an art to some
extent if you break your services up
into too few you've got a baby monolith
problem where each of the services are
smaller than the than the traditional
web app they they came out of but not
really small enough to to give you all
the benefits from micro services but if
you have too many or the service calls
are too fine-grained then performance
becomes a problem so given that I've
told you partitioning is an art and I
can't give you a heuristic for
determining determining a mission
statement for a service well
so I can give you a couple of boundary
checks all right
one is that each microservice you should
be able to express its mission statement
the business that it does in one
sentence in business terms all right and
I've got several primitive examples up
here on the board but the idea is is
that you don't want a certain micro
service to have a technical function if
you're going to create a micro service
to maintain the foo file well the full
file might have some sort of business
impact somewhere but that sounds more
like a technical concern to me rather
than a business concern okay so that's
that's check number one check number two
when somebody shows up and they want to
call your service do you get nervous you
start asking questions about okay what
did you call before you're calling my
service what are you calling afterwards
those are all those are all red flags
that say that you're not truly context
and independent you actually care about
what services got called before you get
called and you care about what what
services you're making assumptions about
the execution flow of multiple services
and you don't want to do that the whole
idea here is that micro service
architectures basically micro services
are supposed to be self-contained and
independent warning signs here people
who are analyzing spend time utilizing
call flows like well you know if if I
call this service first and I gather
this data and I can pass it on to this
other service and I can pass it on to
that other service and those are all
indications that your services aren't
really independent and they should be
okay we do have something that's
unfortunate with micro services and this
exception with size the phrase micro
basically means that you know or implies
two people that micro services have a
small code base the point I'm trying to
make is micro services are about having
a single functional business purpose
they're not about
having a small codebase it just so
happens that if you have a single
focused business purpose you usually
have a smaller codebase it is a
byproduct of using a micro service
architecture not a end goal and another
self in other words they see a couple of
I've had a client in the past it
basically installed rules that say that
ok a micro service can't be um you know
over X number of lines of code and
that's really kind of silly they need to
worry about the mission statement for
the service not not its size designing
for failure ok as as I alluded to
earlier we don't necessarily have the
safety of a database transaction
rollback if user takes an action and
that goes through 10 micro services and
the fourth one the the first three go
completely successfully and the fourth
one bombs potentially your your datas
left in an inconsistent state because
each one of those services has different
database transactions associated with it
there's no universal rollback that
magically puts everything back so there
was some first thing everybody says is
that well you know you make everything
clustered all right so nothing can be
down well the reality is is that there
are cases when an entire cluster for a
service is down you know it could be
that it's being upgraded it could be
that some resources it depends on isn't
available so no the nodes in the cluster
work so in other words clustering isn't
quite enough there are some coding
patterns that we can use to help
mitigate this and I'm going to go over
some of them first one is the retry
pattern alright they call this the retry
pattern but I call it insanity because
you literally are doing the same thing
multiple times and expecting a different
result
and the idea is is that whatever let's
say an initiating service requests
something of a target service the retry
pattern basically just retries it at a
specified interval until it eventually
succeeds the idea is is that whatever
took down the target service is a
temporary condition and someone's going
to come along and fix that all right a
couple of configuration options this
algorithm usually has max number of
retries you don't want to retry forever
right and the other configuration option
this pattern usually has is the interval
between the retries if you give
something 50 retries and it does those
50 retries and 10 milliseconds you
haven't really created enough of a
window for somebody to restore service
on the target so that you know that's
that comes into play too I've got a
sample retrying implementation on my
github however there is tooling support
for this apache cxf supports the retry
functionality spring batch has a retry
template and apache httpclient supports
it as well and i've got links to an
example example there circuit breaker
alright
this pattern is patterned after the
junction box in your apartment or house
alright something bad happens in the
electricity and as the the circuit pops
and there that the circuit trips and is
open and basically nothing on that
electrical circuit works this is a
software version of that alright
the idea is is that the circuit breaker
after a configurable number of
exceptions from the target circuit
basically just short circuits it doesn't
allow any calls to the target service to
go through it airs out immediately now
why is that important everybody here I'm
sure I don't
even have to make this a question
everybody here is surf to a site that's
unavailable and your browser waits for
60 seconds or 90 seconds or whatever it
is to eventually tell you that that the
site's down the same thing can happen in
a service call scenario right now your
you may configure different timeout
periods and you may not be waiting for
the 90 seconds you may be waiting for a
shorter period of time but you can see
how in a micro service world where you
have dozens of these things I'm sorry a
problem with a problem with one micro
service can bubble up to do two other
services suddenly some service that
sized to host ten concurrent
transactions now has several hundred
times that because they're all waiting
for this timeout period right so you
start getting derivative resources
everything on the planet starts starts
coming down so it's important if your
resources aren't there for your service
to do its job airing out more quickly is
better it's an interesting twist on
performance tuning so basically we
hinted at the number of thresholds
common thresholds on this pattern or the
number of errors required to trip the
circuit all right and then the amount of
time required to attempt to retry
basically this this this pattern has
history support is the only product I
found that formally supports the pattern
if you're already using history by all
means follow the link and it takes you
to a description of how to use that
feature there's a very heavy product so
it's not worth bringing it on just to
implement a circuit breaker pattern I've
got a sample circuit breaker
implementation I'm gonna get hub that
you can use copy whatever and I've got
more
and link at the bottom dispatching via
messaging all right we do this in
traditional web applications today right
essentially the idea is is that target
instead of calling a target service
directly you put instructions on a queue
and something reads that queue and
processes the work and the idea is is
that if the target service is down the
work just sacks up in the queue and then
when somebody restores the the target
service all that work just gets
processed in life is fine
basically there's tooling lots of
tooling support for this this isn't a
new concept we do this today
the JMS api is very easy most people use
it directly but for producers you do
have a JMS template and a rabbit mq
template but as tooling support but this
is this is old news service called
mediator all right this is the idea that
if one of your dependent services is
down depending upon you know the
importance of that service to whatever
business function you're doing maybe you
can provide partial functionality all
right we've all seen this from different
websites for example I logged on to my
my bank a few days ago and it told me I
couldn't transfer funds but I could do
anything else all right so the idea is
that sometimes you don't want to abort
the whole show just because a dependent
service is is out of commission so the
problem is how do you how do you mediate
that how do you codify that no one wants
to write schizophrenic services that
have to start wondering about okay if
this thing is up or if that things down
you want to localize that and that's
what the service mediator does the idea
is is
instead of the initiating service
calling the target service directly it
calls the service mediator it makes the
call if there's an error he basically
does any logging that you want to do he
creates it you know issues any alerts to
admins that the service is down that you
want issued but he returns a default
response to the caller and the default
response could be an empty list or
something like that if it was a lookup
or something along those lines and the
initiating service just basically
processes as normal doesn't even know
that the dependent service is is is out
that's all localized in the mediator and
there's an example implementation on my
github sure Danis that is correct well
okay the question is if you have a
mediator in several different services
and you upgrade the service mediator and
one doesn't then the inference is
doesn't that really break the micro
services architecture because the idea
is is that any change you don't want to
affect multiple services
the idea is you treat the service call
mediator just like any other common code
any service that you micro service that
you write and Java is going to have
dependencies right Pachi common slang
just a second sir whatever it is being
utils whatever it is it pulls in each
service should make a decision about
when to upgrade their dependencies and
the service call mediator isn't is no
exception to that all right so what I
would do is I would make the service
call mediator common code version it
so you've got mediator version one
mediator version 1.0 dot one and so
forth and so on and individual services
make the decision as to when they're
going to upgrade okay all right okay I'm
sorry sir I've drawn these yes
essentially what the question is is
basically wouldn't the service call
mediator have to do different things
depending upon which which thing called
it and I'm thinking of the service
mediator as code in the initiator
service
so the initiating service has context it
knows how important that call is and
whether or not it can do business
without it all right and so the services
that could make use of a service called
mediator would employ one the services
that are completely out of the boat if
that target service isn't around would
just simply not use it all right that's
the answer okay moving on designing for
performance micro service architectures
greatly increase network traffic all
right there are a lot more chatty
basically there are ways to mitigate
that everything you've learned with SLA
about trying to make services more
coarse-grained and as opposed to
fine-grained still applies but the there
are some other patterns that we can use
to mitigate that and I'm going to go
through them the only one I'm that's
designing for performance that I'm not
going to go through is dispatch via
messaging essentially that increases
performance by giving the users the
illusion that something
faster but in reality you're just taking
the work offline and since we already
talked about that pattern I'm not going
to talk about that again
so backends for front ends
it's common for web apps to basically
consolidate micro service calls and I'll
give you an example rumors are that when
you surf to amazon.com and it comes up
with that first screen that the data for
that page is actually is actually
obtained by multiple different micro
services and I can guarantee you that
your browser isn't making dozens of
calls to individual micro services
what's happening is it's making one call
something on the other side is taking
that user action request for the display
calling whatever myriad of micro
services need to be called to gather
data for that display combining the
response and sending a unified response
to do the browser the idea is is that
you keep that network chattiness of your
micro service library on an internal
network that you control and that your
network engineers can performance-tuned
right you don't expose it to the web web
at large another name for this is a name
I don't typically use another name for
this pattern is called the API gateway
pattern I don't use that name because
people get it confused with API gateway
products all right like wso - or
business base or something along those
lines those are more for governance I'm
talking about the pattern okay anyway
we've already talked about not exposing
micro services directly to the browser
then we're on to a pattern that I
basically use in traditional web apps as
well and that's expiring cache the idea
is that all organizations have some data
that doesn't change for
often okay in the case of a higher
education example campuses right it's a
rare day when in being in a university
which I came from establishes a new
campus or closes down an old one but
that list is needed for just about
everything on the on the planet in the
university setting so the idea here is
you trade memory for speed the first the
first service that needs to know of the
list of campuses that are out there and
some information about it that data gets
it gets read and it gets cached all
right every other service Clint call for
that information gets served up from
cache all right and you can do that
because campus is such a such a static
static data you don't want to use it for
things that change very frequently all
right but you can safely use it for
things that don't change very often a
couple of gotchas with this typically
the cache is employed on the client side
not on the service side because the
whole point is to eliminate the network
all from the clients of the service so
essentially if the day comes where you
know a new campus is established
services using expiring cache mechanism
will learn about that new campus at
different rates so you could have a
small period of time where you get
different answers from different
services but beyond that it's a very
effective very effective tool there is
tooling support for it I prefer Google
guava but I don't want to start any
religious wars if you're an H cache fan
or your gem fire can Jim fire fan or a
fan of anything else that supports an
expiring cache mechanism use it
I'm promoting the pattern not
necessarily the tool
alright designing for integrity we've
talked about the fact that we don't have
the safety of a database transaction and
unfortunately have you know we've got
we've got a pattern to deal with it but
it's fairly labor-intensive and the idea
is to write a reversing transaction so
the idea is and this is an example up on
the on the board that say microservice
needs to issue several calls to do the
work that it needs to do the first one
works the second one fails and in that
case instead of just blowing up the
initiating services the service
initiates a third transaction to reverse
the first transaction that succeeded so
that your data is left in a consistent
state now this is laborious and there's
very little product support that you can
apply to it because it's so custom to
what you're doing that's yeah so that
you want to make decisions your your two
basic choices are when something fails
have a developer go out and fix the data
into a consistent state figure out what
what's inconsistent and issue whatever
transactions they need to to make it
consistent again or you write some sort
of reversing transaction type logic and
the way you do that is you you make
those decisions it's you just frequency
of the currents for something that fails
like maybe once or twice a year you
don't bother writing a reversing
transaction for it right you send
somebody out to manually fix it if
something breaks dozens of times a day
yes you try to make it not break dozens
of times a day but you might consider
that as a candidate for codified
reversing transaction alright we've
talked about most of this I've got a
link to more information about this
pattern
in the in the slide let's talk about
some other ancillary concerns we I'm
sorry yes sir okay the question is what
happens if something happens that we
lose the fact that a transaction has
partially succeeded and a way that that
can commonly happen is in the way let's
say something takes down the initiating
service between transaction one after
the air and before transaction three all
right
that's a possibility all right that's
something that would have to be manually
fixed alright that comes under the
Manuel camp I can't think of a way to
codify a reversing well I suppose you
know I suppose I need to think about
that a little bit more but you're right
that is a potential weakness in the
algorithm okay yes sir
okay the question is don't you have the
same potential problem in a normal
transaction without an exception because
something could take down the initiating
service say between transaction 1 and
transaction 2 and transaction 3 if I got
your question correct
right
right okay so the suggestion is to
utilize two-phase commit
instead of a
okay the statement is is that
potentially in a micro-services
architecture you could have this same
problem even if there wasn't an
exception because if something took down
the initiating service or something the
the last transaction and the chain
decided to blow up you could you could
you could basically have to have this
same problem and I agree with you to
some extent if you want to talk about
this further we can talk after the after
the presentation but in interest of time
I want to move on if that's okay yes the
question is wouldn't this be a candidate
for some sort of messaging flow where
each service is a node in that flow
typically that's not done with I mean I
I suppose it's technically possible yes
and the the is is pipelining them
against good practices the only one I
can think of that it would be against is
the context independence part but then
if that pipeline serviced a complicated
business transaction then yeah I could I
can see uses for that okay we've got
about 15 minutes left so I'm gonna move
on we inadvertently covered this slide
previously with the question about
common code the secret is to version it
let services decide when to upgrade and
you can't put anything in common code
that if a bug is found or if it changes
forces or redeployment of several
services that breaks the whole paradigm
all right so I'm gonna skip past this
one cross talk about cross-cutting
concerns micro-services okay we're going
to talk about deployment transaction
tracking security and contract testing
there are other cross-cutting concerns
that are very important but the way we
deal with them in a Java world doesn't
really change between
micro-services and traditional web
application architectures so I'm gonna
talk about the first four and the stuff
that's the same I'm going to assume that
you do that today anyway deployment
micro services are deployed as a single
process all right and it turns out that
we've got a large number of tools that
will help you do this from a Java
perspective spring brute and drop
Wizards seem to be the two most popular
but there are a whole host of others out
there if you're using one of them please
don't kill me for promoting one of these
two I'm interested in getting in a
religious war but the idea is is that
both these products basically take your
application and an associated container
typically jetty
although drop wizard or I'm sorry the
spring boots supports Tomcat as well
basically combines it into an executable
jar all right so it's very easy to to
establish it as a separate independent
process just like
micro-services are meant to be docker
which I'm sure you've all heard of
basically takes that one step further
and if you know to execute a jar you
need a JVM installation and whatever the
JVM needs to to function docker takes
that step further and allows you to
deploy the version of Java you're
running under as well as your
application fairly easily another
version of this presentation I go into
this and a lot more in depth than I have
time to here but I've got a sample on my
github of a spring boot to drop wizard
and a docker deployment so for those of
want to get into code level stuff
there's something for you
correlation IDs in a traditional web app
transaction fails typically all the
information about that transaction and
and what what sourced it is is available
in the in the in the application in a
world where a user action might travel
through many different services for
support reasons you need to be able to
associate this service call was you know
the same user action is these other
service calls from different different
different transactions for different
services and the way you typically deal
with that is arranged for each user
action to get assigned a correlation ID
of some some unique ID of some sort and
you arrange to pass that in the header
to any subsequent service requests and
you arrange in those micro services to
include that header information into any
micro services calls that it makes and
you combine this with logging features
that'll make sure that transaction ID
comes out in the logs
of you know basically every every
service call that that transaction goes
through and then when you pull those
logs together and Splunk or logstash of
whatever log management system you use
you can do a search and you can pull up
any any transaction that pertain to the
to a particular particular user action
how we deal with that in Java is
typically with some sort of servlet
filter and there's a code example on my
github bring boot support has been
requested for for this but it hasn't
come to light yet I let's talk about
micro service security all right
I look at security in terms of levels or
layers the more layers that you have
security you put on the more secure it
is in the user level security same way
that it that you govern it today no not
no differences as far and what I'm
talking about now is basically security
for individual micro services or for
your micro service library and I think
of that in a couple of different layers
the first and easiest layer to install
an diplomat is just basic network
routing enforcement all right limit in
your micro service library layer limit
that accessed only to within the
firewall limit it to series of
application servers and whatnot that
need it limit access to specific hosts
and subnets so that people can't you
know just decide from their desktops to
to call a micro micro service in
production without without having
authorization to do so and that's the
easiest thing to do and that'll take
care of some part of your requirements
but not all there are still services
that are more sensitive than others
so for instance a service to list a
service to manage university campuses is
a lot less sensitive than say some sort
of payroll service alright so you might
need additional service acure individual
services that are dealing with sensitive
data and my advice there is to issue
service accounts for them and treat them
basically like database resources if you
think about traditional web apps you use
service accounts to connect to your
database right micro service libraries
are no different in other words what I'm
trying to tell you is if you propagate
end user security back to your micro
service layer and a micro service ask to
worry about whether an individual who's
at the other end of the chain has
authority to do what they're trying to
do that that that basically is very
complicated it gets very complicated
very quickly so treat micro services
like you treat database connections in
terms of security is what I'm suggesting
contract testing all right one of the
ideas and micro services is that you can
switch out one version of a micro
service for another version of the same
micro service in other words the idea is
alright you come across the micro
service you need you need to make a
change to it and the guy that wrote it
or the girl who wrote it basically it
it's hard to maintain you'd rather just
replace it well if you're going to
replace this micro service it better do
what its predecessor did obviously
fixing the bug that you're trying to fix
or making whatever change you're trying
to make but the safety mechanism here is
contract testing okay so basically to
the degree to which you've got a
rigorous contact testing architecture in
place you can more safely you can more
safely switch out services some people
are starting to do consumer based
so if I ride a service that relies on
for other services I basically write a
test for those four services the
functionality of those services that I
use and so that you know I know that
when when they break that's gotten a
little bit of play in the last few
months but hasn't really taken a hold of
yet tooling support their lastest lots
of tools to support this I primarily use
HTTP client and soap UI but I'm sure
there are others out there okay when to
use micro services basically no one
starts out with micro services or at
least I can't find a case study
published out there where somebody
started out with a micro service
architecture to begin with everything
that I've run into they started out as a
traditional web app that got out of hand
for them to maintain and they refactor
it into micro services so that's what
most people most people do and what I'd
like to point out is that micro services
architectures aren't all or nothing all
right
there is nothing that says that okay if
you've got a big monolithic web app and
you want to break a couple of
complicated pieces out into smaller
services you can you can do that you
don't need to bite the whole Apple and
convert the whole thing to micro service
architectures basically traditional web
apps and micro service architectures can
live together all right
warning signs that an app's too large
I'm sure everybody's worked on one of
these right you know you went into the
unintended consequence problem where you
change one thing and you break three
other things yeah everybody's had the
displeasure of of working on one of
those basically that that's a that's a
sign that maybe the the apps gotten too
large and it needs to be broken up and
I've got several other several other
points they're common mistakes in
appropriate service boundaries service
boundaries that service mission
statements that basically depend on a
specific call sequencer
call context or service boundaries that
are not effectively loosely loosely
coupled not recording all requests and
responses when it comes to support most
developers spend more time localizing
the problem in a micro service
architectures so they really do need
access to requests and responses and it
needs to be needs to be searchable so
that they can quickly localize where a
problem with the particular transaction
is happening I go further in exceptions
that I throw in a Java world I also
include the soap request in response for
remote service calls that I make that
that fail and while typically a
developer can eventually get that
information the game is saving time
right from a support perspective the
less time you spend doing support the
better the more time you spend on other
productive things context and exceptions
in common slang which I use quite a lot
make that very easy going right along
with that not checking arguments up
front all right what happens if you
don't and it's less code if you don't I
see why programmers do it but the
problem is you're just kicking the can
down the road derivative exceptions and
things like null pointers because you
weren't passed all the information you
were supposed to pass or get passed in
an instruction those take longer to
debug and longer to fix so in my
development teams when we come across a
null pointer exception to my mind you've
got to defect tickets one is to fix the
problem that caused the exception the
other is to properly document
the exception so that you know it's very
obvious what was missed okay no change
in governance the processes that you put
in place to manage migrations to
deployment every every business has some
process right you have to fill out some
sort of request ticket yet to pass some
sort of testing hurdles whatever that
process is to get from development to
production you have to you have to go
through it a common mistake that I see
is that you don't have change in ISM
governance that really accomodate
microservice architectures the processes
that work for handful of deployables
might not work for 200 you see what I'm
saying
it might just be too laborious so
generally and this could be a subject of
a whole other talk but basically
micro-services need a quicker and easier
path to production they need automated
deployments and back outs the less
manual intervention the better and this
is kind of where micro services gets
into the concept of continuous delivery
and DevOps a little bit and in fact
those concepts go hand in hand
further reading Matt Stein publishes our
reading list on micro services and he
keeps it up to date and it's very good I
recommend perusing it and at a Java
conference I can't believe I'm actually
recommending a Microsoft reference but
credit where credit is due they call it
they call them cloud design patterns but
it's very well written and very concise
so I give you a link to that as well
I've got a Java micro service example on
my github that you're welcome to take a
look at if you want to get into code
level and this slide deck is on
SlideShare so there has to be questions
anybody have any yes sir
I said yes ma'am
I'm sorry I could
okay all right thanks for coming
everybody one for other questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>