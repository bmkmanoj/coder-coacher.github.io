<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CLDC 8 and Java SE 8: Modern Platform Choices for the Embedded Developer | Coder Coacher - Coaching Coders</title><meta content="CLDC 8 and Java SE 8: Modern Platform Choices for the Embedded Developer - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CLDC 8 and Java SE 8: Modern Platform Choices for the Embedded Developer</b></h2><h5 class="post__date">2015-06-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/4_DOBiBsRmA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so my name is Alan Bateman I work in the
in articles jdk team i'm primarily
focused on the library's area and she
fed you wanna introduce yourself ashok
kumar go in there bro so my name is joe
kumar go in de la chaparra I work on the
Java ME embedded team working on
different aspects of the implementation
all right okay so so the title of this
slide is CLD c 8 and java c 8 a modern
platform choices for the better
developer it's primarily a compare and
contrast session where we're going to
talk a bit about the better features in
java c 8 also talked about CL e c8 and
just position them against each other
just to lay out the the trade-offs
between the two platforms so it's
essentially a sem e convergence and talk
and hopefully it's of interest okay just
the obligatory word from our lawyers
yeah okay so this is the agenda I want
to talk about java SE 8 first and talk
specifically around the the compact
profiles and give an overview of of any
age and specifically on CL ec because
there's a because has been such
modernization there talk a little bit
about the trade-offs and differences
between the two and I going to hand over
to shore then sorry shiva to do a demo
and we're going to switch over to the
elmo for that and then we just do a wrap
up at the end ok so and i don't know
whether folks here are interested in in
java c 8 and but it is a significant
updates to to to the platform and the
the biggest features in there or the
lambda expressions the days and time api
annotations and java types and by far
lambda expressions and on all the work
library and language work associated
with that is by far the biggest update
to both the virtual machine the language
and the libraries and since since the
beginning and all the sessions across
the street in the hilton have been
really really packed because there's a
lot of buzz around this
is this is a wonderful update to the
platform so and JD KH is scheduled to go
out in March next year and and but
there's an over already features in here
that and I think Bob and dad talked
about this earlier on in the week and
specifically around subsetting of java
sea for use on smaller platforms and
that's the the compact profiles effort
and also the ability to reduce stripping
of implementations where you're
combining applications and and a run
time together so I'll talk a bit about
the compact profiles soap and compaq
profiles you can consider as as an
interim step until we get to a fully
modular platform so we have been
chipping away for several years and
prototyping and preparing the platform
and so that it can be and deployed as a
set of interdependent modules and that
was originally slated to go into java c
8 and but we weren't far far along in
the effort in artists and specifically
on the module system side of things to
do this so compact profiles was came in
to eat as relative relatively late
feature and because as an interim step
because we weren't going to do
modularity in NH the good thing is this
is that we've we've been we be doing so
much preparation work over the last
three or four years to sort out
implementation dependencies and other
oddities we'd already identified all of
the issues that that and we would run
into when we're trying to module eyes
the platform specifically the just
static marginalization side of things
and that we were able to do compact
profiles with a relatively in a
relatively short period of time also
because we knew where the modules
potentially were going we were able to
do something that wasn't going to cause
us problems or compromise anything going
going forward because we already had a
good idea about the modules were and
we're going to look like the main points
is that it enables applications to the
choose a subset of the java of Java Sea
to actually run a memory constrained
devices now when I look at some of the
talks that are in the on this track
there's
there's a very broad range of embedded
systems we're kind of thinking maybe
slightly bigger systems here come
footwear profiles would be more suited
in terms of mes e convergence then one
of the good things about this is it
actually brings it provides a migration
from the connected device configuration
or CDC that was part of the original and
Java EE architecture it provides a great
migration from that to to full java SE
and in terms of the profiles themselves
there are three defined in the Java Sea
specification the names of them are
completely unimaginative they're called
compact one compact to and compact three
now compared to the Java ME definitions
the profiles these are a little bit
different in that these are actually
just subsets out of the of the core
platform rather than profiles that are
built on top of the platform so in terms
of in terms of their size compaq one is
the smallest come back to is is compact
one plus other features come back to
plus other features then becomes compact
three and and and compact three then is
a subset of the full Java Sea platform
okay so just just to give a bit more
detail on this so compact one itself is
is for the most part it's the smaller
set of AP is that you can actually put
together without doing any subsetting so
there is no removal of methods there's
no removal of classes and for the most
part in this M it's the reason it's not
exactly the smallest is is because
there's a number of other useful things
that are included in income pack one
specifically logging and and and and and
support for and script is the scripting
API to have interoperability between
scripting languages and and and Java
running on the smallest platform but for
the most part is it is the smallest
runtime that you'll actually get without
actually getting into into subsetting
api's provides a really really good
migration form from cdc and foundation
profile because it's it's a superset of
those AP is compact to then builds on
compact one and so it and it adds a
number of useful api so if you want to
do xml you wanna have
connectivity to date a bit to databases
you want to have and distributed objects
in a networked environment and then they
can be added to compact one to give you
compact to and that provides a really
good migration for some of the
standalone jsr s that were built on the
larger j2me cdc that there was separate
jsr is for these going back to be able
to add database XML rmi to CDC way back
so now it's all together in in compact
to then the next size up is compact 3
which is essentially everything all of
Java C minus three elements specifically
korba and the desktop API is desktop you
could think of us as a WT swing Java
sound and other eight ap is that you
would you typically use an a desktop
application and the last that the last
one that's emitted there is is all the
jax-ws and and friends so and Jack's be
so put attachments all of those other
enterprise-e type of AP is that got
added in six and come back three then is
really intended for further the larger
an applicant application that needs most
of there are many of the features of
Java see if you want manageability you
want other other digital signatures
those kind of features they will all be
in compact three so just just to talk
about just some of the constraints about
profiles because a little bit different
from what you see in in Java me is is
each of the profiles must implement the
full vm specification the full language
specification there is no subsetting
whatsoever of those within within the
definitions of profiles profiles for the
most part are defined by set of atapi
packages and have a slide coming up on
on this now all of the types in the
language specification in fact they're
the packages for all of the types in the
language specification that are
reference in this language language
specification are in this the smallest
profile so that there's no there's no
sub setting of the language or any of
the normative references from the
language to two classes and types in the
in
the in the api's and the other rule then
is which is obvious is is that
everything within everything with
everything in a smaller platform was our
profile must exist in in the next
largest profile up and there is one
little glitch in terms with the the
whole sub setting and that is these were
this is something that we identified a
long time ago with due to some static
dependencies that that slipped into the
Java Sea api's over the years but for
the most part is this is the contents of
of the API packages are identical in the
profiles as they are in the full Java
Sea we've only had to remove six methods
across the entire platform and which is
is not bad so these are deprecated
methods and there are also methods that
we've actually marked for removal in
nine so and then we'd already put in all
the property work for this going back a
few years so we knew that this is going
to be a problem anyway and we'd flagged
it a long time ago so for the okay so um
everyone should be able to read this
perfectly well and this is the full list
of API packages i'm not going to list
them all out the slides of course you
can get get later on i listed a down
there so that you can actually have a
have a feel for what's in there on the
left is all the api packages in compact
one is essentially the core platform
security and logging around that come
back to then is adding the xml and jdbc
an rmi API is and then we're adding then
the other API is formal and checked it
for compact three okay I'm going to talk
a bit about Java amino and am
specifically around cldc or and jsr 360
and and so so there is so Java any age
and I've been over the hilton little
dirt tracks for for the last few days of
but I'm guessing that this has already
been presented at other at other
sessions on this on this track here and
covers a number of things it covers a
CLE c 8 and the the upgrade from from
mid p 2 a.m.p next generation to
Java ME embedded and profile and GSR 361
and it covers other other other other
api's device AO and other AP is on top
of that Shiva can can talk to many of
these this is the architecture slide
that's that is I pulled from one of the
product management then slide decks just
showed the architecture I have no doubt
that has been presented here for the
most part what I'm talking about here is
is the core platform right down the
bottom of this cldc and further up and
Shiva can talk more about these later on
in the later part of the session so CL
dch so and so I'm because I'm working on
the JDK side of things is it's it's it's
it it was always disappointing that j2me
and specifically the small platform had
been left behind a little bit and it's
cldc was based on the the one dot for
subset of the one dot for api's and that
that's all a long time ago for us so
it's actually wonderful now that there's
a there's a huge upgrade and
modernization of that and to bring them
bring it much closer and the line is
with with java c 8 so so everyone i
think is actually very pleased to see
this happen so cdc has really been the
been there for connected devices
particularly feature phones going back
for for ten years and it's now being
repositioned and to be targeted target
to embedded devices and wireless module
smart meters as the number of things
listed out here essentially machine to
machine type of devices so it's a it's a
huge big update moving from from CLD c
111 which is based on very old versions
and sub set it off of Java Sea up to
eight and but this is actually really
really good and it fits into the overall
a lot alignment of the platform the
other good thing is is is is the is the
idea that the schedules for both Emmy
and cldc NSE will all be aligned now
which is actually really really good so
as the platforms move forwards we're not
going to repeat the mistakes of the past
of of leaving
they see behind and it also has a
backward compatibility story okay so and
so cldc I think Roger Riggs gave a talk
and he's one of the co spec leads and
this gave a talk about CDC or earlier in
this week that's currently am in the JCP
as jsr 360 and is currently in public
review and that it that will be offered
for the virtual me see machine part of
the the specifications is being updated
to and move to the Java Sea version of
the the vm spec but there are some
differences we're still talking about
and very and memory consistency and
resource constrained devices so there is
some sub setting of the vm spec still at
this point specifically no finalized
errs and which which which was something
that i was also not supported in the
bridge it would be wonderful actually
when you were to eliminate finalizes
from from completely but there's no way
we can do that in the full platform for
compatibility reasons because there are
typically a bad thing and there's also
no support for Jace or to 92 and the
invoke dynamic instruction and which
which is is is again it's really just a
vm feature footprint and decision at
this point in terms of class file
versions and we've moved on a number of
versions since in cldc when became
available and but but at this particular
point and the CDC specification is
proposing to support and version 51 or
52 which corresponds to the M the class
file versions that we have for 7 and 8
respectively and the version 49 and 50
which is which is and corresponds to jdk
5 and jdk six are not supported and then
for the so for the older versions which
is 49 and older and where cdc had its
own
and type checking verifier which kind of
predates some of the type checking
verifier that went into into java CH
there is there is some support for that
I believe is actually flagged as
optional so that so that you if you want
the backward compatibility you pay the
paper footprint cast okay for the
language then it is a monster jump for
applications that were targeting to the
Wonder for an older version of the
language and because there was
significant updates to the language in
five with generics enums enhanced for
loops and so on and it seems a long time
ago when you're coming in from the JDK
pipe a point of view and but many
developers are still getting over some
of these language hurdles and still
learning and struggling with with
generics and in jdk 7 or java c 7 there
was some minor updates to the language
and i gave a talk yesterday on jdk 7
with Joe Darcy and he covered the these
these language updates and a lot of
interest from from people that were
we're looking to migrate from six to
seven and so strings and switch the
tryout resources which is really really
great and multi catch and some of the
other minor features then we come to
java CH where there's a where there is a
huge upgrade to the Java language with
support for lambda expressions default
methods and method references and so on
and so this this is this is all
wonderful stuff and so this is going to
be a big leap forward for for m4 app and
productivity and multi-core and and just
being able to express things in the Java
language so moving from the one dot for
language and older 22 to age is going to
be big hop I think and so it'll be quite
interesting you know there are there are
there are there are few little issues
here the the MEAC convergences is that
it's more of a road forward I think than
anything else so this is a big leap
forward there are going to be a few
little issues here and and because in
classes using lambda expressions can get
compiled down to classes using invoke
dynamic they're not going to run
immediately on a on a small device and
now the language features that were
added in age were designed to support
alternative implement
and in fact many of the prototype
implementations and in before what
before the feature went into in days
were actually and using em by code
transformation techniques in order for
them to run on a slightly older vm and
maybe that would be what we will be
required here there isn't there isn't
there's just isn't supporting the vm at
this point far for that ok for AP is
then and so cldc in emits a lot of
features from from Java Sea and that's
very understandable because it's it's
targeting very very small memory
footprint and so I've listed down the
ones that that are in the specification
so there's no support for reflection
serialization and I'll give a clap for
that because civilization is such a
problematic thing for us anyway and J&amp;amp;I
classloader path loaders no support for
runtime annotations and a few more
things in there there is some support
for mm collections in CLE CH which which
is actually wonderful and whatnot not
the fall collections of it because it's
just there just is not the space for the
for the target environments for this
specification ok so just just to say two
things is about the number of things
actually just about cldc is is that the
specifications this point proposes and
22 different two different essentially
profiles a full implementation which is
all of the AP is that CLE CA defines and
then a compact version which allows you
to throw over there to get rid of a
remove certain api's and where there
just is not the space to support them
and the main things in terms of
alignment which with with java c 8 is
that and there isn't any super setting
of the api so there's no sort of
incompatible additions to the AP is but
there is significant subsetting in order
to be able to meet them the the memory
and resource constraints
and and then just just just just say
this is that this is this is a big
operator valve off cldc and it's
wonderful to see things in there even
basic support for collections and maps
and sets and even Liverpool's is really
really good so here is the full set of
AP is actually I see that doesn't come
out too well on the slide there and but
that just gives a summary of what's in
the fall and and the compact API is that
are in there but very significant
subsetting so you can't you can't start
using c DC with the expectation that you
can take any in any jdk library that's
using these api's and expect it to work
because because of the sub setting okay
so let's just review the story so far
and so I've talked a bit about em
compact profiles and they actually allow
their subsetting of Java Sea and to
allow and deployment on memory
constrained devices and significant
updates to Java me with with to support
and modernize and align with with Java C
so that's really really good and the
language should label a lot more
portable software Portability and I am
with Cabot's of course because of
because of the sub setting and when you
combine them together and support for
the really small platforms and support
for the the big small platforms if
there's such a turn and means that
there's means that java's actually and
can now be deployed on out on a very
wide wide range of devices and combined
they sense you become a sort of a
trade-off sams is essentially a
footprint feature trade-off and i've
attempted to capture that on this slide
here and successes so the numbers here
are our numbers of that folks working on
this have suggested our correct here so
that the low end there is a put cldc and
then adding the the the DME and profile
and
would we for the very small devices
where you've 128k of memory and up and
then for the compact profiles a small
headless implementation could
potentially run in and take up a dynamic
footprint of maybe only 18 plus
megabytes which is actually quite good
okay so just an observation for the
audience that this is a huge difference
but it's a wide spectrum of of platforms
ok so the observation is you transfer
that to Bill of Materials it's did you
see nuts immense ok men's ok so let's
just talk a bit about some of the
differences in a bit a bit between
working in with the small CLD c and java
SE so one area where there is a
significant difference still is in the
area of iowa networking and in the CLE
see space is there's a the connection to
the generic connection framework and
which is what's used to talk to file
sockets and so on and and that's a URL
connection type of API style of APAP I
that's used in the small devices just
because the full networking and I oap is
are not available in the in the small
platforms that has got so significant
updates in jsr 360 as well so I should
have explained earlier the GSR 360
covers what's cldc and also the general
connection framework and the other the
other point is this is that there's many
other AP is that you will be using on
the very small devices and particularly
they're coming out of the the me page
specification these are the jab x micro
edition ap is so there isn't there's no
clear usage of those which have a c8 yet
because many of them don't necessarily
make sense on the larger platform so the
way I always look at this thing is this
is this is the the convergence of the
platform is very much going to be a
term type of effort these are just sort
of issues if you would be just to set
expectations around portability at this
point so just just just as just a few
points final points just then on
convergence is the M schedules are being
kept in sync which is really really good
we can't let a DME platforms fall behind
and on the SE side of things where we
are continuing to move on on and move
towards a more modular platform and this
would be essentially dividing the
platform into a set of entered
interdependent modules and we had to
talk about that yesterday all over in
the hilton and we already have a good
view as to how the compaq profiles that
are being defined in eight with my grade
two modules going going forward and
through what we call aggregation modules
and the other the other point about bug
bug convergence is is that over time and
as more resources become get added to
the lower end devices we should see more
of the SE API is being added to to do
j2me and that's all I have to talk about
I'm going to hand over to Shiva now and
two for the 4a he's going to do a demo
and you maybe want to introduce the demo
first don't meet you go to your next
slide okay I'll switch over this while
you're doing that okay okay we will
switch over
countless villages
okay collectie put
yes my apologies about the delay here
we're because we just got added into the
schedule very late we were not all the
bits with the the deal the animal had to
had to had to appear at the last minute
no it's the the ELMO when he arrived
about five minutes of him before the
talk
subliminal message encoding endless
Harrison
it's the visualization of the the modem
connection to this device as we download
the slides here we go
sure
you
yes I think you're on
okay hello okay thanks Alan arm so what
I'm going to do is a demonstration of
how Allen talked about convergence of
cldc eight and a c8 so I'm going to do a
presentation of how we could build a
simple application that could run on
both sale dc-8 and Java embedded a
little bit background I think you had a
chance to look at the chest robot in
action is in the keynote are on the demo
grounds so that's actually an Emmy
application that is busily controlling
the robot so when we build the Emmy
application we wanted to make sure that
it was such initially implemented on svn
bedded so that we could use these api's
like javafx keyboard access and so that
you could basically try to do some
calibration based on you can basically
do a 3d modeling of the robot so that we
can do calibration on it but we wanted
to make sure that eventually we want to
run it on the Emmy platform so we want
to make sure that the code is reusable
across both ACM better than ME ME as
well so i'm going to show you simple
application that is going to run on the
pipe where your quantity use pretty much
all the pieces except how you go in to
access their the peripherals on the
Raspberry Pi so if you're familiar with
the raspberry pi that is a java api
called pi phi j which gives you access
to the peripherals it's from a third
party it's open source project whereas
on the any platform you have this api
called device access api which is
currently being in the process of
getting standardized so we'll just show
you an architecture where we basically
built an abstraction layer between these
device access api's so that we can build
all our application on top of it and is
very easy for us to just run the code
between either ME embedded sorry ME
embedded ours are scmm as well so let me
so what you see here is basically the
other pie and then we have an
abstraction layer called the peripheral
access API then we build these
components on top of this peripheral
access API so you have this component
like a server driver which is used to
control the robot you have an LCD plate
which is what I'm going to show you a
few minutes and other components as well
so there are so the advantages are very
hear you right
just by changing the the access API
module I can pretty much run my
application on top of any of these
devices so let me quickly through show
some code and we'll go from there so
don't know whether you could see it
clearly so on top of this highlighted
project is actually a peripheral API as
you can look at it it is actually a job
is see project so we are able to build a
jar from a java SE project and consume
it directly within an Emmy application
so that's something that you could not
have done before because you have the
tree verification other process in place
so this this is CL dc-8 this convergence
may allows us to make this happen so
then you have these pluggable modules
for me8 and SE 8 i'm sorry it's not that
clear but I mean but that's those are
the two modules that you plug in to get
access to this device peripherals then I
have a simple demo called pipelet demo
which pretty much has most of the
application and as you can see from the
code it's again an ECG a jar file that
you can produce and then which is going
to be consumed by it by the Emmy
application or they see application so
let's quickly run a nap and then we'll
just go through the code as needed ok so
let me try to run the Emmy app
so I'm just basically bringing up the
runtime the CL dc-8 runtime on the
Raspberry Pi so now I go back to hear
this here I run the me8 application so
if i if i switch to the PI such a one so
now you see the application is running
on it I can just press these buttons so
it just says right breast and then I'm
running on a CL dc-8 environment etc
then I quit so now i can do exactly the
same thing on SC sorry so this is so let
me build the SC application which is seh
sorry too
so I go ahead and then build a c8
application it's built and then I go and
deploy is this copy the binaries to the
pie and then I go ahead and then to
ensure
so it's running the application if I
thank you so now you're so now you're
running it on SC so it's pretty much
that's basically you are having the same
application run on both sem better than
any embedded so as you can see from here
right pretty much everything is shared
between both the applications except for
how you get access to the device the
peripheral access api so if you look at
going into code if you want to look at
we have this single class that we define
called platform
so it basically can figure out depending
upon where you're running it can
instantiate so we think we have
abstracted out the i2c which is I
squared Z access to the peripheral and
spi with a serial peripheral interface
access to the peripheral in an
abstraction layer so you just get an
instance of these factories which will
be either a pipe for J implementation or
a device access API implementation and
then rest of the code is completely
shared between the two platforms so this
really looks promising so that if you
have to have application that you want
to target both the platforms even though
I Java ME ume is supposed to be
targeting on a lower footprint but there
are devices which like a Raspberry Pi
which could basically can support both
AC embedded and Amy embedded so if you
want to target both the platforms then
you could come up with this abstraction
layer and then start building
applications on top eventually once the
device access API gets standardized then
you would have it on both the platforms
the life would be much simpler but as of
now this is what you have and you could
build something like this and then
target both the platforms if you have
any questions I'm more than happy to
answer means the application so the
question is what is a footprint
difference between these applications it
is exactly the same binary yeah it's no
i mean because you're pretty much
reusing exactly the same job you are not
even recompile just yet we compile once
on the use of same charge so it's almost
identical it's only the platform
footprint differences that you would
have
any other question
ok
to wrap up and so just some summary on
this presentation it's mostly just to
get across the point that MEA she's been
being modernized and being aligned with
Java CH and there's much better story
there now and combined they they support
a very wide range of them platforms
sorry and you're okay and we mostly just
see more convergence going forward in
the future and this is this it's going
to take a while to it until the smaller
smaller devices get more more resources
we have to support more features of Java
ch so let's see that's the end of our
our talk so if there's any other
questions please ask
with a be a day when you have only one
half time that you can configure with
the success of the profiles in a way
okay so that okay so the question is do
we see a time when we would only need to
support a single run time and I think
that would that would actually wonderful
I don't know what time frame that were
going to be I think it all depends on
and whether the sort of the
fragmentation and there's other small
platforms how long it will take before
and there's more standardization there
more needs and requirements on security
manageability and and so I I don't know
the answer to that question and I think
we wonderful to actually to get to that
point and but i think it's going to take
some time all right so Bob fantasia's in
the isn't isn't the audience there Bob
leads the the embedded effort I'm on
maybe Bobby you'd like to to give your
views on that particular point
you're basically asking us to predict
the minimal architecture
Louis Louis
major differences
language laughter
that are left out this is popular rocket
science you know features take space and
we
if the small platform become one
absolutely
the city winery
jigsaw
watch your eyes
one platform
up
this year
respectively wat they have a single code
base
all of these products and play shows up
everywhere rather than 0 and the slight
variation
Cameron
this combined CBC and se
that scale
you can see our
question for you given outlawed you have
the time I mean those guys are racing
past the Android and our platforms our
target markets
huge
se embedded work targeting in there
necessarily
we're targeting the
rpms
because Ingrid has concentrated code
that has
tutored markets
you have any idea what the slide and Roy
you can look at all the x-files for the
frameworks in dalvik VM
and use those child letter devices good
news this compact
CLD c yes any plans to
that seems to be
okay okay so the question is is about
osgi which makes extensive use of class
loaders and user-defined class loaders
URL class loader and friends are not
supported in cldc and so I don't have
the answer to that one and it was it's
not something that the jsr 360 group
decided to support and if Roger Riggs
was here I could maybe kick that one to
him and so I have no information as to
win that will be supported
okay I think we're done thank</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>