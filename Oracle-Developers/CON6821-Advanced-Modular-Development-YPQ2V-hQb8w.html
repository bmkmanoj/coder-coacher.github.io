<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CON6821   Advanced Modular Development | Coder Coacher - Coaching Coders</title><meta content="CON6821   Advanced Modular Development - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CON6821   Advanced Modular Development</b></h2><h5 class="post__date">2015-12-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/YPQ2V-hQb8w" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good afternoon and welcome to advanced
modular development so the this this is
part 3 of a series of sessions we're
doing the first for today two of them we
already did this is advanced jigsaw
under the hood Alex will present in this
room at five-thirty and then the project
jigsaw hack session is bright and early
tomorrow morning in this room at eight
thirty so if you have questions that
that we don't have the time to answer
today or you want to you want help
packing on your code or whatever please
come tomorrow morning so go back I'm
mark Reinhold this is Alan Bateman Alex
Buckley there's a seat down here in the
front if anybody wants it i'll just make
a couple of quick remarks before before
Alex digs in an important thing I really
want people to understand is that this
is not finished work you know a big a
big part of the reason we're spending so
much time explaining this system today
is that it's it's a proposal it's a
prototype it's a fairly complete
prototype it's it's a design that still
has some some rough edges and some
missing missing parts but we are at a
stage where we really need feedback we
want to get this right we do not want to
do do something in Java nine that turns
out to be the wrong thing as james
gosling has said i'd rather do nothing
than do the wrong thing so we really
value value your for your questions and
feedback so don't be shy all right Alex
hi everyone i'll just wait a minute for
some people to sit down okay no one
standing no one sitting in the sides
good so I'm going to talk for about half
of the presentation about application
migration and then Alan's going to talk
about library migration and the theme
that you should detect is the advanced
modular development in some senses
because there's so much java code
already out there mostly about migration
so at heart a typical application has
three layers at the top are your jar
files at the bottom is the jdk and in
the middle of this sandwich in some
sense is the filling a bunch of jars
downloaded from the internet and thrown
on the classpath that we've drawn it as
a cloud because clouds are cool there's
just this big mess of stuff in project
jigsaw we've turned the JDK into modules
such as Java base Java logging Java
sequel and Java XML the benefits of
modules you've probably already heard
our strong encapsulation so that no one
outside a module can access its
internals and reliable dependencies so
modules know what they need and there's
no need for you to set the classpath if
this sounds good you might be wondering
how to turn your application into
modules let's put some names on these
jars to get started let's assume the
main application is my apt jar up there
at the top and it has some helper code
in my lib
ER and let's assume that the cloud of
third-party jars can be simplified to
just Jackson the JSON processing library
Jackson comes as three jars core data
bind and annotations if you can read the
slides from the back you might see that
the current version of Jackson core and
Jackson data bind is 263 but for Jackson
annotations is 2.60 versions are hard we
don't know why that is ask them of
course to run the application today you
have to ensure the classpath is set up
like this I've got my other my jar at my
appt jar in my libera are in the lib
directory along with the the Jackson jar
files and you have to set the classpath
up just so correctly every time and the
runtime has to search all of it and then
there's my apt main the main class at
the bottom you wouldn't have to bother
with that if my apt jar and my liberty
are turned into modules now turning each
jar into a module one to one is a fairly
natural way to proceed so I'm going to
go with that theme for now it's not
always possible especially if jars have
cyclic dependencies among their classes
but but let's go with it each jar
becomes a module now whenever you see a
module you should ask two questions what
does it require and what does it export
let's ask that for each of our
prospective modules that I'm calling my
app in my lib one way to find out what a
module might require is to run J depp's
on a jar file Jade EPS is a tool in jdk
8 that analyzes classes in jar files and
finds whatever classes they refer to in
other jar files here are the results of
running jade eps on my APR in
my Libby are the class is in my abs are
make use of classes this shouldn't come
as a surprise right make use of classes
in Jackson quart jar and Jackson
databind jar and also of course in my
lip jar that's whether the helper coat
lives in your application plus of course
my apt jar uses classes from the Java
base module like objects right and also
Java sequel that's just the example and
of course and of course my Libby are
also refers to classes in Java base
because that's our object is with that
knowledge we can start to write the
module declarations here's the module
info Java file that declares the my lib
module all it requires is Java base it
was that last line on the previous slide
now Jade eps can't realistically help
you with exports there's a bunch of
packages in a jar how does how does a
jay depth tool know which of those
packages are meant to be internal to a
module versus exported from a module it
can't know so for the sake of argument
let's say that the my lip module exports
a package calm my app do butel and it
exported in particular to the my app
module we're going to make that's a
qualified export because it's specific
about which other modules can access the
package let's turn to the module info
Java file that declares the my app
module it requires my lib the module
will be created on the previous slide
and Java base and Java sequel no
surprise and of course we know it's
going to use Jackson so we'd like to
write requires Jackson core and requires
Jackson day
to bind does that mean we would have to
write module info dot Java files for
those jacks and jars that would be a
pain what we really want is some way for
the Jackson jar files to somehow become
modules automatically then we could
write the module info Java file for my
app like this you'd require my liberal
that you wrote yourself you'd require
Java base and Java sequel modules that
we wrote and you'd require Jackson core
and Jackson data bind the cloud wrote we
would have a beautiful module graph see
how green it is right with my app
depending on my lip and on Jackson core
and Jackson databind and also on Java
base and Java sequel beautiful we can do
this the solution is automatic modules
an automatic module is a jar file that
you put on the module path rather than
the classpath once you do that you have
a real module that that is there are no
changes to someone else's jar file you
don't unzip it and change the manifest
and rees if it the module name is
derived from the jar file name in an
obvious way the automatic module exports
all its packages because you don't write
anything to say what should be exported
and not and the automatic module
requires all other modules on the system
out of the box for free as if by magic
now this is that this is of messy slept
many reasons so once automatic modules
spring into existence for Jackson core
Jackson data bind and Jackson
annotations the module graph you can see
looks quite different the automatic
modules highlighted in red basically
require everything let's be clear they
require each other automatically they
require all modules in the JDK image so
each each of those three modules is
pointing to each of the Java modules and
for reasons that will become clear when
what Allen covers library migration the
three automatic modules also require
your my app and my lip modules that you
declared explicitly this is to provide
the maximum possible compatibility
surface for code in jar files you might
think that the module system could could
run Jade EPS on the automatic modules at
startup and try to figure out what
modules they require but that doesn't
really help for two reasons the first
reason is that the libraries that you
find in the filling of the sandwich
often make use of Korra flexion that is
the java.lang reflect and they do that
to load classes dynamically such as from
your code Jade EPS can see the use of
Korra flexion but it can't see what
classes are loaded bike or reflection
because it's dynamic the second reason
we don't run Jade EPS to figure this out
automatically is that automatic modules
are actually more powerful than modules
that you declare in module info java the
reason they're more powerful
is because automatic modules can access
types on the classpath now we don't want
to scan the classpath of startup trying
to figure out which jars might be
accessed by which automatic modules that
the class path to the module system is
really a black box so we we simplify
matters by saying it's a mess you know
we're proud of it the automatic modules
basically read absolutely everything
they possibly can including code on the
classpath to maximize compatibility it's
not that bad actually in some sense it's
better than when everything was a jar on
the classpath for example there is no
arrow from my lib to my app all for that
matter from my lib down to the three
automatic modules so there's no danger
of code in my lib accidentally reaching
out and touching code it shouldn't
contrast that with on the classpath code
in my lib jar could access code in my
apt jar cuz they're both on the
classpath and that's the kind of thing
that causes maintenance headaches down
the road in fact if you think about it
the classpath is crazy with just ten
jars you get a hundred possible ways for
code to interact because codes in any
jar can refer to a type and the vm will
go through searching all the jars on the
classpath trying to find it so
everything can refer to everything else
either through static references or
through core reflection for extra fun
the classpath is in some sense the
ultimate in airasia right whatever you
know about the structure of your system
those graphs top down that we saw the
classpath throws it away and connects
everything to everything else and as
Mark showed in the keynotes that means
conflicting classes and missing classes
and generally slow look up every single
time the vm needs to read a class
which is pretty often with modules
you're telling the compiler and vm what
you know about the structure of the
system and finally they hear you
speaking of the compiler let's see how
you run it we've got the jacks and jar
files in the lib directory where they've
always been how we treat them as
automatic modules simply by putting them
on the module path that's minus MP so to
Java C we specify where the modules are
coming from by setting minus MP the
module path to lib no changes to the lib
directory just- mp4 module path to java
see we've got the my app and my lip
source code in the SRC directory for my
upon my lip yep and we tell Java Sea
about this SRC directory with the new
module source path option the reason
that new option is necessary is if you
look at the look at the structure of the
SRC directory there's a new level in the
directory hierarchy at compile time for
modules so it's SRC then module name and
then the code in the module module info
java and the package hierarchy and so
instead of naming the package hierarchy
for each module independently to java c
you just say minus module source path
point to the top level SRC and it will
go and find java sea will go and find
the modules module sources in that
directory as a good citizen i'm
specifying the minus d option to java
sea to set the output directory for the
classes so the result is class files in
the mods directory the shape of that
output directory is the same as the
shape of the source directory so
actually if it was sourced my app staff
and sort my lib stuff it'll be mods my
app class files mods my lib
files then we run jar to build my libra
are based on the classes in mods my lib
we run jar to build my apt jar from the
classes in mods my app and because both
those jar files will have the module
info dot class files the we compiled we
call those jar files modular jars you
can take those jar files I guess you'd
have to have to have some other oops
about the compiler flags but you there's
not those those jar files you could run
them on JDK 8 where the module info
class file will be ignored and if you
run them on jet ek9 the modular runtime
detects the module in photo class files
and you're off to the races you'll see
that when we create the jar file for my
app jar we also specify the main class
which is same class as before the result
is that you can run your modularized
application with a command line that is
considerably shorter than before all the
stuff from CP minus CP in the past is
now wrapped up in the module info module
in photo class files in my approach are
my little jar remember the explicit
modules are located in m lib and the
automatic modules are M yes that should
be mods shouldn't it yes that should be
the mods directory and the old Jack's
and jar files they're still in the lib
directory but we've put the lib
directory on the module path so they
become automatic modules so to recap we
modularized an application with two
techniques first we built modular jar
files for our own code by writing and
compiling module info Java files and the
second technique was to create automatic
modules for third party code simply by
putting their jar files on the module
path
if you like you can think of that as
top-down migration we ask the questions
first what does our application require
looking top down that should obviously
make you wonder if there's such a thing
as bottom-up migration and for that
Allen will speak okay you hear me and
okay so this section is we will mostly
forget everything that alex has showed
us in the first part I'm going to wear a
different hat Alex was wearing the
application developer hat he had a bunch
of libraries that that he was that
depending on that were not modules he's
made the modules through a bit of black
magic in a black shirt I am now going to
look at it from the other perspective of
I've now got the library maintained his
hat on and I am going to take the exact
same same example these three Jackson
libraries that we just picked for this
example I am going to see what it would
take as the maintainer of those
libraries to move them to modules so I'm
moving essentially from the bottom up
Alex was the top down and we bring them
together and later on in the slides so
what I want to get to is this so the
color coding we've been using in these
slides is green as modules orange was
just the jar files so I've now in this
slide turned each of the three jar files
that I had into modules now I'm making
the same assumption that Alex did in his
part of the presentation I'm assuming
that these are good candidates to become
modules as no cyclic dependencies I
don't want to do any significant
refactoring of this code before I turn
them into modules so so we'll do the
same thing that Alex de days we'll go
from one jar to one module exactly like
we did in the first part of the
presentation we ask the same two
questions what what does the module
require what does it export we've got
three jar files that we want to make
into three modules so we're asking six
questions what does Jackson core require
what does Jackson core export what does
the data binding module require what is
it
export what are the annotations a jar
file our module what is it going to
require what is it going to export I'm
in order to help me understand what it
requires I'm going to bring out and
wheel out the jdubs tool again I use it
in some of the other sessions earlier on
this morning to be able to look at
static dependencies one of the other
useful things we when we're moving to
modules we can also use it to see what
it's what it what it requires so I'm
running J depth on just under three
Jackson jar files to get a feel for what
they depend on there are some
dependencies between the Jackson jar
files themselves and they have some
dependencies on some platform modules
everything depends on Java base as we
said in the earlier session today in
these modules we can see the data bind
module has a dependency on Java sequel
and java xml see this is what it looks
like in the graph so in this morning
session we were actually building up a
module graph of a dependency graph that
we turned into a readability graph this
is what the dependency graph is going to
look like with for for these three
modules that I'm going to make I'm go to
wheel out J depth again because G dips
has a couple of other useful options to
help me and generate the module info for
these three jar files that i'm going to
make into modules yes i can actually go
and dig up my favorite editor by d and
start typing in the module info but Jay
tips can help me by at least getting me
started so I'm going to run the Jade eps
with this option called jen module info
I tell it a source directory where I
wanted to generate the module info java
files into and then the jar files that i
want to generate the the digit to
generate the module info far so the
output that that as being shown is its
generating three module infos one for
each of the of the jar files that are
going into me to make into modules so
this is really useful it's going to give
me a starting point and far for the
module in foals that I want to write
so I'm going to look at one of these now
we just look at it for the data binding
one because that's the most interesting
one to look at and we see what jdubs
generates for that jar file and this is
what it generates so it generates the
module name which is derived from the
jar file it writes it requires for each
of the dependency so let's figure out
the platform modules the other modules
that it depends on and then there's an
exports for every package in the module
as Alex said in his part of the talk is
when you look at a jar file you have no
idea what the exported API is now we
will talk a little bit about exports in
a minute but i just wanted to point out
that in this example we can see there's
a requires public on each of the four
modules that are depends on when we
talked in the intro a session this
morning we talked about and using
requires public when when you depend on
something when you start using the
signatures of that module are sort of
types in that module in your in your API
you don't want consumers of your module
to then have to go on oh well you depend
on that therefore I have to also go and
depend on that remember we had this this
morning about their implied readability
so jdubs has figured this out and
generated requires public for each of
these four modules because the exported
API which is all types are sorry all
public types in this module must have
signatures for these four types in these
modules and in the API okay so jdubs
Jenna has generally got the requires
correct but it doesn't know what to do
about the exports because remember a
question is what does it require what is
it export it is generating an export for
every single package now how do I figure
out what the what is exported well as
the library maintainer I should know
these packages are part of my API these
other packages over here are purely
implementation nobody should be calling
them and so what I might do is edit that
module info and start removing some of
the lines that I think so by the way I'm
not a maintainer of this lie
making a guess here that all these
little impul and packages that were in
this library are not for the users of my
library so I'm deleting those lines from
the generation module info so that I've
ended up with my exports that is a
subset of the packages in in that in
that jar file that we will make a module
I'm now going to move on and I'm
actually going to compile this and so we
have generated the module info into the
source tree of the three modules what
will be modules I'm going to compile
them with a similar Java Sea command to
Alex used it this is a multi multi
module compilation that is what this
module source path option is is is about
like that I mean I'm being a good
citizen specifying the output directory
mods that so I'm going to compile my all
the modules into this mods tree and I'm
going to run the jar tool and create a
modular jar for each one of those three
jar files i'm using a couple of advanced
options here i'm specifying the version
of the module at packaging time the
module system doesn't care about
versions but it supports adding versions
and other metadata at packaging time and
that's what i'm using with the jar
commands here now what have I got I've
got a nice clean module graph from the
bottom up I've got my three Jackson
modules and the dependencies are very
clear among those mutton among those
modules and on the platform modules
underneath I'm now going to run this now
running this is a little bit complicated
because we still have jar files at the
top the application is still a set of
jar files on the classpath the libraries
that it's using our modules the
platforms underneath our modules so I'm
going to be mixing the classpath and the
module path for this scenario so we
touch
this in the intro deck this morning and
mixing the classpath and the module pad
to support migration and this is a
scenario where and you need to do this
because the application still on the
classpath so let's look at the the
command that i'm using here so i'm
specifying the module path where to find
the modules that's we looking in the m
Lib directory will see three Jackson jar
files in there there are modular jars I
have retained part of the class path
that has my app and the little helper
library my lib they are still on the
classpath now there may be thousands of
modules in the emblem directory how the
module system know which ones you're
going to use because there's nothing in
my app on my lip to say what modules are
used uses so this is why we have the add
mods on the command line to tell it that
we're making use of the Jackson databind
module so my command line has got a
little bit complicated here because I'm
mixing mixing modules and class path but
that's okay for now anyway we'll bring
them all together in a few minutes okay
so what have we done here we've done the
equivalent of what Alex has done from
the bottom up Alex went a took the the
application and the the my lab made
those modules made made the modules that
are dependent automatic modules and
we're now gone from the bottom up and we
have just got the Jackson libraries as
modules but we still have the
application on the classpath so let us
go and see what happens when we run this
and the reason I want to go into this is
just to show some of the more advanced
topics that one getting one gets into
when migrating to modules so let's run
this and see what happens
I get a scary exception so this is the
second presentation I've done today with
scary exceptions I don't mind doing this
because they're so close to Halloween
there's lots of scary things can
actually happen what is this scary
exception saying this scary exception is
something called an inaccessible object
exception mmm never heard of that what's
going on here what's going on here is
that code in the data binding module
gate data bind module has somehow got a
reference to some type in a module that
it does not read why did Alex not have
this problem when he was running well
this is part of the magic when Alex said
that automatic modules automatically
read all other modules you don't get
that for free when you're writing your
own module you have control over what
modules you actually read so the data
binding module is one is is one that
it's a bit of a serializer deserializer
it's been handed some references to some
random module that it knows nothing
about and it's using core reflection or
set accessible to bypass access checks
and it fails why does it fail well it
fails because the data bind module does
not read now this unnamed module that's
as I said this morning in one of the
presentation ignored the term on name
for the moment just think of it as
classpath Alex will cover a lot more of
this in the 530 session here here today
so okay if you understand readability
you nurse and access checked you can see
why this fails but how am i as a library
maintainer going to be able to deal with
this because I'm always going to be
handed types in modules that I don't
read and this is where the reflective
API comes in to the to the solution so
java.lang reflective I things like
java.lang field and constructor and so
on there is a new type in in the in the
jigsaw bills which is
to guess a reference to the module for
for a type there is a javelin there's a
mem others a third as a method on
java.lang.class to get our modules to
get the module Sosa get module method
now what do we what if we get a
reference for module what methods do we
see well there's a bunch of methods and
you can look at the online javadoc and
get a feel for it but you can ask the
module what its name is and you can get
its original module descriptor you can
do a few other things but two important
methods on this on the java.lang reflect
more can read and add reads so you can
ask the module ask a module do you read
this other module and if you are a
module then you can you can add a read
edge to the graph at runtime and you can
only do it from your own module so you
can eat so you can you can you can as a
module read any other module every one
time so in our example and we're given
some type a reference just give them
some type in some random module that we
know anything about than me as a
serialization library or data binding
library I can say at runtime I want I
need to be able to read that module
temporarily when I say temporarily is
this until that module gates G seed or
whatever and that if that type is then
exported then I should be able to access
it and this is how we get a lot of
reflective and serialization code to
actually to work so what would be the
patch to this library to make use of
this API well it'll be something like
this I find out I'll give given some
class object I call its get module
method now gah say a reference to a
java.lang.reflect.method.invoke
unnamed module and it means that the
code now works the way you expect so to
work the same way that I did with Alex
when he had these Jackson modules as
automatic modules so this is just part
so the point I want to get across in
this part of the presentation is is is
that making the effort to move your code
to modules sometimes will require some
modifications to that code so we've gone
through all of this in the JDK so the
JDK I like to think of is just basically
a bag of frameworks so we've got the GM
X's and with the the Jax's the jacks
bindings we have the web services we
have all bunch of different different
api's in the jdk in Java Sea we've
already actually ported every one of
these over to modules and so we've
already built up quite a bit of
experience actually porting these
frameworks over to it and to help us and
validate the API that we have proposed
and 49 and and once you've been through
this once or twice the amount of effort
required is not all is not all that much
the changes tend to be quite small for
that code to work work working modules
ok so let's now try and put it all
together we've got Alec supported the
the the application
jar file and its helper two modules
pretend that I've got imported all of
the libraries two modules and we will
try to put them all together so starting
at the bottom this is what I have this
is my nice module graph and now we will
add the other modules on top because
they're now nice first class modules as
well and we end up with this nice module
graph so this is the this is quite this
is quite nice it's quite clear what the
dependencies are there's no cycles and
and if of course it makes it easy to run
because everything is modules let's
assume that they're all compiled and
packaged into modular jars and the
envelope directory then I'm down to two
to the one command so this is this is
quite nice okay I have a so that's
mostly what we wanted to talk about
porting our third migration and an
adoption of modules I have a couple
slides just on linking again and the
quite a few questions came up from the
intro this morning but we can actually
use the example that we've worked
through here and see how this works with
linking as well okay so i've got a jail
in command here module path tells us
where to find the modules i'm going to
add one module to that to this image
that i'm going to go and create here's
my output directory and let's see what
happens so for those that were here in
the in the earlier sessions this morning
you know that what we're generating here
is a magyar image this is like a runtime
but it's the it's the JDK 9 version of
it this runtime image is a custom image
it can have standard modules JDK modules
third-party libraries it can have your
own application and in this example I'm
going to create a runtime image that has
my application and of course all of its
transitive dependencies so Ranvijay link
command I've given on the module path by
the way there's two directories I've
given on the module path one is where to
find the JDK modules secondly is where
to find the the other modules that I
that that will need to get linked in my
app and of course all its dependencies
what's in the modular image well it's
got a bin directory where I've got come
want the binaries it's got the lib
directory that implementations stuff in
there it has a conf directory with
configuration files let me look in the
bin directory because that's the most
interesting one and I've got the Java
launcher in there and oh this
interesting 1 i've got a my app launcher
in there as well someone asked about
this late in the previous session so
this is this is generated and because my
app that Alex generated earlier on has
an entry point when Jalen creates a
runtime image with for a module as an
entry point then it will generate a
launcher for that so it's generated am i
up launcher for this application when
you do my job at least miles to see what
modules are in that runtime image then
I've got this small little list it's got
my application my lib all of the
transitive dependencies and then just
the minimum number of platform modules
that this application requires so that's
actually quite nice I've ported my
application to modules i ported this
these Jackson libraries two modules I've
now created runtime image with just
those in there I can I can deploy that
which is actually quite neat and the way
we can run that is by java dash mne give
it the module name nomas your pack need
it because it's all in the runtime image
or if I use the custom launcher I can
ignore all of that and just do my app
which is which which is nice ok I think
that is essentially what we have so
summery and the most important thing to
take from this talk is that we have you
if you have the freedom to adopt a
migrate to modules at your own pace you
don't have to do it from the bottom up
you don't have to do always depend on on
other library maintain errs to port two
modules first there is a possibility
with the automatic modules for you to
move to modules before they do so you
cannot modulate your application before
it's libraries
if you're a library maintainer then you
can actually go from the bottom up and
you can module eyes the library's
completely independently which is which
is good another thing to learn from this
session is an explicit versus automatic
modules we were writing module infos
compiling them at creating modular jars
they're explicit modules I'm taking the
effort to migrate those two modules
myself automatic modules is where we
just treat a jar file as a module that
requires everything and exports all of
its packages we just treated at treated
as a map as a module so you can kind of
think of this as two different types of
modules the other thing to take from
this talk is that when you make the
effort to migrate some library to
modules then there may be some code
changes required I deliberately picked
an example for this session that
required changes to that code because it
was essentially deserialization library
that needed to use a reflective API to
work properly with with module eyes with
modules so that's it I am leave you with
this one message go forth and module
eyes
okay um so mark mentioned about the
other sessions we're back in here at
five-thirty for alex is under the hood
talk which is essentially continuation
of this into another session and we're
back here Tuesday mr. tomorrow morning
at eight-thirty for the hack session and
then we also have some repeats of the
intro and prepare for JT canine
Wednesday Thursday Friday more
information and links to the project
page where you can find all the
documents jep's or the other material
mailing list pointer as well to the to
the early access bills and that session
so questions so right so we don't what
we're going to do for questions is
because this is recorded and streamed is
if you wouldn't mind if you've questions
coming up to the microphone so that it
gets a victim so maybe this is not a big
of a deal once you've linked but let's
say you're using module path what
happens if somebody tries to replace
with the trying to export java.lang or
your security packages to override your
security is there never will happen ok
so it's so someone I've inconceivable
River right sojer means it's in product
okay so there's there's something we
didn't talk about today which is the
system module path that's where all the
platform modules come from okay is you
can think of that as coming before the
application module path so we will never
look for java.lang.object in down the
application module Pat because it's
already in Java base it'll be found
there first before everything else so
how about your own how about application
specific stuff you're providing a
libraries or and it's got a security
layer in it of course everybody can
reverse-engineer it see what the
interfaces is see what the signature is
implement their own bypass your side
right foot okay so we want to talk about
hashing good sir okay so this is an
issue that's come up and you
sure so there's there's more to it than
just put it putting something on the
right path and hoping that nothing gets
in front of you a thing that we've
prototypes not not just for modules in
the JDK but you're used by others if you
want is if you have a a tightly coupled
set of modules and you want to ensure
that you know your app module only ever
uses you your security library module
you know from a specific build then with
then when you package them you can bake
them make a strong hash of your security
library module into your app module and
the module system will validate that
when it resolves and validation fails
just that's what I wanted yeah ok so the
integrity is is is something we take
pretty seriously but it's optional
because in many environments you know
right you have complete control you
don't you have you trust your consumers
yeah so you'd be between that and a
couple of other consistency checks
nobody will be able to redefine
java.lang if you try out the jigsaw
bills have a look at the jar command
look at look at the help option you'll
actually find hash dependencies option
in there for generating those hashes
when you generate those macho jar so
we're trying so for a dependency
injection framework like spring how are
you handling if it needs to get access
to something I don't export is there a
add export or something in the reflect
so that so a repeat the questions i
understand it for dependency injection
framework such as spring how are we
dealing with it when it needs to inject
into something that's not exported aight
well that doesn't that won't work if
you're using a framework that needs to
do deep reflection then you need to at
least export the relevant packages to
that framework module with a qualified
export or maybe just export it generally
it's up to you there is there is no
there is intentionally no reflection API
for breaking an encapsulation boundary
the only way to break into capsulation
boundary is from the command line
because we assume that if if you have
access to the command line you have got
like bars you can do anything any
but we're trying to take take the stand
that integrity from within the running
java process is to be maintained so how
can I speak up into the mic please okay
thus these are protected ixil is it
compatible we always shines no it is not
compatible with osgi but osgi will run
just fine on top of it and in how about
like oh that is also support that hot
deployments like a osgi style jigsaw it
does not does not does not directly
address Hawtree deployments but neither
does it get in the way of other
mechanisms that might do Hawtree
deployments there there is a certain
level of dynamism in the layer mechanism
which is probably the most advanced
concept in jigsaw where you where you
can spin up another layer of modules and
tear them down later but that's that's
not necessarily what people mean when
they talk about hot redeploy so what
about the web project like waffles you
would have to talk to somebody who works
on java ee standards this is so we
obviously we talked to people who work
on on the EE specs you know long term we
hope that there will be a way to have a
modular wire file but exactly how that
will look we don't know but we're trying
very hard to make sure the foundation
we're building will be good for that
thank you what about to Jay and I if I
have a module that too needs dll's or
something it's so far for something like
that yeah can I bundle it somehow with
my module or okay sure so so modules can
have native code and works exactly as it
does today and we have some additions to
the jni API to be able to things like
get module and so on and
you can link modules that have native
code into runtime image that all just
works fine too so you you are using the
chart tool to define the main class in a
module so I would have expected it in
the module in for that job or so why
isn't it there and you need a second
tool to define it sorry I didn't quite
hear that so why do we need to do this
at the main class yeah so why is it not
just in the module into dock travel this
is the extended melody if you want to
take this so there's we've tried hard to
keep the part of the design that affects
the language and the virtual machine as
simple as possible they contain only
only the essential information that's
needed by the compiler in the vm and
leave other things especially things
there that are often used to
reconfigured in in your build system
from time to time and are they aren't an
essential property of the probe your
program if you're thinking if you're
thinking primarily in Java terms you've
got you know methods and fields and
classes and interfaces and packages and
modules that compose those and that's
all that's all that's really appropriate
to talk about in the light in the
language in the vm so even from that
point of view saying well what's your
main class well the language in the V I
mean the vm does need to know it to
start up yeah so hey we truth be told
we've gone back and forth on this and
earlier prototypes we actually did have
the main class in in in the module
declaration so in your source code you
could say you know main whatever class
name but then that got tricky because
especially once we had J length with the
linker tool that could make a custom
image well okay you've got a main class
but you usually don't use the whole name
of the main class as the name of your
command line launcher you want some
short name now do you want to put that
short name in your source code and maybe
maybe not what if it needs to be
different on Windows and you have a
different build for a different OS it
becomes much more of a build time
configurable thing and so we just took
the whole name
concept out but it's still there and
when you add packaging time when you
make a modular jar you can say this is
my main class and you can eat and you
can also say with the name of the
commander I thanks for the talk I wanted
to talk about module exports since you
mentioned and you had in your example
packages I'm assuming that once a
package is declared everything below it
automatically sub packages will be Auto
exploring they will not so they
explicitly said no sub packages and job
java are really it they're nothing more
than a syntactic convention if a package
is a sub package of another means
nothing they have no semantic
relationship other than that they share
a name prefix so there's no there's no
export of sub packages there there's no
export you know kombu bar star star you
really have to ask for each one so for
very large projects that have a lot of
packages there is a certain level of
maintenance required to go and scan and
figure out exactly what what requires to
be exported well that's what jdubs is
for and from a you know software
engineering perspective well it's it's a
good thing to be aware of okay this is
my module here the packages on exporting
and therefore all the others I'm not
gotten all right thank you if you want
to modernize a library that depends on a
third party library that hasn't module
support yet is there a way to go forward
without assistance from that third party
yeah so when you write the module info
java file for your library your you are
the library maintainer welcome we hope
you enjoyed the second half it was for
you right so if there's a module if
there if you've got some jar apache
commons logging or something that is not
yet a module you can still require it
but in your build and test and indeed in
your documentation you will have to tell
your end users to put it on the module
but you will yes to put it on the module
path to put
Commons locking jar on the module path
so that when your module is resolved and
that requires Commons logging clauses is
seen the module system can find from the
commons locking jar oh this is an
automatic module as if the commons
logging people had had modularized it
themselves if you don't want to require
I shouldn't say require because we say
requires and sort if you don't want to
cause your end users that trouble then
and in other words you you just assume
that the jars that you depend on are
just going to be on the classpath they
aren't going to be in named modules even
automatically for some time it depends
what use I can offer you some some
techniques it depends what use your
library makes of those third-party jars
if you're using them widely and you have
many references in your code to their
types then then a reflective solution is
not going to be right for you if there's
a third party library that we have this
for example bootstrapping the JDK if if
your library depends on another library
only in very particular ways and perhaps
the other library isn't even present
right perhaps you can work without it
there I show an example of that in the
next talk then you can do a class not
for name on one of its types get its
module even though it's on the class
part you can still as Alan Shope get
that unnamed module you can call out
reads feel library to then read that
module and you can invoke its methods
reflectively it depends how your library
is using the third party library well
hell the third party libraries using the
fourth party library at the same time
don't forget it you could have release
notes that would say for example you put
make sure you make sure the jar file I'm
giving you is on the module path plus
Commons logging put that on the module
path or just leave them both on the
classpath
because that that will still work in you
know legacy classpath well it's somewhat
unrelated question how do you envision
tools like Nathan to migrate in this
sensor that's a whole other talk but Jay
I'm Jason vans ill is in the model
system expert group and and we hope to
work with all tool vendors to make sure
that their support for the stuff when
Javed on comes out but there's no
concrete plan at the moment how that
will work I don't think there is no it's
it's a bit it's a bit early for that but
I expect there will be let me just make
a point about that the day that JDK 8
was launched with lambdas in it not only
did Java Sea and netbeans support
lambdas eclipse the same day supported
lambdas modules are not like that
they're not a little language feature
that an IDE editor and type system can
support and give you red squiggly
underlines and then the feature is
supported you can see modules are about
the tools and your scripts that are
currently setting class paths sorry
about that and it's a much more
distributed problem so that the day jdk
9 comes out is really the start of the
answer rather than everyone can all of a
sudden use modules you know up and down
for free come to the mic please I've
just come to the mic please we're
streaming sorry I'm Manford most I'm
presenting with Jason about the pageant
even on Wednesday but I mean in terms of
the multi-module support is multi jdk we
have like some of the maven committers
have done a prototype implementation
we're in a multi-module projects you can
already create this multi jdk char kind
of artifact that's already possible we
are working towards improving that in a
single model and stuff but there's
ongoing work at
when you call a module adry does it
matter what context class loader is said
we have no interesting class loaders
okay we didn't say what I'm going to go
I'm going to go with that because it
makes someone we didn't say the word
class that are in this presentation
thank you my next talk I cover class
odors a lot actually primarily to say
how little I am how little interested in
them I am it's what we get rid of them
but the module system is somewhat I
don't know say it's orthogonal to class
lenses yeah there are still class notice
that's you can't not load a class in a
class loader but they are not the prime
know there something we suffer their the
primary mechanism they don't provide
encapsulation right they're pretty damn
on their own they let you get into
cycles it's Ahmed's very low-level
mechanism if you've built a module
system on class voters you've been
relying on a very low level mechanism
which is why we you'll see I introduce
some other constructs one question is it
possible to create multiple modules for
a single jar well do you mean multiple
modules in a single jar correct no but
you're the third person to ask that
question in two days oh yeah Boober jar
with multiple multiple modules in it
right now no but it seems like it's
something we need to think about I meant
make an image well that's not always the
right answer thank you it's currently
it's never the right answer cuz you're
gonna wish it out yeah yeah do uh do it
are we out of time okay thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>