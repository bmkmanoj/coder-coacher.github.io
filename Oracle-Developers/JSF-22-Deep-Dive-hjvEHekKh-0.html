<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JSF 2.2 Deep Dive | Coder Coacher - Coaching Coders</title><meta content="JSF 2.2 Deep Dive - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>JSF 2.2 Deep Dive</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/hjvEHekKh-0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome so this session is called the
jsf 2.2 deep dive
so we'll be basically spending a couple
hours talking all about JavaServer faces
2.2 and JSF in general okay so just a
few words about myself my name is Quito
you can find me at Quito 99 on Twitter
I run a consulting company where I do
training consulting architecture and
mentoring mostly around JSF Java EE and
Liferay technologies
I'm also the US partner for primefaces
which is one of the JSF vendors although
I do work with different JSF component
suites as necessary I wrote a book like
a very long time ago out of print now is
anyone read this book I'm just curious
if anyone actually still remembers it
okay a couple people occasionally
someone will say hey I remember your
book but it's a long time ago I run a
website which needs serious UI work
called JSF social calm I also run a I
don't run by I participate in an
newscast it's a podcast called the
enterprise Java newscast and every month
or two mean a couple of guys he in the
Labatt's and and in Xhosa spend time
talking about Java EE Enterprise
Development some JSF some spraying some
Scala some everything Enterprise so if
you listen to podcasts I encourage you
to check it out basically just go
through different new and leases from
different products and ramble about
different enterprise technologies I also
speak to lots of conferences and I'm a
member of the JSF expert group and I've
been involved in other ones like that
JSF portlet bridge and portlets as well
so before I get into more detail I'd
like to know a little bit about the
audience here we've got I've got a good
group of people
how many of you guys have currently are
currently working in a JavaServer faces
project ok good so we can skip the intro
stuff ok how many people have you know
maybe dabbled with it or heard of it
aren't really too too familiar with it
okay so a few okay so for you guys will
I'll try and fill in some holes along
the way okay but that works out well for
our topics so um just just one quick
slide about one JSF is for those of you
who aren't that familiar so it's a
server-side UI component framework that
actually ships with Java EE it's part of
the Java EE stack and what server-side
means is that it has UI components well
the UI component part means it has UI
components but essentially UI component
is something like a widget or a data
table or tool bar or something like that
it has some sort of representation in a
client device usually a web browser
usually sends down JavaScript and CSS
and HTML and all that stuff and then
there's a server side component to that
server side as part of that component as
well that lives on the server and that's
why it's called JavaServer faces so
that's sort of the the key part of JSF
is really the component framework
because as Java developers we can build
UIs using you know fancy looking UI
widgets and and build a good user
interface one of the things I think that
is a little often understated though
about JSF instead it's really a powerful
MVC framework and you know MVC has been
overused in not lots of different ways
but you know just think of it as a
controller framework where you know you
can separate your view from the rest of
your application and in JSF has so many
features for this I mean you know
everything from you know navigation to a
way to access different parts to your
code you know backing beans to
internationalization handling resources
you know and now there's lots of new
features in JSF too that kind of really
add more more power to that so there's
really a lot of stuff in there even if
you don't worry about the UI components
I mean there's there's like you know an
application framework there okay so so
keep that in mind as you go down the
road with JSF another thing about JSF is
that it has server-side templating right
and this is usually done with facelets
which is just a way to express your
different pages that are part of your
application and also
basically specify parts that you can
reuse in different parts of your
application as templates how many people
here are not using faithlyn's let's say
you're using JSP or JSP X or something
just curious okay so a few of you now
these legacy applications are they
newer than legacy or okay all right good
just checking
so the general consensus in the JSF
community is that JSP is not a good fit
so facelets is the standard and any new
features I'm talking about in JSF 2.2
that relate to markup and a web page are
exclusively facelets features they don't
work in JSP so keep that in mind if
you're on a JSP project and you need to
use one of these new features you
probably will have to convert that part
of your application to facelets in order
to take advantage of it okay so as I
said before JSF 2.2 is part of Java EE
so 2.2 is Java EE 7 and one of the
traditions with JSF is that you can use
it to with older versions so it runs on
Java EE 6 containers JSF 2.2 came out
about a year ago and I know a lot of
organizations are pretty slow at
adopting new technologies so I'm curious
how many people are actually using JSF
2.2 features now even if you have like
JSF 2.2 running but using all the old
stuff that doesn't count
so if you're using that she has to have
two points two features raise your hand
look that's though if you do I guess you
probably may not be here if you were
really using a lot of them so and how
many people are using a Java EE 7
container that I curiosity
ok so not that many ok so the good thing
for you you can run JSF 2.2 you on an
older container all you really need to
circle at 3.0
ok and for things that require Java EE 7
there's graceful degradation it's your
application is not going to break
there's some code that does use the
JSONP jsr which is part of Java EE 7 but
your application will still run if you
don't have that ok
so one of the key things about JSF is
that the component suites are really key
okay and as I said before they render
HTML CSS JavaScript all that fun stuff
and I think one of the understated
things about JSF is they're really great
server-side integration so for whatever
sort of UI components you have there's
usually a very simple way for you to
declaratively integrate it with the
whatever objects you have in the rest of
your application on the server that's
really one of JSF strengths how many
people are here are using face I'm sorry
a primefaces its grace well okay how
about I spaces do you okay
rich faces these are all different
component Suites if you're not aware
let's see what else is there Trinidad I
pick some old things here uh-huh okay
anyone using any other component Suites
which one oh yeah well on my face this
is a really component suite so only feel
me faces is a really great utility
library so it's pretty much that's
actually I'm not really talking about it
here I should go talk about that but
anyways if you're working on a JSF
project and especially a new one check
out how many faces because basically all
the utilities that you think of writing
they've already written for you and it's
really great utility library its have a
few components in there oh you are okay
I think I think I know about that one so
since most of you guys are using
component Suites I'm not going to do a
demo of what components are like we'll
go to the you know the actual new
features of JSF 2.2 but I do want to
take a second to talk about a new
component suite so one of the things you
know when I initially started with JSF
it was like 2002 2003 and I thought
there are going to be tons and tons of
components weeds just like you know the
Microsoft world where there is all these
different components Suites any other
word decent amount for a while but it
basically settled to those
you know rich faces ice faces and Prime
faceless and you know different ones
have been more popular at different
times and I didn't know at the time I
thought there might be more commercial
ones there were some commercial products
along the way that didn't make it an
open-source went out because open-source
is popular in the Java community so
there's been three but I'm very happy to
hear that there's a new one and I'll
spend a minute talking about it and then
I have someone here out I will ask a
couple questions too so there's a new
one that is called alloy faces and all
my bookmarks are gone because I had a
reboot so so how many people here have
are familiar in some way with Liferay
okay so a decent number of you and of
course my actual bookmark is gone now so
if we can find the page it will save me
some time there we go that's the Wi-Fi
so the password is open world
Oracle 2014
you can actually connect any
all right so while we're hoping that
loads um I'll tell you what what
actually it is so so light for a has a
Portland Bridge and say anyone I guess
those of you who are familiar with my
frame and work with a portal before so
portal servers are basically application
frameworks would let you sort of compose
your your entire site that have
different little applications that can
be arranged and personalized and
customized for different people and also
you can arrange them on a page etc etc
and Liferay has a Portland bridge which
you need in order to use JSF with a
Portland okay and so does every other
Portland vendor whether it's JBoss or
IBM or Oracle or whoever okay
but life Freight is taking us to taking
it a step further and they actually now
have a suite of components which are
really not limiting here which actually
wrap their own UI a javascript are sort
of UI framework called alloy so they
have something called alloy which you
can use without JSF you know with any
back-end technology and they've wrapped
those components with with actual JSF
components and what's great about it is
that you can use it inside of Liferay of
course but you can also use them inside
of a a another basically a normal web
application as well which is great so
and the reason I was mentioning today is
because this is actually the official
announcement which is left fanfare that
I'd hoped so so they're basically
announcing the sweet add at JavaOne I'm
gonna try a different network is there
another Oracle world network or is it
just so yeah I just try that let's just
go how about this is
which ones that
still Oracle Oracle 2014 okay
so I'm just having a bad day I don't
know why it seems to be trying to do
that yes this actually worked it's
cached I will try this one more time
see if safari has any better luck
this is going to cause problems from our
next presentation which actually
requires lots of difference okay
well unfortunately it looks like well
we'll see if magically my internet comes
back yeah sure what do you want a ping
hmm that's bad sign
yeah I don't know I don't want to really
want to spend the whole presentation
trying to debug this so um I will go
turn it off and turn it back on
sometimes that helps right
ya know such like
okay
yeah that's I've already tried that
today okay so my network connection
notwithstanding just like go back to
this other one try this one more time
yeah I don't know why it's trying to why
thinks there's a boxing but if we're not
getting anything from Safari either it's
not really gonna be happening yeah okay
so Neal I know adding it's show anything
who'd is right thing you want to add
Neal by the way is I would do that but
we had so much trouble getting it to
come back not last time I'm afraid okay
so we your L is what no way frame that's
it all right
here we go so yeah check that out um
neil griffin here is are you the lead
for that project as well okay so I do
have a mobile JSF session later today
where hopefully the demo I had a demo
working in that iPhone simulator
hopefully that'll work
so so if you have time for that one
maybe I could see the opponents there
but check out that you were out like
free faces that warm web guest showcase
and there's some similarly a nice
components there as well okay okay so
fortunately rest of my demo doesn't rely
on the internet so we should be okay is
it
okay so did and if everybody didn't hear
that he was just asking if alloy comm
was the same lui comm it's the same
thing and Lau comm lol u dot UI calm is
the actual JavaScript you know CSS
component suite and alloy faces is a JSF
integration with that sweet so they're
slightly different okay alright so
moving on so J step 2.2 is is sort of a
nice release because it it's basically
just builds upon what we already have
you know tries to fix some issues that
people have been having but also it has
a few sort of major new features which I
think have been a little understated ok
so let's talk about this a new feature
so the number one new feature is html5
friendly markup and this is basically
the idea that if you want to you can
build your view your pages using a more
of a pure html5 approach as opposed to
the JSF tag based approach or you can
mix the two which is probably what more
people wind up doing ok and the other
sort of reason for this is you know
basically to support html5 in general so
let's say you have an existing
application or you are using the normal
chance of tags and you just want to add
an attribute that is now a JSF and
that's an html5 attribute that's not on
the component then you can just use what
we call
pass-through attributes to add those to
the component and then you can provide
that support in the browser
okay so we'll talk more about that in a
minute another new feature in spaces
flows and how many people have heard of
Spring web flow before ok what about um
I think it's a DF faces cash flows yeah
okay what about my face is Cody anyone
work with that before
ok so you you're familiar with some of
these things so so basically faces in
JSF 2.2 now has full support for what we
call faces flows which is basically the
ability to define a set of pages using
transitions and nodes state
much like spring webflow or any effaces
test flow okay and there's lots of
things you can do with youth which we'll
talk about in a minute another feature
is cross-site request forgery protection
which is just basically a security
enhancement to talk about later another
feature which I'm happy with is loading
facelets via a resource handler so if
you've been working with JSF for a while
you may have noticed that you know in
JSF 2.0 we added this whole resource
mechanism which was really nice and it
didn't integrate at all with the way
that facelets were loaded
so now and JSF 2.2 facelets are loaded
in the same way as the rest of the
resources so there's basically one entry
point if you want to handle an incoming
request to resources called the resource
handler so I think that's a nice
unification it's also a file upload
component so this is actually part of
the JSF standard now I'm not really sure
this is that big of a deal so into every
component suite has a file offload
component but it's good that we actually
have support in pure JSF so regardless
of which component suite you are using
you can use this this feature as well
okay another feature which I like a lot
is called resource library contracts or
multi templating and it's sort of a
multi templating is a better name I
think but resource library contracts is
a nice boring name we ended up with so
basically all that means is that there
is a way that you can basically swap out
templates and style sheets and
JavaScript and stuff in lots of
different ways so let's say you had an
application and you wanted to have a
different sort of layout for different
types of users or a different layout for
different clients maybe you customize
the application for different clients it
gives you lots of flexibility for sort
of changing the way your application
looks either you know there's lots of
different ways you can do it which we'll
talk about so so that's a really nice
feature as well
so let's look at these in a little more
detail so as I said before one of the
key features of the html5 friendly
markup is making it easy to support new
features of a browser without writing a
new component so you know if you're
using a component Suites it doesn't
really have let's say an auto focus
element which all the HTML elements have
now you can just pass that element
through and still add it to the
component tag markup without having to
you know write a new component or
anything another thing is you can use
pure HTML with special attributes to
indicate JSF components so let's say you
really want to just write some pure
markup or you've a designer that's
writing HTML and all you want to do is
say ok well when you post this back to
the server now I want this to actually
be handled as a JSF component we can do
that as well okay so there's a lot of
power there and we do this with two
things one is passed through attributes
and one is passed through elements and
basically the idea is that they are
passed through to the browser without
interference from JSF hence the name
passed through so that means that JSF
doesn't look at it it doesn't really
it'll parse an email expression for you
but it's not gonna do really anything
else okay you know just pass that back
to the browser for you and they are
rendered on the topmost element of the
component which you'll see in a minute
another thing which is interesting is
that html5 is now the default doctype
okay so if you have an application then
you don't want html5 to be the default
duck type we need to actually turn it
off okay so the you know pretty much
anything in JSF you can turn on and off
so html5 is a default doctype which a
lot of people will like but if you don't
like it you can turn it off with this
little information here just in your
faces config file you can turn off that
extension okay
so pass-through attributes so here's an
example of an ordinary select one menu
component and if you're not from there
we're select one menu is just a
drop-down control very basic component
and you see this is a faceless page and
you see we have a couple new namespaces
look actually there's a few things here
so if you've been using JSF for you know
any longer than a year you probably
noticed that this xmlns thing looks kind
of weird it's not Java dot Sun calm
right so the namespaces have changed all
the old ones are fully supported I'm
sure they'll never go away because
that's the beauty of Java is nothing
ever really goes away right so so but
you know we encourage you to use the new
namespaces and of course this makes
sense because now it's not tied to
particular company it's just tied to the
JSP and the JSONP network okay but
there's also two new actual namespaces
here one is passed through and one is
well the core is already there but the
new one is to pass through elements
namespace so you see what we have two is
two things here is two things so the H
such one menu never had an auto focus
attribute before right a lot of throw
this is part of html5 it just means that
that component gets focused
automatically you know pretty
straightforward so if you want to add
that component to the market that's
Jenner I mean that attribute to the to
the markup that's generated by this
component you can just say whatever name
is face you chose whether it's PT or
whatever you want
I'm calling whatever the attribute is
and then the value okay missing a quote
there and so that's one very easy way to
add pasture records right the other way
that you can do it is you can say all
right well really what I want to do is I
just want to add the attribute this way
I don't want to put this all top of my
tag I just want to say add this
attribute to this component here okay so
here we're saying this is a pass-through
attribute this is the name this is an
html5 data attribute which you can use
to specify data that's usually consumed
by javascript in the browser okay
so we're just passing this anatta
attribute because it's like what menu
doesn't have all these you know
arbitrary data attributes on it right
because basically with a data attribute
it can be whatever you want so and then
here is another example where we're
grabbing it from the application so
maybe you have a map of all the
attributes you want to add okay so you
have three different choices here no
generally you're not gonna use all of
them in one component you'll probably
use one approach maybe two okay but this
gives you a very easy way to support
html5 using your existing you know JSF
tags regardless of you know what
components we do this or anything okay
as long as it has to have to point to
support any questions so far
okay so the other way that you can do
html5 is using pass-through elements so
a pass-through element is basically sort
of the opposite okay
so before we had to go back here we had
a JSF tab right width and we were
passing through attributes to it right
in this example we are specifying the
HTML elements and only earmarking the
JSF related attributes okay so it's kind
of flipped right so the first approach
is what you would use if you're going to
use normal JSF tags to write most of the
stuff on your page right this is the
approach you're gonna use if what you
really want to do is write pure HTML and
uses little JSF tags few JSF tags as
possible okay so this approach you have
an ordinary ordinary input element you
put whatever attribute you want on it
and then for the for the attributes that
you want just have to pay attention to
those are the ones that you actually put
in JSF ID in front of and you see we now
have this other namespace here called
yourself okay so you can just specify
these as ones that you want just have to
pay attention to and as we know a JSF
usually has a value attribute so we
specify that we use this if you want
this to be treated as a JSF ID
okay here's label as well it's not
highlighted for a label this is used for
error messages right so what happens
here is is a little bit different though
what's happening here is the rendering
of this component is done here like this
is what it's going to be rendered like
with the exception of course in the JSF
attributes okay
upon post bacc that's when the actual
server side component will be involved
okay so this actually gives you more
control over the rendering of the
component than the other approach okay
and this is why this is more more
friendly to people who are actually
writing more HTML than people who are
just writing JSF tags
okay so let's take a look at this in a
little more detail
let's hope that a clip still works
alright so I'm gonna start my app server
here okay
so
this is just an ordinary JSF application
right there's nothing too special about
this it's got you know faces configure
this is just generated by two clips it's
gotten so entire library has web.xml and
it has this login XML page XHTML plates
so the login page is pretty
straightforward
well essentially not my day
alright let's go back here see if it's
actually loaded yeah oh I still started
doing
that's weird because if anyone's work
with Bob fly usually it's like starts in
two seconds it's a little strange here
okay I'll get with the benefit of the
doubt
okay there we go
I'm gonna turn off Wi-Fi guess it's
somehow magically interfering with my
networks up here okay there we go all
right so this is the login page very
exciting right so you know I'm going to
type in my name and then type in
something here then I'm gonna hit submit
and then I get this error message and
you can read it it says that way toward
it's a please match the present format
till must be five characters long okay
and make this a little bigger and you
know buddy I'm talking let's say I am
even blink because it's needs to be
filled out so I get some validation and
you know if I actually type in stuff
properly I can log in and see a very
poorly a very ugly old app there we go
so all right so this is a very simple
page let's take a look at how this is
constructed okay
so let me increase the font size little
more here
all right so first thing I notice I have
the doctype HTML which actually gets
generated automatically you can really
leave it out but it's just nice to have
it for informational purposes okay then
we have these new namespaces Pte or pass
through or whatever you want it to be
JSF these are standard error standard
JSF namespaces down here okay and then
there's a couple interesting things in
here so we have head okay and how many
people are using an older version of JSF
like JSF 1.2 or god forbid 1.1 okay good
most of you're not that's good alright
so if you use JSF too you know that
you're supposed to have an H head H body
inner page or else things might not work
right right so if I just put head here
okay without anything else this would be
and this would not be a JSF component so
I wanted to be H head so I can put
resources in there and stuff properly
okay so I can specify the head okay and
you see I've got this JSF ID part right
so generally the rule is if you have an
element and you put JSF : ID in it and
it's a normal HTML element JSF says up
it's an HTML and it's actually supposed
to be a chance that component and then
there's actually a table that it goes
through to decide which component that's
supposed to be and usually that depends
on the some combination of the actual
element name and perhaps some other
thing like whether or the name of the
attribute that you're saying is a JSF
attribute so for example here I'm saying
JSF ID so it's going to look at the head
and say okay well they want to use the H
head component there okay here I'm
saying JSF name
yep saying oh well you know it's the
this this is a link right so and it says
rear wheel stylesheet so he probably
wants this to be a style sheet okay and
they need this is another one which I'll
talk about in a minute this is actually
loading another resource from from a
library from primefaces and this is a
part and phases component which I'll
talk about a few minutes okay so you see
this is ordinary JSF markup but I base
it
tags all of these to be actual genius of
components to some degree okay so just
to keep things simple I'm going to
comment out this part and actually I'm
not going to delete it
okay it's now I've got a very simple
page on I shouldn't actually see
anything okay so I don't see anything
but if I look at the mark-up this is
what I see right so is the HTML
I see a giraffe you know just normal
link tags you can see that it does did
the resource resolution by looking
inside looking at those link tags and
saying okay these are JSF resources and
loading them from the resource path for
JSF and then sorry about that
then I also see the title okay now
what's interesting here is if let's say
I took that out right
let's say I got rid of name proteins are
pretty useless tags without its source
isn't it one of the problems I've
noticed with working is yes absolutely I
forget how to use actually HTML so so
let's say I just took these out though
okay and then for kicks I'm going to use
a UI debug component
okay so you ready brothers just the
handing you buy a debug component which
is part of jazz huh okay so so look at
the HTML and we see the this is the
component I put on the page right so all
of this is that component but you see
here these are the pure HTML parts right
so if I look at the actual data stock
component tree what I see is all of this
this is basically a transient she asked
of a JSF component has no state gets
reused across different views very
efficient right so that's what's
happening to the mark-up if I just put
arbitrary markup in a page it turns into
a transient JSF component okay so if I
go back to this and then I go ahead and
put my JSF IDs or JSF here and actually
I'm just gonna
and then we'll put the UI debug back
okay so now I put those JSF IDs back
right the JSF elements okay so so don't
see anything but if I look at the markup
I will again see those that link
references right but more importantly
for the clicking phone entry I see a
little more stuff right
I see a JSF ex face this location has
Bassett okay has a component resource
container that has the components in
there for the style sheets
I see a the head element
I'm the title element here so you see
there's more going on right so basically
what this does is gives you the
opportunity to really decide how much
you want to be JSF components now how
much you don't write in the stuff that
you don't want to be JSF components
those because that can actually be
transient components which are more
efficient and faster to render and do it
okay and will not have any state on the
server okay so let's let's the deliver
to further here okay so now we have the
body okay and again we use the JSF ID
because we wanted this to be an H body
component okay same thing with the form
but seen inside of here it's a little
bit different so these are just ordinary
dips they're not panel grades they're
not panel groups they're not any special
layout components these are just
ordinary grids our divs excuse me and so
we've got a couple nested divs and then
inside of it we have an image okay and
you notice we're using the normal pure
HTML image tag but we're saying it's the
JSF library images and look
the name of the image is logo okay so
remember the rest of these are all being
passed through but it will pay attention
to this so it can grab the right
resource okay all of this stuff here is
just being passed through we have a
normal messages component because we do
want to display messages back to the
user right we have a normal label
element
it's not even in JSF label and then
we've got something else here so this is
an example of the first approach right
this is the example of having the pass
through attributes on a JSF component so
in this example we have the normal JSF
component normal JSF attributes but then
we using pass through pass through
attributes as well okay
and we also have another pass through a
cubed here called required so there's
actually this is actually kind of handy
because what these two paths through
attributes gives us is actual support
for html5 validation which is one of the
nice features of html5 so if you're
using a modern browser you can actually
get some client-side validation without
running any JavaScript okay
so if you go back to my example here
okay remember I typed in you know
something here let's say I type in one
character right so this text here this
is all html5 this is not JavaScript
primefaces
or you know server-side stuff or
anything okay and the reason we're
getting this is because the rendered
markup for this is showing us is
rendering that element pattern right dad
was a pastor element right or attribute
excuse me I was a pass-through attribute
sent directly to the browser and html5
says oh this is a regular expression I
need to use to match this particular
input control right the same thing goes
I also had a title attribute right so
title is an
paster absolute title is on all of the
components already right but in html5 if
you specify the title attribute that's
part of the error message the user sees
back for validation error right so
that's why when I type something in here
and do the form submit I get this is the
default browser message and then I get
the title message that I had there below
it okay
so by using the pass through elements or
attributes I've actually been able to
just basically html5 eyes my normal
input control okay so if we look back at
this the converse example is down here
okay so this is the html5 element itself
right with the JSF ID attributes on it
so it's the same sort of thing but it's
their reverse so we've got the html5
attribute all in here automatically are
already let me add the JSF ID JSF label
JSF required it's interesting the JSF
required and the required attributes are
a little bit different so this is the
browser required which is an html5
attribute right this is the server-side
require you don't have to have both you
can choose to do one or the other all
right so you notice I still have
validators in here so even though you're
using the html5 element since JSF is
turning that into a JSF component on the
server on postback if you still attach
your normal things like validators Ajax
whatever you need to okay all that stuff
works the same so I could nest NFHS
component here I couldn't nest whatever
so that's sort of what's going on here
now what's nice about this approach
though is that I've by adding the html5
attributes I've now added some
client-side validation for browsers that
support it right but for older browsers
or browsers like Safari actually
supports a lot of this stuff but the
form validation is turned off by default
so if you look at this in Safari
you know I can put stuff in here that's
invalid and then what happens is it
actually went to the server and we did
the normal JSF validation right because
it doesn't do the html5 stuff okay and
that only happens because I still put
the P messages component on the page to
display the error messages and I still
put the JSF validators on the component
as well the same thing would happen if
you're using bean validation or
something else you know as long as you
use the normal in JSF features you can
do this server side as well
questions exactly exactly what he said
was was putting this having the
server-side validation as well it's been
way to ensure that it works in different
browsers and that's true okay so if you
look at this page we've got you know all
these different things we've got oh
here's another example this is the the
button that doesn't submit here this is
a normal button okay but we have JSF :
action to basically make it a JSF button
so and if we wanted to we could do Ajax
here as well um the only reason I didn't
is because it's a little more of a pain
to do the the html5 al Edition with Ajax
because you're not really doing a form
submit there so you have to write a
little more JavaScript and do something
do a couple tricks to trigger the html5
validation before so this is a simpler
example okay all right so another thing
I want to mention is you notice the
layout here so I'm not using a panel
grid and you may have noticed that
modern web development trends are sort
of anti table these days although I find
a lot of organizations still don't care
and you know I I think whether or not it
matters really depends on your target
audience and who your users are and you
know you're using you move an internal
application with fifty or hundred
internal users who cares we use a table
that means if it works that's the
important thing
um however if you you know
the benefits of having a more flexible
way to do a page like this is that you
can use other sorts of layout mechanisms
so one of the things we're using here is
a responsive grid and you know there are
tons of responsive grids out there how
many people have used bootstrap before
ok it's up but chef has responsive grid
there's tons of other ones primefaces
actually just added a responsive grid as
well um so I just went ahead and used
that here and you basically the way the
response of grids work is you include
their CSS and their JavaScript and they
basically look at the CSS selectors in
your divs and then do a fluid layout for
you ok so it's happening here is we have
included the prime faces grid library
red dot CSS and it says it basically has
a certain set of UI selectors that a it
understands bush type has a different
set of selectors it understands but the
idea is still kind of the same you can
specify the grid itself you can specify
columns and rows I'm just specifying
columns here usually there is a selector
for the width of the road that you want
so you can specify a different selector
or different widths that you want to use
and that's basically the story so I'm
basically sort of specifying how I want
to lay out this this table okay and
primefaces has also integrated this
responsive grid with their their layout
components as well and a lot of other
components are doing the same thing so
you don't if you do want to use an
actual JSF component some of them
actually just do responsive layouts
automatically now anyways okay I
wouldn't hear more about that you should
come to my mobile a session later today
okay but what this does though if we
look at the layout here so this gives
you this sort of grid layout based on
the divs that I selected but you know if
we shrink it it sort of adapts based on
the look of the page the actual width of
the page and that's sort of what the
response of a grid to do so if I was on
a phone this would look better than it
would if I had done it with a panel grid
for example okay
okay so that's basically sort of the the
basics of the html5 support and of
course you can always mix and match as
you see normal JSF tags with html5
everyone okay any questions so far
yes yeah I think I'll put it I don't
know I'll put it on bitbucket or github
I'm not sure but one of those two yeah
follow my Twitter handle I'll tweet it
how's that matter okay this is this is
some code if anyone's ever been to one
of my sessions before or our training
this I've had a sample app for like ten
years I keep I'm just working it over
time but it works well so okay so let's
go understand the other features here so
another feature is stateless views so
how many people have had a situation
where you have a JSF app looks great
then you start testing it and you find
oh I can only handle a small number of
users anyone run into this before I have
this hasn't happen to many people that's
good so JSF is I feel still think it's
an extremely powerful framework but it
is a very server centric and so that
means that you have to manage your
server-side resources carefully if you
have a decent number of users right and
there's a couple different reasons why
the server-side state is large right one
could be higher application is built if
you have huge objects that you're
keeping in the session and you have lots
of users you're gonna be using up lots
of session of state right that's why we
introduced things like the view scope
where you can have your data tied to
particular view that's why we encourage
you to use request scope when you can so
that the data goes away right away okay
the other thing that that causes certain
that uses server-side resources is the
state JSF component tree right and that
is the server-side representation of
your page now in a simple page like the
login page not a big deal but what I
often see our pages where it's
essentially
you know a tab with a tab and they each
each tab view has like you know ten tabs
and each tab has three grids and then
you're talking about a pretty huge
component tree okay
and JSF has to keep track of that
component tree for each user
now with JSF 2.0 and higher the
footprint per user is not necessarily
that large and some would argue it's
it's actually quite small but the larger
your component tree is the reality is
the more memory you gotta take on the
server okay and you know that can be an
issue over time so one of the things
that JSF 2.2 adds is stateless views and
the idea with stateless views is pretty
much what it sounds like you can say for
any particular view do not manage any
state on the server okay because the
server side state is basically what can
take up the memory right and server side
stages usually manage for components
that use user inputs so input controls
and also you know some things like data
grids and things like that they have
some sort of user input mechanism those
are the things that take a state okay
but if your view doesn't have much of
that stuff or if you don't care about
the component managing that state you
can turn it off and what that does is it
basically says that you know all the
components on that page are basically
what happens is JSF will create one
component tree essentially which will
share among everybody so that and then
whenever it needs data it'll just pull
it from your model okay and the
component its components itself
themselves will not manage any state so
this will it's essentially a performance
enhancement right for applications that
need it and it's actual very logical
thing to do just to save memory on pages
that don't have any States so France
example if you have a page that's like I
don't know just shows a lot of data you
can turn on stateless views and you'll
you'll save some memory you can do this
very easily with the F view tag so just
for any page you can say F V UF view
transient equals true and then you'll
turn off
the you turn off state essentially okay
nope not burr components for the whole
page yeah um and the caveat of course
this will not work with view scope beans
that's because there's no view related
state so in in typical JSF fashion
pretty much what happens is that if you
turn on transient views and you have a
view scope being they'll just become a
request code B which kind of way she
just wouldn't work but it turns into our
oppress scope beam so it's not it'll say
hey I think you might get a warning
actually but so keep that in mind so
that's not another nice little feature a
lot of people were very excited about
that
so actually I have one I've actually
been able to use this in one application
or we develop a kiosk application it's
mostly just navigation so we're like
well we don't need state I only need see
it in like five pages the ones that
where people have to type in their name
and stuff into the kiosk the rest of
them you just navigate from page to page
no reason to have state so so another
feature is faces flows faces flows
basically like I said before it allows
you to group a set of views together
into a lawbook logical navigation paths
okay and basically as I said before it's
taken from AF faces Spring web flow what
was just me my face is Cody etc and you
can think of a flow like a java method
so basically it is a flow of execution
that you can call from anywhere so you
can be in any part of your application
as long as you return a logical outcome
which maps to a flow you'll then go into
that flow okay and examples of things
that flows are good for are things like
wizards or shopping carts or basically
anything that has a series of steps or
where you want to keep track of where
the users are with
that and have logical transitions
between the pages so you can sort of
think of it like a more powerful
navigation system it's a little bit a
little bit more complicated as well than
the default JSF navigation but it's more
powerful you can also accept input
parameters and return values so you
could basically go to a flow send a
couple parameters and then have the flow
use those parameters inside of it and
then return a value when it's done okay
so that can be handy in cases where you
know you're basically you want to call
some execution and then you wouldn't use
that value to do something else in your
page or something else in your
application so the idea is that when you
enter a flow you have sort of a defined
contract maybe those parameters need to
be sent in but you know the details of
exactly what happens are are hidden and
there's actually a new scope so there's
a flow scope available so within any
given scope there is a flow that there
is a within any any given flow there is
a scope available to you as well yes
sort of I mean that that's that's pretty
much the idea the the difference though
is that you're not really gonna you're
you won't magically go back to the page
you came from you have to I mean but but
basically you will be able to navigation
within the flow and then get a result
back and one of the things about phases
flow and you'll see this also in new and
JSF features is that the annotation
which is provided which you don't have
to use the annotation actually there's
two ways to do it but um but if you
wanted for something in this flow scope
you do have to use the annotation for
that you need CDI okay so JSF pretty
much from now on anytime there's a new
feature it'll be implemented in CDI and
whether or not spring adds it who knows
they might either might they might not
if you're using managed beans and not
CDI you're probably coming out of luck
okay so how many people here are are
using managed beans like normal and JSF
managed beans okay
I mean people here are using spring okay
and how many people are using CDI ok so
um so you see that's something to keep
in mind now what may happen it's not too
hard to implement a flow scope in spring
or managed beans probably won't happen
but in spring or something so it just
depends on whether someone wants to do
it spring has its own flow scope as well
all right has its own you know web flow
sort of thing which you can use with JSF
so you're using spring you have to sort
of look at the trade-offs of using
either which one you're using you're
going to use ok yes
yes okay so he said I can you spend the
difference between CDI managed means and
is kind of confusing because basically
what happens it's JSF when Jeff came out
like can't leave I'm getting us old now
2004 I believe but when it I was a 2002
2008
yeah I think it actually came out before
them anyways but it came out there was
no you know the spring was around but
there was no dependency injection for
Java right so JSF and Bennet managed
means a very simple way to do dependency
injection you know and it worked well
okay then what happened was they
introduced CDI okay and part of one of
the things they did and the CDI
terminology is to have a concept of a
managed being which basically means sort
of an EJB managed being the sort of
thing which isn't necessarily the same
as the JSF managed being but
conceptually it's the same so I think
what's happened is because they
introduced that term sort of than Java
EE CDI world it becomes a little
confusing as to what exactly managed
beans are okay so managed beans are the
original JSF specification with the at
managed bean annotation you know at
request cress scope you know etc and the
XML version anyone remember the XML
managed beans anybody remember this okay
so so that's the original one it doesn't
do anything fancy it just gives you
instance of your object it doesn't use
any proxies you know it's very
straightforward pretty fast
right and then CI is sort of the
full-fledged dependency injection like
spraying the use of proxies and
everything and it just happens that
basically a CDI bean is called and
manage meaning conceptually but it's
actually a little bit different than the
JSF managed means
right yeah there's those they're in
different packages to make it more
confusing for you so so the the JSF ones
are and the thing job X face is a beam I
think and all the the job a ones are in
like Java X Enterprise something rather
so so if you look for instance if you if
you go inside a for IDE and you're
looking at some class right ok so this
is a CDI class right because I'm using
the named annotation which is definitely
a CDI or it's actually not just CDI
annotation anyways so there's the
request scope the annotation right if I
get rid of requests go up to here so you
see this is an enterprise context
request pooped right the resource in
this whatever okay anyways so there's
also another one which is Java X I guess
table X faces being requests cope so
this is the JSF version ok and then
there's also the manage mean one as well
so you can see so this would be a way to
make this a JSF managed bean okay so
that's a JSF managed bean now the minute
I start using anything in the other
namespaces with the job X Enterprise
that's when it becomes the CDI yeah yeah
exactly and that's one of the things
that's annoying is that if you're you're
you have to pay attention when you do
the import cuz otherwise things don't
work and you have no idea why basically
so so if you have the option of using
the CDI I encourage you to use it with
JSF because managed beans will most
likely or are going to be deprecated in
the next version of JSF and JSF 2.3 now
as we all know that means they probably
will continue to work just fine but they
won't be enhanced in any way ok
I mean CI has tons of other features is
really powerful
the only real benefit of the management
says are simple and they work without a
lot of hassle so okay
are you saying they would refresh each
other refresh that section independently
I don't think that's built in to JSF I
think that would be something that some
interesting should probably do okay
that's a nice feature though and that's
one of the things I think which would be
nice to see is the ability to basically
integrate the the flow navigation inside
of with Ajax is essentially what you're
talking about right yeah okay so let's
do another thing um so navigation moves
between different notes there's
different types of notes you've got view
what you make sense right there's a
method called note there is a switch
which basically will go through a set of
expressions and whichever one it matches
that's what'll be used okay there is a
flow call which will go into another
flow so you can have one flow call
another flow sort of like a sub flow
okay and then there's flow a term just
basically where you return from a flow
and one of the things I think which is
key about this is that flow is sort of
an egg enable package reusable
application fragment so one of the thing
which I think is some things which I
think has been missing from JSF for a
while is essentially the ability to sort
of easily have reusable parts of your
application so let's not seen as the
many organizations they have like
Framework stuff right you want to kind
of be able to throw this framework or
this set of pages and jar and classes
etc into your application and just use
it and this you know you can do that but
it's a little bit of a pain so they
features like phases flows and the
resource library contracts which I'm
going to show you a little bit later I'm
really help you with that ability to
sort of package up parts of your
application into a jar file okay so you
could say all right well now I'm
creating a new flow this is the shopping
cart flow and I'm putting it in a jar
file and then now it can be reused by
different applications in the
organization which need that feature
okay which is really powerful it depends
on a new feature called the client
window in JSF 2.2 and it's important to
mention this because that actually you
need to turn it on it turned off by
default so I'm talk about that in a
second and it says head before it
requires CDI so for those who are very
curious these are the new classes which
are part of this is actually from the
Java Docs I believe I did not write this
but you see we have a flow class which
is basically represents the list of
inputs outputs etc okay uses the client
window the flow handler is basically
what's used by the JSF navigation
handler which is what handles navigation
normally okay so the flow handler sort
of uses that is used with the navigation
handler to decide where to where to go a
sneek keeps track of all the flows and
then a flow can have flow calls method
calls view nodes
and then also it has maps of the
different navigation cases to deal with
it well these are whatever turns these
are what it switches okay so of course
you don't have to really you know you
don't really have to work with all these
classes but just to give you an idea of
conceptually of how they're all related
okay so I said before that you can
package up phases flows and reuse them
right this is an example of what that
might look like so you don't have to put
them in a jar file unless you want to
but this is just an example of what it
might look like if you had a jar file
you see we have they met it in beans XML
which is just for CDI and basically you
have it flows directly with the name of
the flow and the flow the name of the
flow and then - flow XML at the end and
then you can have all the different
nodes see there's clothes flow name the
name of the node all the different nodes
to be inside of the flow directory and
then of course your java classes being
there as well so basically your flow is
going meta and flows so named
essentially
all right so let's take a quick look at
what the faces photos look like so the
first thing is that I mentioned before
that we have that it requires that the
client windows feature so you actually
need to turn this on there's two values
I think it's like your Allen off or
something so if you if you don't turn
this on you can't really use faces flow
so you have to turn it on and what just
so you understand this feature this is
actually a really nice new feature in
JSF so the the way the client window
works is if I take this page okay and
say I log in see my old ugly application
here okay this see this up here this a
JSF window ID once you've got them an ID
and then we have this colon here right
so then if I just go to another page or
another window and I log into project
track okay you see now I've got another
window identifier okay so each window
has sort of a separate so keeps track of
all the windows and allows you to
actually handle different tabs and stuff
in a much more efficient manner okay so
but that's not faces flows so yeah
um I think if you're doing post requests
it's an it's a hidden field if you're
doing get requests it's sent on the URL
so I think most of these I get requests
but if you're doing a post it'll begin
it's sort of like well then they have do
they have a window idea on each URL ok
yeah so it's the same idea
all right so let's take a look I don't
have the flows inside of my my sample
app but fortunately I do have it
elsewhere
okay so if you want some JSF examples
it's actually a very good place to look
as the Java EE SDK there's basically
GlassFish with a whole bunch of examples
they actually have a lot of examples in
here so they've got examples of pretty
much all features I'm talking about and
lots of different ways and here's an
example of very pick this one okay so
one of the things which is interesting
is there's a couple different ways you
can define a flow okay so these are all
simple maven projects that are very easy
to work with so first we'll take a look
in here let's see there's no faces
config in this application
okay so there's nothing to find an XML
here alright so we've got a simple page
here and you see the action is flow okay
so basically what's going to happen is
the default JSF navigation handle is
going to say okay let me look at the
flow and look for fotodiox HTML blowdown
JSP whatever and then it's going to say
well I don't see this so there's is
there an actual flow called flow right
so it's going to look for a flow and
then basically what's gonna happen is
it's going to enter the flow and I'll go
to the first step in the flow okay so
this particular flow is to find using
Java so one of the nice things about
flows is that you can actually define
them using Java or X or XML so here is
an example of a Java flow okay it's a
very simple one imagine you can see so
it uses CDI as we said before and
basically what you do is you create a
CDI producer okay
producer method so producer method is
basically just a method whose job it's
sort of like a factory method sort of
its job is to create an object ok and
what happens is JSF wouldn't start up it
looks for flows it looks for annotations
flow definition produces or produced
this flow definition or whatever and
then calls those and the you use this
class called the flow builder to create
your flow
so you basically you can it's sort of a
nice fluid API is probably one of the
better interfaces in JSF you can
basically say ID you know build and
basically you specify the name of the
node that you're trying to build and
then you can call other methods on it so
this is marketers start node okay and
then you can of course add more and more
nodes okay and that's basically how you
write a flow so this is a very simple
flow it has one node called enter okay
and see it has a node called enter but
the page for that note is stemming a
okay and we're marking it as a start
node so it's going to happen is when you
go into this flow it's basically just
going to execute or display step a and
step a
oops is right here okay so it went into
step a and you notice there was no step
be to find there so really what's going
to happen in step B this is just going
to load step B - XHTML but usually you
probably would have multiple transitions
in there this is a very simple example
let's look at a more complicated one
yes so so you can yeah here you're
basically saying okay at this state
you're gonna want to move to another you
know and this page whatever link you
click on can go to whatever step in the
flow right but then also inside the flow
you can use expressions which we'll call
methods which can affect the next step
yeah yeah although you know you're
probably I mean yeah you could basically
have even you can even have any action
go to another method if you want to you
know support let's fill the site would
flow okay so here is another one
okay so in this one we've got basically
a very simple flow index flow and you
see what we have here is you can put
your your XML this is an XML definition
right so we have the index page which is
just going to say go to index flow very
straightforward now you see there's this
directory here index flow okay so this
is sort of you know JSF since 2.0 is
really tried to work in terms of
defaults right so you know we have a
floor called index flow so it looks for
a directory called index flow right and
if you're in the meta enthalpy in the
you know meta and flows whatever inside
of your jar file right you're in an
application it looks for from the root
okay so it looks and then inside of here
we can have the flow definition itself
right and as we said before the name is
name the flow and then go to XML
okay so this is the XML version of a
very simple flow definition right so we
have that ID and this is no this is
actually just a JSF config file right
but we it's nice to be able to place the
XML on the side of the actual flow okay
which is what's going on here so we have
the start node which is the index and
then we have the view node which so this
is basically saying start with the node
called index right this is the node
called index which is the view node and
then basically we're saying when we
return from the flow we return exit or I
basically when we exit we we leave the
flow okay so for this one when you enter
the flow you see that values exit that's
basically that return value that I just
showed you so here you see we have the
from how come here so that's basically
going to map to this here ok so another
very simple folk it's the XML version
and I'll show you one more complicated
example
okay so this is what is actually placed
in a jar file this chroma Tory's
application is kind of handy actually
okay so this has three pages show from
create and the actual code the flow is
to find inside the flow in charting side
Java
okay so this is not exact this is
actually an example of a flow scope beam
let's use inside this flow fund
therefore the definition which is not
there
okay here it is yes so here we have a
fluid definition starts with show goes
to the show page and then oncreate goes
to the create page this is a very simple
one but you see also in this one we do
have examples of actual flow scoped
objects so basically we can specify the
defined document ID the value sort of
make sure we have it with the right
scope right flow so I don't have a more
complete example but this should give
you a sort of a flavor okay that you can
define it in Java to find an XML and you
can basically sort of control how you
move wire inside of a flow as well do
you mean is our benefit to flows versus
normal navigation yeah I think you know
perhaps these aren't the best examples
to showcase that but really what you can
do that you can do more expressions and
stuff inside of here to sort of decide
what happens so if you want to do more
of it dynamically if you want to put
more of the logic in terms of what
happens inside the flow you can do more
of that especially by using the method
call or the switch nodes so with those
you can say okay I'm going to call this
method and then based on that method
even if the method is defined inside
here or inside of Java class you can
decide sort of what happens to the flow
the flow can have more logic and control
and it just what are the key thing also
there's it's a very sort of defined flow
forward and backward and all that kind
of stuff and the idea there's another
example here I don't have it I don't
know which one it was but the idea also
that you can pass parameters so you
could say you could have parameter sent
into one flow and then pass them into
another one things like that so so I
mean you know if we just have normal
very simple navigation not really
necessary but I think this this comes up
in situations where you really do have
that sort of you know well-defined set
of pages that interact with each other
and have their own State any other
questions
yes it's an interesting question
so Neil's question was do I consider
this to be better than conversation
scope or different or like an
improvement you know I hadn't really
thought of it that way I mean a lot of
way flash was like a poor man's
conversation scope but but yeah I mean I
guess in reality if you have if you use
the foot scope you don't really need the
conversation scope let's see because so
CDI has a conversation scope and so to
spring you know and there I haven't
really used that much Missy I could be
honest so I haven't I know people have
some complaints about it but and I find
usually the jsf features work better if
they're part of the jsf specter than if
they're part of another spec and sort of
integrate with JSF so I mean I I would
probably try this first
yeah and in some ways you know I wonder
if you know you could just do your whole
application with flows and not worry
about the old-school navigation but
that's sort of overkill for a lot of
applications so I don't know any other
questions okay
oh they said okay okay so how many
people are familiar with CSRF cross-site
request forgery okay so what I find is
you know you write your great
application and then all of a sudden
someone on your team or on another team
in large organizations does a security
audit and they tell you all these things
you need to fix or if you're lucky you
have someone from the beginning who
tells you this up front so CSRF this
actually came about because I had a
client that you know ran some tool
against their app that we built since
like hey it's vulnerable for CSRF so he
worked on the solution and then I
brought up to the EEG and said hey you
know we should probably add this I think
what they added most better than what I
did but anyway so so so this is this is
an ascription event though it's
basically a way to sort of hijack a
session essentially so it's you can also
notice one-click attack or session
riding and abbreviate a CSRF it's a type
of a little let's just exploit a website
here by where by unauthorized commands
are transmitted from user that the
website trusts so essentially you
basically hijack the session of you know
you sort of log in and then you sort of
grab those credentials or the
association with the session and then
can do a post back and cheat essentially
so that's basically the story so JSF has
always handled this relatively well with
because it was so post heavy okay so if
you work with older versions of JSF you
know initially you couldn't even do get
requests very well you could do them but
they weren't they weren't support in the
best way so so if you're using the post
request you're pretty much handled
because what JSF does is it has a view
state attribute which is used to
basically map to the current view so on
the server
JSF can say okay well this is the view
you're posting back to right if that is
not the right view and it's not
associated with the right session then
it's not gonna work okay
so you really can't that's pretty much
foolproof in terms of CSRF at least
okay so and also you can encrypt the via
state as well so you're pretty much
you're you're in good shoes when you use
post requests the the issue arises when
you use get requests so what you can do
now is you can add CSRF support by using
the protected view element in your
navigation rules and basically all you
have to do is use that protective view
and then it ensures that requests come
from the same application right so if
you have a page that you expect to be
getting requests from different
applications and you're not going to use
protective view but this is good if you
want to basically ensure that their
question coming from the same
applications so it's a very easy way to
do it but of course you have to turn it
on so it's not going to happen
automatically okay okay so another
feature I like is the loading resources
or facelets via the resource handler so
you know as I mentioned before JSF in
previous versions had one way of loading
facelets one way one way of loading all
the other resources now there was one
way to do it which is the resource
resource resolver research handler
excuse me this is important too because
in order to support some the other
features like a resource library
contract so it really needs to be one
way to handle everything so this was a
nice way to clean up things how many
people have ever customized the facelets
resource resolver before okay how many
people have customized the resource
handler okay that's a couple of you okay
no you don't count alright so another
one is file upload supported in servlet
3 so it makes sense that we would
support it in JSF because it's supported
that servlet 3 finally and you know
reality is third-party components these
have done this for quite a while
and it's just another JSF component it
supports Ajax and non Ajax use cases as
well
you helped out with this didn't you Neal
we're being kind of active on that part
right right
right okay so if you didn't hear Neal he
said the only it works well what the
only problem is that doesn't do multiple
files and has a dependency on the part
interface and the servlet 3 okay so it's
a very simple component a just file H
input file and you can basically get an
object back this this what type is the
object you get back no yeah it is a part
ok so it's a server three part is what
you get back and you can work with that
ok so simple component if you're using
the third-party components we might have
more features like multi upload why not
so sorry I think it's depends on the
spec right
so if you didn't here you can control
the size by configuration parameters in
web that XML I don't think there's a
limit per se yeah okay okay
right-right-right ready see this i mean
i i i think JSF has extremely powerful
but make sure that you see what what
parameter is what things you need to
configure to really make sure your
application runs the way you want it to
it's one other key thing also when it
comes to implementation parameters so my
faces tuning parameters Mahara tuning
parameters are all very important so
this is probably one of my favorite
features resource library contracts or
multi templating there was a JSF eg
member that had proposed a multi
templating feature which was a superset
of what we provided in resource library
contracts so add the spec Lee didn't
want to call it multi templating because
it wasn't as cool as his feature was but
he doesn't care the guy the guy that
came up with the feature doesn't care so
I'm gonna call it multi templating so
multi templating is what it is so
basically you can template site elements
header sidebar content area whatever
banner of CSS images all this kind of
stuff you can basically swap in and out
templating for those elements in your
application and you don't have to but
you can package them as jar files so
there's another area just like the faces
flows where you can use it to our file
but you don't have to so gives you a lot
of flexibility there because we started
out in your application and then if you
find you need to reuse it somewhere you
can put it in jar file later
so one of the best use cases I can think
of this for is if you have multiple
clients you have to support in the same
application which I see a lot so you
know let's say you have some cool
application you sold it to 70 different
clients in the each other they all want
their own little tweaks right some of
them want things this way some of them
want them that way this gives you a way
where you can essentially provide a
different set of facelet templates and
stylesheets images etc for each client
okay and then depending on how your
application is deployed you can control
it at runtime or you can control it
during the you know it's part of the
build process who knows okay
there's also other uses you can change
it layout dynamically actually even um
so you can have a sort of a way to do
different themes or layouts for an
application and things like that as well
okay so if you put it inside of a jar
file the structure is kind of like this
where you have meta in three contracts
the name of the contract and then you
can have that job of ex phases Concord
XML file that's a marker file just like
beans that XML basically just says
alright this is definitely gonna be a
resource library contract okay
nothing goes in there and you can put
whatever resources you want in there and
so if you notice this layout is very
similar to flows it's just the name of
basically the name of the flow or our
contract and then the resources inside
of it okay so by default though the the
light the contract is global so if you
are you know let's say I add a resource
library contract to an application and I
don't say anything about where which
parts the application it should work for
it'll just take over right which may be
what I want but I can also control it in
a few different ways I can control it by
URL so I can say basically I want this
resource library contract to only be
available or actually this is basically
saying and this is in this example I
want to apply the
this resource library contract called
user to anything that's inside of this
that matches his path okay and this is
basically saying this is going to be the
default and then if you go in here it
will use the special one called user
okay so that's another way you can
control it the third way is per view so
you can say all right well I have a
property and a model object or a managed
bean somewhere and now I'm just going to
say whenever you go to that page I'm
gonna specify the actual contract or you
can say okay this page will always have
this contract
okay just by hard-coding it and you see
you can have multiple contracts okay so
it's actually quite flexible you have a
lot of control over how you want to
apply things okay
so let's take a look at this feature
that's what I do have an example for
alright so in this application it's not
the most attractive application but this
is what it looks like I mean it has some
different pages they all look kind of
the same you can write in some comments
it basically it's for managing different
products okay you can view the details
etc etc this is what it looks like so
let's say that we decided that let's say
somehow I managed to sell this this
beautiful application to people and and
the first client was Acme corporation
okay and Patrick Corporation has some
very specific requirements they said
well you know we want at the bottom he
wants to say copyright Acme corporation
at the bottom and then also we want you
want a different background color for
the whole thing okay
it was a title of every page to say Acme
this says project track one I'm going to
say Acme project tech project rack ok so
say I need to implement that well
traditionally what I might do is you
know maybe pull simple and some
resources some some internationalization
resources from a jar file or something
or you know write some code that pulled
things dynamically from the database
based on the current
or something like that okay um now what
I can do now is I can create a new
resource library contract okay so here I
have Acme layout okay and all I have an
acme layout is a man of directory
contracts Acme and then I have that Java
X phases contract XML file
I have acnes own CSS and then I have
templates so I have a master a standard
template okay so this application has a
master template which just has the basic
sort of stuff as the head has the style
sheet okay and you see the style sheet
here is called Acme dot CSS okay if I
look at the master template in the rest
of my application because the actual
application has the same thing you see
here it has templates directory right
and this is in the regular application
so the regular template the master
template has global dots yes it says it
doesn't have a curry dot CSS okay and in
the standard template a Sano template
has a footer in here just hard coded
right but it's acnes layout so I can
hard code all I want right so the
footers down here in acnes template um
in the default there's no footer at all
okay all right so now I have this very
simple file right or this jar file okay
and it's not in my project if I just add
it to my project which I can do of
course in your build scripts you could
do it that way and the clips I'm just
going to add it this way
when I published my application
okay and lo and behold Dan says
copyright Acme corporation the bottom so
I noticed the right one the title the
top here says acne project track okay
and you see the background is radically
different right the background is a
little bit different there so you see
now we just just by including this jar
we changed the whole look and fill the
application right and this is really the
power so you know if you wanted to do it
during build time this would be one way
to do it right you could swap out
different ones but if you wanted more
flexibility you could then also do it
using the web configuration so I'm sorry
base is config and then I web the next
okay so resource library contracts
I'll check math whoops
contracts and that's acme layout because
i mean though it's called Acme layout
because if we look at the structure up
here thank you
I'll get there in a second it's actually
called Acme because that's the actual
name here so this would be the URL
pattern so and it will say this is only
okay so now we're replying is only two
views in box that X XML HDS accepts exit
XHTML excuse me
I think it's contracts I don't think
that's actually invalid content
yes I'll find out
all right
I think it's usually I think it's a
commis up a space commerce
comma-separated list actually okay so
you see me having it here actually now
we're not we don't have it anywhere now
so it's not showing up at all so maybe
it was wrong now I had it in the
previous version here
looks the same to me all right well I
don't want to waste a lot of time but
the idea is that if you specify this
correctly the the you can apply it to
the specific part to the application
this would be just this page or just
that page or whatever okay and then of
course the other way would be using the
view ID or the display on the actual
view node where you can do dynamically
based on your back-end code okay so
that's possibilities there any questions
about the resource library contracts yes
I think probably the way to do that
would be to you could have different
names basically if you could somehow
change the name based on the version you
could do that at runtime and then
dynamically determine which which one
you're going to use do using the view ID
approach that could work okay
alright so there's some other features
which I'll just go through quickly these
are just other minor tweaks there's a
component managed DL contest which is
really more of a implementation feature
so if you're writing a custom component
not a composite component but a real
Java component you can have your own
special context which you can create for
for rendering and stuff while that
employments being handled which is handy
there's a client window which we talked
about you can actually create a
composite component in code now it's
just nice basically it's just just a
method call that'll create the component
you know it still needs the XHTML file
it just allows you to create it
dynamically if you need to okay there's
a Facebook Factory API there's lifecycle
enhancements view actions which I
actually do have a quick demo of which
I'll always take a quick look at that so
um how many people have ever used the
pre-render view event JSF okay so a view
action is very similar so it lifts a
sample here let's say we click on this
details button okay you notice it's
sitting in this this project ID
parameter okay if we look at the page
it's actually using a view action to
handle this
okay so the way you do a view action is
just like very similar to using eith
like view parameters so here we have a
view parameter which is a way to process
a parameter that's coming into the page
right that's been there since JSF 2 and
basically these are going to set
properties on the controller for this
page and do validation etc and then this
view action is going to be fired as well
now often what people do is they use the
F events tag and call an a freeway
interview event to do the same thing
right so this will you know and that
basically means that before the view is
rendered that method will be called okay
what's nice about their view actions is
that you have a little more control so
you can say alright well no there's no
defaults there but you can specify
whether the view action is fired in the
Evoque application phase or in other
different other faces as well okay and
also a view Bastien can have an action
attribute so you can actually say okay
based on some condition i actually want
to go to a different page I really don't
want to render this page after all okay
so this gives a little more control if
you actually do some navigation there as
well and then also have it be fired in
different phases in the request
processing lifecycle okay
so it's pretty handy little feature I
was sort of what we really wanted to do
this in the thing JSF 2 or 2.1 I can't
remember and I didn't never made it so
but it's pretty handy so I think in the
future if you're using JSF 2.2 you may
as well look at using the view action
instead of the pre-winter view if you
want to execute some code right when
someone goes to a page ok very handy yes
so so news question is what's the
benefit of doing this versus a post from
construct annotation in a beam and the
main benefit is the post construct is
only done that's when the beam is
created right so what to do skillful may
only be called once right this would be
called for every request so in this
example we're basically loading the
project for that request so bitch more
of a request oriented thing whereas post
construct it's going to be more like
something you do once when the view is
created an office a request scope being
it's almost the same thing except with
this you can still control exactly what
part of the lifecycle it's is executed
in as opposed to with you know a post
construct for a quest code being and
just being only when it's referenced the
first time essentially so so I think
it's gives you a lot of flexibility all
right me or rip through the rest of
these
okay um one of the sort of annoying
things about JSF is that something you
should use with CDI or with the Java EE
annotations like a tree source a tjb etc
and some things you couldn't and now you
can use it with pretty much everything
which is nice
cleanest listeners actually get resource
injection finally factories listeners
pretty much everything for the most part
there is actually a view scope
annotation for CDI so for those of you
who are using CDI and have been annoyed
about the fact that there wasn't a view
scope CDI annotation and had these omni
faces in order to use it um now it's
actually partner chance to have to point
to there's a full list available on the
web and this is basically a link to the
issue tracker if you want to look at
that yeah we talked about the view
action okay there are several other bug
fixes and tweaks I like this one I only
picked a few of these that I thought
were relevant there's obviously we look
at the spec there is you know several
pages of little tweaks and changes but
um UI data which means a DEA table
component can now work with a collection
instead of just lists which is it's nice
to finally actually be able to do that
how many people have written code to
translate into a list just for a data
table before alright so so that's a nice
addition composite and non composite
components can now be in the same tag
library
I know Neil has felt this pain before
personally so if you had composite
components and you had regular component
they had to be in different tag
libraries which is kind of silly if it's
supposed to be the same tag library the
flash scope was sort of a a orphaned
child of scopes and JSF you didn't even
have all the right events for handling
creation and destruction so those have
been added and there's also a full list
of that as well on the web just just the
URI changes you don't really need this
table all you have to do is
if you're using JSF 2.3 and you want to
be all up-to-date and just search for
in-place Java at Sun calm with xmlns:a
CP org and your name spaces will be up
to date right so less work
JSF 2.3 has officially begun it is going
to be part of Java EE 8 and it will
actually depends on Java SE 8 which is a
big deal right
so we'll get to hopefully how to do some
fun stuff with the api's with all the
new Java 8 features another key thing is
that it will not when I say no backwards
compatibility I mean with Java EE 7 not
with your whole application so listen
guys were you write your application but
but it does mean that this is the first
version in JSF it actually won't work
with like the previous version of Java
EE so you know depending on your high
organization works it may be many years
before you migrate to job to the JSF 2.3
probably be out I think in a couple
years anyway so but there are some
things they'll be going on manage being
so probably will deck DB deprecated
they'll be able to inject the faces
context in the CDI which is a nice thing
actually these are really just things
we're talking about who knows what's
really going to happen but these are
things we're talking about multi field
validation is on the list
finally Ajax method invocation this is
something that you can do with with
things like primefaces etc or you just
want to call a method in JavaScript and
get some jason back easily some
optimizations to the l language and
better integration with client-side
technologies and frameworks and if
you're interested in talking more about
this there's a verge the feather session
tonight I don't know what time it is at
but this evening that's all about what's
know what's next for JSF so if you want
to sort of be involved you see what
we're talking about you should check
that out
Ian Labatt's my cohort for the newscast
is going to
talking about ways to integrate JSF with
client-side things like angularjs and
bootstraps so the other stuff there as
well so check it out if you have the
time
okay so that's pretty much it I talked
about JSF to to use it with Java EE 7
backwards-compatible talked about the
html5 friendly support faces flows
cross-site forgery protection resource
handler file upload resource library
contract one of my favorites and you
also talked about view actions the
client window and all the different
tweaks alright so I thank you very much
for coming oh it's at cheedo 99 is my
twitter handle was at keto 99 if you
want to just if there's anything if you
if you want to know where the slides or
examples are just tweet me that will
follow that and I guess technically we
have four minutes for questions if
anyone has any questions questions all
right thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>