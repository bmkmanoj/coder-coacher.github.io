<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Task Processing, APIs, and Big Data in JavaScript | Coder Coacher - Coaching Coders</title><meta content="Task Processing, APIs, and Big Data in JavaScript - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Task Processing, APIs, and Big Data in JavaScript</b></h2><h5 class="post__date">2017-12-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/R4RTczsDULY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello welcome to the session on task
processing api's and big data in
JavaScript my name is Prateek Patel I'm
a Java champion and you can find me on
twitter @ @ PR patel in this session
we're going to talk about action-hero
Jas action-hero Jas is a wonderful
framework for building out server-side
JavaScript applications it's an API
server that is multi transport and has
the notion of actions and tasks that
we'll get into in some code in a few
minutes but before we talk about
action-hero as an application server or
server-side framework for the JavaScript
world let's talk about the JavaScript
world in general in the JavaScript world
we have this notion of build-it-yourself
what that means is we start with the
smallest possible thing in the
JavaScript server-side world for example
you might start with something like
Express and then add on some libraries
to build a complete solution with
action-hero you get everything you need
to build a full fledge api server that
can do a number of different things with
support for clustering and tasks
background etc as you need it so in
action here ljs you get everything you
need and without having to piece
together your own framework in the
JavaScript server-side world it's common
to use something simple like Express and
then add in a library to do cookie
management and then another library to
do session management and then something
else to hit a restful api but this can
get onerous in terms of how do you
select what you need to do in this case
actually here I'll helps you solve these
problems let's look at some use cases
for action-hero Jas so one of the things
that I do is I help manage event and as
part of managing these events we have
common tasks that we need to automate
these tasks
are everything from small towns to
larger tasks so how do we automate these
tasks use in Action Hero one thing that
we have to do frequently is sending
emails from a UI so these are scheduled
emails that we send after we do some
kind of query to our database and
construct a email from a template we
also need to generate images for Twitter
but need to do it asynchronously when we
have updates as certain types of data we
can do this as an action hero with the
tasks we also need to do a reviewer
notification and other notification
types has that hit email or some other
method to let a reviewer though that his
comments have been accepted etc and of
course we could hook into AI to build
Skynet well the last case is not really
true but you can see there are lots of
different things we can do you can also
use it for inbound email processing this
means that we can hook in to some kind
of message queue or maybe connect
directly to a pop or IMAP server see
when new emails come in and then process
them accordingly so one of the things
that I like to talk about in this
session is thinking of architecture up
front what is it that we need to think
of what we're building an application
especially on the server side in terms
of being able to have something that's
flexible and maintainable over time but
still scalable in an easy way this is
one of the things that action-hero
provides worth it allows us to think of
architecture up front but not really put
too much effort into it as everything is
baked into the system
however action-hero is a framework that
is not to ownerís and is really easy to
get started with as we'll see in just a
second so let's cover some action-hero
basics and then get on to our next bit
of code so action-hero is a server-side
JavaScript framework so it runs on
nodejs
in terms of a node.js framework there
are other options out there
as Express or happy etc that allow you
to build applications on the server side
but you do need to have a server that
can support nodejs or the ability to run
applications in JavaScript on the server
it allows you to build reusable it's
gave the scalable api's and it supports
static and dynamic content let's look at
the API server portion of action-hero
first we look in action hero and think
of why do we need another API framework
and server we already mentioned Express
for example when we talked about the DIY
type of mentality in the JavaScript
space so let's have a quick look at why
we need another API server or framework
in a lot of ways this is something that
is interesting about the JavaScript
community as mentioned there's a very
much a DIY or build your own server
approach what this means is we want to
start with something very very slender
that doesn't take up too much processing
time or has too much overhead or has a
lot of stuff that we're not going to
need and that's the general feeling in
the server-side JavaScript world and
what we prefer to do is we prefer
sometimes to have more tooling included
into our framework so that we don't have
to go and build and architect our own
application server but we have something
that's built by the community and is
verified in terms of how it's put
together so that everyone can use it
easily and quickly and in an easy way so
why do we want to use action-hero it's
multi transport that means it not only
supports HTTP for accessing its API but
you can also access it via WebSockets or
you can access it via UDP or TCP or
whatever you like it comes with a number
of different server based connections
out of the box and actually it also has
this action / task based architecture
that we'll look at in detail shortly and
one of the great things about
action-hero is that it has a
gribbit distributed architecture for
tasks so tasks can be run on a single
instance of action-hero or you could
start up multiple instances of
action-hero and run it across all these
different instances that you have and
normally when you build an architecture
like this which is distributed you have
to go in and go and set up all the
plumbing yourself this is typically not
what we need to do with action-hero
because it comes out of the box built
with distributed tasks and distributed
actions so that all you have to do is
set it up configure a few things and it
will distribute these things for you so
how do we start with ax here first of
all what we would do is we would do an
install action hero and once we have
that we can go in and use action hero
generate to create a new project and
then of course you have to do an NPM
install to go and install all of the
dependencies that are required for
action here and then you're ready to
start the server up so let's have a
quick look at our running server that we
have in the background here you can see
I'm stopping the instance that we
already have and I'm going to fire up a
new action hero instance by doing NPM
run start this will start up action hero
on my local server for development as
you can see that it has recognized that
this is running in development that's
what the default with this command is
and the server is up and running so
let's do a quick demo before we move any
further we're going to go to our web
browser and we're going to go to
localhost 8080 and you can see that we
have our action hero server or the main
index page running up our action hero
server is working now if we go look and
scroll down this page it has some
information about the action your server
but version how long it's been running
and then it also provides a list for
actions on this server of course our
production will turn this page off or
put it behind some kind of
authentication so not everybody can
see what the guts of our server looks
like we have several different actions
here and we'll discuss a few of these in
a few minutes to get an idea of what is
here but let's do a quick demo first see
there's a link we're trying a real-time
chat with WebSockets
if your lever action here was a multi
transport API server so not only is it
running HTTP on call 8080
but it's also running a WebSocket server
on the backend on port 5,000 so if we go
fire up our chat client here here is an
example of a quick check line so let's
reorient our screen we have another
instance running in a different web
browser pointing to the same server and
now we can say hello how are you in one
of these and you can see that this
message instantly is broadcast to the
other connected instances and you can
say in this other web browser instance
doing just fine you can see that the
messages are sent instantly from one
server to the other and we could fire up
more web browsers and use this chat like
application to send messages back and
forth that's not the interesting part
this is of course just a demo of what
action-hero can do but if we look
closely at the output here you also see
that there's this message that's getting
printed out ever so often it says clock
the time is Wednesday December 6 2016
and it was run at 724 p.m. and 18
seconds and you can see it was run
previously at this time so it looks like
this is getting run every 10 to 20
seconds we'll talk more about that a few
minutes let's go back to our slides
ok so we've done the demo and let's
think about architecture a bit we've
already touched on how architecture is
important what we wish to do is we wish
to create an architecture which is
flexible but scalable and easy to
maintain and also provide new features
but action-hero excels at that so it's
not a very heavy application server in
term
what you might think of as a Java EE
based application server something like
J balls from WebLogic or WebSphere or
something like that it's much more
slender and has less of the kitchen sink
in it but gives you just enough to get
started and everything you need to
cluster and do distributed tasks and
actions right out of the box so the
first thing we want to talk about our
actions actions are essentially API
calls we'll get into actions in just a
minute
tasks are things that we've run in the
background they can be triggered from
other places besides API calls and we'll
talk about that shortly as well right
when we think of action here is
architecture one of the key things to
recognize is that there's a strict
separation of views and logic that means
that action-hero
is meant primarily to be something that
serves up API endpoints to be consumed
by a web application a mobile
application or whatever it may be but
there's a strict separation between
views and logical action hero also
supports built-in versioning for these
API endpoints that you're creating so
because of these two points this is
truly an API first development now we've
touched on the multi transport
capability of action here already but
action hero has non HTTP integration you
can create custom servers for non HTTP
data inputs it also supports stateful
TCP connections and as you saw just a
minute ago it also has the ability to
connect via WebSocket let's talk about
actions for just a second actions are
the core of action here you can think of
your API as actions so instead of
thinking of it as just restful endpoints
you can think of actions as being the
gateway that you open up for your API
now
remember because of the multi transport
nature of action Europe these actions
can without any extra work respond to
any type of connection and these actions
process parameters and respond based on
how you coded them action also supports
plumbing for these api's so if you don't
like the defaults that come out of the
box for exposing api actions you can
have routing that can help you
accumulate different types of actions
together in a cohesive way and give you
the ability to structure your actual URL
or URI endpoints in a more meaningful
way so let's look at some basics but
we're going to jump into our code editor
here and see what it actually looks like
okay so first let's look at the
structure of an action hero application
first we have our actions folder there's
a config folder we'll get to tak shortly
and then later we'll talk about servers
first let's go into the actions folder
and let's just pull up a simple action
called random number you can see I have
it in a file called random not Jes and
to define an action what we do is we say
exports dot actions give it a name and
give it a description and then you can
give it an output the output example
this would be a good way to provide some
basic documentation but what we're
interested in is the run block of this
file so on this one block you can see
that we have a function that takes three
parameters API data and next so this is
where we would dominantly do our coding
to define an action in this case all
we're going to do is say data dot
response dot random number so we're
getting the data from the this specific
anonymous function again this is the
function that action-hero invoked when
this random number API endpoint is hit
is hit it provides this API object which
is the
internal API of the action-hero server
it provides the data which is nominally
the respond response and request of that
actual request that is coming in from
the outside world and then we have
something called next we'll get into
next in just a second but if we look at
this you can see that we grab the data
object we say go and get the response
and say there's a property called random
number equals math dot random times
10,000 so let's actually go try this
endpoint out we're going to drop to a
web browser and we're going to go here
and say okay let's go and try to hit
this endpoint so we're gonna go here say
slash API slash random number and now
you can see that we have some kind of
result come back again we've gone to API
slash random number if we flip back to
our code you can see that the name that
we gave it was named the random number
and this is what's used to key this
specific routine into the API and we say
here's a random number so let's go
refresh this page and let's see if we
get a new random number every time so
right now it's four five six three we
refresh it it's four nine zero we
refresh again now it's five four eight
but let's say that you know what
actually we don't need to have such a
large number maybe we just need a number
between 0 and 100 so let's go and change
our code here hit save and in some other
application environments you might need
to go restart the server to make this
change we see in action hero however it
automatically loads up your code without
you having to do anything so we can come
back to our endpoint go to the same
place random number load that up and now
you see we got 39 but let's just make
sure that our results are between 0 and
100 instead of 0 and 10,000 now so we
get 50 this time 60 649 89 and indeed
we're getting numbers between 0 and 1
and this is one of the great things
about action here I can come back into
my action code here and say you know
what actually I just want a number
between zero and ten so I can come here
make a code change it save go back to
whatever test I'm using or from distant
development use a web browser to test
this end point or hit reload and you can
see now we have one I have seven I have
zero seven zero six nine etc so now I'm
only getting numbers between zero and
ten and this is great this allows us to
do quick development because we don't
have to restart the API server we don't
have to go and do any extra things to
get things ready after we've made a
coach change all we simply need to do is
hit save and then we can retest the code
that we just wrote without having to do
any extra work and again this is an
action specifically a random number
generator action that's named random
number and in our run function here
which is called by the underlying action
hero server we get an instance to the
API which is the internal API of the
server which we can extend as we'll do
in a few minutes we get the data that's
passed in which will contain the request
data and also have a handle to the
response object which we can set for
sending a response back and then we have
next next is used by every action to let
the action-hero server know that this
specific action has completed and it
should go on to do its next thing the
next thing may be in other action or it
may be call to middleware or something
like that we'll talk about middleware
and action hero in a few minutes let's
get back to our slides and have a look
at some things we talked about again
action hero supports heart reload makes
for fast development we put file if we
put a file into the actions folder and
that's it it's automatically discovered
by the action hero server and loaded up
as an action
and that's pretty much it we'll talk
about actions in more detail in a few
minutes but let's talk let's talk about
tasks so in terms of tasks tasks are
things that we want to run in the
background tasks allow us to do
processing not just when our API
endpoint is hit and an action here of
background tax our first class so we can
in queue a task from anywhere and we can
have recurring tasks on a schedule or we
could just have a task that runs on a
single run based on some way for us to
go and invoke it or start it running
again tasks are considered to be
background tasks not necessarily
something that runs in the foreground
when a request comes in so if you need
to have something that returns a
response when a request comes in you
probably want to put that into an action
but if you have something that's
supposed to one for a while whether it's
a second or sixty seconds you should put
that into a task something that's long
running supposed to run at some
scheduled point in time or maybe you
just want to kick it off when you've
read some kind of threshold in terms of
getting some kind of input from within
the system so let's look at a basic task
if you remember the clock example we
showed earlier in our chat application
every so often it looks like
approximately every 15 seconds or so we
have this task kicking off that is
printing into this chat room the current
time so let's go see what that looks
like let's go into our tasks folder here
and then let's pull up clock j/s you'll
see we have a export clock here this is
standard JavaScript we have a name
called clock and as you can see here we
have a frequency about 10 times 1,000 or
10 seconds it looked like it was
appearing in our chat room at about
every 15 seconds or so but again these
are background tasks and we don't expect
to run necessarily at an exact point in
time but that's a point in time which
around which we expected to what okay so
let's go have a look and see how this
task is put together and again you can
see just like the action for this task
we have a run property inside of this
one property there's a function in this
function we get API and instead of
getting data that contains a request and
response object we just have something
called params because this is not
something that's hit directly from an
endpoint incoming endpoint we don't
necessarily have that data and the
contained object for a response and
request and as you can see again we have
this next so you can see we come into
here we see that first of all we have
this rendered okay this render is
basically a way for us to pass to
action-hero something that is getting
printed on to the log file in this case
so if we go look at our output you can
see that we're getting something
whenever this is hit inside of our log
let's go back here could say API dot
chatroom we'll talk about the API object
in just a minute
this is hooking to the chatroom that I
show through the web browser so we have
API dot chatroom broadcast with an ID of
clock into the default room the time is
and then we have a new date object etc
etc and if there's an area we catch the
air in in this case we log it and then
we go hit the next function until an
action hero know that this background
task has finished let's fit flip back to
our web browser and you can see here's
clock the time is and at the time let's
see where that actually lives in our
code we have upper case clock
the time is and this is where we're just
printing out today and this is the
basics for a task in action here we have
our name which is the name of the task
we have a run object and inside this run
we have access to the Intel API which we
can extend prams and then letting
action-hero know that it should move on
to the next thing what's next here and
this is all there is to a basic task
let's do a quick review make sure we've
covered all the points our basic task
has a few things namely we have to have
a name we can or cannot give it a
frequency we can give it a cue as well
if we want in terms of what backing cue
should it be used to distribute the task
so that it only runs once across a
cluster and then of course we talked
about the run function already so we
know what that looks like let's get into
clustering for a few minutes in terms of
clustering there are a few things that
we need to remember it's usually hard to
cluster things that don't have cluster
capability built into them in this case
action-hero has the capability to be
clustered and distributed out of the box
without having to do any additional work
what does that actually look like and
how is that actually constructed in
action here so first of all action-hero
uses Redis to store and share data
between an action arrow cluster so as
you start up multiple processes of
action-hero on the same server or
different servers you can have it
they'll look for other members in the
action-hero cluster and they will use
Redis to synchronize and store data
between them so you do need to have
Redis running for this to work properly
and the Redis clustering provides
caching and the ability to do
distributed workers between different
action-hero instances so let's look at
some action your internals now that
we've looked at action your basics
the first thing we want to look at is
something called initializers
initializers are a way for action hero
to set up some basic data that can be
used in different places within our code
common code used by our app and as you
can probably guess this is what's going
into that API object that we referred to
before we can also use this to do some
initialization so the primary way of
working with this API object and
initializers is we append to an API
object and there are already some
built-ins like API dot Rattus but say
we're using a Postgres or Oracle
database we could afix
functions that allow us to hit our
Postgres or Oracle database by doing API
dot Postgres for API or or maybe just
API dot DB or database in our specific
example we're going to create some
utility functions called API users that
allows us to go and manipulate a user
database and also to read it etc so
let's go look at some basic
initialization or drop back down into
the editor real quick here and we're
going to see that we have a way of
adding some stuff into our API I've gone
into the initializes folder there's a
user's file in here and there's a module
on exports we have it initializing here
and inside of here is where we describe
specific things that we attach as part
of our initializers or API calls to be
used for later in this case you can see
we have a function API and next next is
prevalent throughout action-hero to
allow us as we're coding to signal to
the underlying action your server that
it should go to the next thing in the
queue we'll get about what we mean by
that in a few minutes when we talk about
middle-way
so here we have API which is our goal
object we create a new object inside of
it called users and then we're going to
create a few functions or methods in
this case add scroll down list users
authenticate delete crip password
compare password X are those are int
only utility functions what we really
care about is the list authenticate and
add functions so let's have a quick look
at how we would use this API so when we
do an ad this is just some code that we
use to store users into a Redis hash and
we're not going to get into too much
detail on this because this is not what
we were considered to be a real-world
implementation but just a Devon
implementation of creating a user
database so you can see it doing some
encryption and some other things like
that we probably want to use a real
authentication solution behind the
scenes or maybe we back with the
database or something like that okay so
how do we go hit this so this is in our
API dot users but it's an initializer
where is this initializer that's adding
the API users being used if we go back
to our actions and look at users you'll
see that there's another action here
that's called user add in this case and
then we have user delete user list
authenticate etc so let's see if we can
go pull up our list of users we have
exports dot users list so let's go to
our web browser and instead of hitting a
random number let's say users list as
you can see we've hit this it's told us
that we've hit the users list action but
there's not anything here and you'll
have to remember that's because we just
used the demo implementation of a
demonstration implementation of a
backing store for our user database
so let's actually go and try to add
something in this case okay so we're
gonna drop into here and we're just
going to use this quick command line to
go and create a new username in this
case I'm gonna say let's just make an
HTTP command we're gonna set the day to
be user equals by name pratik and
password equals super password password
then we're going to hit our action here
a server API user ad so if we go back to
our code and we go look for user ad
we'll see user ad is here and if we go
down you can see here's the name what
inputs are required as you can see
here's the inputs we can add some
validation to say well we have to have
these two inputs minimally we can say
that this is also not authenticated
we'll talk what this means in middleware
in just a minute but here's again a run
function for an action so here's our run
function our handled to our API object
where we keep our utilities data and
next so we say API users add going from
the params get the username from the
prams get the password and we're going
to invoke this function and if you
remember this discussion started off
with our initializer which contained our
base API for users so if we go back to
that we're in users j/s in our
initializer where we add to the user's
internal API we have our add function
takes a username and password so if we
flip back to our action now you can see
we call API users add with the username
and password so let's go run this curl
command and don't add a new user
okay so we've run this command and you
can see from the result it said these
are the prams are received and what the
action that we hit was so if we flip
back down to our web browser and hit
users list and go run this you can see
that we have a user called pratik let's
go ahead and other user
so instead of finding this time I'll
just use another name real quick so we
posted that new user called FinCEN let's
go back to our user list that we were
pulling up in a web browser by using the
api endpoint that hits the user list
task
let's go reload that and right here we
should see a new user name alright so
that is a quick introduction to
initializers and to be honest there's
not only much more going on here but
let's talk about middleware for just a
second
middleware is the ability for us to run
something before and/or after every
action this is useful as you can imagine
a number of different scenarios we can
use it for basic authentication we can
use it as decorators to do extra things
around the base action or whatever else
you might need to do in your application
and again initializers and middleware
may seem like magic but it's actually
very straightforward in action here it's
not actually magic it's just all wired
up for you so let's go look at the
middleware for example if we wanted to
add some authentication then what we're
going to go do is look at our
initializers pull up middleware j/s and
let's quickly look at the authentication
middleware in this case again this is
just an initializer so we have API and
next so this is where we're truly doing
some initialization by setting up some
middleware inside of here where you can
see that this is global we have a
preprocessor and we'll skip over this
code for now and just focus on the
preprocessor part okay so we have global
preprocessor there's pre preference
processor function is what would
actually get invoked if we were to
enable this middleware somewhere within
our API or within an action ok you can
see we're hitting next year we have a
preprocessor authentication middleware
is the name of this object so if we were
to create middleware we want a
preprocessor or post processor and we
give it some extra properties like
global and a few other things and of
course we have to be a make sure that we
hit next to signal to action-hero that
whatever this block of code is doing is
finished things should move on to the
next one but the real magic happens here
when we say API which again is our
built-in global API we say to the
actions add middleware called this
authentication middle way and again this
authentication middleware is this new
function that we just created all right
so let's go see how this is actually
used if we go into our action for users
again let's go look at a function and in
this case then I say authenticate this
is a different function okay there are
certain places where we want to have
authentication and what we'll do is
we'll make sure that we have some places
in here okay so in this case what we
would do is we would say let's add the
ability to do an authenticate around
getting a list by adding an extra
property into this location which allows
us to invoke that middleware around a
specific type of action invocation okay
so let's move on and talk about a couple
of other things
which will allow us to understand the
action-hero framework the next thing we
want to talk about is grouting robbing
is used to create a same set of
endpoints as previously discussed let's
have a quick example of rally okay so if
we go into our source code and look at
config slash routes ge'ez what we may
want to do is we may want to say well
the users list action is great but let's
say we want to consolidate this around a
restful type of endpoint and say if
people just hit slash users they should
still get the users list so if we come
back here and instead of saying users
list let's just say slash users and do
it get on that and that again gives us
back our list of users and we can see
some other routes here if we do a post
to users it hits the user add action if
we do a put to you this specific thing
you can see we do an edit and if we do a
delete on user that goes and hits a user
delete action that we have so in this
case you can see that we've created a
restful endpoint by using some specific
verbs get post put and delete and
hooking them into the appropriate action
for doing those operations and that's
the basic of browser okay let's quickly
do another demo on TCP sockets so it's
involved today to do different kinds of
distributed architectures using just
standard HTTP and that's great HTTP it's
a flexible stateless protocol that's
very fast but sometimes maybe you want a
stateful protocol and maybe you don't
want the overhead of TCP well we can do
that or you want the low overhead of TCP
well we can also do this by hitting the
action-hero server rather than by HTTP
as we did here by saying telnet
telnet support 5000 localhost and now
we'll say okay looks like we have some
message here it says welcome hello from
the action-hero API the context is slash
API and now let's go hit one of our
actions in this case let's just go hit
users list and let's see what happens
and you can see here's our list of users
we could also say users here and in this
case that doesn't specifically work
because the routing is only available
for HTTP endpoints and not for TCP
endpoints for TCP when you come in you
hit the actions directly with no routing
in place because obviously we don't do
something like this when we're coming in
through TCP or necessarily don't need it
this is more for usage on the web so you
just go and hit the action directly by
hitting users list okay so vanilla TCP
sockets for connecting and would be they
looked at the action-hero server and see
how this specific server is constructed
we would go into the server's folder and
if we go look at the servers that are in
there we would find a TCP server that
lives in here and the sockets file and
you can see it's enabled it's a TCP as
it's secure what what are we running on
was the bind IP address etc etc so there
are a number of different ways that we
can configure different types of TCP
servers if we wanted to or different
servers all together when similarly we
can go look at how the web server is
configured for traffic that's coming
over HTTP and also how the WebSockets
server is configured out of the box with
action-hero we can tune some parameters
if we need to look and see how all that
comes together okay let's get back to
our slides and talk a little bit
or about custom servers and see what
they look like so for custom servers
what we would do is as we saw just a
second ago we would go and create
something inside of that servers folder
and it just allows us a way to go and
hit some of our actions so in some ways
a action-hero server is something that
can listen on the port and go and invoke
an action like what we saw with the HTTP
server with our various demos or with
our TCP server that we hit from the
command line we can have something that
just goes and reads off of a queue or
reads from a IMAP inbox and this becomes
our server that takes incoming messages
from a mail server or incoming messages
from some kind of queue like a rabid MQ
or a Java message cure or whatever it
may be
all right so for example we could have a
have a server that connects to a message
queue reads to a specific topic or
Channel and triggers an action or we
could do something even more crazy like
create a action-hero server that it may
be physically connected to an Arduino
and reads in the temperature or some
other readings from the physical world
using an Arduino connected by USB or
something like that okay so we're going
to go look at a couple of different
things we've already talked about for
example using RabbitMQ to perform
actions to save data or inbound email
perform action XYZ and let's round out
this discussion by looking at a couple
of other things inside of action-hero
which might be interesting to you so
there's a way within action-hero
to go and configure errors to have
specific format or to go to specific
locations okay and of course the
rheticus and bredis configuration which
allows us to easily cluster our
action-hero instances so the clustering
works us this you would set up a reddit
instance or Redis cluster that goes and
fax your action-hero cluster and is used
to share data and store data between
that cluster and do coordination between
the cluster in this case we're just
using a local reticence and so we're not
really hitting anything but we could say
what's our Redis host what's the right
sport
what DB with in Redis do we want to use
and if there's a password user password
and what we would do is we would spin up
a multiple action-hero processes on the
same or different servers and they would
discover each other through this Redis
and do coordination through that way
some other things that we can look at we
can also say if this specific node
should run a scheduler to run delay
tasks what are some cues we can look at
some logging and other things like that
ok so with this one thing to note is
that we can also serve up static content
to food water we have a public folder
and inside of this public folder you'll
see that this is an index dot HTML this
index dot HTML is the index on HTML that
we were looking at when we just went to
dot when we just went to slash this is
obviously one of the first things that
you'll want to reconfigure if you're
building the web application such as
something that uses maybe angular or
react or UJS this is where you might put
that application and allow it to be
served up from here if it's on a
different house or you can just run the
action-hero server independently and
configure your front-end application to
point to your Redis instances and hit
them directly if we don't want to serve
the static content from that same
location and of course no framework
would be complete without having a
testing story and action arrow has the
ability to write tests very easily so
we're in the test folder it supports
both integration and basic unit test
type scenarios it does use mocha as the
test framework for writing tests but
testing comes out of the box for you
ready to write your own test to do
various different things and verify your
environment and verify your test what
are the great things about action hero
is the ability to go and run your tests
directly against small units of code
without having the entire environment
set up so for example if we were to go
to look at our random tasks what we
could do in this case is that because
this is a free-standing
example that's not really using much or
even if we go to a more complex complex
example where we're using the internal
initializer or API of action-hero since
this is more or less a single unit of
code we can go and write some mocks that
simulate the API and the dot users and
also the data and test this action in
isolation as we wish okay so we've done
a quick tour of action-hero and looked
at some code to understand how all this
works hopefully this gives you a better
idea of how to use action here to build
application servers and also to build
API endpoints to run tasks and how to
distribute them if you need more help
you can check the action-hero j/s
website and there's also a channel
where you can go ask some questions and
get up to speed on action arrow I hope
you enjoyed the session and thank you
for watching this video
you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>