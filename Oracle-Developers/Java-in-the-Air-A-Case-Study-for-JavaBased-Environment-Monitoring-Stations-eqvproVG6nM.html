<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Java in the Air: A Case Study for Java-Based Environment Monitoring Stations | Coder Coacher - Coaching Coders</title><meta content="Java in the Air: A Case Study for Java-Based Environment Monitoring Stations - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Java in the Air: A Case Study for Java-Based Environment Monitoring Stations</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/eqvproVG6nM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this is a joint presentation between
Eurotech and oracle we have been doing a
case study on an IOT project actually
environmental monitoring stations my
name is Marco Carrera MVP of software
engineering at Euro tech can I be in
presenting these sessions with Andrew
yes oh I'm Andy killed it I'm part of
our Java embedded software team based
out of the UK but currently me so we've
been doing this joint doing project with
your attack so just a quick note on the
agenda so we want to set up a little bit
the stage for the use case we'll
actually have to go through a little bit
of introduction about the typical
problems in IOT deployments so what are
the challenges of IOT what it is what
are the reference architectures that are
emerging in terms of how to deploy
lighting solutions and what is also
happening in the technology space what
could be enablers for faster to market
and cheaper solution easier to manage
solutions in terms of technologies and
that's going to be the core part of the
presentation and then eventually we're
going to be seeing how these technology
can actually be applied to the inventor
environmental monitoring use case and
what are the benefits that they bring
both in terms of managing the solution
collecting the data and analyzing the
data and then hopefully we'll leave
enough time for question and answers at
the end so IOT make quick introduction
see so it's everywhere certainly in the
Java one session scheduler this year you
have seen like the present of sessions
this is because it's at even according
to garden and many other analysts out
there it's at the peak of its hype cycle
we you heard the numbers or the number
of devices that they actually expect to
be deployed on the fields ranging from
20 millions to 60 million some of these
70 million devices deploying from now
till 2020 or 2030 depending on
what's that you're gonna be reading so
there are other technologies in this
chart actually that went through a
similar curve of creating a lot of
expectation reaching the hype and I'm
slowly moving towards a more mature
state we highlight in few of them in
that slide because they're going to be
part of the presentation here you can
see that they can actually be used as
building blocks that is the deployment
of IOT solutions one of them in
particular a complex event processing
engine they are actually used for fast
data stream processing and they can be
used both on the edge as well as on the
cloud and we'll see a use case of how we
can apply them here in this specific use
case
others are machine-to-machine
communications these devices are
actually deployed on the field they are
connected especially over satellite or
cellular networks with all the
complexity and the cost of this
communication link spring so there are
specific technologies and protocols that
have been emerging in the space to
address these budget challenges and of
course cloud computing to actually
commoditize the cost of the
infrastructure and deploying it on the
field so why are you team projects are
different the regular IT project what
makes them more complex well if we have
to summarize it in one word is
fragmentation and integration put it
together an IOT system is starting from
selecting sensors and then giving
internet connections to those sensors
transporting data is or receiving
command over as we said subtler or
cellular networks and then receiving
large volumes on data in the backend and
needs to be analyzed filtered processed
and translated into actionable data and
intelligence that may convert into a
feedback loop that sends commands back
to the devices all these steps which you
know can be summarized into a collect
analyze transport and store if you want
to summarize it into four biggest
actions they present their own typical
IT challenges and more talent challenges
from the IOT space in terms of
integrations sensors the general are
coming in many different shapes and
parts depending on the environment
where you're gonna be deployed them so
you're gonna have challenges in
selecting the right sensors integrating
it to transport the data and give
internet connectivity to these sensors
we generally need to follow the approach
of a gateway that actually owns the
connections and the communications with
the field protocol and the sensors and
we talked about the transports and all
these things change so to address these
challenges so if you are able to address
these challenges though the benefits are
you enterprise so that's why i io T is
at the peak of its hype cycle at these
points IOT can improve your current
operations right if you have more
visibility on your data and your current
operation statistics you can actually
find more improvements and that that you
do not see before at the same time it
can also be disruptive in the sense that
it can propose new business model and we
actually see the use case in the
environmental monitor State Station is a
typical use case of that part but the
challenges are the large amount of data
as we said and the fragmentation at the
edge actually put in the devices on the
field and gathering the data and manage
them as we go there so to address these
challenges there are some architectures
that are emerging at this point and the
architecture follows the typical
principle of actually decoupling the
different architectural layers so
decoupling the field layer from the
communication layer and putting
solutions like what they are normally
called integration platform even in the
deployment of IOT and m2m so if we start
from the bottom of these slides we were
talking about the sensors in this case
we have one sensor there which is that
black box that you have there it's
supposed to be monitoring air quality
and environmental measurement will go in
details later so from there we need to
collect the data and send it and we will
use gateways approach to do that so
basically these are embedded computers
deployed on the field their
responsibility is to gather the data on
the internet connection whether it's on
cellular satellite or wired or Wi-Fi
depending on the deployment that you
have that's where your embedded
application is going to be running
that's where your edge computing is
going to be happening you're going to be
coding and developing on those edge
computer this
Lucian's that will drive all your
applications so the collection of the
data the analyse the analysis of the
data and the sending of the data then
once the devices are connected to the
internet and then you push them into an
integration platform you choose certain
protocols that are IOT friendly mqtt is
one of them co-op is another if you have
heard them there are many sessions
actually in Java one that goes in
details about these protocols and you
will use this protocol to efficiently
transport the data and manage lynnie
remotely your devices once you have the
data into typical IT systems like a
relational database and you know there
are plenty of tools at that point that
will allow you to do and consume the
data and extract the value out of the
data itself what we're going to be
focusing on in our presentation is more
the bottom part of the late year so what
can we do to simplify the development of
applications on the edge what is the
current state of the art in developing
and deploying applications on IOT
gateway so again think of them as the
edge computing note of your IOT network
so traditionally edge computing nodes or
Hyatt gateways where custom projects
that were developed for a specific
custom solution which basically means
that you were designing a hardware for
scratch most of the time cost driven so
carefully selecting your components to
fit a certain budget putting a minimal
Linux on it to get a tcp/ip stack that
could connect on the internet and then
deploy a custom embedded solution that
was developed just for that project
cross compiled and deployed on that
field and that was the state of the art
until very very recently Mike C can
imagine the the cons and this approach
was that the time to market was really
long and the costs were prohibitive
every time you you were deploying an IOT
solution you were starting from scratch
every time so what has happened recently
is that the communitisation of the
hardware and CPU power of these hardware
for the price has increased dramatically
and now technology
that were exclusive to the IT world
before right in the server space are now
becoming available also in the embedded
space and become good technology
frameworks and platforms for developing
your IOT applications deployed on the
field so it's the first one that you are
looking at is a code that is portable
across platforms of architecture so that
you know you can actually switch your
hardware underneath but protect your
investment on the application and
actually move the application from one
hardware platform to another for example
you can start on an arm platform or an
open hardware raspberry pi and then when
you massively deploy because you're
having success you actually want to move
to Dragon dies Hardware it's faster
cycle you want to protect the investment
that you have done at the software
development cycle you want applications
that actually can be portable across
these architecture Java no surprise we
are at JavaOne is one of the
technologies that comes to mind when
you're trying to do that and it gives
you one level of abstraction over the
hardware and give you a portable
solutions but java by itself in an IOT
gateway is not enough on an IOT gateway
you need to be able to remotely manage
them as we mention more than once that
means the ability to actually drop
applications on a runtime and other by
installing your application or upgrading
existing applications so Java with
modularity comes together from our CI
which is the next important layer when
you actually try to put together an IOT
stock so SGI will give you the
modularity will also give you through
the Compendium specification the ability
to define configuration options for your
services modularize your application in
different discrete component each of
them we servicing them with very well
defined interfaces and then because of
the needs and the specific reasons of
developing an IOT gateway on top of java
SGI there are certain frameworks that
have been developed to it further is the
development of IOT applications when you
are talking about interacting with the
field right so the tech tips typical
example of the java standard edition
right now there's now contain api is to
interface with the serial port which is
still maybe the most popular way of
acquiring data on the field you actually
need to get an implementation yourself
of that library included and package it
so frameworks like Eclipse Cora which is
a recently graduated and released the
framework allows you to give it comes
with a set of pre-configured bundles
OSGi bundles in that case as libraries
that is that development effective well
we go in these as pie it basically
abstracts a little bit the hardware and
it manages the cloud connectivity and
provides tools common set of
functionality that you would normally
have to deploy when you do it like them
so out of these four components wrote
java OSGi and eclipse cuda we'll walk
through them briefly
we start from java so we talked about
java today
we all know hunched over one is the most
popular programming languages out there
nine million developers and Counting
there are many banners around san
francisco that reminds us wherever we
walk to Java tomorrow is has the hame
and you see the program of the
conference actually makes this aim and
objective very clear to actually spend
not just at the enterprise level but go
from the IOT gateways and the small
gateways deployed on the field so from
the field to the enterprise one single
language one zero platform if we have to
reach twenty million even thirty million
devices in ten years we will need a lot
of developers that can code them and
Java at this point is a very good bet
that could be the programming languages
that we will use to code and program all
these devices on the field then a quick
introduction on hora so we mentioned
that CUDA builds on top of Java and OSGi
and fills that gap in terms of libraries
and functionality that are normally
needed to code an idea to actually
programming IOT gateway we also go from
the example of if you take a Raspberry
Pi with Java you have a programming and
runtime environment for Java you do not
have an IOT gateway you do not have the
libraries that allow you to connect to a
for example remote or MQTT or co-op
broker you do not have api's or user
configuration to configure a different
networking option whether you touch a
cellular modem or a Wi-Fi modem and you
don't have a field protocols like in
facing with you dev or the USB bus or
Modbus or can bus to actually be able to
acquire the data easily you will have to
collect all these pieces together if you
actually divide that with the pel of
death applications or you can download
kora and with four common commands
install it on your raspberry pi and
start off and it will give you a full
set of Java libraries that that you can
actually get going on it
what could I gives you is that the
application portability that we
discussed before in the sense that you
can actually start on the Raspberry Pi
on these libraries yeah sure so the
Gateway is actually deployed on the
field right we use the term IOT gateway
as a device deployed on the field that
interfaces with your data sources right
so in the case of our environmental
monitoring stations you will have the
sensors that actually read the air
quality and inside the same station you
will have the Gateway where your
application run alright so your
objective when you're deploying this
application is developing code that runs
on those little boxes right and you have
many of them on the field and once you
have them there you need to be able to
manage that so what could I gives you is
exactly that try so is the ability to
have a first time to market development
on Java based solutions for interfacing
data on the field and transmitting the
data on the cloud and at the same time
being able to manage the device once it
is there like so deploy a new version of
the applications change the
configurations options of your device
right and we will see examples later on
you can actually for example depending
on your application domain configure
certain thresholds or set different
parameters that may evolve over time or
may evolve because your business
analytics tells you there is time to
change some of the configurations
options so how do you push that new
values down to all the devices maybe
some of these devices you may not even
have access to them right they may be
actually behind firewalls and you don't
have IP addresses so the remote
management functionality okura combined
with the use of a protocol like MQTT
will allow you to give you a very good
starting point of solving these type of
problems
who as we said is an open source project
so all the code is available there's no
law
in on your side right the code is you
can start it on your platform movie to
other platform should you be interested
in having a supported model there are
also companies behind it like your
attack itself and the result so a
commercially supported version of Moodle
and some different Hardware some
produced by era Tech and others may be
produced by yours
a quick look inside cool itself and what
it does so it's organized as a set of
declarative services OSGi declarative
services we can kind of group them into
this architectural slide so at the
bottom there is a little bit of the bias
abstraction so it kind of brings in some
of those api's that are normally not
packaged with the JVM but there are
crucial for IOT type of applications so
interfacing with a USB port or
interfaces with the serial
communications Bluetooth or at farther
down levels like the GPIO so the general
purpose i/o the some of these gateways
have I squared C SPI so really acquiring
data from sensors on the field that IO
that player once you have that data we
have some basic gateway services like a
lot of these gateways for example are
now battery-operated you may be aware
that you know you cannot install
gateways the battery operated on
vehicles for example because batteries
are inflammable right so clock
synchronization is one of the key pieces
and you do it on flaky networks that you
know you may need different policies
then the standard NTP that you get on
Linux so the clock service is a
configurable component and basically as
soon as the device starts up we will try
very quickly to synchronize your
Caucasus internet or coming and through
configuration options you can actually
determine it how it tapers off after
that if it doesn't succeed same thing is
for the watchdog right if your
application stops responding and you
want to have hardware level watchdog
that reboots the whole whole board right
the way so that it gets back into its
initial conditions and the applications
start functioning again we talked
already about the network configuration
that's specifically important on
gateways to have multiple network
connectivity options so gateways that
are used for example to retrofit the
existing solutions that generally one of
the possible use cases connection the
delivery is the one that collects the
data and sends this up for a developer
experience
I think we briefly mentioned about that
but the idea is that because of the
portability of Java we can also offer in
more pleasant more productive
development experience than what used to
be the traditional embedded development
before so no longer cross compilations
on your Linux machines and moving of
your binaries but actually being able in
your Eclipse environment or in your idea
environment to emulate the gateways or
run the whole could a stack in your
laptop attach your serial peripherals or
other sensors that you have to your
laptop tests of your applications and
then other deploy it on the target if it
is locally so the local gateway on your
network or push it through the cloud to
hundreds of devices that you may have on
the field so with that we kind of
address one of the two challenges that
we present it at the beginning right so
we said you know we need to code these
devices we need more modern tools and
framework to be able to reach the
productivity and the volume and to be
able to manage them the second challenge
we presented was the amount of data both
the data collected at the at the edge so
on each of these gateways and at the
cloud so what we can do on that I'll
turn it over to Andy ok so I'm gonna
talk a little bit about from Oracle's
vision for for data a little bit about
complex event processing as well so our
vision for this connected device system
is kind of this there's three elements
that we see so first one is you've got
these connected intelligent devices and
the key word there is an intelligent
device so we're not talking about light
bulbs sensors that they're just sending
the data here you have some kind of
intelligent device probably a gateway
although it could be a smaller module on
it on a chip and that intelligent device
can run multiple services so Marko
talked about Kuro so you could run Kura
on that intelligent device loading those
multiple services and really start to
analyze that data on the edge
the second thing that we see is you need
the real-time analytics so you've got
high frequency data coming in from all
of these sensors and you want to be able
to process and analyze that data in real
time and combine those data streams
together to maybe come up with a
different conclusion so basically you
don't just end up with raw data you end
up with a business event and then third
and this is an Oracle term is we end up
after we've done that real-time
analytics with fast what we call fast
data so data that is useful straight
away that doesn't have to go all the way
back to the Oracle back-end to analyze
it and the week next Tuesday it tells
you you had a fault in your system you
need to know now that something's about
to fail or there's some some condition
that needs to be acted on straight away
so that's the idea of the fast data wise
fast data important well the value of of
an event of a business condition that's
occurred in the edge decreases over time
and actually decreases rapidly over time
so you can imagine if you have a sensor
in a warehouse that's sensing for a fire
it's really really useful to know that
the fire at go note that happened or is
happening at that point if you wait an
hour the value that you knew that the
fire was going to happen and decreases
rapidly more importantly in an
industrial system you can predict maybe
based on on multiple sensors in a device
if that device is about to fail and
maybe switch it off before it fails so
actually it makes the repair of that
device a lot easier if you don't let it
break I knew you maintain it before it
actually gets that break condition so
the earlier in this cycle that we can
start the process that data and take
those latencies out of the system all
right so if you have the business of n
the moment you would have to send that
data back to a cloud or back-end system
that creates a latency if then ask to go
into analytics thing then has to come
back if you could process that on the
edge in real time you've taken
immediately taken a lot of that latency
out the system now we're not saying it
doesn't have to go to the backend it
does but what we want to do is send
through meaningful information to the
backend not just the raw data the other
reason we want to do that is despite the
proliferation of 3G and 4G technologies
the amount of data that you want to
transmit over that kind of connection is
is very limited you want to keep that
small because as you get these billions
of devices you're just gonna flood the
network and even Vodafone doesn't or
AT&amp;amp;T don't don't want you to do that
because they can't cope so what we've
deployed is the use of complex event
processing so this is a definition from
Wikipedia so basically the CP or complex
event processor is the ability to
confine multiple streams of data combine
them together and come up with a new
event so some new meaningful pattern or
a system that basically suggests
something else is occurring so if you
look at the streams in isolation you
might not notice anything interesting
but if you know that for example air
conditioner overheated on on a Tuesday
and you look at the weather you say well
actually was really hot
you know exceptionally hot hundred
degrees or more that's a correlation you
can make and you then have that
information so that's at the bottom here
is what it's saying the goal is to
identify business meanings of the events
so not just that raw data but come up
with a business meeting
so what are the types of things we can
do using a CP processor so we can do
filtering so for example if you have a
stream of temperatures coming in you
don't want to know every single
temperature that's coming in and you
really only want to know probably if the
temperature goes above or below a
certain range so you can apply a filter
and say yeah only tell me an event if if
the temperature is above 200 Gries
Fahrenheit or something like that the
second type of thing is the correlation
and aggregation so for example you've
got multiple streams coming in and you
want to combine them or look at a
specific time window so for example you
want to take the average heart rate of
somebody over the last three days that's
the type of thing a grenade and
correlate that information the next type
of thing we do is pattern matching and
it's really powerful because if you try
and write a patek pattern matching
application yourself yes you might think
it's quite simple but as those events
start to come in and get more
complicated it comes very complicated
very quickly so by using a complex event
processing engine you can really do
pattern matching very easily so you
could say if this event happened and
that event happened and that event
happened and even say when that happened
and combine that at the bottom point
here of the geospatial one let's say
where that happened and combine all that
together and you can really do something
powerful
another thing with pattern matching is
that lot of people forget about is you
can also check for things that didn't
happen so I expected to see something
happen this morning at 9:00 a.m. and it
didn't happen so you can you can write a
CP engine rule to say tell me if a
certain condition doesn't have it and I
said to be powerful when we've got an
example of that in the demo I think and
as long as we can figure out
and so it turns out Oracle has a complex
event processing engine it's came from
our back-end technology so it's part of
our fusion middleware solution that runs
on the on the on the back end where we
create an embedded version so we've
shrunk down the the Enterprise version
from about 300 megabytes to I think it
runs in 30 megabytes on a device and
that allows us to basically put that
event processing engine onto the Gateway
so that's what we've done here so if you
look at this from left to right so we've
got the sensors coming in that's the
dumb sensors information coming in at
information overload that goes into an
input adapter and the input adapter
turns that raw data into an event right
so you get a specific event and that
creates a stream into the CEP engine in
the center once it's there we can then
do all the good stuff that I just talked
about it for the CEP we can do event
correlation we can do streams combining
we can create relations etc and once
you've done all that processing at the
other end you send combined events right
so you take those raw vents you turn it
into another event and then finally it
goes through an output adapter and then
goes off into something else you'd be
into the cloud could be directly into a
data center could go from the cloud into
the data center for other processing for
it and go into business rules etc um so
how do we do that query and that
processing in the middle so there's a
couple of things we have in the the
Oracle system first one is we have this
new language which is ANSI standard so
it's not just an Oracle proprietary
stand language it's an ANSI standard and
essentially what we did we worked with a
group of people to create this cql so
continuous query language well that adds
is basically it adds the ability to
create a relation to a view using the
SQL type syntax from a stream of data so
the example is I want to take a snapshot
of that stream because the data is
continuous right so you want to take a
snapshot of that stream and say give me
the last 30 seconds
and then you perform some coding or some
algorithm on that snapshot the example
we have here at the bottom is we take in
an average temperature but from the last
minute and it's a very simple example I
think we have actual examples of the
code we've got running here but this is
very powerful so that that query selects
your data and then you have a java
application do you write to process just
on that data so you don't have to think
about the streaming nature of the data
you just take a snapshot all right so
this makes it a lot easier to program if
you understand sequel the second thing
that we have in the Oracle system and
this is very powerful is this graphical
tool which allows you to create your
streaming and your event network from a
graphical point of view so we have
moving away from the mic we have
standard protein C R so we have an input
adapter or in an output adapter so
that's what you saw in that the diagram
before the way we the adapter turns the
raw data into an event that's in the
system we then have channels and that's
just a just a connection mechanism
really it routes that the event through
into the thing and then where the heart
the system works is really in these
processes so you can see here in the
network we have adapters here that froze
through into a processor in the middle
and then finally it flows out to an apt
output adapter output adapter can be
anything you want it can be a Jason
thing like we have here it could be in
the Qura system it's mainly MQTT right
it could be restful it could be X now it
could be a
flop right into a flat file system
doesn't matter right you just write your
own adapter and within these processes
that's where the cql lives onion also
the java code so you write just POJO
items plain old java object to do the
the processing on on the data that
you've selected with the the sequel so
after all that we actually took oep
embedded we put it onto this gateway
here with working with your tech and
basically the use cases we we've got
this environmental monitoring solution
from the past here which is basically a
mini data center so you have to have a
shed essentially that you've put all
those server in and the mass and the
temperature sensors and everything and
your attack have created this device
which means you go from having this mini
data center into this tiny little pole
mountable device which does the same
functionality as as that big
installation before so back to marco a
good example of what we said at the
beginning right how Iitate technologies
can be disruptive so the traditional way
of doing air quality monitoring very few
of these centers sparse around the town
two or three four very large town but
very precise answers right actually so
precise that to actually do a reading
you have to collect a sample and then
let it sit there for maybe a day or two
before you actually have the very
precise reading that that sensor has an
alternative that could be cheaper but
many more reference station that you can
actually put across the whole territory
so you can actually get more detailed
reading across the whole town that will
give you real-time data and may not be
as precise but through some tricks you
can get in quite precise in fact in this
specific use case we are deploying
similar
sensor boxes right on top of the old
ones so we can actually see how they
deviate from each other and actually
correct the readings across the rest of
the town so you can get actually at that
point real-time reading very precise or
precise enough across the whole town
right so typical use case right a lot of
devices so you need to manage them you
need to calibrate them as you know the
the sensors inside these boxes are
around 15 each of the sensors is
different and I mean not just from brand
to brand I think from one sample to the
next sample right the correction factors
try to calibrate and get a very good
reading out of these sensors you need to
calibrate each single one of them right
with a different calibration factor so
converting the road to a calibrated
useful data is important the response
curve of that sensor changes over the
life cycle of the sensor itself each of
the sensors normally last two years and
the correction factor changes over the
course of the life of the sensor so you
need to be able to as you push
intelligence into the edge to push also
configuration changes and readjust all
these values either based on your
reference reading from the old legacy
stations or based on the life cycle of
the sensor itself so this is hmm quickly
or what we are measuring so around 10 or
12 if I remember like your quality
measurement electromagnetic radiation
radioactivity itself and temperature
humidity and pressure so we actually
have inside the box in air chamber so
there are some air pumps at the bottom
that sucks the air in move the air
through some little pipes into the air
chamber the air stays there for the
response time that the sensor has
prescribed right so it gets it there for
a few seconds and then it's pushed out
right so you get that's the best way of
getting the readings all the Electric
magnetic sensors are at the top where
the connectivity is so as we said there
are the sensors there is the gateway so
what is the gate we doing is basically
getting the real-time reading and doing
statistics on the readings itself right
for different legal requirements
fending from country to country you may
actually be required to do average
reading on a hourly basis generally
every eight hours and then you have
different thresholds that determines are
there a warning level or an alert level
that needs to be configured again
depending on what legal czar this is an
example of you know what the web
presentation would be of the data that
you get collected we present it there
just to see what is the type of business
logic that you want on the edge right of
this type of data analytics that you
will perform in there so when we took
this project with Oracle right we lay
down this type of architecture so you
can kind of see and hopefully you can
put together the pieces of everything
that we've been talking about up until
now so on the Gateway side the
traditional hardware with Linux and then
Java for the portability and OSGi for
the modularity and then we kind of have
two pieces right the CUDA yaself pieces
and so those bundles that allows us to
do the rapid development are the
applications and interface with the
sensors in fact the sensors are
controlled by a microcontroller that
spits out all this reading in a serial
port that's what we are using in this
case the ESF bundles also owns the
connectivity to the cloud we are using
the MQTT protocol for sending all the
data to the cloud but also receiving
communications from the cloud in terms
of configuration abates
or application updates the data is the
EM process in this case not by
traditional Java applications we
actually started with the traditional
Java applications right hand coding all
our math to do all these statistics and
when we just noticed that as we add more
sensors we had to change all the logic
so we thought there must be a better way
of doing this right not just from a
coding perspective by looking at the
problem or from a data perspective
because that's really what it is so next
to the CUDA usf bundles on the same OSGi
containers we installed
OAP right oracle event processing and
bedded so same OSGi same philosophy you
can actually see how the convergence of
all the technologies right java SGI and
sao SGI container and put the two
bundles together one for the data
analytics and one for interfacing with
the fluid and only in the quad
connectivity
and then the application flows more or
less like this right so the kuda bundle
will actually interface with the sensory
inputs periodically every three seconds
in this case and just because of that
air flow process that I was describing
before the kuda bundle will go to the
sensor and say give me your latest
readings then that data is passed on to
a PE that is doing all the statistical
operations right and we will see them in
a sample so calculating the average is
doing the publishing establishing
filtering and so on and so forth then
when the event network has processed the
new samples it may depending on the
rules that you could in that event
network beside that that's a value that
should be promoted up to the cloud so
being sent up to the cloud so the same
event now is poop sorry it's go back
it's pushed back to the CUDA bundle that
owns the cloud configurations and will
push it up the N key to do the other
flow that we will see later on in the
demo is the configuration update which
we can stress from the beginning right
so the ability eventually to evolve the
logic in the VoIP network through remote
interventions right through the possible
configuration of different loads
thresholds or things like that so that's
kind of the flow now let's take a look
inside at the oep network so this is
very hard to read from here so we'll
actually switch and actually show you
that on the development environment so
we can follow that by there what it does
before we do that let me give you a
quick overview and then we'll analyze
each of the single pieces right so on
the left side if you remember what Amy
described there are the input adaptors
so basically these are your data sources
in IEP terms these are the stream source
so they basically get the data from the
sensors in this case we map the three
six nine ten sensors so each of these
little blue boxes that you see on this
column is one of the sensors that we
read okay then the next one here are
data channels there are basically little
buffers that you put from a source to
the next from one node to the next
processing node into your network so
they collect the data as it's coming in
and flowly send it to the next component
down into the pipe we categorize this
first layer in terms of input adapters
because some of the sensors and we'll
see that in the life they actually spit
out data in slightly different formats
so our first block here is normalizing
all the data is coming from different
sensor in a common data model that we
will use through the rest of the network
right so this channel here in the middle
is receiving events all structured in
the same way which is the sensor type
the sensor reading and where that sensor
data should be published to should that
be elected for publishing later on from
the event processing Network and then on
the right side we actually started
putting our processing flow right so the
first one that we actually did was okay
let's read the data and publish it to
the cloud right so this is possibly the
simplest one as you can see the data is
spread normalized and immediately sent
to an app to the adapter just as Andrew
was describing before these output
adapter is a little Java class that is
basically wrapping or delegating to the
CUDA bundles the formatting of that
event the serialization that event and
the publishing of that event to the
remote cloud once we got that working
then the fun starts because really we
had the basic flow now we could actually
start doing something useful so the
first thing we said okay let's play with
filters so we took the data from the
sensor and we started playing with
thresholds so old
data below this level or above this
level we're not really interested there
must be other spikes or no no good
readings so as to the filtering flow so
the data gets picked up it actually
passes its filter process and then
finally through the different channels
it will actually be signed out let's do
the statistics I want averages that gets
computed on different time intervals the
pattern matching that was describing any
is one of the key features of OE PE so
you can define moving time windows and
calculate averages out of that moving
time windows all with no code right
basically just writing cql statements
then for the nameless to the alerts so
if the message is or if the average is
deviate from each other from a certain
certain thresholds and we'll see how
that was implemented send me a special
message not just the reading send me the
fact that the value moved beyond a
certain threshold that was interesting
monetary and then finally I can use the
same data flow to actually detect
missing events right so if I don't see
certain data points for certain periods
of time from one of the sensor something
may be broken so up there I actually
have a diagnostic data flow that sells
me to monitor or self monitor the manage
the systems as they are deployed on the
field itself so with that in mind
can we get the mic on the the table
switched on please
thank you can you hear me okay so what I
have opened here is JDeveloper
JDeveloper is the development
environment for designing oep networks
this is the same network that we had
before on the slide so you can kind of
see the inputs on the left that we
discussed before and the processing so
let's open one of them so TPU stands for
temperature pressure and humidity it's
actually a single sensor in the board
but it does give three readings right so
part of the normalization process was
actually to decompose this so to
decompose this reading and out of a
single event that is coming from the
physical science or create three logical
events separating the three measurements
that were produced right so in one case
I get so in my case I separate the
temperature and pressure and the
humidity as three separate events and
you can see I'm not doing that in code
right we are basically doing all that
through cql statements out of a single
event that was coming from the board
three logical events being pushed out
sure
yeah so now and we have experts here
that can correct me but now basically
means on every event I comes in at this
point right so it's triggered by the
event itself so it's not on this exact
instant but it's just on the event that
was triggering that rule at that point
yeah exactly
okay so just as we be composed TPU all
the others are basically formatted in
the same format and are in the same data
structures and they are pushed down into
the event network so we'll go through
the examples of for example the
statistical averages so this is this
flow here where the flow event is first
initially processed by a basic start
processors and then whatever comes out
of this is passed down through the
channel into the output adapter of the
MDT publisher so for demo purposes here
we were actually operating on a moving
time window about 30 and 60 seconds so
not the legal terms that I described
before of eight hours intervals but you
can see now the flexibility of a cql
statements when you are operating on
data streams right to do a statistical
operation on moving average which is not
rocket science but it's not still the
simplest piece of code if you want to
have it generalize across different type
of sensors through a select statement
you can actually define the moving time
window so you're basically saying look
at the last 60 second and every 30
seconds recompute is value compute the
minimum the maximum and the average and
anything else that you're interested in
in that frame and then you also define
and this was the common event model that
we are defined where that topic should
go where that data point should go in
which stopping in this case into the
status 30 seconds you want another
average you just write another sequel
statements right so in this case the
basic stats model was competing moving
moving time average over the intervals
of 30 seconds and or 60 seconds if you
pick up another examples you can
actually look at
the raw data filtering where we can see
some of the interactions with the
external word so in this case they're
all value would actually be published
into the filter topic so that's the
output adapter configuration on which MT
tidied up it is would go to if and only
if the sensor value is within a certain
range and as you can see the sensor the
range itself so the thresholds for the
range are determining by an interactions
with the CUDA bundles and therefore
these thresholds are configurable
through remote configurations into the
device itself so maybe show this in
action and then we'll go back and
explore maybe other parts of the event
processing Network so the sensor box
here is actually functional right we
have it connected in this case is
connected through my laptop right using
the emulated environment that I was
describing before so the serial data is
actually entering into my laptop and
then my laptop is publishing that into
the cloud and then this dashboard is
actually pulling the data from the cloud
and showing every three seconds update
from the sense of reading that I have
here in this room in particularly what
we are interested is the electromagnetic
frequency right the sensor that was at
the top which as I'm sure you know
responds to cellular activity around it
so in this specific case we're actually
making or making a phone call now right
with that cell phone over the
electromagnetic sensors and you can see
immediately the spike of activity into
the electromagnetic frequency there
right then he and gets up to the phone
move the phone away and then boom it
goes down again now what we're gonna be
doing is actually playing with that
thresholds range right
remember that basically we had the
filter draw so here we were publishing
the row values that was the bottom of
our event processing Network and then in
the middle we have the filtered values
basically on the value that we're within
a certain range so we saw that we
reached a spike at a thousand something
so let's try actually say that we are
not interested in values above 700
probably not a realistic use case but
just for
the sake of demo purposes now the same
gateway here shows up in our everywhere
cloud management platform right as we
said all the kuda devices can be managed
remotely from here I can actually
explore all the services my session did
not expire
okay so what I see here is basically
this device right just as I described it
that's connected to the cloud over MQTT
pond connections through the CUDA
framework I can actually introspect all
the HDI services that are installed in
that in that device as you can see
basically all our detectors so our
sensors have different considerable
thresholds from here including the HF
detector which is the one that we are
interested in here that has a lower and
an upper threshold exactly the same two
parameters that we saw on the EPM
Network before of three hundred and a
thousand so for now let's lower this
down to let's say 500 and push the
configuration update so from the cloud
what we're actually pushing is the new
configuration value this switch is this
laptop in this case I say this gateway
the Gateway gets new value and the APN
will actually react now on the new value
so now if we try again and we make a new
phone call we will see that the row
values will still go up as before but
the filter values will not
okay can't see now it stopped at 500
where we put it at the upper threshold
right and then it went back down while
the reality value went up to 840 just as
it was before okay Thank You Luka all
right
so going back to our network just to
look at the more interesting a more
complex example of what you can do the
alert section is a good example
so we basically are using three
processing modules in this case so we're
using one that basically computes
averages over a partition of three rows
so that basically means three data
samples if you recall we were saying
that we get one data sample every three
seconds so that's basically a different
way of computing a moving average out of
nine seconds if you will of real world
you know world clock time and then we're
also computing an average on a longer
time window about 30 second right same
type of sequel query but on this would
be morally your historical base right so
what we're trying to do here is
basically compute two averages one on a
longer historical and one on a short day
story is three so that we can actually
detect sharp changes in to your values
by comparing the two averages right so
we first use two nodes to do the two
averages so the short one and the longer
one and then you can kind of figure out
this was a little bit more complicated
because it was a real world scenario
with sensor values that were a little
bit in the mix but we can basically we
compute the difference between the two I
think it was here in the middle yeah so
we establish a correlation between the
recent and the average one and we call
that sensor value change this is also
view so cql also has the ability of
creating in-memory data views so this is
a view that actually does the
computations of establishing the
relationship between the two averages
and then we just apply a threshold on
that average by saying if the sensor
value change is again within a certain
threshold upper and lower that we define
then publish us and alert in fact we saw
that working in our demo before where if
we had sharp increase or sharp decrease
in this case it was actually a 25%
increase or decrease of the recent
average compared to the historical
average an additional message was
published as an alert so that hopefully
give you a little bit of an idea of
everything that we can do I think we're
done with the demo let's go back to the
slides so summary of what we talked
about
so DPN in this specific use case which
is a real word use case proved to be a
very good way of implementing business
logic for data-driven embedded
applications you can imagine the
advantage that if tomorrow we add a more
sensor mostly none of the code needs to
be touched at this point you just attach
the new input adapter and everything
will just work smoothly after that it
also shows how a cloud management option
for your IOT device can be a great
partner to business logic driven through
event processing network because
basically the network evolves as you
push configuration changes or additional
parameters into the network itself so
we're establishing a very good
partnership with Oracle we we are
continually working together to actually
make these two environment to to coexist
and to be easier to integrate and
develop on and that's what can we have
focusing on going forward if you want to
learn more about each of the technology
that we talked about there is boots by
eurotech with the sensors on this plate
and we can give you also more details
about Cora certainly there is demos at
the Oracle boots and if you want
specifically anything more about Cora
visit us at eclipse.org slash Cora and
you're certainly welcome to contribute
it's an open-source project we
appreciate your feedback on that I think
we're good for now any questions yes
yeah so yeah if you visit us at the your
attack booth we can give you more demos
that part is not open source so the
cloud is a management solution for Cora
devices yeah so there are two parts of
that so one part runs on the device
itself and that's part of the open
source the MQTT interface to actually
push bundle updates is also part of the
open source so we publish the contract
so you can use any mqtt client to do it
if you want to or you register your
device with our cloud and you get that
other through a web interface or through
REST API so yes yeah so generally we run
from 256 megabyte like Iroquois and Java
C stack right so generally we recommend
256 megabytes so kind of like a
Raspberry Pi type of device from that
that upwards yeah so upon receiving
events from remote servers by or from
the cloud those events can be input into
your API network and the output of your
EP network can be executing local Java
code in that gateway right so at that
point you can have any kind of business
logic that you may need in your specific
use case triggered by remote events
still embedded into the EP network
exactly so you can still do it that way
if you need specific custom logic
so where's this for that statement yes
of course yes yes yeah so yeah so Cora
comes with some libraries to do that
right so if you are interfacing with PLC
modules there is a very good chance that
we are talking Modbus so there is a Java
Modbus library that comes with Korra we
didn't use in the dis use case because
it was not needed here but Modbus can be
both your input or your output depending
on use case when you're interfacing with
PLC systems know as part of the clips
CUDA framework there is a Java Modbus
bundle that you can use then you'll need
if you want to consume it in a IP
network then you can use and wrap it
into an input or an output adapter
depending on your use case
so there are two ways of doing it right
you can either use mud baths if you're
interfacing there or yes or cool itself
has a library to interface with the
general purpose i/o I Square C and PWM
of the Raspberry Pi through java api ism
so if you are connecting the sensors
directly to the Raspberry Pi board then
you have AP is for dealing with that
sure yes so one last thing I want to
personally thank Oracle for helping us
to put all this together especially team
grapes
able to be bet being possible without
him so I just want to be sure this is
this is there yep the whole box so
please visit us at the euro tack booth
depends on the market that you're
looking for but it's in the or there are
a few thousand euros ok thank you so
much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>