<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Why Isn't My Query Using an Index? | Coder Coacher - Coaching Coders</title><meta content="Why Isn't My Query Using an Index? - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Why Isn't My Query Using an Index?</b></h2><h5 class="post__date">2017-08-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/nL2wGIoN9tM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so spelt properly this time so I'm Chris
Saxon I'm part of steven feuerstein
oracle developer advocate team and along
with Connor McDonald's and Maria Colgan
the answer team on ask Tom it's our job
to help you get the best out of the
Oracle database and hopefully have a
little bit of fun while doing so so with
that in mind we're going to be looking
at sequel performance in indexes bit of
an introduction to that so let's get
started now any of you who spent more
than a few minutes trying to tune sequel
queries of almost certainly at this
question at some point why the bleeping
bleeping bleep is Oracle not using my
index as far as you can tell it should
be doing you know your query only
returns a few rows all the columns in
the index are in the where clause
there's no functions on them or anything
like that but Oracle's decided to go
with a full table scan instead why is
that
well Oracle has decided that the cost of
using a full table scan is less than the
cost of using an index which is kind of
a true answer but doesn't really help us
you know I've just said it is because it
is really so what I'm going to do today
is investigate some of the reasons why
that cost would be higher for an index
and a full table scan and vice versa but
first I want to talk about something way
more interested in exciting chocolate so
I've got two young daughters and they
absolutely love chocolate and if they've
been nice and being good
I'll let them have some chocolate at the
end of the day but as any of you who've
spent any time around toddlers will know
they can be quite particular quite fussy
they love chocolate but it can't just be
any of these chocolates at all no no no
it has to be the red ones and only the
red ones if I give them a blue one or a
green one I'm going to have a screaming
toddler on my hands and I don't like
that so what can I do so my daughter
comes to me and says daddy I've been
good can I have some chocolate and I go
have you been really good to me go yes
and I go okay then have some chocolate
so I've got you know huge many bags of
mmm so what I can do is I can scoop them
up and pick up a few of times open up
the first bag sift through look through
find look at all the mmm see whether
they're red or not
if they are keep them if they're not put
them back in the bag then I'll move on
to the next one in my hands open that up
look at it see whether or not it's red
put it back keep it if it is put the
rest back and so on once I've done that
gone through all these bags I'll then go
through through with the next batch next
batch look through see they're red hot
and so on and so I did this a few times
and I thought to myself well there's got
to be a better way of doing this because
after all I don't know where the red
sweets are they could be in any of those
bags and I have to go through and look
at all those weeks see where they're red
on up I've got a better way I'm you know
there's better way of doing this surely
so I figured to myself okay after I've
gone to the shop and I've come home what
I'll do is I'll create documents I will
write down the color and location of
every single sweet so when my daughter's
come to me and say daddy can I have some
red sweets I can go of course you can
and I go all right I'll go to my
document where's the first-leg red one
oh it's in bag 42 I'll go to bag 42 open
it up pick it out
and then I'll go back to my document
find the location the next one where's
that that's in bag 100 okay I'll go to
bag 100 take that up open it up find the
next go back to the documents find the
next one and so forth so I'm continually
going backwards and forwards backwards
and forwards doing my document and my
sweets here so I've got my two
approaches of trying to find red sweets
I can scoop up a number of bags at a
time sift through all the individual
sweets to see whether or not they're red
or I can in in advance write down the
color and location of every sweet and
when I want red ones or any color for
that matter I can go to my document and
find out exactly where the red ones are
so this is all very well and good I got
a couple of ways of keeping my
daughter's happy but what's all this got
to do with Oracle you know this is
talking about sequel and databases here
well what I've done is I've got the real
world manifestation of my M&amp;amp;Ms table and
each mm is a row from the table so we've
got our mm they've got various
properties so they got color await
expiry date things like that so they a
row and the column
those attributes on the table and my
document is an index on the color column
so we've got the color the value of that
column and the location of each row so
that's what we got our rows and we got
our index and they all the data as a
whole as the table banks themselves also
represent something that's kind of
important in Oracle
does anyone know what this is someone
knows that I'm hearing some whisperings
with putty yes so you get those Jonathan
so yeah so what the bank represents is a
block so just like when I'm we've got
M&amp;amp;Ms I don't just go around they're not
just lying around randomly on the floor
all the M&amp;amp;Ms go in the back I go to the
shop and a by a number of banks it's the
same kind of principle with rows in
Oracle database all the rows go in a
block and when you want to get an
individual row you're not actually just
getting that individual row you're
picking up the whole block and all the
other rows that happen to be on that
block at the same time so I only want
one suite out of here I pick up the
whole bag open it up and get that
individual suite out it's the same kind
of principle when you're fetching a row
from Oracle database you go to the block
pick that up and locate the road within
the block and just like we can get quite
a few sweeps in each bag typically you
can get quite a lot of rows on each
block so the default size of a block in
Oracle's 8k so you think a typical table
with a handful of columns you know a
couple of dates maybe a few numbers and
some relatively short strings you know
can be less than 100 bytes per row you
can fit quite a few rows per block
typically obviously it will vary
depending on how many columns you are
you've got what their data size are and
so on so those are kind of basic the
building blocks we're going to be
working with to the rest of this talk
here and so we'll go to the two
approaches I use to find all the red
sweets so
the first approach is like a full table
scan and just like when I went to my
real world table here picked up a number
of bags and then I open up look through
them to see which ones are red Oracle
does a similar thing when it does a full
table scan can do what's called a multi
block read scooped up a number of blocks
at once look at every single row then it
find every single row see whether or not
it matches your where clause if it does
it returns it up to the next stage of
the query if it doesn't me just discards
it so with a full table scan you're
always picking up every single block and
inspecting every single row to see
whether or not it matches your where
clause with my documents that's kind of
like an index range scan the index holds
the value and location of every single
row so I've got the my document and I'm
finding the location of each row going
to that place picking that one up and
then I'm having to go back to the index
find location of the next row that I'm
interested in so we've got multiple
Ahri's with the full table scan single
block reads with an index range scan so
those are our kind of working things
we're going to work with here so real
question and the thing that you're
probably all coming here hoping out
answer is which approach is going to be
faster so let's imagine I've got a
hundred packets of M&amp;amp;Ms here and I want
to find all the red sweets so which who
which approach is going to be faster who
thinks that it's going to be the full
table scan in this case and who votes
the index range scan who's sitting on
the fence and going to defer decision
right yet so this when I say faster um
I'm not really necessarily talking about
execution time what I'm measuring
particularly is how much work Oracle's
actually doing all the database does and
by work I really mean how many times it
has to pick up each individual bag
because every time you have to get a
block or a class to do some work you
know worst case it's having to go to
disk and pick it up get it into
memory and so on but even best case in
the buffer came when it's in the buff
cache I still have to do some work to
make sure it's getting a consistent read
of the data and making sure you're
getting the data you're supposed to get
so you your query returns the correct
results so we want to look at how much
work how many times we're having to
access blocks so in this example here
we've got six different colors so
roughly one in six of the sweets are
going to be red give or take you know
there'll be a bit distribution depending
on what exactly the shop is sold me full
table scan I'm visiting each bag exactly
once
pick up each bag once that's it and then
I'm done and then it's this example here
what I've said is I've got a little bit
of work I've got to read my index so
I've got a tiny bit of work there and
then I'm having to go back to the blocks
multiple times so we've got about 50
sweets per bag about with six different
colors so slightly less than ten times
so in terms of the amount of work we're
doing here the full table scan is doing
a lot less let's imagine a different
scenario let's imagine that Mars run a
promotion they run one of these things
you you know there's a silver suite in
and at the same time there's some
premium rate phone number you dial they
give you a year's worth of free sweets
or whatever it is you want to find that
free that bag with a silver suite in it
so we've got our hundred bags again one
percent of them are going to be silver
which approach is going to be faster
which approach is going to do less work
this time so who's going to go for full
table scan this time no take one taker
two takers who's going to go for index
range scan in this case yeah so most of
us so if we look at the amount of work
we need to do full table scan we still
need to look we're still looking at
every single bag we're still inspecting
every single row to see whether or not
it's silver because we don't know in
advance where it actually is you know it
could be any of them
with the index range scan we can look at
our document go to the entry that says
silver the one entry or two maybe if
we're lucky and then go and just pick up
and access that one individual bag so
we're just doing you know a couple units
of work so we've gone from a situation
where the index is doing potentially a
lot more work and then the full table
scan to a lot less work so you can see
as the amount of work they might rose
with fetching increases the index does
more work but the full table scan that's
the same amount of work so it's always
accessing every single block looking at
every single row the index is only
accessing rows and blocks which match
your where clause or which match the
values in your index than it might finds
so when you submit a query to the
database this is kind of what the cost
base optimizer is trying to figure out
it's going to one of the key things it's
doing is how much work am I going to do
doing a full table scan versus how much
work am I going to do using an index now
know I use word estimates there a couple
of reasons for that one is that the
infamy how it gets its information is
from the statistics about your tables so
when you last gather the stats see how
many rows there were in the table how
many blocks they use how many different
values were and so on it looks at that
information to decide how much work it's
going to do and you know if that
information is way out of date then
there's a good chance you're going to
end up with the wrong plan and or an
inefficient plan for your query now for
example we've you've gathered stats on
your table and there's only ten rows in
it and you've now pumped a load of data
in there's a million rows Oracle is
going to think that that there's not
much data there for that full table scan
is a lot more efficient than it really
is so you the information is only as
good as those stats and even when their
stats are fully up-to-date there's
various kind of limitations of how it
can analyze the data and understand what
actually going on so there's still some
inference it has to do in some cases
which isn't always doesn't always
produce entirely accurate results so at
this point I'm jump into a quick demo so
what I've got here is I've got my actual
table here with the M&amp;amp;Ms in it so we can
see we've got about 916 o them let's say
I just need to grab this and so come in
over sorry on this any questions so far
here we go all right okay so hopefully
you can all see that so what I'm going
to do is look at the explained plans for
this and we can see that we've got our
rows there so we've got about nine
hundred and sixteen hundred and
seventeen for all the colors except the
silver which we've only got one row off
so if we look at the explained plan for
this where we do a full table scan or
know where clause and why is that not
done when I expected it to that's
because my keyboard all right there we
go so that's a bit small there so let's
just zoom in a bit we can see down here
we've got a full table scan so the
cardinality how many rows does oracle
predict that this query will return so
five and a half thousand rows that is
right you can still check my math like
math later if you want and it's a sign
that across the thirteen so it says it's
going to do that's cost of thirteen now
one thing to note the cost isn't
directly a measure of how much work it's
actually going to do the cost is kind of
a normalized unit you can't go that's
thirteen units of work that Oracle is
going to do executing the full table
scan it's putting some information about
how much how many blocks it thinks it's
going to get looks at other information
or it can look at other information such
as how your CPU and i/o stats and so on
to produce that final figure so that's
kind of an
a normalised figure that isn't exactly
it's going to do 13 units and work
that's kind of a imaginary number
Oh imagine who's not right that's just a
number it uses to assess different
queries and choose one that's lower so
we've got art with our full table scan
and that is doing 13 units sectional
rows doing 13 units of work and where's
money can't see my cursor here so let me
just hang on a sec any questions on this
so far well I try and figure out what my
first 150 sorry what was that time
so yes so well no the index isn't
created for free you're right there is
work to create the index but in general
you're not going to create an index in
advance of every query so you will
create the index to start with and then
as you add delete update your data
Oracle still has to maintain that index
but it's not you know an N log and you
know it's just a little bit of extra
work for H each extra row you add or
remove to the table so as you add more
indexes to the table you're slowing down
your inserts updates deletes now it's
something you need to be aware of you
know if you're adding too many of these
you can just kill your data modification
performance yes your query the nice and
fast but you can't get the data in fact
so you do need to be aware of that but
you know in this kind of example here
it's very rare that you'll go and create
an index just for one query and that's
it and then get rid of it afterwards
you'll typically leave it there because
it is useful on going for your
application okay
so answer your question and I'm still
could anyone see where my cursor is
hiding is it I'd probably want to fly
let me just
oh where is it oh yes it ah there we go
got it at last there we go okay so so we
see your full table scan when we didn't
have a way across so we're fetching
every single row and we do the same
where we're looking to the red rose
one-in-six we can see we get carnality
916 so it's estimated how many rows
we've got correctly cost remains the
same still at 13 actually you probably
can't I got my monitor setup form which
is probably why I am struggling here and
I'm sorry if I just
yeah I'm just trying to I haven't got my
monitor Billiam thing on this screen
here as well which is probably why I'm
struggling bit okay and it's all gone
black and I've broken everything oh
there we go okay let me just start line
up again and let's go back into here
hopefully no we're right done with that
and obviously it's hidden off the bottom
sorry about this folks there we go there
we go alright we're back again at last
okay so we can see it's getting a
carnality right so it's estimating how
many rows but the amount of work it
thinks it's going to do remains the same
if we fetch just on one row I'll silver
row now I notice I have to hint it here
say full scan we do that and it'll come
up in a second and it's still going a
forceful scan with the hint and it still
got turn out is Colonel t1 estimated one
row but it's still giving it cost of 13
so we go down and we look for R we do
for index range scan when we get a
silver umm and we look at our plan and
we see one row cost of two so not much
is expecting to do not much work here
and then we go again with our red one
one in six of the rows we see cost is
going up so it's thinking it's going to
do more work so we saw before I didn't
need to hint the query I had to hint it
to force the index here because the cost
the full scan with lower and then we go
fetch everything again and you can see
searches everything
so that's losing explained plans
explained plans are quite limited
because they are just a prediction they
are what Oracle thinks it might do when
it comes to actually execute the query
there's a lot of reasons
why that could be wrong let's look at
one example here so if this was a real
query you had a real application you'd
have a bind variable volume variables
passing the color so you could choose
different colors for different
situations and if we look at the plan
for this we can see a slightly unusual
hopefully you can see that a commonality
there of 786 so hopefully you can read
that down there
that's not one and it's not nine hundred
and sixteen or seventeen where does that
value coming from anyone so yeah someone
we've got it we've got five hundred
fifty rows there are seven different
values if you take 550 and divide it by
7 you get 786 basically at this point
oracles guess with its explained fine it
doesn't know what that value is so it
kind of goes well it's going to be I'll
take the average and perhaps not too big
a deal on this query single table you
know one predicate against it but you
can imagine these kind of errors can add
up if you have lots of joins lots of
queries lots of bind variables these
little inaccuracies can add up to ending
up give you an explain plan that is
absolutely nothing like the real plan
that Oracle give you when you execute
the query okay so explain plans they
just be kind of a guess really about
what might actually happen how do you
find out what what's going on how do you
know what the Oracles doing well what
you need to do is get the execution plan
the statistics panic what it actually
did when it actually ran the query and
there's various ways you can do it but
what I'm going to do here in sequel
developer going to use tool called auto
trace so this looks a little bit like
explained plan when we run it so I'll
bring it up and I'll pass a value of
silver in to start with and run that and
you can see we've got a lot more columns
here we've got a lot more information
about what's actually going on and we
can now start to use this to really
understand what's happening this is
a little bit like a profile for your
execution plan it's kind of going make
that bit bigger so you can see what's
going on a bit better so you can see
we've got our index range scan we're
fetching one row so it's quite likely we
want to use an index so we've got a
whole bunch of extra columns here so
cardinality a bit like we saw on the
explain plan how many rows oracle
thought it would get the next column see
our buffer get how many consistent reads
did it do this is probably the most
important stat or column to pay
attention to when you're tuning your
sequel query because this is how many so
how many consistent reads how many times
did it have to acquire a block how many
of those did it do and all other things
being equal if you've got two queries or
two plans the one that there's fewer
buffer gets is the better one to choose
because it's doing less work it's not a
cast iron rule you know the things like
sorting which aren't necessarily fully
accounted for but generally speaking
that's what you want to look at also to
kind of relate that you've got this
elapsed time column how long did it
actually take to execute that set of the
plan at Sam in microseconds here thing
to know these numbers are cumulative
here so we got 29 41 and three and four
well that's telling you is it's three
yet for the index lookup and then an
extra one to actually go to the table so
this is the sum of the ones that are
below it same for here so these
aggregate up it's not a total of these
two so we haven't gone done seven in
total we're done four in total so a
couple of things to mention here so
carnality is how many rows oracle thinks
it's going to get if that cardinality is
accurate to that estimate is within an
order of magnitude then generally
speaking
you've got the optimal plan not
necessarily but you've certainly got at
least a reasonable plan how do you know
how many rows are actually returned well
that's where this last output rows
column comes in look at this
we've got one row come melon c1 one
little wrinkle or thing to add to that
what this last starts column on the end
here which tells you how many times it
actually did that step what you need to
do is multiply this by that and see if
it equals that roughly speaking so then
within an order of magnitude then
there's a good chance you've got a good
plan if they're an order of magnitude or
more apart then you may not have an
optimal plan so look at those to kind of
figure out could put Oracle do better
here could the database had chosen
something better okay so we ran that
with silver and it a little bit work
what is going to happen now if I rerun
this for red what point are we going to
get here are we going to stick with the
index range scan or we're going to go
for a full table scan anyone who's going
to go for full table scan and who's
going to go with index range scan okay
couple and lots of people lots of people
sitting on the edge on the fence not
willing to commit here let's let's see
let's see what happens we run it again
and we saw that in theory it should have
chosen a full table scan based on me
next the plans will run this and we
still got the index range scan and you
can see it's now make that a bit bigger
done a lot more work 50 yet and but when
we looked at the explained plan the
prediction it thought it would do a full
table scan so why hasn't it chosen to do
that well the first time you execute the
query
Oracle looks at the values for the vine
variables and the process what's called
bind variable peeking and it chooses a
plan based on those values second time
you can execute that X ticks of that
plan now back in the dark ages this was
potentially a serious problem if you
chose an unusual
peeler or a value which would give a
plan which is remarkably different to
the normal values you'd pass in the
first time you execute that query so the
first time you deployed your application
or the first time you ran that query
again after restarting the database or
it's just run very infrequently and you
kind of step with that plan and you know
Oracle would stick that and kind of go
yeah I'm I'm not going to change to the
best plan even though there's one
available starting in 11g a feature came
in called adaptive cursor sharing so you
had a kiss a histogram on the table and
it can look at these stats and kind of
go okay we've got this plan first one
was good second one actually that wasn't
quite right
we're running if we run this query again
come on up rerun it again for red and
give it a second we'll see it's gone to
the full table scan so it's identified
that in this situation it wasn't
appropriate to go with the index range
scan for the value read so it was able
to kind of adapt and correct itself in
these cases where you've got an unusual
value which would have a bad plan for
the rest of your other values so we've
got our one silver and got question so
if I run silver again Ascot let's have a
look we run silver again now and to do
didn't do and we will find that six with
the index range scan so now it's
actually got both of those plans
available to it okay and they will last
until you know they restart the database
or get aged out or whatever so this
potentially could still be a problem
you've got big data skew big two or more
different values which is going to have
radically different plans and the first
time you run it you get the unpopular
the bad plan for the rest of the values
so I have to get it wrong once before
choose the right planner but it can
correct itself
okay so any questions on that before we
move on notes that one of the plans
actually changed so the when you first
execute the query are a call save that
plan and the cache and that will remain
there and it's kind of like at least
recently used algorithm as long as it's
in the plan it's a long as it's in the
cache it's available to it okay with the
adaptive cursor sharing here we've got
SKU and our data we've got lots of some
values one value which is really unusual
and the rest which are evenly spread so
I've created a histogram or on the table
so Oracle knows that there is that
difference in distribution and it's able
to identify if they will get the stats
from its execution kind of go hang on I
chose the wrong plan here it can also
change a plan if you run DDL so you
create new index that opt opens up new
optimizer paths you can manually flush
planned out the perfect out of the cache
as well if you really want to but in
general they will kind of stay there and
remember that there's a fixed amount
memory here if you've got millions
millions of different queries they're
going to get aged out and they're all
different queries you might find you end
up repassing all the time okay so make
sense
no so when you when you insert the data
when inserting you won't change when you
gather statistics that you can see and
kind of go okay the data distribution
has changed enough now but but just
deleting data inserting data is not
going to change anything any of what's
that sorry yeah without the histogram
it's not able to know that there is that
skew and the data doesn't know that
there's that difference and it goes back
to that first problem I showed with the
explained plan where it just kind of
goes over you know seven different
values I assume it's the average of them
it's 786 okay okay um let's move on
let's move on Pam asked me back so when
I've discussed all this I've actually
made a really massive assumption massive
massive assumption about my data does
anyone know what that is
yeah they won't all be front-end in them
I think you're kind of getting on the
wrong right lines the assumption I've
made is that there is no correlation
between how the rows are stored in my
table here and they'll appear in my bags
this is the order they appear in my
index let's make a different assumption
let's imagine Mars change the bagging
process so that each bag only contains
one color okay and let's go further they
say that the index itself exactly
matches the order they're listed in the
index here exactly matches the way they
are physically stored in the table here
so you can see this is my first bag this
just contains blue sweets and it can be
same as blue sweets 1 through 50 the
next 150 once on how does that change
things
well quite considerably first up if I'm
looking for a specific color such as red
I no longer have to look at every single
bag I don't longer have to look at every
single block to find the red one I just
have to look at the roughly one in sixth
and actually all red
secondly once I've got my first red bag
and I've seen that the Reds gone to my
first red entry I don't really have to
keep picking up and putting down this
same bag multiple times I can just kind
of keep hold of it in my hand kind of
pin it in my hands and as I'm working
backwards and forwards until I've read
them all out so we're doing now
drastically less work when we're using
our index and and at this point a little
confession I kind of misled you a little
bit to start with just to help make a
point indexes are ordered data
structures and the way they impose that
order is first they store the values
from the columns you're indexing and
then there's the row ID the actual
location of the row physically in the
table so it first sorts the data by the
values then it sorts by
row IDs and the row IDs contain the
block number so all the red sweets in
this bag are going to be next to each
other in the index they're not going to
meet I'm not going to be scattered
around as a kind of mislead you a bit
just to make a point at the beginning so
this is a really big deal this can make
a really big difference to how effective
an index actually is for running your
query how fast it is to use that how
efficient it is to use that index when
running your query so oracles measures
this through something called the
clustering factor so this is a numeric
value which ranges from the number of
blocks in the table up to the number of
rows on the table so how does it do that
well it's when it when you gather stats
and it's looking through that index it's
going okay so we've got that first blue
entry which bags in in black one and
we've got counter every time we switch
to a new block it increments the counter
so the second blue sweets also in here
the counter stays at one the third ones
in back to then the encounter goes up so
it keeps increasing this so this
measures this is kind of a measure of
how well the logical order of the index
match is the physical order of the data
so if the data is all kind of nicely
clustered nicely packed so everything
we're looking for is in like the edge of
the table here this is nice and good
we've got ten blocks here clustering
factor of ten good it's going to be
efficient to use this index the on the
other hand they're scattered throughout
the table the rows were interested in
high clustering factor that's going to
be bad so some of you might going well
is it really that bad how much
difference does this actually make so at
this point I didn't jump back into
another demo and here we go so we've got
our table same table again here and we
run it
we've got number of different columns on
it and you do so the peak a sequence of
time primary key into
eight they just values just go up they
are perfectly clustered so I have a nice
low clustering factor here 36
color what that does is because it goes
through all blue and then all the green
see that value of 217 all the blue ones
are going to be one after each other in
the table so it's going to scan through
all the locks on the table wants for the
blue ones and it's going to go through
all the ones on the table for brown then
orange you multiply 36 by 6 you get 216
plus our one silver one you get 217 and
then our my weight basically randomly
generated they're completely scattered
so I only compare using the primary key
which is perfectly clustered and the
weight which is terrible perfectly
uncluttered and we'll see how much work
they do and then I and that comes up so
we can see so we're getting 548 rows
here and it's doing 48 gets to do that
so it's chosen a full table scan to get
548 layers and I have to go a bit quick
because I'm running out of time
unfortunately so we just remember that
so we're going to fetch 550 rows using
the primary key so about the same number
of rows doing that and we will see that
all core chooses to do when it comes up
group it's not going to work now with it
jam on like there we go
index range scan and you can see if I
bring this up so 13 gets so it's done
substantially less work yet it's fetched
two more rows this is the impact that
the clustering the data can have you
know we've got perfectly clustered data
those 550 sequence sign primary key
values are in those first blocks in the
table those weights are scattered
throughout the whole table if we go down
and then force it to use the index with
weight we will see that
when it comes up
we'll see it does some Stanzi more work
doing that when we finally get that
so the clustering factor has a really
big impact on how effective an index
actually is and I think I have to cut
this short because we're running short
of time
any questions on this before I move on
yeah well of course you can fool the
optimizer by fudging the stats in any
way you want but as I said at beginning
so there is a one of the things about
the clustering factor is it's kind of
pessimistic you can get a situation
where rote values are actually kind of
fairly well clustered they're always
going to be near the end so they might
switch around between two or three
blocks at the end but they all kind of
cycle round like this there's going to
look a lot worse than it actually is in
practice there's a new option which came
in in 12c which I can't remember their
name of which is table hash table cache
blocks yes so you can set that and say
okay I expect that within a ten-block
radius so to speak these values going to
keep going so things like insert state
sequence of sign primary keys they're
not necessarily all going to go in the
very end block but they will go in the
end block the set of end blocks no so
there are things you can do to get
around map I'm running short on time
unfortunately any other questions on
that before I have to move on okay so
you let perfectly led me on to the next
thing how can I improve the clustering
factor so having learned about this what
a lot of people says is well how do I
get the data to be physically sorted
more like goodies in the index first
things weren't being where of here
notice in order to improve the
clustering factor you have to physically
move the data okay you can rebuilding
the index
have any impact because that still win
the same logical order you have to
physically reorganize the data by
default when you create a table in
Oracle it's a heap organized table
this means Oracle will insert it
wherever their space usually that will
be at the end you know just like if I
drop a grain of sand on this heat pan
it's probably going to go at the top but
I don't necessarily know you don't know
where Oracle's going to insert a row on
a heap organized table so there are a
number of data structures Oracle offers
which you can use to enforce some kind
of order on the data so look at a few of
those so an index or guys table with an
index organized table normally you have
two data structures your table in your
index that combines them into one so
your table is an index so the table
columns effectively become part of your
index so it's physically sorted in your
the logical order imposed by the index
do note that has to be by primary key so
my one is physically sort things by
color here I couldn't do that because
that's not unique I could do things like
create a fake primary key have color and
then the real primary key but that's
getting embed advanced and I wouldn't
really recommend it except in
specialized circumstances it was
probably better in this situation is I
can partition the data I can split it up
by color and by doing that I've
effectively split the table into sub
smaller sub tables by partitioning color
I know that all the red roads are going
to be located in the red sub table so I
go to that everything I get out of there
is going to be red everything in the
yellow partition is going to be yellow
and so on so that means I'm only looking
at things which actually match my query
clusters kind of a nice advanced
features that's more about joining
multiple tables together so my
daughter's love chocolate but I'm trying
to get them to eat some fruit as well so
when they say I want some red fruit red
sweets I've crossed 'add the fruit with
the sweet so you know there's also some
cherries and raspberries and other red
fruit and things
and maybe they won't notice but it never
works they always notice unless you help
them pay for it anyway an important
thing to remember about this if you
physically cluster or sort your data by
one attribute or set of attributes you
can only you can only do that by one set
of attributes what that means is
improving the clustering factor for one
column or one set of columns almost
certainly makes it worse for the other
type of columns if I physically if we
sort it by color
yes I get nice efficient access by color
but if I'm now the weight is going to be
randomly distributed now this is why
you've got to take some knowledge of
your data your application what your
usage models are to decide what is
appropriate so you know we don't think
about it but chocolate does have an
expiry date it's usually so far away and
we eat it so quickly we never think
about it but chocolate does have an
expiry date and so once a week
I run a query to find out what what's
going to expire in the next week to make
sure we eat it all up
I don't care how long that query runs it
could run for three hours for all I care
because I set it to run on Sunday night
and as long as it email may want to wake
up I don't care I want that color query
by color to be absolutely as fast as it
can possibly be because my daughter is
just going to you know beg me to death
until I give her some red sweets so you
need to decide where the trade-offs in
your application are do you have some
queries where performance is so critical
that you want to you're willing to
sacrifice others potentially and so as
we can see full table scan always looks
at every single row always accesses
every single block so it's the same
amount of work to fetch no matter how
many rows you're fetching index range
scan the amount of work it does
increases as you fetch more rows but the
crossover point entirely depends on that
clustering factor how well that logical
order match is the physical order in the
table so just kind of wrap up quite
often when tuning sequel queries people
think about how many rows their query is
going to return and you know if your
query is going to return one row or two
rows yes you probably want to use an
index it's very rare you don't but if it
returns ten rows if it's
50 rows and returns 100 rows do you want
to use an index or do you want to use a
full tables done I don't know it's more
we I contend that thinking about the
number of rows is probably not so useful
more useful to think about how many
blocks it's going to access using the
full plet now how many blocks are there
in the table for a full table scan and
how many will where access using an
index fortunately there isn't really a
way to know this without running the
queries you can look at things like the
clustering factor your knowledge of the
data what's going on
to make some educated guesses but
ultimately often the end the day you've
actually got to physically run your
queries to see how much work it actually
does so that was very brief introduction
to indexes and sequel performance I'm
Chris Saxon it's great to see so many of
you here thank you for joining me</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>