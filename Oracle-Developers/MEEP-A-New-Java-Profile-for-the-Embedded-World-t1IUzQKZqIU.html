<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>MEEP: A New Java Profile for the Embedded World | Coder Coacher - Coaching Coders</title><meta content="MEEP: A New Java Profile for the Embedded World - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>MEEP: A New Java Profile for the Embedded World</b></h2><h5 class="post__date">2015-06-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/t1IUzQKZqIU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everyone and we'll come to the
rather intimate circle of friends of
embedded java programming the talk today
is about microsoft embedded profile my
name is fuga bohai worked for oracle
excuse me no no no i didn't okay my name
is fuckable I've worked for oracle as in
senior staff engineer and the spec lead
of the jsr 361 the microsoft embedded
profile and in former times still
working for siemens and i have been
inspected of the predecessor Jase RCMP
and IM P and G we come back to this bit
later one year ago I had to talk here
together with Sharon spa one of our Java
evangelists under the working title I MP
nexts then and during Java one last year
we have announced that this jsr has been
started since then a lot of work has
been done and we are today in the face
of the public review and this talk so
the intention of this talk is actually
to tell you where we are now and what
are the results we have come to so this
slide you may have seen several times
during Java one already okay first small
look into the history and the history of
embedded java programming started with
IM p1 dot o already ten years ago now
and as idea at this time was actually
you know mid p MIT p was the
profile for the telephone java
programming and mid p had some features
without any optionality which we're not
appropriately appropriate for embedded
programming and the idea of I Mpondo was
actually to take in subset or on
so-called headless mid p which means
which meant actual is that I am p1 not
all was nothing else and mid p with
algae graphics library it was also ltd
you I because at this time the target of
a better programming they are mostly
wireless modules and those wireless
modules didn't have a display or
something so it made no sense to
implement the graphics libraries there
and it was not allowed just to cut it
from submit p two years later we came to
IM P&amp;amp;G this was actually the same target
it was now based on MIT p20 not MIT be
two dot one anymore and some additional
requirements for improvements mainly in
the security area have been done there
and since then and this is actually
eight years old nothing had happened to
the embedded java programming and now it
was time to take something new
especially because the embedded world
has much increased a lot of new kinds of
devices have come to life not only just
simple wireless modules that we had in
the past but also more sophisticated
once with a display with sound
capabilities with sandra data processing
and so on and the IM P&amp;amp;G was for sure
not may not enough anymore for all those
devices and the new jsr the mep is in a
way also the successor of meat
p because you may be a wizard in the new
Java 8 there's not no mid p anymore and
we will see that you choose the option
ality features of the mep it is also
possible to use mep to make an MIT p
like configuration let's have a little
look into the embedded rod back in the
80s we had actually a network of
computers then later and the 90s we went
to endure to an Internet of computers
and the number of the items within this
network has increased much and now we
are about where we are like to speak
about an Internet of sinks so not
necessarily people are sitting behind a
computer but we have devices speaking to
each other without a human interaction
and this is of course the world of
embedded devices and better devices are
everywhere in our worlds they are in
pipes they are in vending machines here
on cars and so on and all those embedded
devices which from the nature of the
singing actuality are in a very
heterogeneous environment have to talk
to each other and Java which has been
created actually to bezel language of an
heterogeneous world is the ideal means
to do that this is just a picture
showing the broad variety of embedded
devices we have around us we have phones
we have Kindles we have printer we have
vending machines and all this kind of
stuff all these have very different
architecture from the hardware point of
view very different processors very
different operating systems and so on
and they are talking to each other with
a priority of protocols and these are
actually also the challenges for the
small embedded market as mentioned
before those devices are usually
communicate to each other without any
human interaction which means they have
to be very robust they are intended to
have to work in a long life the mode
operation so that if you have for
example an embedded device which is in
the pipeline under the sea it is natural
that it is difficult to go there and do
some maintenance so they have to work
for a long time without any direct
interaction they have to be highly
integrated they have to be easy have to
make a edit value' in the market you
have to be intelligent and because there
are there are so many of them see I
usually have to be cheap I have a low
footprint and limited capabilities and
they have to be power aware because they
often use batteries that cannot be
changed for a long time and see
dependence of hardware and software
should be separated not depend too much
from each other as a consequence from
all this we come to optionality and
optionality is actually the basic
characteristics of the embedded profile
because we have such a broad variety of
devices you can see very sophisticated
devices in the upper part of the slide
something like a medical monitor where
you have graphics
many sophisticated capabilities complex
applications running on these and use a
lot of several API is in order to
control sensor data and so on and have
to be updated on a regular basis basis
and on the other hand on the other side
on the lower part of the slide you have
seen low ends in mass devices they do
not intend to have any human interaction
as they have very limited resources
because you have ten thousand hundred
thousands of them in big technical
systems as they have no need for
advanced features though usually as they
don't need any update or so they often
run just one application which is
installed on the device during
manufacture ins and manufactures and the
device is sealed and never change during
its lifetime so you can see these are
very different requirements we have
forces several kinds of embedded devices
and this is a challenge for the embedded
profile and the answer to this challenge
is actually optionality as a consequence
yes actually everything is optional in
this profile so what we have as a
central part as we headed in mid p and
also an IM p is the application model so
that means we have the midlet package so
by the way how many of you are embedded
programmers okay the majority so you are
familiar with the midlet application
model so this midlet application model
is also available here in the in the
embedded profile and this application
model is the only thing which is
mandatory of course we have to have to
have something which must be there and
then we have a lot of packages
offering a lot of different features and
all these packages are optional means
you can configure your mep
implementation according to the needs of
the devices you do the implementation
for so what's all optional in this
profile we have cellular network
management we come back to this this is
about the management of cellular
networks we have an event management as
you may know it from it peace Ridotto we
have an io package which includes push
and in the middle at communication as it
is also known from mid p 30 by the way
is a profile is not backward compatible
to mid p300 it cannot because some of
the features from it p 3 dot 0 which are
not so frequently used are not available
at mep but many of the concepts of mid
p300 have been integrated into this
profile we have a user interface this is
something we haven't had in the former
embedded profile I told you the first
inp was actually in headless mid p and
there was a long discussion and in the
expert group about how to do the user
interface and we came to the following
conclusion what's integrated in scope of
the jsr is a very simple user interface
just for line oriented displace because
many embedded devices have a line
oriented displays for example in the
vending machine or something where you
just have some text output but we have
seen in the other slide about the
several kinds of embedded devices that
are also very sophisticated devices
within high integrated graphical display
and for this a line oriented user
interface
wouldn't be the right thing so there's a
possibility to integrate any other user
interface into an implementation so this
is allowed from the specifications point
of view and this is possible by doing
this you can do backward compatibility
for example also to meet p because one
of the graphics libraries you can
integrate is of course LCD UI and if you
if you do this then you have an mep
configuration which is backward
compatible to mid p 2 dot 0 applications
you can run MIT let's written form it p
to rot oh why haven't we put the LCD
your eye as a part of the MEP the answer
is actually a DUI is a bit outdated and
just not the right thing for many of
modern and better devices for example
you have no touchscreen support and so
on so this solution we have found here
opens the possibility to integrate any
other graphics library instead of LCD UI
for example you can put their JavaFX or
something depending on the necessities
of your embedded device you are working
for then we have a key event management
you may be astonished at the ski event
management is in an extra ballot here
and see this is intentional because the
key event management in the embedded
profile is independent of the graphics
support the reason is that many embedded
devices have keys but no not this place
you may have the button field or
something or just a single button or so
so there's a possibility to support keys
but not a display and also the other way
around you may have also displays
without any keys then we have the major
support this is also known from IM P&amp;amp;G
already
it is the old audio sub package of the
jsr 135 it is not really up to date we
are very very upset but one of the
requirements has been the backward
compatibility to IM P&amp;amp;G and in i am P&amp;amp;G
many applications have been programmed
to do some very simple tone generation
and those applications should run also
via mep but it has been discussing the
expert group that in a later version of
mep we will probably replace it by a
more sophisticated media package so it
is expected that in mep too if it comes
once as this media package with the OGS
are 135 sub package will at least be
deprecated new in this profile is power
management since we have they have seen
that one of the requirements for many
embedded devices is that they have to be
energy-aware the power management go in
a standby mode or in a sleep mode or
something asking about the battery level
and so on was one of the central
requirements for this profile we have
the record management's rms as you know
it from the mid p and IM p.j.s as we had
before and we have a software management
i come back to this on another slide so
the new features in a spotlight this is
an optional graphic user interface
report as mentioned before this is a
line oriented display and the pictures
integrated into the slide show you that
even if you speak about lion oriented
this place there are a lot of possible
kinds of line oriented displays they may
have
single or multi line displays they may
have a backlight or not as it may be
monochrome or have several colors and
the the interface which has been
integrated into MEP supports all this so
you can configure which features your
displays display in your embedded device
supports and controls these features
appropriately as mentioned before MEP
allows also to integrate a bitmap
oriented graphic the user interface
instead if needed with which could be
else DUI or something more up to date
with a touchscreen support or something
else but it is out of scope of the
specifications the specification just
allows that it is possible to integrate
such an another graphics in their face
the end we have the optional key support
you see some examples of keys in
embedded devices which should be
supported by the profile here the whole
thing is independent of the existence
often display and we have the
possibility to configure keys including
some modifiers like shift or alt or
something sends upon a power management
the power management is aligned with the
event management API as it is known from
mid p 3 dot 0 means we have defined row
of power events battery low stand by
switching on and so on we have some
system power states that can be checked
we have notifications using the event a
management system about power state
changes and you have access information
on for examples of current
level or an estimate of the remaining
battery life where the external power
source is in use as a diss plucked in so
this is very important for example if so
the maining battery life is very low you
can write your applications in a way
that in this case that says danger that
the battery will be down in shortly then
you can save some data or something then
we have the optional cellular management
this is a class representing a 3gpp or
cdma network and everything which is
needed in order to make a management of
such a network so you have subscriber
subscriber identities like phone numbers
or are IM as I you have operator
identity identifiers which could be an
operator name or an MC or MNC or
whatever and you have a permission based
protection of sensitive information so
in case such an embedded device would
use some cellular network in order to
communicate something for example make
an emergency call if you have a break in
a pipeline or something as n this is
needed in order to do so this is the
software management API I have already
mentioned before of course you have an
application management as an integral
part of C of Z profile so you have C
application lifecycle this is a
mandatory part but this package as a
software management package is an
optional package which offers some
extended application management features
for example setting management's you can
managed some settings for your
applications here there are system
settings valid for the whole system on
your embedded device or settings which
can be configured power sweet per
application suite you have task
management features here and you have
sweet management features here which
includes the installation or the removal
of the update of sweet and all this kind
of stuff but controlled by an
application what has been also
integrated into the system is a service
embedded service platform as it is also
known from the standard edition Java
which means we can extend see lifetime
and the flexibility in the value of your
solution by create cross-platform
modular software applications that
enables you to perform in fields of
upgrades and maintaining the system
integrity and also reduce the device
certification testing overhead this is
very important for embedded devices who
have to work or live somewhere in the
field and work mainly autonomously in
practical this means we have also a lip
let support as it is known from the mid
p3 as such a service is bound to a lip
let and can be activated from an
application by using this lip let in an
application run another interesting
feature we have introduced here is the
configurable provisioning and security
if you look back to mid p or IM p UF
actually one authentication provider
it is not been mentioned under this name
in mid peep but happy but it is actually
you have the possibility or not only
possibility to you have to put and
certificate on an application in order
if you note the application to get sure
that it comes from the right sauce and
so on and we found out that there is a
big fish in the scenery to have a more
flexible model in place here so means we
introduced the term of an authentication
provider and also indication of
applications that we headed until now
and mid p or IM p is of course still
available it is a default implementation
of this authentication provider but the
profile opens the possibility to create
and implement other authentication
providers which are for example not
certificate Kate based one of the
possibilities would be that your device
is connected with trusted shava and you
have a trusted connection and then
everything can be transferred by as ass
trusted connection without an additional
check
so as you mentioned trust so there is a
java Sabha that's already final four
crosses are free to wall and there will
be a lot later today by the identity
management cheese artists also let the
horrible are you trying to seduce where
some of those yes you may you may have
attended CZ keynote on sunday we are
nandini spoke about the congruence
between micro edition and standard
edition and of course we are working on
this and trying to how to say to bring
standard the mic rotation closer
together and for z for the next version
of the mep it is very likely that many
of the security features as you note
from SE will come into this emmy space
so it is possible that after some more
java generations there will be no Emmy
and SE anymore right so if we work on
this direction it is clear that employ
sure yeah and you know that is that the
reason for the micro edition in the
passes has actually been the very
limited very restricted capabilities of
embedded devices and phones in the
beginning of the micro edition and
nowadays though devices are much more
powerful they have much faster
processors you have much more memory and
so on and many of the reasons for these
differences between micro edition and
standard edition are not available
anymore and this is also good for you as
a developer because in the format time
CZ skills to write an embedded
applications have been very different
from those to write and standard
desktop java application and these
differences will be fewer and fewer ends
in the future another part where we
introduced some configurability is a
so-called security policy provider you
know that in the IM p and in the mid p
profiles as we had so far there was one
static model of security policy you had
some those security policy files where
you defined grants for several actions
for certain application of for an
application from a certain provider and
also this has been generalized so the
security policy as you know it from IM
P&amp;amp;G is still there it is a default
implementation of the security policy
provider but you have the policy you
have c possibility to implement another
security policy provider so define the
grants in another way one possibility
what would be for examples that you say
for my implementations i do not need
such as all because i'm as a master of
my devices i write my own applications
these devices are not connected to any
rare and they are very limited in their
space and in their memory and so on and
i don't need all this then you can
decide my security policy provider says
any application is allowed to do
everything because nobody else puts in
applications as though there's no need
to make a special check but of course
this is a special case right and we have
seen that's how many different embedded
devices available and if this is the
case in your case and you can do it this
way if you say no I download
applications from somewhere else I have
to be security aware i have to do the
checks i have to do the policy
as the security policy ever I'm used to
it from IM PNG then you can use it the
same way as it as you are used to it and
the cert the cert a way of
configurability is the first ballot on
this slide is a provisioning method the
provisioning method you know an IM pe1
not oh and also mid p1 not oh this has
been actually just a recommended
practice in mid p 2 dot o and IM P&amp;amp;G
this has been and definitely defined
procedure and now we have this defined
procedure as we note from IM P&amp;amp;G and mid
pay 20 and as the default variant of the
provisioning but it is also possible to
provide other provisioning methods which
includes also of course the possibility
of no provisioning at all I mentioned in
the beginning that there may be very
simple devices which are sealed during
manufacturing with one application on it
and then come into a pipeline under the
sea and you never see them again until
they are out of order then you do not
need any provisioning and it is not
necessary to do an implementation of a
provisioning mechanism which would use a
lot of memory if you don't use it at all
but of course you may have other devices
where you need the provisioning
algorithm as you are used to it from IM
P&amp;amp;G and mid p and q may also have other
devices where you want to define other
provisioning mechanisms for example as
that in the
technician comes there with a laptop and
puts and the provisioning is actually
done by playing an application from a
laptop via a wired connection to the
device or something else all these
possibilities are open for mep and this
is of course because we we want this mep
to run on as many embedded devices as
possible okay so what what else we have
a new features we have system and
application events I mentioned that we
have the event model as you know it from
mid piece Rio we have concurrency so
there is a possibility to run several
applications at the same time you have
seen BF also the intermediate
communication as it is introduced in mid
p300 as well but only if you need it all
these parts are of course optional means
if you say my a embedded devices are
very simple they run just one
application and I have no need to run
several applications at the same time
then of course you don't have to
implement concurrency and also not
intermediate communication mmm then we
have shared libraries lip lets ever it
is also known from mid piece we dot o if
you use signed applications as an
authentication mechanism you have the
possibility of multiple application
signers and you have a model of
permission which is already actually
java SE likes those we have in this
place you have already something which
has been taking over from java SE and
you have notifications as it is
supported by the event model
so where we are with mep now as
mentioned before this GSR 361 has been
fired yo go during javaone you have the
link here in the usual gcp side and if
you have a look there you will see that
the public review period-- is running
and ends with a java one on thursday and
the public review ballot will be from
october first october fourteenth which
means the release is expected to be
available early next year following the
normal gcp process means we yes sure
sure thank you I should mention that in
parallel we have of course a new co DC
version so session for this has been
yesterday health / z / suspect leads and
we were close together of course because
the co dc-8 is Z configuration disease
which is expected by the MEP profile to
be the underlying configuration and no
other one so as a reason why we need Co
dc-8 and no formal version of CDC is you
may have missed some ap is within the
MEP for example GCF has not been
mentioned here so as a reason is that
the who GSF has been moved into the CL
DC so any connector open calls are still
available of course and even more than
before but who GCF part has been moved
into the co DC actual is the right place
for it because it is more basic
functionality having to be a part of the
underlying configuration and MEP expects
this to be available
this is by the way also an optional part
within CDC so if you don't need any GCF
and then you can configure cldc in a way
that it is not part of it and then of
course you cannot use it within the mep
means if you create a stack form certain
embedded device you have to carefully
configure the CDC and the MEP but the
MEP contains also a big chapter about
optionality and dependency because we
don't want to let you as a developer
alone or you as an implementer alone
with these decisions what should i phone
from all these kinds of optionality what
should i implement and what not as
though they are recommendations our
recommended recommended configurations
for example what I have to choose if I
want to have a minimal configuration for
very simple embedded device what I have
to choose if I need a backward compat
compatibility to IM P&amp;amp;G and what can i
choose or what I have to choose if I
want to have a very sophisticated
embedded device and need everything
that's possible and memory is not my
first concern so then you can really put
features in it and this chapter also
defines the dependencies between the
several packages because you can imagine
that it is not always possible to decide
for or against the package completely
independent on another decision zone
some of the packages may have
dependencies on each other and as this
is described in the in the chapter as
well okay that's actually it questions
please
yeah okay this is the footprint of the
implementation depends very strongly of
course of the choosen optional packages
right so if you choose a very minimal
configuration of this profile where you
have actually just the life cycle of the
application and say all those api's I do
not need I just have an application
computing something and sending in a
result somewhere else then you have a
very very small footprint also ZZ see
the underlying co DC you can configure
in a minimal way where you for example
decide not to choose GCF as a part of it
and then you can have a footprint which
is lower than one megabyte if you choose
to have a very sophisticated device with
a graphical API which is not even part
of the MEP as an it depends of course
what all you put together and then it
could have an need for several megabytes
of memory so this is maybe not as
satisfying answer that is this is the
nature of the very strong optionality we
have in this in this profile and it is
logical consequence on the need to solve
very different devices with very
different available memory in space
any other questions
hey
so first of all of course the release
comes together was a reference
implementation of course and i expect
actually implementations to be available
very soon because we have configure ray
you have seen by over configuration
which is backward compatible to IM P&amp;amp;G
so in a way having an IM P&amp;amp;G
implementation you have already one
possible maple implementation availables
all cimp and g implementations are
available in the world with a few
changes of system properties or so can
be made into an mep implementation the
question is you have seen you have such
a lot of option ality here and so
depending on the fantasy of the
implementers and the variety of the
possible embedded devices we will see
which implementations come up and which
features they will include of course you
have seen several packages are brand new
they have never been in any other
profile before it will take some time
people to make implementations of this
but I do not expect it to be too long so
I expect during the next year we will
have several maap implementations
available Zosia
I to be frank I would have to check i I
don't know it's a moment I i can i can
give you my email address and we can
check this i have to check with our RI
implementers i'm not sure
any other questions yes if not and thank
you very much and yes you next time
maybe with a new version of MEP or with
some first reports about experiences
visit I would be happy to hear some body
of you talking about your experiences as
MEP next time thank you bye bye</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>