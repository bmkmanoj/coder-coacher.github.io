<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Optimizing JavaFX Applications | Coder Coacher - Coaching Coders</title><meta content="Optimizing JavaFX Applications - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Optimizing JavaFX Applications</b></h2><h5 class="post__date">2015-06-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/dw8se4uA1qc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome everybody my name is oleg
massainov I represent the Java client or
Java FX performance team and the name of
the talk optimizing Java effects
applications is a traditional one for
our team that we present practically
every year this year though I suggested
talk about some internal mechanisms
rather than best practices pitfalls
tweaks that are mostly covered in our
peers previous presentations or other
presentations that are part of our job
and this year with probably some focus
on particular areas like embedded maybe
controls etcetera so here I expected to
see the program agenda
once more no no such luck okay finally
so I'll start with high-level
presentation of JavaFX threading
architecture and this is a pretty common
topic as I figure it out during other
presentations from the JavaFX team then
I will cover high-level implementation
details of various scenarios hardware
accelerated graphics pipeline soft
pipeline swing interoperability we are
web node and how those map into these
threading architecture lots of diagrams
then I will tell I will describe what
JavaFX runtime performance data is
available it's not much it's something
that we as a team use internally a lot
this is something that you might be
interested in if your task is creating a
benchmark for JavaFX application for
example and finally i'll cover some ways
to outer JavaFX runtime behavior so that
more performance related data could be
obtained and while using the ways the
methods that I will have described by
that time okay
to make sure so the JavaFX threading
architecture basically can be captured
by considering two most important
threads in JavaFX and those are the
JavaFX application thread also known as
event thread also known as effects
thread you see different names for the
same entity in different documents in
different discussions it's also usually
the native event thread when you
consider JavaFX application as a native
application usually are not always
mostly on Windows Mac OS I believe that
embedded Linux could be considered
different case there okay JavaFX
application is responsible for
processing input events pulse and I'll
describe it in much more detail later
and any user code that the user wants to
run on the JavaFX thread and basically
any user code that modifies the scene
graph the basic representation data
structure or for all your graphical
elements during the thread is
responsible for actually translating all
scene graph changes to actual render
comments using various graphics
pipelines and finally either presenting
it to the screen or making it available
to other parts of the application
somehow and we'll cover that again later
so I mentioned the power so that's an
internal mechanism of JavaFX runtime
that is basically implemented around
animation timer I would say but the idea
here is that we run we execute pulse
based on a 16 millisecond timer which
runs in the separate thread not very
important because that's the only thing
that it implements and in worst case say
that each 16 milliseconds we want to
combine all the changes that have
happened to the scene graph up to that
point and process them in one batch and
those changes may be coming from input
events if you have an input event
handler and you modify your your notes
part of the scene graph explicitly or
you have maybe some CSS definitions that
allow you to just specify what kind of
behavior you want to get from you know
in response to some input events like
hover for example all those changes from
input event handlers all the changes
that come from that invoke later
mechanism that allows you to make
changes to the scene graph
well basically originated on maybe a
different separate threads okay basic
mechanism of Java effects all from
animation handlers you may specify an
animation in your program and in that
animation also you will be modifying the
states of the nodes of your scene graph
so all those changes are combined and
processed in the batch within pause so
basically the 16 millisecond is a
parameter that only meets the frame rate
that we can run the pulse at basically
if you come on if you computed back then
you get 62.5 frames per second we are
aiming at 60 frames and usually that's
what the underlying heart allows us to
to get but on the other hand the timer
itself is usually limited by the ability
to specify the delay using the operating
system mechanisms and there is some
contradiction between those 16
milliseconds that we run our timer at
and the actual frame rate that the Cardo
allows us to run say 60 fps the
difference is like 68
Pearson sixty two and a half years
sometimes that difference creates
interference between those two
frequencies and it may even become
user-visible so we have some cases when
that could lead to dropped frames not
because we didn't have enough resources
to run them just because the
synchronization was not quite right
between those two mechanisms and some
house maybe
just an empty house without producing
any frame okay during my presentation I
will be referring to very exact names
that you can look up in our source base
in OpenGL effects mostly is open source
now and even if some of those names
don't make much sense in case somebody
wants to come back to this presentation
it will be those things will serve as
anchors into the actual source code so
this is why quantum toolkit post policy
is mentioned here by just its name
basically that's piece of code that runs
on the timer thread and that piece of
Court decides whether a new path
needs to be scheduled or not and the
condition for that is as following is
any animation is running we won't run
pause we expect scene graph changes from
animation so we run pause we process
those changes and that's it if there are
any dirty scenes
well usually our simple applications
have one scene complex applications may
have multiple scenes I will be mostly
talking in the context of one scene but
you need to understand that the actual
picture may be more complicated
what's a dirty scene basically if you
run any input event handler and modified
any node in the scene graph that node
becomes dirty and the scene that that
node belongs to or represent the
syndrome that you are working with
becomes dirty so basically that
condition means that something happened
to the scene graph in between two pulses
the previous one and the current
that we are considering for schedule or
pulse has been explicitly requested well
again I'm basically translating a piece
of code here that exists in the actual
JavaFX code and that usually happens as
an internal mechanism some part of
JavaFX might say okay I certainly won't
the pulse to be running next time the
time of hires I'm not sure its user
visible but as I said I'm just
translating ab-soul code here so and
another condition is that the previous
pulse is not running that one well see
we are on the timer thread and the
actual action happens on the effects
thread and if we are not done with the
previous pulse we are not going to scare
you another one I consider it as a
possibility for some performance
improvements but we were limited by some
part from long
I do think resists brisker windows where
we could not take advantage of it well
too detailed to technical detail but at
a higher level that's just it the
previous pulse is so running and we'll
consider the diagram on the next slide
that will that should make more sense
okay there are some internal flags for
debugging pulse and I'm putting them on
the slide I'm not going to discuss them
they are really debugging if something
really if somebody is really interested
in what's happening to the pass why say
the pulse rate is not as expected etc
that would be some way to get some
information about it without looking
into the source code itself and but they
were introduced by the actual developer
of that part and probably make the most
sense to that developer only well I use
them still okay so this is the diagram
that
shows the anatomy of pulse as I started
describing so the action starts at the
time of thread on the left upper part
and this is as simple as deciding
whether the new policy needs to be
scheduled and if yes according to the
condition that I described then a new
task is pushed to the event queue of the
effects thread same event cubed that
exists for input event same event queue
that exists for other invoke later user
tasks etc ok if nothing interferes
effect starts processing the pulse
immediately and the phases that it goes
through are depicted here using again
their real names in the source code so
first phase is we are running all
animations that they are defined
currently at the moment so based we will
invoke all the animation handlers they
will do some changes to the signals to
the scene graph ok we'll have some dirty
notes that we will be processing later
the next phase the next actually five
phases are related to a particular scene
if you have multiple scenes you will
have duplicate examples of those phases
again I'm simplifying the picture
showing just what happens with one scene
so the first pass the first phase is do
CSS pass and which does exactly that
it processes all CSS that needs to be
computed to recompute that apply to
applied the next phase is do layout pass
this is where you well not you JavaFX
runtime where Java affects one time does
all layout work update bounds works
again on the entire graph and according
to the all the changes that have
happened it update bounds that will be
used for event delivery
rendering process later and then I use
the different color to represent that
this is not something that we really do
we wait for rendering to complete and it
will make more sense on the next slide
basically the previous frame may not be
complete yet and we need to go to the
next phase which is synchronized sim
nodes synchronized scene nodes we have a
sing-off on the effect side and when you
have it spear on the render graph
basically same graph only with the
different information that is needed to
actually render those nodes and this is
where we transfer information about all
13 nodes from those in the scene graph
to the art of those of the peer we can't
do that if the render thread is
processing those notes so
synchronization here is quite simple we
wait until it's wrong with the previous
frame but that may take time and thus
the color finally when the previous
frame is rendered we do exactly what I
just said synchronizing nodes and after
that we submit around the job for the
render thread since it's done with the
previous frame in most cases it's almost
immediate it almost immediately picks up
that ran the job and starts executing
but in fact this is a usual queuing
mechanism so you submit a task on the
one end you pick up the tasks on the
other end in my experience I've had some
cases when what you expect from this
simple picture didn't match what
actually happened but again probably I
shouldn't complicated the render thread
is represented only by two phases
basically we paint everything we
actually execute we actually issue they
are the drawing commands on the render
thread according to all the changes that
occurred to now the peers of the scene
graph nodes and
finally we are presenting the result in
fact presenting is either making sure
that the prepared frame appears on the
display or making the prepared frame
available to other parts of the
application somehow that phase is
implemented quite differently in
different scenarios and we'll cover
those but I'm so calling it presenting
ok multi-threading and concurrency one
significant change occurred between the
previous JavaFX to the two release and
the current release that we are working
to working on Java effects ADA role and
basically we were able to get more
parallelism from that scheme we were
already multi-threaded into the two but
we were not concurrent because those
thread would never run in parallel why
because of some synchronization issues
because the random graph would sometimes
need information from the actual node
that was not a well about
synchronization point well whatever the
reason was it was not empty safe okay so
basically the way multi-threading was
implemented into the two was that
effects thread will not would not start
a new pulse until the current trend the
job is finished and I'll show it in a
diagram next time
so in Java effects say that all we might
say we fix that and the effects and
render threads can now run concurrently
and the basic principles of that is that
on the render side once around the job
is started it will be completed with no
interaction with the effects threat
anymore what's not the case into the
tool and the effects thread can start a
new pulse and proceed with animation CSS
all those phases concurrently with the
render job if there is any other end of
thread depends on how much time it pro
takes so all that time dynamics is
important
here and effects threat will not start
synchronizing single notes until the
last when the job is finished so now I
have two diagrams in the same terms that
I previously used so say the timer
originates initiates pulse and then we
have all the work until we submit an
actual run the job to the render thread
and then during the thread we'll start
working but the effects thread will wait
until that and the job is finished
and will not do any other useful work it
will not start pause more importantly it
will not process input events so if well
that blue rectangle represents a
possible input event that will be
processed only after the FX thread is
done with the current thread and the
yellow part of the render thread is
still say presenting so sometimes it
takes more time than we would like to
but that's the case so basically
multi-threaded skin but not parallel if
you use some external tools that measure
CPU load you will never see for job with
Java effects to the two you will never
see that CPU load goes above one CPU and
well that was not considered of course
in good fun so what we changed in eight
near the current release is we
introduced the ability at least for
these two threads run in parallel so now
the only synchronization point between
two threads is when we need to
synchronize nodes that phase depends on
how many nodes you have in your scene
graph if you have to feel it's very fast
if you have hundred thousands it may
take time notice about time but again
here the important fact is that now a
big chunk of our effects thread
functionality phrases may run in
parallel with the render thread and
input events also can be processed in
parallel with the render thread so the
render thread now can really add to
parallelism of your JavaFX application
okay something's wrong with this slide
I'm not sure watch okay so now I will
talk about high level implementation
details of various scenarios and how
they map into that threading
architecture again using those same
diagrams the very straightforward one is
implemented on Windows with hardware
accelerated graphics pipeline d3d so
basically just what I have already
described we use one on the render
thread when it's after the render thread
to processor and the job we paint
everything we have to and finally we use
best Java term for basically d3d present
which again may cause some delays due to
missing but as straightforward as that
I might say that the same diagram could
be drawn for embedded Linux so again
nothing peculiar about this scheme on
Linux okay software graphics pipeline in
case no hardware acceleration is
available in a platform we fall back to
the software pipeline implementation is
basically in open prices I'm not
competent enough to talk much about it
but basically all the drawing occurs on
the CPU there is no GPU there is no
video memory there are no text just
nothing so we just create all the pixels
that we want to show in the width in the
window on CPU as part of that processing
phase finally we want to present the
result
to the native windows so that it appears
on the display and the way it's
currently implemented is such that we
basically copy the entire buffer that
contains pixels and make it waiting for
the effects thread to run a specific job
that was put into its queue event queue
by the render thread saying here are the
pixels please draw those pixels in the
in the native window that you have the
problem here is that the affects thread
at the time when we have the pixels
ready may be busy with other stuff
it may be processing next pause it may
be processing input events so you cannot
oh this is why I drew this arrow at an
angle because it's not vertical it's not
immediate not necessarily immediate it
could be but not necessarily and another
problem here is that we currently don't
have a good way to account for those
delays so I'll be talking about some
mechanisms to account for some delays
some runtime information available from
effects not for that part unfortunately
something we need to fix but this is
something that may be ok
applications developers should be aware
of certainly all the effects developers
should be aware of
ok hardware accelerated graphics
pipeline on map now first on Mac the
effects thread is the same native event
thread native GUI thread well whatever
the actual call is I didn't mention that
we have a way to specify a particular
pipeline you want to run with of course
that pipeline should be available in a
particular platform so I mentioned the
software pipeline and the code name for
it is SW ok let me get back to the so
you can see the actual options that you
can provide in the top
left corner JavaFX tries to define the
best way to run your application on a
platform if there is no graphic
acceleration that will run in the
software pipeline sometimes it will
switch it will fall back to the social
pipeline even if you do have a GPU if
you do have hard acceleration but
effects it doesn't deem it to be
reliable for whatever it wants so we had
some issues with Intel integrated
graphics when some drivers were not good
for us to do the actual rendering using
them and they were blacklisted and
people who would use those drivers
default drivers usually only Intel of
laptops mind was part of that would fall
back to the software pipeline I believe
that now you are getting at least a
warning message from the JavaFX runtime
saying that that's what what happens and
then you know that you are not running
at full speed on your hardware okay so
the codename for the hardware
accelerated graphics pipeline on Mac is
ES 2 again if for whatever reason
although unlike I haven't seen such a
case that hard the pipeline is not
available for you then it will fall fall
back to social pipeline ok on Mac JavaFX
runtime is implemented I might say on
top o as core animation OpenGL layer we
use OpenGL for actual rendering as
actual rendering comments and the
context of the native window for that
basically the OpenGL context is provided
by that layer that creates some
peculiarities for the mac OS model and
we'll see the diagram on the next slide
so the render thread when we actually
issue the act well when we issue the
apps or OpenGL commands or
in its own OpenGL context it creates a
texture that contains all the beats that
we need to get to the screen and then
but unlike the previous case where we
also would create all the beat song only
not with the opengl but with the
software rendering at this time all the
beats are already on the GPU we render
to a target we render to a target
rendering texture or rendering target
text I believe that's the name that we
use internally but if we want to start a
new path we'll be working with the same
texture so we don't want those needs to
be lost we copy them into another
texture into another buffer you might
say and make that buffer available for
the effects thread to eventually render
it when time comes up okay so let me
discuss it on the actual diagram it's
very similar to the one that I showed
for the Soto pipeline only the
difference now is that all those pinkish
rectangles represent native code so you
don't see that activity in Java code so
the effects thread the render thread
while most implemented in Java of course
with a lot of native code involved in
the render thread but that phase is when
we say okay the frame is ready we that's
an actual current from from the source
we copy we bleed the prepared bits to
another texture and notify the core
animation layer that we have a frame
ready to be rendered now it's up to that
layer to make an actual call on the
effects thread and of course it doesn't
know that this is the first thread it's
a native gooey thread native event
thread and it makes that called raw in c
GL context it provides that context in
which we are supposed to make the final
draw and again with as with the previous
example that may not necessarily happen
immediately because when we need to
notify the layer that we have a ready
frame
or it might be busy with our thread our
fax thread may be busy with the
processing next frame processing input
events whatever else and such
thus a delay may occur between the
moment we decide that we are done with
the frame and the moment the frame is
actually passed to the native layer to
be eventually displayed on the on the
screen okay next scenario is swing
interoperability which is discussed a
lot during this year while much more
interesting swing the interoperability
to finally moving from a legacy swing
code to Java effects this or that way
and I'm representing I'm showing the
internals of the internal mechanics of
the mechanism that we already had in the
previous releases basically jfx panel
because this release we are going to
have yet another mechanism of
implementing interoperability which is
called swing nodes when instead of
embedding Java effects into a swing
application you can embed a swing
application to Java effects that's a
separate separate scenario and not
covered here so that's the one that is
already available in Java if X 2 dot X
ok
the initial phase is the same we process
pass on the effects thread we submit to
render job to the render thread but what
happens at the end of it when the frame
is ready we read I also picked pixels
from the GPU and I'm considering a hard
accelerated pipeline here so we read the
entire frame if you are running in full
screen we're reading the entire screen
worth of beads of pixels and pass them
down to the AWT that works in parallel
with Java FX threads so basically we
notified the AWT component that we want
to repaint and the corresponding
component will read those pixels
from our buffer that we just read from
the GPU and finally using graphics
drawimage will make it available on the
screen where it's supposed to be so even
that simple scheme shows that it moves a
lot of copying the most the worst one is
the fact that we copy beats from the GPU
so that we could send them to GPU again
later in a WT frame this is a huge
inefficiency and although in many actual
applications if you embed the entire
JavaFX application in Java effects panel
you see probably 10 to 15% the loss of
performance as opposed to a standalone
java effects application though that
really depends on manufacturers and
we've seen cases where it's higher the
intent here is to improve it the intent
here is to have so called unified
rendering when we leave the beats where
they were prepared on the GPU and make
sure that we can use those beads on the
AWT thread so that we avoid passing them
back and forth between CPU between main
memory and video memory since well
apparently that could not be done
without changing a WT now that all the
components are part of the same release
that work finally becomes more feasible
although I cannot say whether or when it
will be actually implemented but that's
the general scheme how beats get how
they traverse different threads and as I
said a lot of copying here is involved
and by the way another manifestation of
that is that again if you use an
external tool that measures CPU load you
will see that when you embed JavaFX
application into a java effects panel
java effects panel cpu load increases
that increases you exactly to all those
copying that occur between these threads
okay another scenario that I wanted to
come to cover is web view so Java
effects have has a webview know that
basically is and where did browser in
your Java effects application
implemented on top of WebKit and I'm
going
mungus briefly to discuss how that how
interaction with WebKit occurs in the
scheme of for Java affects things so
first of all web engine engine part of
the web web node webview node implements
a pause timer basically it sets up
continuous empty animation and as we saw
in the very first diagram that animation
is always executed when the pulse runs
and on the other hand if you have an
animation you always run pause so
basically we create a surrogate timer
for WebKit based on our pulse if at once
at 60 FPS on nearly 60 fps okay you have
a 60 FPS timer for the WebKit if it
doesn't okay it doesn't because you have
a lot of work to do and you cannot run
at 60fps okay this is a point and it's
better shown so fire time I went it's
part of the first phase on the FX thread
animation this is a point where you go
into the WebKit and you allow say if you
have JavaScript animation on the webpage
that you are displaying that's the point
where it gets chance to run and we make
sure that it happens every time we do
anything on the system okay
so basically I'll describe it on that
slide another part of web view
implementation is involved before any
scene related code before CSS before
layout start as part of a so-called
stage post listener so web view
implements a staged pulsation and we
have stage post listeners we have simple
listeners and and this is done so that
we make sure that any webpage updates
any anything that we need to render
during this frame is defined in webview
node before any scene related code it
runs well that's important for some
reason but what I want to describe here
is that the result of that work the
result of that update content is some
internal implementation that's specific
for webview webview creates its own
rendering cue it creates its own cue of
rendering commands that JavaFX runtime
in general is not aware of and it saves
that state until later and when it gets
to actually drawing or actually painting
the peer node on the render thread that
rendering cue is decoded and actual
drawing commands are issued on the
render thread and this is somewhat a
bypass mechanisms all other nodes play
by the same rules you defined your
transitions and those transitions in
general are translated to actual drawing
commands webview is somewhat secure in
that regard but otherwise otherwise the
entire skin is now should be very
familiar to you
ok so once again
I'm getting better at it the next part
of the talk is finally what runtime
performance data is available from
JavaFX and not much basically we have
two pieces of code which are called
performance tracker and pulse logger and
I'll start with the performance tracker
so it's part of JavaFX runtime it's
available in release beats part of JRE
so you can actually invoke it using the
JavaFX runtime that is part of your JDK
Oteri installation so it's not something
it's not something that we use only
internally though the name of the
package of the performance tracker
suggests that this is not considered by
the part of our public API well
basically everything that I'm talking
about today should not be considered as
stable as committed everything can
change but again my goal is to share
what the performance human generally
uses for Java effects and if it's useful
for you great if it's if not okay so
this is how you instantiate it very
simple you need to provide the scene
because the tracker is associated with
the particular scene you have multiple
scenes you may have multiple trackers
that will track only a particular scene
they will provide information about it
and the tracker has well specifies its
API and this is not the complete API I
believe although pretty much close to it
okay so the first functionality that it
provides it allows you to ask it what's
the current or average FPS for my
application is it makes sense for
applications that run continuously so if
you have any animation in your
application that will be the case if you
have a pure UI that just sits there
until you start start interacting with
it then fps boom
not necessarily mic make much much sense
but I'll talk about some ways to change
that
okay the instant fps is basically how
many frames we have rendered during the
past second or two I'm not sure I don't
remember but it's always taking probably
a second it's it's always reporting
about the last second of execution
whereas the average FPS is from the
start of the application or from the
last reset so you can reset average fps
and you can start collecting new counts
and compute new average FPS from that
but if you have the tracker you just ask
it it returns you the value you print
that value you make it somehow available
and you know what the performance of
your application is at this point but
the tracker provides yet another
functionality which is basically to hook
points into the pause mechanism that
allow you to run your own code whenever
pulse on the scene starts or whenever
the current frame at least the current
rendering work for this particular scene
is finished so you have those two points
where you can submit your runnable which
will be invoked at those points you can
collect your own statistics you can make
you can obtain your own time stamps you
can do whatever you want at those points
in order to maybe compute some other
metrics that most sophisticated more
applicable in your case probably in fact
we also use those mechanisms in before
assessing so sometimes we want to know
exactly when a frame rendering at least
from JavaFX Point finished and we want
to know how much time it took from some
originating event until all the
rendering job is done those that's
exactly the point that you will be
getting a new timestamp
so that you could determine that
interval and on the diagram I am showing
the points where the interaction with
the performance tracker occurs from this
side of JavaFX runtime so you can see
that the pulse
I mentioned house while seen pause
listeners so each scene has its own
pulse listener so each scene will come
to the performance track and will
notified that the pulse occurs and if
you provided your notification the
performance tracker will notify you that
the post starts but that doesn't cover
animation in this case frame rendering
render it is well exactly what you
expect it to be only this is when frame
rendered as considered by the render
thread not necessarily by the native
platform that we are running on so
that's important to understand okay
another performance related data that
JavaFX runtime provides is through a
so-called pal girl that's also mechanism
that is considered internal but it's
available in the actual runtime that is
shipped with Jerry so you can use it
there you turn it on with that option
JavaFX pause for equals true and it
accepts one parameter and basically that
logger will report some information
about every pause that happens in the
system and with that threshold you are
telling it that if a pulse total
processing time took less than 17
milliseconds and I believe that's the
default then don't bother with printing
out all the information so you will be
getting basically information about
pulses that took longer than the
threshold that is said you said all is
preset by the system okay so output of
the post will consist of pause based and
some interpose data sometimes not much
but some some time intervals how to
describe them in
later messages and counters if you are
working on three if runtime itself if
you are able to modify it if you are
building it and then you can actually
use this mechanism to insert more
information into it it's very simple
examples are they in the source code and
that may give you more information about
how runtime I understand that's mostly
for effects developers but sometimes
even application developers want to
understand why the runtime doesn't do
what they expect it to do and get more
information about what it's doing okay
so here is an example of actual cost of
the output it outputs holds data per
standard output so you need to run your
java effects application from say
command window terminal and that's an
extra output that I got from running
that command line above and well we have
some Java FX port of we mark to test
benchmarks and this is how I invoked it
and this is what I I received so for for
each power to get its consecutive number
then two intervals the first interval is
time between the start of the current
pulse and the start of the previous
pulse the fact that it's 48 and it's
multiple of 16 tells us that we have
missed two timer events and we started
our class exactly on the third time an
event here so there is some consistency
in data here the second interval is how
much time it takes to run it has taken
to fully process that that pulse it's 74
milliseconds the fact that 74 is greater
than 48 kind of suggests that we are
running in parallel and we are taking
advantage of it then a set of messages
follows and each message starts with the
thread ID of where that message
generated from and while we have two
threads while t10 apparently is the FX
thread and t8 in this case is apparently
the render thread index thread IDs I
believe are provided by Java Runtime so
those should be consistent with the
thread IDs as reported by JVM to any
other through any other API okay now in
parentheses we have two numbers the
first one is a relative time with regard
to the moment when the power started so
the CSS pass in this case started 3
milliseconds after the power started and
to 0 milliseconds we mark 2 bitmap test
is mock up gaming environment where a
lot of graphical elements monsters are
running around the tower that shoots
those monsters so basically we are we
have a lot of image views and we
translate them we move them around the
screen and for image views there is no
CSS work so the fact that we didn't
spend any time there is a good
indication that we didn't waste any time
then layout house is also layout is not
involved in this case but the fact that
CSS per has sorted at three milliseconds
and not at zero means that we have spent
3 milliseconds somewhere animation so we
know from that diagram that the first
phase of any post processing is
animation and of course in that mock up
gaming test case animation takes some
time 3 milliseconds we can infer so post
lager is not basically it's developed
whenever a developer wants something
from it
it just goes mostly our architect ok it
just goes and adds new messages or
changes I hope that the format the
overall format will not be changed I did
some work on that and I want it to be
preserved because even some internal
tests start relying on its output
waiting for previous rendering again the
fact that we have waited 27 milliseconds
is an indication that we are running in
parallel also although in this case it's
not a good indication we have waited we
could not proceed with what we wanted to
do but we had a lot of work to do and
well this is what it took at least we
know how much we wait then 2
milliseconds to copy the state render
graph and then we are switching to a new
thread or basically mom those messages
are generated from a different graph and
they could not intermix because we could
not start rendering job until we are
done with everything we have on the FX
thread you remember that we certainly
the render job at the very end of the
post-processing of the FX thread okay so
you get some timing information you are
basically and okay yes I mentioned
previously that you also get some
counters so when all the processing
occurs and when the post worker is
enabled if it's disabled nothing that
had nothing of that happens we count
some events like in this case you can
see how many nodes were rendered during
that frame and how nodes were visited
during the render in this particular
case those numbers are pretty close
because again the application is such
that basically every element on the
machine moves so we need to render we
need to render every element on this
scene with the controls based
applications for example that may be
quite different okay and here is again a
diagram that shows exactly how we
measure those intros so 48 milliseconds
as I said is between the start of the
current pass and start of the previous
pause 78 milliseconds is how much time
processing the current frame has taken
and you see that it's 2 times simply
obtained on two different threads
actually because we decided that we
finish
the current frame on the render thread
and for any message in between we
measure its time starting from the
current box and this is a more elaborate
diagram that shows exact points where
interaction with the post logo occurs
again I don't expect it to make much
sense right now during this discussion
but it's quite not obvious from source
code so if at least for reference
purpose that slide may serve some my
probably some usefulness even for myself
but otherwise it's pretty natural so CSS
pass is reported at the end of the CSS
phase layout pass at the end of the lab
layout pass update bounce phase is not
counted can be inferred from other time
stamps but is not counted as such wait
for previous rendering is accounted for
exactly copy state to render graph is
synchronization of force in graph nodes
with its peer pulse and is when we
actually submit a render job it's
curious that render start is defined as
the beginning of that face it's not
visible in post fogger output as such
but if you ever have a need to
understand how powerful works that's
exactly the point well then that
internal event occurs ok and finally
dirty ops computed is part of the
rendering of the first part initial part
then painted for each dirty region I
believe and finally presented how much
time it took to present make sense on
samples and some scenarios doesn't make
much sense in other scenarios I believe
that if there is no presenting as such
if we are uploading beads to say oh I
can swing up swing intro
a probability scenario and I believe
that message will not be there nope okay
and the final part of the presentation
is how to enjoy effects runtime behavior
and I need to speed up okay so first I
mentioned that if your application has
animation it's very simple to measure
its frames per second if it doesn't we
have a way to emulate that and
internally we use glass robot this is
part of Java effects the runtime is
available to you in again any job of
extra-time beads and its api is quite
simple move mouse mouse press key press
mouse wheel you may so basically this
scenario is such that you use the robot
in order to move Mouse make clicks on
some elements that elements will require
the pass to be processed and if you do
it continuously you will have kind of an
automated way of running your
application and actually in some cases
we do use it as an automated way to run
our performance benchmarks rather than
functional tests and I want to mention
one framework that is thoroughly hidden
in open G of X which is Jaime effects
that's a framework that is built on top
of glass robot and that allows you to
create automated scenarios to run your
application on in Java FX Jones
rather than in Mouse move or key pressed
terms so it's a high-level way and I
believe that it's used in the act in the
JavaFX
QA team to create the forms benchmark or
not functional benchmarks okay go ahead
we're available it's not available on
every platform
AWT is not I believe it's not available
on embedded Linux it certainly won't be
available on iOS but we're available yes
AWT robot works with any application not
necessarily job sometimes if it goes
awry it's very difficult to get rid of
it because it continues clicking on your
desktop and etc so it's very low level
in this case well one important
consideration is that the event is
inserted into the event queue at the
mobile code glass level that's the level
between JavaFX runtime and native
platform not native level but for JavaFX
consideration low enough for us to know
that all that event will pass through
all the phases of processing so it will
be processed as a JavaFX input event a
handler if available will be invoked and
it will make changes etc so basically
that's a better way to automate your
application for say testing purposes
then working with Java FX nodes directly
say you may find out what no to present
your scrollbar and you may just work
with the scrollbar directly you may say
okay set your position to 0.5 for
example and everything will work that's
not good for performance benchmarking
why because we are missing a pretty
important part of processing the input
event of or taking you mouse wheel for
example and that change goes directly to
the scene graph by passing that input
event handling ok I skip the slide ok so
I'm running out of time
all right full speed mode that's the
option and basically what it does its
eliminates dependency on the timer
whenever you are finished with the
current frame on the FX thread you
immediately start a new one of course
all input events will still be processed
but there are no delays other than
waiting for the render graph to finish
its job with the previous frame if you
run it with full speed mode okay if your
application measures fps you get those
fps and you can compare them with say
original one sometimes the difference
may be quite big and there are reason
for the reasons for that and basically
concerning interaction with vsync of the
native platform but I do not go into
more details single thread it is yet
another option to alter your runtime
behavior in this case everything will be
run on the same thread so the render job
that we said need for the render thread
will be running the same effects thread
will interfere with the input events
with the timer etcetera so it would
certainly run slower but it allows you
to evaluate how much you are getting
from per list of Java effects as in
Pedro okay in order to explain other
ways to alternate effects front time I
want to present a different view the
JavaFX stack as a pipeline where is
similar to the previous one but just a
different aspect so we start from
updates to the scene graph and then when
we go to the render part of Java effects
that consists well the name the internal
name is prism and it consists of two
parts one is common and this is where
most of the action occurs and the other
one is pipeline specific d3d on Windows
OpenGL on Linux on Mac OS and finally we
go to the actual or native layer that is
available on particular platform finally
to GPU so I'm using this view to explain
how other options work so when you sayno
render jobs it's very
you know cut it right after sing Graff
has done all the work
synchronize all the notes by the way all
that work is presented but instead of
actually submitting around the job to
the render thread it does nothing so one
important application is that if you
specify that option you see nothing on
the screen because nobody rendered
anything and thus the only importance of
that option is again to if your
application say using formal structure
prints the current fps you see how it
appears changes and you make a
conclusion whether the bottleneck in
your application is on the sink rough
side or on the render side if FPS
doesn't change your single bound if I
first changes dramatically
you have bottleneck on the render side
for Java effects developers it's well
good starting point to know where to
start talking to the two for you it's a
good way to know which category to file
your bug against jello effects whether
it's single for graphics or well
wherever else now 3d pipeline is a stop
graphics pipeline implementation instead
of going to the native level for
executing actual or drawing commands it
does nothing just but all the common
prison code is there and is part of that
execution again that's just a way to cut
the pipeline at a different point and
see where the bottleneck is before or
after that point finally I wanted to
touch one utility that we develop
internally nothing original highly
original but very useful in our context
we call geo trace it's part of open GFX
repository the source is there you can
compile it's fully functional our own
Linux arm that was primarily the
platform that we were interested in and
it allows to capture the entire OpenGL
interaction between JavaFX and open-air
layer to record the to file and later to
replay it and when you replay it it will
provide you with two metrics recorded
fps and actual fps and that allows you
again to see whether you need to make
JavaFX to generate opengl faster or you
need to generate different opengl in
fact we have two completely different
cases on two platforms that we support
BeagleBoard on the raspberry pi on
BeagleBoard we are mostly GPU bound same
application running on two platforms so
gel trace shows that you run the same
OpenGL on bigger board you are getting
same fps as if JavaFX is not there well
it's not there but it doesn't cost you
anything to produce that OpenGL on
Raspberry Pi one may get 10x improvement
that means that GPU is fast enough but
the CPU is boom is not catching up and
we really need to focus our optimization
efforts on the Java side part of it ok
and finally I wanted to describe why
using irregular profilers is not good
with Java effects CPU profiles not much
is for useful why wait time is important
factor in Java effects performance and
you saw that we have weights due to
interacting with the GPU on the render
thread due to synchronization between
threads sometimes they are due to GC
activity because under some
circumstances Java effects on time we
start generating a lot of garbage that
will invoke garbage collect and that
will affect your performance performance
of your application so if you just see
or where we spend CPU time becomes in
many cases total not telling my own
experience and CPU utilization in fact
may be misleading for the same reason
due to some yes/no
you need the unit a better picture
because if you just take CPU numbers
they may be totally misleading because
that particular node may be really a
bottleneck but due to the fact that it
interacts with GPU say read pixels read
pixels is a very expensive operation it
will not show up in your CPU profile why
because we are waiting for GPU to
provide those are those bits it will
show when we'll start copying them on
the CPU but that's a different face
ok another difficulty with using
profiler see is that most time of your
application is spent in JavaFX runtime
you barely see your user code in the
profile and when you see a particular
profile Java call stacks they reveal
graph traversal algorithms either during
event handling or CSS processing or
layout it's all just bypassing the graph
and seeing a lot of same identical
frames doing apparently the same work it
doesn't tell you much even for us it's
still very difficult to match that
activity to actual program and what
needs to be done in the program in order
to to change it program or even Java
effects runtime ok and even if you when
you do know that you are spending time
on a particular type of syndrome say
image view it's still very difficult to
attribute it to a particular object that
you created in your program you may be
having like in my case with goon mark 2
you may be having 3000 image view nodes
are they the same is it spread over all
knows is some nodes separate different
from others you have no way of knowing
so this is a common kind of problem that
we are suffering from ourselves and we
realized that a general purpose tool
that is not aware of Java FX is not well
it does not provide meaningful
information and we need some way to try
to Java effects internals and this is
something that we're thinking about and
we want to well provide for our sauce
first okay and finally
our lawyers wanted me to say hi that's
for the Google site okay
that concludes my presentation so it's
ran a bit longer</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>