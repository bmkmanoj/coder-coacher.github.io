<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JavaFX Versus HTML5 | Coder Coacher - Coaching Coders</title><meta content="JavaFX Versus HTML5 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>JavaFX Versus HTML5</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/f0ES68bZ3Sc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I'd like to welcome everybody to Java
effects versus html5
I'm Ryan Ryan cupric from the so systems
I work on basic I work on a chemical
formulation software actually it's a
swing going towards FX app hopefully
David Greve who's also helping with it
was also involved with the presentation
we'll be demoing the one of the apps at
the end of the presentation just a
little bit of a spoiler or there is no
winner to this presentation so if you
came here looking for you know Java
effects clearly beats out HTML 5 or the
other way around it's a little bit mixed
as you'll see as I go through the
presentation so it all depends upon you
know the you know whichever it's not
good okay
whichever which depends upon what you're
looking to do so the agenda for today
I'm gonna start off discussing the demo
application which is the sailing
application if you were here earlier
this morning I did a two hour training
session on Apache Cordova in Java EE 7
so we'll be looking at that html5
application comparing it against an HD
FX implementation of it so first I'll go
over a little bit of the demo
application explain how it works and
what it does and then go into a
technical comparison where I look at the
code kind of in-depth between the two of
them it's all slide so that I won't be
diving in and out of NetBeans giving a
vertigo then a look at putting Java FX
and perspective html5 and perspective in
terms of the histories and their feature
sets and then finally do an analysis
between the two talk about integration
between the two technologies and then
wrap it up with a summary and so just a
little plug for work we actually
designed both of those boats or our
software is used as as I'm both of those
boats and if you haven't have made a
chance the boats I'm an avid sail or are
down at Moscone so we can intercept the
boats down there the code for the
presentation will be up on my github
account I believe it is still private I
thought I switched it over to being
public but evidently it's still not so
you'll be able to check out all the code
for the
ve7 backend for this application the
html5 version as well as the JavaFX
implementation of it so the demo
application is actually a sailing
application for managing sailboat races
so the first question before I show the
the thing before I show the actual demo
application is JavaFX versus swing why
why is this presentation you know why
are we comparing JavaFX to html5 and not
swing to html5 well the reason is that
the first reason is that JavaFX replaces
swing swing was in 1990 1990s technology
is definitely from a different era we've
definitely moved on since then swing has
significant shortcomings in terms of no
support for touch it would be very hard
to actually wire that in its tabeling
support is pretty lousy you can't
actually join table cells no support for
animations data bindings etc and you
know often times in order to do the site
types of things that we can do with Java
effects with CSS files in swing you
actually have to make changes to the
actual look and feel implementation so
that's that's just kind of putting it in
perspective because I know that quite a
few people ask about Java effects versus
swing and then in terms of html5 so a
little background before I show off the
demo application html5 has arrived on
the desktop there are actually html5
desktop applications that you can
download and run at Apple's developer
conference there's extra sessions you
can watch online right now where they
will talk about how to debug desktop
JavaScript applications you can submit
JavaScript applications to the Apple
Store they actually digitally signed it
and they prevent end-users from actually
you know attaching the debugger in
looking at your JavaScript code but
job.but html5 has arrived on the desktop
it's just not something that runs inside
of the web browser html5 has also
arrived on mobile that's the Apache
Cordova icon that's up there and I'll be
talking a little bit about that as well
that's actually what the demo
application is written using html5 apps
are actually applications they aren't
web pages the logic is written in
JavaScript the UI is implemented with
html5 the markup and then css3
so it's not a situation where you're
serving up you're writing a code in JSF
or jsps and you're serving it down to a
you know a client operating system
that's you know makes it look like an
application application is completely
implemented and standalone so it doesn't
even require a network connection
depending upon the type of apps then in
addition one area where html5 JavaScript
is often lacks is in terms of device
support and you'll see a slide another
thing if you interrupt the the Cordova
presentation earlier you have seen how
you can talk to the cameras on the
phones you can talk to you can now you
know get the you know take a picture you
know get the GPS things get actual
feedback from the GPS chip on the phones
accelerometers talk to Bluetooth devices
Bluetooth Arduino devices so all of that
is now possible if you're writing
JavaScript code and it's pretty easy to
do so what type of demo application well
the Apple the demo application has a
mobile application using html5 and
Apache Cordova like I mentioned that
Petra Cordova is previously known as
PhoneGap the it is not a website
application the application the app was
completely developed using html5 it has
a rich user in experience and as I
mentioned before it's not JSF plus html5
the application is completely written in
html5 and in terms of applications this
is more of what I mean in terms of like
the Google applications that are running
in your web browser not the old table
type things where you're presenting
static content you know not the 1999 web
app type stuff okay so that's that's
where we're going so the the
presentation today as I mentioned it's a
sailing application I go sailing on a
regular basis and one of the challenges
is trying to coordinate a race out there
typically a committee boat will sail out
and then set a racecourse then via radio
tell all the participants this is our
course for tonight and then everybody
has to check in with committee boat and
tells you know inform them what start
are they participating in are they a
fast boat and they're going first with
the first start and the fast
are they you know a slower about etc so
it's an application that kind of
simplifies doing this and hopefully I'll
have it in the app store within a week
or two after I get back so that's that's
what the application is if you were here
last year and got to see the the
America's Cup out there that will give
you some idea of set about racing so
anyway so it's an application for
managing that the application is a rich
application that has both a rich
front-end and a pretty hefty back-end so
it's the interface is written using
Apache Cordova and JavaFX which we'll be
demonstrating today jax-rs is the
communication layer that goes back and
forth to the server and WebSocket so the
content is never rendered on the server
data is pushed back and forth and the
application can function if for instance
you're out there five miles from shore
and you lose cell phone connectivity the
application can still function because
it's cached it locally using the local
storage on the phone or the computer the
actual application logic is implemented
using ejbs
also javascript to a certain extent the
entities the data model on the backend
server uses JPA JMS CD iso uses the full
alphabet soup of java ee technologies on
the backend coordinate the rate
coordinate the race among the different
phones that are connected to it so as i
mentioned just kind of a rundown of the
features for the committee boat sets the
racecourse and announces that via radio
the boats register video radio set up
the start sequence the committee built
monitors the progress of progress and
also pushes out weather information to
the boats out there that are
participating and then alters the course
so this is where the stuff like
WebSockets and jax-rs come in into into
play so with that now pulling back to
the html5 stuff I've stretched stress
that already a couple of times that it's
not a JSF application it is a single
page web app it's a single page
application s.p.a the application is
actually basically just a webview
wrapped as pretending to be an
application now you can actually
right additional native code to do stuff
the logic is implemented using
JavaScript along with JavaScript
platform extensions for you know talking
to the camera and the GPS on the phone
the UI is implemented using well
typically for this mobile applications
the UI would be implemented using html5
markup and then you also have the option
of using SVG canvas and WebGL if it's
supported on the device and then all
assets with the html5 mobile application
or even if it's a Chrome application get
bundled with the application ok so
native html5 versus your traditional web
applications the first thing is that as
I mentioned before there's no JSF JSP is
your Jason facelets and there's also no
HTTP session and so I kind of stressed
this this morning the application is
completely running in there and you'll
see as I go through the presentation and
talk about the code in this application
you'll see exactly how its operating now
on the next slide just to show off
although I won't run the application at
the beginning because it's kind of hefty
I was having trouble with network
connectivity it is a large application
with multiple screens on it so it has an
initial landing page and if you've
already logged into the application it
skips that and brings it brings you to
the menu because you know every time you
you open your mail client on your phone
it doesn't ask you for your username and
password I actually covered this morning
how you handle that from a security
perspective so that you're not caching
given that you don't have an HTTP
session and to ensure that you're not go
over how not to cache passwords and how
to implement stuff and that's the type
of situation but it's a large
application with over the the data I
think I've got like something like 17 or
18 database tables right now so it's a
large large application on the backend
that ships down many different types of
objects via JSON and WebSockets down to
the client has got integration with maps
so that you can actually track your
progress going around it so this is a
full-fledged application that's been
implemented and now in both html5 and
Java so this isn't your typical like you
know HelloWorld application it's a to do
thing you know really simple with a
couple of screens so the Java the
technologies that were used to implement
this on the JavaFX side it's vanilla
JavaFX designed using the scene builder
version 2.0
in terms of connectivity with the back
end it uses jax-rs to the jersey
implementation the Tyrus implementation
of WebSockets and then finally the JSON
the Java API for JSON processing revert
the reference implementation that comes
with GlassFish so these three
technologies are not built-in by default
on the html5 side of things is more of a
polygon because it uses Apache Cordova
so you get the native phone capabilities
wrapped up as a native phone application
and Apache Cordova supports Android iOS
Windows tins and Blackberry etc so as
far as the end user is concerned they
will that would have no idea with this
application that it is a html5
application running on their phone if
you do the CSS right for it you would
think that this you know that it's a
regular iPhone application it might look
a little bit different but I guarantee
you that on your phones right now you
probably have a Cordova application and
you don't you don't realize it and it
uses jQuery and jQuery Mobile as well as
knockout Jas which I do a little bit of
demonstration on and the reason why I
picked jQuery jQuery Mobile is just
because it's easier to demonstrate
what's going on because there's other
there's many other application
frameworks but most people are familiar
with jQuery the other one that I like
which I'll kind of get on to the next
slide okay so in the next slide I have a
list of different frameworks now there's
about a new framework I think every week
so these are you know various frameworks
that you use for actually building your
application you're building a Java FX
application you're not paying
necessarily attention you don't you know
the JavaFX kind of provides an
architecture for you in terms of how
it's designed you don't need a framework
that's providing this for you so many of
these frameworks provide enough you know
basically a framework and a whole bunch
of you know CSS and appearance stuff to
make your application work so and some
of them will provide that you know CSS
files to make it look more like an
iPhone application I'm really if you're
doing html5 development for a phone
you're going to need one of these
frameworks because you don't want to
reinvent the wheel
I would require an extensive amount of
code to re-render a link as a button and
if you look at some of what's going on
in there it's it's quite a bit of work
that you'd have to do you can also use
angular and then as I mentioned I pick
jQuery Mobile but the one that I like
that provides more of an experience like
what you get with using scene builder
and the Java platform is Sencha touch
now their IDE
it forces good MVC practices its
development environment similar to that
of scene builder same builder 2 or Xcode
and Android studio so it allows you to
graphically design things forces you to
use MVC and all the good things however
the IDE itself comes with a $400 license
sinister touch itself is open-source and
does not you know there's no licensing
or royalty fees with that the only
restrictions that you can't build an IDE
for it so that's probably you know will
probably never get the complete support
for that NetBeans but it's one of the
better ones I think so the material
differences on the demo application
between Java FX and html5 with Java FX I
don't have any integration with the
camera or the GPS or connectivity
information so I can't find out you know
what type of connection that I have so
the Apache Cordova stuff extends the
JavaScript API so that I can get
information as to whether I'm on a 3G
cell phone and Ethernet connection that
type of information and whether there's
even a connection that's available I
don't have to try reaching out and
waiting for timeouts Tucker we're doing
vns lookups and waiting for them to fail
so the that's one of the benefits of the
html5 stuff with Cordova now in terms of
html5 some of the material differences
UI layout now if you're using Sencha
touch that does have a concept of layout
managers but if you're not using
something like sensotouch and you're
gonna have to handle doing the layout
yourself you're the framework you might
pick might have something for it but
you're gonna have to wrestle with the
layout stuff and it gets a little crazy
with the phones as you'll kinda see you
also have issues with background
threading with html5 yes you do have web
worker that you can use however web
worker you're not supposed to be
manipulating the Dom from it
so though you can run things in the
background you're not supposed to man if
you like the dome from it and then you
have browser support which I have
indexdb up here because I wrote the app
the application initially using indexdb
to cache the racecourse and your
coordinates as you are around the course
now when I deployed it to my iPhone I
found out that I'm running iPhone 7
still I didn't want to upgrade for that
you know a couple of days before the
presentation and iPhone 7 doesn't
support indexdb iOS 8 does but the
application would actually kind of crash
from the JavaScript interpreter would
stop when it hit my indexdb calls and
then I found out that it was not
supported and had to rewrite the rewrite
part the application in the same vein if
you're trying to look into use HTML 5 to
do like a cross cross phone game with
like like WebGL WebGL is not supported
on iOS devices as a blast check although
I haven't checked with iOS 8 so you know
there's there's certain caveats with
each one of these technologies so now
I'm going to kind of dive into the
technical comparison between the two of
them looking at the code actually so for
the HTML 5 as I mentioned is constructed
using html5 markup the logic is using
javascript and the tooling was NetBeans
in both cases so nice thing with
NetBeans which I really like is that I
can develop both my html5 and Java
applications using it it's got excellent
support for html5 development and also
Apache Cordova support so I can actually
from NetBeans without installing any
plugins or doing any anything else to
the ID I can just download the IDE and
I'm off and running doing html5 mobile
development it's a breeze it also
integrates with Chrome for doing the
debugging it also has support for Java
FX with the JavaFX UI was implemented
using the FX ml so it was designed in
the scene builder so the UI is done in
XML essentially and you can kind of see
the projects I've snipped out the
projects on the left there so you can
kind of see they're fairly large
projects with many files and there's sub
directories that I haven't expanded that
are a part of this so that's that's the
overall projects as you can see there's
quite a few files on both ones now in
terms of the
looking at the the JavaFX implementation
each screen has got the concept of a
controller associated with it so this
one shows the various screens that make
up the application each one has you know
I shortened the class names up there so
it would be logon controller just so
that it would fit on the screen but then
they each have you know login control
and then there's analog gun F XML up
above so which screen is associated with
it the application the FX implementation
has the same behavior as the mobile
phone application that that's a card
layout it's not the most ideal but it
would allows you know comparison between
the two implementations in terms of code
complexity and feature use so that's the
basic architecture of it it's fairly
well structured and then each controller
for each one of the screens there's a
common base class called a regatta
controller which has methods for you
know sharing the next page moving back
and forth because it's kind of a card
layout you're swapping the nodes in and
out and then the log and controller and
all the controllers implement that so
this is a pretty common construct with
it and it passes the data between the
screens so when the next screen gets
displayed it gets over the data for that
okay now I'm diving a little bit deeper
into the the technical stuff so we have
are looking at how the pages flow within
the application so in this case here we
have our join race XF XML when you click
on confirm to log in to the application
it's going to invoke the confirm confirm
method on the controller and that is
wired up using the property editor on
the right so when it says on action
you've entered in the method name that
you're going to invoke that's going to
look for and deep down in the code you
have a method annotated with F XML and
the name of it being a confirm action so
the IDE and the sort of the scene
builder are working in tandem to allow
you to wire up the application easily so
this is how you do this with Java F Java
FX music scene builder now moving on to
the html5 application and this is sort
of the same way that the FX application
was working but just to kind of stress
that this is a single page application
using jQuery Mobile when the user clicks
on the you know the first page clicks on
say a link to open up the menu page it's
actually invoked via button action what
actually happens is that the index page
is still loaded the content of the menu
page the the main body portion of it is
inserted into its content so it's not
actually didn't actually browse to a
separate page you took the content from
one file and inserted it into the other
file and then if you then click on that
link it's then going to insert the info
right so if you've then browse from
indexed menu then menu to info you're
replacing you're inserting content into
the contents of the phone into the
contents of the file so that's how this
this single page mobile application is
written so you're not transitioning
between pages so although there's
multiple HTML files out there that make
up the project there's only one that
actually gets loaded initially and then
the rest of the rest of the pages get
dynamically loaded in so the actual
application structure so if we look at
this slide here you can see there's
quite a few pages that make up the
application basically it's a one for one
versus the the previous slide on JavaFX
so we have you know basically the same
type of screens locked up there the one
difference is that loading the
application is a little bit tricky
because I have to initially load a page
because when that thing browser goes to
render a page it has to render an
initial page and then after that page is
complete then I swap in either the login
page or the menu page depending upon
whether your credentials are saved so I
have to go through some hoops in order
to get that to work you know given the
workflow and jQuery Mobile and Apache
Cordova in the rendering cycle of the
browser that's why there's a few more
pages there on to the next screen so
we're looking at the H the UI flow so
I'm just taking a simple you know the
simple thing when you login to the
application presents you with the menu
for joining a race looking at the
results for a race and so I'm looking at
here where you click on you want to join
a race and how do you actually get to
the page that says join race because
there's a few things that have to happen
it has to render the next page but it
also has to go off issue a Ajax call
what a restful web service call to get
the list of races that you could join
and then update the contents of the page
before it displays it for you so that's
what I'm gonna that's that's what this
is covering here so there's some
callbacks that these callbacks are not
specific to html5 they'll be different
based upon depending upon the framework
that you're using so here I have a page
before so the agent before show so what
happens is the first the menu HTML is
rendered and then you click on you know
what looks to be a button that's
actually a link underneath the hood that
triggers a get racist call which
ultimately goes out and retrieve the
races for you and then you know the
in-app j/s file there's a page change
event that gets fired and then a page
before show that gets fired
they then calls the race judge as
telling it to update the page with the
list of races and then the join race
page actually gets invoked and you've
got the button that allows you to click
on joining a race so as you can see it's
quite a few steps there's callbacks that
you have to implement it's not well
factored for each page the control the
the logic is not you know the logic for
the JavaFX application is centralized in
the controllers whereas this one we kind
of have like a centralized controller
that then dispatches out now there's
other ways of writing the application
depending upon your framework or if you
build something up this is just the path
of least resistance when you're running
the application so moving on with a
jQuery Mobile stuff this is how you
actually go about transitioning between
pages so as you can see the first one
we've got programmatically you know when
I decide you know I'm trying to figure
out which page do I show next I use a
mobile dot change page and give it the
page that I want to transition to you
know and whether you know is the
animation that I want with the
transitioning if you're not using jQuery
Mobile and you weren't using the
framework at all you're gonna have to
implement that all yourself you even
have to implement the slide mechanism
they take for granted and an iPhone or
an Android application UI and then
there's also you can use links to
invoked loading of the next page it
actually overrides the on click on your
underneath the hood and then finally
there's a logic down below just showing
a new example of the process before
rendering you know the type of logic
that goes on for
then on the next page next slide I'm
looking at the the startup logic for the
application now because I'm using two
different frameworks I'm using Apache
Cordova to wrap the application on the
mobile phone and then I'm using jQuery
Mobile both of them have init methods
and whatever framework you use there's
gonna be some type of startup method
that has to get invoked whether it's
Sencha touch or the Intel framework that
I had on previous slides there's gonna
be some init method for that so when
running on a mobile device when running
on a mobile html5 application I first
have to wait for the application to be
started for the web rep for the native
code to kick over to the the JavaScript
code and say it's done loading now you
can continue doing your own
initialization so then I have to
programmatically invoke until jQuery
that it has to initialize and go through
its normal initialization type stuff so
you kind of can't do the things dollar
sign ready ready that you get with
jQuery that won't quite work correctly
for you and then this is just going into
a little more depth some of the logic
that goes into loading data on the
screen so this example here is not using
knockout which I'll show on the
subsequent slide this is me manually
loading so before the page gets
displayed I want to you know blitt the
values that came back from the server
write the clear out things and then I
have to generate content for you know
populate the combo boxes that appear on
the screen so that's what this code is
doing even if it's a little harder to
read it's doing a lot of manual stuff
that really is a pain in the neck to
actually implement yes
where he's got all the data back and
he's gonna figure out with the screens
and look at the screen in the java text
application inside it's just making a
query and then it can display the screen
when that date comes back all these
combo boxes in
yep so on the next slide you see the
knock out a kind of example this is more
now I guess what we get in JavaFX in
terms of being able to bind stuff you
know bind up a bind a basically we're
creating the equivalent of JavaFX
properties and we're binding the UI
controls to it so that's what this code
is doing so you have the bind I set up
the bindings up at the top and then
you've got the snippet down below which
is the html5 snippet using the data bind
to handle that okay and then the one the
one caveat if you take that approach of
doing it then when you go to generate
you JSON then you have to you know do a
little bit more work there and list the
properties out so it became kind of
becomes labor-intensive although
depending upon your JavaScript skills
you can might be able to come up with
something that's a little simpler than
this and less less redundant coding now
switching gears here looking at and
comparing it to the JavaFX stuff and how
you actually do binding so we just
looked at html5 binding it to your data
model because remember we're not just
collecting values in the traditional web
application and sending it down to the
server we're actually storing them in
memory then working with them later so
you know we're actually dealing with
JavaScript objects the term in the case
of the html5 application for the JavaFX
application we have our field we look at
the binding property on the right and
that's how we bind it to we have the
binding as up at the top as the the app
the ID and then we can register various
change events down below that we'll hook
in so in the field changes we get
notification etc so this is how this is
much simpler you know depending upon
your framework this is a much simpler
approach it's standardized if you're
writing a Java FX application and then
the actual code for that screen that you
just looked at we have our text fields
there they're annotated with F XML and
that's how they get how they get bound
in there and then I mean you could then
by net to your actual Java pojos using
bindings as well and property bindings
and then the bottom piece down there is
basically until you type in the username
and password the login button doesn't
become enabled so that's doing down
there is that is enabling the binding to
basically the you know
the fields are populated whether they're
empty or not to control whether the
button is enabled or not so that's
that's pretty straightforward code
compared to the html5 version of it okay
so moving on one of the things that the
application has to do is while it's you
know loading a page waiting for a
response back from the server it throws
up the equivalent of a glass pane with
an animation on it the whole reason that
throws up the animation is so that it
tricks the user into thinking that the
application is doing something while
it's waiting for the server to respond
it's nice little UI trick right if the
application looks like it's doing
something it's probably busy processing
something so your users concept'
mentally your users don't realize that
you know it's taking longer than it
actually is when you do the animations
so it's how you can trick them that you
improve performance it's about just
adding animations to because then
they'll watch the animations from 10
seconds so the progress indicator in
Java affects the busy indicators using
the progress indicator and we set up the
the bindings for for it
SEPA sizing and all the rest of it and
then on the next slide is where we
actually configure and put it together
and we bind it so that if the screen is
busy it watches on each controller
there's a property that says whether
that controller is basically blocked
waiting on something and then it
displays that busy the the chasing dots
up on the screen to keep the user
entertained ok the JavaFX implementation
is a little bit different this
implementation of all it's two pieces
one is H yes sir the long day the the
html5 bit of so there's two pieces to it
there's an html5 html5 markup and then
JavaScript code the html5 this is where
I set up each one of those black those
boxes that you saw and then it is
animated using css3
so this is the initial block of css3 and
then the newer css3 stuff for doing the
animation which you know of course uses
some WebKit specific stuff for handling
and you know doing the animations so
there's actually as more code in the
file if you open up and look
so that's that's how you'd animate that
so it's a comparison between the two in
terms of the animation and complexity
it's not necessarily one is better than
the other if you're more familiar with
Java FX and Java the formal one might be
easier this one is just as well now
switching over to html5 tables the
application has to display tables and
rendering HTML table elements does not
count because we need to be able to do
things like sorting and all the rest of
it so in the case of this for this
application I used the jQuery the data
tables to render the content up there
and then so that's what the UI looks
like in the link for this is a standard
jQuery plugin that you can get and the
code for it is fairly straightforward as
you can see my object model for the
screen that's displayed is is created
using JavaScript and then you know blitt
it up onto the screen down below and
what that code is going to do the
framework is going to do is it's going
to generate the divs for the table I
don't believe it actually generates the
table elements because it supports
things like drag and drop switch TRS and
tables don't necessarily support so
underneath the hood plug-in is going to
generate all the code for me for
rendering the table and I can
dynamically create and add a table to
the screen afterwards and handles some
of the basic binding stuff for me as you
can see with a data model I passed it
okay now looking at the Java FX support
for tables so this is what the
equivalent table on the JavaFX side
looks like this example is a little bit
of exercise a little bit fancier than
html5 implementation in that we have you
know that the header cell that's joined
above two of the rows and everything
like that so it's fairly easy to do the
code for that this is a snip-snip shot
of snip of the code for it there's two
ways of doing this you could set it up
in scene builder too and configure all
of the columns however the data model
that this is using isn't using a nice
property the JavaFX property stuff to
implement the data model so it's kind of
a POJO based data model so it's not
using some of the nicer things so that's
why the code is the way it is for this
this is you know basically working with
like a legacy data model and so the it
sets up and initializes things and then
we've got our
for handling you know formatting of the
cells because some of the data elements
that get registered that gets rendered
you know we have to do a little bit of
massaging to make it look nicer for look
nicer for the end user so I mean on the
the JavaScript side of it they would
also have to handle that I didn't show
that code but as you can see I mean you
can do both in render tables in both
cases with the JavaFX stuff is provided
by the platform if you're with html5
stuff you're going to have to go out get
a third party and then look at the
license and verify that it's acceptable
and look at the track history track
record of the project okay now moving on
to server communications both
implementations use rests and WebSockets
like I mentioned earlier the WebSockets
for the application is used because the
application is actually streaming data
back and forth now the JavaFX
application doesn't have access to GPS
you know the laptops don't have we don't
have any API for getting at it so the
web sockets are primarily used for
displaying the progress around the
racecourse that you can see what the
other boats are doing you can't
necessarily feed into it and then the
rest is reused for you know when the
client needs some information give me
the list of races give me the list of
boats etc that's what that's the
function of the rest in there so the
implementations as I mentioned
previously the JavaFX stuff that the API
is for WebSocket and rest aren't part of
Java 8 you have to download them they're
part of Java EE 7 however they have been
standardized and you do have several
different implementations that all have
the same API to choose from so because
I'm familiar with the GlassFish stuff I
picked the WebSocket from tyrus and also
Jersey on the html5 side and I also
grabbed the JSON API from classical a
special reference implementation as well
for the html5 side I did use the native
support that's within the web browser
the xhr and also the native WebSockets
support over there so I don't actually
have to for that stuff it's all built
into the web browser for me it's also
asynchronous so I don't have to do
threading now talking a little bit about
WebSockets as I mentioned before I ran
into trouble with
indexdb support with WebSockets
especially in the mobile devices is not
supported everywhere so as you can see
that line down there is mostly it's you
know everywhere except for upper mini
but for an Apache Cordova application I
don't actually care because it runs
inside of WebKit so Opera Mini doesn't
you know it's only gonna be somebody
that's writing a mobile web application
served up from a server that would be
affected by that however when I noticed
that Android Browser support for the
they just added it recently as of last
October and presently as of October
sorry as of last as of August of this
year only 20% of the phone's had
upgraded to KitKat so that means that
the Cordova application would be
slightly crippled if it was running on a
phone that's a year and a half old and
the user hadn't upgraded it or was
prevented from upgrading it by their
carrier so that's you know
although the web technologies are
pervasive they've also been changing
over time and if you're trying to use
latest stuff like WebSockets you have to
be kind of cognizant of that because
support might be there already on your
latest and greatest phone that you're
working with but it might not have been
on the phone three months ago okay
and then the rest implementation for
this is the client REST API client
jax-rs rest code also using the Java API
for JSON processing and so as you can
see I'm working with Java objects the
entire way through so when I'm working
with jax-rs
especially Jersey I get to work with
Java objects although that it might be
sending JSON back and forth over the
wire it's all Java objects I'm not
actually you know parsing um having to
do much of the parsing myself now on the
html5 side of things this is the
standard code for jQuery this Maps
pretty much if you're using just if
you're using the raw Ajax support this
is pretty close to it I just use it
because it makes an easier Preston from
browsers but codes fairly
straightforward for him for invoking
calls there and getting callbacks
moving on to WebSockets the code for
html5 versus the Java client side looks
basically the same
here's we've got the JavaScript code now
you create this the WebSocket connection
up above as soon as you create that that
object up above it contacts the server
and establishes a bi-directional pipe
we're in the web browser or the phone
can send data to the server at any point
as long as the pic as long as you don't
change the page in the case of an Apache
Cordova application because you're
always on the same page that connection
is always live and then the server at
any point can stream data back to the
client that's the benefit of the
WebSocket stuff so this is the code on
the web browser and as you can see
there's a non message which handles
different message types he basically
uses the command pattern for you know
the different types of messages that
come to come back whether it's a
tracking message a race start message
behaves appropriately the Java code
looks almost the same so this right here
I'm actually creating a WebSocket
container on the client side this is the
WebSocket client API that's now
available with jax-rs to meant for end
you know Java SC applications like a
Java FX application or a server
application if you're using it there but
here I'm creating you know connection to
the thing and then registering my
callbacks and I have basically the same
callbacks as the JavaScript code does
I've got an on message on Aragon clothes
etc so you know it's the same API on
both sides it's fairly easy so moving on
from there and just kind of talking
briefly about layout challenges
JavaFX versus html5 you JavaFX
application the first time I loaded it
up on the phone look at the Apple had
changed the thing so that the battery
indicator would paint over the
application because it's actually
content that doesn't push it down and so
because of the jquery mobile template
that i was using and how it was doing
the layout it was a real pain it took me
several hours and many google searches
to try to find a solution that would
actually work to push the page down and
to make that thing solid up at the top I
think it actually even required to plug
them to fix it so you kind of like trade
ubiquity for being able to get your
application on every device for
debugging and having code for every
device so yes html5 you know it's kind
of like the old job of the
the old joke that people used to have
about Java right once the bug everywhere
html5 you know if anybody says html5
allows you to write once and deploy
everywhere nope that one is still that
one is also right once test everywhere
as well the nice thing with java at
least it was you know you it would be
threatening issues the layouts generally
worked across the different devices with
html5 the phone dimensions you know
especially with like a Cordova
application suddenly get into your
application looked fine on the iPhone
but on that tablet that looks terrible
so now it's you know now you know you
know it used to be you know maybe you
needed Mac and Windows now you need you
know an LG phone a Samsung phone three
different Verte three different iPhones
you know $10,000 worth of hardware in
order to test it and I just would show
this decided to show this off here
although I don't have an analog code for
the Java applications this is the
JavaScript functionality that allows you
to take a picture for instance using the
Apache Cordova stuff so as you can see
here this uses the native capabilities
on the phones to take a picture so the
user would not actually know it's any
different so some of the challenges for
the html5 sides you know if you're
coming from the Java side null versus
undefined
and you don't want to change your mind
midway through writing the application
on what you're going to do different
approaches to defining classes there's
several different approaches for
defining classes out there if you have
multiple developers working on it you
want to make sure that everybody is
consistent the global namespace if you
don't if you declare a very mode but you
put don't forget to put var in front of
it and you're in a method you actually
just created a global variable and so a
lot of people don't know things like
that
also with JavaScript those little braces
so there's there's usually holy wars
about them whether it goes on the same
line or on the next line with JavaScript
there are situations where that actually
does matter and the code will behave
differently so actually the the not
putting it on the separate line is the
one that actually works correctly so if
you're a fan of that one like I am then
you can have fun the IDE coding support
is a challenge because the IDE can't
provide you with enough information to
tell you if you've done something wrong
so we actually have to write to run the
application on the code sample before
where I was in you know setting up the
option pane drop-down I actually had to
run that code in order to verify that it
works
threading webworkers cannot update the
Dom model as I mentioned indexdb when I
initially had the first implementation
of this using indexdb all the operations
with indexdb are asynchronous so that
means that if i want to get the list of
boats out of indexdb i have to pass it a
function that will then update the UI
afterwards
now when you say you're issuing an ajax
request to the server to get the list of
boats which you're then gonna store in
indexdb for if the phone was as the
network connection you've got one
asynchronous call to go to the server to
retrieve the results then you execute so
you have you have a handler that handles
the results for inserting it into the
index DB when it comes back when the
Ajax call returns back then you've got
another asynchronous call to the
database to store it and finally that
finally executes the method that's
actually going to update your UI at the
end so there's not you know that's kind
of it's kind of a nightmare to work with
when you have an asynchronous call that
recalls another asynchronous call and so
forth it's really easy to mess things up
there so you're not having fine-grained
control over threading is definitely a
weakness on the JavaFX development side
the mobile support and also the
interaction with the hardware the tube
is two biggest things that I can
complain about with it and those I mean
although the list for html5 was longer
those two items there are pretty much
bigger especially if she tried to write
code that would talk to a thing so I'm
running about 20 minutes behind right
now so I'm gonna try to speed this up
here so so some common misconceptions
now looking at JavaFX and html5
JavaFX we kind of touched on some of
these but JavaFX is relevant with html5
that's definitely not true i'll scoff FX
does not have good graphics performance
all of these things are generically
false
JavaFX desktop applications are still
alive and kicking
so html5 does not kill them it
definitely does not and html5 is not an
easier way of writing a cross-platform
application it has its own if you're
writing a desktop application using
html5 it's going to be painful there's
no there's no mad there's no silver
bullet in other words legacy
technologies with job effects now when
this will get more important when I
start looking at some of the the ones in
html5 but Java 3d j JM F are dead JavaFX
replaces all of these technologies and
it's cross-platform so it does have
cross-platform 3d support and there's
some sessions over the last couple of
days covering that JavaFX unlike html5
does have cross-platform support for
media codecs I have a slide where I kind
of go over that so some of the key
features of it are we have a retained
graphics mode which is what as SVG is on
the HTML html5 side of things we've got
60 built-in components as compared to
what the 10 or 15 we had to the swing
you've got CSS skinning built-in
animations multi-touch support you've
got a whole bunch of features in there
so one of the main differentiating
features in this one I'll kind of strike
back too especially when talking about
html5 is that the scene graph is at the
core of the API so when you're laying
out a screen of widgets it's actually
using a scene graph underneath the hood
to layout the widgets you're actually
working with scene graph to arrange a
scene graph right so the UI widgets are
nodes just like in any other node and to
see what what I mean by this could take
us as write a small little hello world
swing application and try to get it so
you can zoom in and zoom out and spin a
button a J button around and if you can
do that within you know a couple of
hours then good luck you know your let
me know and it has built-in support for
animation you can apply transformations
you know to that graph so it can have a
button that partakes in a you know that
gets transformed etc so looking at html5
some of the major features of html5 are
the 2d canvas which is just you know a
2d drawing area it's not retained mode
its immediate mode WebGL which everybody
thinks is part of each
five however it is not part of html5 and
it is not supported everywhere Safari I
think you have to enable it explicitly
I don't believe unless they change it
with iOS 8 and I Oh s do not support
WebGL so some of the other major
features are css3 support for animation
of it's very rudimentary WebSockets
which we already covered data storage
you know such as file system access
index DB and some of the other things
that covered earlier I've touched on
this before but html5 you know unlike
the traditional web applications you
know that when people talk about html5
what they're really meaning is like the
single page application I mean nobody
gets excited you know I mean the the big
news is not that we added a bunch of new
attributes so you can make your static
content look better the big thing with
html5 is that you can actually write
applications with it and you can
actually sell those applications through
app stores so the application that was
written for this comparison is a hybrid
application so it kind of demonstrates
with what's on the slide here in terms
of the things so now we'll move on to
the technical comparison between the
tool so the one thing I would say when
comparing html5 to JavaFX is that html5
is amorphous there are a million
JavaScript libraries out there there are
new JavaScript libraries that are coming
out every week and there's there our
script libraries that are slowly falling
off and nobody's using anymore so you
know if I tried to pick out a feature
that Java FX can do this in html5 can't
somebody's gonna somebody and they
always have pointed out a JavaScript
library that does exactly that
so I never view it as you know something
like that so you know all the exist
additional functionality is provided by
external frameworks Java FX is fixed and
has a course of the features so that you
know that they're always you're you're
always there you don't have to deal with
licenses from the different
implementations in terms of html5
limitations the JavaScript language
however the JavaScript language is
changing there's ekam a script six which
I believe iOS implements and there's a
bunch
language changes with it so if you think
that javascript has been static since
you know 1999 no it has not been there's
been additional cell language there's
now ekam a script six the last revision
to the language I believe was in 2009
ekam a script six is either finalized or
close to being finalized and there's
some support already in the browsers for
doing it so just because you remember
you know writing JavaScript form
validations back in the late 90s
JavaScript has moved forward some of the
other imitations of the has is and
support for currencies time zone
detection you know the number of times I
use I will be like scheduling a meeting
I'm on the East Coast I'm scheduling
something on the west coast or vice
versa it always seems to pick the wrong
timezone because there's no way for to
detect unless you look at the GPS
coordinates of the web browser and
correlate that with time zones there's
no way to figure out what time zone the
users actually in and then one of the
biggest drawbacks to this patent
infringement and IP theft that if your
application is html5 application then it
is not compiled anybody can look at the
source code and they can look at your
source code and see if you've a you know
violated any patents so depending upon
the type of application you're writing
that may or may not be an issue
so if you've implemented some type of
new image processing algorithm using
JavaScript you know somebody you know
before they'd have to you know you could
decompile an application but figuring
out exactly what I'd do it would be hard
with everything as plain text you can
look at it and say hey you lifted that
from that other site or that looks
strangely like something else so it
makes it much easier to do that with
Java FX the biggest thing is the lack of
mobile strategy I was trying to get I
was trying to download this the other
day because I was determined that I was
going to try to run the demo using a
robo VM when I saw that that was
featured on the keynote slides Sunday
but Robo VM allows you to run your Java
FX application I guess on the iPhone and
they have documentation up there as to
how to do it and then kind of moving on
to deployment strategies with the
application html5 with these these store
things you can now deploy them anywhere
whereas the JavaFX stuff unless you're
using the Robo VM that's why I have a
kind of circle than a dot there or Java
Webster on the web browser
those are the two holes than that
looking at the html5 support across
different web browsers you can see here
that as support is not entire entirely
set in Firefox or Safari and then talk
to moving on to rendering the HTML
canvas is a 2d drawing service much like
Java 2d or Mac OS quartz and I like to
poke fun out of when people would get
really excited about the canvas support
and say yeah it's just like quick draw
on the Mac in 1984 we finally don't have
to draw everything with divs errs I
think there's a really interesting I
think was in the a1 of the ACM
publications where they used divs to
draw triangles and then they could build
anything off of that they've all got a
complete image processing pipeline using
it was kind of interesting html5 canvas
is immediate mode JavaFX uses retain
mode which means that you can scale and
apply transformations to it on the
JavaFX side which you can't necessarily
do on the canvas side the canvas does
not support hit detection you have to do
that yourself and then kind of like
lining up the two technologies the
JavaFX scene graph is analogous to the
html5 SVG canvas on the FX side is the
canvas immediate mode thing for Java FX
is equivalent to the canvas in html5 and
similarity is on the 2d canvas versus
HTML Java FX versus html5 you know some
media both our media mode rendering we
have almost the exact same API the html5
side lacks support for filling polygons
at least at this time and then to kind
of drive the point home with the
difference between the two api's and I'm
not you know one technology is not
necessarily both have pluses and minuses
and you can do awesome things with both
of them but the feature set with Java FX
is fully integrated whereas that's not
necessarily the case with html5 so say
you want to draw on a video that's
playing with html5 you would have your
canvas and then you have your video and
you try to use you know absolute
positioning to get them to line up so
that you could draw over the other one
right whereas with Java FX you have no
you know one node would sit on top but
the other node etc so the drive FX
provides a much more natural thing you
don't have to worry about different
behaviors between the different web
browsers moving on to html5 in Java is
the 2d vector support I had to do a
double take because I remember when SVG
seemed to be hot back in 2003 and it's
back again and they're actually it's
development on but is proceeding again
it's kind of like we had a lull in the
mid 2000s with HTML with all the
technologies where everything kind of
slowed down we've sped back up so you
can use you can embed it using embed
object and iframe multiple tools can
export SVG and it's you can actually
render this in and Java effects as I'll
get to in a second and then finally just
moving on to controls here
JavaFX as we saw before has great
support for bindings if you're doing
that with html5 you're gonna have to get
your own binding framework as you saw in
the code when I compared the two
applications earlier html5 lacks a
windowing API so although you can you
know get libraries that will you know
throw a lot dialogues those are actually
just divs that are being placed on top
of something else and JavaFX controls
our nodes in the scene graph table
support we touched on previously this is
just driving at the point home that
there's no grid native grid support
really in html5 unless you count that
table which is not really what most
people think of when they think of a
data grid because you can't necessarily
drag and drop those things the web
browsers can lock them down okay moving
on to multimedia support video codec
support is determined primarily by
patents so Oracle has licensed the
patents for JavaFX
html5 has no supports no VD audio video
codecs by default it's the web browsers
job to do that and just as an FYI the
JavaFX stuff uses GStreamer underneath
the hood this is I'm not going to go
through this Ignasi impart codecs that
are supported by the different you can
see the ones that JavaFX supports when
Java X supports it supports across all
platforms html5 it does
which means that you're going to either
have to have two copies of your video or
do something else that's why I believe
CNN still uses flash for their videos
now interestingly looking at both of
them both of them have a major flaw in
terms of their video support neither one
of them allows you to actually get at
the individual video frames so whether
you're using Java FX or html5 you're not
gonna be able to write your video
editing application because the api's
aren't there you're gonna have to use
something else in order to do that okay
and just similar type of graphic for
audio that list also changes that
changes on a regular basis looking at
animation html5 animation is primitive
you'd have to use something else like
the tween j/s library in order to do the
animation correctly and the reason why
and I'll get to that in a second is that
this is what html5 provides for you
provides a nice little callback so you
know call me back every 10 seconds
JavaFX has much more complex support for
building up time frames and key frames
and all the rest of it so that comes out
of the box with Java with Java FX you
could you'd have to use as I mentioned
before you'd have to use a JavaScript
library to fill in those gaps
moving on to 3d support Java FX 8 has
support for 3d and has some built-in
primitives for you so it provides the
basics of the scene graph and I like to
say that Java effects 3d is 3d without
the overhead now WebGL on the other hand
is basically low-level OpenGL so you
really don't have any primitives to work
with you're given a triangle to start
with so unless you're using an external
library like which ones I have here
three Jas seemed ijs or one of these
right here you're gonna have to dig out
your college textbook and start
tessellating that triangle because all
you have is a triangle to start with so
Java effects 3d is providing a lot for
you depending upon so you know if you
need a same type of function now they
say we're writing a CAD program you you
know you'd like OpenGL whereas Java 3d
would be too high level but if you're
writing an application where you just
want to present the scene to somebody
Java 3d is the better solution for that
so if I wanted to do like an add-on to
the the
failing application to make it so you
could you know simulate the boats going
around the thing and use the Excel you
know the the tilt things so I could you
know show you the tilt of the boat and
the speed of the wind you know the speed
of the boat with the tilts and
everything like that you know I could do
that easily with Java 3d WebGL would be
require a lot of work and just some more
stats on in terms of you know built in
shapes and shading and with that I'd
like to like to point out that although
Java FX has more primitives generally
you're going to use another application
like blender or you're going to export
something from SolidWorks you're not
gonna render you know you're not going
to come up with the you know an
application that allows you to walk
through this hotel by programming you
know rectangles and try to place them
you're gonna use a designer application
have a artist do that because you you
know so although that's listed here as a
benefit of JavaFX is not really because
you'd use another application and
importer for doing that one of the
biggest things if you're dealing with a
large application has a Java FX with a
JVM it's well understood how you can
tune it right so there's other sessions
here that go over tuning the JVM you
know you know premature promotion of
objects you know you can see what's
going on with a garbage collector and
you can tune it with JavaScript you
can't tell the web browser
you know jeez you know you need to i
need the the the what's at the eden heap
to be large you know the the first
generation to have a larger size and so
forth like that you can't configure it
so you're pretty much limited to what
the web browser provides now chrome does
provide some nice tools for monitoring
performance and kind of digging in more
depth but you don't have flags and you
can't see what's actually going on
underneath the hood and so we're almost
out of time so I'm gonna hop through
with the integration quickly so the the
CSS support and JavaFX
looks looks nice in here you can
actually use CSS to skin your JavaFX UI
however it's not the same CSS as you'd
use for a web application or a mobile
web application or even the the Apache
Cordova application when I pinch this at
work I said yeah if we go to Java FX
we'll be able to use CSS and I'll have
the same look and feel as the graphics
designers for our website nope
I was wrong so I kind of got caught
there though I haven't mentioned that so
as you can see on the previous slide
this is what the H the CSS regular CSS
looks like this is what the FX CSS looks
like and so all of these have - FX in
front of them and I never quite got them
to look the same and so just another
comparison between the two of I'm
showing you how the properties differ
and what the line that is just some
simple examples and then the web view
this is one of the reasons for using how
you can integrate the two technologies
as Java FX has that html5 component and
that's actually the the chrome rendering
engine underneath the hood and you can
actually talk back and forth to it so in
the case of this application I can be
receiving callbacks I can amuse the the
WebSocket code in Java and then execute
JavaScript code in that that in that
webview so I can actually talk the JVM I
can communicate back and forth the
JavaScript code in the webview can talk
to the Java code and the Java code can
talk to the JavaScript code and called
methods now this slide right here you
can actually do even more than that with
the integration you can actually there's
a secret debugging protocol underneath
the hood there's some google docs up
explaining how this works but this
allows you to basically you know change
the you know you can change the user
agents you can enable wot logging so
this this code right here enables
counseling so if you've ever used the
JavaFX webview you can actually get
those console dot log messages back
because you know right now you might
just if there's an error in your page
you just shows up as white but you can
use that for building more integrated
solutions so I will hop along here this
is some SVG just showing you that SVG
works with it you can actually read
render SVG content and your JavaFX
application so you can take the html5
SVG yep and render it and they're
telling me that I have to end so this is
the conclusion it's really nice and
sweet there is no winner between the two
of them both technologies have pluses
and minuses depending upon what you're
doing and I have one more session ahead
of the session this morning on hybrid
mobile development one more on
EJ be best practices you can reach my
via email the code will be up on my
github account hopefully later tonight
when I get back to the hotel and fix
that button so thank you very much I
guess we're out of time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>