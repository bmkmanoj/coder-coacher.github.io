<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JSF 2.2 in Action | Coder Coacher - Coaching Coders</title><meta content="JSF 2.2 in Action - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>JSF 2.2 in Action</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/sFWR2SHUfAo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome everyone this session is called
JSF 2.2 in action if you if you didn't
hear me earlier I said if you if you saw
my I did a two hour session on Monday
morning on JSF to point to deep dive
this is a subset of that so if you went
to that one this might be kind of
redundant but if you didn't then this is
a good place to be so my name is Kido I
am a principal consultant virtua it's my
company we do a training consulting and
mentoring around JSF Java EE life for a
portlet and related technologies I can't
read the slides on the screen okay I'm
also the official u.s. primefaces
partner so we do a lot of primefaces
work and we really sell a prime C prime
face of support as well I wrote a book a
long time ago Commons anyone I read this
book who didn't was not at a previous
session anybody okay one more person
okay cool if this book is like 10 years
old so it's kind of out of date and I
never updated it I ran a website called
JSF Central which is a good place to go
to find some articles about JSF and also
every few months I do an interview
podcast and also transcript with someone
in the industry the class person with
Shh Meltzer who does the ADF face of the
rich client or leads the oracle ADF
tools division so so that's a good
little talk I'm also the co-host of the
enterprise Java newscast which is a
podcast that comes out every couple
months about all things related to JSF
Java EE Enterprise Development me do
some Scala stuff so it's me and a couple
other guys and we talked about we'd go
through some headlines like new releases
but we also talked about some different
topics so if you're into podcast you
check that out Enterprise Japanese comm
it's also in iTunes I also speak at lots
of conference and I'm a member of the
JSF expert group and the portlet expert
group so before I get into the details
how many people here are not using JSF
ok so there's a few of you ok and how
many people are using JSF
one point two okay Jess F 1.1 chu man
sorry um JSF 2.0 okay 2.1 anybody any
money using 2.2 yet okay so a few of you
alright cool so I'll just mention this
quickly for the few new people in the
audience JSF is a server-side UI
component framework it's been out for
around 10 years or so way before a
client-side development was really
popular so so back then it made a lot of
sense and it still makes sense today in
some situations to have a representation
of the page that you're working with the
actual UI components on the server okay
and when I say UI component I'm talking
about something like a data table or a
tab control or a tree or a toolbar you
know all sorts of visual components that
are much more powerful and rich than
what you get out of the browser by
default
okay so JSF has a server-side UI
component framework so every component
has a server-side counterpart but it
also has all these components also
render themselves to the client as HTML
CSS JavaScript as well it has a very
powerful MVC controller and this is
something that I think those little
understated is that there's a lot of
power in sort of the the application
side of JSF okay there's a very elegant
programming model with managed beans
that can back different pages there's
very elegant binding from for the data
on your in your browser from the server
and there's lots of other great
facilities to build your application in
JSF and all of course integration with
all java ee there's also a really nice
server-side templating framework called
facelets this lets you basically compose
your views that have different sections
and then you know very easily have you
know a header or footer or different
sections of your page and we'll see some
some enhancements along those lines as
well
and there's a JSF has been part of a
Java EE since pretty much I think the
very first release was not but pretty
much after that it has been and JSF 2.2
is part of Java EE 7 so it ships with
Java EE 7 however if you're running an
older container you can still use it so
if you're using Java EE 6 you can use it
really the only dependency is servlet
3.0 ok so if you're using just a plain
vanilla Tomcat you have to have at least
sort of a 3.0 to use it and if you're
running an older container you know you
should be able to use JSF 2.2 as long as
you figure out the proper way to add a
new runtime to your your App server so
there are a couple things that use Java
EE 7 features so JSONP is one of the API
is in Java EE 7 and JSF 2 uses that but
it's the still work if you're on an
older container so one of the key things
about JSF is of course components so
it's a way to rapidly build an
application using components that render
HTML CSS and JavaScript and having Java
as your core programming language so
that's really the sweet spot for JSF and
we talked about those things ok so
what's new in JSF 2.2 JSF 2.2 came out
about about a year and a half ago or so
well the less than that so as things
often move in the in the corporate space
you know now it's slowly gaining
adoption because things have to be out
for about a year or so before it really
starts picking up in terms of larger
enterprises and one of the one of the
nicest new features of JSF 2.2 is the
HTML 5 friendly markup so this is the
ability to create pages using more more
actual HTML markup as opposed to JSF
tags and we'll talk about some of those
features and the main thing is what we
call pass-through attributes and
elements which I'll go into in more
detail there's also a new feature called
faces flows which lets you
organize a set of pages using sort of a
state machine sort of model so we'll
talk about that there is cross-site
request forgery protection or CSRF so
this is just an security enhancement
there's the ability to load facelets via
a resource handler which is just a sort
of sort of a cleanup of the way the
internals of JSF work which we'll talk
about and there's also a file upload
component native to the JSF core as
opposed to having to use file upload
through a third-party library okay and
lastly there is resource contracts
resource library contracts or multi
templating this is one of my favorite
features just lets you sort of swap out
facelet templates and other resources
sort of dynamically or statically or
basically however you want in your
application so gives you a lot of
flexibility for changing the look and
feel of your application as well so
let's talk about html5 friendly markup
so basically the the key impetus for
this was to basically make it easy to
use a JSF component on a page without
having to rewrite the component so you
know html5 is coming in with all these
new attributes right and we wanted a way
to expose those attributes to developers
without actually requiring that
component to be rewritten or to be
updated okay so with so html5 friendly
markup is largely about integrating with
a lot of the new html5 features you can
use pure HTML and then you can use
special attributes to indicate JSF
components so here's an example of
actually I don't want to show this I
think I'm gonna actually um I'll show
you the actual demo of that in a second
alright so there's two things there's
pass-through attributes and elements so
these are things which are passed
through to the browser without being
really interpreted by JSF you can use LX
Russians but other than that JSF is not
really doing anything special with them
okay
and they're usually rendered on the
topmost element of the component so for
example if you have a component that you
know it's one tag but it renders you
know a div and stuff inside the div then
a patch-through attribute would only
apply to the top-level div that's being
rendered so html5 is actually the
default in JSF 2.2 so if whenever a page
is rendered it's gonna send the HTML
doctype at the top which is the default
for html5 okay so if you upgrade the JSF
2.2 and for some reason you don't want
that you have to actually turn it off
it's in just a context parameter okay so
by default we're doing html5 and of
course it doesn't mean that the page
won't load in an older browser the older
browsers one say Oh html5 and not do it
they'll still render the page okay so
that's how you can turn it off if you
have to and faces config
so this also passed through so this this
is the first thing patched through
attributes okay so this is an example of
a JSF 2.2 page okay you notice there's a
couple of you namespaces there's a
couple things that are interesting here
number one you notice this xmlns part
here okay so instead of having java.com
since sun doesn't actually exist anymore
the new namespaces are all XML and NS
JCP org and then pretty much JSF the old
ones will still work your applications
won't break but we encourage you to use
the newer ones but there's also two new
or there's a new name space to use
called pass-through okay and so what you
can do with this is you can use them
like this so this is a normal HTML
component if you look at the attributes
defined on the facelet tag for select
one menu there is not an auto focus
attribute out of focus is an html5
feature right however you can very
easily just say PT : auto auto focus or
whatever prefix you choose here
something examples have P but that if
you're using prime faces that doesn't
work very well because you know many
people use P for prime faces so anyways
so you say PT auto focus equals true so
that means this attribute is gonna be
sent through to the browser on this
topmost element here when it's rendered
okay this is these are other examples of
ways to use patch through attributes as
well so if you don't want to do it this
way you could just say AF patch through
attribute a little more verbose right
you could also use an expression here if
you wanted to but here we're using an
expression and here we're saying we want
to pass there an attribute called data
info okay how many people here know
about html5 data elements or data
attributes I should say okay so a few
people so data attributes are sort of
arbitrary attributes you can add to your
HTML elements that then are usually
consumed by JavaScript to say more about
what's going on okay and this is the
same thing as basically saying let me
send pass through attributes but we're
grabbing a collection of them from a
backing beam okay so these are three
different ways you can do patch through
attributes and again the purpose of this
is basically to say okay well
I know I'm using an ordinary JSF
component but I want to add some of
these html5 attributes because you know
I'm using them on a client somewhere or
I just want the browser to use them so
auto focus is really a browser thing you
know it means is that that component
look at focus right so there's another
thing called patch through elements and
patch through elements is sort of the
inverse a patch through active roots
okay so in this example in the past
would attribute example we have the the
standard select menu tag which is just a
drop-down right and this one this is not
just like my menu but this is a input
control and here what we're doing is
instead of using the standard JSF tag
we're actually using the standard HTML
tag we're just using input right and
what we're doing here is we're just
using the normal attributes but what
we're saying is by using this JSF colon
ID we're saying hey this is a JSF
component so upon post back it'll be
processed as a normal JSF input control
right but their rendering is actually
what you have here there's no special
rendering going on okay so this gives
you more control over the mark up
because you specified the mark-up and
then you just tell JSF exactly which
attributes need to be processed in the
JSF way right so the ID here this is
going to be a JSF ID right here if this
is an involved but this ensures that we
have server-side validation for the
field being required and this is of
course is the JSF value to bind its to
some property in the application okay so
this is an example of pasture at
elements so let's let's look into this
little in a little more detail
so here I have a JSF tu application and
our days have 2.2 excuse me okay
looks pretty standard nothing really
special going on there's some templates
they're all a lot of XHTML facelet pages
there's a very there's a faces config
for navigation of course you don't have
to have faces config and this
application is just simple well let's
first talk about the login page so what
we want to do is make this simple login
page right so if we look at the login
page it looks like this okay and you see
that it is it has a doctype HTML
although this would be rendered
automatically for you and then we have a
head element alright and what I want to
do here I'm actually gonna just get rid
of this for a second here
well we'll come back to the actual
content in a second but I just want to
show something here alright so if I have
a little page and I say you know
and let's say I want to put an input
control right here okay very complicated
page right it's put an input control on
the page okay so Wow voila
I have an individual right very exciting
all right so I used the the you know
input element right so if I were to look
at the actually I do want to put
something else here forgot one important
Pete piece here anyone use the UI debug
component before
very handy yet component whoops okay so
you a debug gives me a little bit of
information about the actual component
tree right and this has been in JSS and
GSF too
so this is the component tree that I get
so basically you see I've got the UI
view route and then I've got my input
text and these ones that are in gray
they're they're essentially transient
markup right they don't have any state
and if you have a thousand people
looking at it though there's only one
copy of them essentially that that's
that's managing memory okay so you see
my input control is just transient mark
up the UI debug component is there
because I put on the page four for
debugging right so this is my component
tree in it and of course every component
tree has the UI view root which is the
root okay so let's say I say all right
well really I do want this to be a JSF
component
okay
all right so it looks the same right but
then if I look at the component tree
it's a little bit different now right so
now I actually make this a little bigger
now I have the in actual HTML and put
text component right so now actually
because just because I put JSF : ID in
there now I have an actual server-side
representation okay which can let me do
things so we know if I need to on the
server okay you know I haven't tried it
with specifically with the primefaces
components it's not if I it probably
might work with some of the input
controls but usually if you're going to
use a part in faces input controls you
want all of their HTML and CSS anyways
because that's kind of the whole point
it's certainly not going to work with a
data table or anything because entirely
different beast okay so so that's sort
of the difference they're just probably
putting JSF : idea now turn this into a
JSF component and what that means is
that on post back it'll be processed by
this component but the rendering is
still handled by the markup that I have
in the page okay so let go and put my
page back here
okay so if we look at this little more
closely usually in a JSF page we want to
have the H the head and body be JSF
components so that the we can put
resources in the head of the page right
so I have an ID on the head and ID on
the body right this is going to be
transient here I'm still using the JSF
resource handling right but I'm
specifying the name and library so it
loads it from a JSF resource library
okay
and down here I have a form but I use
JSF ID because I want to be a JSF form
okay and then I have some divs in here
okay and basically I've got two
different versions of the same input
control notice for the labels I'm just
using a regular HTML element I'm not
even bothering with the JSF component
just for a label okay
this P messages this is a parent faces
messages it works just like normal so I
can mix and match two styles right and
this is that first example I showed you
where we have a standard JSF component
right and then when we want pass through
attributes we use the PT to pass the
attributes through okay
and I'm also passing using this to pass
through a single attribute just to show
how it's done and I also have a
validator on there so even though it is
well this is what it is so host I've got
a validator here as well okay now I've
got another example down here which is
the other approach right where we have
the actual input control using the input
element and then we're making it into a
JSF component by saying Jess f : ID and
then we specify the value okay and and
and then by the same token down here we
have a button alright so the render is
going to be specified by what we what we
do here but we say JSF actions so that
it actually goes and calls a method
vacuum beam okay so what this allows me
to do is take advantage of something
html5 features right so one of the
things
html5 has if you notice this a PT
pattern here
Mike this is actually a regular
expression that I can use for
validations so in html5 you can use some
validation on the client without
JavaScript okay so if I look at this
page okay and I type in you know
something that's too short right I hit
submit and lo and behold what does it
say it says please match the requested
format okay and then this part here this
field must be at least five characters
long this is actually specifying the
title attribute okay so this is
basically chrome doing client-side
validation okay and by the same token if
I type in you know something here and
then I'll leave this one blank right I
get another validation error singing
must be five characters long okay but
also it's saying please fill out this
field meaning that it it also needs to
be it's also required as well okay so if
I go back to clips the reason that's
happening is because not only did i do
PT pattern but I also did PT required so
I so html5 has required attributes on
the input controls too so I'm using the
html5 required attribute so the browser
would do that work as well now what I
can also do is you know Chrome has
really good support for html5 and Safari
has pretty good support too however the
html5 form validation is turned off in
Safari by default so I take the same
page
okay and I leave them both blank you
know what's happening now is I'm
actually getting the primefaces
amazing I'm getting the normal JSF
server-side validation with the
primefaces P messages error message okay
because what's happening here is the
browser isn't doing anything it doesn't
care about the required attribute or the
pattern attributed or whatever so it's
going to the server like normal and
normal JSF server-side validation is
taking place right and that's happening
because in here I also specified the the
JSF validate or two and this would also
work the same if you're using bean
validation or something else excuse me
for validation as well okay so the upper
thing that I'm doing is in this page you
noticed that I am using divs here for
layout instead of like a panel grid okay
so one of the things that's become more
popular these days are very popular is
more of a responsive UI design right and
all that means is that the layout of the
page can adapt depending on the size of
the page okay now if you're using an old
standard age panel grid what you're
going to get is a big table which will
not be responsive right so a lot of
there's several different modern
frameworks to do a grid-based layout
bootstrap is one of them and it turns
out the prime basis is actually added in
grid library as well okay but it works
just like the bootstrap one or any
standard one so the idea here is that I
have included the grid CSS which is a
included with primefaces 5 let's see I
think it might be 5.1 a k-mer is 5 or
5.1 there is actually a 5.1 rc1 is out
so so here I specify this grid library
ok and what it's going to do is look for
these special CSS selectors so all the
grid you know our responsive grid
libraries work this way they look for
certain selectors ok so here I've got
div class equals UI grid UI grid
responsive so this is saying
this is going to be a grid CSS grid and
it's responsive and I can specify the
layout using UI grid call one you know
so these are these are specific to this
grid library but it's basically saying
lay it out you know four four four
different columns okay or eight or
whatever so that's how this is laid out
instead of using a panel grid and what
that means is I get responsive behavior
so if I make it smaller it still works
you know I can make it larger etc so so
that's one of the benefits you get if
you start using more you know html5 div
sort of style things as well now it's
worthwhile to say that components Suites
like prime face or suits are also
starting to integrate these features so
the grid CSS library is now used in some
of their components probably used more
as time goes on but this is one of the
things that can happen once you start
what you can one of things you can do
once you start doing more with the html5
stuff so this that is the html5 said I'm
going demo any questions on that so far
all right so another feature which which
i think is a great addition is stateless
views so basically a deal is that any
given view can be marked as stateless
using this transient attribute and what
that means is that a JSF is not going to
maintain any state for that page per
user okay so um one of the one of the
things you can run into with JSF is
having very very large views and the
view has to mean state that JSF has to
maintain view state for each user
because they're the ones interacting
with it right so by using a transient
view you don't have to have JSF maintain
that state okay so it works really well
for any sort of read-only page you can
make a transient and also it can work
well for some pages with input controls
as long as you maintain in the state and
in your model or in your model or
controller and you're backing beam you
should be okay okay so this is basically
in a performance enhancement because a
transient view is only created once and
then share it among multiple requests
okay the caveat is that doesn't work
with view scope beans right so since
there's no state it's not gonna really
wrote with a views views coat being view
scope bean will turn into a request
scope to bean so keep that in mind if
you try to use transient views so
another new feature is phases flows and
phases flows allows you to group sets of
views together in logical navigation
paths so no one here ever used a spring
webflow before only one person huh what
about Apache my face is Cody anybody so
one person
okay so faceless flows is very heavily
influenced by Spring web flow and also
ADF faces cash flows anybody use that so
a couple people okay and also by my own
faces Cody so they all sort of had
similar sort of functionality
so you can think of a flow like a job a
method right it's something you call and
then you can pass parameters okay
and also when the execution of the
method ends you can get parameters back
now what happens in the execution of
that method in this case would be more
like you know going through a wizard or
a shopping cart or some set of states
where you actually want to have some
control about what's happening in
between those states and you also want
to keep some state during that flow okay
so you can call them basically inner
flow from anywhere and then into in an
application just by specifying an
outcome that matches the name of the
flow okay
and as I said before you can accept
input parameters and return values so
basically what's nice about a flow is
that it's sort of an internal it's like
an interface contract right it's
basically saying all right when when I
enter into this particular flow I'm you
know this is I hate to send these
parameters maybe I get something back
but I don't really care what happens in
the middle right and what this means is
that you can actually have let's have
sort of reusable parts of your
application right so you could have a
flow that you could put in a jar file
and then use it in different
applications okay
and all the application cares about is
how it needs to call the flow and what
it gets back at the end okay in order to
facilitate this there is a new phases
flow scope that you can use while you're
inside of a flow and there's the flow
scope annotation to go with it and
notice it says CDI annotation okay
so how many people here are not using
CDI ok so basically what's happening and
this is generally the direction of Java
EE is pretty much more and more stuff is
going to require CDI okay so the phases
flow feature is really only available in
sight with CDI if you're using managed
beans
then you might be able to get some of it
to work if you if you have part of your
application using a CDI but there isn't
a JSF managed being annotation it's only
CDI okay so um navigation is can be
cannot move between nodes would end so
node doesn't necessarily have to be a
view okay
and there's a couple different types of
nodes one is the view another is a
method call okay another is a switch
which gives you a set of expressions
that something can be that can be
evaluated and whichever one returns true
is the one that gets some executed and
then also a flow call which means you
can have another flow so you can have
sub floats as well there's also a flow
or term which is basically just a state
that ends the flow okay so as I said
before you can have packaged reusable
fragments which is lovely it also
depends on a new feature called client
window so JSF now has the ability to
notice that you're actually in different
tabs in the browser so there's actually
a client window API and faces flow that
requires that and since Ted before a
require CDI you can also packaged up
flows and jar files which is how we get
to that whole reusability level um so
this is an example of a structure of a
jar file with faces flows and we have
beans that XML for CDI this just means
that it's a CDI archive and then inside
of our meta and directory we have a
flows directory and then we have the
name of the flow so this could be like
you know my flow or whatever and then
you can specify the flow and XML if you
want to but you can also specify it in
Java which is nice so here we have we
can put the name of the flow as well and
they make it put whatever files we want
whatever XHTML files you want to include
and any Java classes that are required
as well so you can package everything up
in a jar BOM so here's an example of the
Java flow definition for a four phases
flow
and what we're using here is the CDI
produces annotation which basically is
sort of saying this is a factory method
essentially right so basically what's
gonna happen is when JSF starts up its
going to look for classes that use this
annotation and then it's going to use
this to basically build the flows that
it has to work with and what's happening
here is we are creating a flow using
code okay using this flow builder here
and we specify the ID we can specify a
different node so this is specifying a
view node or marking as the start of the
of the flow and then we're also creating
a return node as well and then giving it
an outcome was just an expression
okay we're also are specifying a couple
of inbound parameters as well okay so
basically what's going to happen is when
those parameters when those parameters
are set it set on the flow we're gonna
set those properties on the view scope I
mean on the flow scope excuse me
so I'm here's another one this is a call
node okay so basically this is going to
make a call and we're setting to output
two parameters that are gonna be sent
out from this call so basically what's
gonna happen is when this is when this
flow is called it's going to return
these two parameters okay and then we
return the flow here so this is the job
a way to do it you can also do it in XML
okay so this is a face of config file
but you would call it like that - flow
dat XML or whatever in your jar file or
in your actual web application and here
we have a flow definition the ID here
this is the return node okay these are
the inbound parameters that we want to
support the same things as we saw before
and this is that another that flow call
that we saw that makes a reference to
another flow so this actually is really
going to be calling another flow so sort
of a nested flow
example okay so this is an example of an
XML flow so again this really is great
for situations where you know you have
multiple views and you want to basically
group them together and have some state
that goes in between them so wizard is
of course an excellent example okay okay
so that space is flows another one is a
cross-site request forgery this is
actually I think from Wikipedia yeah so
it's also known as a one-click attack or
session writing and abbreviated as CSRF
and it's a type of malicious exploit of
a website where by unauthorized commands
are transmitted from a user that with
the website trust so it's sort of like
sort of like hijacking the session so to
speak this actually came up with one of
my clients say that they did a security
audit of the site and they're like I see
it you know doesn't match CSRF so we
started talking about what we can do and
then to make sure that it actually
handles the situation so basically the
the benefit of JSF is that our one of
the benefits is that it does the there's
a lot of posts which actually happens to
already be secured the way it's done in
JSF so when you post a JSF form back it
has a view state element a form field
okay which is hidden form field and that
basically is what JSF uses to match the
current view on the server okay and it's
encrypted and you really can't hear they
can't intercept it okay but the problem
comes with get requests right so with
the get requests you don't have that
built in in JSF so the way they handle
they'll handle that is by using the
protected view element and the
navigation rules so if you want to use a
CSRF stuff just put protected view in
front of get requests and of course this
is really the only going to be useful in
you know the URLs that are internal
alright you don't want to put protective
view on your login page if you're coming
because then they might be coming from
an external site right so basically what
protected view ensures is that the the
crisis coming from the same person who
was already logged into the session
essentially okay okay so another feature
that I like is the loading facelets the
resource handler how many people have
seen the or used the facelets a resource
resolver before anybody heard of that
class so internally what happens when
you request a facelet in older versions
of JSF instead we use this resource
resolver class which would then go and
get the facelet and so if you want to
load your face light from a Java file or
something you just override and you
implement it your own version of the
class you can grab her foreign jar file
or from wherever you want and but what
was a little clunky about it is that
that API was very different than the API
used for resolving resources like style
sheets or images etc okay so basically
one basically what we've done is sort of
we've gone through and consolidated
everything so in JSF 2.2 now we can
actually use the resource resolved or
I'm sort of resource handler for
everything essentially for facelets for
style sheets for images etc so so it's
just just a nice sort of cleanup of the
API there's also a file upload component
this is something that they wanting to
do for a long time but sort of it didn't
support it very well at least so file
uploads is supporting struggle at three
and it's also supported in JSF 2.2 most
third-party suites component suites have
some sort of file upload anyway so it's
not that big of a deal but there is a
basic file upload feature it doesn't do
it does Ajax and non Ajax use cases but
it doesn't do like multi file upload
it's not super fancy but it is a basic
file upload mechanism and it looks kind
of like this called input file what you
get back is a collection of parts which
is the servlet 3 API for dealing with
multi-part requests or responses I
should say
okay so this is probably one of my
favorite features called resource
library contracts or multi templating I
think the name should have been multi
templating in the expert group there was
somebody who came up with this idea
multi templating you know having sort of
different site layouts and everything
and what we implemented isn't as
complete as what he had in mind so at
the spec lead he wanted to change the
name to something more boring I guess so
we didn't use the name multi templating
because that was the other guy's name
but I think multi templating works just
fine but it's called resource library
contracts in the literature
so essentially what it does is allows
you to sort of template your site okay
so this is we're not really talking
about themes for components here talking
more about the layout of your actual
pages okay so you can change like the
head of the sidebar content area footer
whatever you want to do however you want
to organize things and you can do this
in different ways you can package it as
a draw file well you don't have to but
you can and doing so it gives you lots
of flexibility as well because you could
just have a layout that you have as a
jar file and using different
applications or layout for one client
things like that and another very good
use for it is I Maps with Park client
customizations so if you have a layout
or different resources that change per
client you can do that using resource
library contracts okay you inside of a
jar file the layouts sort of like this
you have this directory contracts you
can have as many layouts as you want and
just just you just have to put this
marker job X faces contract that XML in
there to say this is this directory is a
contract called this name so the name it
goes is basically defined by the
directory name so this is saying this is
these files are part of the contract for
site layout these files are part of the
contract for sub-site layout okay
so what's nice is the the actual
templates slow so if we look at all of
these files right by default these are
applied globally so so if you just put
one resource library contract in the
class path it'll be global okay but you
can also specify how you want it to be
applied so you can say all right so only
for this particular path I would apply
want to apply this resource library
contract okay so here we're saying for
the users we want to use the user
contract so which might have different
CSS different you know different facelet
templates etc okay and saying here for
everything else essentially we want to
use the default contract which is just
going to be what's in your application
pretty much okay another thing you can
do is specify things on a per view
manner so here we're seeing for this
particular view we want to use the
contracts defined by this backing beam
okay this might be dynamic right this
might be based on configuration your
database to say which client the
application is working for right well it
might be based on something else and by
the same token you can actually apply
multiple contracts so you could have one
contract at this layout when this CSS or
you know who knows what you could do
there's lots of possibilities okay so
let's take a closer look at this so this
application this is an old demo I've had
forever which I keep on updating a
little bit but it's not very attractive
you know I'll log in here oops okay so
this is my beautiful application right
you can get add and delete project or
approve and reject projects and stuff
not too exciting but this is what it
looks like right so let's say I somehow
managed to sell my beautiful application
to Acme corporation okay and at the
corporation said well you know it looks
ok Kito but we want you we want to put
our copyright at the bottom and we also
want
the title to say Acme project track on
the page okay and they probably would
want more customizations but let's
pretend it's that simple right so I
could then create a new contract here so
you see up here I have this not this one
but this one is Acme layout okay I'll go
back to the project Explorer here ok so
you see basically let me build it back
to the navigator ok so what I have here
is inside of my source directory have my
meta and I have contracts I have acne
and then I have my resources right so I
have a different template ok so this
application has two templates that has a
standard template in the master template
ok and I also have some different CSS
right so if I look at my master template
here it says output style sheet equals
acne dot CSS okay if I look at the other
template the one that was chips with the
application it says a stylesheet of
global dot CSS right so since I'm using
facelet templating and master is used by
every page in my application would ever
see us as I specify here will be global
to the application right so inside of
the Acme version I'm specifying a
complete different CSS to use right now
I'm also let's see on this page which is
the sort of internal template that most
pages also use ok this actually uses
master ok so it's gonna inherit that's
CSS that I have then also it has a
footer which each page can use right but
I'm hard coding the footer to say
copyright Acme corporation ok so now
every single page is gonna say Acme
corporation at the bottom which is what
what my client wants ok
and all I did was basically take those
resources you use the same path names
right that I have my main application so
if I look down here I also have a
templates directory right off the web
content with master and standard right
so these are it's the same contract
right the same path names that I have
here this is relative to the layout or
to the the come to the resource comment
library contract this is relative to my
application so what I can do if I apply
the actual resource library contract I'm
basically overriding the the same paths
right now I said that um if you don't
specify a particular path a particular
page that uses a resource library
contract it's essentially global right
so what I can do is if I take this
project here and use it put it in my
class path as a jar it'll basically take
over the look and feel okay which is
what I want in this case in other cases
I may wanted to only be applied to some
pages which you can totally do it well
okay so in order to do that all I have
to do is is basically add this to my
application you know so whatever build
tool I'm using I could just add the jar
file so here I'll just do it from
eclipse that way to many projects in
here actually okay so now I've just
added this just to deployment it's not
really a dependency per se because the
application can run without it but it's
we wanted to be part of the the wire
file
so let me publish that okay so I'll go
back to the application again okay I'm
on behold now it says copyright Acme
corporation right because now I've added
that resource template and at the top
here you can see that if is FB project
track right so now of course you could
also take us further right you could
have different classes that you brought
in you could have different um you could
even have different resources using the
internationalization that you were
loading there's all sorts of things you
could do okay so so this really gives
you a lot of flexibility in terms of
sort of either dynamically or statically
controlling the look and feel of your
applications so it's definitely not my
favorite new features okay any questions
on this yes
so are you saying you want to know what
layout is currently being or what a
contact is currently being applied yeah
so the question is is there any way you
could i Nampally determine what contract
is currently being used and I'm honestly
not sure I'm preached I'd be really
surprised if there wasn't but I don't
know exactly what API that would be if
it would be fairly easy if there isn't
an API to do that so when you load it
when you went to pick our contract you
could save a variable somewhere you know
to say okay this is whatever contract
I'd be very easy to do but but I don't
know exactly what API that would be all
right so let's continue
so those are kind of the big-ticket
items in J has to have to point to
there's also some medium-sized features
there's some component changes component
managerial context is really more of an
internal thing for component developers
that makes their lives easier client
windows another feature so actually if
you noticed what was going on here you
notice this part up here this jsf w ID
okay so this is basically saying this is
the first window for this view okay if I
go to this page again okay and then I
submit something
okay you notice that the ID has changed
right so this is basically JSF now knows
that this is a different tab or a
different window in the same actual
application and you can you can also
find out what window you're in and
everything so it's a nice feature
okay so for facelifts we talked about
html5 doctype you can also create a
facelet or a composite component in code
very easily just the way you create any
other component in code there's a face
up factory API there's also a feature
called view actions which I'll talk
about in a second
almost all the artifacts are now
injectable via Java EE resources like
add resource at EJB and then also the
CDI as well so you can inject CGI beans
yes okay so he said faces context has a
method called get resource library
contracts that you could use yeah well
tell you what it is for the current for
you so and it's contrast cuz you don't
have multiple contracts associated with
one view so I knew it had to be in there
somewhere
okay so what's great about this is a lot
of the like a phase listener things like
that those are classes that now are
available for CDI injection and resource
injection so that's kind of Handy it's
often you know if you're writing a phase
lesan or some of some other more
internal JSF class you would not have
any dependency injection that's like hey
but all the rest of my application has
it why doesn't this class happen so this
is nice the only thing that's really
missing the valid editors and converters
still don't have it I think we'll do
that in JSF 2.3 the faisal center
factory is listeners acceptor so there's
also a CDI abuse scope this is actually
really nice because if you're using CDI
there was never the view scope
annotation when to manage being
annotation not a CGI annotation so now
there's a full-fledged CDI view scope
the annotation there's also a full list
on the web basically the issue tracker
lists if you want more information
that's a good place to look alright so
just want to talk a little bit about
view actions basically how many people
have used the pre render view event
before and their pages okay so this is
something that's often used to
initialize a page before it's displayed
apparently cousins because basically
it's an event that occurs before the
view is displayed and then you can call
a method listen
and do some work in there okay few
actions are essentially a more powerful
version of that so they are called
before pages loaded they have other
features they can return an outcome for
navigation so even if you're going to a
particular page if that view action says
well really I don't want to go to this
page I want to go to a different one
they can do that it can return an
outcome which can navigate to another
page okay
they can also be executed at different
phases of a lifecycle so you can say
okay well by default the view action is
executed during the invoke application
phase but you could have it be executed
at other phases as well like you know
you could do you know before we're in
review but you could also do like you
know before validation occurs or
something
okay so there's there's some more
features that more things you can do
there and there's a very quick demo of
that it so in this application if I
click on this details link sending a
project ID here right I'm also sending
in another variable from inbox okay
so inside of this page okay I have F
metadata which is required if you want
to use a view parameters or view actions
and I specified view parameters I want
to use so view parameters are a JSF two
feature where you can specify parameters
for the page they can bow into
properties in your backing beam right so
this is gonna set these properties but
then I'm going to call this view action
okay and this view action will get
called before the page is displayed by
default and I can process these actions
so what this going to do is basically
load this project project ID here okay I
could do other things as well but this
is just a very simple example so what's
happening is the page is getting this
request parameter project ID right here
that is being bound to a new parameter
here and then inside of the actual
backing beam
this load project method is being called
and it's looking at the project ID to
then load the project from a from a
service layer okay so this is just an
example of very simple example but it's
what you can do with view actions and in
general I'm going forward I would
recommend using view actions as opposed
to the prerender event for sort of
processing when the page loads or other
points in a lifecycle okay
okay so there's also lots of other bug
fixes and tweaks how many people have
wanted to use some collection other than
a list with a UI data when data table
component anyone ever had that problem
so now you can actually do that which is
nice if you're writing a component
library you may have noticed that it's a
pain to include composite components and
non composite components in the same tag
library that's now been fixed there's
also new events for the flash scope the
flash cope has always been sort of this
you know unhappy child that never really
had full support for everything so all
the other scopes in JSF have these
events and now the flash go past it as
well there's a full list of that on the
web as well
the your eyes as I said before if all
changed but back the old ones are
completely compatible and but if you
want to be you know hip and compliant to
the JSF 2.2 you used to assertion
replace for Java not some calm and the
XHTML files and you're pretty much good
to go
so JSF 2.3 has officially begun we just
started we just had our first expert
group meeting this week it's part going
to be a part of Java EE 8 and it's
actually going to depend on Java SE 8 ok
and dattara date is 2016 ok target a
year I should say it's third-quarter
2016 so this doesn't mean that all your
applications will break I need to change
the wording here all this means is that
it's not normally JSF will run on the
previous version of Java EE so that's
why you know you can use JSF 2.2 and
Java EE 6 server this is the first time
like this version of JSF is not gonna
run on a Java 7 server ok so for once
where we're moving we're aligning with
the exact version Java EE for the first
time but that would give us the ability
to use lambdas and use Java EE 8
features and things like that managed
means are going to be deprecated ok so
if you're using managed beans again
they're not going to go away your
application won't stop working but we
encourage you to use CDI
and that's why all the new features are
using CDI as opposed to managed beans
okay if you're using spring how many
people are using spring with JSF just
out of curiosity then you know for
things like flow scope if you really
want to use a JSF will open on spring
web flow then you have to either
implement your own custom spring scope
or wait for somebody else to do it
sometimes spring will well support these
features I don't know if they're gonna
do flow scope or not but they may or may
not okay if you're using spring you
don't have to worry about the managed
beans anyways so you we want to allow
you to inject the faces context which
would be nice time which is would be
another CDI annotation multi field
validation is something we're talking
about finally a desk method invocation
this is something that primefaces does
where you can call a method directly on
the server and get Jason back eyo
optimization better integration with
client-side frameworks and technologies
is some of the things we're talking
about like a better way so we can
integrate with some of these more hip
things like angular or web components or
things like that that are that are out
there in the landscape but the but you
know of course I should have that that
Oracle's safe harbor statement you know
we don't know which this might change we
don't know but these are things we're
talking about and the JSF expert group
is very open there's a mailing list you
can join where you can see what's going
on you know where we were really in the
community feedback so if you have ideas
let us know so just a summarized J's
have to point to is part of Java EE 7
came out spring 2013 backwards
compatible with Java EE 6 he new
features the html5 friendly markup faces
flows the cross-site request forgery
protection loading facelets via resource
handler file upload component resource
library contracts which again is one of
my favorites and and one of the things
you should keep in mind is I think one
of the main benefits that you get with
JSF 2.2 is sort of more modularity
right so now we're at a point where we
can load the different templates from
jar files we can load faces flows from
jar files so you can actually have the
ability to compose your application much
than you could before and that really
helps with teams where organizations
where you have like lab code you want to
reuse across different applications
medium-sized features we have the view
actions CI resource injection the client
window feature just a good bonus and
lots of facelets tweaks and lots of
other bug fixes okay and JSF 2.3 just
begun so that's it
I think I have one minute for questions
anyone have one question okay all right
thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>