<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CON6823   Project Jigsaw   Under the Hood | Coder Coacher - Coaching Coders</title><meta content="CON6823   Project Jigsaw   Under the Hood - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CON6823   Project Jigsaw   Under the Hood</b></h2><h5 class="post__date">2015-12-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/xswtIp730Ho" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so welcome everyone this is project
jigsaw under the hood my name is Alex
Buckley and before we get started I know
people have been doing polls all day I
will always like to ask a captive
audience such as this who is running
jeddak 88 in production right answer who
is running jdk 7 in production you're
all it's all the same people who is
running jelly k 6 in production i get a
good good five at the back yes okay 14
okay so mark this day no one is running
14 in 2015 12 11 are you right okay good
has anyone tried any jdk nine early
access builds some okay the jdk 9ea with
jigsaw fewer okay because they're two
different binaries who attended prepare
for jenneke nine this morning lots intro
to modular developments some advanced
module development difference as you
morally more than intro okay who plans
to attend the jigsaw hack session
tomorrow morning some may all hands up
good good okay thank you for that let's
recap obviously many of you will have
seen lots of this stuff at something of
a different level that i'm going to go
through it today so so so bear with me
let's just recap with a quick survey of
the modularity landscape first the Java
platform module system this is
technology being defined in the JCP for
java SE 9 the expert group started
discussion in February 2015 jsr 376
second the java SE 9 platform itself
will be defined in the JCP though no
Jess ours been filed yet and that jsr
will own the modular ization of the java
SE api that is the allocation of java SE
packages like java and java sequel in
tomorrow
Jules third project jigsaw is an open
JDK project to implement the Java
platform module system in jeddah k9
that's jep 261 it includes support for
modules in Java Sea Javadoc the java
launcher and other JDK tools project
jigsaw also splits the JDK into modules
there are three jets for that 200 2012
60 those modules will be in input to the
java SE 9 platform jsr when it modular
Rises the java SE api formally project
jigsaw also replaces RT jar and tools
jar with a new runtime image and
directory layout that's jep 220 this
will help modularity in the long term
but it's not directly related to the
module system it's an implementation
change specific to the JDK with all
these jsr s and jets you might be
wondering what what this talk is about
when you use JDK 9 and the features
implemented through projects or you're
subject to the rules of the java
platform module system from jsr 376
that's what's under the hood so really
this talk is less about projects or and
more about the java platform module
system the talk has three parts the
first part explains how the module
system works with the language and vm to
offer certain guarantees the second part
is about migrating to modules and the
third part is really under the hood what
the module system is fundamentally
capable of beyond what you can express
in the Java language I want to set some
expectations for this talk the style is
quite different than the style of a talk
about say lambdas lambdas are about the
shape of programs in the small
individual for loops turning into method
calls with lambda arguments you can
reshape a program to use lambdas without
anyone noticing modules are about the
shape of programs in the large we deal
with classes and packages and get bigger
from there
if you reshape a module it's quite
likely that other people will notice so
this talk is less about the code you can
write for yourself and more about the
kind of system that you can set up also
lots of my pointer
one second there we go Mike winters back
because modules affect all phases of
development compiling testing packaging
deploying running they're much more
connected to the tools ecosystem than a
feature like lambdas which only needs ID
support tools like maven Gradle ant and
so on don't support modules yet but
that's okay the jsr is still in progress
everything will be all right in the end
so that not all right not yet the end
accessibility and readability everyone
knows the hierarchy of accessibility in
the java language and vm it's simple to
understand easy to use and strongly
enforced by the compiler and vm but it
has a big weakness the only way to share
code between packages is with public but
then you're sharing with everyone it's
not surprising that package friendship
in one form or another has been
requested many times over the years one
goal of the module system is strong
encapsulation to allow a component to
declare which of its public types are
accessible to other components and which
are not the lines in italic are the
levels of accessibility connected with
the module system so reading upwards you
can arrange for types to be accessible
only within their modules or accessible
within their module and to other
specific modules or accessible to
everyone now as usual migration drives a
lot of our thinking we want to make it
easy to place an existing package into a
module and immediately give that package
the benefit of strong encapsulation we
don't want each and every public type in
a package to have to opt-in to strong
encapsulation so public types in a
package and not accessible outside the
module by default
that is public on a type declaration no
longer means that always it's always the
case that everyone can access the type
what happens if someone tries to access
a public type that's not accessible
here's an example from glassfish 4.1
glassfish full one doesn't start on jdk
nine because the vm throws an illegal
access error there it is probably can't
read the error message the error message
is class calm some enterprise security
provide a policy wrapper in module
unnamed module don't worry about that
yet cannot access class Sun security
provider policy file in module Java base
the point is that the class Sun security
provide a policy file is declared public
within the OpenJDK source code but since
it's a jdk internal api it's now
accessible only within the java base
module sorry glassfish or outside the
java-based module you need to find an
alternative to this internal api as the
title of the bug kind of admits they
know so in java SE nine modules are
first class program components like
classes and interfaces here's a
declaration of the java sequel module
that contains JDBC it's in a file called
module info java in a directory named
after the module the compiler treats it
like any other java file and translates
it to module in photo class which you
can put in a jar as normal we call that
a modular jar lots of you've seen that
earlier today the package hierarchy
exists in the same directory source java
sequel as module info java so module
info java is outside all of the packages
of the module it's in fact the job of
this module declaration to say whether a
package is strongly encapsulated or not
it's easy to get strong encapsulation
don't mention the package in the module
declaration to allow other modules to
access the package or more specifically
to access the public types
the package add an export clause you can
export to all other modules or you can
say exports to to give access to only
your friend modules at compile time Java
Sea prevents code outside the Java
sequel module from accessing any
packages except for those listed as
exported you get the same compile time
error as when you try to access a
package private type from outside the
package in Jenny ka and in fact since
forever right at runtime the vm throws
an illegal access error like you saw
with glassfish let's look at the vm more
closely traditionally accessibility in
the Java platform is about who is doing
the access and what is the public
protected private flag on the target
class at runtime the vm uses the class
loader of the accessing class to find
and load the target class and then the
vm checks the flag on the target class
because the vm relies on class loaders
people can create loaders that only know
how to find and load classes of certain
packages in effect loaders can isolate
one package from another in the top
picture class PC is trying to access
class QD I have very exciting class
names as you can tell the loader for
class POC knows how to delegate to
another loader for any class in package
Q such as QD only when that other loader
has loaded QD can the vm check its flags
to determine if if p dot c can access it
for example QD being public in the past
in the bottom picture the load of the
PDC has no idea where to find package Q
so no access to QD is possible from PC
technically this isn't a failure of
accessibility because the vm never gets
to check the flags of cute
wat d because Q dot d isn't loaded
instead it's a failure of visibility QD
is invisible to P don't see still the
effect is quite powerful if the
classloader of the accessing class can't
find and load the target class then it
doesn't matter if the target classes
public it's effectively encapsulated
whoever sets up the class loaders sets
up the encapsulation but encapsulation
based on class loaders like in the
bottom isn't strong encapsulation it
relies on packages being carefully
apportioned into different loaders but
that isn't how the JDK works most code
in the JDK is loaded by the bootstrap
loader while code on the classpath is
loaded by the application loader
spinning up lots of loaders for all of
this code would be a compatibility
nightmare in any case in this bottom
picture there is no actual isolation you
can circumvent class loaders by getting
hold of references to java.lang.class
objects once you have a class object
class loaders are irrelevant you can do
anything with them and it's impossible
to stop references to class objects from
being passed around a program they're
just references to class objects strong
encapsulation is about being able to
prevent access even if the accessing
class and the target class are in the
same class loader and even if someone is
using core reflection to manipulate
class objects let's assume that
different modules x and y are somehow
we'll come to that later mapped to the
same class loader can clasp you see in
module X access class QD in module why
another goal of the module system is
reliable dependencies to replace the
brittle error blow error-prone classpath
mechanism with a means for program can
opponents to declare explicit
dependencies upon one another so in
order for PDC to access QD not only does
module y need to export package q But
module X needs to explicitly depend on
module why the formal name Fort depends
on is readability readability that that
reads edge we'll be seeing a lot of them
underpins accessibility in the Java
language and vm in se9 the accessing
class PDC must be in a module that reads
the module of the target class that
reads why and that module containing the
target class module why must export its
package q to at least maybe two more but
to at least the module of the accessing
class module X so you can see that
accessibility is a two-way street X
reads why and why export package Q 2 X
and probably many others this
accessibility is independent of class
loaders just like accessibility was
before the module system this is
important for two reasons first it means
accessibility works at compile time when
there aren't any class loaders second it
means you can reason about accessibility
based solely on requires and exports
clauses in module info Java there's no
need to worry about this class loader
mapping and the class loaders in
existence at runtime in fact
accessibility is actually quite
straightforward a package is either
exported or it isn't but on readability
there's actually more to say when you
depend on a module you depend on a
hopefully coherent collection of
packages that are exports in some sense
those packages are the interface of the
module inside the module hundreds more
packages may sit encapsulated waiting to
help implement the interface and more
than that when you
pinned on a module you implicitly depend
on all the modules it depends on for
example if you depend on the Java
activation module in jeddah k9 with its
35 classes then you implicitly depend on
the Java desktop module with its 5580
three classes if the watchword for JDK 8
was functional then for JD k9 it's
transitive you should think in terms of
the transitive set of modules needed by
your application the indirect
dependences can be as important as the
direct dependencies let's see how
readability handles this I'll use an
example of readability real example from
the graph of java SE modules the java
sequel module that holds jdbc on the
Left requires the java logging module
that exports the package java.util
logging this lets code in the java
sequel module on the left in the blue
access the public types of Java util
logging such as logger you can see some
code in the JDBC driver manager class is
newing an instance of lager as an
anonymous class good what if the API of
the Java sequel module rather than its
its method bodies wants to use the
logotype for example the JDBC driver
interface wants to return a logger so
loggers right there in a public method
signature let's look at this through the
eyes of an application module that uses
jdbc my app on top in order to use the
driver method that returns a logger the
maya module not only need to read the
Java Sea cool module but also the Java
logging module that exports the logotype
it will be a pain if the developer of my
app had to remember to say requires java
logging sad face when using the API of
Java sequel that's going to return the
logger there's good news
the java sequel module can take on the
responsibility of remembering look at
the java sequel module the java sequel
module now says requires public java
logging the word public here means that
anyone who reads the java sequel module
also reads the java logging module for
free the my app module no longer has to
bother with requires java logging cross
out happy face because the my app module
reads java logging thanks to reading
java sequel this is called implied
readability and it's very powerful it's
powerful because it lets a module be
refactored without breaking consumers
for example suppose that JDBC has a Java
sequel time package that we'd like to
ship in a separate module this new
module java sequel time same name as the
exported package is at the bottom right
the java sequel module can say requires
public java sequel time so that my app
which explicitly reach java sequel
implicitly reads java sequel time the
java sequel time module and it goes
further we could refactor the java
sequel time module by extracting a java
sequel date module the java sequel time
module would say requires public java
sequel date so anyone who reached java
sequel time also read java sequel date
for free my appt at the top would be
unaware that this is happening this
refactoring is happening in essence the
readability model supports downward
decomposition any module you read can be
decomposed into new modules and
readability of those new modules can be
recovered recovered with a requires
public clause in the old module you can
see here that the definition of reads is
recursive a module X reads another man
it reads another module y by requiring
directly
the top or by reading some third module
q there's the recursion where q says
requires public why and now that x reads
y along the bottom y can say requires
public Z's something else and X will
read Z as well now be careful once
people require your module explicitly by
name you can refactor it as much as you
like but you can't delete it there's no
way for a module to stand in for another
module by taking its name as an alias if
someone requires X and X is deleted the
module system won't start someone's
broken a contract effectively everything
so far has been about accessibility in
the Java language and VMware the
accessing class pedo SI and the target
class QD were known statically but
accessibility extends to dynamic class
references that you manipulate with the
core reflection API that is
java.lang.reflect.method.invoke the
array ms refers to maybe private methods
of this inaccessible class now we want
to preserve strongly encapsulation even
when core reflection is used to access
types in their members the only
opportunity to do this is when an
operation is performed on a
java.lang.reflect.method.invoke and get
and set the fields on these classes
perform the same pair of checks
as the compiler and vm does the caller
module read the target module and as the
target module export the relevant
package to the corner module even set
accessible respect strong encapsulation
suppose you have a
java.lang.reflect.method.invoke impaler
and vm and i'm going to say them again
because it's the same rules all the time
does the caller module that's calling
set accessible read the target module
and as the target module export the
relevant package to the corner module
whoever's callings it accessible if all
that checks out then the private field
can be made accessible via set
accessible true so that's accessibility
and readability accessibility used to be
a simple check for public or same
package I'm skipping protected because
it's a whole den of iniquity in itself
no one wants to go there in Java SE 9
accessibility strongly encapsulate smaj
ool internals accessibility relies on
readability you have to have that reads
edge which can be direct or implied and
the key point really is accessibility is
enforced by the compiler vm and core
reflection
let's take questions at the end let's do
some different kinds of modules
everything so far has been about named
modules modules explicitly declared with
a name in module in photo java got a
bunch on the left what about jar files
on the classpath that don't have a
module info doc class file they seem to
be in this world of their own to keep
the model of accessibility and
readability consistent we introduce the
unnamed module all classes not in named
modules are in the unnamed module it is
as if everything on the class path is in
one big module because it's the module
we can ask two questions what does it
read and what does it export what the
unnamed module reads is simple every
named module all of them as if by magic
for free this means anything exported by
a named module can be accessed by the
unnamed module you can turn a jar file
into a named module by adding module in
photo class put the jar on the module
path where modules are found and the
jars left on the classpath in red in the
unnamed module won't realize anything's
happened because they can read your
named module that's a huge help for
migration the next question is about
what the unnamed module exports before
that though we should ask the unnamed
module reach all these named modules who
reads the unnamed module was anyone
thinking that who is he on a module it's
wondering some people remember our goal
in the module system is reliable
dependencies we believe very strongly
that named modules should not read the
unnamed module
out of the box it would make a mockery
of reliable dependencies to have modules
named modules depend on the arbitrary
content of the classpath so you can't
Rights requires unnamed or requires
classpath in a module declaration there
are no reads edges going out to the
unnamed module this looks like a huge
hindrance for migration because any jar
you turn into a named module can't
access the jars can't read and thus
can't access the jars left on the
classpath the answer is automatic
modules you can take a jar say guava jar
and move it from the class path to the
module path this turns the jar into an
automatic module that's all you have to
do you move the file an automatic module
is a named module declared implicitly
rather than explicitly its name is
derived from the jar file names from the
jar file name in obvious ways placing
guava jar on the module path gives an
automatic module an automatic named
module called guava as before whenever
you see a module you should ask what
does it read and what is it export the
automatic module guava reads everything
in the JDK image and the unnamed module
it's as if it says requires unnamed now
the hindrance to migration is gone you
can turn a jar into an automatic module
by moving it and it can read the unnamed
module and thus access the jars left on
the classpath we asked earlier what the
unnamed module exports now the answer
we're ready to give the answer the
unnamed module exports all its packages
all the packages in j unit jar and
glassfish jar and hibernate jar
precisely to help code in automatic
modules
which like guava read the unnamed module
because an automatic module is a real
named module as if you declare to
yourself another named module can
require it here the javafx core module
which is a real named module there's a
declaration in everything in jeddah k9
it says imagine if it says requires
guava that means there's a reads edge
from JavaFX core to guava what does an
automatic module like guava exports easy
all its packages so JavaFX core can
access all of the public guava types
JavaFX core could even say requires
public guava to transmit its dependency
on guava up to its own consumers so
anyone who reads JavaFX core there's a
whole stack of java effects stuff above
that will also read guava for free so
moving a module from the classpath to
the module path means you get an
automatic module that lets you start
building up your own graph of modules
it's not necessary to wait for every jar
on the classpath to be modularized by
its author before you start developing
modules that require it by the way what
happens with the second automatic module
hibernates moved from the class path to
the module path well automatic modules
read each other as well as all modules
in the JDK and the unnamed module guava
reads hibernate hibernate reads guava
they both read all the modules in the
jdk image they both read the unnamed
module in some sense they read as much
as they did when they were jar files on
the classpath morally so our goal
clearly is for you to take groups of jar
files from the classpath move them to
the module path require them from your
own named modules and have everything
just work
in some sense automatic modules in the
module system are like raw types in
generics necessary evil necessary
because they enable migration and evil
because they look straight forward on
the surface but had a lot of complexity
behind the scenes that's our problem
that said we've had good experience
using popular jars like J unit and juice
to take some examples as automatic
modules you put them on the module path
you can require them easy so there are
three kinds of modules explicit named
modules like java sequel automatic named
modules like the guava example and the
unnamed module aka the classpath the key
point is there is lots of readability
between these modules given for free to
help migration the third and final part
loaders and layers I said before that
strong encapsulation is independent of
class loading there are no changes in
the java.lang class loader API due to
the module system class loading doesn't
change in some sense the module system
exists underneath the VMS class loading
architecture not on top of it vm at the
bottom module system class loaders the
module system works with whatever load
has already exists it doesn't feel the
need to create or mandate its own weird
and wonderful set of loaders and so good
news jdk 9 has the same three loaders as
JDK 8 bootstrap extension and
application sometimes called system some
implementation details of those loaders
have changed but that shouldn't matter
to ordinary programs most modules you've
seen like Java base
and java sequel and java logging have
their classes defined by the bootstrap
loader a few modules like java korba
have their classes defined by the
extension loader and out of the box a
handful of modules related to tools have
their classes defined by the application
loader where most modules will end up
actually it's important for security the
java SE modules be moved out of the
bootstrap loader if possible modules in
the bootstrap loader run with all
permissions which is not ideal from a
security perspective they can only be D
privileged that is run with fewer
permissions if they're not in the
bootstrap loader we've spent a lot of
time and effort on moving modules out of
the bootstrap loader so they can be D
privileged frankly for a module as big
as Java cawber we've moved to extension
1833 classes and 31 exported packages
that is no small accomplishment the d
privileges self figuring out the
permissions and setting them on a per
module basis will continue throughout
JDK 9 and JDK 10 so while the module
system doesn't create loaders itself it
is responsible for associating loaders
with modules if you have any classes in
your vm there has to be a class loader
to load them but the module system will
associate those loaders with modules to
help manage this the module system
introduces a concept called a layer a
layer is a family of class loaders that
together serve to load classes for a
graph of modules out of the box jdk 9
defines the boot layer consisting of the
three familiar loaders it's the boot
layer that associates the java base and
java sequel and java logging modules
with the bootstrap loader java korbo
with the extension loader and so on
that's the boot layer now the boot layer
is the only layer that
most people will ever have to think
about or indeed not think about but
there's a lot more to say about layers a
layer is created from two things there's
a graph of modules that it's going to
manage and a function that maps modules
two loaders on the left it's the graph
from resolving the JDK J link module
which contains the jailing tool for
building runtime JDK images you CJ link
depends on some internal module and the
Jade EPS module and you go down through
some compiler modules and of course of
course you get to Java base also to
create a layer here's a lambda
expression mapping modules to the
bootstrap loader and to the application
loader very simple example based on
logging go and bootstrap everything else
jdk compiler blah blah blah go in the
application loader creating a layer in
with those two bits of information
informs the module system about the
classes that will exist in the program
and the modules they'll come from the
module system passes this information to
the vm so that when classes are
eventually loaded the vm knows which
module a class belongs to and what that
module reads and exports layers mean
that the vm effectively has a shadow
copy of the module graph that it uses
when checking accessibility between
classes in it and it needs to know about
readability so the vm knows about all of
those reads edges now because of
fundamental constraints in how class
loading works the module system must
enforce certain constraints both on the
module graph that I showed and on the
mapping from modules to loaders let's
talk about constraints on the graph
first this is the graph of java SE
modules today what do you notice about
it my question to you is there anything
that you notice
out this graph sorry apart from the dots
and lines sorry so well sorry ah yes so
always it was yes yes it is a directed
acyclic graph that has no loops because
that's the same thing there are no
cycles in this graph this is fundamental
in the Java platform module system
cycles bring an entirely new dimension
of complexity it has taken over half a
decade to detangle the tens of thousands
of classes in the JDK to the acyclic and
relatively sane state that you see here
we don't wish that pain on anyone else
java application architecture is the
best book about modularity I have ever
read in a section titled cyclic
dependencies the death knell it says
excessive dependencies are bad but
cyclic dependencies are especially bad
the book goes on to say generally
speaking cycles are always bad however
some cycles are worse than others
remember this book was written years ago
before the module system came along
cycles among classes are tolerable
assuming they don't cause cycles among
the packages or modules containing them
cycles among packages may also be
tolerable assuming they don't cause
cycles among the modules containing them
module relationships must never be
cyclic so that's clear enough module
graphs must be acyclic let's turn to
another requirement on module graphs the
requirement is that a module may read at
most one module that exports a package
called P if a module could read more
than one module that exports p as X
appears to be trying to do by requiring
y and z
in which module would P be accessed
there is no answer the system would just
be broken so we defend against that only
module graphs which obey this constraint
and have no cycles can be turned into a
layer let's turn to the constraint on
the mapping from modules to loaders
remember the mapping modules loaders is
an essential part of a layer along with
the module graph there's only one
constraint it's due to a fundamental
limit in class loading a class loader
can only create one class called see if
ma if multiple modules in the graph have
a class called C then those modules must
be mapped to different loaders more
broadly we say that if multiple modules
have the same package then whether or
not they exported just for simplicity
sake those modules must be mapped to
different loaders there's a secondary
constraint on this mapping that I'll
talk about though it's not practical to
check because it concerns how the
loaders behave at runtime by the way
quick poll who's ever written a class
loader here wow that's a lot so you will
know about class whether delegation
excellent the secondary constraints
hinted at the bottom is that loaders
must delegate to each other in
accordance with the reads edges of the
module graph that is loaded delegation
must respect module readability the
reason is obvious if module X reads
module y then in order for X's classes
in one loader to access wise classes in
another loader X's loader must delegate
to wise loader now there are no read
cycles in the module graph right so you
might expect that there would never be
delegation cycles between
regardless of how the modules are mapped
to loaders unfortunately this is not the
case you can get delegation cycles if
the map from modules two loaders is bad
I'll illustrate bad with an example
quite an interesting example from the
JDK in jeddak 88 the 40 w3c Dom packages
you see here were present in our tea jar
and defined by the application class
loader but it turned out that Jax p the
JCP technology which endorses w3c
technologies never actually endorse
these four packages their presence in
the JDK was unofficial what should we do
with them in jdk nine it turns out that
Jack speed doesn't want to endorse them
so the obvious answer is delete them
however XML labor is outside the jdk
assumed these packages are always
present in the application class loader
so rather than making every library ship
its own copy we decided to ship them in
their own module JDK XML Dom you get
this module if you require JDK rather
than requiring java SE from your own
code in the jeddak a module graph
there's jdk XML Dom sort of hiding out
near the bottom in the boot layer we
plans to map jeddak XML Dom to the
extension loader because it has no need
to be in the bootstrap loader it's not
some security sensitive vm friendly
system thing and this looks good jdk XML
Dom requires java XML so there's a reads
edge and the extension loader will
delegate to the boot bootstrap loader
four types exported by Java XML great
this looks great unfortunately someone
added a jdk plug-in module top right
that required JDK XML DOM and they map
that JDK plug-in module to the bootstrap
loader so there's no site there are no
cycles in the reeds
Edge's right but for class loading to
work at all there would have to be a
cycle in the delegates edges that's bad
sooner or later a delegation cycle would
become an infinite loop class that is
very unpredictable but set that aside
and consider this the bootstrap loader
as a matter of fact never delegates so
in fact the mapping of modules two
loaders in this case for that plug-in
module is just wrong given that reads
edge from JD hey plug-in to jeddah cakes
mailed on now fortunately we caught this
in time one possible fix was to rewrite
JDK plugin to not depend on these Dom
packages so that green reads edge to jdk
XML Tom would go away now this fix might
sound unlikely but it's surprisingly
common to clean up parts of the JDK and
discover you can cut out many
dependencies another possible fix was to
move JDK xml dom up to the bootstrap
loader that's not great the solution we
actually chose was to move JDK plugin
down to the extension loader it's not
trivial but that kind of D privileges is
always the right answer long-term so
going back to loaders respecting
readability there should be no
delegation cycles between loaders just
like there are no read cycles in the
module graph and another aspect of
loaders respecting readability concerns
splits packages who knows about split
packages some a reasonable number of
hands a split package is when multiple
loaders define classes for the same
package remember that a module can read
at most one other module that exports p
that's baked into the definition of a
well-formed module graph no reads edge
if X reads why that exports p the next
cannot also reads it that exports p and
so if loaders respect readability the
loader for module x will delegate to
exactly one loader class thota to
four types of P that means no split
packages out of the box it's a very good
thing unfortunately there are libraries
out there which include types from
packages belonging to java SE that means
a split package which traditionally
leads to class caste exceptions and
entire java one talks about how to avoid
them if a third party library that
included some types from a java SE
package was to become a named module
then the module system would detect that
the module exports the same package as
the Jazz a some java SE module the
module graph wouldn't be well-formed and
the boot layer couldn't be created but
if this third-party library is in the
unnamed module then the module system
doesn't detect the split package this is
because we don't want to scan every jar
on the classpath at startup just in case
there's a there's a package that split
across named modules and the unnamed
module the results in this case can be
rather surprising and I I want to
present two scenarios that demonstrate
this one scenario is a jar file on the
classpath that contains non-standard
types in the Java X annotation package
on Jenny canine these types will be
ignored because the Java SE module graph
already has a module that exports the
Java Rex annotation package any code on
the classpath in red which relies on
non-standard types even if it ships them
look it's got some of its own we'll get
a no class def found error because Java
SE doesn't have my own 01 and my no.2
now this no class they found error
sounds bad but it means we avoid a split
package as soon as it would become
dangerous that is much better than the
program running with two distinct
versions of Java X annotation because
that can generate errors at almost any
point in the program's lifetime
and those errors are famously hard to
diagnose let's go this scenario is
actually almost easier when you go
through it in detail so many years ago
jsr 305 proposed annotation types to
help with defect detection the famous
ones are Java X annotation nullable and
Java X annotation non-null guava
supports them despite jsr 305 never
finalizing their semantics now the Java
Rex annotation package is actually owned
by jsr 250 common annotations for the
Java platform there's a module dedicated
to jsr 250 called Java annotations
common it exports the Java Rex
annotation package so while virat jar
comes along the classpath expecting to
find this nullable type and thanks to
jsr 305 jar the unnamed module contains
the java x annotation package but the
module system doesn't notice this by
design when the boot layer starts up
instead the unnamed module with the old
jar files reads the java annotations
common module which exports the java x
annotation package and there is no
nullable type in that package in the jdk
so guava gets a no cluster found error
what's the solution for guava users one
option is to lobby for jsr 250 to
include nullable and non null types in
the official java rex annotation package
another option is to lobby for guava to
include nullable and non null types in
its own package not in Java X annotation
notice these are really governance
issues not technical issues and that's a
common thing when migrating the world
towards modules here's a similar
scenario this time with a better outcome
for many years Jax p that guy again did
not endorse the Dom element traversal
spec
from the w3c the JDK is enormous right
there are all these examples everywhere
of little touches like this so Jack
speed did not endorse the Dom element
reversal spec in concrete terms Jack's p
included the org w3c dom package but not
the interface element reversal in that
package so the Xerxes XML parser wanted
to implement the Dom element reversal
spec so they included the element
reversal interface in Xerxes jar in
jeddah k9 the org w3c dom package is
exported by java xml so the same package
in the unnamed module is ignored xerxes
will get a no class there found error
element reversal just like guava did the
happy ending is this Jack's P has agreed
to endorse the Dom element reversal spec
in SE 9 so in concrete terms we added
the element reversal interface to the
org w3c Dom package in the Java XML
module it's as if jsr 250 had agreed to
add nullable a non-null to the java rex
to their java x annotation package now
everyone who reads the java xml module
including Xerxes jar in the unnamed
module can access the element reversal
interface the Xerxes version in the jar
is ignored but that's okay because the
interface in Java XML is up to date has
all the right members two more slides as
their name suggests layers can be
layered when a graph of modules is
resolved it's actually resolved against
a parent layer then when the graph
helped to create a new layer the new
layer picks up the parent this allows a
graph of modules to have dangling
references requires clauses for modules
that the module system will find in a
parent layer during resolution on the
Left resolution has set up not only a
reads edge between modules in one layer
but also a reads edge
between modules in different layers
constructing a tree of layers in this
fashion is the job of a framework like
an app server or a test runner layers
give frameworks tremendous freedom to
organize modules at runtime without
upsetting the frameworks traditional
uses of class loaders it's like the
invoke dynamic instruction in java SE 7
away for framework authors to interact
with the vm to reify information about
the shape of the program now that sounds
a bit abstract let's look at one
scenario where layers help out layers
are how the module system supports
multiple versions of a module here an
app server has created two layers above
the boot got the boot layer then two
layers above that the Hadoop layer and
the JavaScript layer each layer has two
class loaders and each layer has the
boot layer as its parent so it's modules
can read Java base the Hadoop player
reifies a module graph with guava
version 11 and Jackson version 1 while
the JavaScript layer reifies a module
graph with guava version 18 and Jackson
version 2 each module graph is
well-formed and maps two loaders in a
sensible way but the modules in the
Hadoop layer are not aware of the
modules in the JavaScript layer and vice
versa now note this is all thanks to an
app server creating the layers the java
command-line tool you used to launch
programs doesn't create layers like this
all it does it resolve the module you
give on the command line then map
everything in the resulting module graph
to the application loader in the boot
layer there's my app in my lib you might
have had on the command line so it
supports only one version of each module
the reason is to avoid the nightmarish
problems that occur when multiple
versions of the module casually come
into contact with each other it's really
only safe to use multiple versions of
the module when a framework like an app
server is in control the takeaway is
this just as modules wrap up cohere
sets of packages and interact with the
VMS accessibility mechanism layers wrap
up coherent sets of modules and interact
with the class load of visibility
mechanism it will be up to frameworks to
make use of layers in the next 20 years
just as they have made use of class
loaders in the first 20 years so that
was a deep dive into loaders and layers
modules do a better job of encapsulation
than class loaders but class loaders are
still necessary layers control the
relationship between modules and class
loaders and assuming class loaders
respect the module graph the system is
safe by construction no cycles no split
packages zooming all the way out here
are the three key points in se9 they're
strong encapsulation of modules by the
compiler VM and claw reflection there
are unnamed and automatic modules to
help with migration and the system is
safe by construction no cycles or split
packages the module system in essence is
a seat belt keeping you safe not a
jetpack pictures pictures please
there is a long road ahead the module
system is conceptually quite simple but
in jdk nine its associated with changes
that probably won't break your code but
might break code you depend on we've
tried to support migration as far as
possible but it only takes one
unmaintained library using a jdk
internal type to prevent a migration to
jdk nine if that library can't migrate
nor can anything on top of it so in this
regard modules are unusual they suffer
from a tragedy of the Commons whereas
most big features like generics or
lambdas let people opt-in at their own
pace without needing to way for others
you can see we've done a lot to be
flexible but one are maintained library
using something internal and you have a
problem so we've come full circle the
day started with a prepare for JD canine
talk and here at the end of under the
hood I'm talking about how you can
prepare for JD canine please try JD
canine with jigsaw there's the URL run
your applications on it run J depp's on
your code and on the jars on your
classpath and subscribe to jigsaw dev at
OpenJDK to see common problems and
solutions please tell us what you're
finding lots of other talks tomorrow 830
the hack session and then repeated on
Tuesday Wednesday and Thursday the first
three talks in this series effectively
of modularity talks also I'd point at
two-thirty tomorrow hands doctor from
Gradle we're talking about solving the
puzzle with jigsaw and Gradle and Paul
Sanders in the afternoon talking about
son mis gun safe crazy crazy things
they're also Stewart marks on Wednesday
afternoon dr. deprecated himself saving
the future from the past innovations in
deprecation migration cleanup moving
forwards it's all the same thing right
and with that thank you very much thank
you for listening we'll take questions
here
thank you for coming I think you have to
come up to the mic in the well so the AV
crew has mostly gone home so I guess we
can stay as long as we like audio is
here but but video is not so questions
jar files can not only contain classes
but also resources ah hardly also
protected by encapsulation the question
was about jar files containing not only
classes but also resources are they
strongly encapsulated the current answer
is yes but there are many many design
discussions about that read the expert
group lists you've been waiting a long
time if if I access an exported class
and it returns an object of an exported
interface can I assume I can still
interact with the object even though the
object was not exported as long as I
treated as an instance of something I'd
res exported and so yes question you
couldn't hear us yes part two of that is
can I call new instance if the thing
that's returned is a class a cloud I
should have said class new instance is
under the same regime as field get feel
set and method of oak so something is
back a class of object I can't call new
instance on there if the object right if
the class if the class object represents
a non exported thing you can't new
instance it any more than you could new
the class thank you yeah the could the
question that I knew someone would ask
is all this accessibility staff blah
blah blah what if I just you know the
thing that returns logger what if I just
call that method and assigned to object
does that work and the answer is yes
because the language is very clever and
lazy about access control and as long as
you treat it statically as something
that's safe everything compiles
everything runs if module X exports
package to module why can module why
require public on that package is it
effective if sale again if effectual X
exports package to module to module why
yes okay this module why can it requires
a
requires public on that package you
don't require public on a package you
require partly funded module so I oh why
could require XY can requires public
access no problem with that why it's a
feature why why is going to require X
and maybe the API of module y uses types
from the other module that's completely
common situation so it's quite common
that module why would require public X
to push up the x dependency to its
consumers so frankly its consumers might
see a package from there and it becomes
the job of the system assembler or
higher level developer to figure out
what idiot has got too many dependent
it's in what you did it's as simple as
that next question whatever the
performance implications what are the
performance implications that's a talk
we didn't submit the answer is that I
think there is there is so much to say
about that and I'm not performance guy
the accessibility checks that you saw
where one type where the vm is seeing
one type trying to access another the
good news and under and the
accessibility depends on the readability
the good news is through the the module
graph is immutable so the vm when it
gets its copy of the reeds edges can
optimize and make a nice table and i
believe it does yeah it's those
accessibility checks that there are no
up in performance terms because all of
the modules module requires this guy
requires public so he reads him and
requires probably could set up a whole
chain of these things to refactor the vm
knows all about it knows about all of
that a start-up ok basically layer
creation same thing so you mentioned our
model we cannot import two modules with
package beat that exports the same
package right right right I export the
same package P but what if the root
module monkey patches a class say from
gawa right is that possible because it's
not important
I'll module a in any model a bitch ass
monkey patches so maybe the monkey patch
term is making my hair stand on end
right it's not a commonly used term it's
oh no it is and that's in it should make
it should buy your house that lends as
well right now so it's it's a monkey
patch is a very serious tool right i
mean it's used a lot in reality it helps
a lot right so the question is if what
if you what if you almost accidentally
put a class into a module know that I'm
so I want to fix a bug in Goa say oh I
cannot be over a glass of cava and fix
the bug locally only in your module I
application in my models no module and
you export that package no see I don't
are you don't need but imagine I am the
root module okay then i'm not actually
importing sorry yes let's go with yes
you could do that I i guess i guess in
monkey peg leg okay up one more question
that's okay um automatic depends on the
names of jars now yes that's crazy i
know what else can we do I don't did you
have a better suggestion no i don't know
like big buts thats grenada stuff you
just make migration part that's gonna
break a lot of i would be totally happy
to delete all them automatic module
stuff all right i'm not note so
challenge if anyone can find me a module
system that supports migration is sort
of a first-class feature where there are
such things as modules and also such
things as not modules please let me know
about it none of the JavaScript module
systems and there are so many let you do
that other module systems on the Java
platform you're either in it or you're
like a loser and so this automatic
module thing I don't know say it's a
hack that that's genuinely unfair but
it's a pragmatic answer to what do you
do when you're building up look we've
got JDK modules javafx has been
motorized and there's something you
depend on that is well for minimize the
pretty well formed and you want to
require it if you want to use although
its public types but it's not a
well to keep things consistent I have to
say it's a module or not only access
access is for everyone to do or open
source or otherwise is suffix the
version to the do their names of the
chart that right so versioning and
module name that that's a is a real
issue and that sort of a separate point
which I can probably agree with you on
but the fundamental extract the GU a VA
parts I don't see any other way around
it but your versions you use fair point
just for one of the road module is the
one with the main bathroom what you say
route module and we have a particular
meaning for route module yes let's go
with yes yes and so you you've mentioned
that reflection will and take note on
and on are always a module boundaries
yeah method handle look up yes does the
security checks and look up time robbed
of an invocation time yes are we going
to see terrible uses of this that's
right so method handle look up now what
does the security checks at module
method handle creation time having not
done so to begin with now we can't
change here's the thing we can CH
there's lots of code out there that
creates looks up class objects and
passes them around right I don't know
what that code is doing so class
creation time the time when you get the
capital C class object you could in get
class have a whole bunch of checks we've
chosen to do it as lazily as possible
like the vm does so you can pass the
class objects around just like you're
doing today and only when you actually
go and touch a field in there might be a
public field in a public class but of a
package that's not exported it's an
internal package only then at the latest
possible time that's the general vm
approach as lazy as possible and call
reflections pretty close to the vm do
you get the error but sure we could have
done it yet we could have done it a gate
class time lots of questions
if I have something in the unnamed
module yes that requires a named module
that has not been added on the module
path is there a way to get around that
at runtime or just have to be specified
well so the unnameable doesn't
explicitly require anything right sort
of it reads whatever there is for free
so if you have built yourself for
example a jdk image and forgotten to
include a module with useful types in it
that no glassfish jar was rather hoping
to use glassfish jar will just fail with
a no cluster I mean the classes really
aren't there so all this all the
readability stuff can't overcome the
fact that the module you want to read
isn't there yeah yeah let's take another
question say imagine you're running only
with class passed on jdk nine so ok
everything goes india and yeah module
yeah that's fair in that case which
named modules does that in this net and
name module actually depend every named
module within the jdk yes and on the mod
so reads Hannibal is read the reeds
edges they're kind of virtual right they
they need to be present if you ever try
to access something in order for the
access to work how you know when those
reeds edges are set up to everything in
the image by the way I say these name
modules I mean some of them are in the
JDK image java base some of the oj maybe
jdk javadoc is on the module path so
everything everything that is a named
module yes within the module by of
itself with its really within the module
system whether it's on the module path
or I'm gonna give some more details away
the upgrade module path right which we
haven't talked about at all today but
wherever the named module is isn't is an
implementation detail right the unnamed
module reads all named modules that's
how accessibility a simple rule for
accessibility could always low if if for
instance
yours we go to jdk chan and God forbid
you still only using classpath and one
of the one of the libraries in your
classpath gets gets merged into the jdk
into a named module okay yes your code
will no longer work at all because you
are not because you are not explicitly
naming that module but you're not
picking it up by either oh no um the the
that sort of the Gua for example if
there is some package that gets pulled
into a named module on the jetty Kayla
when I run my application I do not
explicitly say I need that module right
because you're still running in jeddah
k10 with the classpath and you've still
got some jar on so they're so the module
is automatically imported by by the
unnamed ba jewel and whatever that
module that that's got the new stuff in
jdk 10 exports is what stuff on the
classpath kodel classpath we'll see okay
so things if anything I mean it's the
moral equivalent of this guava situation
here we are yes so you know there is
today it is a true fact there is a
module that begins java that exports
this java rec sanitation package and
there are more types in that package
hanging around in a jar file on the
classpath it's true today if those two
annotation types move into the java
module that that's great i mean it's not
great for our footprint just shot it wit
will work so i think i found a bug in
the current jigsaw girl totally possible
thank you okay hopefully this is a
little more straightforward um the thing
of the thing the thing the thing is like
the thing um so the module info java
really seems like a buffed up version of
what would normally be can't be
contained in the meta f directory do you
intend to get away do away with
manifests so there's more in a manifest
sealed packages and some weirdo legacy
version information than you can exploit
legacy stuff there's more there than you
can express in the nice clean module
declarations so if you have a need for
some of that legacy stuff in a manifest
it will keep working and jawline package
will continue to export that manifest
informations sealed package blah blah
blah but the most useful parts of the
manifest basically translate into module
declaration risk including the metron
services files which we haven't talked
about here at all today because we need
like another dimension of jigsaw talks
so basically the mat the benefactor will
still work there's nothing wrong with
having it in your jar file angelica 9
you can have it alongside the module
Declaration and the module system will
only read the module declaration in
module in photo class do you intend to
eventually move away from manifest
altogether is there is there something
the manifest can do that a module info
that Java could not there is an example
of that today which is the main class
right which you can't specify them at
you can specify the main class in the
manifest right yeah right but you can't
specify the main class in this here
module declaration you've specified a
right so when you build your jar file
you can nominate the main class and it
gets recorded in the jar file but you
don't say it in this source file and the
blank look on your face tells me which
is completely reasonable a lot of people
say why aren't i'll just add red why
aren't their version numbers in this
module declaration why isn't there a
main class there's actually more stuff
than we're showing you but people don't
care about that why why can't I put this
other stuff in there we're trying to
keep this module declaration very simple
because it is read by all those
compilers which need to figure out the
module graph to figure out accessibility
at compile time and stuff like main
classes and authors and what license the
module is using and so on and so on
compilers don't care sure that the vm
doesn't care and so that's why i say the
module system is much less about code
and it's much more connected with the
tools ecosystem that do care about those
things and the way these thing the way
the tools and this stuff will work
together remains to be seen
we're working with hand thanks Jason and
yeah thanks for ya to various questions
first one is you can only export at a
package level correct yes you get
explorer takoj second one is with all
this information be available via
reflection yes
java.lang.reflect.method.invoke of
reflection how would a dependency
injection framework that uses reflection
yes handle a modular system someone else
exactly thing exactly this question
about di framework um so the issue is
really that the non exported packages
are locked away and if the DI framework
wants to either bind classes to
interfaces little locked away or use as
implementation classes stuff from the
locked away packages frankly it's got a
problem so there are a couple of things
that can be done one is you know this is
not a command line or in to talk but you
can always on the command line override
module declarations minus X at exports
because it's your machine and you're in
control the other thing you can do is a
module that exports I should put an
export stay up and module the only
exports so my app good example my app
doesn't export anything it's got a main
class and it requires a bunch of stuff
but it's not a library right but it
wants to benefit from dependency
injection so what it can do is it can
export certain internal packages to the
dependency injection framework I haven't
showed the cinder it's basically export
something to spring dot di tutto juice
better example it's kind of
straightforward and you say well why
should I have to say that the answer is
you're making your intentions clear
you're declaring what you export to
everyone probably nothing in this case
of what you export to your friends so
the vm can enforce it last question i
think automatic modules are they a
specific think of the boot layer or can
they do good question
our automatic well that's not quite a
question of what you would ask but our
automatic modules sort of an
implementation feature of the boot layer
yeah it automatic modules quite how
standardized they are and therefore
whether they only exist in the JDK or in
other implementations because maybe you
have a story for migration yeah on the
classpath and what about application
service so I think me wasn't any there
so okay so what about someone else
actually someone else asked earlier
today what about we spoke about modular
jars what about modular war files
modular files how will CDI arranged for
dependencies to be set up all of those
java ee questions remain to be answered
by the java ee eight expert group and
beyond there's a completely fair
question how will app servers take
advantage of this I mean there's the
question of what they how they
modularize themselves just fer just to
protect their own internals and then
there's the question of how will the
various EE standards take advantage of
module declarations and services and all
the other stuff you don't necessarily
show the ball the ball has only just
started rolling thank you Thanks I think
that is it thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>