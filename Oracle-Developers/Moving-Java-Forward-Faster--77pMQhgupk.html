<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Moving Java Forward Faster | Coder Coacher - Coaching Coders</title><meta content="Moving Java Forward Faster - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Moving Java Forward Faster</b></h2><h5 class="post__date">2018-03-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/-77pMQhgupk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so good morning thanks for coming
before we start Java developers who here
develops Java excellent who's using Java
nine eight seven six I or three two any
before six there's always somebody there
there's just a shame to raise their
hands so initial disclaimer everything I
say about the future its plans subject
to change
so don't hold me to it let me change our
plans about me oh I'm a director of
product management with the Java
platform group at Oracle
before joining Oracle actually I didn't
join Oracle I was acquired by Oracle I
was part of the Sun team so I was also
in the Java management team not handling
the JDK before then I anybody ever heard
of the Java store and the Java warehouse
but there's like one guy yeah that's
what I did before joining Oracle after
that around 2010 I was moved as the
manager first of the Java libraries and
a figures after that of the whole Java
standard edition so I wrote the product
requirement documents for JDK 7 and 8 we
don't use that mechanism anymore for
Java 9 and above so there's no product
requirement documents for JDK 9 I'll
explain why in a minute before that well
Sun Microsystems management that's it
about me I'm going to tell you a little
bit about the new release model this was
announced slightly before the release of
Java 9 or a few months before that the
idea is no more limousines thing trains
and what do I mean with that in the
previous model we had these what we call
release drivers the key features that we
decided this is what's going to make
this release interesting and we decided
that when
we're done with the prior one so when we
were done with JDK 7 a few months before
actually bunch of people got together
and we decided hey you're the things
that we want for JDK a and yeah let's
aim for that now somewhere the release
drivers and those were the big you know
the VIP feature and after that
everything else that can fit within that
schedule and when you develop like that
as you probably have already discovered
as you get closer to the release you
know two years into the future yeah
everything can be done right the closer
you get you realize we're not gonna make
this feature and if it was not a release
driver we just push it out until the
next release but if it was a release
driver now we have a problem right and
that meant that you could either pull
the whole Reese for that one feature
even though some other features were
ready or kicked out one of the release
drivers neither of which is pretty so
that was the limousine right until the
major feature was ready everybody waits
now I think more trains they just go out
the important thing is the schedule and
if you don't meet one release you'll get
to the next one oh how do we get there
the previous model the model was a major
race about every two years okay and we
support it for a very long time so you
know you create this very nice stack of
releases that were available at any
point in time I've you'll zoom in and
look at it during the first year and a
half now some people didn't notice we
had minor updates and we planned and
delivered three minor updates or every
major Reese okay and those were spaced
six months apart so under the old model
we had eight eight update 28 update
forty-eight update 60 six months apart
don't get me started on the versioning
you know that's a sore point for some of
us we came up with something a little
bit more logical with nine
so under the old model we would have
released nine six months after the last
update for 8 and after that six months
9.1 and 9.2 9.3 you notice that what
gets into steady mode is not the GA
version right so once we went from 8 to
80 or 20 there is no more updates to the
8 line
now there's updates to the a new 20 line
so when people think oh 8 is available
for a long time in my head I'm thinking
a 260 is supported for a long time a
minor distinction but I'll become
important in a minute so this is the
plan okay but of course you know what
happens right jigsaw wasn't ready we had
to delay it a couple of times so those
two years turn into three years and you
know that's significant you know you
just relay the whole thing including a
bunch of features for a whole new year
and you know I don't show it here but 8
was of course 3 years after the release
of 7 so even though the goal was every 2
years
in reality we ended up sleeping 50% of
the time that's not too good but we
realize given that in theory we have a
mechanism for delivering new
functionality and features every six
months why not do that right now when we
were using 99.1 9.2 9.3 you cannot
change the API on a minor update that's
just part of the JCP rules so we could
only do certain things on those update
releases and we figure yeah we don't
want to do that we want to make it so
that every feature when it's ready it
just gets added to that release whenever
it's ready so let's not call it about
anything let's say 9 10 11 12 13 and
have them on a 6 month schedule
okay now the element near asked me a
question how do you support these well
we cannot support six-month releases for
each one for eight or nine years that
would create an unmanageable stack of
backboards every time we want to fix a
security vulnerability so you know again
we didn't invent anything here we just
borrow from what you know other
platforms and operating systems do and
we introduced the concept of long-term
support so every few releases we'll just
you know adopt you that long-term
support option and we will support that
one for a very long time okay next
question is of course how often do you
have these long term releases and
remember when I said that we were
landing on three years between majors oh
three years between LTS releases so now
we have nine and ten and just coming out
probably by now if you search the
download page and say JDK 1011 is going
to be our next
LTS trees and that would be supported
for a very long time then we have three
more years until the next LTS seventeen
oh good yeah good this is not
retroactive we already had some
commitments we're not going to you know
say well eight is no longer LTS four
seven or six so six and seven remain and
eight remain supported for as long as
they were supported when they launched
okay now that's just the Reece cadence
there's a more subtle though for me at
least an even more important change
which is JDK releases versus open JDK
releases so the way that we used to
develop Java in Oracle was we developed
most of the source code in an open
source repository called open JDK but
open JDK we didn't produce binaries from
it we would grab open JDK we would
add layer on top commercial features
that were only available for Oracle and
will release that as the Oracle JDK so
up to an including JDK 8 Oracle JDK is a
superset of what was available in open
JDK now other Java vendors would also
grab the code from open JDK do the wrong
thing right replace the JVM with the
wrong like IBM does or offer different
garbage collection algorithms that we
didn't and in some cases charge for that
much like Oracle JDK be so we came up
with this binary the Oracle JDK and we
released it under a license called the
binary code license which had two
purposes
it was meant for customers but it was
also meant to be available to the
community that didn't want to pay for
the license and it had some restrictions
well after that so if you read the
binary code license you'll say things
like it's free to use in a
general-purpose computer but if you want
to put it on a printer or on a kiosk or
in an ATM that you need to license right
it also had constraints about how could
you redistribute it and it included all
these commercial features that you
couldn't use unless you license the JDK
from Oracle and for the vast majority of
developers they just ignore that because
hey most people use it on a jumper of
the computer they don't care about the
commercial features but for a handful
this was really troublesome so as part
of this announcement we said let's make
it very clear first of all we're going
to start producing open JDK binaries not
just the Oracle JDK binaries now we
didn't do this on time so that you know
all of those commercial features that
were available only in Oracle they're
not yet there and that's why that little
blue box on nine is smaller it's not
that I cannot diagram right with ten it
gets a little closer and the goal is by
the
time we reach JDK 11 all of those
commercial features that George talked
about will now be available in open JDK
and therefore available to anybody that
grabs open JDK miners
when we get to that point we're no
longer going to offer a jdk under the
current license we're gonna have the
Oracle JDK and their Oracle standard
terms and for everybody else open JDK
binaries under GPL which is the license
under which most of you get Linux you
know it has it's an open-source license
oh good excellent either you're all
follow me or you just like I hope the
first so another way of thinking of this
or the way I like to see it is I now
have a continuous stream of open JDK
binaries that's what I expect most
people will use that has new
functionality added every six months and
it's just tip of the line when pen comes
out we no longer produce updates for
nine we're in eleven comes out we're
done with them or is that in the top
line when twelve comes out we're done
with eleven so that's the you know we're
trying to create two different binaries
for two different use cases developers
want new features from a new
functionality they cannot wait three
years for the next version of anything
on the other hand enterprises tend to
prefer to stay in the same race for a
very long time when I asked that
question about who's using JDK six it is
mostly a developer audience when I do
the same session for large companies I
get a lot of people raising their hands
when I say five or even four there's a
few that raise their hands when I say -
we haven't supported that for years and
yet they're still using it so for those
guys stay in the LTS versions along -
for long term support versions okay now
these means starting with JDK nine you
can now download open JDK binaries from
Oracle we're not saying
don't use Java from Oracle anymore just
use the opportunity once unless you need
to nicest m4m support
so we now produce them really in JDK 11
they'll reach parity until now for most
people that are the same but if you want
flight recorder and mission control you
still have to use the Oracle ones Hey
we have new features releases every six
months let's see what else we're open
sourcing the infrastructure that we used
to build we used to build it in Oracle
machines behind closed doors and just
put the binaries out there now we're
saying the whole infrastructure should
be open source as well so that other
people not just Oracle can use the same
machines to build open JDK binaries so
this is our hope that the vast majority
of users will stop grabbing the Oracle
JDK from Java and go to the open JDK
from work that sound like a tongue
twister to you but I guess it's clear
now right good so what were those
commercial features that now will be
available in open source Mission Control
on flight recorder those of you that
we're here for jars session
you saw him talk about this you know the
tools that we use to know what the JVM
is doing at one time it's a pretty cool
tool application class data sharing
which is the first open source feature
that used to be commercial only JDK 10
the open JDK 10 version includes
application class data sharing if it
sounds familiar it's because we used to
have class data sharing for the JDK
classes what we've added is the
application in front so now your
application class data can also be sure
not just the JDK one usage structure and
infrastructure as I pointed out we're
also going for a late binding of
features now I did this slide in July of
2010 and you know this was when we were
doing the whole waterfall we're gonna
plan ahead of time what's going out
check out when we're doing jigsaw it's
part of JDK 8 it's coming now
in the second half of 2012 and notice
this is one of the confirmed features
you know at the bottom there yeah
because that's a release driver afraid
what happened in reality the decayed
released in March of 2014
not in the second half of 2012 and
jigsaw had to be you know it wasn't
ready or ate it was very painful we had
to move it to 9 and 9 itself didn't
release in 2014 it released September of
2008 six months ago almost to the day so
you know as anybody who's done any large
project knows this is what happens when
you try to set the features first and
then you know real world happens you
have to do other stuff it's not ready so
what are we doing now if I was trying to
get you know some kick made I would say
JDK 9 the last major release of Java
ever and I mean that it's the last major
release we have a list of features that
doesn't fit in one screen or two okay
and if you read through that list of
features in slow motion you will find
that we have support for Unicode 8 you
will also find Unicode 7 anybody care to
guess what happened there we're done
with Unicode 7 but we were not done with
the release by the time we were done
unable to release JDK man it had been
superseded now of course we had Unicode
7 ready why could a developer not use
that sooner we call it you know that's a
marble stuck behind a basketball it was
being held back by jigsaw so 100 plus
features last major ease after these we
are going to have and by the way if you
want to learn more about what's in JDK 9
I'm not gonna you know we don't have
time for that
there's some screencasts about the most
interesting features and you know that's
me at the bottom explaining this change
in the release model right just
searching your favorite engine for
screencast JDK 9 ask the experts with
JDK 10 we only have 12 features now is
these regression
no the new model doesn't change a number
of features that you get in a three-year
period so we're not changing the
throughput we're changing the latency
right if you add all of the releases
that happened in a three years you're
going to get very close to what happened
with JDK 9 but the idea here is it's
much easier to get into this stage by
using the stairs than by climbing
straight here right so instead of giving
you tiers and large number of features
every three years good luck
we're gonna need about a year of overlap
right so that people can migrate from
the old one to the new one we're saying
every six months here's something small
changes much easier to give up this is
much closer to the updates that we had
when we had a debate 22-8 update 42
innovate 60 how many people here noticed
that there were new features on eight
updates anybody how many people notice
that there were new features between
seven and eight or between eight and
nine that's the difference right so I'm
not claiming that they're gonna be the
same because of course they're larger
than an update release but we hope to
make it as easy as an update release to
uptake this new feature releases JDK 11
I mean out just six months from now and
if you look at the list of features it
only has four now I don't think we're
gonna release with just four but to my
previous point that least a little drone
it will not shrink and stop that's
already there will not move of course I
say that knowing that as soon as you
give it an absolute it's very unlikely
that it will shrink there they will move
okay all of those features we think are
ready of course we do put early access
builds out there there is a chance that
one of you guys is going to find
something completely broken but you know
we're a lot more certain of this list
and we ever we're of those old slides
that talked about what's gonna come out
four years from now
okay now this also changes the early
axis one of the things that you know has
to change via these model is in the past
hey I would like to try jigsaw Nick so
is coming in JDK 9 let me get the early
access for JDK 9 right and that's how I
test jigsaw now of course we have a
catch-22 a feature cannot be added to a
release until it's ready a feature will
not be ready until we get some feedback
on it of course the obvious answer is
now we're gonna have you notice that the
bottom of that we have early access not
just for the releases but also for the
major projects so you know I hope this
is gonna make it cleaner we used to have
two different types of people
grab in early access one is large
corporations that were like I just want
to make sure that my program will work
the same in the next version I really
don't care too much about the new
features I just care about backward
compatibility and therefore you know I'm
not going to use bar I'm not gonna use
it I just want to taste and if
something's on a break I want time to
fix it right and you have the different
audience which is I'm very excited about
project Mahalo right the value types I
would like to try that out and I want to
work on that one and give feedback with
the previous model we were not doing a
good service for either of those because
if you just wanted to test things that
work these major release kept evolving
and changing and features were being
added and it was too you know
shifty and if you only cared about one
project you were getting this one
you know binary that included every
other project being work for that
release so you know we hope that this
makes it a little bit cleaner if you
just want to taste whether it will work
just go to JDK 11 or 10 grab that if you
want to know about what we're working on
the future take a look at Valhalla
project CGC and you Anna
other early access binaries to come up
here Oh
hopefully cleaner this all early access
started with JDK 10 before then we had
them with the Oracle licenses now
they're under GPL does anybody care
about the licenses here in some places
some people are very passionate in
others it's like as long as I can get it
I don't really care which ones are you
anybody really passionate about which
license tom using yeah well that's a
good point making sure you're illegal
not everybody goes through the trouble
of reading that new world new deployment
options there's another important change
which is how do I use Java how do I get
Java in there when Java came out twenty
years ago the most common one was Java
on the browser applets right for applets
work you'll get Java at the time from
Sun not from Oracle you'll get your
browser from oh you know from Google or
Firefox or something right and you get
your code from the developer and those
three things Rev at different speeds and
any one of them could do an update and
when everything works no magic happens
and you know everything is fantastic and
Oracle updates Java and you roughly just
got better what has happened then though
is browsers have decided yeah we don't
want to support and happy anymore
is the API needed for applets so that
model is breaking away that's not gonna
work anymore okay even if you factor in
and say I'm just gonna look at Java and
my code the way it basically works now
is there is one runtime on your system
that's the model right and all the
programs share that one runtime and
every now and then about once a quarter
Oracle says hey new version I'm gonna
update everybody to eight you 141 right
and how to update happens and all of
your programs happy now work with the
new version of 80 141 and that happens
every single time right
so every now and then it has happened a
release comes out and hey everybody
works fine but there is one program that
that's what we're fine now it gets
interesting what do we do you know we
could roll back just have everybody go
into 141 but you know that's a security
mobility fix thing do I really want to
roll back what most people did was I'm
just gonna install the old one and now
I'm gonna do this fantastic thing where
I change the code that launched that
program so that it uses that all release
all of the others now have to go to the
next one and it gets more interesting I
also need to have some sort of
protections so that other programs don't
use it all release it's just for that
little yellow one right and a long time
so I call it produces Java 9 which has
new features and of course some of those
programs like yeah we want to use those
new features but others were not ready
to go to 9 so even though the model was
there's one shared runtime which has
some benefits in the end we ended up
with there's a handful of runtimes right
and the developers have to spend or this
is more the administrators because the
developer just rolled that go to the
bottom right they have to do some
workarounds and hacks to make sure that
their program doesn't run with the
latest which is what they want it but
runs with this one specific version so
what we're proposing now is bring your
own Java ok when we came up with this
model Java Runtime was about 70
megabytes that used to represent about
one or two percent of most people's hard
drives one runtime the runtime has
increased in size now it's like a
hundred and fifty megabytes but hard
drives have grown much faster than that
so 150 megabytes now is what point one
percent of your hard drive right new
model is you can tie every application
to its own runtime and if you do that
then the runtime is not
simple to anybody else and your
application you know doesn't get updated
may not break so that's one option you
can still use the previous model of
course but in order to make this issue
would you have a nine we introduced
something called J link and the module
system we create a tool that you know
that's the important tab is the the red
stuff we can create a custom runtime
optimized for your program Oh Oh dick so
we modularize the whole jdk and we broke
apart what used to be this monolithic
this is a version of a runtime - this is
a collection of modules with inter
dependencies you'll say you know these
are just the Java SE modules we actually
ship more than these there's the jdk
modules and others but you know to
illustrate my point
imagine that you write a program that
just happens to rely on two modules
that's all you need right of course
those modules rely on other modules
there's some dependency between modules
but now your program only needs the
stuff that's color-coded everything else
isn't needed now I used to have to carry
it around because with a shared runtime
I don't know what the author program is
gonna need so I cannot trim anything out
I may break that or the program now I
use j-link and I could create a custom
runtime a strip out all of the modules
that I don't need at this point we can
only go as low as modules perhaps in the
future we'll make it even smaller and
you know like get rid of the classes
that you know need but you know it's a
step in the right direction
and here's another subtlety that some of
you may have missed notice that the
application is inside the bubble so your
own application is also included in the
image right so if we go back to my
previous example with JDK 9 or later
I can have smaller runtimes that have
been optimized for that one application
they're smaller and they include the
application so I encourage you to go and
take a look at that option if you like
to deploy using this new model the
applications no longer look like a java
application they look like a native
program it has its cons of course now
you have to update you know if you want
to update the runtime you have to
repackage the whole thing and set it
again but if you're doing something like
docker images on which you were creating
a new container anyways this is probably
something worth looking into
okay George pointed out we do know this
improves security
the most notable use case is hey there
were some vulnerability in one of the
modules that I throw away I don't have
to worry about it right and we don't
share runtimes anymore so updating the
runtime will not break any application
it comes with the application you can
also look into the head of time
compilation so you know Java interpreted
language it runs and it creates the
proper machine code at runtime right
which lets us optimize for your current
situation all right so if you have more
memory you can actually end up with a
slightly different machine instructions
that you have less memory so that's good
but sometimes I don't want that I want
to create the you know like that
compilation ahead of time I don't want
to do it dynamically if you want to do
that you can now use the Ã¤Ã´t Java
compiler and create a custom anthem that
already has the completion now when you
do this here's a trick though don't
forget that you have to do this on the
machine on which you want to run not on
the machine on which you developed
because the code will be optimized for
whichever machine you do this on so if
you develop on a machine with very
little memory you may not get the proper
optimizations for a large system later
oh that's a prototype
people mistake that Ã¤Ã´t they think we
can do it in their own little machine
deploy that doesn't work quite like that
you could it's just not gonna be as
efficient that's what I had for the
release model so we have several other
sessions where you can ask the experts
questions about JDK 9 JDK 10 I strongly
recommend going to Alex Buckley's
session about what's here what's next
these if you weren't here this session
would have been longer and I would have
tried to cover some of these information
but it does a much better job than I do
when talking about that one so with that
I'm hoping that you have some questions
that I can address
okay so one of the questions that I have
is you said that you've eliminated Java
EE out of the distribution I'm just
going to power back and see how is that
being released that's the beauty of the
animations here we go
JDK 11 the third one removes Java EE and
CORBA modules so the jdk used to include
modules that were not part of the Java
ACS specification they were part of the
Java EE specification you can still have
them as separate modules they just don't
ship with the JDK anymore you have a
preview of that because the Java EE
modules were disabled by default in JDK
9 so if you were using these modules and
you try to use JDK 9 you'll say you have
class not known you can toggle them back
on in JDK 9 and JDK 10 we just pass a
parameter and I don't remember it off
the top of my head but that's probably
the most common issue that we found
right I try to run in 9 it blow up in my
face here's the whatever yeah it's
because you were using an EE module you
passed this parameter you're good but
this is a red flag that you will have a
problem with JDK 11 for JDK 11 you'll
have to include the modules from me
directly don't expect them to be there
from the JDK well then the other
question is how would the release cycle
for the Java EE modules relate to the
JDK release cycle and the answer is have
no idea you know we do the java SE e
release model right when we call bundle
stuff that we don't produce there's
always this lag right we grab the
current version at some point and we
include that in the jdk and then the
other thing may release with an update
even before we do so there's always a
bit of a lag that's one of the reasons
why we don't want to shape stuff that
you should grab directly from some other
provider we don't want to thank you any
the question is how alt works okay so
the idea of doing a head of time
completion it would still run on the JVM
I'll just you know that the JVM right
now
no Geo class runs to c1 compiler which
is pretty fast if the class runs long
enough it'll be optimized using a c2
compiler but it'll continue running the
JVM so ahead of time allows you to do
those steps ahead of time I jump
straight to the the code has been
optimized it'll still be run by the JVM
it's not native code won't turn it into
C but the whole part of warm-up if you
will can be saved at the cost of it's no
longer optimized in real time it's
optimized for whenever you did the IOT
now Ã¤Ã´t is experimental
I believe in 9 or 8 you know they start
to get muffled right now it works only
for the Java classes not for your code
in supported more experimental for
everything that's your code eventually
you'll be able to just a ot your whole
application and the runtime parts that
you need does that answer your question
yeah so the question is is there any
performance issues with this and the
answer is maybe right so a OT is a
choice either you optimize at runtime
which has the benefits of it's optimized
for what it's currently going on on your
system right now but you pay the penalty
of having to warm up the JVM or you do
it ahead of time you save the warm up
but you lose the optimization like most
things you know like should I do
parallel should that into serial the
answer is you should probably try both
with the stopwatch and see you know do
you wanna optimize for resource usage or
for speed so there's so many variables
that nobody can reasonably tell you and
now we can give you of thumbs but it's
up to you to decide that okay that
question
okay the question and I'm not gonna be
able to paraphrase the whole thing but
is jayleen going to give me some
advantages you know for the long term
our containers or it may even supersede
the need for use in containers and
j-link and containers are probably
complementary so it just happens to be
that containers is a common use case on
which you don't have common dependencies
and that's the kind of situation that
jailing will help you with you're trying
to create instead of a common runtime
and a bunch of applications connected to
it
single runtime when you do that you know
I'm even careful to say you no longer
have what I call a Java runtime this new
image will not be able to run every Java
program he'll be able to run your Java
program technically or any other that
only uses the classes that you choose to
use right modules so I don't foresee
j-link superseded I need four containers
by the way they address different needs
they just base nicely with each other
very well and I don't foresee containers
going away anytime soon or anything like
that if anything it's probably more
likely that we will move to a model
where continues the memory continuous
integration using containers will be the
norm rather than the exception I don't
know how long that one depends region
okay so the question is how j-link deal
with dependencies that are not just your
code you have Java EE or or hibernate
well the answer is they're still Java so
as long as they have been modularized
jailing we'll be able to use them
anyways now you can use jail ink on a
non modular application the way it works
now is if you wrote your application as
a modular application you can just say
hey J link here's my application here's
the mods j-mods there they ship with the
jdk which is you know like the the
modules that come with the jdk you
figure it out and you look at your
application I'll say Oh since you
motorized it I know which modules you
need I can build an image that contains
that for you you could grab an
application that has not been
modularized and manually say J link
create an image that contains all of
these modules and if you get that right
it'll also create a runtime that you can
use to launch your application it's just
more work for you and more error-prone
likewise you know you can suddenly write
a program using reflection that will
work on a full JDK and failed on a
modular ice J link option if you call
something that you know Watson called
out and it was just generated at runtime
does that answer your question yeah
three minutes any other questions
right so the question is we've made some
improvements to Java running on a
container at a high level
the difference is JDK usually optimizes
based on the memory and the processors
that are available on your system and
what most people running containers want
is to have it optimized to the memory
and processors assigned to the container
before you could pass parameters and say
limit you know the memory to these or
limit the the CPUs to these number of
CPUs the improvements that we're making
it is so that by default it behaves as
if it was running on a machine with you
know recognizing the constraint number
of CPUs or memory that has been back
ported some of it I think the memory one
I'm sorry the CPUs one has been back
ported all the way to eight there's
further enhancements in that same idea
that our enhancements that are probably
going to go into JDK 11 as they are not
ready you don't see them yet on the JDK
11 page but if they're ready for
September of this year they'll be there
for 11 if not 12 or 13 team whenever
they're ready
yeah correct so yeah if you don't pass
the the the proper flags to diversions
that don't figure it out for you
it'll just you know in hog memory or
processors because you'll assume that it
has the whole machine which is what it
was meant to be sure no problem
okay my recommendation for the upgrades
from six to eight or nine remember when
I said the Java nine was the last major
release I do expect that you will have
to have some word to go between major
releases now seven to eight was well six
to seven there was a lot of work being
done on seven you note since six was out
for such a long time right it shouldn't
be that painful seven to eight should be
almost seamless I haven't heard of any
major complaints between seven to eight
it's only good news nine represents an
inflection point because with nine
there's some change in the list of
supported platforms for example we no
longer do 32 bits we no longer do arm
and some of the internal api's that were
meant to be used by the jdk to implement
the official api's right people were
relying on the internal api's with jig
so we have the option of hiding those
and I can produce you know archives of
son pages from 95 telling developers
don't use the internal API
show of hands how many people think
people actually follow that advice had
didn't use the internal ApS even if you
were very diligent in not using internal
api's libraries and frameworks weren't
as diligent and whatever wise or virtue
is available in a library that you
choose your program now has that vise of
virtue so there's a bunch of people that
rely on internal api's because they use
log4j right going from anything prior to
nine to nine or above will probably run
you to that problem having said that in
this new model point from nine to ten
it's really very small going from ten to
eleven really very small so as long as
you keep up you're not going to have to
do that big jump that I said at the
beginning you always have small steps
what I recommend is even if your
intention is to stay only on the long
term support options
always you know check your code against
the current one and if there's any
tweaking that needs to be done do that
at that time that way you'll see
everything small you know easily
chewable pieces six months apart as
opposed to finding this large number of
changes every three years does that
answer your question
yeah I'm sorry we had some noise in the
back and I think we're on time so I
understand if anybody needs to you know
like bolt down and go I don't know if we
have lunch after these or anything but
if you can repeat your question I'll try
to address it
correct and what we recommend is always
try to compile your first try to run
your all code on the new one without
even be compiling right most cases that
work the next step is try to compile the
new code with the new version your all
code with the new version of the JDK our
modus operandi is we try not to break
people without a warning so you might
see warnings when you're compiling in 9
that means it won't work on 10 okay if
you skip that part and just go from 9 to
11 you may see things break without one
okay or if you ignore whenever you're
running and you do something that we
think it's silly we'll will print along
and say you shouldn't be doing that
most people that I speak to they're like
yeah we ignore that like sorry about
then not giving you warnings leave you
ignore the warnings okay oh thank you
then</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>