<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Learning Scala? Learn the Fundamentals First! | Coder Coacher - Coaching Coders</title><meta content="Learning Scala? Learn the Fundamentals First! - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Learning Scala? Learn the Fundamentals First!</b></h2><h5 class="post__date">2015-06-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ugHsIj60VfQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">um I think the first thing I want to do
I know this is a little bit annoying but
could I get everybody to just stand up
for a second sorry I know if you got
laptops and stuff but this is really
good so all the people who have written
a line of Scala you can remain standing
okay everyone who has written an
application in Scala you can remain
standing Wow okay this is great this is
the perfect audience for this because if
you are sorry do you work for typesafe
there okay okay this is the perfect
audience right because this is a
fundamentals type of talk if you know
scholar very well you'll be bored to
tears sorry sorry and this is good
because you know there's not too many
fundamentals talks on Scala a lot of
them are we you know we assuming you
know the language some of the ins and
outs and then okay let's talk about
monads now for the next hour and
everybody's eyes glaze over so that's
not what this talk is about this is me
I'll have the slide at the end as well
if you ever want to get in touch with me
just some quick plugs I run a podcast
called the basement coders podcast
mostly Java but other technologies as
well
I run a JVM programming group back in in
Winnipeg which is up in Canada and then
I own this company called grind software
and our flagship product is using Scala
so why did interest there um so I became
interested in Scala both four years ago
and essentially it was becoming very
popular we didn't have the even I think
the notion back then of Java ever
supporting something like lambdas which
is all the rage this this conference
right you know I just thought this would
be like any other language and I just
dive in and we start being productive in
few weeks but I was sadly mistaken
because it was a paradigm shift big
paradigm shift I I had no exposure to
functional programming I decided maybe
you know one week in University when we
covered that in an non imperative
programming or something like that um
like Lisp or something right and I just
went yeah I'm not gonna touch that so it
was a whole new paradigm for me and so
when I started getting into it the kind
of the de facto answer to people that
would ask the question why why should I
program in Scala what's what's the big
deal you know it's it's it's a new it's
a new paradigm it's it's it's kind of
hard to understand from a newbies
perspective and the default answer was
well you can just write it like Java if
you want right this is anecdotal right
this is me saying I think that's false I
think that will basically work if you
never have to touch a library from a
third party right might work great at
first at some point you're going to have
to interface to the rest of the scala
community they're going to be using all
these nice tricks and ways of
programming that you're going to look at
it and just go this doesn't look like
Java at all
so I always give this as an example of
you know this is probably one of the
first lines of code I kind of saw in
Scala and I just kind of went like what
is going on here like this what is going
like what's Scala and what's is there
library code here I don't know what's
going on like is Emma a key word I don't
know because there's spaces there and
there's no I don't know what it is so
here what I'm here to explain today is
that you know if you study some of these
simple concepts that especially in the
Scala syntax
they have big impact over the code that
you write and the code that you're going
to be seeing so here's some basics so
this is like the the basics slide here
so if you're not familiar with Scala at
all if you want to so in Java land we
would have getters right for properties
in scala we do have a getter it's
defined like this right this is a
function called some prop it returns a
string and here's the body you know
there would be something probably just
passing back a field value but the way
that your your user would access that is
just by simply using a dot and then the
name of the property so it looks very
like Rubeus ruby s for our javascript
esque right there's no get some problem
so similarly in with setters it's very
natural you just assign a value to a
property what happens in behind the
scenes is you know it will call a setter
function well actually you know I got
this wrong because there's supposed to
be an underscore here it messed up the
slide but there's a special are actually
underscore equal there's a there's a
special way that you have to create a
setter in Scala so that the language
picks up that you actually want that to
be a setter
I apologize I'll update the update the
slides but but yeah essentially it's
very natural you just assign a value to
a to a property and your setter will be
set this would be how you define a
variable okay so you have a variable you
want the name to be some bar you want
the type to be some type so use a colon
pretty much anything after a colon in
Scala is going to be the type of
something and we're going to assign it a
value and just so long as that value is
type compatible with some type we're
good to go
Scala is a statically typed language so
you know if your types are wrong at
compile time not at runtime right Ruby
person would probably have to write a
bunch of unit tests and figure that out
or just hope you know I run time to just
oh I assign something that was a screen
to something that was an integer I
didn't really mean to do that
but I digress so if you want to define a
class again these are just the basics if
you wanted to find a class that's how
you define a class that is a class
that's a valid piece of Scala code
doesn't really do much because what
happens is you know I can new that class
and I can pass in a value for that
constructor argument that's listed here
but it's not exposed to the outside
world I wouldn't be able to for instance
assign a value or read a value from this
property okay so that's probably not a
great example if you use this nice well
there's two ways to view this but what
you'll see is there's this special
keyword called case if you put case in
front of your class declaration and it
has an argument you get a getter in this
set
well yeah you get a getter for free
setter I think you probably have to use
another keyword to say that that's a
writable property but you can new that
class and then you can read what the
argument is and hopefully when you read
this argument it should be high because
that's the value that I put in the
constructor so that makes sense so far
it's very concise very compact so you
know there's more to the case keyword
than that but you can you can think of
it as a nice keyword that gives you a
bunch of stuff in your classes that you
would normally have to set up yourself
okay so another thing you'll see in
Scala this is very confusing I should
also mention that this val keyword just
make sure that this variable is
immutable once you set it to this value
here it can't be set again in your
program this is important in functional
programming but you can think of it like
this the compiler can actually use that
information to reason about your program
and actually make it a lot more
efficient if it knows that this is never
going to be assigned another value
anywhere in your program because it
can't it can start doing things like
making things referentially transparent
so any time it sees your variable some
var mentioned elsewhere in your program
it can just actually stamp the value
that it was an originally assigned to
right there so it so it can does some
efficiency for your when it's compiling
so what we're going to do here is we're
actually going to drop the new keyword
you can do that because in Scala if you
can do this for free if you made sure to
put case in front of your class
declaration you get what's essentially a
factory method on what's called the the
object a companion object of your class
companion objects are where all your
static methods are stored so in Java
we're used to putting static and
instance methods in the same location in
a file in Scala what they did what they
add to active that out you put all of
your instance methods on your classes
you put all of your static methods on a
companion object so it creates a
basically a factory method that will
accept the same parameter that you set
up in the constructor and produce a new
some class instance for you so you can
you just get to drop the the new they
just think of it and then this is how
you would declare a function on a class
so you always start with the keyword def
for definition right defining a function
you name it and then you have an
argument list and again anything after
the colon is going to be a type so on
and so forth this isn't part of the
syntax this is just I'm saying you can
have more than one parameter if you want
it to on your function usually you do
and then another colon and then here's
the return type and then you would set
that equal to the body and you'll forget
to put that equal sign there inevitably
and things will not work too well in
most cases and hopefully the the error
message will be clear enough that it
probably won't be but it will be clear
enough that you have to put an equal
sign there that's something new to Java
programmers right so that's that's the
basics if you have anybody have any
questions on any of these basic things
okay this is a good little cheat sheet
so what a little cover now is a
fundamental concept in Scala called the
tupple so tuples are like lists but
lists are contain a bunch of the same
type of thing right you have a list of
strings of a list of ins a tupple is
actually different it's a it's a set a
fixed size of things you have maybe a
tuple that has two
it'll only ever have two elements but
those two elements can actually be typed
differently so you could have the first
element being a string the second
element being an int and you specify
that by saying the first element should
be a string the second should be an int
not like how you'd have to do it with
lists where you just say everything's at
gather laying object and you know figure
it out at runtime so that's what the
tupple is and it has it has special
syntax in Scala to be able to define its
function sorry define its type and
special syntax to actually instantiate a
tupple some people call it tuple as well
but yeah you can think of it as a
container for other data types and I
like to use this example if you're
familiar with Japanese food there's this
concept of a bento box you got a nice
little box and it has a bunch of
discrete little things in it right
so you can think of the bento tuple as
being maybe this is an instance of a
bento tuple the first element is going
to be sashimi the second element is
going to be anything that's onigiri and
you might have a you might have a
hierarchy in your application that looks
like this I've been told that not only
Gary isn't sushi as sashimi is actually
its own thing but you know I'm a
foreigner gaijin guy so who cares right
but here's it here's a bent here's how
you define a bento box in in Scala
so we name our variable here and we have
this special syntax for saying I want a
tuple or a tupple that the first element
is a sushi and the second element is the
sushi and I'm going to assign that to an
instance of a tugboat right so the
instance of the tupple that's a special
syntax and not creating a new tuple
class I'm laying Scala do that in behind
the scenes right so basically anything
between parentheses is going to be a
couple so are they primitive types no
they are not they're syntactic sugar and
I kind of promised myself I wouldn't use
that term because you hear that all the
time with Scala but there it is it's
instant syntactic sugar so in
behind the scenes there's it's just
classes there's a tupple class that is
that has type parameters on it for a
tuple that takes two elements three
elements four elements five elements
right but it just has special syntax for
how what the type definition is and what
the instantiation is so this is a type
this is a tupple type this is an
instance of a double yes sorry they are
the same types yep yeah like this is
this is the type definition this would
be like string int my class this is this
would be like the new string new int
kind of thing right so this is like I
want instances of a tuple and this is
here's here's what this tuple looks like
right and we'll see as we we go farther
in the demonstration that you can
actually you can actually leave this off
if you wanted to but scholar would try
and infer what type this variable is
going to be but you'd actually actually
inferred and go oh this is a this is
this is a tupple that is a sashimi and
only giri on the giddy and not the
generic you know parent class sushi and
sushi right that makes sense
yes
yes if if sashimi and only giri were
work case classes yes you could I think
there might be some syntax where you
might have to put the friends after to
say this is the norc's kind of maybe I
can't remember but or you you would
actually provide your own factory on
your honor on a companion object that
you created for it yourself
yeah okay okay so what is a what does a
temple class look like well there's 22
of them can anybody guess why there's 22
tupple classes in the scala library
exactly a couple of theirs you can make
a couple of 22 elements I guess yeah
because there's no zero tuple I guess
but wouldn't be too useful to have a
couple that doesn't have anything in it
but yeah there's a tupple class for
every for every era T allowable in in
scala for tuples so you have double one
tuple to topple three tuple for up to 12
22 and this is what it looks like this
is type compatible with what we had on
the previous screen where we had that
nice special syntax for defining the
tupple type and an instance of a tuple
this is the exact same thing it compiles
the same way yes
Oh arity is just the number of you can
think of it as like the number of
arguments to a function or the number of
elements in a list so if it's a
narrative - there's two things in a in a
list okay so if you were to if you were
so inclined and you went into the scala
sdk you look through the class library
you would find there's a class case
class defined as tuple - this is how you
do type parameters in scala so in Java
we're used to using angle brackets for
type parameters for generics this is how
you doing scholar use use square
brackets and so we have a case class
tuple - and the first type is going to
be T 1 T 2 and
then the parameters that you passed to
it better be
you know the first parameter better be
of type t1 the second parameter better
be of type t2 and it names those two
elements especially it names the first
one underscore one and the second one
underscore two so that you can get
access to it after the tupple is created
okay so I have an example of that if I
were to create my Vento box and I wanted
the first element out of it
I could just say bento underscore one
ugly let's do this a little bit better
we can actually unpack a tuple way
easier by binding to variable names so
this is a tuple bind
so we're saying here's a tupple now I
want the first element to be put into a
variable name first the second into one
name second and you kind of get like I
remember this from Perl and I remember
going cool you know but this is very
nice very consistent yeah this is a
little ugly so make sense so if you had
tupple 22 I guess you'd have an
underscore 22 that you'd have access to
so if you have a tupple 22 you might
want to look at your program and see if
you can maybe refactor that a bit so
let's let's go over some essential
syntax unless somebody has a pressing
question about tuples why would you use
a tupple well they're actually used all
over the place one good example I can
give is you want to you want to return
more than one thing from a function
right maybe you're writing some kind of
some kind of code that returns a
response code like an HTTP response code
and the body or the error message so you
could return a tuple where the first
element is always going to be the error
or the status code the second is going
to be an error message if it exists but
yeah they're used all over the place in
Scala and it's kind of one of those
things when you when you start using the
language you realize that yes
it's not key-value yeah you can't index
them other than going dot underscore one
dot underscore - yeah that's cool
are they mutable good question uh yeah I
guess they are if you use Donnelly
yeah yeah thank sorry
why not 42 hmm I'm not sure like if you
actually if you actually look at the
definition of the tupple in the library
you see that they are generating these
things there's not somebody didn't
actually type in all 24 I don't know why
they picked 22 I'm not I'm not too sure
okay you can you can put you know if you
you can contribute that as a patch
here's the other 22 tuples okay now now
I've contributed to Scala so so here's
some some essential syntax that you
should know functions that take exactly
one parameter so you have a function it
only takes one parameter there's special
rules around this stuff and when you're
beginning in the language it's really
helpful to know what these rules are
okay so a function that takes exactly 1
parameter can omit the parentheses
around the parameter the arguments right
so we have no parentheses here we just
said you know there's a instance of a
class called util it has an echo method
and we're going to pass it hello we can
use braces instead of parentheses so
again you know I can use braces this
kind of just makes it look more like
like if you're creating a DSL
domain-specific language for something
this kind of makes your function look
like it's part of the the Scala syntax
we don't need to put a dot so there's no
dot here so I have a class instance of a
class it has a echo method that takes
exactly 1 parameter I don't have to put
the dereferencing dot again this kind of
just makes things I mean when when you
see other functional programming
languages this is a very common pattern
closure for instance you don't have you
have a lot of parentheses oddly enough
they're not for argument lists you
usually have a function and then you
just kind of list the parameters you
know separated by spaces after it
so very common in in functional
programming to follow this standard and
the return values
oh no okay and the return value of a
function is the last executable
statement of that function so in our
echo example we would have a echo
function it takes a string and basically
we're just going to put s on a line by
itself and Scala will evaluate that and
go oh that's a string and it will pass
that back as the return value if you
have an if if-else statement well you
have to make sure that the last
executable line of code in the then part
is type compatible with the last
executable line in the else because this
is a statically typed language right if
tries to figure out if you're doing the
right things with types at compile time
and everything should work we you'll
notice that we left off the type here
like we don't actually know what the
type of echo is that's because we're
letting Scala infer it and I have more
information on that later but just if
that looked weird if you thought I'd
minted something know what skull is just
smart enough to go well you pass me a
string I'm passing it back
probably the return value of this
function is this ring yes void functions
it's called in Scala it's called unit so
you'd make your return type of type unit
and then that's basically avoid that
there's also a dirty trick that they
don't recommend you do but you can you
can leave off the equal sign there and
it will assume that the return value of
your function is unit yeah so let's
remove some of the syntactic sugar from
our example you know that kind of like
what the heck example so we can add in
our parentheses so now we're and we can
add in this dereferencing dot and we can
see that there is an instance of a class
I call them the variables called am
there is a map function and that map
function takes a parameter we don't
really know what this is right now
because we haven't covered it yet but
you can see adding in some of the
at syntax that was boiled away makes it
a little bit more readable to to the
layperson or to the Java you know Java
initiated so a concept that we weren't
too familiar with in Java is that
functions are actually types they're
first-class citizens as they say in
Scala so a function that takes an int
and returns a string that's a that can
be actually expressed as a function type
if you tried to say say if you have a
function that is expected to take it int
and return a string and you try and
assign it something that doesn't do that
at compile time you'll get squigglies in
your IDE I feel like I should have a I
should have like a shirt that says Scala
and then like with little squiggly red
underlines I like squigglies because it
tells you all this stuff at compile time
not when you're running the thing so so
it's something that I was going to say
we are used to or we were used to not
something that we were used to because
with Java 8 we have lambdas now come so
we're starting to think of you know
functions as as things that aren't just
there on a class and kind of that's all
you can just invoke them now you can
kind of pass around functions in in Java
8 through function literals lambdas
right so but functions are in Scala are
like tuples they have a special syntax
for type definition so you can create
classes of functions you can say I want
to create a class of function that takes
an int and returns a string and I only
want things that are compatible with
that type to be able to be assigned to
that that function or if I'm using that
as a if I'm passing a function to
another function and I want it I want to
define that the function I expect to be
passed is one that takes an int and
returns a string I can now do that
because they give us an special syntax
to do that and instantiation so function
liberals or lambdas right we have
special syntax for that in Scala
well let's see it so type definition so
what are function types well what what
would be a function will we classify a
function well it's the number and the
types of its parameters that you're
going to pass to it along with what the
return type is going to be that's what a
function is number so the arity and the
types of the parameters and its return
type that's what a type a function type
is so let's see that so in Scala this is
how you would tell Scala hey this is a
function type where there's one
parameter everything on the left hand
side of this arrow one parameter that's
an int and we're going to return an int
so if I were going to create a function
literal so I'm going to I'm going to
define the function somewhere over here
where the ellipses is I'm going to
assign that function to this variable
named add one and I actually want to
specify the type well I'm saying that
add one can only accept a function that
takes an int and returns an int yes
sorry exceptions that can be thrown from
the functions they would still be thrown
yep
it's our way to specify trying to think
in this context if there is I'm not I'm
not too sure checked exceptions they shy
away from the checked exception actually
you do exceptions a little bit
differently I'm not covering that in
here but hmm maybe I'll give you some
some tips on that after the presentation
because we can go down that rabbit hole
but we wouldn't have time sorry there is
a
the ordering is important as well and I
mean the ordering is basically based on
the first parameter has to be of this
type the second parameter has to be of
this type it doesn't care what it's what
the parameters are called per se just
what the types are yeah great okay so
function that takes two ins and returns
a string would look like that here's the
function type so you can imagine that
you know normally when we declare a
variable this would be something like
string int myclass something like that
well you can just dubbing this and this
is saying that you know maybe this would
be add to would be a function that takes
two ins an Intendant int and returns a
string I don't know why you know that we
add two isn't a good example of that but
maybe a sub string or some function like
that concat okay have it right there
here's so this function here is sorry
the concat function would be a function
that takes two ins and returns a screen
and we'll get into function
instantiation like function literals and
lambdas to kind of tie this all in
together at the back yeah I'm glad you
asked that can you guess how many 22
hahaha yeah they chose 22 for the number
of parameters you can pass to a function
as well yeah yes sorry I can't hear you
val is just saying that once I assign
add 1 to something anywhere else in my
program where I'm trying to set a value
in to add 1 again the compiler is going
to blow up and say this is this is
supposed to be immutable if I had var it
would allow me to overwrite the value at
that variable so it's it's specifying
immutability
it's a what it becomes is what we do is
we assign that to a function literal
which will we'll get to in the next
slide and then add one can be invoked
they can actually be invoked like a
function so you're you're naming an
anonymous function at this point it
would probably make more sense once we
see that right yes yeah you can do that
as well yeah you can have say it a tuple
that contains other tuples that are
different era T's in each element yeah
you can nest for sure okay sorry all
right
so function instantiation so this is
your lambdas your your function literals
right so here we're I mean this is very
concise syntax we're not using new lines
or anything so this looks a little bit
you know
Genki but what we have here is we have a
variable that's going to be of type a
function that takes an int and returns
an int what we're going to do is we're
going to assign that to a function
literal and I think I have a nice little
demo here so what I like doing is I like
looking at this type of syntax and then
saying if I were to explain this in
English to people what would it sound
like so follow along with the bouncing
boxes here add one is a function which
so the function type takes a single
parameter of type int so you'll see the
inner box here returns a value of type
int anything on the right hand side of
this of this arrow construct here and
it's implementation is as follows so
we're assigning we're using the equals
sign to assign a value to this variable
and what we're going to be assigning to
it is a function literal and what we're
saying in the function literal is okay
you know that in two you told me that
I'm supposed to expect well I'm going to
in my function literal I'm going to call
that X so I can get at its value I could
have put a colon after this and put int
to specify that you know that int that
you're going to send me I'm going to
make sure you know
that I specified to my the readers of my
code that I'm it's actually an int so
they don't have to look back here
because you know they're lazy but Scala
will infer that because I mean the only
only type of parameter that can be
passed to this function literal is an
int because that's what we specified
right so type type inference is coming
into play here then we're going to do
something so we're going to say this
function you know after we specify what
the parameter is going to be named is
going to return X plus 1 it's going to
return X plus 1 because that's the last
executable statement of that function
right so all of a sudden that example
that really ugly example I gave at the
beginning is going to start making a lot
more sense you know tuples you know that
the last executable statement of
function is what gets returned so life
is becoming a little bit better and when
you're looking at Scala code there any
questions on this slide here I didn't I
didn't specify yeah I didn't specify the
yeah I didn't specify the parameter type
I don't have to specify their return
type because it will infer that as well
yes
you think it's uh it's a class
everything's our classes
yeah there's no real yeah literal I
guess it does probably the compiler
probably maybe does some tricks to make
it really efficient and behind the
scenes yeah
it's a class anything with an upper case
at the beginning is going to be is going
to be a class yes part knee braces oh
right here right this is just specifying
that it's the parameter that's coming in
so it can't parse unless I don't think
it could parse it but if you just put X
here without the braces I don't know if
Scala would be able to interpret that is
this is the start of a function literal
I think it needs those those braces are
the sorry parentheses around maybe we
could try that we could give that a shot
but no it's not passed by name that's
that's a little different but you know
what let's do something daring so you
can you can start up the Scala repple so
this this a lot on that's really small
about this and test out Scala very very
fast something that I wish we had in
Java if we do have then Java been coding
in Java for fifteen years so please tell
me about it
it'll make my life a lot easier yes what
IDE do I use I use the Scala IDE which
is just eclipse with a bunch of plugins
yeah so I can show you that later if we
have time too but this is this is just a
quick and dirty way of being able to
evaluate a some Scala and see if it
actually compiles and does what you
think so in our example we had Val add
one and you know I'm going to leave off
the type I know I won't leave off the
types you know it's of type something
that takes an int and returns an int I'm
going to assign that equal to something
that is a function literal where I'm
going to name the incoming Prime
X and I'm going to flesh that out and do
X plus one so if I do that the repple
comes back and says okay Craig well add
one is now a variable of type of
function that takes an int and returns
an int and it's equal to a function one
okay so let's try invoking that so now I
can invoke that it's add one plus one it
returns a two now let's try dropping the
let's go of it that will add 1 1 2 so
this gentleman was saying okay I want to
see if I can drop the parentheses around
the X and see if that compiles I suspect
not but I could be wrong it did okay
there you go
so I could have made my slide a lot
easier by doing that that's okay you
know I kind of like the parentheses to
be honest I kind of like the parentheses
mmm that one I'm going to say no but
then I was wrong the first time but
let's try it okay there you go
you know I'm just going to say that oh I
compiled this examples under a previous
version of Scala where this didn't work
this well defining a function is
actually tying it to a class this is
just we're defining it in the middle of
our code we're assigning it to a
variable yes no there's more than one
way to skin a cat and if you read our
dare skis book programming in Scala
second edition which I highly recommend
he does give some styling tips here and
there yeah yes sir there is who said
that three oh there yeah just a voice
yes series yeah so you can look that up
of Scala - Lang org and you can probably
find that yes oh sorry the question was
was there a language specification yes
sirs
yes yes you know and that might make
sense why I thought it was illegal
because I was using the Scala worksheet
as well if you get this the Scala IDE
they give you this nice worksheet which
is literally just this repple in eclipse
with all the intellisense and everything
you can test out things fast this
gentleman was saying he tried dropping
the parentheses and it gave him an error
like when you define oh interesting okay
some weird language problem I'm not
aware than okay let's get back to back
in this arena around time about 20
minutes about some lots of stuff oh and
by the way like I in 2011 I did a
scalawag which to her where I basically
took all of Scala and tried to fit it
into one hour and it was like a fire
hose and people were passing out and
fainting so this this is a lot better
for like that people's interest they
went home my goodness there's a lot of
stuff in Scala this is
more of like I want to learn Scala and
this is how I should start and some just
some pre-fit say okay so we're going to
have to go through all right you know
this seems so good in school like that
okay okay so how does how does this work
how to function literals really work in
behind the scenes well again we're going
to what Scala does is it boils off the
syntactic sugar that that syntax for
defining a function literal and what it
does is it has those twenty two classes
in its library that are called functions
so there's function zero function one
function to function three so you know
function zero makes sense tuples zero
doesn't really make sense because you
could have a function that doesn't take
any parameters and it defines them in in
order to be qualified as a function in
Scala all you have to do is is implement
a certain function on your class called
apply and what apply will do is this is
your pretty much what you could consider
your factory method if you have a class
that has an apply method it has to be
named applied that's what Scala looks
for and you have some parameters that
function and you have a return type in
to return something you can invoke so if
you create an instance of that class and
assign it to a variable you can invoke
that variable is this as if it looked
like it was a function itself right so
it's a really nice little syntax trick
that they they used so let's check that
out again 22 so when you do this right
we're assigning something that's in that
function that takes an int and returns
an int here's what it does it actually
just squares it signs that function
literal to square int Scala converts it
to this
basically an anonymous inner class right
this is something this is how we kind of
had to do we this is how we had to font
the pass around functionality in Java
right we we would create you know you
have a mouse listener maybe in a swing
app and you want to listen for Mouse
events you would have to create an
anonymous inner class of type Mouse
handler or something like that implement
the events or on click method or
something like that
and then pass it to something that wants
to invoke that handler at some point
this is what happens when we create a
function literal this is what actually
happens it create goes okay there's one
parameter so I'm going to create a
function one class this these generic
type parameters here are saying that
okay that that one argument is going to
be an int and then the return type is
going to be an int in reality you
probably want to double or something if
we're going to be squaring things as the
return value by degress and then we're
going to flesh out that apply method and
all where it all it does is it takes
whatever you put on this side of the the
arrow and just transposes it into the
definition of the apply method so here's
that X type or that X argument here's
the return type and here's the actually
now the interesting thing is this this
is how Java eight was going to implement
its lambdas as well you've probably all
heard of the Sam the single abstract
method interface and it still allows you
to to specify your your function
literals as that but it doesn't actually
go ahead and behind the scenes and
create you a new anonymous inner class
and kind of shuffle around you know the
body of the function literal into an
actual interface method it uses some
tricks with the invokedynamic that I
have to review my notes Brian gets K to
give a good thing on that yes
can you see that yeah you can if you so
if you run the Scala compiler so this is
the address can we actually see Scala
boiling away our nice and tactic sugar
and seeing what actual types are being
created in behind the scenes and fleshed
out yes you can there's a there's a
special flag that's escaping my memory
right now that you passed the Scala
compiler and you say here's here's some
Scala code show me what you're doing
with it before it gets turned into byte
code and you'll see that it's unwrapping
all the syntax and creating structures
like this
it's transposing it in there yeah you
could you could directly write this is
valid Scala code you could put that into
the repple and it would be fine yeah
okay so both these can be called like
that just like a function even though
this is a class you know Scala does its
thing and says oh there's apply method
okay I'll just invoke that right okay
somebody was asking about call my name
you know the reason why I put that in
here is because it might be when you're
new to Scala and you see this contract
you'll be going what is actually going
on here so it's a way to basically
specify a chunk of code in your program
and have that chunk of code passed as a
parameter to another function inside
that function they receive that block of
code as a variable as an argument and
they can choose when they want to invoke
that code okay so here we go you specify
that you want a code block this is
called the call by name syntax by not
putting any input type here just putting
an arrow and then putting the return
type and basically you can now call the
transaction method like this transaction
here's a block of code it that block of
code that executable block of code but
gets
put into this this code variable it's
not actually executed so we execute the
code here right so I'm passing anything
I could have had multi statements
whatever and what I'm saying is you know
whatever you pass me whatever code block
you do pass me the last executable
statement of that code block should
return a boolean all right so we'll
assume that execute returns a boolean
and everything's good
so this code block will be put into here
and then you know we connect to the
database don't show that code we execute
the code now so we actually execute that
function it kind of wraps it up like a
function and then we do our commit or
rollback after that so read it right
away you know I remember when I was
first starting with Scala I saw
something very similar to this and I
went oh cool
Scala has a transaction keyword nope
it's just that they were using this
special called my name syntax okay okay
type inference after a long delay this
is this is something that you know was a
really good selling point for when
people were trying to get convinced to
go from Scala or from Java to Scala it's
smart it knows that if I assign at the
declaration time I assign a literal
string to a variable it's probably of
type string so if I type this into the
repple I would get a response paying
back saying thanks Craig we now have a
variable called s and it's of type
string because that's what you assigned
it to me
similarly we can assign hashmap you know
we do have to put our type stuff over
here and it's almost like reverse
diamond syntax but it will create that
it will it will say okay when I create
this hash Mac the actual type of this
variable M is going to be of type hash
map string it and here what I'm saying
is I'm defining a function called add it
takes two ins I didn't specify what the
return type was so Scala will look at
the last six cubed line of code in this
in this function and it will say I think
the function should return an INT based
on these types or a double it might
decide if you want to be explicit you
can put you can tell Scala no I really
want it to be a double that gets
returned scholars yes yes I guess it's
right there's no semicolon there are
semicolons in Scala you can use them if
you want to but people will probably
slap you you don't have to put
semicolons if you do have a bunch of
statements on one line of code you do
have to put semicolons between the
statements right you can't just use
white space and in that way you you will
always have a last executable line of
code the penny
okay and then I'm not too sure yeah it's
a last statement its last executable
statement yeah so however Scala
interprets that for you sorry yes
and then I want to return they would be
after that you'd have to assign it to a
variable and then put the variable name
on the as the last executable site or
you can actually you could actually use
the return keyword if you want but say
for instance if like Coursera you know
Coursera like typesafe or darsky has a
class on this online education system
called called Coursera you can take
their Scala fundamentals it's actually
functional programming in principle or
something like that and when you submit
your assignments your Scala assignments
for grading if you use return statements
they knock off some points because they
really want you to get down to this
concept but yeah that's how you do yes
oh you you probably have to import it
yeah so there's like you'd have to
import hash map so it's Scott I think
it's Scala collections dot hash map at
the top of your file just like in Java
right you'd have to do import java.util
hash map okay higher-order functions of
Parma you could use the java hash map
yep you could and actually there's a
there's a utility class that you can
import that will interchange so if you
have a Scala hash map and you want to
assign a Java one to the Scala one you
can do that yeah it's very interruptive
Scala is very interoperable with Java
that's one of the powers right that's
how they're getting into the enterprise
is it common when you're interfacing
with class libraries that were written
in Java yes
and I'm doing that for instance I wrote
an OAuth provider I wanted to use Scala
but Google only provides a Java library
so I had to actually use those
conversions okay so higher order
function you'll hear this in in
functional programming terms this is
part of the vernacular in order to be
called a higher-order function you have
to be able to be passed a function or
you have to be able to return a function
one of those two things or both you can
be the uber higher-order function so
funny graphic you know this is inception
this is the the movie where people can
go into other people's dreams but then
the people inside those dreams can dream
again and you can go into those dreams
and you get in kind of things so this is
kind of like the same thing with higher
order functions you can pass a function
to a function that could pass that to
another function that can recreate
another function that can return that
function wraps up in a closure so yeah
so we know about function types we know
about function literals right we can now
construct higher-order functions we can
now pass things because we have the
vernacular to be able to say as an
argument type I want to you to be able
to pass me a function that takes an int
and returns an int we have that and then
as a as another part of the syntax I can
actually create a function literal
inside my function that is returned
because if it's the last executable line
of code that function literal will be
passed back as the return type as a
return value so let's see an example so
again I'm explaining this in English so
we have this function called deferred
tax calculate it takes an employee so
pass it an employee and it will pass you
back a function that takes no parameters
but returns a double which presumably is
the tax that got calculated the function
that it's going to pass back so the
important thing to note here okay it's
got ahead of myself the important thing
to note here is this doesn't get
evaluated right here because our return
type is we expect a function to be
passed back we don't expect the return
value from the phone
to be passed back presumably this passes
back a double we don't want that we
actually want you to pass when when we
choose to invoke this it's going to be
invoked with that employee that we we
passed to defer tax calculate so we have
really slow tax calculator that we don't
want to do right now and I think if I
show I don't have an example of where I
show you how that's going but I could
assign I could call the fur tax
calculate pass an employee and I can
assign that to a variable I can keep
that variable around in my in my program
I can maybe put it into a hash map or
something like that and then at some
later time when we have time we can
calculate the employees tax by invoking
that value and then the tax calculation
will happen so this is called a closure
right because we're passing in an
employee so that's on the stack of this
function but then we're keeping it
around for when we're ready to actually
invoke this function and that value will
be passed into really slow technically
yes at the back
yeah so the the question is I passed an
employee to defer tax calculate I
haven't invoked deferred tax account
like the function that got passed back I
haven't invoked that yet sometime in the
middle between the time that I'm going
to that I pass the employee got the
function back and the time that I
actually invoked the function somebody
calls a setter on employee and it gives
it another value will that be reflected
in that function called the answer is
yes because employee is a reference type
so even if you defined the employee
object using valve right that just means
that you can't overwrite the reference
to the object it passes to you can't you
can't change employee to point out
another employee but you can mutate the
employees you know through their setters
and I mean in pure functional
programming languages they don't allow
you to do that any time you you try and
mutate an object it passes you back a
new one that has that mutation but you
know I think that the people that
created Scala realized that it has to
interface with Java and people are used
to this and you kind of need to be able
to change objects after they've been
instantiated and not just pass back
copies oh sorry yes sir
yeah call it call back is a really good
example so you know you're you have a
service and there's some events that it
creates that it spawns and on those
events you want a piece of your
functionality to be called so a function
of your choosing to be called you would
pass that service your function and
anytime an event happens it goes out
here's my list of functions that I have
to call and it will call them yeah so
see the check the time here we have
three minutes okay I'm not going to be
able to finish but okay let's just show
you some really cool stuff in that time
and get past all my animations ah okay
okay so here's our here's our original
you know piece of ugly code and now we
can kind of boil away some of the
syntactic sugar and show you how it
works I'm not going to explain this
right now because I want yes Oh somebody
sings on the no okay I'm going to blast
past this because I want to show you
something really cool and Scala before
we go pattern matching this is huge okay
with pattern matching we're not talking
just about regular expressions like we
would normally think of in Java you can
actually pattern match against a lot of
ad hoc type of things for instance if I
give you an example I can pattern match
against a string I can say here's a
string I'm asking somebody you know at
that that's going through the TSA line
you know how would you like to be patted
or something so I get their response and
then I match it so this is how you do
pattern matching I'd match it against
these case statements any time it's
scanner I print out that any time it's
pat-down it print out that any time it's
something else
so the underscore is kind of like the
the fill in the blank in Scala
it means I don't know what the input was
but I want to do something when I don't
know what the input was we do that
here's how you would do it with regular
expressions if you tack on a dot r2 any
string it will create it will make that
string into a regular expression in
Scala okay and the way it does that is a
little bit farther on in topic than what
we're used to but we have a list of
strings so this is a nice way to show
you that I didn't need the new and I'm
just creating a list of strings and then
for each of those teams I'm going to
match the team name against my regular
expression when it hits I go do that
when it's anything else I print boo
matching on foo so we can actually match
against instances of objects we create a
person with these constructor parameters
now we want to match to see we want to
match against that that person instance
and any time it was created with Mitch
and Tatar and I'm going to print out hi
son you know Lily at to turn my daughter
and then if it was created with any
other parameters I'll just put this
default thing here we can match against
lists so this is the cons operator cons
operator allows you to take an element
and append it onto a list so we can say
here we have this list of words and we
can match that sentence based on if the
first element was the and then the rest
of it was this we want to print out that
or return that if we have a list that
has a first element and a second element
and then I don't care then we're going
to print out that I know I'm blasting
through this but we don't have time
the really cool thing under the hood is
that you can create your own objects
that work with the the mat the match and
case statement and all you have to do is
is provide an unapplied
method so you can what you can see here
is when we were matching against
remember I created a kid what we can do
here is when you're passed in a person
what we do is we unwrap the internal
fields of that person and we pass it
back as a tuple the match statement will
then go ahead and say do I have a case
statement that matches you know a tupple
that where the first name is this and
the second name is that so it's not it's
not magic you can actually you can get
control it's not something that's baked
into the language
only there are special cases get to
handle you can do that yourself which is
really cool you get that unapplied
method for free if you use case in front
of your class ah that's why it's called
case glasses okay we got to do trivia
because I got stuff to give away can
anybody answer this question by show of
hands it says what's the what's one of
the special syntax rules for a function
that can accept only one parameter yes
okay good come up and see me after the
show second function type that's
comprised of what two things so you're
you're specifying I want yes yes come
and see me after okay that's trivia the
one thing I got to say is please rate my
my session I'd really appreciate that I
did this I did the talk back in 2011
nobody knew how to rate sessions back
then you go to your schedule builder it
shows you rate at the top my session
click on it and then give really good
ratings so this is me if you want to get
to me my slides are right there on
github so you can clone that github
repository and grab my slides thank you
very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>