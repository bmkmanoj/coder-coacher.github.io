<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Building Real time Data in Web Applications with Node.js | Coder Coacher - Coaching Coders</title><meta content="Building Real time Data in Web Applications with Node.js - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Building Real time Data in Web Applications with Node.js</b></h2><h5 class="post__date">2017-10-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/GPz3VY_0bXE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right cool i have 245 let's get
started
before we do some questions for you guys
want to get a better sense of the
audience java developers alright yeah
that's about 80% I guess JavaScript
developers all right leave your hand up
if you're using node alright we're down
to about 10% I would guess okay cool
thank you so this is building real-time
data and web applications with nodejs
but before I talk about that I got to do
a brief plug for another talk that
starts at 5:30 today
and it's time to get excited for
javascript in the database this is kind
of the way things have been going
javascript starting the client-side just
a browser only technology nodejs and
some similar tools brought it to the
mid-tier you're able to use that
language and more and more projects and
applications well now one of the groups
within Oracle Oracle labs
has been working on technology to bring
it into the database and it's really not
just JavaScript that's just sort of the
language that they're doing first here's
a really high-level example and I know
this is going to be hard to see in the
back but what we have here is a standard
npm install' validator validator is a
package that has all kinds of different
validation routines including one which
is is email and you may think all I can
do that and sequel or PLC go the regex
right well turns out if you look at the
source it's actually quite complex some
of the types of validations that they're
doing so you don't often or always want
to reinvent the wheel so we get this
open source JavaScript library and then
we use this new tool here dbj s deploy
and we point to that package and then
point to a database and so what we're
basically doing is shipping that
javascript off and into the database and
then what we can do this is one example
where we're using that code as a
user-defined function in the sequel
engine so I'm saying select email from
emails where validator is email and I'm
passing on a value and filtering out
some rows so if you're interested in
this technology we want to know more
about it and how you can kick the tires
on it
definitely go to this talk at 5:30 today
we have the location here if you'd look
up this conference ID and the in the
description ignore it it's completely
inaccurate what the talk is really about
is this new multilingual engine or MLE
that Oracle Labs has put out there and
one of the cool things I'll just show
you very briefly they also have a web
page out now and this is a rather long
URL I know no one could just get that so
I made a bitly link and it's bitly comm
slash oracle dash MLE so if you go there
it'll load this and what you'll see on
the overview page is a very kind of
high-level description of what this
technology is so Emilee and enables
developers to work efficiently with
database resident resident data and
modern programming languages if you go
to the Downloads tab you'll see that
they've actually put out a preview
release and this is an entire VirtualBox
VM with Oracle database installed with
this MLE technology so you can already
start kicking the tires if you just go
to documentation you'll get some ideas
on how you can start using this and of
course if you attend the session at 5:30
you'll learn a lot more about it they're
cool
enough of a plug let's move on to
real-time so whatever you do don't leave
here and make a purchasing decision
based on what I say my name is Dan
McGann I'm an Oracle developer advocate
I focused primarily on the JavaScript
and html5 communities as well of course
is the Oracle database community my
contact info is on screen we'll make
these slides available after if you have
any questions about this talk or
anything related to JavaScript and
Oracle please reach out I'd love to hear
from you here's a very high-level agenda
we're gonna start by talking about the
past and how we got here we'll talk a
little bit about where we're at today
and then we'll talk about how we mix in
the database when it comes to real time
data but before we get to any of that I
want to do the demo first so we can
spend the rest of our time kind of
talking about how we put it together so
what I need everybody to do looking at
you take out your cell phone and
participate I'm going to give you a URL
in just a moment and I need you to go to
it and you can start cheating now if you
like if you can type this you long URL
but basically I went and found this
website these are the 20 greatest cities
to live in and it was kind of tedious
one of those we have to hit next next
next or I guess you could have done view
all but at the end of the day I got all
these and I loaded them into a database
oh no did I delete them that would be
bad
they're all there let's try re-freshing
if that doesn't work oh no this is
terrible so this is running in our
application container cloud service just
on the off chance that it's something
simple I'll try to restart service
yeah it was something simple okay so
basically you're seeing all the cities
that we've loaded in and what you're
seeing on the left is a ranking and
everyone's currently tied for first
because there are no votes yet and then
you'll see the total number of votes for
that city and then a button that you can
use to vote for the city and what I want
you to do is just come in here and vote
for your favorite city by the way anyone
here from Germany Germany has five or
six cities in here you guys are doing
something right for sure personally I'm
going for Munich I'm a fan of beer
they're coming off the heels of
Oktoberfest but we'll see who wins all
right now here comes the URL so it's
right here bit ly slash Artie - s F
that's for real-time San Francisco and
I'm gonna stay on this dashboard page
while you guys do the voting I'm gonna
feel a lot better once we see at least
one vote come in real quick I'm gonna
come over here
nothing's coming in yet let me make sure
I didn't break something else oh alright
never mind we're we're in business folks
all of a sudden Zurich is taking the
lead note Toronto's overtaking Zurich we
have Berlin going in second with Bern
coming in third
Amsterdam's got a strong lead now
they're coming in first with Toronto
gone by second Berlin's coming in third
burns dropped to fourth
all of a sudden Toronto's taking the
lead doing pretty good at anyway let me
describe you a little bit what's going
on here
so we have total votes submitted and
that's each vote you're doing that
numbers going up we have updates pushed
and what I want you to see is that this
number is much lower than the total
votes submitted Wow Berlin's doing
pretty good tell you what while you guys
are rocking the vote I'm just going to
come over here and do a little bit of
work I don't know if anyone here is
familiar with Apache benchmark but you
can see what i'm doing here i'm doing a
benchmark method post keepalive
concurrency 100 number a thousand and
i'm pointing it at some crazy URL I'll
hit enter and it'll launch hopefully
correctly go go go let's try that again
oh man I was hoping to cheat and put in
a bunch of votes from Munich but it
looks like that's not gonna happen at
any rate pay attention to this number
five thirty five and forty eight what
I'm gonna do is enable a trigger which
will stop the voting I learned the hard
way that if I don't stop the voting
everyone will keep voting and they won't
pay attention to me
onew
cool
voting has ended looks like Toronto won
with just under 600 votes very nice very
nice all right
3,000 votes submitted only 58 updates
pushed let's talk about how the demo was
put together so we'll start with how we
got here it was actually almost exactly
20 years ago that we got HTTP it became
a thing in 1997 it was a simple request
response protocol so the browser issues
an HTTP request to the web server
usually something like Apache it's going
to read a static file it's going to take
the info and send it back down as an
HTTP response the web browser which then
renders in it displays it to the user
over time we realized we could do some
cooler stuff and what we did is mix in a
database
so the browser still sent an HTTP
request to the web server the web server
then issued a database driver request to
the database the database sent back some
data
the web server used that to generate a
dynamic web page but still sent that out
as an HTTP response now some of you were
thinking no actually Dan we use
transactions we're an enterprise who our
flow looks a bit more like this and you
know what we have to shard our databases
globally and we scale our web servers
based on CPU and memory utilization or
doing all that because we got a whole
lot of users so our traffic actually
looks a bit more like this I get that
that's like the reality a lot of folks
are dealing with today but the
principles we'll talk about here can be
scaled down or scaled up rather we can
just keep it simple here
so at this point when the response makes
it out to the web browser and a way that
web browser is now in sync with the
database right you could say it's almost
like a cache of the database data but
then you know what happens somebody goes
in they issue some kind of an update to
the database and it's changed and now
the database is change like different
it's more up-to-date than the web
browser now for the longest time we've
had the ability to issue an HTTP request
to the web server to let the web server
know that there has in fact been a
change but what we've not been able to
do is also let the web browser know we
can't do that it was impossible for good
reasons related to security and thus
began the quest to simulate this kind of
thing all right now raise your hand if
you're guilty of one of these I'm guilty
of all of them so it all started with
the forever frame we'd like have a
hidden iframe and your web page and use
that to request new data when you got
data you'd proxy it up to the parent
frame that actually works all the way
back to ie6 and then Microsoft gave us
Ajax so we could do this more
appropriately we start just a little
timer and we would just keep polling for
new data but problem with that is you're
sending a whole lot of requests to the
web server and ultimately the database
where there were no changes so it
doesn't scale very well if you weren't
Google or somebody and you had a lot of
end users it wasn't going to work well
for you Ajax long polling got a lot
better because then you could establish
a connection to the web server and you
could just keep it open and then when
the change occurred you could just send
the response and then establish a new
connection so it got a lot better but
still wasn't great things started to get
really good with html5 server sent
events but that kind of got over looked
by some newer better technologies which
brings us to where we're at today so now
we have WebSocket and web RTC and WebRTC
stands for real-time communication you
might think this being a talk on
real-time communication that's obviously
the technology I use to do the demo
right
no I use WebSocket WebRTC is really cool
though the idea with WebRTC is you're
going to enable direct peer-to-peer
communication so if you're doing any
kind of streaming audio and video
between clients or if you're doing video
games that kind of thing where you don't
want the latency involved with a
middleman then WebRTC is the right tool
for the job it is a little bit more
complex in that you do need a turn
server to get the clients connected
directly and there are various services
for that you don't have to host your own
turn server you could with node it's
kind of fun but not necessary and anyway
I use WebSocket and I use WebSocket
because what I was trying to do is
simply send a change out to the client
in a real simple fashion and when you
look at web RTC I've been doing this
talk for a few months now and I've
actually seen a lot of red go to green
so it's getting a lot better but if you
do look at the percent right now global
it's about 69% of clients are supporting
web RTC this may or may not be a problem
for you
but for me it wasn't exactly what I was
looking for when you look at support for
WebSocket we're up to about 90 to 93
percent so this is much much better
unless you're worried about supporting
Opera Mini in which case you're kind of
in trouble so I went with WebSocket and
here's an example of how WebSocket works
so online to hear weirdo variant
declaring a variable and we're setting
it equal to a new instance of the
WebSocket and you just specify the path
to the server your WebSocket server and
then you have a new WebSocket instance
and it's an event emitter so you can add
some event listeners and so here on the
open event when we get this event we can
actually send data to the server
hello server or when the message event
occurs we get data from the server and
the data is just a property on the event
object itself now that you understand
how WebSocket works I want you to forget
about it because it's a very low-level
protocol like all good protocols are but
it's also very tedious to work with
instead I recommend you work with a
higher-level library such as socket IO
socket IO
is great it comes in two parts you're
going to have part on the client side
and part on the server side and I'll
show you how that works here in a little
bit one of the cool things about socket
IO is it supports some of those older
tricks that you saw so if the client
doesn't support WebSocket it can fall
back on a long pole which is nice so
it's almost like its own little protocol
but it'll favor WebSocket unavailable
has all kinds of features multiplexing
rooms so if you're needing that kind of
stuff that's built in but another one
that's really important I live in New
York City you get in the subway you get
out before you got in you had that
persistent connection right you get out
of subway it's gone well socket IO will
start pulling for you establish the
connection again it's all built in so
this is definitely what you want to
start with when working with WebSocket
all right so we're gonna see some code
here let's get into it
anybody heard of Oracle jet cool a lot
of hands that's great so Oracle jet is
Oracle's client-side toolkit for
JavaScript applications
and what I did when I developed this app
I did it in two parts so I have the
client in the server and the client is
an Oracle jet based application and I
created it using the CLI so basically it
creates a bunch of stuff for you makes
it real easy you get like grunt scripts
and all this kind of stuff basically I
do all my dev here in source and then
when I'm ready to push it out to
production I run a little script it
creates this web directory and that's
what ends up going on the file server
but I'll show you real quick we'll just
go in to source and we'll look in the
JavaScript directory and everything in
jets going to start with main so this is
what the main file looks like and you
can see the jet is using requirejs for
its module system and most of this is
just default jet but this line down here
is not what I had to do was go download
socket IO and there's various ways you
can get it and then I had to make it
available client side this is the client
side part of socket IO and so I expose
it here and I also have a shim here and
once I have this IO this module is
available then as IO so what I then do
is I create another module and this is
about as simple a module as you can
imagine this one is an app socket module
now the reason I've done this is because
I want a single WebSocket connection to
the server I don't need multiple we can
proxy everything through it so to get
that single instance I need something I
can share around the app and so I bring
in the socket IO module I instantiated a
single time so we just have the one and
then I can expose it via this return
here and then we can share this app
socket module everywhere with me so far
any questions I should have said if you
have questions as we go feel free to ask
all right so then the next thing that's
relevant the way that jet works you have
two directories you can switch this up
but you usually have view models and
views and so the views go and views I'll
show you what one looks like this is the
page that everybody was on what's your
favorite city everyone that was doing
the voting so you saw this at the top
and then you have this unordered list
it's not a regular unordered list
reusing data bind here this is jet
syntax it's a jet ListView component and
it's data comes from this thing super
city's data source and this is a
reference to a memory structure that's
in the view model which I'll show you in
a moment the other relevant thing here
is this template I'm using and you see
the template ID here that points to this
here so this is a template so for each
element in that data structure it's
going to create a list item and then you
can see through this like you're seeing
the name the number of votes and as we
go further down you've seen another
Oracle jet component for a button that
was the vote button and when you clicked
it we invoke this function up float
again all of this functionality is
defined in the view model so if we go
back out the way it works by naming
convention the just have the same name
so if I go into super cities J yes this
is that view model I was talking about
you can kind of see what they look like
so I'm bringing in that app socket
module the reference to the socket IO
instincts so that I can use it in here
and what you're gonna see in a jet view
model are various lifecycle functions so
this particular one gets invoked when
you navigate to this view and what I'm
doing I'm using jQuery AJAX method to go
out to an API and get some data and I
should say that I actually have two
api's one API is the API that everyone
here was using that's the public API but
I also have a database API and that's
how the database is able to let no js'
know when a change to the data has
occurred and you'll see more on that in
a little bit so once I get the data I
sort it and then here's the reference to
that in memory representation of our of
our cities it's just an array table data
source and that has a reset method so
when I first get the data I just shove
it in there and then if you look at the
bottom here you'll see that reference to
the socket IO instance and I'm saying on
cities dot change and I'm gonna get the
data from items
and all I have to do is parse it and
then invoke that datasource change
method and pass in the latest and
greatest data so what this is going to
do is update essentially the array and
then of course the view is going to
update to reflect the current state of
the view model right so that's how that
you know the the chart was updating and
that's how if you were voting you would
see the numbers change and all that kind
of stuff that was just happening live
the other relevant thing here here's
that up vote function when you did cast
a vote basically I was issuing a post on
another endpoint with the city ID at the
endpoint was vote so that's how the
actual vote went in so the next thing I
want to show you taking a step back from
the client side app let's get into the
server side so here we're going into
nodejs and remember when I mentioned let
me go back to the client
I mentioned that I run a script and it
creates this web directory here for me
well if you look and the server side app
you're going to see that same directory
I basically just copy it over because
those are the static files that I need
to send out to all of you so I have to
upload that as part of my node app and
then just dish amount of static files
when you go to the website but the node
app itself starts here with the end XJS
and so this is a pretty standard node
web server and bringing in the database
driver for Oracle and remember I have
the public API in the database API just
in separate modules so as we come down
you'll see I'm using Morgan for logging
I'm using JSON body parser here's the
Express static reference and it's
pointing to that web directory might be
WW sometimes and this is essentially
emulating Apache right for the static
files a little further down I mount the
public API is router on slash API and I
mount the database API router on
database API but before I do that I
passed the webserver itself into the
database api's init method and I'll show
you why I do that it's actually right
here here's the init method and the
webserver coming in now I'm bringing in
socket
this is the server side the nodejs
socket IO that we need so I bring it in
and again just a single instantiation is
enough and then I had this reference and
the only reason I did this in this
module so that I had this reference I
could have put in a separate module and
shared it like I did in the client side
but at the end of the day I needed to be
able to refer to the single instance and
here's that omit so this is where I'm
omitting the event that you saw on the
client side and passing along the data
that I want to send to the client and
this gets invoked when the database says
there's been a change and I'm going to
talk about that in a little bit but are
there any questions yet so far so good
all right
so let's talk about mixing in the
database and it really doesn't matter
which database you choose to use you're
going to need two things to make this
work you're going to need some kind of
evented system and you're going to need
the ability to communicate when an event
occurs I'm an Oracle database guy I
really know practically nothing about
other databases so I can't say how that
would work there but I can't I ad work
in Oracle the first thing most folks
think about when we think about events
an Oracle it probably triggers and
there's all kinds of triggers in Oracle
one we could have used as a DML trigger
like before insert or after insert so
when an insert occurs on the table that
holds the votes I could use that as the
evented system maybe what I'd have done
is created this trigger so after insert
on that table for each row and then in
here I'm going to talk about the
implementation of communication later
but yeah I'd communicate with node and
let it know that a change has occurred
but this would be really bad can anyone
tell me why blocking yeah to a certain
extent it's blocking really what's
happening here when you think about IO
and IO occurs in different layers we
often think about IO is starting at disk
but actually your level 1 your level 2
level 3 cache that's Li oh your your Ram
is also IO but those are so fast we
don't usually think about it we think
about it when we get to disk and of
course an insert is going to be disk IO
right well what we don't want to do is
add some kind of network IO on top of
disk IO of course and everyone say
Oracle's so slow right no it's just a
really bad thing to do so maybe we could
use scheduler this has been around for a
while - a really cool package for
scheduling jobs we used to have DBMS job
that's been deprecated and now it's
scheduler and it's super cool you can
create jobs to do any kind of thing like
if it's a PL sequel block you can just
stick in an anonymous block here and do
something awesome and this repeat
interval accepts a calendaring syntax
that's really advanced so you can
schedule all kinds of things to run as
frequently as necessary but what's
interesting about scheduler is that you
can create a job that doesn't
necessarily run periodically you can
just call it on-demand
when you want to so what I could have
done is created a procedure to notify
nodejs and we'll talk about the
implementation later but then I could
agree visited the trigger and I could
have said okay we'll make it an
autonomous transaction and rather than
actually do the network i/o here which
would be blocking instead we'll create
job and invoke that using a job and so
basically scheduler spawns a job behind
the scenes and takes care of that on a
back on a separate thread or process
that could have worked it's not the way
I went on the opposite end of the scale
maybe too complex for what I was doing
we have a feature that a database known
as advance queue advanced queuing or a
queue and this is a really cool really
flexible queuing system you can use it
as point-to-point you can do pub/sub you
can use it in many different ways it's
durable by default which means we do
write to disk a lot of queuing systems
these days are in memory you can switch
this to end memory about where Oracle
write we're gonna we're going to be
durable by default and it has a really
neat feature called notification so when
something is N queued you can have a
notification lets you know you can
invoke something you can notify
something that kind of stuff that was a
little advanced for what I was doing
here just a really simple demo and while
I was looking through all the different
options I had I came across this feature
that I had no idea was in the database
but it just was exactly what I was
looking for it's called continuous query
notification and this is super cool so I
don't really like the API so much is a
PL sequel API you've seen here but what
I'm doing up top I'm declaring it a
variable and the type is CQ notification
registration info wow that's long and
then I instantiate it here and I'm
passing in notice it says callback this
is the name of a stored procedure that's
pretty cool you're seeing callbacks we
think about callbacks with node and that
kind of stuff they've been in Oracle for
a long time and what I'm doing here I'm
using the new registration start method
or procedure of this package and passing
in my registration info object and then
all I have to do is
open a courser which is a query and
close it I don't execute the cursor I
open it which registers the query with
our registration object and basically
what is now happening Oracle is going to
start to monitor the result set of the
query and if the result set changes it's
going to invoke this stored procedure
make sense pretty cool right so that's
what I ended up using as far as events
go now when it comes to communication
we've had for the longest time all kinds
of ways to communicate out from Oracle
database to the mid-tier from UTL tcp
and HTTP to mail protocols like SMTP and
Mail I didn't go with any of those I
went with Apex web service does anyone
heard of Apex yeah nice decent amount
basically apex is application Express
really cool rapid application
development tool for the database and
because it needs a bunch of packages we
get this one for free Apex web service
because most folks these days are doing
rest communication you can do rest with
UTL HTTP you it's just really tedious so
I recommend you use Apex web service you
can see how simple it is here now you're
seeing the implementation of the
communication piece right
so when notify the server is invoked by
cqn it's going to use Apex web service
make rest request and now I point it at
the node.js server but the database API
and I just do a simple get that's all it
takes take a quick look at that so the
best way for me to show you this is
actually just to kind of walk through
how the user was created so in the
sequel scripts directory
we have the creation of the user so I
created this user J Sao demo that's
JavaScript and Oracle that's my blog and
then you're seen this is a bad practice
don't do this at home what I'm doing
because since 11g the database is being
hardened more and more right so you
can't just make Network call outs all
willy-nilly there's an ACL in place so
you actually have to open up the network
to certain users on certain ports and
whatnot I'm doing something like a power
user thing I'm just giving this user
access to make call outs on any port any
domain that kind of thing
but it works so the next thing I do as
that user is create all of the metadata
but the first thing I do is I install
logger and hopefully at least some folks
here are aware of logger this is a
really cool it's an open source tool for
PL sequel logging so you don't have to
do your own implementations this is done
really really well very performant
highly recommend you take a look at it
but I installed logger because I needed
to debug when I first started with this
what was going on with cqn and invoking
the procedure and because it was being
run as a background process I couldn't
just do it so you had to have like a
when others then and kind of log what
was going wrong so that's why that's in
there but then I create the two tables
insert the data here's the trigger I
used to shut down the voting and then we
have an anonymous block here and this
looks a lot like the example you saw a
moment ago except that I'm actually
using some of these parameters so if I
go back to the demo app do you remember
this high number in this low number if I
sent out a push to the client for every
single vote that you guys were doing
this would not scale very well at all
that would be bad the way I was able to
get this number much lower and therefore
more scalable was using this feature
called
NT FN grouping so here I'm specifying a
class of time and here I'm specifying a
1 which is 1 second meaning that all of
the changes that occurred to that result
set from cqn all the changes that
occurred over a span of one second were
treated as
event therefore it invoked the procedure
here only at most once per second makes
sense so then that procedure is defined
down below it looks again a lot like the
example you saw before only here I'm
hitting on an HTTP endpoint when you do
that from with an Oracle database you
have to have an Oracle wallet set up
with the cert so it makes sure that
you're actually communicating with the
right web server no man-in-the-middle
attack kind of thing and then down here
you see the one others then and this is
how easy it is to use log or just logger
log and you can figure out what's going
wrong so that is pretty much everything
and I'll revisit actually really quick
the web server or rather the database
API
so when cqn would invoke the stored
procedure the stored procedure would use
Apex web service to make the rest
request this endpoint would get invoked
and all I didn't then was loop back to
use the public API to get the latest
data and then emit that over the socket
IO channel just send out the data so now
you kind of have the complete picture of
how the demo app was put together
now the only other thing I'll touch on
is native driver support because I have
a background on PLC go that's really
where I started but frankly using that
API was was not fun
both the stored procedure as well as the
cqn technology I didn't want either of
that to be NPL sequel and what I'd
really like to see is native driver
support this is actually in Java by the
way so like with JDBC I believe you guys
already have this we do not yet and node
but this is what it could look like in
the future and this goes back to that
safe harbor statement from the beginning
this is an make believe API for now but
hopefully it'll be implemented in the
near future
so rather than PL sequel like you saw a
moment ago this is how it could work I'm
in node land I use the node driver to
get a connection to the database and
that connection comes here there's a new
method on connection called create
subscription the same parameters you saw
before so I can do grouping by time and
specify one second it's just a lot
easier to work with in JavaScript once I
do that I get the subscription object
and I can then use that to register
queries that I want it to listen to and
when the results set of the query
changes the callback could also be
implemented in JavaScript just handle
query change which is defined below and
of course we could then use the driver
just go back at the latest and greatest
data and then he met that out all from
JavaScript land without having to do any
PL sequel this is what I'm hoping we
have in the near future cool so the only
other thing I'll show you is on the end
of the slides if you're interested in
learning more about any of these
technologies that kind of separated the
links in terms of the tiers and so if
you get your hands on the slides
of course we'll upload them and if you
want I have a few cards left happy to
give them to you if you want to email me
you can just click any of the links and
learn more about the various
technologies I talked about today
any questions
No all right thank you all very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>