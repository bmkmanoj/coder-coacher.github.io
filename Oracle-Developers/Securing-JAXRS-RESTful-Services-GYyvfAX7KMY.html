<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Securing JAX-RS RESTful Services | Coder Coacher - Coaching Coders</title><meta content="Securing JAX-RS RESTful Services - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Securing JAX-RS RESTful Services</b></h2><h5 class="post__date">2015-06-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/GYyvfAX7KMY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">we'll come to the session about security
in jax-rs I would look would like to
introduce myself my name is Marisa
fukusa and I'm a software developer in
Oracle I work in on Jersey project with
/ Jersey is reference implementation of
jax-rs one of the tasks which I was
working on recently was migration of out
one from Jersey 1 to Jersey - and also
adding additional support for out - to
Jersey - this is my colleague McHale guy
- he's also developer in the same
project in Oracle in Jersey team I will
start and after some time
McCarver continues so what we are okay
right now monitor is right from Oracle
and we can continue this program agenda
what we are going to talk about today we
will firstly give you some introduction
to security and to jax-rs I actually
actually suppose that you know at least
something
Applejack's RS and then we will continue
to describe you something about the
clarity of security and there is a new
feature in Jersey which is called entity
filtering kamijo will talk about those
topics a little bit more and it can be
used for security is quite nice new cool
feature we will then describe something
about security in jax-rs client and then
we will continue is out one and finish
our presentation without - okay and we
would also like to ask you to have
questions at the end you don't have time
for it so some interactions - jax-rs I
think you probably know what jax-rs is
it just Java API for handling store web
services there is a new jax-rs version
mmm
jax-rs - lot of atrocities as a part of
Java EE 7 in May so it's quite new and
there is a reference implementation of
this rock solid which is Jersey - we
will be showing some examples on Jersey
- this is why I'm mentioning it
basically restful web services are
services which are based on basic HTTP
methods like guard post and delete you
can choose between multiple
representations to get your resource as
aged as a HTML or JSON XML and so on
and there are a lot of other properties
like you can use caching restful web
services are stateless and so on so we
will now take a look and some simple
example of jax-rs resource I hope you
can see it there is a student resource
which is resource available at the
student part there is a jax-rs
annotation of part and it has two
resource methyl gut and post so it means
you have a URI of the one resource which
can be student API slave student / atom
which is one of your resource you can
actually here get it or you can post new
student if you would like to get it you
need to spouse parent which is in this
case atom so this is basic jax-rs
resource and now we are going to talk a
little bit about how to secure this
resource how you can secure your URI
space like it so this and so before we
start talking about it we need to define
two basic terms which you probably are
aware of very well so first term is
authentication what authentication is
it's identifying who the user is in our
case it's to identify who is the client
who is using our REST API on the other
side so we need to you find out it's an
entity usually it's done by username
password as you know and there is
another part after you identify who to
use race who is the client then you need
to define the authorization rules
authorization is about
which part of your API can be accessed
by particular users in particular user
groups so in a HTTP they are basic these
are actually two methyls how to
authenticate user using HTTP basic basic
authentication which is like old very
old it's not you in jax-rs or sorry as
tulip services you are just sending
using basic HTTP authentication your
username a password in the HTTP header
so it's only base64 encoded it's not
encrypted so everybody who can spy on
this request can see your password so
it's not secure therefore SSL is needed
for this communication and there is also
for example actually be digest
authentication method which is a little
bit more complex it's using cryptography
to encrypt your password and add
signatures to your duo requests so let's
go next what we have you can one of the
basic ways which can be used in securing
of your jax-rs services and your URI in
namespace space sorry can be to use a
security of servlet container which is
you can define your the XML as you know
for example for normal web application
in your app XML you defines that you
would like to use basic HTTP
authentication method and you just
defines at all all you arrived space in
your rest allocation will be secure will
be accessible or nofollow administrator
so this is quite simple however if you
would like to live with this so this is
authentication and this deals with
authorization if you would like to
define more granularity on your
authorization than your web big summer
is getting bigger and bigger here we are
defining to http different rules for
HTTP method post and get and forgot we
allow administrators and user to access
it for post on the administrator can
access
so mm-hmm as you can see the coat is
becoming larger actually you would also
need to define some complementary
methods to disallow to access it if you
would have really complex your as API
this lot of resources then epic similar
will be very long and also another
problem that it will be quite fragile
because you can array easier and make
mistake in this one another problem it's
maintenance if I for example change the
part of student to something else than
this the security will not work anymore
and I know I still need to keep it up
up-to-date and synchronized so there is
this are disadvantages which I spoke
about the last one images which is quite
interesting in jax-rs is that it will
not work always there are components in
Jack our Jack sorry sorry pre-matching
filters which are able to change your
URI rec request sorry we are I offer
your request during processing of
requests these are for example tranching
filters and therefore you are securing
something else and which is actually
invoke at the end so if you would like
to secure jax-rs services you can do it
like that is done like that but this is
not the best way the great advantage is
that it's managed by container you don't
need to care about it it's working it's
good
so standard actually what we can do and
- what is the improvement how to solve
this problem jax-rs provides you
security contacts which is interface and
it defines metal similar which you can
find for example you know
httpservletrequest you can check we can
get user principle on check if user user
a particular user is in some role sorry
the currently logged user is in some
particular role and so we can inject the
security context into our resources like
we have it here I'm not sure if can you
see it if I'm ok so here is the security
context injected by context annotation
and
we use the security context to check
inside the reserves method if user isn't
here or admin if it is not we just throw
not authorized exception 401 if it is V
return the data which are requested so
you can actually put your authorization
check into each error source method this
is working but still you can see lot of
code it's like old style of coatings are
new approaches to do this and McHale is
right now I'm going to talk about it a
little bit more how to saw it in nice
thing so hi I'm Hitesh and I'd like to
do and I'd like to show you more
convenient way to restrict access to
your jax-rs resources or resource method
then Meera just show you this approach
will be annotation driven we believe
security annotations that are already
present in Java EE it will be
annotations from javac sanitation
security package we currently support
permit all deny all and rocksalt
annotations and in order to use this
feature you need to have custom security
contexts beforehand the other thing that
you can you need to do is to set rules
allows dynamic feature that is present
in Jersey core server in your
application and basically you're good to
go
so how to register roles are dynamic
feature is shown on this slide basically
every jax-rs application should have
extension of jax-rs application class in
it we're gonna we're gonna here use it a
resource config which is Jersey
proprietary class and it brings to you
some more convenient methods to register
providers resources and so on so this
was the first step that you need to do
the second step is actually to annotate
your resources and resource method with
security annotations as you can see on
this resource class we have a permit all
annotation on this class which means
that all resource methods that are in
this resource class that do not override
this permit all annotations are
basically allowed to be executed by any
user that is is in any role that you
have in your application the other
methods the other resource method is the
post method on the bottom of the slide
and we have annotated this with roles a
lot annotation and admin admin role in
it and this means that this method can
be only invoked by a user in which is in
admin role if some other user that is
not in admin role will try to invoke
this method it will Jersey runtime will
which on a 403 response status which is
forbidden so there are two things to to
to define access rules on your on your
resource classes and resource methods
you need to register roles dynamic
feature and then you need to annotate
your resources with security annotations
and basically you're good to go yes
which annotation parameter all its it's
part of Java EE it's it's it's not in
Jax RF so the next thing I'd like to
talk about today is a new feature in
Jersey its entity filtering feature
which basically introduced a convenient
way to reduce the amount of data send
over the wire from client to server and
also it allows you to define access
rules on your entity classes or on your
entity classes it this feature at the
moment only works with Jason media-type
and Moxie Jason provider but it should
be mentioned that this feature is pretty
Universal Universal it's not hardwired
to any media type and we plan to add
more support for other media types and
other third-party medium modules so to
mention some ideas and motivations about
this feature as I as I mentioned in
imaging you have an application that in
in which you want to expose only a part
of your domain model or only a power
only a set of fields the darkened
currently present in your entity classes
for for input and output these leads to
reducing the amount of data and are sent
over the wire you can some some
requirements was that to define your own
field filtering rules based on current
context this context can be resource
methods it can be resource class it can
be value of some query parameter and and
so on but we're going to focus more on
assigning security access rules to
properties of your entity
versus the last but not least this
feature allows you to prototype and the
Bob little bit faster since you have
only one model you have only one place
to define security access rules and you
not forced to create a separate data by
components for your for your model
entity filtering feature in Jersey is
also annotation based you can create
your entity filtering annotations via
entity filtering mathematicians but as I
said we're not going to focus on this
we're gonna focus on use of security
annotations also from a jokes annotation
security package all of them mentioned
annotations are supported so permit or
deny all and rows out and you need to
also have your security context set
beforehand you can use this feature so
in simple space there are three steps
that you need to achieve to make entity
filtering work the first is to define
dependencies on Jersey and the filtering
extension module the second is the
second part of the first step is to
define dependency on Jason moxie media
module the second step is to register
your security and the filtering feature
in your application and the last one is
to annotate your domain model with
security classes with security
annotations and you can as well annotate
your resources and resource method with
these annotations so imagine you have a
jax-rs application with modo with some
jax-rs resources and some security roles
and you want to define access rules to
your security to your entity classes to
properties of this entity classes and
for example to to your resources
as I said I'm gonna I'm not gonna cover
the first step which was the defining
dependencies I'm gonna skip to two to
the second step where you need to
register the security and the filtering
feature in your application this feature
also registers the ROS allowed dynamic
feature so you don't need to register
that separately imagine we have some of
in our application we're gonna have two
entities one would be restricted entity
the second will be restricted sub entity
the first one will have free fields the
first will be simple field the second
will be permit old field and the last
will be mixed field which is style which
is of type of of restricted sup entity
which also which then contains two
fields one is manager's field and the
second is user field we're gonna
annotate this domain model with some
security annotations so we're not gonna
update the simple the gutter for simple
field with any annotation and this means
that the simple field should be returned
for should be returned to the client or
sent to the server every time a
restricted entity is is used the Gator
for permit all field is annotated with
permit all annotation and this also
means that every time a restricted
entity is written from from the server
or is sent from from the client to the
server this field should be part of the
entity get mixed Gator is annotated with
rules allowed and
there are miniature and user roles in
this annotation and this means that get
mixed field is only returned for users
that are either in manager or our users
role the restricted sub entity then
contains two fields one is for manager
annotated with add rows allowed to bid
manager roles in it and the second one
is the user field that is annotated with
rolls out and user role in it as I
mentioned in our application we have two
we have several jax-rs resources I'm
going to show you two one is one is
called unrestricted resource and we are
returning and we're returning our entity
in application Jason media type and we
have there one resource method which is
called get restricted entity it's
annotated with get annotation which is
part of jax-rs standard and on this
resource I want to show you that entity
filtering works even if you don't untie
your resource classes or resource entity
or resource methods with security
annotations it's it is it is able to
check the the the roles that are defined
on entity classes against the security
context the second result this is the
second resource is restricted resource
when we have two methods and the first
one is parameter method which is
annotated with parameter or annotation
and this method is allowed to be invoked
by user in any role the second one is
rows allowed methods which is updated
with rows out and manager role in it and
this method is only allowed to be
invoked by by a user that is in managers
role
so let me show you this designs on
sample
sorry okay so here I have the sample
I was talking about in my IDE and here
are my restricted here is my restricted
entity here is my restricted sub entity
here are my resources and here is my
jars application the only thing I didn't
mention is that I have also security
request filter in my application which
which basically sets custom security
context to my application and this
context states that every user that are
trying to approach any resource in my
application is in role manager so you
can see it's sorry right here so I'm
gonna switch to my terminal and I'm
gonna run the application it's it's a
simple java application which contain
which starts Grizzly server and to the
server our application is deployed so
here you can see a list of resources
that our application exposes I'm gonna
show you two resources one will be the
unrestricted resource and as I mentioned
from the front of fields from our model
a simple field permit all fields and
then from the mixed field managers field
should be returned to to the client
and here you can see the output we have
permit oilfield we have simple field and
in the mixed field we have managers
field since our user is by default in
managers role and sorry the second
resource I'd like to show you is our
roles allowed which involves the growth
allowed method that you could see on the
slides and it should basically return
the same entity since this method is
annotated withdrawals out and manager
user in it and manager role in it so
here you can see we have exactly the
same entity returned to - to our client
and did this was entity filtering
feature that is that you can try right
away its present in Jersey 2.3 and your
any comments on on this feature will be
welcomed I'm gonna now Mira is gonna
talk something about securing Jax's
client and then he will talk about alt
one and all
okay yes before we switch it I would
like to tell something to your question
you asked if it is part of jax-rs
actually those annotations are really
part of Java EE on the other hand if you
would like to use it it you will need to
have some specific support from Jersey
jax-rs doesn't define support for those
annotations so for everything which
Michael has shown you need to have Mouse
registra special features actually this
is quite important because jax-rs even
check solace to dot oh it doesn't define
too much about security so what we have
in jax-rs 2.0 and we just we already
covered is security context which I
shown you at the beginning and the
second thing is that Jack's are is to
dot added some support for for the
client for security on the client and
using this using Jack stylus you can set
up your SSL configuration to your client
this is new injectors are astute Oh
basically it's quite easy you are using
your client builder and you set you can
setup your pistol trust or or SSL
contacts into your client builder
sometimes it might be complicated to
build assess assess or context so
therefore Jersey provides you Assessor
configurator which is utility class to
create your security context you can
even use environment variables to set up
set it up correctly so now I'm I will
show you
it's very badly seen you can see it a
lot so basically we are here using SSL
configurator which we we set up the
trust or key store also passwords for
all stores and then in the next step we
get the client builder which is normal
jax-rs
jax-rs builder then we call jax-rs
method ssl context and we just used a
social context which we get from our
Assessors configurator
but you don't need a sucessor
configurator to call this metal t just
for our convenience so this is what
jax-rs to doto edit and now we also
speak about
another thing I told you that you can't
let your container to perform the
authentication for you for example HTTP
basic authentication but on the other
hand you have client and you need to
client to authenticate to this server so
that is again nothing in jax-rs but
usually how it's being done those things
in jax-rs you usually have some filter
which is adding your authorization
headers so in this case also Jersey have
has some filter it's HTTP basic out
filter you just create new filter
instance and you pass the username and
very secure pass or one two three four
five and then you build new client and
again in the client builder for example
you can register your filter and then
your client is initiative is this filter
so it means for every request that photo
will be executed and if you are
accessing for example our resource
authorization header will be added for
each of your request you can also use
HTTP digest filter if you like so and
then again everything can be done on the
background so this is how you will opt
indicate your client okay so we have
covered already authorization
authentication we cover the client
security and now we are going to look at
alt and we will start without one
firstly we establish very basic and
general principles of using out and why
it is needed probably I know most of you
already know definitely when we want to
use it in the basic scenario which I
describe is you have client which up the
decades against your service provider I
get some let's say against some server
in out we call this service service
provider is something which is exposing
rest api's and so stress VI as IPS can
be used by clients we also have your
resource owner which is the user if we
get some real example from leader board
this can be Twitter and this can be user
using Twitter and has some Twitter
account and user can use some REST API
to getting the data actually it's not
exactly at on the box is just example
okay so what is all about
we get some sales party which is called
in all this consumer it is another
application
who would like which would like to get
some also use service providers API to
for example get your tweets and you
would like consumer to use those feet
tweets so this is basic principle you
would like to give access to consumer to
access REST API on service provider on
your behalf and get some data and you
would like to work it like that so you
have one wave this is like motivation
example you can give consumer your user
name password which might be okay in
some cases but in most cases of course
you just don't want to give your user
name password - every - every
application which you have on your
smartphone or just to other side part a
web application so we would like to have
some different solutions one of these
solution can be that and this is how I
like to explain out that you would
actually release a special password for
this cost consumer so this consumer will
not use your username password but you
will just create new one something like
sub account for your consumer also you
will like sometimes need to differ defy
restrictions for this account so you
will say okay I this consumer can access
my services but I would for example like
to export only let's say my tweets on
Twitter but nothing else so this you
can't do this username password the
another program is username password is
when you want to change username and
password you would have to change it
everywhere so when you have more
password for each consumer you will just
can change your password and all those
others will stay same you can also then
easily revoke access for one consumer
which you can do can't do if you give
them only one password so this is
described or I said if you give password
to have problem its revoking Casa access
password change you can't limit access
and the basic principle is just because
you need to trust the
- give it your username/password
okay so all this solving exactly working
exactly in the way which I said it's
actually doing something like giving
your sub-accounts like giving your
special password for each consumer you
know this is called access token and so
in or out mmm you can authorize every
consumer every consumer makes an
authorization process and at the end it
gets some sink which is called access
token in alt one it's access token
access token secret but basically it's
some credentials with which consumer
keeps on their side in all tweed so we
don't have any other source password
sharing you can revoke access to any
consumer and anytime and you can define
also it is depend it depends on provider
if provider supports its service
provider you can for example a limit
access to only some part of the API okay
so some details about how out one works
so you have actually there are two parts
I would like firstly to start with this
one I have authorization process which
is which is the way of issuing those
access token service I simply it is the
way when user gives the authorization he
grants access to the cell to the
consumer to access service provider and
second part after everything is done
service consumer already has access
token done consumer can use it so access
token to access service provider and
this is what we call authenticated
request so we have basically two parts
to solve involved and everything which
is going which is happening amount one
is based on based on signatures it means
that every request is signed using your
secret value of your token so you note
one you have access token access token
secret and use balls to you just
construct our message out there out
optimization harder and power
it is signature which is based on
cryptography but you need to know your
access token secret so this is something
which your consumer will keep secret and
use it for signatures okay now we are
going I'm going to show you simple
authorization flow so this is process of
granting the access in out one firstly
we start with the flow start okay sorry
I didn't say I'm saying authorization
flow actually note one it's called of
the organization user grant process or
something like that I am using the
authorization flow which comes from out
to specification so firstly we start the
flow Y consumer asking for something
which is called request token it just
identified or communication second part
is that we're a detector user who is
just currently connected to our consumer
we directed it to the service provider
so for example in this case to Twitter
and you will just be displayed with some
nice screen asking ok this particular
consumer is asking to have access to
your I don't know some read on read-only
access to your account and you can
actually say well that's good I approve
of your I decline if you decide to
approve that's the best case for our
consumer then you are a directed back ok
well they're redirected anyway and
consumer now knows you have authorized
him to access service provider so it's
quite good and the last step of the
authorization process is v sub in which
we request the access token
so looks complex but basically
everything what is happening here is
signed by not everything but most of the
requests are signed by signatures
especially those two it's secure
everything is signed by request request
token and at the end you have your
access token access token secret which
you can use afterwards to make out
dedicated requests to service provider
ok so some summary about opt one
it's quite secure I would say because
it's using signatures it's based on
their security keys you have consumer
secret which is secret key of your
application so each consumer has one
consumer a secret secret for one service
provider you are using access token
request token secrets and some knowns
time stamps which protects from
repeating from attacks of repeating your
request and the only problem little
problem is that it's a little bit
complex for implementation and it's
thanks to signatures which it's already
not so easy always to implement so to
address this issue mostly this
complexity issue out to was created out
to actually it's not really it's not
like improved version of out one it's
not as a 2v2 specification of opt one
and added some new features and
everything it's just that it's something
like different approach to authorization
of making this authorization because
basically it doesn't use signatures if
it doesn't looks English signatures it
allows you to implement it very easily
sometimes you can it's very easy
implementation which you can finish in
one hour of let's say so you would have
very big problems we solved want to
implement it it so quick also this one
is not backward-compatible it means
because it's different approach this is
there is no compatibility and how to
defines a lot of extensions and a lot of
points which are unclear so therefore
it's not really a protocol it's more
like framework so even different service
providers I implement out and they have
different really different
implementations which are not compatible
between each other so when you are
working this out too mostly you need to
check to the commutation of service
provider and check both examples are
doing 14 what do you need to do
differently and so on but basically at
the end you are following some basic
process which is good they are in out in
Oh - there are many authorization flows
which
I showed you authorization flow out one
and in out two are many of them also
it's extensible you can define your own
or it can be defined so the most used or
the authorization flow which is similar
to out one I would say is this
authorization code ground flow which is
very similar for similar use case but
all to also define another authorization
flow like if your client would be only
JavaScript client and you would just
need to get some information and just
for a short time and you expect that
your user is still sitting in front of
your browser so then there is an
implicit grant there are also another
authorization flows I'm not going to
cover all of them some of them are
really not secured secure light for
example password grantees will need to
give password to this your username and
password to this authorization flow so
it's very only for secure very secure
application which you really trust so if
I compare out to two old one what is the
different and the biggest difference is
that it's easier for implementation you
can really use some very simple
optimization flow implemented it very
quickly you sometimes even not need any
support but how it works in reality
there are supports for out one and
walked two for unusual service providers
are providing a support for you so it
means you have libraries which you can
use for example in Java to access the
API and authorization flow is inside but
not every provider provides this library
so there are some security questions
which we can cover and it's how much
secure out - is there a lot of
discussions which you can read on the
Internet and for example the problem is
out - which might be a security problem
is that it doesn't reduce any signatures
the only password which you have which
consumer has is access token and
sometimes refresh token I will cover it
later on but there is no secret part of
keys which you weep see security in the
database and use it
for signatures so we are really sending
your credentials the only credentials
over the wire in that case you really
need to use as a cell because otherwise
everybody would can sniff your request
and just get your data so you need to
use as a cell and this might be also
sometimes complicated because of the
configuration of SSL it's and that is
yeah I see the last point there are
authorization flows we submitted
security so you really need to sync
which flows you decide to implement so
if you are a service provider and you
will allow so many authorization flows
then you have two things that you are
maybe really putting there something
unsecured and you need I would say in
out one if you implement a implement
basic optimization flow you can be sure
that it's secure that it works if it
needs the requirement is based on the
protocol then it's great and secure and
out to you need to check more things
more think about it and at the end the
benefit of using Auto is that it's
easier implementation okay and now I'm
going to cover again this authorization
flow just to give you some overview oh
no ok I'm going so just to give you some
overview how it works so we have I am
going to describe this authorization
conquer code ground-floor flow sorry we
have resource owner service provider
consumer again and we start in alt - by
redirecting the user to the service
provider so in out one that was firstly
some communication between consumer and
service provider then again service
provider ask user buying some nice
screen ok would you like to give
authorization ok so user agrees and then
user is redirected back to the consumer
or sending some code inside which is
inside of the requisite of the red
election which is done basically
exchanged with service provider for
access token and sometimes in
if it's defined it's it's not needed
it's really not much but service
provider can issue also refresh token
the principle is that access tokens has
some limited lifetim for example they
can be used only for one hour after next
hour you need to refresh it so we've got
refresh token and then when time of the
token expires you will just initiate
another request and you were just sent
your refresh token some polymers inside
request and say ok please refer with me
another access token so this is how it
works in many cases that you need to
address your access token regularly
sometimes service provider says ok I
don't want to give you a refresh token
if you would like to get a new access
token you need to perform the
authorization fall again in this case
usually service provider doesn't ask
user for another authorization it just
use the using active rockin session and
just automatically approved but this is
how it works
ok so I have covered like basic
principles of out1 out2 and I will tell
you something about how which support we
have in Jersey and then we will look at
demo of implementing code to in using
Jersey again there is no support in
jax-rs
for out two and one so in we have in
Jersey there is a support for alt one
version a which is actually the latest
version and in 30 support for client and
server so you can use Jersey to act as a
consumer and also as a service provider
so which is quite good and there is for
all - we have support for client only
right now in Jersey 2.3 so there is
important to mention if you someone
someone of you were using Jersey 1 - for
authorization flow on client side it's
the IP I was very built it was terrible
to match the same pattern of API for out
to so currently how authorization flow
works in client you just get some object
for example
out one authorization flow and you
initiated some parameters you need to
define endpoints on service provider and
so on and then after you have finished
you have builded that you just call the
start method which initiates the basic
request to service provider cut request
token and it provides you the red
direction or a to which you shall direct
your user and then you just perform your
optimization this is not done by Jesse
you have to do it by also to react to
get some get a response depending on
your application on your deployment and
then last up you will just call finish
which will get results from the get
access token from the service provider
and if you would like to use on the
authenticated request it means you
already have the optimization flow
finish so you will use feature on the
client feature is something which is
these geologies cuz that it will
register basically some filter into the
your client as in as it was in HTTP
basic authentication and after it
authenticated request will be done on
the background you don't need to care
about them ok so now we are going to
show simple demo its application which
is using which oxalis application which
is using all support or to support in
Jersey to get Google Tasks from using
Google API
yeah so basically we have we have here
one resource one main resource which is
accessible for user is the only resource
known to user and it's called maybe can
you show a task resourceful thank you
Thanks
so this is tasks resource as is the
resource which actually has only one
resource method one get method and it
will return the list of your Google
tasks which you have defined in Google
actually so it works when you when you
get this resource on the background the
data will be downloaded from API of
Google and to bulk at the newest data
which you can get so and we are produce
only text HTML for demonstration
purposes so we know how many JSON format
and stuff like that so how it works
firstly when you access the task
it's very only sample application in
real life with implements on stick more
sophisticated but we just check if we
have the access token for this user it's
ray only one user applications this one
so we found out at the beginning that we
don't have access token so we need to
build some redirect URI this is the
array we are I to which the user will be
redirected back after user grants access
to our application on service provider
so we just use some resource on outside
we will show it to a writer for
authorization and then we just build the
outer out to code grant flow using this
builder we set up some parameters we
also set up the scope we are saying this
is you need to read documentation of
your service provider in this case I
found out okay I would like to have
tasks for here they need only access so
I define the scope which I'm going to
access I build my authorization flow and
then I cash it this is quite important I
have simple all services at flow flow so
I store my authorization flow for later
usage because I will need it later on
after the user will be redirected back
to my application and then I just start
the authorization flow in all - it's
quite simple it only provides me
redirection array to Google
authorization view array and then I read
like the user using building response
phase mister direction to Google
authorization array and that's it so
this code is not even executed and maybe
we can go to authorization a source so
after I call this one
you still will be redirected to Google
Google asking for approval user will
approve it until I looked redirected
back so it's user will be addicted back
to back to our authorize method and we
will again get the flow which we start
in the previous step it's actually
different another activist but least we
cash did that and we will call finish in
this finish method on the optimization
flow with a request will request the
access token we will get the some token
result and inside a sec access token
refresh token other things and we just
said the access token we keep it in our
simple service which is some it would be
some database for example this very
simple static metals inside okay and at
the end after this is finished this is
only our rejection resort we read elect
back user to the task resource so this
is the resource we saw previously so
maybe if you can switch back please okay
so this is task resource and then so we
gain again this task resources executed
but we already have the access token
it's not a problem so we can get the
flow we again get the flow which we
cashed it's the same authorization flow
and we get the authorize client which is
for this is method for our convenience
that you don't need to define clear and
client to authenticate request which is
already prepared client and which is
based on access token initial it's
initiated with the access token we
received and we just have some metals I
I think we don't need to show it when we
are accessing the we are accessing the
Google API using authenticated request
is our access token and we just build
some modal maybe can you
screw up a little bit just it just to
mention for you we are using here MBC
support from Jersey so we will be we are
using out templates to make some nice
view for you so we are attending the
model and this is the template template
used for this model okay I think we can
show you the demo how it works
yeah it's application we are just
deploying it to jetty
okay so we have some user which we old
sample user which we use for 40s
demonstration this user has tasks for
Java one was that user needs to create
presentation and sample this is fiercely
and in the second list Jersey - he needs
to upgrade to migrate out one and
implement support for out - so these are
tasks of our user and so now we switch
to the application we didn't cover this
code because it's justice for you to
show the setup every consumer has some
sick consumer key and consumer secret
which is given by Google so after you
register on Google using a API console
you get just two keys which you need to
setup for our consumer it's ray only one
key for consumer and you need to keep it
secret so definitely don't show your
keys on presentations or such so this is
first is client ID which is being
sometimes sent over a request but this
is also client secret which is define it
okay and now what happened after we
defines this one user was sent to task
resource you haven't seen it was very
quick but task resource recognized okay
we don't have access token for this user
so we are going to talk to rise it
people are directed to do Google
authorization page we just say except we
are via your task you know the scope is
shown here and we get back to the
authorized resource it just stores the
credentials or not our access token and
then we go back to the tasks which you
can see right here and this is the
result so we have our tasks shown here
you are just get from Google API so just
and now we have access token so you
don't need to perform outer ization flow
again and again we might we can show you
that it works Weaver for example out new
tasks - displaced
something again implementing per user
so so okay and we refresh the page and
our user also has another work to do
user has to implement entity filtering
for Jersey so it's we don't we didn't do
any authorization flow we just get new
request so how this is how it works it's
very simple sample but shows you how to
use it okay so I think this was out one
of two if you like to use it just get
the sources or just use Jersey if you
find any problems and any if you have
any questions write us on the mailing
list and it's even about security
filtering feature or any other feature
so now we have time for questions yeah
us sorry maybe is there any Mike no
he
who means as I have a client library for
all too
yes
yeah yeah actually okay so I'm not sure
I get your question but I'll go girl
support salt - so you need therefore you
can use support from Jersey for all to
client and Google is implementing
support for out to on the survival site
okay okay yes sorry for just yeah
okay so if another question so okay at
the moment you need to use Moxie for
this we want to mmm
- so protection as well in the future
is it possible
yeah currently we'll need to really
perfect summer if you would like to
define security constraints which he
spoke at the beginning so there is
currently no support which you can use
to define it other way so this video
because this is done by service
container it is out of our scope so we
really need to use if you have if you
have deployment as a serve at your
jessic application so you need to use
you need to straighten up xml definition
okay okay now i maybe i should repeat
questions so so yeah the question was
van outflow which we saw inclined
expires if it is some lifecycle
limitation actually one old flow can be
used only for one authorization process
but there is no time limit limitation
time limitation is done defined to you
by protocol by service providers so they
say for example for out one after you do
your initial request to get your access
token then you have not sure for example
one minute of 10 minutes to just
continue otherwise it expires but after
you finish it you shouldn't use this
authorization for object anymore you
just can get client out of it and just
drop it if you would like to write their
own perform another authorization to
create a new one
yeah yeah exactly I said it at the
beginning actually this is very simple
application it's only one user
application it's very for demonstration
purposes actually how it in a real
project you will just have database and
for each user you would have access
token and for out to you would also
store the expires in or the time limit
so you know you don't need to perform
the request to check out first so we
refresh it immediately okay some other
question actually we just implemented a
client site and maybe I'm not sure it's
maybe in some future releases I can't
promise it right now yeah but but yeah
definitely it might be good to have it
because we have it also for generous
even for old one sorry Oh to answer
can't answer your question sorry
okay so yeah okay let's go yeah yeah so
maybe just one question if okay so we
are running out of time so at the end
maybe if we can switch to another slide
yeah and this is so question answered
ask finish and also you invited us for
another section we can also invite you
for if you are interested in jax-rs and
in Jersey and not only Jersey but index
RS mostly you can visit some of those
presentations one will be more about
entity filtering than also by Michael
and there may be present ations done
specifically on use in jax-rs to toe and
developing key objects RS application so
you are never come to go there okay
thank you very much for your attention</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>