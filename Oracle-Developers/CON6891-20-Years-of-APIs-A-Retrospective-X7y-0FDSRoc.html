<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CON6891 20 Years of APIs A Retrospective | Coder Coacher - Coaching Coders</title><meta content="CON6891 20 Years of APIs A Retrospective - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CON6891 20 Years of APIs A Retrospective</b></h2><h5 class="post__date">2015-12-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/X7y-0FDSRoc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning thanks for coming in to an
early session on the last day of the
conference you're the truly the diehards
my name is Stuart marks I work in the
core lives a core libraries team of the
Java platform group at Oracle quick
introduction since this is a
retrospective talk i figured i should
give a little retrospective on myself I
was not one of the people who worked on
the original Java one point oh I came
into Java sometime after that but I did
work when i was at Sun Microsystems I
did work on some applications using jdk
one point and so I think I do have a
pretty good perspective on on the
history from one point oh and I also
worked on various aspects of the Java
platform for over 15 years personally
before I started working on Java I was a
sea programmer I guess it's hard for me
to say I'm a sea program or any more but
as a sea programmer when i approached
java it was actually really cool looking
at the one point o stuff now looking
back at one point 0 of stuff i think we
have a different different perspective
on that and so that's what this talk is
about so i have started the twitter
conversation on the hashtag java 20
retro i'm not going to be monitoring
Twitter during the during the talk and i
don't have an assistant helping me with
it today but i hope to catch up with
twitter sometime next year okay so let's
look at jdk one point the the top level
javadoc page for jdk one point all of
the packages yes really this is all the
packages and the amazing thing to me
about outside from the the kind of
cheesy looking gif image for the header
that's an 8-bit image and so if you look
at it it's all pixelated and stuff aside
from aside from that the amazing thing
to me about jdk one point is how small
it is and so to give you a quick idea of
how things have grown jdk one point is
is just kind of a what i call feature
count which is the sum of classes class
members methods fields and so forth and
jdk
last members and a jdk 8 that was over
that was over 50,000 so the platform
excuse me in terms of API features a
platform is 25 times larger than it used
to be and here's a little graph of that
growth rate it's pretty amazing how
large a platform is or really in
retrospect how small the platform is 1
point 0 was and then not going to go
over all of this but this is a quick
rundown of the features that have been
added to the Java platform since 1 point
0 and so you can look at these lots and
lots of language changes lots and lots
of major API changes and so forth
clearly have changed the platform quite
a bit what I think is also interesting
is to look at what has not changed at
least in the technology of the platform
this fundamental idea that was very
through at the very beginning say single
class inheritance multiple inheritance
of interfaces that's still very much
central to javas object orientation
strings were and always have been
immutable garbage collection dynamic
linking I mean these you know we deal
with these every day yes well maybe
garbage collection we don't forget about
but dynamic linking sometimes we have to
remind people you know everything in
Java is dynamically linked and so
there's some that has some implications
about things so a lot of these things
have not changed and it's I think a
testament to the staying power of Java
that some of these core core fundamental
features have not changed and I stood
still serving us well today but what I
did want to talk about is I mean
certainly there have been a lot of
changes in the platform some things have
changed but many many significant change
but also what has also changed as a
little little subtle and I'm going to
try to explore today is how are thinking
about the language technology and how
our creation development maintenance and
usage of AP is has changed and that's
not necessarily a technological thing
it's something that has something had
has evolved as we have learned how to
make more effective use of of the
programming language and
programming development in general so
I'm going to hit five key topic areas in
in api's you can see them here general
data structures date and calendar
concurrency synchronization subclassing
inheritance and then kind of a grab bag
of general issues alright so let's start
off with data structures and collections
okay so in one point oh there was no
collections framework remember that the
collections framework came in in 1.2 so
before that there were things that were
aggregate data structures they weren't
called collections at the time they were
vector hash table which is where the tea
is lowercase contrary to the rest of the
the camel case convention and so so some
of us call it hash table enumeration
which was the the way that you well
iterate it over I mean now things are
called iterators but you knew Maury shin
was the way you enumerated the elements
of collection or or an aggregate data
structure and then they're these things
dictionary and stack floating around
which related to a hash table and vector
so here i have an example co a piece of
example code of how how you used vector
so well i kind of do it now but when i
was actually typing this i was typing it
in netbeans and boy the whole screen was
filled with with yellow squiggles it was
amazing but really you know this point
of this really kind of takes you back so
vector vacuoles new vector okay no
generics right in fact we didn't even
call them raw types you just had a
vector and so how did you how did you
deal with things when you wanted to put
things in and out of a data structure
well you could put anything in so here i
put in a string and a boxed integer a
double an object and then when you get
something back out you always had to
cast it down to the right type and in
fact if the thing did not uh you know
the thing does not match the type that
you expected you would suffer a
classcastexception so vector and hash
table are still in there and I'm pretty
sure they they still get fairly
spread use but there's anybody use
dictionary or stack one a couple people
okay so that's that's that's interesting
maybe you can talk afterwards I'm not
well stack maybe I can see but there are
actually replacements for those
dictionary is kind of weird anyway it's
been replaced by the map interface but I
wanted to get into some more details
about how to enumerate you numerate the
elements of vector so there's some
interesting things going on here so here
I create a vector and put a few strings
in it and then we use the the kind of
old-fashioned way of going through the
elements here we have a for loop will we
get an enumeration by calling the
elements method and we keep we keep
running the for loop while the you Maury
Shin has more elements and so this is
just kind of like an iterator except the
the methods are spelled differently and
then we get the next element we have to
cast it to the right type and print it
out but then what I've done in here is I
have this little thing it says hmm okay
if the string we just got equals the
word Bravo then remove the first element
okay that's kind of interesting so
what's going on here we are modifying a
data structure while we are enumerated
its elements so those of you who use the
collections framework know that there's
there's there's a whole set of
discussion and issues around this so so
if you are modifying a collection one of
the standard collections like an
ArrayList then there's this thing that
happens called concurrent modification
exception so if you're iterating over it
and you modify it the next time you use
the iterator you get concurrent
modification exception and so there's a
policy there of which which is called
fail fast policy it applies to only to
certain collections but the point is in
the collections framework the need for a
policy was established and introduced so
the core collections have a fail fast
policy but other collections don't for
instance the concurrent collections have
a week consistency policy the point is
there has to be a definition of what
should happen when you modify a
collection while you are iterating it or
here if you modify
actor while you are enumerated so what
happens with vector well it's not
specified the fact is it does something
anybody care to hazard to guess what
happens okay no maybe a little too early
all right so what happens is that it
prints out come on where's my built
there it is it prints out alpha Bravo
and Delta because when it reaches Bravo
the zeroth element is removed all of the
elements shift forward and we skip
Charlie and so then it prints out Delta
and finishes okay yeah I'm pretty now
that's what it actually does it is not
specified to do this but by
experimentation that's what it actually
does and you can it's pretty easy to see
what an enumeration does is it just
keeps track of what index it's at and if
things shift out from underneath it the
index stays the same all right now what
happens if we insert an element at the
beginning while we're in the midst of
people turns out it's an infinite loop
okay and I was actually surprised by
this but of course it's pretty it's
quite explainable because we get halfway
through ians we say AHA this word equals
Bravo we insert okay so from your
opponent we insert something at the
beginning and everything shifts over oh
the next element is Bravo we insert
something being shifted over and and so
basically it infinite loops here so it's
not too I mean this isn't terribly
interesting but what I think what I want
to highlight is there is no
specification about this and I suspect
what people did was if they wanted to do
this they wrote programs that that might
have relied on this behavior but it's
unspecified and so there's this
interesting question of you know what if
what if vector or enumeration changed
its behavior in this regard would that
be compatible or not I suspect that most
people would consider it not be but
there's no specification around this all
right so now I wanted to talk a little
bit more about specifications although
actually in the one point no time frame
they weren't really called
specifications yet so if you look at the
documentation there is this is a
snapshot of the vector dot copy into
method so it is declared public final
is void copy into and then it takes an
object array what this does is it takes
all of the elements of the vector and
copies them into the destination array
that you provided okay so the very
interesting things here synchronized
appears in the method signature hmm
that's interesting actually have a whole
section on concurrency their world where
I'll discuss this issue some more
that'll be later on it's also declared
final in fact all of the public methods
on vector declared final in one point oh
and i actually don't know why that is
i'm not sure anybody well maybe somebody
some of the world does i did some
research in the bug database and when
Josh Bloch was working on the
collections framework in 1.2 one of the
things he did was do a lot of
retrofitting on the older collections
like vector and hash table and he
removed the final modifier I don't I
don't know if it was him personally but
the decision in 1.2 was that the final
modifier got removed at some point and
the reason given was historical reasons
so it's lost in the mists may be lost in
the mists of history of why those were
why those why those methods were
declared final originally okay so I was
talking about specifications earlier so
we had a question about what happens if
you modify the vector while your
enumerate elements well okay so some you
can have some questions about this what
if the array is the wrong type what
happens I don't know I guess you'd get
erased or exception but it's not
specified what happens if he raised and
long enough I don't know I would guess
and it's just the gas array index out of
bounds exception now here's another
thing which is suppose you're well it's
getting a getting a little bit ahead but
vector is actually thread-safe and so
there's actually a race condition if you
want to copy all the elements of vector
into an array because you need to get
the size of the array but the vector
might change size so I'll actually go
into that a little bit more detail later
on but there's some interesting things
going on with just this one API
alright so the the lessons from from
going back here are I mean yeah so the
api's are old-fashioned and they're raw
types and stuff but it really puts in
perspective how fundamental the
collections framework is and how many
advances that made even though the
collections framework itself is pretty
darn old it really it really contrasts
with the original stuff and so one of
the things that was introduced in the
collection framework was a separation of
interfaces like collection list set map
into conch and concrete implementations
and that's a that's actually a very
powerful design pattern whereas in if
you look at the one point oh actually
don't have a class diagram of this we
have we have dictionary and hash table
extends dictionary and those are classes
we have a vector and we have stack
extends vector and actually I have some
more comments about that later on but
the class hierarchy was all about
classes and concrete implementations
there was no no notion of using
interfaces to separate the abstract
thought of a linear list of elements or
a linear array of elements versus the
implementation of a vector another thing
as I mentioned before the collections
framework introduced the need to have a
policy for concurrent modification so
there's fail fast there's week
consistency there's snapshot semantics
of things like copy-on-write ArrayList
that did not exist in one point oh and i
think the collections framework still
serves us well today i gave a
collections talk yesterday that was I
think well-received we're still we're
still enhancing it people are using it
every day there's a lot of work a lot of
work continuing on the collections
generics of course were big change
obviously a big change to the type
system big change of the language but
kind of on a corner that which is a
fundamental concept of that is
collections very very strongly became
homogeneous Lee typed that is everything
you put into a collection has the same
type so you have a list of string and
it's a compile-time error if you try to
put something else in there like an
integer and you know in the in the old
days people would throw a bunch of stuff
into a vector of all different types and
and that's just the way Java
programs java programs were written and
you can still do that today you have to
do some casting and maybe some suppress
the mornings you can still put any
object into a into a container because
of type erasure but I really don't see
that style of programming anymore so
that even though you can still do it
we've really moved beyond that and there
are some there's some particular
patterns for heterogeneous containers
but those are those are kind of obscure
the main thing is that this style of
programming of putting differently typed
objects into into containers basically
doesn't exist anymore as far as I can
see all right I'll move on to date and
calendar there's a long and checkered
history here my former colleague Mike do
we go the other day if you attended his
talk on James Gosling's code he
mentioned that james gosling was one of
the authors of date 11 tidbit I didn't
know is that the date class which which
which everybody hates now apparently
they hated almost as much as they hate
calendar the original purpose of that
was to be an object that represented a
date and time string our date and date
and time object in an email header or an
HTTP header and so that's if you look at
the email stuff there's RFC 822 it it
has a specific format for the date and
that's what the what the date class was
intended to represent but when you put
it in a general-purpose platform what
happens is they're enormous pressures to
to enhance it and to do a bunch of other
things right and so so people if you say
the date class is for email headers
maybe it's perfectly fine for that but
if you're looking for general-purpose
programming it is totally inadequate and
mixes all these different concepts
together so so in particular the date
class represents a single point in time
you know the usual millisecond off since
since 1970 but it also has embodied in
it the notion of a calendar system and
so many of us are used to the Gregorian
calendar system in 12 months in a year
leap years and so forth but for
international purposes people around the
world use different calendars and so the
system needs a
different calendars other than the
gregorian calendar that was baked into
date and then the date class also has
parsing and and formatting stuff baked
into it which is really centered around
RFC 822 that is email email headers so
when 1.1 calendar and gregorian calendar
were introduced to replace date and in
fact at the time most of date was was
deprecated because all of those things
were you know have those problems i
mentioned so the idea was okay the
calendar class is supposed to be the
root of class hierarchy that is intended
to be able to represent any calendar
system and in fact it's it's so loose
and flexible and extensible that that
that i would i would go so far as to say
it's intended to support calendar
systems that haven't even been invented
yet but if you look at the API it
doesn't have a setter for a month and a
setter for a day or whatever its fields
are all named by integers so there's
there's a bunch of constants for setting
the day a bunch of constants for setting
the month are setting and that you use
in the setters and getters but there are
a bunch of problems with this as well
because calendars are complex systems
and that API leads you to believe oh I
can set all these fields individually
and indeed you can but there are some
very very strange consequences that
result from from setting up an API like
that so and I'll have I have an extended
example that that shows some some
strange properties meanwhile it also has
some idiosyncrasies as a carry over from
the old unix c library the months are
zero based so january you know january 0
february's one and so forth this throws
people constantly in fact when i was
writing the test program you'll see it's
like wait a minute that's not right oh
yeah monster based on 0 ok so it's i
think it still bites people to this day
okay one thing about the calendar class
is that it is mutable so so now i don't
know i mean i think the idea of
immutability has really has has really i
mean there there times to have things
mutable and immutable but i think at
this point
in the present day people rely
understand the advantages of
immutability but if your see programmer
in 1996 it's like what immutable you
mean you can't change it why would you
ever want to do that right I mean it the
concept almost did not exist I mean
strings were immutable in in one point
no but but the idea of immutable
immutability is a general-purpose
programming style and API is that that
only offered you know read-only access
and things like that it was it was
almost a completely foreign concept and
this this traces it back its roots back
to the the early days of bunch of C
programmers might injure migrating to
Java not being used to it but also the
immature technology of memory allocation
and garbage collectors and so forth and
so if you're see programmer you might
say memory allocation expensive okay so
let's let's reuse memory as much as
possible so that that also led to a
bunch of you know lousy programming
patterns like you know object pooling
instead of relying on the garbage
collector and so forth but what I wanted
to talk about here is not only is the
the calendar object mutable but the
individual fields are can be changed
well the fields can be changed
individually even though it might not
make sense to do so so here's my example
so it's sort of two columns on the on
the left half is a really sample per
really really pretty simple program that
that it's intended to do something its
intended to do something pretty simple
let's start off with a calendar
representing account a calendar object
representing january first 2015 and then
what i want to do is set the fields of
this calendar object so that it
represents februari 29th 2016 okay so
2016 is a leap year so the 29th is the
februari 29th is a valid date only in
that year but not in non leap years now
just for purposes of the example what
I'm going to do is set the day of the
month first and so notice I'm using
constants here instead of you know I'm
not saying cept that there's no method
set day of month so i have to say set
and then I
field using it day of month which is
which is an integer constant it's not
any new those warning those weren't
introduced until later so i set the day
of month of the 29th then i set the
month to februari it's like hmm well now
i think i have a date that represents
februari 29th 2015 which doesn't exist
so what's supposed to happen but I'm
going to charge ahead and then set the
year to 2016 and then print it out and
what do you know februari 29 2016 okay
that works how did that work well I
guess I guess maybe maybe there's an
invalid state in the middle there and
maybe that's okay somehow alright so in
the program on the right do exactly the
same thing so I start off with January
first 20 2015 set the day the month to
29th set the month to februari but then
oh yeah so what is the state of the
calendar there i'm going to go print it
out Oh what do you know it says march
first 2015 how did that happen now I go
set it to 2016 and it's this march first
2016 so what happened there so there's
this weird suspend its kind of like
quantum superposition state inside of
the calendar class where you can set
fields and it says oh well my state is
invalid but it might become valid if
something if something else gets set
subsequently but if anything needs to
look at this state I'm going to have to
normalize myself before printing out so
it turns out that getting so get time
gets a date object out of out of a
calendar and that's that's the easiest
way to print it out so getting the
getting the time out of it forces the
calendar normalize itself and it has a
side effect of changing what you know
the actual field values in there so it's
like wow so if you look at the let's see
I think I yeah this is this is basically
this is basically the deal here so
there's this weird interaction between
the fields and side effects at
unforeseen times now it turns out that
this is a very strange behavior of
course so in order to deal with this
they added a mode to to calendar that
says okay well you know this this is
potentially a source of errors so they
added a strict mode so that instead of
doing this silent normalization process
it would throw an exception if you if
you actually had some fields now you can
still set fields into an eval
the state but if anything tried to use
the calendar in that state it would
throw an exception but that's that that
the mode is lenient by default so it's
like wow so so anyway you know they're
these weird order dependencies and and
interactions between the different
fields makes it a very strange difficult
class to work with and in fact I'm not
only to use but it's basically
impossible to maintain because there are
so many programs out there that that
depend on all these weird itÃµs increase
in Chrissy's and interactions if
somebody tried to fix a bug it would
undoubtedly break somebody so anyway so
at this point the calendar stuff has all
been abandoned at has all but abandoned
and replaced with the java dot time api
that came in and java 8 much much nicer
api a good deal of thought went into it
but anyway so this is the stated
calendar api so anyway and then another
thing they had to do was they realized
okay yeah there's this nice framework
for setting individual fields but you
know it kind of doesn't work and if
people need to set say month day and
year all at once then okay so we'll have
a method that does that too so it's a
convenience but it also makes sense
because it's a single state transition
that goes to the right state instead of
individual fields that potentially can
lead lead through invalids temporary
transient invalid states all right so
there's there are few lessons in here I
mean it's easy to poke fun at calendar
and I don't mean to the fact is it was
designed in a real hurry I spent some
time talking to one of the designers
about it he was a little defensive about
it even even still but but the fact is
they've tried to do a bunch of stuff and
they had to write down an API and you
know the fact is nobody at the time new
Java very well I mean everybody
basically everybody had less than one
year of experience with Java I mean
think about that a little bit right
design an API and send it out there to
millions of developers and oh by the way
you can't change it because because of
binary incompatible so design in a hurry
and repent at leisure so anyway yeah so
the bunch of things going on here we
have mutable state but we have also a
bunch of different fields in fact an
extensible set of fields
that had all these weird interactions
with each other and that's that's kind
of a toxic mix for for compatibility and
if I wouldn't try to map out the state
machine of calendar it's it's it's
incredibly complicated with a whole
bunch of special cases and it was
intended to be the design for
subclassing and I think some people
class of calendar in the image in the
public JDK API which is Gregorian
calendar there are a handful of
subclasses internally but it turns out
the the the relationship between the
class and its subclasses is very tightly
coupled so it was really not a
successful subclassing interface which
is probably because it was designed in a
hurry and actually initially there was
only one subclass so there's a there's a
design lesson embedded here as well if
you want to design something for
subclasses make sure our sub classing
make sure that there are two different
subclasses that have different forces
acting on them if you have only one then
you kind of have to think about well
what if somebody in the future did this
and and you have to make a bunch of
hypotheses about what other subclasses
might need without having written them
and you know it likely to guess wrong
all right so let's move on here ok
concurrency is an interesting topic a
bit of history so Javas concurrency
mechanism is descended from Mesa style
locks from Xerox PARC which in turn are
descended from whore and bring Hansen's
monitor concept so basically they're you
know locks and condition variables is is
the main thing there are some
interesting things about Javas
implementation of the not not only the
implementation the design and the
programming language so for instance
locking is lexically scoped so when you
say synchronized when you have a
synchronized method or if you use a
synchronized block then there's no way
you can leave that block without the
without the lock being released and even
if something inside that block throws an
exception the lock is released
automatically because of lexical scoping
of locks and this this is actually
really good if you if you've ever did
any POSIX POSIX threads programming and
see then you really have to keep track
of of what locks are made where and a
typical thing is you take a lock at the
top of a method may be in the middle you
encounter some condition any return if
you forget to release that lock your
system just grinds to a halt because
nothing ever releases the lock so so
that's one thing we're Java Java was at
the time java was lauded oh wow java has
job is really cool it has programming
language support for concurrency and I
think that's this isn't it's an
interesting feature and pretty useful
but there are some limitations with it
there's runtime support for making sure
that wait and notify and a condition
variable is made at the right time so
that's another thing with POSIX thread
there's this this curious relationship
between locks and condition variables
and if you get it wrong things just fall
apart whereas at least in Java there's
kind of a fail fast here for instance if
you want to wait on a condition variable
you must hold the lock that is
associated with that condition variable
so that's how that's how all these
schemes work and so you can call wait on
some arbitrary object but if you don't
whole block on it the system is going to
say hey you don't hold the lock and then
throws illegal monitor state exception
so that's kind of a fail fast way of
flushing out kind of syntactic level
bugs although there's no way there's no
way that that that particular
restriction is enforced through the
syntax of the language so that's
enforced at runtime now there's a simple
library API for threads you create a
thread object and you can say start and
join we can also say suspend resume stop
and destroy ho boy okay so those those
it turns out we're impossible to use
safely and those have been deprecated I
think that what those want those became
deprecated in the first round of
deprecation xin jdk 1.1 so there's
clearly some some some things going on
there where of course there's people who
claim oh we absolutely have to have
those you can't take those away and then
there's other people rightly I rightly
say it is impossible to use these safely
so there's lots of interesting things
going on with threads here so now
there are some limitations and issues
with the way that the java dealt with
concurrency early on and in fact we we
still have these today every object has
a lock and a condition variable
associated with it or at least
potentially and so it's sort of well
okay so if you're designing system where
you expect that there are threads
running everywhere and everything is
supposed to be thread-safe then of
course every monitor needs to have lock
in order to protect its own state and
that turned out to be a mistake because
one there are lots and lots of objects
that are only ever created used in de
stand well not destroyed but released by
a single thread so they are thread
confined so there's extra overhead
associated with having a lock and
condition variable on every object now
modern JVMs try to a new pretty good job
of lazily creating locks and and
condition variables but all the
machinery has to be under there and that
adds complexity maintenance costs and a
little bit of runtime costs because any
fee if anybody ever takes a lock on an
object then that object is inflated so
it has sort of larger header and extra
things allocated and so and that's
irreversible so it turns out that the
programming style is that if you want to
do locking you actually create dedicated
lock objects and keep them private I
think it's mostly a style programming
that is falling into disfavor is to use
the the public the public lock on on an
object and actually that's the other
thing which is that the lock and
condition variable on an object are all
public so you know we've learned about
encapsulation and data structures and
you should you know keep keep your
internals private and keep those
separated from the collars but if you're
doing thread safety and locking you
might think okay so my locking policy
should also be private but the lock on
every object is public and it's public
in the class object and so you cannot
restrict the access controls of of an
object so any caller from outside can
just take your lock and hold it or
notify your condition variable and so so
that that kind of breaks encapsulation
when it comes to dealing with
concurrency
there's there's also a feature of Java
that somewhat controversial there's
there's two camps in this basically all
locks are reentrant that is if you have
a thread that takes a lock on an object
and it does some stuff and it calls
another method that takes the lock on
the same object then it is permitted to
for a thread to take the same lock on
the same object in fact they're
well-defined semantics if you if you
then wait on that objects condition
variable even if you've taken the same
lock multiple times all of them are
released and then when you come out of
the the wait state all of those locks
are relocked so there are times when
that's really useful and convenient
there are times when it really leads to
sloppy programming and it's a bit too
detailed for me to describe in detail
about why that is but but that
controversy still still exists today to
a certain extent but I wanted to talk
about thread safety so I mentioned
earlier that vector vector was a
thread-safe class so is so his hash
table so is a string buffer so the early
data structures were all thread were all
thread safe and that was considered a
good thing and the way they were made
threadsafe was by declaring every method
on them to be synchronized well that's
what you do you have a method that
mutates the state obviously it needs to
be synchronized because you want to
protect against multiple access from
different threads and and this works for
simple operations right so for adding an
element to a vector so sure you know we
have a synchronized method add so it
takes the lock does its bookkeeping
maybe reallocates the internal array if
necessary does whatever needs to do and
then returns and releases lock okay so
that's great unfortunately there are
lots and lots of things that real
programs need to do that are not quite
so simple so there are higher level
semantic transactional operations that
need some kind of consistency over a
data structure and you don't get that by
locking every individual method so for
instance here is an example of
enumerated over the elements of a vector
and it's it's suppose you have multiple
threads that want to do this at the same
time well
the threads are are mutating the vector
this this is totally unsafe right so
there are several individual methods
that are that are threats it turns out
the enumeration methods also are
synchronized so basically when we
enumerate over a vector we're getting
each elements at a time and it's taking
a lock and unlocking it taking lock and
unlocking it but between between the the
locking something can can shift out from
underneath so we get exactly that
problem I showed on the earlier slide
where if some other thread modifies the
vector concurrently you could either
miss elements or get an infinite loop or
something unforeseen so the way to do
this is they oh that's right the lock on
every object is public and so we can
actually take advantage of this so the
way that you enumerate the elements of
vector safely as the caller is to write
your own synchronized block around the
whole thing so you create your own
transaction concept by taking the lock
and then doing whatever you want so you
can you can iterate over it you can add
a room of elements what you want
basically wrap everything in a
synchronized block so so that that
really exposes vectors internal locking
protocol to two collars and so earlier
on I also mentioned there was a race
condition with with copy into so the
problem here is i have a vector with a
certain number of elements and i want to
copy it into an array of the right size
okay well i can say get the size of the
vector allocate the array with that size
now copy into it well but between those
two lines of code the vector could have
changed size and so there's always the
potential that the the array that I've
allocated is now the wrong size by the
time I pass it to the copy into method
so the way to do that once again is to
write your own synchronized block around
the vector and and then do that kind of
as as it as a transaction to make sure
that other threads so presumably other
threads are going to be doing the same
thing so well actually the end the
methods themselves are locked using the
same the same public lock that on vector
so that should be a thread-safe
transaction but
the fact is this is a terrible way to
program right the idea is that vector
supposed to be thread-safe but you as
the caller have to do your own locking
around it in order to do anything
interesting with it so so that's that's
kind of a lousy way to program to
library API so but that has a few
consequences so one is it takes
advantage of what many people think of
as a Miss feature which is that all
locks are public but then it also
implies that locking must be reentrant
because if the caller can take the lock
and then call methods that also take the
lock then if the lock isn't reentrant
then then that simply fails so if you
take this to its logical conclusion the
idea is if you have you know not only
one object but maybe a whole data
structure of objects like a tree of
components in a WT if you want to do a
transaction over that and do some
surgery on the on on the on the
structure of the component tree well why
don't we have a getter for the lock and
so the caller is supposed to get that
object right a synchronized block around
it and then then it can do surgery on
the tree and then release the lock and
so so that is really exposing your
locking internals to to the caller but
it puts a lot of responsibility out onto
the caller to get things exactly right
and so that's really quite frankly it's
it's a lousy way to program so so there
are few lessons from here hold on that
we've learned from one point 0 1 is that
synchronizing every method doesn't
achieve thread safety there's a lot more
going on that you need to think about in
I forget when this was in 10 in 1.1
there's this idea that that synchronized
was part of the specification and that
that changed later on if you look at
current javadocs you'll notice that even
for synchronized methods the
synchronized keyword does not appear in
the specification and so after some
thinking people realized the locking
policy
now the thread safety sorry the locking
policy of an object is actually a
artifact of its implementation whether
or not an object is thread-safe is part
of its specification but the fact that
this method happens to be synchronized
is not part of its interface and so that
was not true early on so in one point oh
we saw synchronized methods with the
synchronized the synchronized keyword
appearing there and then later on that
disappeared from from the Javadoc and
then finally I think that this idea of
shared memory multi-day with locks and
condition variables is really just to
low level for for general purpose
concurrent programming and so since then
we've had the the concurrency utilities
that came in in Java 5 some higher-level
data structures with with nicer
transactional transactional operations
and then more recently of course we have
the parallel streams the streams API and
Java 8 that that has some fairly
convenient automatic parallelisms with
it so we've moved on a lot since locks
and condition variables okay a few words
of a few words about subclassing and
inheritance I think in the mid-1990s
object orientation was was shiny and new
and everybody wanted to everybody know
this is really cool let's let's use
inheritance and subclassing and so what
I the way I describe this is everybody
wants a system that is flexible and
extensible and in the object-oriented
world of the 1990s the universal solvent
for achieving flexibility and
extensibility was through subclassing
and inheritance and you see that in the
in the way that a lot of the api's were
designed unfortunately this led to the
what is what's called the fragile
superclass problem where and I don't
know why it's called the fragile
superclass problem because it's actually
the subclasses that get broken so the
typical thing is if you have a few of
class and then somebody subclasses it if
the class gets modified in particular
way that can easily break some classes
because they're essentially depending on
on behavioral internals of the way the
superclass is implemented now if you
combine that with java's goal of chi
binary compatibility what it meant was
that it was at a certain point it was
very easy to get yourself into a
situation where you could not change
anything without breaking any of your
sub classes and I mentioned this is this
is this was an issue with calendar was
also an issue with the both of the UI
libraries particularly a WT and swing
those allowed uncontrolled subclassing
in fact they encouraged subclassing the
the 1.0 version of a WT the only way to
to add behavior the system was to
subclass component remember that
remember the old event model before
listeners you subclass tan / road I
forget the name of the method but
basically you subclass than overawed
methods in order to get to get
customized behavior since then I think
people have wised up a little bit Alan
Snyder who wrote a bunch of
object-oriented papers in the 1990s
basically came out and said inheritance
breaks encapsulation and then Josh block
the author of effective Java and also
the designer the collections framework
said he in ineffective in sorry in the
book effective Java he has an entire
item that is entitled prefer composition
to inheritance and I think that's that's
a good lesson I see I still see
inheritance you over used from time to
time but you can see this in the API is
here I think this is one of the deepest
class hierarchies here we have object
dictionary hash table properties and
provider no provider is not not well
used but it is a fundamental part of the
system that that existed in the security
package and and and we've we've broke
ourselves with the fragile superclass
problem a couple times some things
changed with hash table at one point and
it broke provider or it actually broke
some invariants that provider had and
you know what since provider is part of
the security language sorry since
provider is part of the security package
if you break the invariance of a
critical security class you have
security holes so that's a pretty big
deal so another issue is that properties
the intent of properties was to be a
mapping from string keys the string
values and you have a property file it's
just a text file you
edit it but properties inherits from
hash to hash table and there's no
restriction on hash table to just
strings remember no generics no raw
tight salt all raw types so people would
put people to create a property's object
and put objects of any type in it and
it's it's legal to do that I hear if
people who use the system properties
object is kind of a global a global
bulletin board for for posting objects
of any type now there's this problem
which is if you if you load and store
properties to and from into a file those
implementations expect to have only
strings so there's a bunch of defensive
code in there yeah well what do we do if
it this thing is not a string because
it's because it really totally breaks
the model the reason is that this is a
violation of the liskov substitution
principle there's this idea that if you
have a subclass that subclass should be
usable anywhere the superclass is that's
not true with with properties and hash
table all right there's another example
here with vector and stack I'll just say
that stack if you look at the methods
that stack adds it's a nice stack
abstraction except that inherits every
single method of vector so you can have
a stack that you can you can modify
anything anywhere on the stack instead
of just that the at the top so it's it's
kind of a weird beast so what you have
to do is if you're really using a stack
you have to ignore a bunch of methods on
it if you want to maintain the stack
abstraction there's some other weird
things about object design in here so
the the i/o classes are what I described
is a curious mixture of inheritance and
composition so if you look at this whole
family of input streams every little bit
of functionality was a new stream and
then you wrap them in each other and so
typical code is you see at the bottom
you you take you open a file with a file
input stream wrap it in a buffered input
stream and then wrap it in a data input
stream to read to read data out of it I
think it's beyond the scope of this talk
to propose a redesign here but you might
think that that family of interfaces and
factory methods might do a better job at
this in particular a file input stream
there's nothing special about of the
input stream you get out of a file it's
just that its origin was a file and
maybe maybe there doesn't need to be a
class called violin but stream because
once you've opened that file there's
nothing nothing really special about it
there are a couple things floating
around in there in Java util there's
there's an observer observable pair does
anybody use this st. me to remember that
these classes there yeah maybe maybe
maybe talk to me about that I i look at
it every time I've tried to use it it's
like wow what howdy how can you possibly
use this the big problem here is that
observable is a class and the reason
it's a class is because there's a
machine in the machinery in there to
make to maintain lists of observers and
to notify the observers and so they said
oh well this has to be a class because
we want to share this code but if you're
writing some other class somewhere else
and you say oh I want to become an
observable well you already existence in
your own class hierarchy so you can't
you can't mix this in somehow so it's it
turns out to be very difficult to use in
practice all right oh I'm sorry I
actually might have misspoke before the
actual title of Josh blocks item in
effective Java in the book effective
Java is design and document for
inheritance or else prohibited I think
that's good advice that he wrote me
several years ago I think it still
applies today and you can see that
because it's a reaction to some of the
early API designs in in Java 1 point 0
and then I think there's there's a more
recent idea which is thinking about
families of interfaces and static
factory methods for getting instances of
them instead of instead of exposing new
concrete classes for different
specializations all right a few general
programming notes here in the early days
there was this idea that took hold which
took many years to dispel which was that
Java is slow and in fact in one point 0
was pretty slow so there's there's no
question about that and but the reaction
to the system being slow was that a
whole crop of poor programming practices
developed
to work around the the slowness so for
instance here here is a here's an
example of of a poor coding practice
which is using an exception to break out
of a loop so if you think about this a
little bit if you want to iterate over
the elements of an array it's pretty
easy to say you know start off with an
index variable and then you know check
to make sure that every time through the
loop the the index variable stays within
bounds and then you terminate the loop
but somebody observed well that's
redundant because the JVM always checks
the array bounds anyway so we can take
out that extra check and let the vm do
the work for us and and then we just
catch an array index out of bounds
exception because that means we ran off
the end of the array so we can save an
integer compare by doing that and
somebody had some benchmark that
actually show that that was faster in
the in the one point Oh classic vm
interpreted interpreter bytecode and so
forth well it turns out that not well I
mean I guess it was when JIT compilers
came in turns out JIT compilers are
really good at optimizing simple code
and they're really bad at dealing with
with things like non-local flow control
like exception catching and so the
optimizers could say if you had a
straightforward for loop over indexes
they would say oh yeah we know about
this we can unroll the loop we can we
can do all kinds of nice things we can
inline things we can make this go really
fast o.o it relies on exception handling
let's fall back to the old slow path
because we have no idea when the
exception is actually going to her in
here and so in fact what what was a this
would I think at its best this style I
should say this style of programming was
a tiny speed advantage at its worst it
makes your code a major code abysmally
slow compared to straightforward simple
jit optimized vil code I mentioned
earlier that since since GC was slow so
people would create object pools and say
oh well we don't want it we don't we
don't truck you know what it is it's
trust we don't trust the garbage
collector so we're going to do our own
remember these are C programmers in the
1990s right and
I'm one of them maybe so anyway but as
time has gone on I think I you know the
the the systems have become much more
high-performance faster reliable and and
so these these concerns have fallen away
something that is I think a pragmatic
decision early on that we still live
with is this divide between primitives
and objects and if you follow Brian gets
his keynote let's talk about valhalla we
are finally trying to bridge that gap
and it's a lot of work and it requires a
lot of technology to do so but this is
something that we deal with on a regular
basis I think it was it's a it's a
little too easy to say it was a mistake
we should have been like small talk and
made everything be an object or
something like that but I think that the
fact that primitives were put into the
language of the beginning was kind of a
kind of a bone that was thrown to C
programmers to otherwise C programmers
would have said the system is far too
slow I think it did actually provide
speed advantages early on and for many
things it still does in fact in the
streams library we introduced in Java 8
there are primitive specializations for
int long and double and it would have
been nice not to have had those but the
fact is having having those handwritten
classes that deal with primitives
differently from from objects excuse me
provides a significant speed advantage
so primitives as much as there's this
discontinuity between primitives and
objects primitives in many cases still
provide significant advantages but we
are finally working on that let's see
what else is there so there are there
are weird okay so kind of in order to
try to bridge the gap so instead of sort
of there are they're primitives and
they're objects and then there are boxed
primitives which are objects that
contain that are that are duels of the
primitive types and those you know those
are sometimes useful but what it meant
was that there was a set of api's for
converting between primitive
actual primitives and boxed values and
in if you if you look at old code I
think for straightforward things this
was okay if you wanted if you wanted to
if you wanted to put integers in a list
and then you had to box the integers and
put them put them into a list and that
was moderately painful one thing though
that it encouraged which I still still
see in looking through old code is fact
is that primitives are just a value
they're not they cannot they can never
be null whereas if every object has a is
a reference to an object and it can be
nullable and so I ran across some old
code that used a boxed boolean value as
a tri-state right it could be null true
or false and I have a piece of advice
for you don't do that and actually it's
a real problem because in Java 5 with
auto boxing you can you can deal with
with boxed values pretty conveniently
almost to the point of forgetting that
you're dealing with a box value and if
you do that and that box value happens
to be a null reference then you get a
nullpointerexception out of something
that that is totally nonsensical so
really i mean it's it's terrible and
then they're also these subtle things to
which is for instance this line at the
last last part of the slide it turns out
that there is a specified caching
behavior of boxed integer values but not
all the integers are cached so if you
say integer value of 1000 that will
create a box tanager and it is sorry let
me let me step back a little bit if you
have if you have two boxed integer
values if you have a less than or
greater than comparison the auto
unboxing will say oh ok wants to do an
integer comparison those do unboxing and
then do integer comparison but if you
say oh well actually I don't want to do
a less than comparison i want to do an
equals comparison if those are boxed
values you don't get a numeric equality
comparison you get a reference equality
comparison and now all of a sudden this
idea
of having box values it is now gee I
have to realize when when I might have
two different instances of the boxed
integer 1000 and so in this case if you
say integer value of 1000 reference
equals integer value of 1000 the answer
is false which which is sort of you know
it's okay that's that's a little subtle
but but not not that not that
unreasonable sure when you're looking on
a slide but if you're trying to debug
something at 1am this this is the kind
of stuff you forget and this is a real
real pitfall in the language I think so
boxing auto boxing helped somewhat to
bridge this divide but it also created a
set of pitfalls on its own so
immutability I think I said a few words
about this before immutability is now
much more well accepted as a general
programming practice particularly
anything that is immutable is basically
automatically threadsafe there's you
know now widely accepted there are a lot
of things that were mutable at the
beginning Dayton calendar I talked about
awt has a bunch of data classes like
point dimension and rectangle they are
mutable and what what it led to was that
every time every getter basically had to
make a defensive copy of of these
because since they were all since they
were all mutable you never knew what the
caller was going to do with it so you
had to make a defensive copy before
before returning it to the caller so
we're still actually working on this so
in in Java 8 the new the new Java dot
time ap is all of those data classes are
immutable and so that was a key aspect
of that sign decision and I think people
people look upon that very favorably to
this day the core JDK does not have
immutable collections their variety of
libraries out there third-party
libraries that do provide immutable
collections but maybe in jdk nine if you
saw my collections talk yesterday talked
a little bit about this maybe in jdk
nine we will get our first taste of
immutable collections
in the in the core libraries and then
there's something that John Rose the JVM
architected oracle has talked about and
I don't know if he's talked about it
here or in other conferences he has a
bunch of ideas around he's calling a
raise to 0 which is essentially an
immutable array there are times when
that's very very useful and the fact
that all arrays are modifiable in Java
is actually sometimes a big problem so
doing defensive copies of large arrays
is is quite expensive wanted to say word
on specification versus documentation
one of the things one of the things that
happened I'm not sure exactly when it
was maybe 1.2 or so was the idea that it
wasn't just documentation that was
produced by javadoc it was actually a
specification and there are two things
that happen to that one is the text in
the then the documents became much more
verbose because lots more was was was
specified so here is I'm not going to
read all of this but you can see from
the volume of text vector dot copy into
just has one line and I asked a series
of questions about it earlier that we're
not answered by the documentation all of
those questions are answered by the the
collections list dot to array method so
it's very well specified exactly what
happens if especially if the array is
not the same size as the number of
elements in the collection and so what
so one is it gives more information to
programmers clearly but the other point
is that having a specification enables a
test suite to be written for conformance
testing which then enables independent
implementations of Java to be made and
in fact there are independent
implementations out there and this this
is what the licensees use for testing
conformance all right so I'm just about
out of time but I'm almost at the end
here so I this is basically recap of
what I just said so I wanted to
summarize here with the the this quote
from George Santayana those who cannot
remember the past are condemned to
repeat it I think there are a lot of
lessons
to be learned from looking at the
history of Java a lot of we've learned a
lot since then made a lot of mistakes
and so let's not repeat them but I would
not like this to be me up here saying
boy those people who designed Java were
so stupid look at all the look at all
the mistakes they made so I wanted to
show you another quote from George
Santayana which is not quite as popular
as the first one we must welcome the
future remembering that it will soon be
the past and we must respect the past
knowing that was once all that was
humanly possible and so I hope that 20
years from now when people look back on
the work we do in Java today they
forgive us our mistakes and say look how
far we've come since then thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>