<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Navigating the Streams API | Coder Coacher - Coaching Coders</title><meta content="Navigating the Streams API - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Navigating the Streams API</b></h2><h5 class="post__date">2015-06-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/cZDQeZNViEw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so good morning you come to the talk on
navigating the stream API I'm Morrison
astelin thank you very much for turning
out at this time in the morning it's
pretty brutal I think I want to say the
thing that the airline's say you know I
know you have a choice of lambda talk
you go to thank you for coat thank you
for coming to this lambda talk this is
actually my punishment I was on at ten
o'clock talking about this about this
but at ten o'clock was a talk which I'm
actually going to recommend you to where
Brian gets his talking about the stream
API and I thought you're not like I'm in
one ball room talking about the stream
API and Brian's in the other ball room
talking about stream API so I asked to
be moved and this is my punishment and
yours as well because you're here at
half past eight in the morning so so
just to start off let's let me say you
had a choice you did have a very wide
choice of lambda talks to go to why
should you have come to this one well
the the focus of this one's going to be
slightly different I think from others
in that this is a very highly this is
very much a developer focus talk I'm not
going to motivate why you should be
using lambdas or why you should be using
streams i'm going to assume that you've
drunk the kool-aid no I can like there's
been plenty of motivation and the
motivation is the motivation is really
good i don't really have time for that
what I'm going to try to do today is I'm
going to try to do a reasonably thorough
exploration of the stream API it turns
out to be quite a big job and and that's
going to mean it's going to be quite
fast paced we're going to have to we're
going to have to look at a lot of
methods and see what they're used for I
did actually advertise this talk as
being one which would help you to
analyze your problem in terms of the in
terms of the methods that are available
and break it down and that was what I
was hoping for but it turns out you
really need to have some familiarity
with a stream API before that really
works so I'm not going to try to do that
today I'm going to build examples up
rather okay so that's me whenever I see
these kinds of descriptions on Twitter
and so forth well I don't know what it
means about other people but it's for me
it's another way of saying I don't have
a real job I am probably known if I'm
not at all in the Java world's being the
co-author of the book on Java generics
my current projects are focused well you
know I'm a follower of fashion so I
and the maintainer of the of this lambda
faq which aims to be an authoritative
resource on all things lambda but has i
might make some difficulty updating that
because my other project which was kind
of risen out of that is mastering
lambdas java programming in a multi-core
world this Amazon tells me is due out on
the eighth of april 2014 and it's going
to have 208 pages and how they know this
stuff i really don't know anyway so
that's that's my credentials such as
they are for talking about this stuff so
navigating the stream maybe i'm going to
have the toxin for very unequal sections
i'm going to talk i'm going to give a
very quick overview of the fundamentals
and quick overview of the api and then
i'm going to then i'm going to look at
some of the stream operations in some
detail and then at the end my I've been
trying really hard to get some kind of
lame streams jokes out of this and I
just really can't it's somehow it
doesn't seem to work but I thought well
let's push the boat out will actually
try and work through some examples there
is a test at the end of this talk but
the test is to see whether or not the
test is of me have I actually managed to
get any of this over at all so i will
set we'll look at some small problems ok
so what why we got streams very quick
overview with the intention is we're
going to replace loops for aggregate
operations so that lambdas has a part of
the story but this is focused
particularly on streams and that's what
streams are going to be four instead of
writing this kind of thing and here
we've got some very ordinary code where
what we're going to do is we're we're
making up a set of a set of cities we've
got their data models going to be that
we have a we have a person type and the
person type has an attribute of the city
that they live in so we're imagining
we've got a list of persons it's called
people we iterate over it we get the
city for each one of them we look to see
whether the name of that city has a has
a passes the test of being less than
four characters long and if it does then
we add the city to the to the set that
we're accumulating so this code is the
kind of thing that you see all the time
that we've been we've been writing for
ever since has been Java so instead of
writing that we're going to write stuff
like this and we're going in this this
what we're doing is we're taking the
list of people and we're turning we're
putting it into a stream we're using it
as a source for a stream and then we're
running that through a map operation and
that takes each element of the stream
each person industry and and turns it
into a city so we're using here a method
reference person get city when that's
just that's just a short way of saying
for each person I want to get the city
attribute for them and then so now we've
got a stream of cities instead of a
stream of instead of a stream persons
and we filter that over the same test to
see whether the name of it is less than
four and we then we collect that into a
set so there are all kinds of advantages
claimed and when I say claimed i don't
mean i don't believe the claims for the
for writing code in this style it's
going to be more concise it's going to
be more readable we're going to get
better api's with more composable
operations and very importantly and
actually a major driver for the whole
thing it's going to be more
parallelizable so if we want if we want
to change this the code that i just
wrote so that it runs in parallel then
all we need to do is change this is
change the stream method on the on the
on the sit on the source to being a
parallel stream method that creates a
parallel stream and in many
circumstances depending on the size of
your data set and and a whole lot of
other stuff as well that may well
execute in parallel very much more
efficiently much faster than it then it
will in in serial so this is all great
and I'm and I guess you've probably seen
a lot of this stuff in the keynotes and
in Brian's talks so for so I don't want
linger on that but I do want to bring up
but it's not exactly a drawback but
something that doesn't get emphasized so
much on the other hand we if we were
going to write something like this and
in this case we're just doing something
a bit more complicated and what we want
to do here is we want to classify the
well we actually want to produce want to
classify the people by the city they
live in but is but instead of actually
instead of so excuse me instead of
forming a map from from city to the to
the the person to live in the city we
want to get the names of those persons
so here we're making we're making up a
new a new map and then we are again
we're iterating over the
the list of people the list of person
we're getting the city for each one
we're looking to see it we're looking to
see if that city is already in the
classification map and if it isn't in
the classification map then we put it in
the classification map with an emptier
with a with us its value an empty array
list and then we and then we add the
person that we've found we had that we
had the name of that person into into
the list again it's pretty it's pretty
straightforward code it's pretty
straightforward but it's kind of clunky
and it's in it's long and so we've got a
better we've got a better version of
that 44 with streams so what we're doing
here is we are taking / taking the list
of people and we're we're using it as a
source for the streams and then we're
using a collector and collector is
something which i'm going to explain a
lot more detail in this talk it takes
the it takes a stream and it puts the
contents into a container but possibly
after some transformations in this case
what we're going to do is where the
classifier is again going to be the same
we're going to use the we're going to
use the function from the person to the
city that they live in so this is we're
going to end up again with a with a map
from city to list of name but but the
things that we're actually going to put
into the values for the classifier well
we have to transform so we've got to
change them from being a person to to to
a name so we use a mapping collector
which is going to which is going to get
the name for each person and then it's
going to put it into it that's going to
put it into a list so but now you're
looking at this and you're so naturally
this is not quite as straightforward as
I as everyone's been telling me this
stuff is going to be I don't know maybe
maybe you're not thinking that but
certainly I have to say when I thought
when I saw it time I did feel that so
what we're going to what I'm planning to
do today is show you that it actually is
more straightforward than it looks so
does this mean that students are hard to
use now what it means is you come to the
right talk so so streams just to finish
the overview what's the idea of streams
well if I don't want it it's quite
difficult to describe them inwards so
I'm going to be using their quite
dynamic so I'm going to be using a lot
of animations in this talk to try to get
the idea over what they are but if but
if you try to describe them words you
end up saying what they aren't
and what they are so it's not a it's not
a collection because it can be because a
stream it's a dynamic structure it can
be partially evaluated or it can be or
it can be exhausted so you have to know
the state of it in order to be able to
talk about it it is like an iterator so
I've emboldened that because it does
yield elements for processing but it's
really not like an iterator because it's
not associated with any particular
storage mechanism you can use for
sources you can use collections arrays
there are generated functions your IO
channels we can use strings for as a
source as a source of a stream and so on
they can be parallel that's very
important and they can actually be
infinite for it so if it's coming from a
generator function so we have to have
some short circuiting methods which will
actually enable us to cut off the
evaluation of a stream before it's fully
evaluated because an infinite one you're
obviously going to be waiting well quite
a long time before an infinite one's
fully evaluated and there are some there
are some further versions of streams the
the stream the stream API has a stream
interface but it also has three streams
of primitive types so there's an inter
stream which is clearly instead of being
a stream of references is a stream of
int and the long stream and a double
stream so that's the that's the kind of
outline one useful thing to one useful
idea to hang your understanding of
streams on is if you're familiar with
unix streams the ideas are pretty
similar and in particular the way that
unix streams are composed into pipelines
is something that's an idea that's been
used pretty copied over in a fairly
precise way here okay so that's the
fundamentals of streams what about the
fundament fundamentals of the API well
there are various operations on the API
the lifetime of a stream the lifecycle
of a stream is it's born as a source
there it suffers various intermediate
operations these these are often use
lambdas this is where the Association
come they use lambdas or they use method
references i'll be using method
references a lot in this talk to
transform values into or indeed to drop
them as for a filter for example the
operation itself intermediate operations
themselves return a new stream they
don't
do the work the work is generally they
don't usually do the work in many cases
the work is actually done by the by the
what's called the behavioral parameter
the lambda or the method reference that
the intermediate operation takes and the
the life of a stream ends with a
terminal operation I have to say I think
this is unfortunate phraseology because
you know it's kind of a bit gloomy isn't
it but we hope that it doesn't apply in
the same way as it would to people so it
seemed eyes to the terminal operation a
terminal operation actually uses up it's
unlike a sudden like an intermediate
operation which doesn't actually itself
do any processing the terminal operation
actually does and I think of it as a
pull API where the terminal operation
pulls values down the stream and and and
so actually the stream evaluation
doesn't begin our stream processing
rather doesn't begin until the terminal
operations hooked up to it so we'll see
some of this in more detail in a minute
so here's the here's another feeble joke
around stream operations I tried to get
a map of how they're structured using a
stream map the they are divided as I've
said into intermediate and terminal
operations intermediate operations are
further divided into stateless ones
stateless operation on the stream
doesn't need to know anything about
where it is in the stream processing how
many elements have passed it by or or
what are the results of any other of any
other operations a filter map flatmap
and peak will look at all of those in a
bit of detail stateful ones are
different in the sense they need to know
something of the history of the
processing of the stream because they
produce to take it to take an example
distinct will filter out duplicates so
it needs to know what has already passed
through the stream terminal operations I
talked about those there's three kinds
there's reduction which if you're used
to the idea standard idea is a reduction
is pretty pretty similar to this the
idea of reduction is it takes all of the
values of the stream and in some ways
rams them into a single value so it's so
it doesn't give you back a stream in the
way that the intermediate operations do
it gives you it gives you a value which
is in some sense a summarization of all
the values that have come down the
stream
we've got and you see the ones we've got
there there's there's also a kind that
actually big gives us the most
difficulty I believe in understanding
the API these are mutable reductions and
mutable reductions do the same thing
that I just discussed that it did they
take all the values that have come down
the stream and they summarize them in
some way but what they do what mutable
reductions do is they put them into a
container so for example if you wanted
to take all the values that have that
have come down the stream and put them
into a list or into a set or process
them in some other way you would use the
collect operation the click method to do
that to array is also a mutable
reduction of that kind but it's much
simpler I won't be talking about that
there's there's a further group which I
won't be talking about today that are
roughly summer sunrise well as search
operations these these contain the
short-circuiting that I mentioned
earlier that allows that allows you to
process infinite streams so it's clear
that if you if you're looking for find
first an element that satisfies the
first element satisfies a predicate from
an infinite stream that may well
terminate even though the stream is
infinite at the point when you find the
first one that satisfies it and finally
off at one side is for each it really is
off at one side than this in this
picture for each is is kind of peculiar
and it's not really in the spirit of the
stream API in one sense it just allows
you to apply some processing to every a
limp to every element that comes down
the stream I won't be talking about that
further today okay so that's the API
overview let's have a look at some of
these operations in in a bit more detail
so we worked I'm going to take them in
the four groups intermediate state
that's intermediate stateless operations
intermediate state full operations and
then I'm going to look at the reductions
the ordinary reductions and them and the
mutable reductions and then at the end
of that will that's when we'll have the
test so intermediate operations return
new streams they're lazy in the sense
that they don't actually well they won't
do any work until I have to they
creating a new stream they don't create
new out they don't do any processing of
any elements so in this case with the
the map method here
will what we get if we if we call map on
the stream of person that we've created
in the second line there is we get back
another stream in this case it's a
stream of city but no processing has
been done this pipeline has been set the
pipeline has been set up that connects
the stream of person to the stream of to
the stream of city that comes out of the
map but no work is done until two until
a terminal operation is hooked onto the
end of that so the pipe like the
pipeline remains unevaluated okay so
visualizing stream operations I find is
very useful I mean I've got I've got to
feel I've got a few of these animations
and the general idea is that we is that
we've got an element out oh that's his
real shame you can't see the stream
itself there can you I've colored it too
I've used to to a paler color that's
right so there's meant to be a kind of
runway between the array on the left and
the this and the stream operation which
you are missing from that on a shame and
and the idea is that here's an operation
which is going to do something to the is
going to do something to the to this to
the it's that stream element maybe it's
maybe it's a map in which case it might
alternate to some other kind of value
and it's turned the next zero to a y0
and then then the wiser then that
element flies off and another one
another one is taken so we're imagining
an array here as being the source of a
stream and in this case it's probably a
n in this case it's probably a map from
the way it looks so so this this may be
helpful for visual learners I'm a visual
learner so I like this kind of thing you
shouldn't really be to you shouldn't get
too hung up on that picture though
because in fact the stream API is
completely agnostic between serial and
parallel operations it's a very
important thing to remember when you're
using it it will not support you in
defining any operations which will only
work in one of those modes and in
particular will only work in cereal and
there's been a lot of discussion about
this whether this is really too strict
but further picture that I have can you
make up it can you make out the balance
at all on that or is it they can oh good
okay that's
feel better so so in principle you could
imagine parallel processing and being
something like this we've got we've got
our array here then it's a source of a
stream but if we said we really want it
to be processed by a parallel stream
then we could imagine something like
that happening and they're all going to
happen at the same time because the big
advantage of this is we're imagining
each one of these operations is
stateless operations as same operation
and they're being executed on different
on different cause that's the way that's
the way we're headed with this stuff and
and then then they fly off but they get
transformed and fly off but I don't want
you to take that too literally because
actually you don't know that it's going
to happen that way and it's very
tempting to fit into that neat picture
but in fact there is no there's no
prescribed order in which the the
elements are processed in parallel other
than what is necessary in order to keep
the correctness of the operations so
they don't guarantee that the first out
that there's going to any particular
ordering between x1 and x3 here maybe x1
processed first but then x3 got
processed and there's a danger with this
which you have to always bear in mind
they call it the prime directive in fact
of the other stream API which is to
avoid interference so interference is
when you have an operation like the one
that that's about that's taking place on
y1 which affects outside data and in
particular may have may actually
overwrite or change in some way the
source of the stream you're just not new
you're just not meant to do this so it's
a it's a bad idea and it will lead to
all kinds of problems you're not there's
no operation on the stream that is
supposed to change that is allowed to
change the source of the stream the
prime directive the prime directive is
that that no operation on a stream may
change this with me it may affect the
source of it made me take the source of
it in any way
if you're just not meant to do it so the
question is is it are you meant you're
allowed to do it if it's cereal or are
you meant to desist will only apply to
parallel the answer is you're just not
meant to do it we'll take it offline
I'll take it offline so so so the
diagram I have their brakes the brakes
the prime directive in fact there's in
fact there's a very general rule which
says that you know that nobody is
allowed to mutate the source of a
pipeline except except in the case of
concurrent sources so by and large and
and and there's even even that even that
is controversial but but but it but
inevitable but the operations of a
stream mustn't do that okay so so these
are the principal stateless intermediate
operations I've got illustrations of all
of them so I'm not going to I'm not
actually going to talk about them about
this table it's there for reference if
anybody wants to look at it once look at
the sides afterwards in summarizing the
types of these operations I have missed
out that the type bounds which you will
find in the which you'll find obviously
in the API documentation for example
filter doesn't really use an interface
of predicates of tea it uses an
interface of predicative of anything
that is that is tea or a superclass of
tea but I throughout this talk I've
missed out all the wild cards because I
think that it makes the code more
readable and I've also I've also
neglected to say as well that map and
flat map have support operations that
will actually matter that will produce a
stream of int or doubles or or Long's as
well so this is actually variants of map
and flat map and we'll see one of those
later on so let's have a quick look at
some of these operations his filter
working on a stream of string very
simple predicate the same one that I
that I showed you earlier it's just
going to test each string that comes in
to see whether its length is less than
four so here comes here comes Jim and
that's that's okay the the predicate
it passes the test of the predicate and
flies off on to the dance on to the
downstream you'll notice that filter has
a the the whatever the input stream type
is that's the type of the output stream
as well it doesn't change it and here
comes bill and Bill fails the test so it
just disappears it doesn't go onto the
onto the output stream and then comes a
third one and that one passes so that's
filter and I think this and I think this
idea is pretty straightforward here's
map which is not that much harder map
does something different it doesn't
discard any elements what it does is it
transforms each element usually to it
not always but often to a different type
so in this case i'm using the the
classifier function person yet city
which will which will for each person
that comes in will will transform them
into the city that they in the city that
they live in so here comes bill &amp;amp; bill
bill lives in London and London goes off
down there so in this case it's the type
of the input and the output streams are
different a stream of person is the
input in the stream of output of the
city and you can see the function that
that map expects the function type there
is corresponds obviously to the change
in the types of the the transformation
the type of the streams okay Amy lives
in Athens and she goes and I've got
another one I think all right okay so
all right let me let me talk about flat
map flatmap next flat map is the idea of
flat map in this case I've chosen flat
map to int but the idea of flat map is
is is similar whether you choose one of
these maps to a primitive type or not
but this one was was just particularly
easy to illustrate so I'm taking a
stream of string in this case and I'm
transforming it into a stream into an
inch stream so the in-stream is actually
going to it what's going to happen is
they each of the streams that comes in
is going to get broken up into its
constituent characters and the in and
the individual characters are going to
send out be sent down the output stream
so what so what you need here what you
need to put into flat map is a function
which is going to take the the type of
the input value of the stream and give
you back a stream of some kind
so what's so what's happening here here
comes a string Amy to consist of the
characters am and why and that function
which turns it into into a stream of
characters then allows it takes each
character off in turn and although you I
don't know whether you can see it or not
but there's a little stream there which
feeds into the output stream so what
we've done is we've is the idea of flat
map is it's literally to flatten the
structure of the input objects and to
turn them into into streams it turn each
one of them into a stream source itself
okay so the last one that out the last
intermediate operation I'm going to look
at briefly is I can get to it is going
to be did I peak so peak is useful
typically for debugging it doesn't
actually do anything very much I don't
even have an animation of it but the
idea of peak is that it's going to take
each element that comes in it's going to
pass it on to the to the downstream to
the output stream doesn't change it in
any way but it also gives it to what's
called a consumer so a consumer is
something which will take the value and
do something with it in this case I've
said well let's print it out because
you'd often use peak for debugging so
you can see the values as they come down
the pipeline and and if you put a peak
operation into a pipeline that was there
was going to protest n elements that was
the stream was going to produce ten
elements then that would be called ten
times once for each of the words for
each of the elements okay so those are
the stateless intermediate operations
and I think probably I tend to think
actually although I spent some time on
those that they're actually relatively
easy straightforward to understand the
stateful operations are also not not
that not that difficult you can see that
the I've already talked about distinct
limited substream are like slice
operations limit will say I'm only I'm
well we'll will cut you off the stream
the output stream will be exhausted
after say ten elements and substituting
will allow five elements through and
throw them away and then it'll allow
another ten elements and then after that
the output stream will be exhausted
the idea these are pretty
straightforward sorted does what it says
on the tin really so visualizing extreme
operations for stateful for stateful
operations is kind of a bit more
difficult so it's it's harder the
sometimes do what this diet what this
animation shows in the case of sorted
sorted always does this so you lose some
parallel ISM for sorted that they're
pretty clever about they're pretty
clever about how about how to avoid
having to do this no one wants to do
this because you've got to bring all
your values together and you lose the
advantage of distribution of a different
cause but so they're quite clever about
doing it for the different for some of
the stateful operations but so I chosen
in the next slide I've chosen chosen an
animation sorted because sorted is the
one that always has to do this so here
come the values they get they all have
to be held together sorted can't proceed
until the entire stream has been
collected together it's still lazy the
operation the sorted operate sorted is
still a lazy method it doesn't cause
evaluation of the of the of the stream
when you when you call it but but it
does but it does but it's it's not lazy
in the sense of allowing for example an
infinite stream you couldn't use it for
that okay so that brings MIT brings me
to the terminal operations the terminal
operations are the ones that return non
stream values typically they're eager
not all of them very nearly older than
they force evaluation of their stream so
here's this a pretty stupid example I
have to say which maps into the one that
I showed you earlier on in this case
we've created the list of the the list
of people with we've used that as a
source of a stream we're mapping each
one of those to a to the city that they
live in and then we're collecting the
then we're collecting the result of the
result of that into a set so it's not
it's not a very clever example but what
it shows is because collect is a
terminal operation what you're going to
end up with there is is the stream
actually will process and you will get
back not it not at the top line here
it's not assignment to a stream but
assignment to a non stream value because
the terminal opera
pulled that pulled a the values from the
source and process them they've gone
through the pipeline been processed and
collected together at the end okay this
so there's there's two kinds of terminal
operations as root the general
reductions and there are these
collections these that I talked about
their mutable mutable reductions so I
want to distinguish amongst ordinary
reductions I want to distinguish two
different kinds because it's really
important to understand the API air have
chosen a kind of stupid very very
primitive example of a reduced operation
that just multiplies two numbers
together so I'm imagining that I'm
working on an inch stream here which has
got a supply of hints and here comes
here comes in in and what I want to do
is I'm going to i want to multiply
together all of the values that come
down this stream so there's got to be
doesn't have to be but I've chosen a
version of reduce that needs a starting
point the starting point for this is
called the identity well the identity
for multiplication is obviously one
that's the number that you're never
going to go wrong with if you want to
know if you want that as a starting
point and multiplying numbers together
than the one to start with this one so
at the top there where the one has just
appeared there it's where i'm going to
accumulate this product all right so 3 x
1 the reduced operation takes the first
the first element there and multiplies
by one and that's okay then it in comes
to and that gets multiplied by what we
have so far the accumulator and that
gives six and then in comes four and so
on the moment now we're finished and we
get 24 and 24 is the answer that comes
out okay so that is one way in which you
can think of reduction but it's not
actually though it's not the way that
you should think of reduction all the
time I mean it's a standard way in which
functional programs do think of
reduction but we are really focused here
on making sure there are no operations
but then we don't support any operations
that can't also be done in parallel so
every reduction needs also to be doable
in this kind of way to here come take on
the values and their multiplied together
and then they get multiplied together
again eventually right so what's
happening you can imagine if you had a
much larger if you had a much larger set
of values that you could get lots of
parallel
working and they would only be there
would only be gradually merge merge
together so in the end obviously in the
end you're going to have to the final
results going to have to be done on a on
a one single process but the reduction
operation there because it is symmetric
it can be it can always be can always be
a merge and there's a kind of divide and
conquer which makes it possible with
with symmetric reductions to to perform
them in parallel and this is this
explains a lot of a lot about the API
because if you look at the reduce the
reduced method for example it the one
that I've the one that I've shown here
takes a binary operator and that's
symmetric the lambda signature for that
it takes to tease and it returns a tee
so that like in the case I just showed
you takes two integers and returns an
integer so if I had a big array of
integers then what I could do is I could
divide that up and do lots and lots and
lots of multiplications and gradually
merge them together if the there are
other overloads of the reduce methods so
for example you can also provide an
accumulator function which will tip
which will take a tea and a you and give
you back at you and gradually build it
up but there's no overload of the of the
reduce method which will take a funk
which will take only an accumulator
function you always have to have a merge
function there at the symmetric kind so
that it's always possible to efficiently
parallel eyes it and that's something
that quite confuses people the first
time they come across the API min and
Max and count I guess are kind of pretty
obvious so that's that's the ordinary
reductions and now the mutable
reductions these click the values of a
stream into a container and they
probably have more complexity than than
than we see anywhere else to array is
also a mutable reduction it takes the
values of takes the values that is
supplied with and dumps them into an
array but I'm not going to talk about
that because it's not so flexible so so
these all work through the collect
method here's the collector the
signature of the collect method it takes
a collector which is parameterized on
three types T anr and it gives you back
and it gives you back an AR the are then
is the the r is the is the
action that you're in some sense the
container that you're collecting your
values into the tea are the values
you're collecting into it and what's the
a the a is the type of an accumulator
which is which is used internally within
the collector and is and is transformed
into the are when when their collective
finishes its work so an example of that
an example of an intermediate type is
for example one collector that you can
have four strings will join them all
together right so the output is the
concatenation of all of all the input
values but the intermediate inside the
collector it doesn't store them as it
doesn't store the intermediate version
as strings it stores them as a
stringbuilder kind of obviously so
that's that's a that's a example of an a
but usually we're not worried about that
usually that's an implementation detail
and what we really care about is the T
and they are so we're going to be
looking at collectors which will take a
stream of T's and put them into a gnar
here's an example of a collector which
will which will take a stream of a
person in this case and collect them
into a set right so so I've got so the
the outer black box here is the collect
method and the and the blue box is the
didn't mean to do that and the blue box
the blue the blue box is the is that is
the collector itself the collector in
this case is has been produced by this
factory method to set in the collectors
class so you don't normally have to
write your own collectors I mean you
often won't write your own collectors
often what you'll be doing is using
these static is using the the results of
calling the factory methods in the
collectors class I'm certainly not going
to talk about anything else today so
this one this one is a two-set collector
it's going to take what's going to
happen is the collect method will take
its input value and it since it's a said
it's going to put it into it it's going
to create an empty set and it's going to
put there it's going to put the incoming
value into that so here's a stream of
person and they're getting put into a
set and eventually when when when the
stream is exhausted by the disappearance
the disappearance of the runway to the
left then what happens is that all that
gets sent out and the output value is
the result of the
the accumulation within the container
okay that what's available with
collectors is kind of quite a wide
variety so I mean you wouldn't normally
think it may be counting as a kind of
container but there's a sense in which
you could summarize the values that have
come down the stream as the number is
you put them into a container which is
like the number of other than have been
and there's more complex ones for int
double and long which will give you a
fairly complex averaging and summarizing
and summing type of type of behavior
strings can be joined together there's
collectors a collector for that you can
take values that have come down have
come down a stream and put the collect
them into a list or into a map well
we'll talk about that or into a set into
a list of assets fairly straightforward
matin really needs a bit more attention
there's a reducing collector and you may
wonder why do I need a reducing
collective and I've got to reduce
operation well we'll maybe see about
that and the rather the last two which
are grouping by and mapping which are
very useful and they're the ones I want
to focus on now because they're a bit
hard to understand so so grouping by the
collective the grouping by clicked it
takes a classifier function so the idea
of the classifier function is to make a
classification mapping and it's much
easier to understand this if you think
of an example something of persons and
cities you can make if you wanted to
make a map from the city if you want to
classify people by the city they live in
you would want to make a map of from
city to list a person okay and you would
and the classifier function for that
would be the one that would take the
wood tip for each person would be to
give you the classification key that you
want that person associated with all
right so we're classifying I mean it's a
characteristic of a person of what city
they live in now we're going to take all
of those all of those the cities that
people live in and for each one we're
going to we're going to map that to the
list of the people that lives there
that's what the grouping by collector
will do so persons are classified
according to the city that this
classifier function gives them and same
classified persons are put into a list
why into a list because that's the
default behavior for this simple
overload of grouping by and the code the
code that will do that is here we're
going to
up with a map from city to list of
person people but city and the and the
and the grouping by collector that will
do that for us his a picture of what it
looks like we've got the clap that
grouping by tate needs a classifier
function and it also needs whether it
doesn't need a collector because it
automatically is going to put this into
a list so the so in comes the classifier
function here is that bill and John live
in London namie lives in Athens and so
what we're going to see is when when
bill comes in it's going to be put into
a list the list that belongs to London
and add amy is going to be put into the
list that belongs to athens and john
also lives in London so he's going to go
into the list that belongs to London I'm
now the stream the input stream is is
exhausted and when the input stream is
exhausted then the then the result of
the of the whole operation is that is
the mapping from which I just went to
too quickly what it does is when the
input stream is exhausted it maps each
of the keys to the to the list of the
values that have been there have been
there have been associated with them so
that's grouping by with this overload
but there's another overload of drooping
by which is actually quite easy to
understand once you've seen it this way
and basically what what this next
overload is designed to do is to address
the case where you don't want to take
where you want to do something different
with same classified of the same
classified values so maybe you don't
want to put them into a list maybe you
want to put them into a set I've just
really done something very simple here
so this one which has which has a
downstream collector allows you to
parameterize the collection behavior
after the after the after the
classifications taking place so this
slide is actually a copy of the previous
one except that I put some just that
what's in red is a change so previously
with the default grouping by that you
just got a list of person because that's
the way it always behaves if you want to
customize it to make a set of person
then you're going to need to use the
doubt a downstream collector here and
and the and the downstream collector
will define the container that the
values
going to be put into so and the code at
the bottom looks really similar we've
got a map from city to set of person
instead of list of person and we've got
and we've added a collector onto we
added the collector on to the end
they're collectors doctor set is the
collector that puts things into a set so
the animation for this looks looks
pretty pretty similar except that
instead of the dead lists that we had
there which were the default with the
previous overload we can now put in our
own collector in this case i put in a
two-set collector neglect has dr. set so
now what's going to happen is ought to
be fairly predictable well bill lives in
London so he's going to go to the
collector that is associated with London
and that's a two-set collector so it
puts him so it puts him into that set ja
Amy lives in Athens so she's going to
she's going to go into the collector
that she's going to be taken in by the
collector that corresponds to to Athens
and that's going to put her into into
the set there because there to set
collectors and then finally in comes
John and John also lives in London so he
too is going to go into there and now
now the input stream is exhausted and
the mapping and the the collector emits
its final output which is a mapping from
each one of the classification keys to
the result of the to the containment
that's taken place so eventually those
things go into the sets that are the
output from the from the downstream
practice and then the whole thing goes
there so when you see this the first
time I think you really probably think
what but I feel like I mean I've been
looking at it for a while maybe you know
like a my brain has been warped but it
feels it feels okay to me now the last
one I want to look at is the is a DAP
mappers and the matter is pretty
straightforward it adapts a collector
accepting elements of one type 2 1
accepting elements of another by
applying a mapping function to each
input element so actually that looks I
mean that's from the API documentation
which for this particular function I
think it's actually actually pretty
pretty comprehensible so basically what
happens is it takes the it's an ordinary
collector but but the values that it's
taking in have been transformed by the
mapping so in this case I might be
I want to make a a set of the city's
people live in and here we go we're
going to take we're going to make a
mapping collector which will first of
all transform people to their cities and
then downstream will put them into a set
so the diagram for that looks like that
there's a map at the mapper it's the
same as the same as a classification
function we had earlier but now it has a
different role the mapping the mapping
method of collectors the factory method
takes a mapper and a downstream
collector and this is what happens it's
going to instead instead of putting
instead of putting the persons into into
the downstream collector it's going to
put the result of the result of the
mapping so so aim Amy lives in Athens
and Athens goes into the set and now
John John lives in London again and
London once more is going to go into the
set but hey its assets oh nothing
nothing happens and then the out then
when the when the input stream is
exhausted the output from here is is now
a set of a set of cities okay right now
is all easy 10 I still give some
problems ah so from a stream of person I
had to add all to these all at last
minute because I realized that all the
problems are set or it's actually we're
all in the code examples and since I
know everyone's going to completely
absorbed the code examples I thought it
wouldn't make it too easy for you but
actually they're pretty similar so so we
so I want to get oh and yeah that's
right so I worked through them they get
they get harder as they go on the first
verse 5 are quite doable from what I've
talked about the sixth one there's need
some stuff I haven't talked about and
the seventh one is a challenge to the to
the the stream mavens in the room so I'm
so I'm going to ask the stream mavens in
the room not to not to help out with the
with the answers here if you know that
if you know this stuff and if you
haven't seen it if you're already
familiar with it I'll ask you don't you
call out the answer unless nobody else
is calling out the answer in which case
please say so Barrett
so a list of adults of age 18 i'll give
you a start on this oh sorry this is
America so we're going to we've got a
list of people and we're going to and
we're going to put that into a stream so
this this this one's pretty easy what's
the method that we're going to use for
that filter right okay and what's the
and what are we put inside of those
brackets filter sorry person dot a is
greater than 21 absolutely and but
remember it's a lambda so we have to
actually specify what we mean by this so
the weight of the way to read this I
guess everybody knows about this right
for each person evaluate whether that
whether the age is greater than 21 that
one's easy I wasn't it wasn't meant to
be too hard and facts and I think the
next one is as well so what I'm going to
do is I'm going to build up each example
from the previous one because it's kind
of because it gets quite hard a later on
to kind of to make them up from scratch
and you often look at things you
previously had so problem to set of ages
of the adults and I've just changed the
first line here because actually but I
think will notice that the the
subsequent lines actually don't relate
very much to what we want to do now we
want a set of integer which are the ages
of all the all the different adults so
people got streams probably all right
what about that what about the filter we
probably still need that but it doesn't
look like the last the last bit is okay
so what are we going to need to do to
get a set of a set of ages at the moment
what we've got here what we're creating
here is a list isn't it and it's a list
of a list of adult a person so we are
going to need we are going to need to
set I had to try to make a guess as to
which and as to which of the two things
we're going to need to do will come up
first and I'm afraid I'm afraid my
animation does it the other way so
what's the other change we're going to
need to make we're going to need to put
in a map army so we need we need to make
a space there and and map what's the
what's the argument we're going to use
for the map
person colon colon get age absolutely
right and and and then and then you're
telling me that this has to be a set and
nautilus and of course you're quite
right so so in this case I've done some
static imports the to set it to set is a
method right but it's on the collectors
class you're always going to do static
import of all the collectors methods
okay so that's set of Ages but of the
adults now we'll get it will get a
little bit more interesting this is what
I want now is to classify people by
their age so I've got a map from integer
to list of person people but people by
age okay so I've got to get rid of some
stuff here I think what don't I need any
longer sorry I don't need the filter
more what are we going to be doing in
the end here pun are we well are we
going to be able to make a list I mean
we mean something what we're going to
need to do will be making a list right
but that's not going to be the whole
story and if we just make a list we're
going to lose the information because
what because we actually need to keep
all the information about a person right
to the end of the pipeline sorry
I'm gonna need I'm going to need
grouping by this is I'm sorry but this
is actually I guess this is kind of a
kind of a classic thing that's demanding
demanding and grouping by I need to what
on what I'm looking for here is a
classification I tried to kind of qu on
this a bit really with this idea of a
classifier function grouping by it's
always going to give you classifier so
the map here is is is is not it's not
what we want any longer but we do need
we do need to collect into something and
what we need to collect into is grouping
by what needs to go into the brackets
okay so so I'm here so I'm hearing get
age button you would think you would
need to say get age and also comment a
list but you don't need to what's the
reason why you don't need to because
it's the default for the for the for the
grouping by method that only takes a
single argument and and now of course
the next one's going to be really easy i
think there's it's pretty easy because
i'm going to ask now about about that's
people by age sorted out looking right
now I'm going to ask you about
population by age so here I want to get
the I want to classify big clue than the
people by the by the age that they are
no i don't sorry what I'm wanting to do
is I wanted to count them by the age of
they are so what so what do I need what
am I going to need here well you know
the problem with count is I mean I need
count at some point but if I start but
if I start counting remember what I'm
looking for here as a map so I've got to
end up with something that is going to
give me a map count is going to give me
a number or a reduction that goes to
counting is going to give me a number
what is going to give me a map what's
going to create a map for me which is
what i really need here it's grooving by
again we again what we're doing it
doesn't look so much like a
classification but that's actually what
it is we really oh no it wasn't what i
meant to da
I guess that's a good idea all right so
we're somewhere that's where that has
come from is that is that we wish we
still have a classification but remember
I said that collectors put put their
values into containers and in containers
would not necessarily look like what you
normally think of as a container so you
don't actually use a sense in which the
count for a for a stream of values is a
container for that for that student
values it's a reduction you okay you've
thrown away almost all very nearly all
of the information except the number of
them that were but it still fits into
the same it fits into the same framework
so so the so counting is a counting as
one of the is one of the collectors you
see now why we have that instead of just
relying on using the count method on
streams because we can use that as a
downstream collector in situations like
this I'm frustrated I did them sorry it
what it were little bit is working on
that what are we ready here we've got
the way taking were classifying the the
input stream by age and then then what's
happening is / same classified for same
classified persons in other words all
persons were the same age they're going
into this counting collector and the
counting collector is just accumulating
the number of them there are it could
have been to set in which case it would
have accumulated a set of them but it's
the counting method so it's just the
counting method is created a factory
method it creates a collector so that is
a factory method on collectors now all
these all these all these collector
creating methods are on collective
switch creating a correct collector and
the collector takes a value in throws it
away but says I got that takes another
one and throws it away I got that hmm
okay names by age how we didn't fit more
or just about on time so so what we're
doing here we want to get we want to map
from from age not to list of
not to list a person but to a list which
we've already seen but to a list of name
and each person has a name right you can
find that out with the with the yet
named method so what are we looking for
here okay so we think we're going to
have to change counting that looks right
to me because this is a downstream
collector but what but what do we need
to change it to ok so I'm hearing lots
of mappings I'm a happy man right so
it's yeah absolutely we're going to have
to what we're doing is we're classifying
them on the age but what is it that
we're doing the classifying well the
mapping is going to is going to do that
for us so what's the so what are the
arguments to mapping going to be
remember remember mapping has a mapping
function which is what it transforms it
into and then it's got the downstream
container sorry person absolutely I'm to
list absolutely Paul marks that man okay
sorry all right so I am happy ok good
question Stewart why is it not the
default and I don't know the answer
that's a good question and I never
thought of it before ok so now I got to
turn and decide am I going to show you
problem 6 aren't the two minutes to go
because I'd have to tell you about that
and I don't want to give you the
impression I mean I what I mean I'm
really happy that you think this is easy
and you're quite right it is easy
unfortunately I haven't told you the
whole story i cant pretend to have so
i'll show you what most popular age is
just and then we'll wrap because i'm on
the hour unfortunately i have told you a
lot but i haven't told you the whole
story about stream api so if you want
the most popular age i've called it the
modal age because that science at the
single one that's most you've got to
what you've got to do is this you get
the pop you get the population by age
which we already got now remember
population by age was a mapping from age
to a list of people i think it was to a
list of person
so now what I've got to do I'm starting
from that point and what I've got to do
and sometimes you do have to do that
with these problems is break it down
into a set of entries each entry is a
single association between an age and a
list of people so I've got to do that
and put them into a stream now that
works fine but then what I'm going to
want to do is I'm going to want to
compare those it's basically the one
that I want the entry that I want is the
one with the longest list of people
associated with it all right and I'm
afraid you won't like this could you use
them because I don't have access to the
it's there is a max function that takes
comparator yeah there is the definitely
definitely is one on one stream so that
would work ok yeah that would be better
so what yeah that's that's a better I'd
thats a better idea than sorting them in
this way but the comparator is actually
that it's producing the comparator
that's really that's really the pain
okay and then once you've done that
that's that's really the story I'll take
questions at the end what we need to
then extract the key because the key on
that entry is that is the the city oh
sorry the age that has the most as the
most are the longest list associated
with it and and then we find them we
find the first one but max would avoid
us having to find the first one so
that's actually a really nice suggestion
thank you and most popular ages we're
not even going to talk about that though
if there was a tie between the most
popular age so in that solution I was
only taking the first one if you want
more than one that's an exercise for the
reader okay so collection processing
with streams does obviously look quite
different but the payoff is going to be
huge and we need to think differently
but i hope what you've got out of today
is that it's not actually that hard some
resources there's the resort there are
not there's not a lot of resources about
this stuff i'm afraid the first three
are by guessing Brian so he's got to
talk today on the on the streams API
which is diff
an emphasis from mine but it's you
should go to that there's a state of the
lambda libraries edition which doesn't
although update it doesn't do much
detail here very useful is the API
documentation for the streams package
and there's also some documentation
written by me and I'm sorry to say that
I don't know of any other so this looks
a bit in modest there's a lambda faq
which is going to have collections
material real soon now and there's the
mastering lambdas java programming in
the multi-core world which is real
soonish not quite not quite the same
thing ah and that brings us to the end
of the talk so i hope you hope you
enjoyed it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>