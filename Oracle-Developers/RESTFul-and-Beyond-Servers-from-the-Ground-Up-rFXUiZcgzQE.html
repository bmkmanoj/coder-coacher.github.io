<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>RESTFul and Beyond: Servers from the Ground Up | Coder Coacher - Coaching Coders</title><meta content="RESTFul and Beyond: Servers from the Ground Up - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>RESTFul and Beyond: Servers from the Ground Up</b></h2><h5 class="post__date">2015-06-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/rFXUiZcgzQE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you everyone for coming my name is
jon heyman this is restful and beyond
hopefully you're in the right session so
what are we talking about today we're
going to be learning to use apache delta
spike to build CDI based applications
building them in microservice fashion so
we're not going to be deploying CDI in a
container we're going to be deploying it
just to a plain jaan SE application
we're going to using some neat
technology so not just CDI jpa being
validation all its up a little bit about
me i'm on the apache dealt spike pmsing
a member of the CDI 20 expert group as
well there's lots of other CDI talks out
there antwon's about their own it's also
speaking today and tomorrow so feel free
to look for those sessions software
architect it's part of systems and you
can capture my Twitter you can also get
all this material on my github account
this bit ly URL bit ly / j 1 dash cut
2184 download the whole presentation the
slides are built in ask a doc and all
the code is don't using maven
so i pre-ordered this presentation a
whole bunch of times in the last two
weeks I decided I'm going to take a
slightly different approach in that
we're going to do it more use case based
so we're going to be learning to build
the API step by step by fulfilling
requirements as we see them coming up I
will be switching back and forth from
code editor and presentation mode so
hopefully nothing gets lost some of the
things that we're looking to do we want
to deploy a simple API server has to be
easy to configure and start up building
course management API just a lightweight
things so we can show REST API is being
built from the ground up using Jack's
for us we're going to create an update
courses save them to a database for the
database and just using h2 it's a local
rebuilt from scratch every time I start
up the application we're allowing people
to enroll in the course free of charge
we're going to not we're going to cap
all the enrollments at five and Roli's
per course we're going to support some
push notifications using WebSockets of
course availability so when a new course
gets created we want to tell any client
that subscribe without the new course we
also want to send out notification when
course fills up so people don't try
joining courses that are full and we
want to track while API requests just
because we're interested in seeing which
AP hours are getting hit the most
so as I mentioned this is mostly ja ve
technology CDI runtime is weld has
anyone worked with CDI before about to
spring people in the room I'm guessing
we're also working with Apache Delta
spike health spike is a suite of CDI
extensions that do some of the basic
ground for you when using CDI they work
in enterprise app servers plus tomcat
jetty you can also use them just plain
SC applications which is what my focus
is today we're also using recipes the
ejects RS runtime about spring MVC folks
in the room Jersey
undertow as well as the servlet
WebSocket container meant to replace tom
cat as you run time or jetty is your
runtime hibernate ORM for jpa I'm sure
everyone in this room is at least
touched hydrating once in their life and
hibernate validator the reference
implication of bean validation so nany
stuff sort of Jackson for Jason
serialization even though e7 introduced
a json parser implementation binding is
much easier to work with and mongodb
just as a blade way non SI no sequel
database to work with finally our
Killian for testing many people may have
heard my name before I published last
year a book arquillian testing guide so
obviously I'm going to be using or
killing for some of the testing in here
so the first thing we need to do is we
have to build the server to do this
we're starting a CDI runtime we need to
start undertow as a servlet container
did you watch with the flash place thank
you and build a reusable undertow
component to handle the integration of a
servlet runtime to the application
so to do this you will notice I have
pre-built most of this stuff my figured
live coding everything from scratch
would be kind of boring for everyone but
I will walk through how we build this
and how we test it
okay so the first thing I'm going to
start with is the test for this code in
this test I want to see that I'm able to
start up a servlet container launch it
and verify that if I go to a specific
URL I'm able to get a response the type
of response that I'm expecting so the
first thing I'm going to look at is this
undertow component it just meant to be a
lightweight easy to reuse class wraps a
lot of the internals around undertow
makes it easy to integrate with this way
your code is never directly tied to
undertow other than the simple component
so we give it a constructor we know some
of the basic things are poor find
address name and context path for this
runtime instance the reason that it has
a name so that you can actually tie
multiple listening ports within a run
time you're not tied to just a single
HTTP port if you want it this is good if
you had things like madmen interfaces
you need to expose for non public use
and then we just build some maps and
list of some of the components that we
may be running registering at runtime
servlets filters and listeners I am
following the Builder pattern here so if
you see as it's getting invoked over
here I'm just instantiating it and
adding servlet telling it to start up
so in here I have the ability to add a
servlet using the web server let
annotation so one of the features of CDI
is the ability to have an incentive in
stantial annotation which is not
possible in the job of language per se
the way this works is we create an
extension of an annotation literal where
the annotation literal is meant to wrap
the actual annotation for you so you're
not directly instantiating a web server
temptation but you are instantiated
something that satisfies everything that
web server it needs to do so we do that
by extending annotation literal type to
web server and then implement web server
since annotations are at interfaces you
can technically implement the interface
we have a constructor that takes all the
necessary arguments
so name URL patterns params acing
supported and load on startup and then
we have wrappers for the methods that
are exposed in the inner annotation that
represent all of the methods that need
to be satisfied so name things like
value we're not using but URL patterns
we are acing support and then some of
the basics like icons and description
we're not particularly interested in if
you really wanted to you could have
setters for those or add other fields to
represent them so this ad servlet method
just registers a new web server look for
you it also takes a servant class the
server class here is going to be your
basic servlet in this case I have a
greeter servlet where i'm specifying a
URL pattern and a name and it just
prints out written we changes to
greetings or anything you want
and then we do the same thing for
filters and listeners will be talking
about WebSocket shortly so the next
thing we do is we use a new Java 8
feature which is functional programming
so we have a function here that is meant
to convert from a map entry of web
server and class into servlet info I'm
servlet info is something used by you
Naruto to register servlets at runtime
sort of their internal class around
servlets we get the web server let
annotation we get the class and then we
use their builder in order to create the
servlet information and as you can see
here we're just calling methods on the
web server let annotation to register it
we're also using a stream as I want to
go through all the anit parameters that
were passed in and add that an it
parameter into the servlet info so this
is a simple and the written that takes a
new nip / am is an argument and then
calls the ad nip Ram method on the
servlet info object and then finally
return that
we do the same thing for filter info we
build the filter info object and wrap
its and vocations in a stream with a
similar for each as over here
now if we look at our start methods
there's a couple of loops that we're
building the first one is listener infos
these are the list of listeners that
have been registered in the runtime so
we're streaming the listeners and then
we're mapping servlets lot listener this
is using a method reference so that
we're just calling the listener method
on the sore ribs class that would be the
same thing as if I were to do this right
here
and then I'm collecting it into a list
of listener and folks I do the same
thing for servlet info except I map it
using the function up here the reason
that I'm using an external function
rather than an inline method reference
like this is simply for readability
purposes to me this is easier to read
since I'm able to clearly identify the
function as defined here at the runtime
and use that to map the entries in the
servlet map into list of servlet infos
and then I do the exact same thing for
the filter info function
finally we build a deployment info we
populate the listeners the filters the
servlets the context path and name and
then the class loader just ways so that
it can identify things at runtime plus
you have to register all of your content
in the beginning we'll talk about this a
little bit more later we also support
serve the context attributes so if that
is not all we're going to add all the
serve the contexts attributes into the
deployment info again using a method
reference you'll notice that in this
case I'm using an instance variable
rather than a class just so that it
knows to use that instance the one that
you saw above for listener is because
it's a static method
finally we create a deployment manager
and deploy the application when we
deploy the application still not
listening on any port so we use undertow
to build a server listening on a certain
port and bind address we give it a
handler reference back to the deployment
manager that was started up and we build
the server we start the server and then
we turn the undertow component again
following the Builder pattern and then
finally we have a stop method to allow
us to shut down the container if we need
it to so looking over here some of the
requirements that we had were easy to
configure so what I'm actually doing
here is I'm leveraging a delta spike
extension that allows me to inject
configuration parameters directly into
method barb class level variables this
allows me to just read a configuration
file at runtime and automatically bind
the contents of that config file to
objects in the runtime to do that what
I'm doing is I'm creating this example
config source that extends the Delta
spike property file config and telling
it to look for the file called se
example tower properties if I open up
that file you'll see that I have a bunch
of buying ports address route and
deployment name defined in here so these
values these four values here will be
automatically injected into these four
parameters over here and it just so
happens that these four parameters are
the four parameters that I need to build
a new undertow component
I add my greeter servlet which as we saw
here was defined over here and what I'm
doing within this is I'm getting the web
serve that annotation on the greeter
servlet by calling get annotation on the
class I pass in the servlet class and
then I start up the runtime so at this
point the runtime is running I will have
a listening port and a bind address all
listen all configured and running based
on the configuration that I have here
so my test method what i'm doing is i'm
using our killian to build a uber jar
that has all of the run time that i need
from this application plus the run time
that i need from delta spike I inject a
reference to the servlet deployer which
is the class that i'm showing here i
start the application i build a URL
based on the URL that i know and then i
open an inputstream read the contents
now instead of written i'm going to see
breedings come back and then I close the
stream and then I shut down the
application we can run this test
great
skill set
okay let's try this one more time
why
sorry about that I reham ported my
project this morning okay so what we can
see here in IntelliJ is that CBI is in
fact starting up we can see shrink-wrap
is running in order to load the naval
configuration of my palm file it loaded
the config over here and we can see that
the test did pass so I was able to read
the right response from the server so
what have we done so far we were able to
start a CD hour run time in a test
environment wave are a little to use on
your toe to run the servlet container
and then build a reusable undertow
component so the next topic to look at
is container control this is a delta
spike specific feature although is being
considered for CDI 20 what it allows you
to do is start the container
automatically through some code as part
of a main method or something along
those lines to bring up CDI for you
you're no longer tied to using CDI
within an application server runtime
so to do that we have a startup
component that we're going to implement
this startup component has two simple
methods start and register shut down
hook in the start method we're getting a
reference to the CDI container so it's
going to look at your classpath and
identify what CDI runtime you're
currently using it's going to boot that
container and start all contexts
starting all the context allows things
like your application scope run time to
start up your request scopes to start up
and is generally needed to run most
applications one of the things that CDI
does add for you is the ability to tie
objects to various scopes if you're
looking at other dependency injection
frameworks you have things like a global
scope it's a singleton object or you
might have a prototype object which is
new reference every time it's brought up
in CDI we define five or six different
scopes that allow you to create objects
with different life cycles request
scopes tying you to an HTTP request or
thread in certain cases session scope
tying you to an HTTP session then you
have more global things like application
scope and singleton which are meant to
be global for an entire application you
also have the pending scope which is a
new instance will be provided to you
every time you try to reference it but
the star context is meant to just
initialize all the default context for
you we register shut down hooks so that
when the JVM exits we want to shut down
our CD I runtime we don't want it to be
lingering around we want to ensure that
it does close so what we do is register
shut down hook in the runtime using a
thread with a reference back to the CDI
container over here
finally after we've urged them to shut
down hook we tell the application that
it's ready to start so we fire this
application startup event using the CDI
utility class in order to start any
application components that need to
start it on startup this is roughly the
equivalent of doing eager instantiation
or singleton with startup annotations in
your ejb runtime so this essentially
becomes our main method as you can see
I've defined main in here to do start up
for us
what i can do is i can build the
application for you and we can see
I'm just going to skip test for the sake
of not running everything at once
ok
so now that I've built the application
what I've set up in this project is a
maven assembly so that all my binaries
end up going into a directory as output
so if I look here I have a shell script
a live in a calm folder in my
configuration I have some property files
that are going to be using later on and
in my library's I have all my
dependencies over here fortunately do
end up with a lot of NC's when you build
this way if i look at my shell script
you can see that all i'm doing is i'm
building a classpath setting log4j
configuration and using the startup
class in order to start the application
if I want to I can run this shell script
and see that weld starts up my
application starts up and everything's
running and I now have something with
saying for 87 87 I'll be looking at more
on what's 80 on 87 87 later so we now at
least have a way to start the
application outside of a test
so as I mentioned there is no eager
instantiation in CDI the closest thing
you can do is firing an event on startup
you may want to do this with an
extension eagerly load things like HTTP
listeners or entity managers on startup
for you maybe you want to verify that
your databases running before you try
booting the application in CDI 10 the
only solution that you had was the
solution that I just showed you firing
an application startup event or
something along those lines application
startup event is something custom that I
grow
it doesn't do anything it's just a
simple class that's out there you can
instantiate it and fire it in CDI 11 we
now have an initialized annotation which
can be used anytime you initialize a new
context this would allow things like
having an application scope beam that
starts eagerly we can see that over here
where I observe the initialization of
the application scope so when the
application scope starts up you're going
to see this being getting San Shi ated
automatically you'll see though that
when I do instantiate and I am using the
post construct call back if you were to
observe this object this initialized
object you're potentially going to have
repeat firing so if someone were to put
in some bad code that maybe refire the
exact same qualifier here you could have
your application startup a second time
or third time or five hundred times
which would be very bad you probably run
into some out of memory exceptions or
permgen issues so you want to keep your
instantiation code still within some
sort of post construct you don't want to
do your instantiation as a part of the
observer method
so the next part that we want to do is
do some emulations of container behavior
so one of the things that you lose when
you move to this approach is the
application doesn't know anything about
servlets it doesn't know anything about
HTTP requests it just knows that there's
some threads running so you have to do
some of that instantiation yourself
Delta spike has an extension that allows
you to handle this using context control
context control allows you to start up a
scope for the duration of a thread and
then shut down that scope you can even
do it mid thread so if you wanted to you
could start a request stop a request
start a request stop a request so what
I'm going to do is I'm going to start a
request listener
okay so i have this HTTP servlet
listener defined within my code this
server the listener is meant to start
the request scope for me anytime an
incoming HTTP request comes in and then
stop it once the request is destroyed so
you never fix that part so in the
request initialize I'm observing the
reserve lit request event and similarly
in the request destroyed I'm also
observing this event this is the same
event that is used in your servlet API
so this is no different this would work
for you and tom cat jetty as well so in
here what i'm doing is i'm taking my
contacts control which is just a CDI
bean all i have here in my get contacts
controls a usage of the CDI utility
library to look up the context control
class and return that back to a caller
when i start this context control i'm
going to put it into the server context
as an attribute we want to ensure that
we're getting the same sort of the same
context control for both the startup and
the shutdown we don't want to get two
different ones the context control is a
dependent being it is meant to be
instantiated every time you're looking
to get a new one when the request is
destroyed I'm shutting down by context
over here so I look up the context
control object that's in the servlet
request and then I just call stop
context on request scoped the opposite
of what i was doing up here are starting
the context this says that there's no
longer and CDI request contexts
associated to this thread
this would allow me to reuse requests
scoped objects within incoming HTTP
requests
so we already talked a little bit about
configuration tools as you saw i was
able to inject references to different
beings within the application you have
to specify your config sources as beans
so if you look back here at my example
config source i'm giving it the
application scoped annotation so that a
single instance of it is created at
runtime I'm also telling it to just use
this one property file if I wanted to I
can have multiple property files to find
and look them up at runtime so I have
another one to find here called app
config which just looks that application
configuration doc properties two
different config files are being loaded
for you so what this means is that no
matter what bean I'm looking at it's
going to look at either of those to try
to resolve configuration properties so
these properties here versus
these properties over here where they're
defined in two different config files
so simply by providing this app config
class I'm allowed to inject any
parameter found in that file so we saw
that you can build a listener to start
your quest scope you can also do things
like build interceptors to do the same
thing what this is useful for is beings
that don't support any sort of context
where invocation for those who have
programmed against the WebSocket jsr
you'll notice that it has no real CDI
support to it other than allowing you to
do some basic injection the Interceptor
would allow you to start a context
during invocation so that the invocation
can't rub did include a request scope
we'll talk a little bit more about that
in the WebSocket section but basically
you can have an intercept they're
defined here where you start a request
scope call the method on the beam that's
being invoked and then stop the scope
there when the invocation is complete
so we do want to check to see if the
request scope is active first you
probably don't want to start in multiple
H ap context within a single threat in
most use cases you want there to be a
single one so what this will do is look
to see if there's a request scope active
first and if there is or if there is not
then start the request scope we allow
the context to proceed and then in a
finally block as long as we have a
context control let's stop the request
scope object as you can see here I'm
only getting the context control when
the request scope is not already active
you also see things appear like starts
request scope this acts as the
Interceptor binding for you you would
put this annotation on to being methods
or being classes where you want to bear
method invocations to start a request
scope for you we also have the priority
annotation this is a very easy way to
start the Interceptor without having to
register the Interceptor in your beings
XML this is a new addition with in java
ee 7 as part of the intercept
interceptor specification
so the other thing that we probably want
to address with undertow is the objects
by default are not CDI managed and this
is a general problem for servlet
containers we want servlets we want your
filters or listeners to BCD eyewear so
that you can inject references into them
without some features like this we
wouldn't be able to do that thankfully
undertow allows us to override their
default behavior so what we can do is
define a class inspector which is an
undertow specific feature unfortunately
that allows us to manage the instance
creation of objects the create instance
factory is used by the class inspector
in order to wrap the instance creation
for you you see that I have to go
through a few levels but eventually I do
get to something that is CDI specific
where I'm trying to get a CDI instance
handle where the CDI instance handle is
using the CDI utility library to get a
reference to the class in order to look
it up within the CDI context this would
be similar to look it up in your
application context but all this is
required in order for me to make things
like servlets and filters CDI aware
so going back to the actual application
some of the things that I did skip over
a little simply because I wanted to come
back to them later if you look over here
I'm getting a reference to the CDR class
introspect er when I'm starting up my
undertow component when I do this I can
tie it into the deployment and say use
my intro Specter when instantiating
objects and it'll use it'll give you CD
eyewear objects so now if I go back to
my greeter and I do something
I have this request invoker class I can
take this request invoker and now inject
it into my greeter servlet
I can then do something like Oh actually
I'm going to add a new method is called
do work
so instead of me hard coding in my
servlet what the response is going to be
I'm going to instead call my request
invoker to get me what the response
should look like
the other thing that I have to do now is
I have to register my servlet listener
so that service listener we just looked
at where we start a request scope
not only do I have to tie my servlet in
here but I also have to tie my listener
and
so now when this component starts up
it's going to actually start any TP
request for me and if I rerun that same
test
oh good so you can see that it still
failed what's happened here is I failed
to add the request object the request
invoker object into my deployment
archive so if I go back to my start test
I will add a new class
and try running this one more time
okay good still felt
ok
so we got a 500 error now fortunately
right now with the way I have this set
up you can't see stack trace so let me
go ahead and add that in as well
so if we want to troubleshoot what's
happening easiest way is just add your
stack trace into your output
okay let's see and for now
alright
alright let's try this out
Oh
and
alright i'm not sure why this is failing
right now so anyways let me go ahead and
undo this
alright
so let's talk a little bit persistence
then and the data module within Delta
spike we have a number of extensions
around database persistence management
they allow you to ease your
configuration of jpa at runtime you can
use injectable configuration you can
load config files at runtime we also
have the ability to automatically
generate dowels for you so there's no
more need to build it out directly no
code required so there's a few different
ways that you can try tackling this the
first one that I kind of referred to as
the long way is to specify configuration
properties and manually build your
persistence context at runtime this is a
lot of work it requires you to know all
the configuration properties you want to
load it requires you to know what the
structure is of your object of your jpa
implementation so you're kind of limited
in what parameters you can use
so to do that we're going to do
something like this in a nit method load
all the properties that we need at
runtime and then build the entitymanager
factory by calling persistence I'll
create an energy manager you can see
what this looks like by looking over
here so what we were doing is we are
injecting all those config properties
these are again loaded from config files
on the file system and we're
initializing the entity mataji and an
entity manager factory for you we're
also leveraging a CDI feature that
allows you to produce and dispose of
objects as a part of your application
code so what i'm doing here is I created
a producer method this producer method
is basically dynamic generation of CDI
objects for you at runtime it will
create a reference to an entity manager
that you can then inject within your
code this is similar to using something
like add persistence context or at
persistence unit except it's using add
inject to get a reference I also have to
do things like Vinick begin a
transaction in here i'm using a resource
local JPM editor or kpa entitymanager
and in here because of that I have to
manually create a transaction it's not
going to be started for me at runtime
you can see within my test what i'm
doing is i'm starting a request scope
without that request scope this producer
method is not going to be satisfied as
you can see when i produce it i'm saying
that it should be a request co-editing
manager this is similar to that old
hibernate paradigm of threadlocal
sessions where you're reusing the object
for the entire HTTP requests and only
committing it
when everything is done in my disposer
method which is this method down here
what I'm saying is one of them you're
ready to clean up the enemy manager call
this method this method will go in and
commit or rollback the transaction for
you and then close the entity manager
this is pretty much the same thing you
would use anytime you're using jpa
outside of an application server so in
this test what i'm doing is i'm getting
a reference that entitymanager down here
I'm saving the employee and then I'm
stopping the requests ghost I want to
test this right now i'm using a CDI
feature that allows me to turn off
certain classes called vetoed all right
i can run this test hopefully this one
doesn't start failing either
alright
did get a green bar so hopefully that
means everything worked so you can see
all the hibernate startup happening here
CDI starting up as well and then test
completing so this approach to creating
the persistence the entitymanager it
have some problems to it because it
directly ties your parameters here to
the parameters that need to be passed
into the entity manager because of that
if someone needed to add new
configuration parameters at runtime you
wouldn't be able to use this so we can
use a slightly shorter version of this
test here to see how that works what
we're doing instead is we're using any
manager factory using delta spikes
persistence unit name as a injection
point this will start up the
entitymanager factory for you at runtime
without needing to configure anything
what it does is it looks for a file
called persistence dash whatever your
unit name is dot properties these
properties can be updated at runtime so
that you can add more configuration as
you need to if you need to print out the
raw sequel the parameters that are being
passed in you can just update the
property file to see that information
all you have to do is provide a producer
method for your entity manager and then
manage the transaction
so you can see that here again I'm using
an injection point for the entitymanager
factory rather than manually building in
and manager factory that I did before
nope wrong test so as you can see here I
no longer have to do any of this to
create the entity manager I still have
to do things like manage transaction
though which is not ideal but it's at
least usable and some code so my
producer my disposal methods are still
listed to hear
the last part that I have is the actual
transaction management so instead of
having to manage the transaction even
anytime you're using resource local you
can use our built-in transaction manager
to start and stop the transaction for
you this was actually a precursor to the
java ee 7 and transactional support that
was added in the most recent AP is so in
here all i'm doing is i'm getting a
reference to a transaction dean and i'm
telling it to create the employee inside
my transaction being my create employee
method simply instantiates an employee
and get some at nity manager and persist
the employee so there is one maybe two
complications that this introduces the
first is that I have to annotate a bean
at transactional this a transactional is
kind of like a CDI scope that will start
up it is sort of an interceptor sort of
a scope where any method invocation is
going to be wrapped in two contexts the
first context being the transaction
context basically a custom scope that
allows you to tie all beings into a
single transaction this allows you to
nest if you were persisting multiple
objects at once into a single
transaction call roll back the whole
transaction at once you're done if you
need to or commit it all together
so let me go ahead and run this too
oh boy
alright
when in doubt switch through command
line
I'm
there we go so for some reason it
doesn't want to load in the IDE but what
it's what's happening here is we can see
that any employees are being inserted
and we're committing the transaction
what we're done you can see the commits
happening down here this shows us that
it is being fully committed to the
database and is being managed as a
transaction so to do this we had to add
a bunch more feature so are the JPA
module for delta spike is the key here
it allows you to control transactions in
four different ways resource local is
the default option designed for servlet
runtime zor SE runtimes you can also tie
it into the JTA transaction manager
so first is that you have a beam manage
user transaction strategy that allows
you to use djb be managed transactions
you also have container manage
transaction strategy and environment
aware transaction strategy environmental
where transaction strategies if you had
different project stages or different
environments that you may be running in
it'll look to see what kind of
environment it is in before starting and
managing transaction and as I mentioned
the resource local transaction strategy
is the default if you want it to switch
any of these you'll see that they're
annotated alternative alternatives are
just different implementations of beans
that allow you to have slightly
different behaviors this is controlled
in your beans on XML by going in and
simply switching on an alternative
so now if i were to rerun this i would
get be managed to user transaction
strategy instead which obviously won't
work is on in SE mode
so the only other thing that we had add
to this was a producer method
so this producer method is meant to wrap
all that dealt spike functionality so I
have it as an application scoped object
I can even tell to do this on startup to
make sure that the entity manager
factory does start up for me
and now this will cause it to start up
at runtime I do still have to provide a
producer method for my entitymanager
except it is tied to a transaction scope
rather than a request scope so anytime a
new transaction starts up you're going
to get a new entity manager
so as you can see when we clean
everything up all we have to do is
provide a producer method for
entitymanager this is meant to allow you
to look up different entity managers at
runtime in case you have different
database connections that you were
talking to we also have some simple
acquiring support we can look at instead
of having to build douse you can just
use our repositories to look up objects
and our repositories are just interfaces
so this is literally an entire tab no
additional methods required
so we have another transaction being
that we can look at where instead of
using the entity manager we're using an
employee repository for that employee
repository okay I did add a method later
on but this employee repositories just
meant to allow you to look up save
delete objects from your database we can
inject a reference to it and then save
the employee printing out their ID we
can also add a method like find all
employees to see who's in the database
there are other methods available within
the repository by default so find by
name fine bye you can give it some
object search based on eating accounts
delete remove refresh so on the way
these work is using a proxy at runtime
so this employee repository will be
proxied using an interceptor the
Interceptor binding is this annotation
up here at repository it's a slightly
different version of an interceptor
binding called partial beam binding
which is our wrapper api for anything
using a dynamic proxy
you can do other things in here as you
saw for example if I wanted to write a
JP ql query or an HQ al-kuwari I can add
that as a query here and it will be used
at run time instead of using any find
that you may defined in here if it was a
named query
so it's going to look for a named query
with this name on it and use that query
at runtime in order to execute this
method we do have to use a parameter
here on the method argument to give us
access to the name of the value the for
jdk 8 you had no direct reference to met
parameter names that's a new feature
within Java aid so until we're able to
support that you have to tie in the
query parameter as a method argument so
finally we're going to get to the point
where we're building the actual REST API
we're going to be leveraging a lot of
what we just put together and look that
in order to build this API
so within our course rest api i'm just
using jax-rs annotations to define where
it's going to live and what the object
types are going to be at runtime I give
it the transactional annotation so that
it knows to start a transaction this
means that every incoming request is
going to start the transaction for us
we're going to get a single entity
manager in case it we're updating
multiple tables and close that any
manager when we're done I also say that
the object is request scoped this will
happen for you automatically in your
jax-rs runtime and allows you to have a
single instance of this for every HTTP
request it also means that you're only
going to have you're not going to have
to deal with any pools of objects when
dealing with the incoming requests so we
have a couple of crud methods that we're
looking at the first is to find all
courses
so to do this we created a course
repository same same idea as the
employee repository we just looked at
where it's extending from the entity
repository and using a query to find any
course either by ID or to list all the
courses I am using a left join to
optionally fetch enrollments and course
may not have any enrollments in it and
it could also be that the course doesn't
exist in which case we need to handle
that a little bit gracefully
what I'm doing in here is I'm wrapping
the course in a POJO where it just wraps
a list of courses makes a little bit
cleaner and the JSON output I'm
populating courses based on course
repository lists all courses and then
returning that object I do something
similar when finding a course except
them directly returning that object I
also have things like update course
where I save the course and return the
object back and I also support creating
a course here so you're able to take the
JSON object of a course and persist it
directly to the database no need for any
intermediate objects so we're calling a
safe method here on the repository to
persistent
pure call back few slides
we wanted to do things like allow people
to enroll for courses and don't allow
new enrollments after five courses as
well as the basic creation and read of
courses saving them to the database
so when we do this we can see we added
support for enrolling into a course
based on the course ID and enrollment
object that's coming in we find a course
based on its ID we set the course in the
enrollment and save that enrollment to
the database so if we want to we can
start to test this out and see how well
it's doing
Oh
okay so what we're doing in here is
we're directly starting the context as a
part of the test case so we're using CDI
container or using context control as
part of the before class and after class
of this test clay test case so we're
doing the same thing that that startup
method was doing we could even replace
this technically with that sort of class
so if instead of this we wanted to we
could do startup
and that will start it up we then no
longer need these guys over here
so the first thing we want to do is we
want to see that we're able to create a
course to do this we're going to
leverage the jax-rs to client api's to
get a reference to a client we know that
the applications can be listening on
port 80 787 and based on the api that
we're consuming we're going to point to
slash courses
we're telling it to post the course that
we created which is just course name
course one and then get the course ID of
the resulting object so if you look back
at the REST API what's coming over when
we create a course is the managed object
we can then try to get that course again
and verify that the object coming back
is the same object that we were
intending for
so i can run just this one test
and see
that there was in fact one course
created when I ran this this course will
just be that course with the name one as
we can see here in the test we're
verifying things like the course ID and
this course ID here
we can then run a test to verify that
we're able to list the number of courses
together so assuming that we've created
a bunch of courses we can then loop
through them and post each of them into
the rest api to do this i am using a
simple lambda that loops to reach course
and then post it to the rest endpoint
what i call yet i'm going to get back
the courses and verify the size is great
at least greater than or equal to the
given course list the reason I'm using
greater than or equal to is because when
I was running this it was running
against all these tests running in
parallel the database doesn't get
destroyed with each test call if I
wanted to I can do
this because I know my database will be
destroyed
and see that I do in fact get three
courses coming back you can see with
every invocation I just have a filter
running so you can see that there was a
request coming in and there were a total
of four requests three to create and
then one to get the list
we can also do some things like testing
enrollment to have to change one thing
we haven't quite gotten area so what I'm
going to do here is I'm going to even
ignore the WebSocket stuff right now but
I'm going to do the same thing i'm going
to create some courses and then i'm
going to try to enroll six times now we
know right now that it's going to allow
the enrollment for the six times
so let this run
so we can see the names of the people
who were enrolled and you can see what
I'm doing in this loop is I'm just
adding a number to the end of John Doe
showing that John Doe 0 through five
have all been registered for the course
now this wasn't supposed to have worked
we were supposed to cap the enrollment
at five enrollees the reason for that
working is because there's no validation
right now in the size of the enrollments
if I instead use the enroll method here
I'm going to be able to use Java X
validator the job X validator just
allows me to see what constraints have
been violated by method invocation so
I'm validating the new enrollment class
of the course the way this works is we
define a group of validations so this
new enrollment means for anything new
coming in the size has to be great less
than or equal to 5 so you can see that
sighs max for groups the new enrollment
group and then course enrollments full
as the response message and this is a
validation constrained place directly on
the field in the JPA object so I'm going
to go in I'm going to validate the
incoming course so when I pull up the
course by its ID I should get some
validations when i get to the sixth
iteration if it's empty meaning there's
no validation problems i'm just going to
send out of notification actually we'll
talk about this when we go through web
sockets i'm going to send i'm going to
say that enrollment to the database if
there was a problem i'm going to loop
through the count the validation
constraints and append whatever message
is appearing and then throw a runtime
exception with those messages
so let me go ahead and run this one more
time
very
good
so if you recall and when I ran the test
last time I told it go through six
iterations and when it gets to hear to
expect six I know I have to tell to
expect five so as you saw we got an
assertion error expected six but it was
actually five enrollments so what's
happening here is the client is
receiving back an error
in this case I didn't wrap the error in
any specific HTTP response code so it's
going to come back with it as a 500
error probably not ideal for real use
cases I'm going to try to read the body
and verify that the course enrollments
full message was displayed I can put
garbage checks in there to verify that
I'm seeing something exactly as expected
so I expected see full 29 said saw full
so I am getting the right error message
back as well
close the response
so the way the validation is now working
is it's only going to be invoked when we
explicitly ask for it in that group
there is so it allow you to create other
enrollments for example when you're
directly calling jpa there's a built-in
javac validation support where we'll try
to validate all objects if this group
wasn't here you would actually see the
error happened during persistence rather
than during validation phase putting it
into the persistence layer makes it a
little bit harder to find out the error
so I decided to put it here in the group
instead
okay so now let's move on to web sockets
so as I mentioned the WebSocket jsr has
very limited CDI integration we want to
do things like start a request scope any
time a new messages received either
client or server and unfortunately this
means that most of the work that we have
to do for the integration is
platform-specific although you can do
similar things with tyrus with tomcat in
order to make your web sockets work in
those containers it's a similar problem
to MDB s where mbbs don't really define
a scope that is started when a message
is received by the beam we also want to
do something like manage the instance
creation so as you saw i was using a
class inch respecter which is an
undertow specific object to wrap the
instance creation we're going to use
that here to also wrap the creation of
WebSocket components so here i have a
very simple server WebSocket server i
have a post construct in here which
means that it will be invoked using CDI
creation every time I get a new message
I'm going to start a request scope using
that interceptor that I mentioned
earlier now i'm going to respond to the
incoming session with some data
so in here what's going to happen is
every time a new message comes in I'm
going to use that request invoker and
tell it to call it sin request scope
method that says I'm in request scope
and then respond with foo plus whatever
they pass then just a simple chat back
and forth so we can see messages going
from client to server
so when building the test I'm using a
number deployer except this time i am
telling it to register a web socket
endpoint which is this responder server
defined in here so that means that this
responder server will be launched by the
undertow runtime I can then run this
test because all I'm looking for at this
point is communication back and forth I
use a test client to do some additional
CDI integration since my tests are
running within the same jvm as the
application I do have access to the same
CDI runtime which is a little bit
cheating but it gives me the ability to
communicate from client to server or
even though client and server are the
same program and I do to find that
starts request scope over here so that
every time it comes in it's going to try
to do things like get a request scope
and then countdown some latch I'm
telling it I'm expecting five messages
in here which matches the test case that
I've defined over here where I'm going
to send five messages so by the time
this is done I should see that the latch
has been counted down to zero
ok
alright so we can see here that it
created the client created the server
we then see the server receiving
messages the client receiving messages
and so on until we get to the bottom so
we can see that all five of these were
received both client and server
basically the client and server are able
to talk to one another we can use this
as we have requirements to push
information from server to client when
certain things happen so within our core
CPI we can see that there is a client
connection component all this does
is we have a core server the core server
is meant to be where clients connect to
during WebSocket and location so this
could be your JavaScript client a Java
client anything that can support the
WebSocket protocol any time there's a
new session open we add that session to
this client connection component where
this client connection component is
simply an application scope object that
keeps track of all the open sessions
when we remove a session we obviously
want to remove it from the map so on
clothes we're removing the session and
then any time we're receiving a message
we simply print that out on the server
side we don't expect any messages to
actually come into the server
we can notify all the sessions about a
message coming in to do this we loop
through all the sessions in the map and
we try sending a text message to them so
any session that's already in here you
would be able to just loop through and
try pushing something when I'm using the
basic remote it's going to do it
synchronously if this is a large number
of sessions I'm probably going to want
an async remote to do that work
so if I go in here if I go back to my
course API what we saw was any time
we're creating a course we're notifying
all sessions about the new course being
available so a new course has been
created anytime the enrollment fills up
as we saw so the enrollments I the list
of enrollments is for the reason we're
using for is because the next one to be
added will be the fifth one we indicate
that the course has reached max
enrollments so if i run that crud test
one more time
we can see first that I am getting a
WebSocket container and I am connecting
to the core server I tell to use my
course client which is this guy here it
keeps track of all the incoming messages
for me so it's on message simply adds
whatever text came into a list of
strings and then I provide a getter for
those messages as well we're going to
set the idle timeout to 50 seconds I'm
going to reduce it to four just for the
sake of the demo and then like before we
are still using the web client to invoke
the HTTP request and at the very bottom
we do see
that we are getting the course clients
messages and printing them all out so if
i run this test one more time
the right thing
okay so you can see here first that what
we're seeing is there's one session
connected because I only create one
session during my test case if I created
multiple sessions I would actually see e
to them in here
so this would actually create a second
session
we see that it is trying to send to the
session ID to find in here finally we
see that at the end of the Texas cution
new course e1 has been created and then
finally course one is reach max in
Romans so we know that we've pushed to
the client first that the course has
been created and then that the max
enrollments did a car if I run this test
one more time with the additional
session
you can now see that there are four
messages pushed in so even though I'm
creating two sessions because i'm using
statics within the client it's only
going to keep track of it once so we see
that both were pushed approximately the
same time up a new course being created
and then both are being created at the
same time about their maximal elements
so the last thing we have to tackle for
the current requirements is a filter for
tracking API invocations to do this
we're going to implement a jax-rs filter
to catch every request coming in store
it in the database
so what we do here is we implement two
different filters a container request
filter in a container response filter
the container request filter is for
every incoming request up here and the
response filter include is done for
every out for every request that's been
completed and response is going out we
are using a MongoDB instance to store
the API hits as we expect the api's to
be hit very frequently and we may want
to do some analytics to determine who's
getting invoked the most i am using a
tool called morphia from MongoDB to do
basic ORM in no sequel environment I
could use ogm as well from hibernate to
do that mapping morphia seemed a little
bit easier to work with I have an insert
method that simply returns an ID and
then the DB name so I know what database
i'm going to i can have any number of
databases in my MongoDB instance so in
the API hit down the only thing
additional that we define is a find all
so that we can get the list of API hits
that are available we may want to do
this to expose REST API that provides
this list as well
so if we go back to the filter the way
the filter is tied is using this
provider annotation anything that's
annotated provider will be automatically
bound in the jax-rs run time so that
incoming requests will populate and go
through this filter in the actual logic
here all I'm doing is in San cheating
the pojo storing the URI that's being
invoked in the start time of the request
I then put it as a request context
parameter so that I can look it up when
the request is done if I want to do
things like store how long it took for
the incoming request to happen we can
see that we get the API hit as long as
not null converted into the API hit
object populate the end time and then
insert into the database we've already
run this a bunch of times so we can
actually see in the database instance
what's in here
so I have an epi database
if I call hit stuff
Oh
sorry
so if I look here you can see that what
i call the find function on the hits
i'll get a list of all the objects that
were stored so the ID is the class name
the start and end time so we can see how
quickly in vacations are getting through
is what the as well as what the URL is
that they're invoking if i wanted to i
can do a count and see that we didn't
totally done 45 invocations that are
gone through the rest api and these will
mostly be urls against the courses api
we're soaring dates so that we can do
the diff as we can see most invocations
or taking milliseconds to run so Oh
point 35 0 point 0 35 2 point 0 to 6
you're talking about a little over 100
milliseconds for the invocation to run
and we can actually see as it's being
invoked more and more the time actually
gets less so point 466 2.47 to it took a
little just about six milliseconds for
it to run so we're seeing very high
fruit but as this is being invoked
so how do we do the MongoDB integration
the first part is in the Dow we have a
simple object structure where we define
a base class with some of the work in it
we inject the Mongo client to do that
we're providing a producer method that
gives us access to the MongoDB
connection we're going to look in
whatever configuration properties that
we have for the series of mongo
connections it could be a single server
it could be multiple servers but we are
looking for this configuration property
if i look at my application config i can
see that i have Mongo connections to
find here is this localhost 20 70 17
which is the default parameters and I
provide an application scope producer
method to get a reference the Mongo
client this would allow me to have
multiple consumers of the same client
over and over
so so far we've done everything the
requirements have looked for however
realize that there's a problem we're
allowing anyone to enroll and anyone to
create a course so we want to do some
level of security integration so that
we're blocking only certain people from
invoking the api's so delta spike has a
large number of security integrations
that are based on interceptor strategy
what this is meant to be a simple
annotation based interceptors that allow
you to look at incoming requests and do
some sort of authentication of the user
coming in so first thing we have is a
course create authorizer this authorizer
is looking at the invocation context and
a logged-in user in order to verify that
the user has specific group so to do
that the first thing we have to do is
create a user object what we're going to
do with this user object is simply tie
him to a request scope so left for any
incoming request it's one user who's
logging in we want to authenticate all
incoming HTTP requests as well so he has
username and he has a series of groups
what I've done here is implement a
simple user manager the user manager
looks up the user from a file on the
file system in this case users are
properties where users are properties
just lists a simple key value of
username password not very robust
security but some level of security we
also lo the group's class the group's
file at runtime which looks basically
the same it says for any given user what
roles that they have in the system
in this user manager because we're
building properties with the users and
the groups we want to expose certain
things like is the user authenticated so
we're validating credentials again using
javac validation to verify things like
user name and size of the user name is
valid gives us a little bit more of
declarative approach I don't have to
litter my code with if user name doesn't
equal null and password those an equal
null then do all this stuff this will
automatically do that checking for me I
can also look at the groups that a user
has by providing a list of strings of
that group that are in the group
parameter as you can see it's looking
for a comma so if I were looking in the
group stop properties I can do something
like this and it will add more groups
the list
so if we look at the course create
authorizer we're saying that we're
looking for an invocation context and a
user so this user has to somehow get
populated when an incoming request comes
in to do that i'm going to add another
filter to the context this one is just a
provider that implements their container
request filter it's going to look for an
authorization header and parse the basic
parameters that are in here which should
simply be wrapped in a base64 basics
before being then one of the newer
features in Java 8 where we finally have
be 64 support built into the language
I'm going to validate the credential I'm
going to set the user name when we set
the group what's going to happen in here
is if for some reason there's no user
name it's going to throw an exception so
if I go back to my test
you can see here that I'm not doing
anything yet to populate the header I
need to populate now the header for
course create with the admin user
obviously don't do this in your real
code
so now I'm going to get a header with
the base64 credential I'm going to put
that header into the Ingo the outgoing
request
so now any outcome your request is going
to include the basic header with
username and password in it if I go back
into my rest api you can see that i
previously had the course grade binding
on here if I uncomment that now any time
you try to call the create course API
it's going to verify that the user has
an appropriate role to test this out
what I'm going to do is instead of admin
i'm going to put admin to as my user and
see that this fails
good so now you can see that the object
going out was not something I could
understand Oh
sorry
okay go send it sorry so you can see now
that I was trying to read chase on that
it couldn't understand this is because
I'm telling it in the client to always
expect the JSON object as response so
what I want to do here now is look at
the response and get the status code
so move that up in here
and I want to verify things like did I
get a 500
I still want to close my response when
i'm done with it so if i run this one
more time
I'll see that it was successful I was
able to get a response
and if i look at the entity
Oh
and then
and we run this test one more time
I get back the message invalid user
admin too that's coming from in here in
my login rest filter
so as we can see in the filter we're
calling user manager validate credential
and it's trying to find the user it's
saying that it got a user but the
password didn't match the password those
in here so i get back invalid user
username so i go into users up
properties i can add admin to in here
and we run this test one more time
and see that it was able to successfully
authenticate the user now so the user is
in the system
the other thing that we wanted to verify
is when I'm enrolling only students can
enroll in a course to do that I'm going
to create a student binding which is
just another annotation a student
authorizer which looks just like the
course create authorizer except that
it's looking for sorry the students
group
um
when I look at the filter it's just
going to look at the same things over
again except now when I enroll I need to
add my student binding to the
enrollments
now that I added that this should start
failing
oh it did not
ok
so part of what has to be enabled is you
have to define the security interceptor
in your interceptors on your bnet xml
this is what controls the aop behavior
of the application they don't get
started automatically because our
extensions within dealt spike are
designed for CDI 10 features
ha I know why
so there's a little bug in my code
so now we should start seeing things
fail again so if user has no groups
currently it's skipping the validation
all right
so when we try to enroll it failed we go
to this line 168 I was expecting to see
a 500 but instead I got a 401
unauthorized because when I look at the
Interceptor there what I look the
authorizer I'm looking to see does the
users groups do any of the match the
students now this was fine for when
admin2 didn't exist because there were
no groups for its match one of the
downsides to the streams API no way to
really check if it's empty other than
the optional interface so if i put admin
to back into the admin group horse
manage
and run this test one more time we
should see that the actual enrollment
starts failing
okay good
so now this failure is happening online
151
as you can see in here every time we're
doing enrollment we're checking to see
the response code we have a handler for
500 think what we need to do is add a
handler for 401
and if I run this enrollment one more
time now
we can see that nothing was created and
we're getting responses fail to
authenticate user and we can see that
what's happening is it's throwing an
access denied exception this is one of
the built-in exceptions within Delta
spike for security violations where we
are throwing this anytime someone's
access they try to access resource or
access a method that they didn't have
access to based on the bindings
we can see that there is no actual
message coming back just the 401 and
that's because we're not handling this
axis tonight exception
to do that well actually so what we want
to do is we want to be able to invoke
the enrollment API as a user who can
actually do this which we know that the
student user has the student group
actually the students group the students
group
right because we're looking for the
students group here in the is student
authorizer so when I go into my rest api
I can do dot request actually first I
have to build the authentication
and encode this
and then on every outgoing request I'm
going to add this header
so if i run this one more time
we can see that I was able to
successfully enroll now into all the
courses i still get back the message
indicating the courses reached maximum
enrollments so our course our API is now
back up and secure / change
so
the way the authorizers work is you can
either return false or throw an
exception from your method this will
cause it to fail and cause it to roll
back any incoming requests one of the
common use cases that's out there as you
saw we do use a user class that
represents whoever is logged into the
application this can be a request scoped
session scoped but it's common for this
to be where you're looking up the data
from so that's pretty much it thank you
everyone for your time anyone have any
questions anything they like say I also
have some stickers for delts spike up
here if anyone's interested feel free
yes yes yes we have a thread sleep sure
so in the test
so the reason that this is here is I
want to make sure the websocket is
catching up in enough time so the web
sockets all run asynchronously within
the application I want to make sure that
all the incoming requests are through
before I'm done and want to verify it we
are using the countdown latch but using
a bread sleep is also a fair way to do
that I did have another question sure
the classes under applications go is
there a way no there is no ordering
currently yeah it's the the CDI
container we'll sort of figure it out
for you based on the dependencies that
it sees coming in so if you have being a
dependent on being be because DNA has an
injection point of beam be it's going to
instantiate beam be first for you so if
in here so this listener was where I was
doing most of my work and if I inject it
in here the user manager
it will instantiate the user manager for
me first because it's a dependency for
the listener class yes so I'll bring
this back up
so up here you'll find a link this bit
ly URL will go to my github account
which has the repository bit ly /j 121 @
up 2184
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>