<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Apache TomEE, Java EE Web Profile, and More on Tomcat | Coder Coacher - Coaching Coders</title><meta content="Apache TomEE, Java EE Web Profile, and More on Tomcat - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Apache TomEE, Java EE Web Profile, and More on Tomcat</b></h2><h5 class="post__date">2015-06-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/MNg1drdIkUQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome everybody it's really great to
be here we got a good crowd so before I
get started obviously you know what
you're here to see so I want to learn
something about about you so who uses
Tomcat as expected pretty much everybody
in the room who also uses another app to
her like JBoss or GlassFish it's also
very very large percentage of the room
that bill about 3/4 if not more and yet
that's you know as I say that's one of
that's really what we're trying to do
with Tommy at least at minimum and you
know you typically get as far as you can
with Tomcat and then you know you you
run into some limitations and then you
have to use another server because it
just gets too hard to in grade all stuff
together so a question brave question
who's used to Tommy before or tried it
out Hey
good a number of hands yeah we're we're
kind of new to the whole Java EE scene
and so it's nice to see some some hands
go up who has met who saw my talk last
year by chance okay good so I guess it's
all gonna be fresh new material you
never know what to repeat or what not to
repeat I think one way to to summarize
kind of what world what how we got to
where we are is this kind of phrase this
I met I met somebody any Michael in the
lobby yesterday and he he he said
something that very accurately
summarized the last 10 years of my life
which was good decisions come from
experience and experience come from bad
decisions so having been in Java EE for
like a really long time and done things
away and in a way that you're sort of
trying to tell people what they want and
what they should use and what they
should do we decided to take the
opposite approach and say all right
let's stop let's figure out what people
are actually doing and we'll just try
and help them let's just try and make
that better
and so when we created Tommy the goal
was not to make yet another choice for
the sake of having just another choice
the goal was very specifically that
almost everybody uses Tomcat for
something want to use Tomcat for more
and almost everybody spends a
significant amount of time putting all
this stuff in the box because that's
better than whatever alternative that
they offer and so we wanted to say
alright that's a great way to do things
that's valid let's take that and
integrate it further just take it a
little bit farther so you don't have to
start from here and go up to there every
single time you start on a new project
the interesting thing is I don't know
anybody's Tomcat integrations that are
all these custom time kind aggressions
that are exactly the same so if you are
in one job and you're using a Tomcat
stack you go into another job and you
have to learn how they decided to
integrate all that stuff together and so
that whole easy portability stuff it's
not quite as great as it could be so
we're lifting it up putting it in the
same realm as a certified server not
because Java is the best thing in the
world which I think it is great but
because it's ultimately easier for the
people who have to consume it so thank
you Michael if you're in the audience I
believe okay so question about Java EE
so this is kind of one when I'm talking
to someone they say j2ee
I go okay there are some things we need
to talk about so what may have happened
in Java EE since the j the days of j2ee
so high-level recap of some game
changers this is not the entirety of it
but basically it's not called j2ee it's
called Java EE so if you're still
talking about constant and all will
understand that it's now Istanbul you
know if you're talking about the history
of your life and Constantinople it's a
little bit different now
so another one is the web profile so the
web profile is half the full profile so
korva Jax RPC lots of legacy
technologies are not in the web profile
the web profile was giving an inch
that's what Java he decided to do okay
it said the world saying that this stuff
is heavy and a lot of ways that they're
correct
so rather than fight that we're gonna
trim down and create a new smaller just
containing the greatest hits of Java EE
and offer that to people and allow
vendors to certify that and then that's
your new base if you want to go all the
way up to a full profile server there
are plenty of them out there you can go
ahead and do that but you can have a
guaranteed level of portability at the
web profile layer and that that opens up
more options for things like Tommy to
exist when that was created it was sort
of manifest destiny I mean we had been
working on some very similar pieces to
what is Tommy but when the web profile
who was being discussed it was like wow
okay we don't need to do all these
complicated things that we would
normally have to do to become a full
bakoma Java EE server I'm one of the
founders of Geronimo and so I had to
work on terrible things that probably no
one here has ever used such as I hope no
one's ever used Jack's RPC yeah yeah
it's it's really really really bad
you know CMP entity beans anyone is
anyone yeah ok ok you guys who raised
your hand you're awesome for still being
here
so these are some certain things that
are not you know we the job II took it
on the chin over and they're cut out of
the web profile they're not they're in
the web profile another one is ear files
are dead so I mean they're still there
there but ultimately the war file is
where it's at these days you can put
everything in the war file used to be
that Javy would be like you know what
for your own good we're gonna say that
you have to split up all your jars into
all these modules and we're gonna make
mandate a certain class loader structure
so all your DJ B's are here and your
third-party libraries and your web apps
are here and they don't see each other
we're gonna package it all together so
you have a jar with in a jar within a
jar and then to run a little Russian
doll thing I mean you it's it's
impossible to do that because you go
ahead and throw a third party library in
your war file and then you decide oh I
want my EJB to use it but my EJB can't
see the stuff in the war and so now
since you needed one EJB you had to go
from a war file to this huge complexity
and that's just a big moment of you know
Fonzie jumping the shark that's when you
decide let's do something else and
that's dead you can put everything in
the war file now everyone knows how to
build a war file although tooling for
war files work great the tooling for
ears often doesn't work so wonderful
wonderfully mavens ear support is
written by people who don't use it so
it's it's ultimately not that great
Java is now testable so despite the fact
that you can't do this and you can't do
that yes you can in fact do this there
are two great choices for that one in EE
six we added the concept of embeddable
containers so java SE SE running EJB
container running and you could do that
very easily with servlets via jetty and
things like that in the past
JP a's runnable and SE environment you
can run almost the entire stack
standardly in an SE environment
non-standard li you can run the entire
stack in an SE environment
everybody now has an embedded container
so in Java e6 we add the requirement for
an embeddable EJB container and that
didn't cover standardly the entire
specification but it covered the part
that was perceived as the hardest and so
when all the vendors had to take their
EJB container and make it an embeddable
container per requirement of the
specification they figured well as long
as we're doing it let's just go all the
way so most people have a fully
embeddable container GlassFish JBoss of
course tommy it's it's the way things
are going these days and I really hope
that that continues we were really a a
core part of that tommy comes from the
project open EJB which you know was
trying to be an embeddable container
years ago and that was not the way
things were being perceived back then so
it was a good idea at the wrong time
which is tantamount to a bad idea and
that goes back to the whole you know
knowing what not to do thing and yeah so
we we we amongst others have been
championing that that embedded container
concept so java SE now testable now like
packaging reduced and bloat gone that
pretty much addresses a very large chunk
of what people would not like about the
standards what you have left over I
would encourage people to view not as Oh
Java is like this 7 million page
standard that who could possibly ever
read that you know you don't need to
read the whole thing which you should
understand is that really from the
perspective of a vendor Java EE is a ton
of tests that you have to pass in order
for you to ship something to somebody
and have them use it that's really bad
for me and good for you not really bad
for me obviously it's a lot of work to
do that stuff but it makes for better
software and that's that's what you
should view Java is you should view it
as a lot of tests a whole lot of tests
that we have to run tens of thousands of
tests
okay so what is Tommy the name comes
from Tomcat plus Java EE equals Tommy
it's a very clever little little little
concatenation there we just cut some
letters out in the middle it's
pronounced Tommy as in the album or the
name or the person it's not Tom EE
it's just Tommy and then the it's a web
profile certified the e7 stuff is in
progress that was just released here in
this June or something like that I
believe and so we have a Apache overall
working towards that it's all Java EE
aljalja patchy components so we try to
use as many the fellow Apache projects
as possible
so of course Tommy of course Tomcat but
then open web beans my faces open JPA
ActiveMQ list goes on and the way I like
to say Tommy is what we've all in the
industry not us here in the stage just
like everybody all of you it's what
taught what's what you've been building
for the last 10 years it's you're taking
Tomcat you're adding these things
together so that's what we wanted to
build we didn't want to build something
new well as I mentioned we just really
wanted to improve what was being done
what we saw people doing despite the
fact that a lot of people who build
things on top of Tomcat say they're
doing it because they don't like job II
what they're really saying is that I
want it done this way so we we did that
way okay so here is how to envision we
have a few different distributions of
Tommy and you probably maybe can cannot
or read that quite so much but that's on
the Tommy website so we have Tomcat over
there on the side we have Tommy down the
middle that's the web profile version of
Tommy it contained only the web profile
technologies so I'll list them off for
you basically we have certain JSP that's
covered in Tomcat we have JTA the Java
transaction API JPA
persistence architecture CDI which is
the new dependency injection framework
that's in Java EE 6 who has had the
ability to use CDI all right who and who
who really likes it that's a youth
that's used it same hands alright so
those of you didn't raise your hand
that's the first thing you should go
research what after you leave job one is
go check out CDI the reason being is I
think that CDI really is a fresh start
for Java EE not I don't want to say the
words Java EE so much because it's a
brand that people don't like CDI is a
component model that allows you to do a
lot of the things that were really
difficult that you couldn't do without
say like an EJB but then EJB brings in a
bunch of technology and things that a
certain way of doing things that perhaps
it's antiquated CDI doesn't come with
any baggage it's a proxy type of
technology it allows for interceptors my
personal favorite part of CDI is the
observers it's a listener API and it
comes with almost no overhead in terms
of your complexity to use it it's one of
the most elegant approaches to event
handling and listening that I've ever
seen and it makes you want to rewrite
all your code in like just a really good
way so I highly recommend checking that
out
Java being job of it we have jazz and
Jack those are sort of it jazz is in the
JVM already it's wired up in in Tommy
Jack is a is where at rules allowed
comes from so you can do container
manage security Java mail and bean
validation and EJB light so - the heavy
stuff EJB that's web profile so then we
have basically the same thing with
jax-rs that is basically now the web
profile in 87 and the e6 jax-rs did not
make it into the web profile it is being
added in EE 7 so we have a district
should have taught me with that in it
then Tommy plus is basically the last
remaining things that you possibly would
want that are still relevant today that
are not on the web profile and towards
the full profile so JMS the connector
architecture which you probably haven't
heard of I'm giving a little thing about
that in EJB 3 to talk later today and
then jax-ws so those are the the really
relevant things that are still being
used that we have in the full pro and
what is close to the full profile
version of Tommy ok so as I mentioned
all Apache components and here's what
those do respectively so open a web
beans open JPA open ujb my face is being
validation 6f and ActiveMQ we use for
cgi JPA EJB JSF being validation we use
C except for jax-rs and jax-ws and JMS
is ActiveMQ and that pretty much covers
it design goals and just general goals
the project I would have to say
primarily we want to be very simple
because that's why we love tomcat
obviously it's very simple even though
you have to add all these things
together it's still very simple so if we
take that away it's not very good we
want it to stay simple and that's not
something we do really just because
Tomcat does it that way we as a project
want to get out of your way and not make
work for you we want to just let you do
your work and not create work so for
example if you go to the poi a web
application that has a reference to a
JMS topic or queue and you didn't create
that JMS topic you we don't go excuse me
Sarah you need to make that topic you
know it your topic is called we can see
the name of your topic because it's
gonna be say a tree source topic fool
well if you don't have one called fool
we'll make one called foo in will log
that we've made one call foo we will do
everything to make your app deploy and
love all the stuff that we're doing so
you can see it but at least then you can
go and try your app out
and then when you have time you can go
back and change things if you want but
odds are 80% of what we do is just what
you want and maybe 20% is not so it's
convention over configuration we do not
make you make an upfront investment in
configuration just to try your web app
another one is obviously be Tomcat so if
you've done something to ruin the Tomcat
experience in some way it's no good
please let us know if your app works in
Tomcat and does not work in Tommy let us
know we will fix it we consider it to be
a serious bug so you know please we'll
be super super active on that stuff and
then of course be certified we want it
to be portable so that if you were app
is written on Tommy you can port that to
JBoss or port that to GlassFish or
websphere WebLogic or of course you can
do the reverse if you want if you had a
bunch of those servers and you had
Tomcat and you're in your environment
you could pull all that stuff onto Tommy
should you like ok integration this is
sort of one I've been struggling for a
way to describe how when you throw jars
into a web app that is not necessarily
integration I'm gonna try and show you a
picture of how I view it so here's how I
view when people throw jars into a web
app what you end up with you end up with
jars side-by-side not talking to each
other or not cooperating in your web app
and so you end up having to write all
the code to glue them together and
that's that part that's very hard to
maintain and you have to go around
looking at blog posts and all that kind
of stuff to make this work here's how we
view integration so what we do is we
need to make sure that if you have a
jax-rs component it has all the entity
context support and all the dependency
injection for that your Jack's rest
components should have complete CDI
support same with service should have
CDI support I mean everybody has to be
aware of everything integration is not
throwing five side-by-side things in a
box-like if you took a car and you took
it apart and you're throwing your garage
and you called that integration that
would not be you have a bunch of parts
you could probably put some of them
together and get sort of far but you're
not gonna get all the way so we try and
put all that stuff in there and that
part is the really really hard part when
something has to touch everything that
becomes incredibly difficult to do and
these are the things that you end up
doing without when you do things
yourself on Tomcat and so this doesn't
take a lot of code it just takes the
right code this most you know it takes a
considerable amount of work and here's
the rub so you're building this stuff up
to yourself on Tomcat and then a new
specification comes out and then now you
got a real goal right back in there and
figure out how to integrate that into
Tomcat yourself so so it never stops you
know the wheel never stops turning okay
so we like to say spend your time
writing applications and not writing app
servers it's a best way - all right so
what a certification I'm going to get
through this quickly so I can go to the
demo
it's months and months of work this is
huge test suite of tens of thousands of
tests that Oracle issues - previously
son now Oracle issues - all the vendors
who want to be Java EE implementation so
JBoss GlassFish WebLogic websphere they
all pass that that test suite and only
once they pass that do they release
their their platforms and you can better
bet that as soon as they're passing it
that that platforms going to come out
within a month or two of their passing
that is the primary we are ready to
release trigger for all these Arab
servers it's a very significant effort
and like I say it doesn't make for a
bloat it doesn't have to make for a
bloated server so like when we integrate
the stuff together and Tommy our
certified server is about twenty seven
megabytes and we passed the TCK with the
default heap size we don't increase it
so it's 64 bits or so
thirty two-bit VM and twice that on a
fixed me dice a six well on a 32-bit VM
it's smaller and 64 is double so we do
our tcq testing and amazon ec2 using t1
micro instances the very smallest vm
size that's available on ec2 they only
have six hundred and thirteen megabytes
of memory we use up the default JVM
settings which are tiny so you have a
hundred couple hundred megabytes left
over we just recently started doing TC
testing on a Raspberry Pi just for fun I
mean why not
Stefan was telling me just a moment ago
that he's building a cool system that
does like fullscreen scoreboard stuff of
games and it's all using raspberry a
little tiny Raspberry Pi which they're
about that big and and it runs Java EE
eight and Tommy and it's he says it's
pretty cool so I can't wait to see more
about that he'll be blogging about it ok
so enough talk
alright so what I'm gonna show is a pet
store Senor Antonio here wrote this fine
application pet store which is a kind of
a revival of the one you may have heard
about in the j2ee days but it's more
modern and a lot better in this if you
want to take a picture because I'm gonna
show these things so JP bean validation
CDI Jack's for us each a B and JSF these
are the kind of highlights of what what
you're going to see so I'm not going to
be coming back to this slide so if
you're wondering what was that thing you
showed me now is your time to remember
all right
I should have a camera - you taking
pictures okay
and then because always innovation comes
from things that are not standard here
are some amazing things that are in this
demo that I'm also going to show which
are not yet standard I'll let's call
them future potential standards are
Killian is is a wonderful testing
framework written by us Locke and Dan
Knutson or excuse me Ocelot Knudsen Dan
Allen and and some of the JBoss guys and
it's a wonderful testing framing that
allows you to write a test and use that
against any server
not just any server but since I've
mentioned we now have a lot of
embeddable servers you can run it in
your IDE all one VM no remote stuff
within and with an embeddable server not
modify that test run it against the
remote server not modified that test run
it against a different completely
different vendor if you're in the shoes
where you have to actually certify your
your application on a bunch of different
app platforms you have to look into our
Killian if you don't you're that's a
significant advantage that you that
you're not leveraging even if you don't
have that scenario our Killian is the
best testing framework out there for
Java EE by far we have a little plugin
for running Tommy we're gonna show that
it's a maven plug-in and I like to show
new stuff at JavaOne and big conferences
like dev ox it's so-so i hacked this up
last week so when i say last week i
really mean like starting wednesday so
if it doesn't work which you probably
won't let's expectations correctly it
won't work if it does that'll be awesome
okay so a couple new concepts that some
of them are have some ideas that we've
kind of been working on for a while but
we're fully implemented so i try to
implement those and another one is a new
one which we kind of been thinking about
for a while but didn't actually
implement so these are where new
specification technologies come in come
from so perhaps we're looking at some
Java EE eight stuff who knows it's a
group it's a committee we'll well at the
you decide alright so let me first go
here alright so here is Antonio's pet
store ok that's the test area so it is a
day bass-driven application we have our
entity beans here I'm close all these
windows ok
that's is that big enough let me see
would pull up some code can you see that
that could be bigger there we go ok so
basic entity beans JPA I'm assuming most
of you use JPA if not hibernate right
same same thing more or less ok so we
have all the domain objects this is a
pet store application and so at the
beginning of the application or is it dB
okay when this application loads this
bean is going to be called it's a
singleton if you are concerned with if
you're using EJB are considering using
AJ be use Singleton's whenever possible
do not use stateless stateless our
pooled beans if you need a pool you
stateless if you don't because you just
don't want stateful don't use stateless
the names are bad that they were that
they were named years ago and we can't
change them now but understand that
stateless means limited it means a fixed
number of calls can happen against this
beam at a time it means pooled if you
just simply don't want state use a sting
use a singleton okay this thing is
annotated with at startup so when the
container boots when the application
starts this bean is invoked like this
servlet load on startup but here's the
problem with serve a load on startup you
have something exposed to the web now
you did not want that just because you
wanted to do some initial initial
on server startup you did not want to
create something for the world to invoke
so don't use servlet still do your
initialization logic anymore that is not
the correct usage of servlets only use
all servlet that loads in start but if
you actually intend to serve requests
from it so use EJB at singleton and
you're great this is a CDI annotation
I'll mention that briefly later here is
a nice fun part this is a new addition
in EE 6 this allows you to define your
data sources and things that you require
in your application right there in your
application without external
configuration this is everything that
I've showed so far here are all things
that you cannot get in plain Tomcat even
something as simple as I wanted to find
a data source be an annotation is not
implemented at Tomcat because it's 2 ish
so there bar for what's a key is
probably a lot lower than yours so here
we have two data sources and now we go
ahead and have effectively a couple data
access objects being injected via add
inject this is a CDI annotation and so
as I mentioned on startup this method
will get called that we have a post
construct and then we have a pre destroy
and so here in our example we're gonna
create our database and I've reformat at
Antonio's code just a bit so we create a
bunch of categories we add the products
and then we go ahead and persist that
down here if we go ahead and look at
that bean we have a standard sort of
entity being a EJB that does persistence
and and that kind of thing ok so I'm
gonna go ahead and load this up just
just as is it's already running I should
have just left it let it go
alright so this is now booting and
running via the tommy maven plugin so it
will download the server it will
download all the war files in fact you
can have just one maven palm with no
actual libraries in it and that would be
enough to provision and start your
server install the web apps that you
want install the libraries into Lib
directory or that you want even remove
from libraries if you don't want them
there and and it's it's pretty cool ok
so we have our pet store and we have
some fish so we have angel fish fish
bone goldfish liquid complete with
mackerel I added some bad names in there
because there was in enough entries for
my tastes and I thought it was funny we
have dogs of course so bulldog Snoop Dog
Three Dog Night
iguana rattlesnake white snake you know
I like the caption kitty kitten not
included she was the one dancing on the
car in the Whitesnake video with four
cats we have you know of course Manx
Persian Def Leppard white line warning
cost an arm and a leg - the leg or - the
arm bad joke yes of course
we have Amazon parrot Finch the Eagles
The Yardbirds if you've not heard of The
Yardbirds you've heard of every
guitarist that came out of the are birds
okay so and of course you know these are
all clickable and and yeah okay so very
basic data-driven application okay so oh
I first should love to server started
I'll boot it up again so there's some
rest stuff in there I've had a bug and I
fixed it on the other copy will see if I
fixed it in this copy but on the startup
we will actually print out all the
restful endpoints so you don't have to
go digging through and we've had this
feature for a while but we we really
actually put a bunch more work into it
so here we go I'll grab this
so - all the info - all being four lines
if you do like that boom you get you get
the aerial and now you can't see it at
all alright well you should we show the
method names and they're excellent
excellent I like get categories and I'll
paste that in there and then boom we
have our restful restful stuff here
here's the code for that simple jax-rs
component now a critical thing to
realize about this application we help
we don't have any third-party libraries
none these are all using stock
technology that's there in job II so
that means that you writing this
application would not have had to have
gone to find anyone's blog posts do any
integration write them emails in their
comments get ignored find somebody else
who might have done it get ignore again
and then work through a bunch of issues
and that eventually have something which
perhaps works and then you leave your
job and go to another job and then they
all are screwed at your previous job so
all this comes straight out of the box
okay so arquillian and what you need to
write tests so here we go you can write
some very simple tests with our Killian
so this will actually deploy this jar
file into the server so we have runs
with our Killian - j-unit annotation we
can get dependency injection in our test
case yeah and then we can actually build
up the archive that we wanted a ploy
into the server in the application so
this means if you have a 500 megabyte
application with a ton of stuff in it
you can trim
- just the things that you want to test
and do more unit testing than you
possibly would do otherwise so here
we're specifying one class ended being a
means XML and we're testing one class
think about the significance of that you
can do Java EE testing and I shouldn't
put in quotes it's yes it's job' testing
testing one class to see how that works
so we're just gonna run this test boom
not a lot of time so we're actually
starting to leverage functionality in
the container paying very little cost
because our app is tiny and does very
little and in fact the cool thing about
this is that allows you it's hard to say
though many of one of the cool things
about this is that it allows you to
start mocking things right so if you
have implementation a and B you know you
can just say include the concrete class
that I want to test and he gets his
dependency of our database system or our
search engine or whatever we have
third-party thing or some other team
controls this and we don't want to use
that we just want to mock up one put
that mop class in the application deploy
them together and then let CDI wire them
together and then now you're testing
your logic and then a mocked up version
of these other things so if your
organization is this big mock-up those
guys test your stuff and make your life
simpler okay I'll run a a bigger test
here this actually does persistence so
this uses EJB CDI JPA and being
validation and there we go so there go
that that ran so I mentioned a lot of
things and it ran still fairly quickly
who uses bean validation okay for those
of you didn't raise your hand being
validation is probably the second most
important thing to development other
than tests
it effectively allows you to test your
data and that's a really critical thing
so in our let's see if I have it's the
item we have a custom annotation on this
JP entity that says price what does this
mean okay so we have an item it's
something we sell and we have this
annotation that says the price cannot be
less than $10 and these are all standard
annotations that you get to write
yourself using the bean validation API
put them on your entities the container
will automatically run them and check
them before allowing you to persist data
into the database so you can get
constraints validated before you make
the heavy expensive trip to the database
why make the heavy expensive trip only
have the database say this this is not
good so a lot of things that you would
want to check about users data you can
do early and standardly and reuse those
annotations in all your applications
okay so we have a test that shows that
so I've added a little little test down
here item price validation
yeah bean validation hasn't a descriptor
file so you can get a lot of that stuff
in XML if you want and most servers
allow you to specify the XML externally
the downside of the database validation
things is that if if the entities change
and the rules change you're in that kind
of situation where every new release you
have to then like roll the logic forward
in your database as you roll the
application forward this way you can
kind of centralize everything and if
you're getting a lot of invalid data
from users and you're setting that
traffic to the database and a
high-volume environment that's a huge
cost because basically all the people
who are sending invalid data are taking
just as much back-end resources of the
people are sending validate valid data
and you can get a lot of there's a
performance benefit to stopping the bad
traffic early ok so here we have a we're
creating a category a product and a fish
so we have a sickly fish and this one
doesn't look so healthy let's sell it
cheap so we're selling it for five
dollars and then we try and sneak this
by the container and we'll see of course
the container is going to reject it and
say that that's not valid and again we
haven't had to actually write the code
to do the check and admit an error and
all that kind of stuff we just had to
annotate our entity itself with the
rules that say this can't be below that
how awesome is that
and just allows you to like I say write
your code don't write the plumbing you
know that that's a Java EE thing and
that's a Tommie thing okay so CDI we've
seen the at inject thing
so we have this guy logging interceptor
an interceptor is basically in a rounded
vice and here's a real archetypical
implementation of an interceptor when a
method is called this method it wraps
the objects that you want to apply it to
you get to execute logic beforehand you
get to say now keep going this is
basically filters servlet filters if
you're comfortable Cyril filters you get
the idea the cool thing about it is that
you annotate the Interceptor with your
own custom annotation so this is right
here in this application and then you
use that annotation on places where you
want to apply the Interceptor so which
you can see is pretty much our entire
application it's now our logging for our
entire application is handled standardly
in one spot we don't need to spread that
over all right we're running short so
I'm going to show you some of the
interesting stuff and this is a part
that may or may not work okay
so if you notice I'm gonna first code
this up by hand so this is the part that
that's probably definitely not going to
work if you can say probably
indefinitely in the same sentence which
you can't but I did okay all right so
here is a little bit of a gripe that I
have and that's necessarily gripe but I
see room for improvement which is where
this feature comes from if you look at
this code it's pretty boilerplate all
right we have a something we have a fine
category and then it goes and validates
that you've passed in good data and then
it does it find you have a another one
and this one executes a name query takes
this Quran
and shuffles it into the parameter and
most of this code follows this fairly
predictable format all right so that's
sort of neat but it's a lot of code
because if we have a lot of entities we
end up with a lot of this boilerplate
code so here's the experimental feature
that's not even a week old the idea is
as I've been mentioning we don't what we
want to reduce the amount of work that
you have to do as much as possible so
we're going to allow you invocation
handler to implement invoke the
java.lang reflect invocation handler
okay so now you can do you can declare
your beam as abstract have it implement
invocation handler and then go ahead and
do something that's a implement invoke
and all right
argh zero
and then we're gonna declare this
abstract oops not what I wanted to do
okay so now we have a test case with
this
yay test cases and fingers crossed all
right things can work for me or not yes
okay so we deleted the body of that now
obviously it doesn't make so much sense
if you're just replacing one method but
if you improve your little invoke logic
so that you can handle all the various
kinds of methods effectively we have
only very few things that we want to do
right so so here is how this looks
completely implemented there let's close
all this stuff and that's
catalogs okay
so what I've done is in I've had a new I
wrote a little standard class that's in
this application and when this invoke
methods called I use my own custom
annotations that I wrote these are not
standard stuff they're in the
application that says all right if
they've annotated their method with
named query then I'll invoked the name
query logic and so now I have basically
the same boilerplate code that you saw
on the other thing but the logic has
been generalized and reduced and so I
have this one little class that handles
basically create logic using entity
manager so we're gonna go ahead and
we're gonna grab our entity and we're
gonna call persist on it right here
that's the magical line we check all our
values I got a reed method find by
primary key which executes entity
manager find invoked name query which is
another Reed we have an update logic
here does a JPA merge of course still
validating the arguments we have remove
simply does emerge then a remove so we
sync it up with the entity manager and
then we delete it this is all the exact
same code we had but now look almost no
code in here left anymore that's the
entire entity that's it that's the
entire data access layers all been just
abstracted out we have all use that in
it so we could have what I'm doing here
is instead of having instead of having
what this here was what find category
look like
we are executing we're saying
entitymanager get us this query and we
have the name of the query and then
we're setting the parameters and then we
have say get me the single result well
now
I've annotated my parameter with what
parameter name I want in my named query
I've set what
query I want you to execute and
basically what else is there that's
enough for you to write the code to do
it and you get sick of writing that code
all the time so why do it so that's the
idea
allows you to basically take all if you
find yourself writing the same code over
and over and over again and you're
falling asleep at the wheel that's
that's no good
interestingly enough this is kind of
what home interfaces did so so this is
you know when we created ejb 3.0 that
was my first standard that it
participated in the question I remember
coming up very explicitly should we make
an annotation version of home interfaces
and I recall into in fatica saying no if
we have anything resembling a home and
they're people who ignore all the stuff
that we're doing and she was completely
corrected because if we had done it then
we would have done it incorrectly like
just the way that it had been done in
EJB too low right and so it was a really
wise decision now I think we could
actually do a really cool implementation
so you don't have to continuously write
all this read write update logic that's
so boilerplate it's monotonous and
mind-numbing
and the cool thing about it is that
unlike home interfaces before where you
had this magical 500 page documentation
you had to write I mean really all this
stuff is driven by code that you could
easily write yourself and maintain and
then you don't have to read 500 pages
you just read the one class that you
wrote that's so much easier
who can't debunk and you can step into
it and debug it I think this is gonna be
a really cool thing to do so that's
abstract beans as we call them now I
don't know what we're gonna call it
because like I say it's not very old not
not very old another idea that how long
these sort of lines are you know we
could have you know this sort of driving
be standard so we had to put this little
method on the bottom here that to
implement invocation handler we could
potentially say you know use foo handler
and then we would instantiate that and
use that for that method and you could
say how you want the various methods to
be handled and so you could externalize
all that logic and perhaps a more
flexible way than doing like a big if
statement in a in an envelope ortant
thing go ahead
perhaps yes I tried to get that to run I
couldn't get that I ran at a time I was
like hacking on that until I don't know
6 a.m. on Sunday night so absolutely
ideally jet I mean if you look at the
jax-rs endpoint when I show it to you
I'm gonna go over here and show it
catalog rests so if you notice this
thing is all boilerplate too right you
got a bunch of annotations and then you
have it's simply calling at catalog
service and we all know already that
this that method is abstract so why not
make this thing abstract too and then
basically you have jax-rs
front-end that serves xml or json
persisting to a back-end and all you
have in the middle and the Java layer
would be one abstract method how awesome
would that be not have that actually
have to write any code you're just
chucking stuff in annotations
so what the trick is underneath the
covers when we're deploying so this is a
this is this is a primary example of
something you would not be able to do
yourself on top of anything right this
is an example of that we're not just
trying to integrate these things
together better we're trying to take
advantage of having control that little
piece of that star to drive innovation
in areas where it'd be difficult so what
we do at deployment time what I have
what I implemented was when you're
deploying the application we see that
that EJB is abstract that it implements
an invocation handler interface and we
subclass that using ASM we generate a
subclass and the subclass method and we
implement every abstract method to just
simply call the invocation handler it's
like that much line of code but it's
easy to do because we have the control
at the right layer if you were to try
and implement something like that on top
of the server that would be a lot more
code you'd have to have a tool that
generated it ahead of time to give it to
the server because the server would
otherwise kick out an abstract beam and
so then you're in a situation where now
you can't use your standard tooling and
and all the stuff you can't just use
Eclipse and and run it because you need
to run this external tool first so so
there's a there's a lot that can be done
playing at the right layer trying to
different layers problems are hard but
yes that's what we do which we just
simply subclass that beam we swap that
class out for the actual beam class and
we deploy that and then everything just
magically works and all the annotations
are supported ok so there is something
to show in this particular class the
second concept which is men annotations
I've shown this I showed I showed a an
EJB specific thing about this last year
but basically there's a lot of
annotations in Java EE and code in
general and the amount that we're
getting is piling up so that there's
more
annotations than actual code especially
now that we can delete the code and so
it gets sickening actually we
annotations are a good thing but we gave
up something when we created them we
gave up reuse so if this was a java
method and i had copied and pasted that
java method that many times in an
application I should probably get fired
but because it's annotations we just
live with it
we just alright that's the way it is we
have to have to do that so we so we take
our configuration and we sprinkle it
throughout our entire code and it's
completely unmanageable
so I implemented this idea of annotation
reuse in cxf just this just this week
and so here we go here's the concept so
this is our enhanced version of the pet
store application so it's it's very much
like CDI stereotypes what we're doing
here is we're making a custom annotation
something of our name of our choosing
whatever we want to call it we're
putting all the methods we want that
annotation to have so all the ads so if
you want this annotation to imply that
it consumes application XML and JSON we
put that on this annotation and then in
our code we delete we just simply do
like that
so now we no longer have to replicate
that it consumes this consumes that
because as your application grows and
you end up with a lot of restful
endpoints you're gonna have XML JSON XML
JSON everywhere and then your metric
comes to you says hey let's just do JSON
and you're like yeah that's a big change
and it is because you would have to go
and do a fine replace across all of your
restful endpoints well now you just do
the one so here if I delete XML and I
hit the service again let's go over to
our extended one
may even clean install forgot tommy run
tommy run that's executing that maven
plugin it will boot up all our restful
endpoints will be deployed and as we're
looking at that
here is the maven plug-in configuration
to do that running right here
so we say what version of Tommy we want
to run we can give memory settings and
the like we can even pass in system
variables we can say what flavor of
Tommy we want the web profile the jax-rs
the Plus version what libraries do we
want to install and the Lib directory
and because this maven product is a war
file it automatically deploys that war
into Tommy
so we'll unpack Tommy into the target
directory install these libraries and
these are all maven dependencies so it
downloads them over the internet it puts
them in there so you can get your
drivers in their boots up Tommy and boom
you can have all your configuration and
everything right there in a little maven
project and it will basically provision
a server for you to your specification
and you don't have to do any of this
stuff in advance anymore ok so let's go
grab a restful endpoint here and why was
XML before now it's a JSON and we didn't
have to do anything but change that one
chunk of code now all our restful
endpoints are updated so let's finish up
here here's our Java EE 7 if you status
if you want to take a picture of this
this is good here are the various
projects in their states and the
versions that are going to apply to them
so most of the projects are in the
finishing up stage ActiveMQ and open JPA
are in the starting stage or yet to
start stage so it's probably going to be
right about here that I think will start
the Tommy Java EE 7 branch because well
of course we have to wait for all the
dependent projects to get in good States
Tommy has been in the last year adopted
by a lot of platforms and tools are
supporting Tommy so jelastic IntelliJ J
rebel staccato New Relic hopefully
Liferay at one point
and also this week oh go ahead and get
your picture you're welcome okay and
then also this week we're announcing of
course we're supporting Tommy directly
so I started a company Tommy tribe and
we're sharing a booth with jelastic and
it's basically the Tommy support company
you know I like to say you know Tommy
tribe didn't create Tommy Tommy created
Tommy tribe that's the way it should be
so it's a no it's a it's a company
created by the developers of Tommy it's
us so if you're enjoying Tommy and you
want support we're there for you you can
stop by our booth we're giving my
raspberry pi's in an Xbox we're sharing
with jelastic so come over and talk to
us questions yeah it can be so what you
would typically the problems you would
encounter are typically that you have
too many server libraries' in your web
app and so often it's just a matter of
taking them out and then you can go
ahead and port it so absolutely yes and
there may be some work involved because
porting is never like free but yeah
absolutely
yeah well we're the app server so yeah I
totally modified the app server itself
for that I haven't checked in all of
that code yet I will if you want to like
get note updates on it go to our booth
and just get scanned and I'll send out
like you know I've checked in the code
here some builds go try it out that kind
of stuff and you can give feedback and
we can work it into the idea and as I
say this is where the next generation
this is where things that get
standardized come from vendors
implementing them and trying them out so
we just finished a standardization phase
Java EE 7 is done so now is a great time
to try things out and make ideas for job
ee 8 yeah yeah so the answer the
question was is there ever going to be a
the ability for you to conditionally
have things in the class loaders because
sometimes a webapp may have those jars
and you don't want them to conflict with
the server libraries right yeah so we
shift my phases by default what if you
wanted to use Mahara so we do you we do
support Mahara but currently you have to
gank my phases in order for that to work
well so absolutely so here's the clever
compromise that I've thought of for that
instead of creating an OSGi like
architecture where the library is always
there and then we try and hide them with
the application well I don't we put them
in a separate jar name or whatever and
they're not in the server Lib directory
and they're not the server thing if your
web app doesn't have a jace
implementation in it then we'll add that
jar virtually to your web app and then
that would be one pragmatic way to solve
it the only thing that would confuse the
Eclipse tooling but that's really the
only downside to it so we would probably
just need to update or fix the Eclipse
tooling and it would work fine
and it would allow us to basically do
that sort of conditional class loading
without having to have a fancy class
loader which is really good because
fancy class loaders have severe
limitations they do 95% of the work okay
but when you hit that five percent
that's like a couple weeks of pain that
you're looking at and so doing something
simple like just hey we're gonna add the
jar if you didn't have in your web app
is a much more pragmatic approach any
other questions
oh yeah oh you know I should have
mentioned explicitly so I've all last
year I showed a demo that involved
eclipse using the Tomcat web adapter
using a standard Tommy installed if you
like so yes that works
Tommy works with the Tomcat plugin and
Eclipse you just unpacked Tommy and you
point the Tomcat plug-in at it and it
runs we have a demo on the website okay
I got a wrap-up but there's a there's a
ten minute demo as well you can see the
job one talk from last year on YouTube
the DevOps version is my favorite no
offense to Java one from last year but
that one's really good and they all show
the it working with eclipse just fine so
thank you very much guys</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>