<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Java Versus JavaScript: Head to Head | Coder Coacher - Coaching Coders</title><meta content="Java Versus JavaScript: Head to Head - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Java Versus JavaScript: Head to Head</b></h2><h5 class="post__date">2015-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/wMUX4fne2iQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Chris Bailey and today I'm
going to be covering an introduction to
to Java and JavaScript so comparing
contrasting the two languages how you
can run them and the runtimes that are
available for you to run them on and
you'll probably be able to see from the
logo that I work for IBM if you've been
to an IBM presentation or an Oracle
presentation the next slide will be
familiar to you so it sounds like a bit
of a pitch that I don't know if you
aware IBM for the last 21 years has been
the patent leader worldwide right they
submit more patents than anybody else
and that kind of requires us inside IBM
to to constantly do innovation and the
lawyers take that quite seriously as
well so you'll seen from Oracle one of
these a legal disclaimer now the lawyers
started off by writing in legalese which
kind of requires some kind of college
degree in Latin to understand and then
they went for small print now our guys
have gone to stage further they real as
block capitals are impossible to read so
we've got a legal disclaimer that
basically says you know any suit make
assumptions on what's going to happen in
the future if we talk about future stuff
don't do product decisions based on it
because it's subject to change but in
all honesty are not talking about
anything that's unreleased here
everything's of fully available soon so
there's nothing to worry about on that
front so before we get started and
before I tell you about myself we're
going to run a quick survey about you so
the first question is if I can get this
to come up what programming languages do
you actually program in so it's the
options are purely Java surely
JavaScript or both so who's a purely
java developer in here so i would say
probably about forty percent ok who's a
purely javascript developer in here good
all to a couple of people you're at the
wrong conference
okay and who says that they program in
both okay that's a fair amount as well
so that's probably the other 55 least we
hope saying okay right now the next
slide what runtimes do you actually use
so who uses java on the server so java
ee web apps in java that's like ninety
percent of you who hit rights applets
okay who does javascript in the browser
okay that's probably about fifty sixty
percent who has using nodejs on the
eighth okay that's maybe ten percent of
you who is doing stuff on rhino to
people okay anybody doing math on now
it's available in Java 8 any national
people know and anybody played with
avatar j/s okay so this is kind of the
picture that I expected right we're kind
of self selecting here it's a Java
conference so you expect most people to
be Java developers we expect most people
to have done some javascript stuff in
the browser particular leaf they're
doing JavaScript stuff we don't really
expect people to be doing applets
anymore and a few people started playing
where I've nodejs which is server-side
JavaScript and playing around with some
javascript in the JVM okay so a little
bit about me my name is Chris Bailey I
work for IBM in the UK I'm the
monitoring and diagnostics architect for
IBM run times so we produce Java on 16
platforms so I've been doing JVMs and
Java technology for 14 years and
recently I've started looking at doing
know Jas on v8 which is the the virtual
machine for javascript that's originally
from google that they use in the Chrome
browser so all
my experience is really je viens I'm
only just starting to stop to look at
javascript and the the v8 runtime that's
available for it so really this
presentation is a lot about what I've
learned over the last six months and how
the to compare and how you might want to
make use of them so the goals of the
toolkit ooh to talk about a little bit
about the language adoption why at
javaone this year there's something like
18 presentations on Nash horn for
JavaScript why there's another 15 on
Avatar j/s so why at a Java conference
we're doing a lot of talking about
JavaScript I'm going to talk about
deployment mode so where you can use it
and I'll talk a little bit about nodejs
is that's what I'm now working on and
asynchronous i/o which is one of the
reasons you might want to use nodejs
we're going to talk about web app
performance so the performance of web
apps written in JavaScript versus java
then i'm going to go under the hood is
no jess and go a little bit down into
the virtual machine and the technology
and then finally we'll look at nash horn
and avatar j/s and whether javascript on
the JVM is is the best of both worlds or
not so language adoption who went to the
keynote on Sunday okay then you've
probably seen this slide already so this
slide says that based on github projects
Java is one of the top languages right
and get hubs kind of a self-selecting
area because it's all open source and
javas original history isn't so open
source right it's becoming more so but
it wasn't originally so Java is the
second highest number of active
repositories and the second highest
number of total pushes of updates to
those repositories and it's actually got
the third highest rate that pushes /
repository so dead that there's a lot of
them and they're quite active the
javascript is actually number one so
there are more repositories more
projects more code being pushed and more
work being done in github open source in
JavaScript than there is in Java now as
I said that could be more because
javascript is it's in some ways a newer
technology
it's more predisposes itself to open
source so that may be the reason for it
secondly module Kate's calm so this
compares the number of modules available
for download for different languages the
the blue line is JavaScript so these are
no Jas NPM modules written in JavaScript
available for use within OGS runtime and
you can see how they've really taken off
particularly in the last couple of years
the orange line is maven modules written
in Java so there's quite a number of
them and they are growing because
there's now more usage in open source
and the use of maven four modules is
taking off as well but javascript is now
completely surpassed that now again you
could take this two ways you could take
it to mean that there is lots of
JavaScript but that means there's lots
of fragmentation right there's lots of
people working on different projects
rather than a consolidation on the
important components but it means that
there are a huge number of people out
there today writing JavaScript again
look at stack overflow and so stack
overflow each year does a survey of the
people that use stack overflow and one
of the questions that they ask is you
know what programming languages have you
used in the last 12 months in anger and
the most popular one is JavaScript and
then you look at Java and you see that
it's actually a little bit down the list
in slot number five I think that is so
that makes it seem like javascript is
actually the most important language to
slashdot users you could also take it
the other way and say JavaScript
programmers are fairly clueless because
they need to go and ask people how to do
their job and Java programmers are
experienced than they know what they're
doing you know and so like any stat you
can push it whichever way you like so
next there's something that called the
tob programming community index and
these guys do an assessment of different
programming languages by using a number
of search engines to look at things like
job postings and technologies used by
servers and these kinds of things and
this is showing that Java is actually
way ahead of JavaScript
and I think what this really means is
Java is still hugely relevant
particularly in the enterprise the
serious work being done with it there's
more jobs being made available in Java
than there is in JavaScript but it is
declining to a certain extent and that's
because other languages are starting to
become more important and more in vogue
so people are choosing to use different
languages for different types of
problems now it's not everything in the
enterprise is java and indeed you see
the same thing on job trends job trends
those charts make it look as though well
first of all everyone's in trouble
because jobs are just tailing off but if
you look at the scales you'll see that
the the right hand graph which is Java
has a higher scale so whilst the lines
look roughly the same job is actually
tracking about one and a half times
higher because the scale goes up to
three rather than going up to two so in
terms of jobs and in terms of more
server-side enterprise work Java is
still where it's at so in terms of the
language adoption JavaScript's got a
huge developer base it's a number one on
github it's number one on module counts
it's the number one on Stack Overflow
for survey responders is actually nine
on the tob index so it's it's quite low
in terms of you know jobs and
professional work in courses and the
like Java is still hugely important in
hugely relevant particularly for server
workloads and enterprise applications
and it's not like it's dropped off the
radar it's sitting at two and three on
all of these surveys ok so we've said
that there's a lot of interesting
JavaScript now and it's growing it's
taking up particularly an open source so
what about deployment modes well really
there's two there's client and their
server so in terms of usage in the
browser the the data that's available
from the w3 Tex website is up in the top
left-hand corner and that shows you
exactly what the room here kind of said
which is hardly anybody's doing applets
so pretty much JavaScript has one in the
brain
it's the language that everybody uses
some people are still doing flash Apple
is trying very hard to kill that off
that some people are doing flash but
mostly it's JavaScript Java also has the
problem of some negative publicity
particularly on security when you've got
carnegie mellon university sponsored by
Department of Homeland Security saying
pretty much disable Java in the browser
and don't just disable it for this
vulnerability disable it in general
because there's going to be another one
down the line and you've got us saying
much the same thing so you've got this
problem that no one's really using Java
in the browser everyone's using
javascript every browser supports
javascript it's got integration with
HTML and CSS so javascript is basically
the winner in the browser so let's look
at the server well Java's been around on
the server for a very long time java
professional Edition which became java
ee started in 1999 so it's been around
for what 16 years there's a lot of
platform support so you've got linux x86
linux power linux z which is the
mainframe you've got Mac you've got
windows you've got Solaris you've got
AIX you've got z/os which is the
mainframe there's also I 50 s it runs on
arm it runs pretty much everywhere so
Java has been around for a long time on
the server it's got enterprise-grade
capabilities it's got bindings to
virtually every data source that you can
need and it's really not going away but
as the client side is becoming solely
JavaScript there's an advantage to
having JavaScript on the server so that
the two parts can talk to each other
better and you've got code reuse between
what's on the server and what's in the
client so now we're starting to see on
the server side JavaScript being used to
serve up those web pages so JavaScript's
a nascent language on the server but
it's starting to grow there's limited
platform support and at them initially
JavaScript had no way of talking to the
OS right we run in
side the browser it talked to the
browser but I was it so that's where no
j/s comes in so no Jas is a
single-threaded event-based JavaScript
framework so what it's done is it's
taken the v8 JavaScript engine which is
embedded inside the Chrome browser which
has no way of talking to the OS and no
we're talking to the machine because it
doesn't need to and wrapped it with an
i/o library could live UV so this means
you can I run JavaScript that talks two
sockets and talks to the filesystem and
talks to whatever it needs to so the
structure that you've got is in that
diagram it's basically you can now run
JavaScript outside of the browser
directly on the server and interact with
IO capabilities so it's designed to be
highly scalable and make it easy to be
scalable but it is single threaded so
that's kind of not very useful if you
think about the fact that most servers
that you buy today have got a large
number of CPUs especially when you take
into account cement symmetric multi
threading and so on and in fact my
laptop's got eight CPUs so you're
getting to the point where single CPU is
not normal but what we've got at the
moment is a node.js run time that is
single threaded it's available on a huge
number of platforms it's available on
Windows Linux ACC x86 arm Mac OS solaris
iBM has now moved it so that it runs on
linux on power and linux on z and AIX so
those are I BM server hardware so we've
now got the ability to run JavaScript on
most of the same hardware that you can
run Java on so why is no je s actually a
good platform to use well the key
starting point is that it uses non
blocking asynchronous i/o so the typical
approach to i/o which is really where
job has been for a long time although
java's name and got a sync capabilities
is the whole idea that you would have a
single thread per connection right so if
you deploy a web app and it runs
servlets you
you then configure the web container
pool size so every time a new connection
comes into the web container you have a
thread that handles that connection if
it then needs to go and talk to
something else that thread does some
work makes a connection to the database
waits for the response gets the response
goes back to the servlet serves up
response to the user so you become
limited to the amount of throughput that
you've got to the number of threads that
you're running it's one thread per
concurrent transaction so the analogy
that you've got is a parcel collection
at a depo and so you have a customer
that comes in goes to the desk and wants
to collect their parcel so they get to
the desk and there's two people who are
fetching parcels from the back shelf so
the customer goes up gives them their
ticket and the parcel depo guy has to
walk off get the pass will come back at
that point nothing else can happened
because the the depo guy is fully
utilized walking forwards and backwards
getting parcels so if you've got two
guys working in the depo you can only
work with two customers at the same time
any other customer has to stand in line
so what non-blocking i/o does is much
more like a fast food restaurant all
right so if you go to the Westfield sent
and you go to the food court there's a
queue of people they woke up they order
once the orders been done the person at
the till hands it to the other kitchen
and then goes on to the next customer so
it the number of customers being served
at any point in time is not the single
person at the till it's however many
people happen to be in the queue they
take the orders from everyone it goes
back to the kitchen so then there's
nothing that happens the server goes on
to the next person and when the food is
available from the kitchen then it gets
served up to the customer so you have
these customers who are actually being
served right things are actually
happening so here the limit on
scalability isn't the number of servers
or the number of people at the till it's
how quickly the back end the kitchen can
serve the food now there is a slight
problem here which is you could run out
of counter space if that's where all of
your customers are waiting but we'll
talk about that in a second
so the drawbacks of asynchronous i/o
first of all is tasks have to execute
quickly right if you're the server
you're serving the customer and then
giving the order to the kitchen that's
all you want to do if you're the person
that then starts going into the kitchen
flipping burgers then you've your
blocked and you can't serve the next
customer so you have to make sure that
you don't do much inside inside the
JavaScript process the whole idea is if
there's work that needs to be done you
hand it off to another process you give
it to the database you give it to
another process or whatever the whole
idea is to just do fast I oh but in some
ways you can think of that's the same as
locking in Java and if you've got a
synchronized block for scalability you
get told don't do significant amounts of
work inside a synchronized block because
it blocks the other threads from doing
anything so it's the same kind of thing
except you're applying it to your entire
piece of work in any given cool back of
work don't do a huge amount of work do
as little as possible now the second
problem is that counter space problem
which is that it's easy to run out of
memory right because every incoming
transaction can be handled straightaway
and then you wait on the backend
database if your back-end slows down and
can't serve as fast as you can then you
end up with all of these customers with
their tickets on the counter waiting for
their food and each of those has a
little bit of memory because there's
some states inside it so all of those
pieces of state grow over time and
eventually you can run out of memory now
that's not a node problem it's not a
JavaScript problems is an async I a
problem but that's the downside the
advantage is very good scalability the
downside is if your back-end is too slow
you just grow with the amount of pending
work and you can run out of memory so
JavaScript and a synchronous i/o well
JavaScript's good model for this because
a sink is is built into JavaScript from
the ground up so for those of you that
do browser-based development with
JavaScript you'll be used to the whole
idea of having unclick events and
onmouseover events right so this is you
just declare a piece of code that says
when someone clicks I want you to
execute this when someone puts the max
over this link I want you to do this and
that's how you do non asynchronous i/o
in JavaScript on nodejs as well you say
when someone connects to my port run
this piece of code when's when I've
asked for a file to be opened I don't
wait for that file to be opened I just
say once it's done run this piece of
code so you're just handing callbacks
around to say when an event happens go
and do this it also fits well because
you've got first class functions and
closures you've got the advantage that
you can send methods through as
parameters and that's how you say when
this event happens do this and you can
have that code running in the context of
the event that spawning it so you can
run your your piece of code in the
context of the file being opened for
example so so that makes it well-suited
this to this concept of asynchronous i/o
which is highly scalable and because
JavaScript was already designed that
that it's got a synchronous i/o in from
the ground and it's built up on top of
it where Java is now trying to do
asynchronous i/o it's got the challenge
that that wasn't the original design and
now we're trying to put asynchronous i/o
on top of it which is why if you go to
some of the talks on lambdas they say
lambdas are very very powerful right you
see a graph that says it gives you 40
percent extra throughput the challenge
is that they're quite complicated to do
in Java gives you a lot of scope to get
yourself in trouble and hang yourself
whereas that's not so true in JavaScript
because it's the event model that was
designed in from the ground up so there
is a worry that javascript is single
threaded right I said there's a single
thread and a single event loop so that
does call some scalability problems when
I'm on my eight CPU laptop when you're
running on a server that's got 32 CPUs
running smt so I've got 64 execution
units so there's a couple of them routes
around that and I'll show you that in a
second so this is a simple HTTP server
written in node.js JavaScript so the
only bits you need to look at at the
moment are the ones that are highlighted
right so first of all I do far HTTP
equals require HT
p so that's the same as an import
statement in Java I then do HTTP create
server so create me a server and I then
get it give it a call back and so I'm
creating a function that says when
there's a request call my function with
the two parameters request and response
and what I'm going to do is I'm going to
create a response will fill in the
response with a header the value hello
world and then tell did tell it to end
and when that end happens it will send
that message back and then I tell it to
listen on port 8080 so that's actually
all you need to run an HTTP server in
nodejs so once you've done that and you
start your program that's it it's
listening on port 8080 every time
someone reaches port 8080 that callback
is generated it creates a header it
writes hello world and it ends it which
tells nodejs to send the response to the
user so any hip just serves a hello
world and that's it you're done now that
single-threaded now the rest of the code
lets you do clustering so it's fairly
basic at the moment but you require the
cluster package so that's in porter you
require the OS package which i'm going
to use to call CPUs length which tells
me how many CPUs are there available on
my machine so if this for my laptop
comes back and says you've got eight
CPUs I then do the equivalent of the way
fork exec works in at the sea level
right I can say if I'm the master
process creates a number of extra
processes up to the number of CPUs using
clustered or fork and that basically
makes a exact copy of my process so this
is going to give me eight processes that
are identical one of them is going to be
set to the master the other seven are
going to be set to being slaves I then
add a callback called death so I say if
the cluster raises an event called death
I want to execute this function and I'm
just using this to say that one of the
work processes died I could just as
easily use that callback to start
another child process so i could say
every time one dies start another one
and that's it so this is now gonna
create eight node instances all serving
port 8080 because one of the things
cluster does under the covers is it does
the multiplexing on the poor and in fact
if you're doing file i/o it all the
multiplex on the file so it handles the
fact that you've got eight clones
working together so it's fairly
simplistic but it means you can now
scale across all that the CPUs that
you've got okay so now to go in a little
bit more depth about the way that the
event loop works I'm going to go through
this fairly quickly it's a little bit
complicated but don't worry about that
the slides are going to be available for
download from SlideShare after I
finished presenting so you'll be able to
download them go through them yourself
there's a couple of key things to
understand though the first is that
unlike Java where the flow of code is
very top to bottom read through it and
you execute as you see it javascript
because of the system of callbacks will
first execute everything that you see at
the first level of nesting so I'm it's
going to execute read file and then it's
going to do n be open and set a call
back and only when that call back
execute will it do the next piece of
code so it's not top to bottom it's all
nesting and the second thing that you
should be looking at over the next few
slides is the fact that the event loop
is very rarely used right so it's the
fact that once we only have one thread
it's really not going to get used a lot
so the code here basically does what you
would get if you were to call read file
and so it's just I'm going to read some
data from a file i'm going to count the
number of lines in that file and then
i'm going to close the file i'm also
I've done that for two files I'm going
to exit so this is my application what
I'm doing is I'm saying require the file
system so filestream package read two
files once called a dot txt one's called
be text and for each of those I'm rest
registering a callback called print line
count so it's just going to print the
number of lines in each of them so the
first thing that
burns is I execute FS read file now what
that's going to do is then execute the
next bit of code which is to register a
call back it's not going to actually
execute it it's just going to register
the call back so it gives me a pending
event which is chained to open and so
when open completes nvm underscore open
handle is going to be executed the next
thing I do is execute the second line of
code here I'm not executing any more in
the middle because I'm going to execute
my outside first so do the same thing
and set up another callback for the
second file open so at that point I move
into my sub functions so when I get the
response from open and I get the data
back it's then going to do the handler
for open so my handler for open gets
moved on to the event queue and from the
event queue I then execute it so I'm now
doing NB read an NB read is just setting
up a callback for when the read finishes
so that sets an IO of doing read and a
pending event for when the read finishes
execute this code now at this point my
second file finishes opening so that
then execute my open handler for the
second file and the same thing happens
and as I'm about to set up my next
pending event I get a return from
returned from the read of a so as this
flows through you'll notice that most of
the time we're actually doing work on
the right hand side and very little is
on the event key it spends a lot of time
waiting whilst I 0 is executing and
callbacks are being pushed waiting for
the am I owe to finish but the event
loop spends a lot of time in wait so
what this means is I can actually do a
huge amount of work without the event
queue having to do anything which is
what my single threaded CPUs doing so
this is why I get huge levels of i/o
scalability with just one cpu and one
thread so very little time spent on the
event loop and that means I get huge
amounts of scalability for applications
which do large amounts of IA right if
it's io bind it
very very good if its CPU bound and
actually just has to do computation then
it's no better than anything else
because i'm not using non-blocking i/o
i'm not using a sink at all i'm just
doing computation now the sorts of
applications that do lots of i oh well
that's web apps so web apps should work
really really well with no Jas so let's
have a look at web app performance so
there's a there's a group called tech in
power and they do a whole series of
benchmarks of web apps and web app
frameworks across the board so I've
limited it to a view of only those
running java and javascript frameworks
they also cover Ruby and Python and PHP
and C and C++ and the like as well so
the very simple case JSON serialization
so all it's doing is serializing some
data into a key value pair as a JSON
object with a key of message and a value
of hello world and that's actually
fairly computational you're really doing
work every time a message comes in and
what we find is that at the top of the
benchmarks all of those top five or six
results are all running java so whilst i
said javascripts really good for web
apps for this case java is actually
significantly better and in fact that's
the result for nodejs it's the best
JavaScript result and we're running at
you know somewhere between a third and a
quarter of the the throughput of a JVM
running surveillance so next one single
query so this has an incoming requests
that we go to a database we see realize
that row into JSON on we return it back
again we get a similar picture all of
the top responses are Java and the the
highest John ojs response which is
javascript is still running at about
five or six and it's about half the
throughput that you're getting from Java
so again here Java appears to be winning
multiple query again it's a similar
picture
this is doing a query across multiple
rows and creating JSON ain't of it and
no Jas is a bit further down the list
but that's actually because there's
different databases involved in
different types of bindings you'll see
the performance delts is only twenty
percent at this point and a final one
data updates and this is actually the
most complicated I own benchmarks that
they've got and what this does is it
fetches data for multiple rows in the
database it does a transform on them it
writes it back to the database and then
when it gets that response it serializes
JSON and sent it away so it's doing more
than one an i/o trip permit request and
here's suddenly javascript has the
highest level of performance and in fact
for some of the Java frameworks it's
over 2x performance so this is because
there's much more io involved and there
is doing serialization of JSON objects
so it's actually fair to say that
whether you java or javascript is better
for web apps in this case depends on the
work that you're doing it still means
that if you have got client-side
JavaScript and server-side JavaScript
then that's probably going to be a
killer but there is certain use cases
for JavaScript and there are certain use
cases for java on the server for web
apps now the strange thing is that I
said that um game JavaScript's got this
async I oh it's non blocking it's hugely
scalable but it hasn't actually
performed as well as Java for a number
of those benchmarks particularly the
ones where it has to do some work so if
javascript so great why is it not as
fast as Java well part of that is to do
with the fact that javascript is
polymorphic and what that means is when
you declare a variable you never give it
a type right in Java you say I want an
int I want along I want a string I want
a hashmap in JavaScript you just declare
VAR and it can be anything and this
causes a few problems so if we look at
what happens inside the JVM right when
you create an object inside Java and in
this case we're doing an integer object
right
you do new int so integer my integer
equals new integer you create an enter
your object what you get is a small
piece of data that has a class pointer
that points to the integer class and
basically says this bit of memory is an
integer object you then get some flags
which says whether it's an array holds
the hashcode and these sorts of things
you've gotta look object because you can
lock and synchronize on any object in
Java and then you've got a single field
which is an int and that contains your
integer so we know exactly what an
integer object looks like and it's
always going to look like that because
it points to the integer class and
interrupt pass tells me what it looks
like it tells me it's got one field in
it that it's an int and the integer
class also contains a method table which
gives me access to all the methods for
that object now one of the other things
for javascript is you can store methods
in variables so it's not just data that
I store my variables I also score store
methods so for JavaScript we've got
another problem that we don't actually
know where the methods are or what the
methods are until someone assigns it to
my object so if we look at the same
representation for javascript it's a bit
more complicated first will you have
your JavaScript object and at the top of
it you have a map now the map is the
closest representation you've got to the
equivalent of a class object the map
points to a data structure that says
you've got some fields and some object
offsets and that tells me that field one
is actually this name right so it that's
my way of looking up when someone says
give me javascript object dot my
variable and it knows my variable is
stored in slot 1 so I have to go to the
map to find out where my variable is so
an example of this is if you create an
object you can do object or x equals 1
and then you can do object or y equals
to that puts X in the first slot and y
in the second slot now one of the
problems is in JavaScript I could also
do the same thing exactly the other way
around I could say I'm actually going to
do my y equals 2
then mind or x equals one and they're
exactly the same I've said X is 1 and y
is 2 but I declared them in the other
order and in JavaScript they actually
put them into the slots in the order in
which they're declared so I can have two
objects which are identical in terms of
data but they've got different maps
because those maps tell me where to find
fields inside the objects so it actually
becomes really complicated I also don't
know how many variables any given
objects going to have so JavaScript
starts off by saying okay I don't know
how many variables you're going to put
inside this object right you couldn't
have hacked fields how many fields
they're going to be so I'm going to
guess and I'm going to start off with 32
so I have 32 slots in which to put field
in JavaScript now what's worse than that
is in Java if you put a boolean into an
object right at Bouley it's just true or
false and I know it's only ever going to
contain true or false and that requires
just one bit so I only need a bit to
store a book boolean if someone's going
to store an int into 32 bits I only need
32 bits to store it in and I know it's
always going to be in in in JavaScript I
don't know what you're going to store it
could be a boolean it could be an int it
could be a double and doubles the 64 bit
so each of those slots is 64 bits in
size because I've got no idea what
you're going to store inside it so this
makes it really complicated and in order
to access a field I actually have to go
from to the map to look up where to find
that field get an accessor for that
fielder then go to the field so the fact
that you can change the variables and
assign additional variables to objects
makes the life a lot more complicated
for a running JavaScript and you get the
same thing for jet compilation so JIT
compilers work really really well when
they know exactly what your code does so
an example of this is if you're trying
to write really fast java code if you
declare your variables is being private
the JIT compiler can do that faster
because it knows nothing outside of your
object is going to access it can make it
a local variable
if you declare things as final and we
know they're not going to change then we
can make that into a constant we don't
have to do a look up to see where
there's someone else to change the value
we can just in line it into the function
so based on the fact that types don't
change we can do things faster we've
also got the problem that we don't know
when we're executing something like a
plus operator ID the plus operator in
javascript is interesting that if you
have two numbers and you have a plus
between them it adds the two numbers
together right that's what you would
expect but you can actually do a plus
between a number and a string right in
Java that doesn't work in JavaScript it
converts them both to strings and then
puts them together now if you've got an
object and a string or an object and a
number something even more complicated
happens so the just-in-time compiler
doesn't have a clue what you're going to
do because it doesn't know what the
types are so it has to try and deal with
this and really what it does is it makes
some optimistic assumptions right it
hopes that you're going to do what
people typically do so it will get
compile it assuming that you're going to
do something sensible and then if it
turns out you don't write if it turns
out you are trying to add a number to an
object it handles that by saying okay
it's not the types that I expect it
we've just failed I'm now going to have
to create a whole load of new code
that's actually going to handle this
case and I'm then going to associate
that with the map and hope that any
object with the same values in the
fields allocated in the same order are
going to be running the same code so
next time it's only this one that I need
to do so it changes which is the the
first choice so this is all to do with
the fact that polymorphism is there and
it's all dynamic and weakly typed so the
just-in-time compiler has a real problem
with this so what javascript does
furfolk compilation is first of all it
starts off by doing really really poor
compilation right in Java you write your
Java code and then you run Java Sea and
you get byte codes and the JVM runs
those byte codes in order and then it
converts it to assembler event
it right there is no Java Sea step in
JavaScript you take your script and you
run it and execute it straightaway so
what it does is it just takes the code
that you've given it and it converts it
to assembler in the easiest fashion and
it does it lazily so it does it the
first time you execute a function so
there's a function you never call it
never compiles it but it doesn't do any
optimization admit immediately then
there's a second compiler called
crankshaft and you can think of this
much more like the just-in-time compiler
so it's the equivalent of the hotspot
chip what this does is it watches code
execution tries to work out what the
common path is through the code and then
creates compiled code based on that
common path now what interesting thing
is it used to do sample-based profiling
I used to every couple of milliseconds
take a snapshot of what's being executed
and used that to decide what to compile
and how to compile and that's exactly
the way hotspot works they then decided
this doesn't actually work so well for
JavaScript and they decided to change
model and use a counter based system so
the more often a method or a function is
called the quicker it will get get
compiled and that's interesting because
that's the way hotspot worked like seven
years ago so they started where hotspot
is now and then went backwards and this
means that it's probably a
characteristic of JavaScript that it
just doesn't work in quite the same way
so using the same JIT compiler for both
or the same schema of JIT compilers for
both doesn't quite work garbage
collection so it implements garbage
collection very very similar in fashion
to hot spot it has a new space in an old
space it has generational GC it has
remembered sets which are used in hot
spot as well to know about references
from the old generation to the new
generation so the scheme earn the design
is very very similar there's some
additional areas so for these maps that
tell me where to find fields inside
objects it's got a separate space for
those you can think of that may be a bit
like the permit
and it implements a concurrent marking
concurrent sweep which we have in hot
spot so it's very very similar it does
have another unique problem and that is
the way that you work out what is live
in Java the way that you work out what
is life is to start from the thread
stacks and say any variable that's being
used by methods that are currently
executing needs to be kept alive so if
my method is using an object I'll keep
that object to live and then everything
that object is using I'll keep that
alive and I build a big tree but the key
is I started off by knowing which things
my method was using and whether or not
their objects but we've just said that
in JavaScript we have no idea whether a
field is going to be an int or a long or
a boolean or an object so there's two
ways that you can handle this the way
that they used to do it was they said if
you've got a value and what that value
points to if it was an object pointer is
an object then I have to assume it's
using it it's called conservative
garbage collector garbage collection
right anything that my data points to if
treated as a pointer if it's an object
I've got to keep that object to life
they've bagged on a stage further and
they've used tagged pointers it's a
little bit of magic on the way that it's
a stored and it allows us to use the low
order bits to determine whether or not
we think it's actually an object so it
now is a bit better than it used to be
but they still have this problem that
because variables can change we don't
know which are definitely objects and
therefore i'm not quite sure what I have
to keep alive in GC so that brings us to
the next bit and that's JavaScript on
the JVM so there's a whole load of
challenges that v8 has trying to run
JavaScript but v8s not really being
arraigned for all that long right the
Chrome browser has not been around for
the almost 20 years the Javas been
around and it's not had the same kind of
investment in gaining performance so
JavaScript on the JVM is being pushed
quite a lot and I took a look to see how
well it stacks up so in terms of what's
available
so Rhino was delivered in Java 6 from
the Mozilla Rhino project and that
allows you to run JavaScript directly
inside java so it's quite good it allows
you to execute some JavaScript code from
inside your Java code so you cannot ask
it to evaluate some JavaScript code and
from that JavaScript code you can ask it
to execute some Java code so you've got
interoperability in hang and it provided
a command line utility the performance
of it did however suck really badly and
that's why they've introduced invoke
dynamic in Java 7 and the nashua engine
is the evolution of rhino that uses
invoke dynamic and the whole idea of
invoke dynamic is when you're executing
a function in JavaScript you don't know
what type of function is and what it's
going to act on what data it's using so
invoke dynamic lets you change the
method that you're about to call based
on some heuristics so it allows you to
do much more polymorphisms style of
things which have to happen in
JavaScript and now the effect of that is
depending on the benchmark that you're
running mash horn is 2 to 10 times
faster than JavaScript so it's a huge
leap on on top of JavaScript and that's
a statement about Java 8 Update 20
update 40 is due to occur where they've
done a whole load of additional
performance work so nasha one's going to
be faster again in a couple of months
time okay so I said that you can do
interrupt between Java and JavaScript
with Nashville so the way that you do
that it's quite simple in your Java code
you request a script engine manager and
from the script engine manager you ask
for an engine by its name and that name
is Nashville so I just do nashorn equal
script engine manager don't get engine
by name mishawn and that's it I now have
my Nashville an object the next thing I
have to do is I'm going to have a
variable could send vow that I want to
send to Java so I just do natural not
put the name of the variable that I want
to send and so how it shows up as a
variable in my JavaScript code
the value that I want to send so
basically engine dot put is the way to
send variables to your JavaScript code
then I can run my JavaScript code by
doing Nash horn eval so let's evaluate
this JavaScript so in my JavaScript I
can also call back out to java so I said
JavaScript single-threaded so one of the
things i can do is i can actually access
the java threading library so i can
create a variable that i'm going to call
thread and i'm going to access the java
threading library using the Java keyword
so Java doc type and then the name of
the class that I want right so that
that's going to give me the the
java.lang the thread class then I want
to create a thread so I create another
variable which I'm going to call my
thread and i'm going to ask it to extend
so that's equipment making a subclass of
my thread object and i'm going to give
it a function called run and all it's
going to do is execute a line of text
that says i'm running this in a separate
thread I then create a new instance of
that thread and I start it so it's going
to print out the text and then the last
thing I'm going to do is I'm going to
create a result value which is my send
value plus 3 and then when i get back i
can get that result value from nahshon
so I can put values in using put I can
get them back out using get and I can
create threads inside my JavaScript code
even though JavaScript doesn't actually
by default in VA outside of the JVM let
me do threading so it lets me do
multi-threaded JavaScript if I want to
so the next thing to say is that there's
a layer on top of mash Sean right now
Sean is the equivalent of v8 it does
JavaScript know Jas took v8 from the
browser and gave it libraries to
interact with sockets and the file
system and so on avatar Jas is the
equivalent of nodejs on top of right on
top of mash on so you've got exactly the
same thing you've got this event loop
style callback system for doing fast io
running on top of Nashville and inside
the JVM
and that means that you've got two or
three advantages over note j s the first
is that you can use Java classes so if
you wanted to use a jar of a hashmap or
the big integer class then you can do so
if you wanted to use bindings to
databases that happen to existing Java
code but don't exist in no Jas you can
do so the other key difference is that
you've got the ability to run more than
one thread so we're know Jas is a single
event loop right single-threaded avatar
is not limited to that because it you
can use the threading model from Java
there are a few problems with it at the
moment to download from maven there's
only 64 bit version available so that's
what i'm using at the moment 64-bit
avatar there's a huge number of modules
available for you to use it for third
party code in node you download and
install those with NPM and which is
there no package manager you have to use
the native node package manager from
node at the moment to pull these
packages down to use with avatar and any
NPM modules which happen to interface
with the v8 runtime at the moment you
obviously can't use with with Abbott rjs
so there's some modules that don't work
but a huge number have actually been
tested with avatar already so avatar j/s
verse is no jay s so this isn't an
official benchmark that Iran well it is
in that I used octane release 33 octane
is the JavaScript benchmark from
Google's that they use with v8 it's not
directly an oj s benchmark so i'm
actually doing a benchmark of v8 against
a benchmark of nash horn you know in all
honesty and i ran it on my laptop so not
a controlled environment you know it
could be right or wrong by a number of
percent either way I ran out my late
laptop which is an eight CPU windows box
node is single threaded so it can only
use one of those I ran it using hot spot
a update 20 as I said there's better
performance in 40 but I don't know how
much because it's not really
yeah and I used out of the book settings
I made no attempt to do anything other
than run avatar j/s bench j/s and nodejs
bench is that's it so this is the
results I got so I ran avatar jas first
and that's perf born in Windows it's the
windows tracking that line is physical
RAM usage over time so to run the octane
benchmark it took 1 minute 56 seconds
and used almost 3 gigabytes worth of RAM
so that's a huge amount of memory to run
the benchmark I ran the same benchmark
on nodejs and that's what happened it
executed in 24 seconds and use 268
negative memory so the difference at the
moment is node ran my made up very
quickly hack tank test with a public
bench mark 4.8 times faster and used
less than ten percent of the memory now
that actually really surprised me I
expected it to be slower I didn't expect
it to be that much slower I expected it
to be bigger because whilst the the op
that when you think like that object
model for JavaScript I said it's really
complicated in comparison to java
objects when you're running avatar on
the JVM it's got to represent that
complicated javascript object in java
objects which makes it even bigger so
yeah uses a lot more memory and doesn't
provide you I near as much performance
at the moment Marcus is doing huge
amounts of work on this and I expect
those gaps to come down over time but
you're still doing emulations of
javascript in java on the JVM so they're
never going to you know disappear 220
difference so I actually wanted to know
what that memory usage is for and you'll
actually see that a big problem here is
the hot spot garbage collector the the
the the red line there at the bottom
that's the actual used memory of hot
spot running avatar j/s
the top line is the heap size so all
occupancy against the heap size is
really not very high a hotspot basically
expanded the heat rapidly when I had a
spike in memory usage and never brought
it back down again but even if you just
look at the the real used memory it's
still 2 X what it is for avatar I'm
sorry for EM for nodejs and the other
thing is that there's a huge amount of
non Java heap memory that's being used
as well as bad a gigabyte of non Java
heap memory used when you're running
avatar Jas where there's there's only
about 30 or 40 Meg's worth of non-object
heap memory when you're running node so
there's a huge memory difference so the
next thing I actually tried to do was to
start looking at what that memory is
used for so I took a dump an H prof dump
from avatar j/s and loaded it into
memory analyzer which is a tool for
visualizing the Java heap but it also
gives you access to the thread stacks so
I saw the thread stack of what's
executing in Avatar j/s and if you can
read it everything is java.lang invoke
lambda form so because you're
virtualizing the execution of Java code
your stack traces are actually useless
to you because they just show you the
interpreter for the JavaScript running
not the jut not the name of the
JavaScript functions that are running
and in fact if you can see the bottom
line which I'm sure you can't it says
total 25 or 327 entries so that stack
trace is actually 327 frames deep so
we're doing a huge amount of work to
execute some fairly simple JavaScript
code so what are the challenges of
running on top of national top of the
JVM is that your stack traces will make
no sense anymore I also tried to go
through some of the object memory but I
didn't get too far because only started
looking at that a couple of days ago but
it's a similar picture you don't see
JavaScript objects are going to see java
objects which contain data that would
otherwise be in a JavaScript object so
it's all being rapid and virtualized so
in summary javascript is growing and if
you're not looking at it you probably
should be
it's a sink io is built in from the
ground up and that makes it very easy to
write scalable applications particularly
those that interact with a client on the
browser because then you can share
JavaScript code on based server and
browser it scales well but for depending
on the workload Java may still be 2x
faster it's got problems in terms of
getting truly fast because it is
dynamically linked and weakly typed I
mean it also has a challenge there that
in JavaScript if I try to add together a
number and an object it's going to fail
at compile time with JavaScript I can
actually do that at runtime and I've got
no idea what's going to fall down it's
just not going to be right so Java is
better in those ways where you can find
out problems at development time that
you would in JavaScript only find out in
a deployment time Nash short and avatar
Jas does bring JavaScript to the JVM and
it lets you do interop and I lets you
run them in the same process and it does
let you run multi-threaded JavaScript
but it suffers from the same challenges
of trying to run fast which is the fact
is weakly typed and dynamic means that I
don't really have a good way of
compiling this I just have to be
optimistic I have to guess what's the
best route going to be and if that fails
I have to roll back and try a different
way of running a method so i think it's
it's never going to be able to catch up
with v8 unless v8 stops doing work to
optimize for running JavaScript and it
becomes a less interesting project for
Google and final slide there's a plug
there that we do our own ojs runtime
name it we've done the port as part of
the open source project to IBM servers
but we also do a version for you know
linux intel windows intel etc as well so
questions none ok I guess either
everyone realizes they're serving beer
outside and wants to go or I've really
confused everyone by the way thanks for
attending
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>