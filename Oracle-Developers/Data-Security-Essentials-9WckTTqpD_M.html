<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Data Security Essentials | Coder Coacher - Coaching Coders</title><meta content="Data Security Essentials - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Data Security Essentials</b></h2><h5 class="post__date">2015-06-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/9WckTTqpD_M" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning everyone and welcome to
this talk on data security essentials we
appreciate that you're chosen the stop
for attending so a quick introduction of
ourselves
I'm Manish I work at Verisign for as a
principal engineer and for most part I
have been working on the DNS naming
registry products and my co-speaker and
everyone thanks Manish so I am an Arab
and I work as a software architect at
very same so I've been working for many
years in the software industry mostly in
back-end applications and systems in
areas such as databases text search
engines and of course security in the
data security area I have worked on the
DNS sex signing of the DNS root zone and
also on data security for enterprise SAS
applications so what's the motivation
for this presentation on data security
essentials firstly data security is
vital so not only does data have a value
for business competitiveness which is
why we have so much of analytics and
stuff and it's valuable to enterprises
but protection of data in at rest in
motion at all stages in the life cycle
of the data is very vital for the
reputation of the company and the trust
that customers have so if a data breach
occurs or if a company inappropriately
discloses data to other parties that
trust can be lost and that reputation
can be lost so as all of us know we have
been seeing some of that happening
lately so it's important to understand
these aspects of data security too now
the next thing when a bit surprising so
data security is not necessarily the
same as application security so there's
a lot of talk on application security
and most engineers have to go through
secure coding practices training and
that kind of stuff which deals mostly
with authentication of users into
applications and what kind of actions
they can perform now that is the
authorization aspects now why would
somebody hack into an
allocation it's mostly to get access to
data they might do some other things
like bouncing a machine or sending spam
but that's more of you know not so much
concerned with the enterprise it's more
of the stealth mode access to data and
getting out that data that's important
for from the enterprise's point of view
now should an app breech necessarily
cause a data breach that's a question
that we have to think about now the way
things are implemented currently this
pretty much is the case so because an
application connects to a database or
some other data store and if you have
control over the application you pretty
much have control over what they are you
are getting but should it be that way is
it at all possible to ensure that even
if an app breach occurs all the get
access to is encrypted data and then
there is some other secret piece of
information that a client has to provide
which would allow that data to actually
make sense because if we can achieve
that then we have achieved a lot of
security from you know malicious access
now that is one aspect we are going to
see some examples of that later in the
presentation and data may be handled
independently of the app as well
so data has to be migrated archived
there's a whole data lifecycle that is
there so at all stages it has to be
protected now when we bring cloud
computing into the picture the the
puzzle broadens so now there are many
more parties involved and a clearer
appreciation of applied crypto becomes
necessary why is that so because now you
have to understand what kind of security
assurances you are getting from the
cloud security provider so CSP is cloud
security provider so what security
assurances are they providing you what
are they expecting you to implement
yourselves they might be providing all
the facilities for doing so but you
still have to do it understand and use
the right algorithms so that separation
of responsibilities is there and finally
if you are providing a cloud service you
are responsible to your end customers so
the questions will be directed to you
and you are relying on other parties to
provide you some kind of services
and secure services at that so to
understand that there is an appreciation
of applied crypto which has become much
more necessary in recent times so and it
also helps to make sense of some of the
news items which are coming out so even
during the preparation of this
presentation there have been reports of
NSA having backdoors and you know
different kinds of weaknesses in Kryptos
so how serious of those how much should
be bother about those so to understand
that a bit of crypto becomes necessary
so with that I'll pass it on to manage
to cover the first part of the
presentation and I will come back later
thanks everybody so here's the outline
of the agenda today so we'll go through
the you know key security the basics
cryptography and some basic security
goals that we all of us have we'll also
cover the crypto primitives that are
used to achieve these goals basics like
hashes symmetric key cryptography
digital certificates signatures and then
this is followed by you know some data
security considerations for the cloud
some of the more recent trends like the
hsm the encryption gateways for the
cloud and homomorphic encryption as well
so the basic terms let's begin with some
of the basic crypto you know concepts
and these are all simple concepts of
course the math behind it is very
complicated but these algorithms have
evolved over a period of time and to
almost always to make a right choice
what we need to know is the basic
concepts of these things so we'll we'll
see what all are the security goals that
we have essentially there are four
security goals that we want to cover in
our data security applications
authentication is one of the goals where
you know you need to prove that you are
who you claim to be right
confidentiality would generally mean no
one other than the sender and the
receiver can make sense out of the data
right non-repudiation means the sender
cannot deny that they had actually sent
the data and one of the final security
goals would be you know data integrity
which means that the data cannot be
tampered
when it's in transit some more basic
terms encryption the process of you know
converting the clear text into cypher
text also known as ciphering decryption
is the opposite of it where we convert
the cipher text back into the clear text
at a very high level there are two
encryption algorithms that will be you
know talking about one uses symmetric
keys where we're in a shared key is used
for encryption as well as decryption and
the other one is the asymmetric key
cryptography where we technically deal
with a mathematically related key pair
where there is a public key and a
private key and one of the keys can be
used to encrypt the data whereas the
other one can be used to decrypt the
data so the cryptographic hashes so what
are these so hash is basically a digest
or a small fingerprint that can be
matched against a bigger message to
prove that neither of neither of the
hash or the message has been altered
since the creation so there are some key
properties of a cryptographic hash that
I'm going to quickly cover over here
should be infeasible to reverse that
means given the data or the message you
can create a hash but not the other way
around you can provide any length of
input to the hash function but the
output is a constant length usually you
know 128 or 256 bits or 512 bits of
output which we call as the digest or
the hash it should be easy to compute
infeasible to craft collisions so let's
say the the hash is like you know 128
bits or 256 bits right so at most at
most you can have you know 2 to the
power 128 or 2 to the power 256 hash is
created but the domain of the inputs is
huge right you can have any any text
data that can be used to create a hash
so there would be collisions but the key
property over here is it should be
infeasible to craft a collision which
means that given a hash it should be
almost impossible to find out another
string
can generate the same hash and lastly
the even a very small change in the
input should result in a significant
change in the hash so even if you change
one bit in the input the hash should
change you know more than more than half
of the bits in the hash should change
so the key security goal that is
achieved when using hashes is data
integrity which means that if the input
changes the hash changes so anyone can
compare our data with its hash to verify
that the data is you know not tampered
with it's pretty well-established these
days that passwords shouldn't be stored
in clear-text so because passwords of
this they are stored in clear text in
databases and if the databases are you
know our table is a stolen then all your
users passwords that you know vulnerable
they're out so all the passwords should
be stored as cryptographic hashes and
other than these we'll see
further ahead that the hashes are also
used in digital signatures and digital
certificates there are some non
cryptographic hashes as well like for
example one example is CRC which is the
cyclic redundancy check so it is also a
hash but it's a non cryptographic hash
meaning that it necessarily does not
follow all the five properties that we
just covered for cryptographic hashes so
there are some uses for non
cryptographic hashes for example it's
mostly used in network protocols or you
know sometimes to check the integrity of
a file
during arcing and things like that so
what are the algorithms for hashing well
here are some of the algorithms you can
use md5 sha-1
or sha-2 family algorithms and which
includes chart 256 sha-512 the only
recommended algorithms in today's times
would be short 256 and above md5 you
know has been proved long back to have
some of the collisions hashing
collisions even sha-1 is said to be
vulnerable so chart 256 and above are
generally recommended for hashing now
still what all are the different attacks
when we
thing from a data security perspective
um one attack would be pre-computed
dictionary attacks so when the input
domain of of something that you want to
hash is a small so let's talk about
passwords over here
the usual non complex passwords would be
like 15 to 20 characters so how many
such passwords could be there right and
then on top of it if you just are using
some dictionary keywords or some common
terms and some alphanumeric passwords
there can be a limited set of such
passwords and the hashes for these
passwords can be pre computed right so
you can always create a lookup table
with a password and its corresponding
hash now what dictionary attack involves
is let's say given a hash write hashes
are one way obviously but given a hash
if you reverse lookup in this table and
find out that okay this is the hash and
this is the corresponding password then
you know where you are able to still
steal the information or find out the
the the data that was used to generate
this hash right so mitigation towards
this is using random salts so salt does
nothing but it's a you know random
sequence of bits that's concatenated
with the passwords and then before
computing the hash so then the hash is
computed on top of it naturally this
will involve storing the hash along with
the salt so that when a user presents
the password back you concatenate the
same salt again and then compute the
hash to verify and validate the
passwords the other attacks are hash
collisions and the usual mitigations are
using stronger versions which is like
char 256 and upwards so that you know
the hash collisions can be avoided more
specifically for passwords one can also
use two-factor authentication or
multi-factor authentication which which
has this factor of you know the
knowledge and possession and inherence
who you are and you know what you
possess and something like ot P as well
what you know so quick code snippet of
you know in Java how do you come
sha-256 hash right I'm not going to go
through all of it as of now because I
mean code snippets are pretty common and
not a very big deal over here it's
important to understand the concept as
of now and I believe the presentation
would be made available later so these
can be seen and referred to later as
well so what is H Mac or the hashed Mac
message authentication code right can we
the the thing is can we combine data
authentication along with data integrity
in a hash because a plain hash would all
it gives us data integrity right so what
is the deal with H Mac so H Mac factors
in a secret key so what it does is let's
say you have some data it factors in the
secret key let's say it concatenates the
secret key with the data and then
computes the hash now this hash and the
data can be passed on to the let's say a
receiver if the receiver also has the
shared secret or the shared key the
receiver also they also perform the same
concatenation and then compute the hash
on top of it right so here two things
are guaranteed to of the security goals
are achieved one is data integrity
because the hashes match and since the
hashes were computed by factoring in a
secret key at both the ends it also it
also guarantees the data authenticity
right so you know that the data has
originated from someone who already
possesses the secret key so that's all
about the H max essentially factoring in
the secret key is not as simple as
concatenating the secret keys it's
described more in detail in this RFC
2104 how to compute H Mac the algorithms
are on top of the hashing algorithm so
the usual recommended H Mac algorithms
are H Mac / sha-1 or H Mac / sha-256
right so H mac covered security goes
achieved our data integrity and data
authentication with H Mac symmetric key
cryptography now this deals with and
corruption right you have a shared key
or a symmetric key which can be used and
the key is symmetric which means that it
can be the same key can be used for
encryption as well as decryption right
the one key thing over here is that the
communicating parties who want to
exchange data encrypted data should
share the symmetric keys right that they
need a mechanism to exchange these keys
and obviously the keys must be secret
and safely stored when I refer to keys
over here there are some sequence of
bits in general use for confidentiality
now if it's not only used for the
encryption is not only used for data
transmission but you can also use
generally the encryption for data at
rest for example as an urban mentioned
that app secure app security is not
equal to you know or app breach is not
doesn't mean that you know your data
should be at risk so even if you have a
data at rest on the disk you can in
general encrypt the data and put it on
the disk so that even if the data is you
know made available to someone else they
cannot make sense out of it and it is
still an encrypted format some of the
key things about symmetric key ciphers
are that they are very efficient it's
very easy to you know generate the keys
it's it's cheaper and relatively non
expensive to encrypt and decrypt using
symmetric keys and the keys the smaller
bit keys can protector you know or
relatively can give a higher level of
protection meaning that if you compare
it we have one of the next slides but if
you compare it with a symmetric key
cryptography you get the same crypto
strength with a smaller key size in
symmetric key we'll cover that in more
detail in one of the next slides the
algorithms the eight LS it the
algorithms which are italicized over
here those are the non recommended or
the older algorithms so as on date the
only recommended algorithms would be a
es 256 or AES one
- for symmetric key cryptography to
point out one more specific difference
des Triple DES and AES are all they all
use block ciphers where as you know rc4
uses its clean ciphers what are the
possible attacks over here cryptanalysis
attacks are possible on symmetric keys
so crypt analysis is the art and science
of breaking the secrets right and one of
the mitigations is avoiding the use of
ECB mode of operation so this is
slightly more involved and I think we
can cover it in when we cover the the
code snippet over here but in general if
you when you are using a block cipher so
which is the case with DES Triple DES
and AES algorithms right you have to
choose a mode of operation and this mode
of operation can be you know ECB which
is electronic codebook mode of operation
or it can be something else like CBC and
CTR so the preferred mode of operations
are CBC and CTR here so that is one of
the mitigations for cryptanalysis attack
the key must naturally be you know
safely stored so you have to avoid key
compromise and the only mitigations
against at our use larger keys or you
know rotate and roll over the keys
periodically store the keys securely
over a restricted file system which has
a restricted access and you can also use
the hardware security module which which
will be covered in one of the slides for
storing the keys so here is a small code
snippet over here for symmetric key
cryptography using Java the the first
part includes the choice of algorithm so
we are using AES algorithm the key size
is given to be 256 right the
initialization vector so this introduces
an additional randomness when you you
know encrypt using the symmetric key
cryptography so you can this this should
be a random random integer random bytes
sequence of bytes and then you have to
provide the transformation scheme so
which actually tells over here that the
algorithm is AES the mode of operation
is cipher block chaining and the pkcs5
padding is used so when you do a block
cipher typically you you you chunk your
input into specific blocks the last
block might not be the full block size
so you might need to pad it so you
that's the padding scheme used over here
and then rest of the stuff is pretty
straightforward over here and I'm not
going to cover it in detail and you know
nothing which has evolved very recently
it's the same way which are you know
which it has been since our a symmetric
key cryptography this involves a
mathematically related key pair a public
key and a private key one of the used
keys can be used for encryption and the
other keys can be used for decryption
over here and one of the important
properties is it should be infeasible to
compute the private key from the public
key when you are using a symmetric key
cryptography private key is naturally a
a secret key which is owned by one
entity whereas the public key is public
it can be made available to everybody
else
okay so what are the key security goes
covered when you are using asymmetric
key cryptography data authentication
right so let's say let's say you have
some data and you know you you encrypt
it using your own private key okay and
make it make it available when when that
data can be decrypted by your public key
by anybody else what it means is that
the data has originated by the you know
from someone who owns the private key so
data authentication is one of the
security goals that's achieved using
asymmetric key cryptography
non-repudiation so non-repudiation is
another key goal that's achieved over
here now what it means is the sender
cannot deny that they had send the data
which is almost similar in many senses
over here with data authentication
because the data is encrypted using the
private key of the sender so the sender
can not deny that they had sent the data
and Trust
sorry confidentiality so now this is
essentially one-way so if if I you know
encrypt using my private key right then
it can be decrypted by my public key
which is with everybody else so
confidentiality is not guaranteed here
right but if the data is encrypted using
my public key then it's only me who can
decrypt the data right so in that case
the confidentiality is guaranteed so
anybody who owns my public key who has
access to my public key can encrypt the
data using my public key and then you
know that data is encrypted and can only
be decrypted by the owner of the private
key so here we are comparing the crypto
strengths there are three algorithms and
covered over here
the bottom most line is the I'm sorry
the font size is little small here the
bottom most line over here is the
symmetric key cryptography algorithms
the middle line is the elliptical curve
cryptography algorithms and the you know
topmost line is you know RSA or
diffie-hellman algo are
terms which are essentially the
asymmetric key cryptography algorithms
the key thing is for a given algorithm
like if that if I choose any specific
algorithm the smaller keys are almost
always most efficient which means they
are faster to generate it's relatively
quicker to you know encrypt and decrypt
using the smaller keys and they always
produce a smaller encrypted output okay
so smaller keys in general are
preferable but why do we want larger key
size because larger key sizes for a
given algorithm they provide a higher
crypto strength so there there will
always be a you know tend to choose a
longer key for a given algorithm now if
I compare across algorithms then
symmetric keys are smallest and provide
you know same crypto strength for a
smaller bit size as you can see in this
specific bar over here the 112 bits of
symmetric key provides similar crypto
strength as you know to 0 for 8 bits of
RSA which is a asymmetric key
cryptography so symmetric key
cryptography is always you know cheaper
to encrypt the data but for one problem
you know how do you transmit the shared
key between parties so here are the key
things asymmetric crypto since it's
pretty expensive to encrypt the data
using you know this mathematically
related public and private key pair
right they are almost always used to
encrypt very small amount of data right
it's mostly used for basic
authentication but if the data is
voluminous then it's not feasible to use
a symmetric key cryptography and similar
to the symmetric key cryptography you
always have to store the private keys
safely it's used to provide the data
origin authentication so this is one of
the key usages
another important usages for you know
for secure communication schemes like
SSL and GPG and SSH
asymmetric key cryptography is used to
initially share the premaster secret
okay and then both the parties once they
use the premaster secret to compute and
generate a master secret then the later
half of the session is always you know
using symmetric key cryptography so they
have the they share the common secret
and and that common secret is used to
encrypt the data over the insecure
communication channel
so asymmetric uses primarily for
initially sharing the you know premaster
secret and then and then when both the
parties have a common common shared key
then they can use a symmetric key
cryptography for the later half of the
session so it's it also finds its use
and digital signatures and certificates
which we are covering so mmm small code
is in effect that that you know shows
the usage of the public and the private
key pair so in this code snippet we are
using RSA algorithm and 2:04 it is the
size of the key you can generate the
public in the private key pair and then
the encrypt decrypt are pretty much
similar to these operations are similar
do you know how you would do in
symmetric key cryptography alright
moving on to the digital signatures so
digital signatures typically they use
two of the important things which we
already covered two of the important
crypto primitives hashing and the
asymmetric key cryptography right so it
builds on hashing and asymmetric key
cryptography what you do is you have a
data which needs to be transmitted over
in secure communication channel right
you compute the hash of the data and
encrypt it using your private key so so
you have an encrypted hash of the data
right this encrypted hash is also
transmitted along with the data at the
receiving end the the data is received
and the encrypted hash is received the
encrypted hash is decrypted by the
public key right to get the hash
- and this hash can always be compared
with the hash of the data received so
there are two goals which are achieved
over here one the integrity of the data
because the hashes have matched and two
the data authentication of the data
origin authentication because I am able
to I am able to decrypt the data using
someone's public key that means the data
must have been sent by by the owner of
the private key right so I know that the
data origin authentication where the
data has originated from and thirdly the
sender cannot deny that they had sent
the data because I was able to be crypt
using their public key so
non-repudiation right so these are the
three cryptographic goals covered using
the digital signatures the prominent
algorithms for digital signatures are
RSA RSA DSA and the you know elliptical
curve cryptography the most common is
RSA over here
the applications are in you know signed
emails and you know the digital
certificates DNS SEC the attacks and the
mitigation so since digital signatures
are typically based upon public key
cryptography and hashing the attacks are
common and the mitigations are also the
pretty much the same so usually you
would have a strong hash and a strong
encryption and you would take care to
you know store your private keys safely
and securely alright and the final piece
and the basics is the digital
certificates so one problem still
remains unsolved how do I rely on the
public key you know how do I get the
public key let's say someone send send a
public key how do I know that this is
the public key of a specific entity
right so this problem is actually solved
using public key infrastructure so which
is a set of computers hardware software
processes policies in place and most
importantly the ca's which is the you
know certifying authorities globally
right so what is being done is I Allah
you know as a part of my browser
I get a set of trusted ca'se the the a
set of CS that I you know generally
trust and who act as a trust anchor
right and when I let's say when I open
open our HTTP connection to some
specific server the server presents its
certificate to me that certificate is
signed by one of the CS which is already
available with me which which I am
already trusting now since I am trusting
a a CA right I am also trusting anything
that he has signed so I verify the
digital signature of the certificate
presented to me right and based on it I
extend my trust to the server who is
presented the certificate to me so that
chain of trust entirely right so you can
have a certificate which is signed by
someone else then you will see ok this
guy has signed the signed a certificate
now who has signed the certificate if
ultimately the root or at any point in
the chain if you trust one of the one of
the entities then you are trusting the
entire chain over here yeah so if you
have the intermediary certificate as
well in your chain then you are you
annoying you stop validating it up from
there so you you know treat it as a
trusted certificate right so what are
the key parts of a digital certificate
right the most important parts there are
whole lot of things which I am NOT going
to cover but most important parts are
one the subjects public key so a
certificate is essentially you know the
public key along with some other
information which is signed by ax C ok
which is a digital certificate which
means which means that you know I I can
rely on this public key I know that this
is the public key of the subject another
important part is the subjects name
which could be the you know the DNS host
name or the email address you know which
associates the subject with its public
key and there are some other things like
validity extensions and the actual
signature which is the which is the
digital signature of this entire thing
so digital certificates they solve one
key important thing that trust right
which was missing in all other crypto
primitives and usually it's a it's a
choice of choice between these crypto
primitives they are used to in
togetherness you know to achieve the
overall objective the attacks could be
once again since digital certificates
are based on you know digital signatures
which in turn was based based upon
hashing and asymmetric key cryptography
so the attacks and the mitigations are
pretty much same but some general
mitigations would be used a reputed CA
so a CA who has put in all the processes
and policies in place to you know keep
their signing key secure because a
compromise of a CS signing signing key
or private key would mean the compromise
of you know all the certificates which
are signed by a specific CA so choose
your CA very carefully and use a reputed
certifying authority right it should
also use a strong encryption and hash
functions when you know creating the
digital certificates refer to
certificate or vocations this is mostly
for the clients the clients must
actually refer to certificate revocation
lists so in case of a specific
certificate being compromised then this
is the list where where where all the
revoked certificates are maintained
alright with that I'll hand it over to
an herb and for data security
considerations for the cloud okay so
after the overview of crypto basics we
come back to data security at a higher
level particularly with respect to cloud
computing although even if you are not
using cloud computing many of these
things still apply but in in a different
way so again just to come back to how we
started the presentation so we data
security is crucial for enterprises and
data protection is vital for reputation
so now what's happening in cloud
computing in particular is that data
moves out of the enterprise boundaries
so there has to be trust on those who
are hosting that
and those were sort of managing the
lifecycle of that data and also in cloud
computing you have shared infrastructure
so the network is shared the disks may
be shared the data center is shared so
you have multiple tenants which is not
the usual model in which many of the
applications were designed where
anything within the LAN is considered
trusted so when you are on the same
network segment as another enterprise
then some other things come in there but
at the same time the benefits of cloud
computing are compelling we know about
that so now one thought that should be
in mind is is not moving to cloud
actually secure so if you don't move to
the cloud does that make it secure so
one of the benefits of cloud computing
is that you can use solutions for
problems that have been encountered for
you know the whole ecosystem for other
enterprises so if some of the security
problems are being solved there you
stand to benefit from them so it's it's
not always necessary that not keeping up
with these trends is beneficial
although yeah if we have the data within
our enterprise boundaries it feels
comfortable but is it all that
comfortable is something to think about
as well so now earlier this year Gartner
brought out a research note which
covered top cloud data security issues
this is pretty good coverage of the kind
of things that enterprises have to think
about the kind of security plan they
have to put in place to understand the
implications of moving data to the cloud
or even if they are not moving to the
cloud some of these apply to within the
enterprise also but in the cloud there
are more parties or even developers have
to be more aware of these kind of things
so the first is breach notification and
data residency data residency refers to
where in which geographical location
that is country or region is the data
actually resident the important thing is
that if data is resident in a particular
geography it is subject to the laws of
that geography
so if European company is getting its
data hosted in u.s. it is
to us laws so us legal authorities or
government sources can ask for access to
the data from the cloud service provider
and also if any breaches occur or if
such disclosures are made then that
information also has to be provided by
the cloud service provider so they
recommend that you evaluate your cloud
service provider for these things you
you might be able to conditionally tell
them that this data has to reside in
this geography now big cloud service
providers have taken care of these in
many ways so in AWS you have such
facilities of regions and countries and
stuff like that
the next is data management at rest so
this means how is the data stored in the
databases is it stored encrypted if it's
stored encrypted then that is better but
if it's not stored encrypted what kind
of mechanisms are in place to take care
of the privacy concerns and against data
compromised now also data goes through
its whole lifecycle so some data might
get obsolete it might be end-of-life so
one of the the benefits of encrypting
data is that you can implement some form
of digital shredding as covered by money
in the previous section the the key the
secret key is the basic thing for the
encryption so if you can somehow have
encrypted data and you destroy the key
then in some sense you have destroyed
the data or you digitally shred the data
so such mechanisms if they are provided
by the cloud service provider that is
they are storing the keys securely and
managing the lifecycle of the data
properly there is something which would
be useful and also multi-tenant storage
is sometimes used which means that there
are big you know storage things which
are actually hosting data from multiple
enterprises now we are always
conditioned to thinking about having our
data in the internal network on our disk
but when it is shared with other tenants
what kind of separation between tenants
is being provided by the cloud service
provider so these things are all
available better cloud service providers
provides such assurances and there are
the vendors have made such things as
part of their multi tenant enhancements
data protection
in motion so when so at the very basic
it involves the use of SSL and stuff
like that for interactions between the
client and the server and also for move
replication of data and in this case
also there is something within at the
LAN level which means that now the
tenants are sharing the same physical
network in the cloud service providers
data center so you know are they able to
snoop on other enterprises data is
something which has to be thought about
so now here also there are solutions
available in the form of VLANs or
virtual LANs which actually achieve some
kind of virtual network separation for
the same physical network encryption key
management so how securely are the
encryption keys managed ideally hardware
security modules should be used by the
cloud service provider if they are not
allowing you to control your keys in
most cases it will be the case but there
are solutions where the enterprise
actually has control of the keys as we
saw the possession of the key is the
vital thing so whoever possesses the key
can get access to the data so if the
enterprise can actually only have the
key the enterprise alone then that
provides higher protection than the
cloud service provider having the key
but even if the cloud service provider
has the key they should have it in a
hardware security module and be able to
manage will cover a bit of hardware
security modules later so access
controls so especially for
administrators there should be some kind
of additional checks or two-factor
authentication or checks on which IP
addresses they're coming from because
the administrators can perform some high
privileged functions including
snapshotting of VMs now that is
something which is a very real thing if
you can snapshot a live workload then
you get the contents in memory so if the
key secret key is in memory then you
might get access to that data through
some snapshotting and these are
sometimes possible in these virtual
memory systems it's possible to avoid
those also so better cloud service
providers again have this in place so
long term resiliency of the encryption
system so this will cover a bit
so cryptography in general is something
which is an established science and
there is research which proves that
certain algorithms are safe and not it
takes years for any algorithm to be
considered safe and then things change
certain things become weak
so crypto is never implemented by
developers it's implemented by the
experts and developers use it that's the
way it should be so in the trends we
will see that there are certain
restricted forms of encryption which are
very powerful and offer important
functionalities such as having the
plaintext ordered in the same way as the
ciphertext so that you know we can have
wildcard matches on the data we can have
text search on the data and stuff like
that so enterprises need to consider
whether these secure these encryption
schemes are resilient in the long term
okay so as we talked about a bit the
important thing in cloud data security
is who is responsible now the cloud
service provider may be implementing all
the security policies and stuff that
they need to do but as a consumer of
that service we need to be aware of what
our responsibilities are so here is
something from the Amazon Web Services
overview of security processes it
clearly states that encryption of
sensitive data is generally a good
security practice and AWS encourages you
to encrypt your sensitive data why and
algorithm consistent with your
applicable security policy now when you
are faced with a statement like that a
bit of understanding of crypto becomes
necessary because what is your
applicable security policy in the first
place so what kind of encryption do you
have to use and so some of that
responsibility they are transferring to
you and they are providing all the
primitives for doing the encryption and
all but you need to use them in the
right way you need to choose the
algorithm and such choices have to be
explicitly done so and when there are
different levels of providers then there
is shared responsibility and we talked
about how the shared infrastructure like
having multi turn on storage multi
tenant networks sharing the same LAN can
have some kind of things and then these
things are the the cloud infrastructure
is
service providers usually have good
api's for doing all the admin functions
across the machines and they're very
easy to use so but they're very powerful
so it's important to make sure that
access to such API is is controlled and
you know a lot of harm can't result from
that
so now encryption can be done in
different layers so you can encrypt data
at the application layer so the higher
up you do the encryption the better it
is from the point of view of security
because the lower layers don't have
access to that data
now you can encrypt stuff at the
application layer itself it's actually
more work because all the stuff has to
be done there at the application level
if it's encrypt it could be encrypted of
the database level so like in Oracle we
have transparent data encryption where
the data is actually stored encrypted on
disk but when you do the if you have
access to the database you can still
query and get the data it's it
transparently decrypt the data and
provides it to you so the file system
could be encrypted the disk could be
encrypted so the encryption could happen
in different layers no higher level
encryption as we say it could protect
better but it's harder so the question
to ask here is who has the keys they
potentially have access so if you are
not using encryption at the application
layer you're not doing it at the
database layer and relying on the file
system so whoever is running the file
system can actually see your data so if
the disk is encrypted by the providers
and the provider can see disk content if
the file system is encrypted file system
provider can see the content so that
brings about a couple of questions is
server based encryption sufficient so
this is something which we talked about
at the start so in server based
encryption basically the server is doing
the encryption transparently so that
anyone from the client side who is
getting access to the server who can
breach the the application security is
actually able to get the decrypted data
the server may be storing it encrypted
but it's decrypting it also while
processing so is there any way to avoid
that so there are technologies which
have come up which are encryption
gateways so
we'll look at that next so the
encryption gateways on the enterprise
side can do the encryption from the
enterprise side itself and send the
encrypted data the server actually
unknowingly operates on the encrypted
data it returns back encrypted results
and the enterprise can or the encryption
gateway on the enterprise side again
decrypt the data that's the basic idea
and then the other aspect is how secure
are the encryption keys now the key
security of the encryption keys and how
they are managed is of course crucial as
we saw in the previous section so they
could be stored in hardware security
modules ideally so that brings us to
some of the recent trends in cloud data
security so we are going to talk about
hardware security modules and encryption
gateways and then finally we are going
to take a look at a research area which
is considered the holy grail of
secure multi-party communication so what
are hardware security modules hardware
security modules provides secure and
temporal at ample resistance storage for
high-value keys so as we saw in the
section on digital certificates the
private key of the root CA is basically
the ultimate trust anchor any compromise
of that key actually breaks the whole
chain of trust and any so anybody who
steals the private key of a CA can
actually you know generate any
certificates they want because they can
signed it or now so traditionally it was
used for these kind of internet security
places like certificate authorities or
even in DNS SEC at the top levels of the
DNS so now it is being considered for
more users in the cloud and actually AWS
is offering a cloud HSM service so these
devices are typically expensive but they
are becoming more and more common for
storage of keys now these devices make
it extremely difficult to steal the keys
from the device you you can't take the
key out of the device so all the crypto
operations happen inside the device and
if any physical attempt is made to
tamper with the keys or get them out
then there is some kind of response
which the HSM server which may include
self destruction of keys so in terms of
using them they are pretty simple to use
because you have often the HSM vendors
have a jce key store provider so you can
directly use it from java just as you
would use a java key store on the file
system now some of them don't have a
direct JC key store provider interface
but you can still use the pqcs eleven
providers there is a there are j'ni
interfaces available but still they can
still be reasonably easily used from
java now
just to emphasize the main idea of
hardware security modules is that the
key stays within the HSM so the secret
key basically so if you generate a key
pair for asymmetric key crypto you can
export the public key that of course has
to be public but the secret Keys stay
within the HSM then never get out of the
HSM now
if the so that makes it secure because
no in in various ways because all the
crypto operations are happening inside
the hardware so there is strict control
of where the keys and all use of the key
are being logged inside the device so we
have a clear idea of who is how the key
is being used so assigning encryption
decryption everything is happening
within the hardware so this is a
cryptographic black box so now it also
solves the problem of snapshotting of
live vm workloads and getting the key
from memory because the key is inside
the device it never goes out of the
device okay so now we move on to the
next area this is quite a new
development cloud encryption gateways so
here what happens is there is an
encryption gateway within the enterprise
network which is actually transparently
doing encryption and decryption of data
that is going to the cloud so you can
have SAS pass is whatever you are using
so whatever data is being sent to the
cloud service provider is actually
getting encrypted by the encryption
gateway on the enterprise side
it goes to the cloud service provider on
the way back it is decrypted and
provided back now this may sound
unintuitive because the server would be
dealing with encrypted data which as we
know is not the case servers always deal
with regular data not encrypted they
transparently decrypt that if there is
any update data on the server they need
to decrypt it and then process it all
queries text search queries database
queries all run on plaintext so but this
is how it works we will see how how that
falls in place so it's encrypted on the
way out and decrypted on the way back so
there is real-time crypto on every
operation so the enterprise owns the
encryption gateway where the secret key
is stored for the encryption the data
off which is getting stored in the cloud
service providers data stores is mangled
it's not actual data it's encrypted data
and you can configure these systems to
to encrypt specific fields not not
everything has to be encrypted and these
these are very specific to the the
backend system I mean the cloud system
that it is interacting with so if if
there is a Salesforce application to
which this kind of connection is being
made the various form fields which are
marked as sensitive would be encrypted
and it would go and it would get stored
in encrypted form in the database now
that wouldn't work right intuitively
because the that application is written
to work on plain text not on ciphertext
so how does that work so this encryption
is format preserving so it produces the
encrypted cipher text in the same format
as the plaintext so if you have provided
it an integer it's going to encrypt it
in such a way that the output is still
an integer if it is an address which is
a string it would be the string and it
would it would not only have the same
data
type it would have the same kind of
length also now that would of course
make the queries work and stuff but
there is actually more to it so there
could be business rules which are
operating on that data so if it's a
credit card number it's credit card
number is just not a 16 digit number
there is a specific meaning for many of
these fields so whether it's a Visa or
MasterCard which financial institution
it belongs to so the whole range of
values is not possible so this at the
time of format preserving encryption
these rules also are taken into account
such that the business rules are also
satisfied after the encryption even if
that is done there are things like wild
card matches and sort orders which won't
really work even if you are able to
preserve the format so now we come to
function preserving encryption and this
is something which is not proved to be
secure yet but it's still in use and
more it's not being proved to be
insecure either so the vendors claim
that it is secure so one of the
companies which are providing solutions
like this is cipher cloud so so we have
to support wildcard matches in short
order so if a wild card match has to be
supported or a sort order has to be
supported then the format preserved
encrypted data still has to be in the
same order as the plaintext which it
represents so so that the wildcard
matches and sort still continue to work
so it has to be an order preserving
encryption or more generally it should
preserve the whole functionality so you
are doing encryption the server is
unknowingly acting on encrypted data but
it's still preserving the function so
all the functionality is still possible
so now we come to the final topic which
is fully homomorphic encryption now this
is an active research area so the
difference from the previous thing that
we talked about of format and function
preserving encryption is that here we go
to this picture
here the server is actually knowingly
operating on encrypted data so the
service logic operates in ciphertext
space itself so here if you see the
picture to the right so the encryption
and decryption is happening only on the
client the server is written in such a
way that it actually does everything on
the encrypted text itself in ciphertext
space so that is what fully homomorphic
encryption is supposed to make possible
so the server is doing something but it
knows what it is doing in ciphertext
space so but it is not able to see what
the input is it's not able to determine
what the output is it's just doing the
computation so that might sound like a
very strange thing but this is the holy
grail of cryptography in the area of
secure multi-party communication so you
are able to offload computation securely
to someone they don't know what they are
getting they don't know what they are
outputting but they know what they're
doing and they carry out that
computation on your behalf so so the
thing is the encryption and decryption
happens only at the client end I'm using
the term client it can be any peer the
data is stored in encrypted form as send
by the client the server operates in the
ciphertext space itself so in the
previous case we were tricking the
server into believing that it is
plaintext but it is actually encrypted
text but here the server is doing
operations in ciphertext base itself so
researchers Stanford University and IBM
proved that such general operations are
theoretically possible it was proved a
few years ago but the catch is that it's
it's not at all practical right now it's
like really really slow and infeasible
but lot of advances have been made like
orders of magnitude are being shaved off
so even if this doesn't work in this
form itself there is a possibility that
you know because there is a compelling
need there is a possibility that
something or
either this or something similar would
be possible in the near future and that
would really solve a lot of these
problems and actually I saw a reference
to Google looking at multi-party secure
communication because if somebody uses
this then if government agency is asking
for data they just can't provide it it's
impossible to provide it because they
don't know what the data means they're
just doing the computation so so the
thing is it's not as as outlandish as it
may sound but you know even in RSA you
know it's exponentiation so particular
operations are possible in particular
algorithms so if you multiply two cipher
texts you are actually effectively
multiplying the plaintext because you
know when you multiply two things the
indexes add up and so the decrypted
thing would be the multiplication of
these so there are these have been
theoretical problems in cryptography but
now they are being revived
so to summarize cloud security and
others so there are many pieces so you
know what if solutions are emerging
there are breaches there is discomfort
we will take a time some time for people
to actually have the trust and hopefully
things will work out so there are some
of the references so the six security
issues are actually discussed in this
one the whatever is contained in the
garden node and that's it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>