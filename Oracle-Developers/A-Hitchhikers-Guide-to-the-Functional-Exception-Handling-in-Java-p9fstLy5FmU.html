<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>A Hitchhiker's Guide to the Functional Exception Handling in Java | Coder Coacher - Coaching Coders</title><meta content="A Hitchhiker's Guide to the Functional Exception Handling in Java - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>A Hitchhiker's Guide to the Functional Exception Handling in Java</b></h2><h5 class="post__date">2018-02-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/p9fstLy5FmU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay looks like it's time to start so my
name is Gregor dubov addict for you out
here it might be more pronounceable if
you skip those disease in my name then
becomes something like Gregor and I came
from Poland and I hope I'll be able to
not fail today because of the jetlag so
I'm a software engineer from Poland
during during the day I'm developing a
system for kusuma and Malta and I'm a
trainer in a bootlegger in Poland other
than this I create and writing this blog
at for comprehension calm and I do some
open source in in my free time well if
there's any so today we'll be talking
about the topic is functional exception
handling but actually we'll be talking
not only about exceptions but more about
I've driven development you will see why
so we'll touch exceptions start during
development and then a few practical
applications of the ideas in the world
of Java so basically actually it was
very long time ago over 15 years ago
people said started noticing that the
mechanism of exception pending the
mechanism in which the handing becomes
like an alternate path of execution path
can be deceiving and that it might cause
more problems than it solves if not
handled properly so people started
noticing that well
exceptions having seven handing creates
unexpected exit points from methods and
the way you handle it it behaves somehow
like a like a go-to so all those like
abrupt jumps from one place code to
another
pretty much looks like a go to other
than this those execution paths are
often not clearly visible in the source
code well it's very hard to judge which
way will route the path take and
sometimes when you go I think it's very
it's easy to like lose information about
exceptions and what's quite interesting
is that exceptions don't come for free
in Java there is one thing that makes
the instantiation of variable much more
Costigan's instantiation of any other
project do you have any idea what this
could be
there's one very interesting thing that
differentiates exceptions from ojos if
you look at the method filling stack
trace in the probable you will realize
that in order to instantiate an
exception actually we need to like make
run on the whole stack and collect all
frames which can be more costly than you
might think
if you need more information about that
what's going on there there's a very
cool right up by science couples cost of
causing exceptions but now I want you to
look about for results of experiments of
Norman Moyer if you don't know the guys
that met one of the main contributors of
the net deep framework it's a
high-performance Java and networking for
Java so well since they are doing is
quite extreme of the optimizations they
were experimenting to me some research
how the exception instantiation impacts
the performance so they were performing
benchmarks they started benchmarking
standard exception throwing and they
applied some optimizations the first
optimization was pretty much about
caching and exception and referral get
in the same
texts and the most extreme one included
creating stackless exceptions also
static instances of starquest exceptions
and throwing them when needed so and
here are the results
so this graph represents operations per
miss the community second and on the
left side you can see well there are
bars actually it's not like they are not
there they are just very small so on the
left side you have a situation where
standards creation of exception was
applied and on the right hand side you
have situation where statuses exceptions
were thrown so as you can see the impact
but for performance impact is quite
substantial however you should not worry
that much about that say it's a good to
remember about that but if you are
throwing so many exceptions that it's
causing a huge performance impact of
your application don't probably you have
other problems to worry about
so other languages approach exception
handling in their own ways for example
we go treats exceptions as any other
value there's nothing special about
exceptions in go what's interesting is
that go has those this very nice feature
that allows you to return to values more
than one value from a function so for
example if we define a simple function
called for that accepts a string it
returns our return value that we are
interested in but also an error and
what's cool about that there is no
abrupt jumps to other parts of the code
it's just a error that's a return value
here so whenever you want to check if
there is something happened or not you
simply perform and all track well you
probably expected something more
spectacular here
rather than a simple no check which is
quite well not now our favourites
construct but it's worth appreciating
how easy it is how much simplifications
they got by applying this approach
whenever you get an error there is no
alternate execution path you just have
another return value that you can check
if it exists or not handle ends up as
simple as it is
however sometimes in our code we have
situations which are well truly
exceptional so obviously it go has a
special dedicated mechanism for that but
there is a difference between written
returning errors from methods and Aniki
we panic when there is absolute you know
when we don't expect users to recover
from that when someone starts to panic
it's it's gum okay application is that
we need to we need external help to do
something with that well actually you
can kind of even recover from a panic
using the third methods but you
shouldn't but meanwhile in Java the
exception handling causes many people
start identifying that practices too
related to that and now it's not the
point
I want me just going for all them
explaining what they means because some
actually made sense in certain context
but the idea is that the whole exception
handling sparked a lot of bad practices
well at least controversial practices
and now
let's remember that we are actually in
this world of static typing well since
we are in the Oracle Java conference so
I hope I don't need to convince you to
go well for them to convince you that
static typing has its benefits but let's
recall some of them because actually in
order to benefit from them we need to
invest into this so obviously the main
difference between static and dynamic
typing is that in static typing we have
the abstraction of types and in dynamic
well not really but what's quite
interesting is that I noticed that
recently in the community for example
Uncle Bob present in wrote on his blog
he criticized Kotlin and Swift for being
heavily statically typed and the
criticism was is that stuff types do not
really help a lot but you should use
tests instead to provide the same of
like integrity tracks that type provide
you well but how often do you run your
tests if you have them and how long do
they run because if I run tests and they
run for more than 10 seconds I'm on
Facebook already and if you have static
typing and you elaborate the power of
types in this context you get basically
an well instant feedback and this is a
very very important because if you
remember agile that basic principles of
agile is benefiting from leveraging
short feedback cycles so we are
forgetting about waterfall when there
was one feedback cycle after two years
you start project you develop you go to
a client client sees this and says well
that's totally not what I wanted so the
idea was to shorten feedback cycles as
much as possible and by her leveraging
static typing we have those very
shortened backside
almost well almost instantly almost
immediately but as I mentioned you need
to invest in static typing and it
requires some effort so we are quite
often you can quite often see constructs
like this where everything is Rusted
represented for example using strings
you know because if you have no word of
that wealth was up in JavaScript you can
benefit from dynamic typing very easily
because you don't dry it types and you
your benefits immediate but if you are
here you need to invest into that and
this starts to give some value over time
so instead of writing strangely type
code in a strongly typed language we can
add some more semantic meaning to our
types by well creating them like
sculpting them and now what we have well
additional security prodded by types we
can benefit from that because compiler
will save us from many situations that
we we will never never think of and
what's quite interesting is that
actually Java started realizing well
since Java 8 there has been more
emphasis on type development because for
example with Java we a Java developer
starting noticing that optionality can
be expressed using wall pipes and not
not news by the way have you seen
today's keynote by Venkata
have you seen ok because this is a very
good follow-up because some of those
tools that I will be showing to you
might feel unfamiliar but in long term
we will prove to be well quite simple so
if we can express optionality using
types why not apply the same concept
to exception handling we aired out we
can and that other languages are doing
this so just a short disclaimer in Java
world if you want to work with life
additional functional abstractions you
have basically two choices the FF waiver
and Cyclops and in this talk I'll be
focusing on waiver because it resembles
Marcos syntax that's found in Scala so
for example well we we could encapsulate
optionality so now let's try to
encapsulate well operations that can
throw exceptions so for example Scala
has a dedicated type called tribe and
this time in optionals who were putting
with some value inside and this value
could be either present or absent and in
try we are encapsulating basically an
action that my for exception or might
not so how does it look like from the
practical side of things let's imagine
that we have a method called get search
results and there is one parameter well
what we are searching for
there's obviously declaration of an IO
extra exception being thrown and the
return tab which is a list of URLs so if
you were to leverage I've driven
development and try in this case we
would get rid of the frost declaration
and encapsulate our result in a try try
object and now we can leverage the
functional API functional declarative
API for processing than this value so if
you are familiar with Java 8 well you
should be because we are now on Java 8
and Java 10 is being released in a week
from now you can you can leverage very
similar syntax that's this present in
optionals streams and comfortable
futures in in Java so we are replacing
standard try caches with functional API
we leveraging methods like map filter
plus other exception dedicated methods
that can be used in this particular
context so as you can see here we are
leveraging declarative programming so we
are no longer trying to manually catch
exception reflow it
apply some if-else and so on but instead
we are decoratively specifying what
needs to be done what we would like to
do with this value if that if it had if
it was computed properly so we can use
map filter and so on and at the end of
the whole functional processing chain we
can specify what to do if actually the
exception was from somewhere on the way
so if you go for the whole API you will
see a lot of a lot of methods well some
with quite scary signatures but if you
play with it
for a while it becomes very intuitive
because at the end of the day it's a
declarative programming you are not
writing how to do I mean you're not
writing how to do stuff you are writing
what to do and but for like many years
Java was very strict or P and we kind of
got used to the different way of writing
stuff that's that's very obvious for
people coming from the functional
programming background so I promise you
that if you advocate a little bit of
time into getting familiar with that
you'll be you'll be able to highly
benefit from learning the functional
decorative approach to do stuff so this
is basically just a list of ApS but
let's have a look at the actual examples
how it looks like in practice so for
example imagine that we want to
implement our method to get search
results and our flow would be like this
firstly we'll be trying to get our
results from Google and if we can't get
results from Google let's try get
results from dr. go and as you can see
those two methods are implemented in a
slightly different way because as you
can see get from Google is flowing two
exceptions in throwing IO exception and
no such element exception and the second
one is throwing only IO exception so
let's have a look now at the
implementation from the producers side
so what's happening over there so if you
if you look at the line with with return
I'm afraid I hope you can see that green
dot over there so first thing what we
are doing here we are encapsulating our
operation that might throw or might not
throw an exception so we have a
dedicated try off method for that we
obviously passing this as a lambda
expression because we want to pass in
actual action and not a value because if
we try to pass a value it's after it's
computed either section might have been
wrong so we are passing an action that
will be evaluated nicely by try itself
the cool part about that is that we
don't need to manage all of this by
ourselves where the eye API that's
exposed by trial managers it for us so
now we can leverage a few dedicated
methods but from try like recover so
recover is a very interesting method
that allows us to well recover from
certain type of exception so in the
first case when you are trying to get
something from Google let's see
you can see that they apply that they
are instead of returning an empty list
if there's no result they are throwing
an exception well that's unfortunate
because it's quite uncomfortable to
handle so in this case we can simply use
recover and tell that if you encounter
no such element exception then well pass
it empty list further additionally by
inspecting the source code we notice
that there may be a runtime exception
being from and they say forbidden
exception and any kind of the same but
if still something went wrong along the
way we declaratively specify or else so
try to get the result from Google if
exception was thrown written as further
an empty list stay here
but if still something was well
something went wrong here
try fallback to get from Doctor go
so that might look pretty scary but
after some time it becomes very very
easy to use that both from the producer
side and consumer side so actually let's
have a look how it looks like from
consumer side but first let's think
about one very important corner case
sometimes we might end up situations
where somewhere there in the whole
execution chain it would be easier to
see it here if our method returns
another another try
so in such cases sometimes when I end up
in a pretty ugly situation where we have
try from try from try out of something
else so you might think that this is
situation where we are super safe at the
end of the day are put in trying to try
to try okay so you have three layers of
safety but it couldn't be further from
the
true because it's very hard to handle
because into constantly unpack stuff and
very cumbersome so remember as a that if
you ever encounter pretty much like
nested nested tries that's it optional
nested streams probably you're missing a
flat map somewhere so that's the short
thing to remember about what also super
cool is that if you are if you are
working with well in typical functional
programming languages you can more often
you can leverage button magic
whoever also provides such such thing
but probably you won't need to use that
anymore because fortunately it's coming
to Java although I think it's not
targeting Java 10 so will but probably
Java 11 that will be in September so
very interesting but probably won't be
we want me to use that anymore since we
have this natively in in Java so there's
there's a try but sometimes there are
situations were exceptions are kind of
abused and not really used and we could
actually see this example over there
when the our method get from Google was
returning no such element exception when
simply signifying that there are no
results so for example if we have a look
at spring reporters or many native java
api so you see that you have methods
like find one or some parsers that froze
that throw exceptions when well for
example it doesn't find something or
when it can't parse something
but still there's not that much it kind
of enforces consumers of those api's to
handle it in a spec certain way which is
not cool because it could be done much
in a much more elastic way well so we
learned that something like try exists
we could rewrite this using try but
still if some element is not found well
we don't get we don't get that much
information from leveraging a tool
that's dedicated for like more advanced
more fine-grained exception handling so
whenever you are dealing with absence
modeling it might be beneficial to think
and instead of throwing exceptions or
loosing tries simply turn an optional
because at the end of the day if you if
you if you if you are looking for an
element and you don't find it well you
either cateresa or don't you obviously
could get some additional information if
an exception was from but it probably
wouldn't reduce that much entropy in
this case same with our sirs many of
them actually when the exception gets
wrong they don't provide any special any
meaningful info that in such case you
can also replace it easily with
optionals and actually if you have a
look at github or and do a very very
simple and very naive search you can see
that well there are this pattern is
abused the abused a lot but you can work
much easier if you actually not impose
on your country on consumers of your API
certain ways of dealing with will do
this particular problem so we try to try
and option so far but as you can see tri
is still kind of encapsulating exception
handling that we have already in Java
but what if we wanted to try to emulate
the exception well the way that go
handles exceptions well we could
leverage tuples for that and instead of
returning one result returned the tuple
which could contain the person and our
custom error object which is not a
variable and where you don't pay which
is anywhere you don't pay the cost of
association and exception but the
problem is that that tuples they are
kind they work fine if you if you are
working with non durable values so if
you try to simulate this go fill in Java
using tuples
well it's not very handy to use because
you end up with two objects instead of
one so since we know we can solve
problems with types and encapsulation
why not try to do the same in this
particular scenario and actually
functional languages are doing this for
quite a long amount of time so for
example you have the concept of either
and this is a type that in capsid that
can hold inside one of two one of two
elements of two arbitrary types which
can be very handy for such situations so
if you think about either it's very
generic so it can be used for exception
handling but doesn't need to be this is
also why the API will be a little bit
less rich than in
example of try but thankful for that you
can use it for many different scenarios
and we'll have a look at them right now
so the very important thing now since if
you know that either is is very generic
it has interests two sides left and
right so either exposed still map filter
api's and so on so now here comes an
important question
what happens if you create for example a
left or right either and call a map
method or filter so which of those two
types will be treated as default because
if you work with optionals you have two
situations you have either it's present
or not present and optional is biased
towards presence so if you call a map
and the value is inside the function
paths the maps to a map function map
method will be performed on the
underlying value but if we pass a
function through a map method to an
empty optional nothing will happen
same with tries if the operation was
successful the map operation will what
we passed the map function will be
performed if there was an exception it
won't be but here there is no bias by
default some languages introduce that
but by default conceptually there is no
bias the left and right sides are equal
so when working with others we can
actually dynamically well specify which
side we are working on right now and
this is why the where the concept of
projections jump into this though those
two so basically whenever you work with
either you still leverage the same API
Maps filters flat maps as with optional
streams tries and so on
but before you start working with that
you should leverage one of projections
either right or or left and if you call
the left projection the call either will
behave like its left biased if you call
the right projection everything will
behave like it's right by us so now it's
all up to us how we use it other than
this you will be able to find very many
and generic api's but probably when you
are using either you probably want to
use projections first so now if you are
working with either we need to work with
custom error objects so for example if
you are working with Scala you can do
that using only one one line create a
case class that contains a message and
in this case
HTTP response code okay it's a simple
one-liner but today we are talking about
Java so unfortunately we need to write
much more code to achieve this the same
result oh god actually this is this is
44 discussed case classes that could fit
in there but in Java I'm not sure this
is Java 10 or 11 but the concept of data
classes is coming so my jokes about Java
verbosity won't be valid anymore and
we'll be able to do this using only as a
single line so it won't be that scary
and now let's come back to our example
from the beginning and let's try to
approach the eat using either and not
not exceptions so we are starting as
with the try as our entry point here but
we don't want to will encapsulate
exceptions button to return errors our
own errors
so that nothing gets from along the way
so again instead we are going to change
the type since we had a generic try that
could fend well that could called an
exception type but here we have an
either that has either a phat error or
our result that we are looking for and
now whenever we are working with either
we have we can leverage projections so
we call the method
we get our result here and now whenever
we are interested in this part we start
with the projection then we do with it
whatever we want with everything the
same declarative API that optionals and
streams have and then if something wrong
happened on the way will we specify the
default but then whenever we want to
handle exceptions well the error that
was returned over there going to create
another projection and then process it
as we wish
obviously now none of those will be
performed if if this result turns out to
be if we make a right projection and the
result is left and same here if the
actual result is right and we are
looking we are doing west projection
none of the house will so what's also
quite interesting is that well either
doesn't need to be used for exceptions
so imagine for example some internal
method that is querying a DNS server so
for example internal and how does it
work if DNS doesn't contain certain in
for the whole information it pings
another DNS server in E and if this one
doesn't have everything it pings another
one so we could model such situation
using an either as well so for example
as you can see there is no exception
handling involved here at all but we are
using either for representing well
alternate alternate paths
so whenever we try to resolve certain
like URL we either get address of
another DNS server or the resolved URL
and it turns out that for example we in
Scala we can find those usages in many
interesting spots the one this is the
one that's most interesting and this is
actually what venkat was showing today
when he was implementing his tail
recursive method so it turns out the
sky's doing put them out the same but
using pattern matching and either so as
you can see those this can be applied in
many different interesting scenarios so
here comes the major question let's say
that you decide to use that obviously
this is this is not a silver bullet it
won't work for everything you need to
try it out and see if this works for you
because obviously the problem with
static typing and statically typed
language is something that sometimes
they introduce way too much bureaucracy
but let's say that you want to try doing
that well you can internet this by
yourself probably you want you won't
like to do that we needed to do that
some time ago when some libraries were
not out you can use one of those two
libraries I mentioned a few minutes ago
but probably you should start with
waiver dot IO which is very similar to
Scala and it's not a small library it's
already very well tested and even like
libraries frameworks like spring are
recognizing it and introducing
integrations for waiver but other than
automatically you can try to be apart
try to become well more active in the
community and become the part of the
Java community process
because you can influence what's
happening in Java for example Java you
to time or project lambda well were
pulled into the Java after some
community voting so if you want well you
can already see the drop is adopting a
lot of functional programming ideas so
here's your turn to do something so
let's have a look at this key takeaways
of today's talk exceptions well we were
criticizing exceptions a bit but they
were quite fine they are not often the
performance problem and but they work
best when you when you don't use them
for control flow but when you use them
for signalizing situations that are
truly exceptional and you don't expect
people to recover from them each time
whenever you try to write when you
whenever you are tempted to write a
frost cloth in your method signature you
did can be replaced using try which
pretty much exists only for like the
world of capsule anything existing
exception handling in Java whenever you
are emptied to throw a no such element
exception
you should probably reconsider using an
option instead because there is no
reason often not reason to impulse
well the certain way of handling absence
for your use for users of your API and
ultimately you can use either that can
be used for advanced scenarios involving
custom error object and metallic
alternative paths from my experience
it's quite hard to adopt either idea in
Java because we are leveraging external
libraries that use exceptions
sometimes unavoidable and creating
custom facades and encapsulating
everything into either x' again it would
be very cumbersome and a lot of effort
so it's quite hard to do this but the
try approach can be implemented very
easily is it a problem so probably you
might want to you will probably want to
try try India like everyday work with
either is good to know about this idea
about the concept but it's very hard to
do this in the in Java also let's also
remember about waiver that's becoming
any guava waiver is not only try option
and either it's the whole is the whole
library fully as many fun good
functional ideas as it came from Scala
so you have new functional interfaces on
steroids we have also a new redesigned
from scratch called fully persistent and
immutable collections API which is which
is super good so definitely have a look
at this one and that would be all for
now
I hope I hope I sparked some new ideas
in your minds so thank you very much and
I hope you are tempted to try one of
those approaches at work thank you
and we have five minutes questions time
yes
can you can you speak up
can you speak louder I mean at the
beginning you need this one okay
so basically all of those and they can
be considered antipatterns or not
depending on the context but the point
is that many people found many practices
controversial in different scenarios and
it's exception handling is not the baton
job but I spent a lot of time in
functional programming languages and I
really appreciate the freedom that and
security that static typing gives us yes
- those one dust I would say Google
mostly
okay thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>