<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Turning the JVM into a Polyglot VM with Graal | Coder Coacher - Coaching Coders</title><meta content="Turning the JVM into a Polyglot VM with Graal - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Developers/">Oracle Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Turning the JVM into a Polyglot VM with Graal</b></h2><h5 class="post__date">2017-08-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/TQMKPRc6cbE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I research programming languages and
broad reasons I love programming
languages as a researcher is you can
talk to anyone in computing about
programming languages because everyone
uses programming languages so everyone
has their own opinions on programming
languages throwing things they need from
programming languages and then things
which don't work for them or do work for
them that's not true for all areas of
research and as you speak to some
researchers and you can't even begin to
understand what they do I find it great
because I can talk to to all programmers
and get ideas for them but why there's
so many different programming languages
why do we need anything more than one
programming language or perhaps a couple
of programming languages
why isn't there just one ultimate
programming language that we can make
really really good and really really
fast and could do everything we need it
it's probably not a realistic question
to ask because if we try asking this
question on Stack Overflow though
closure is not constructive so perhaps
it's not gonna lots of questions to ask
in the first place and if you ask why
can't we have one language you'll find
that everyone thinks their language
could be the language to support every
use case it's probably the case that
these people haven't worked in all kind
of areas so they don't know what other
kind of things people need from their
program languages so it's probably not
realistic to aspire to create one new
program language which does everything
that everyone needs all the time but
part of the form of this is that the
implementation of quality of all the
different languages we have vary so much
because we have so many because
apparently we need so many this is some
benchmarks for many different
programming languages it's not any
particular benchmark it's a sort of
aggregate of benchmarks you get from a
website called the computer language
benchmarks game obviously there's a huge
spectrum of performance across these
different languages so a language like C
right on the the left-hand side all the
way across to a language like R on the
right hand side this graph is actually
logarithmic so R isn't just a few times
slower than a language like C it's
actually getting up towards B a thousand
times slower than language like C and
the problem is if people have good
reasons for wanting to use these
languages they'd like them to be fast
and they'd like to be able to be capable
of running the kind of work
loads and be capable of scaling as
they'd like but because there's so many
of them with such a wide variety of
performance that's problematic what we'd
like to achieve in Oracle labs to
support developers is to be able to get
all these programming languages and
people want to use and get them down to
a similar sort of level of performance
as Java has and this means that people
are there and free to choose the
language they want to do the tasks they
want consciously language they know
passive language which is best for some
of reason particular tasks and to get
that high performance out of it and that
means then we don't have to debate with
people anymore which language they
should be using we don't have to tell
people well if you use this language I
said it would scale better if people
think they've got a good reason for
using a language we would like to enable
them to do that and to make it fast no
matter the reason why this isn't the
case is because implementing a language
is a really really complicated bit of
Engineering I'm going to talk about some
language implementation concepts and
this talk some of them are quite
technical but you can just take away the
kind of complexity of what we're doing
usually languages come out of a need so
someone finds they need some need to do
something so javascript is created out
of the need to script websites other
languages creating out of their own
particular niche needs and what people
generally do is they prototype a simple
implementation of the language they
represent your program is a tree data
structure we call that an abstract
syntax tree and they execute that tree
by walking around doing a kind of
visitor pattern on it and then over time
if the language is popular and people
liked it and people want to use it then
people may start inference a sort of
real virtual machine and they might use
a language like C or C++ to get people
performance out of the implementation
and they spend a lot of time influencing
things like runtime systems and garbage
collectors things like that a good
example is a language like go people
created it saw a need for something else
but they have to spend a lot of time
writing all their own systems all their
own libraries or their own runtime
systems our own GC to get out to a
certain level and then people start to
use that language which is great the
people still complain about the
performance of it so you may do
something like definer a bytecode format
like the JVM has has
a bytecode format and write a bytecode
interpreter performance is still bad to
people right edge it's like hotspot has
to make it faster and formula is going
from this point here we have a great
idea for a language that's fine that
people have great ideas languages we
just do what they want to do and do it
well getting all the way down to here is
decades of time and it's probably
hundreds of millions of dollars worth of
costs to do something like that
very few languages get down to this sort
of level down here so a language like
JavaScript took a long time it took a
huge amount of money from a company like
Google to get it down to that
performance the same sort of thing for
Java and if we want to have a system
which encourages this kind of polyglot
use whichever languages best for your
particular needs or which whichever
language you've used in from the system
already then we can't give people that
performance for all those different
languages the big idea we have in Oracle
Labs is the idea that you should be able
to prototype a new programming language
in Java or a new implementation of an
existing language that people want to
use and they should be able to do just
the first step it supposed to write a
prototype for the language in the
language like Java and they should
produce a simple technique such as
representative program is a tree and
interpret the tree and then it should be
already be as fast as this bottom step
down here and to get a JIT compiler for
free and to get that that's super high
performance for free and this is the the
growl vm concept we sometimes call this
the one vm through all the art them all
the idea can have a single virtual
machine which runs all your languages
and runs with high performance the
current problem with polyglot is that
even when that work is being done to
make those implementations fast they're
all running on separate virtual machines
so a set of language you might want to
use together such as Java JavaScript
Ruby and the language like are they've
all got their own virtual machines
implemented in different ways and
they've all got their own
implementations of languages sitting on
top of those virtual machines and if you
want to communicate between the
different languages that you need to go
outside the VM and come back in the
other one so you may reuse something
like a pipe an old-style UNIX pipe or
you may use something like a rest
interface but whatever you do you
be yours want to communicate from
something like Java to someone like our
you're gonna leave the the Java VM and
come back in the r1 over some sort of
socket some sort of handle some sort of
rest interface and that means
serializing things means converting
complicated data structures to something
that can go a long wire lots of these
languages have systems to help with that
but it's never going to be as easy as
simply using the data difference from
the same language now the JVM does
already make this better
I'm specifically picks languages here
that all have an implementation works on
the JVM
so of course job works on the JVM
there's implementation or there's
multiple invitations of Java scripts
that work on a JVM for Ruby there's
JRuby for all those languages like
there's impressions like Brendan but
these all have implementations that sit
on the JVM and that means the data can
stay inside the Jade inside the the JVM
when it's sent around so we can reduce
leaving the VM to stay with VM bar being
copied around but we've still got these
different implementations and that means
this process isn't perfect in leaving
one implementation and going into
another implementation is like a cost
they're still what we'd like to do is to
take it to the next level and to have
all these implementations implemented in
a common way and have a common wave and
written languages so a common way they
can communicate and work together and
have them all in the same VM and that
way we hope to remove the costs of doing
polyglot so that people can who want to
do it can do it and can use multiple
languages together without being
penalized for wanting to do that we
think that'll move towards a more
polyglot style of programming which we
think would make people more productive
because if people want to use different
languages they've usually got a good
reason in this talk I talked
specifically more about JavaScript and
Ruby because those are the two languages
I work with most and I I know the most
but the idea works for for many
different languages so grow vm is these
implementations these languages done on
a modified JVM I'll talk more about as I
quote grow VMI's is later but this is
what probably looks like on the Grove
the air
so this is some Ruby code and we have an
API here called truffle intro I'll
explain what's awful is as well later on
we have a simple interface here which
allows you to evaluate written in a
particular language using its mime type
so we could say eval application
JavaScript and give it some source code
we can import values that have been
exported and we can export values for
another language and bought them to
export them so we have a simple
interface here it allows you to eval one
language from another that sounds like
quite a high level interface but I'll
show you the power you can get with this
we allow you to take languages from one
language and use them in another
language using just this simple API and
in JavaScript the API looks the same so
we have Interop eval another language
and its source code and you can import
values and you can export values so all
the languages on the growl of the end
implement this kind of API which sticks
the same for any language on the graph
VM you can execute code written in
another language that also is running on
the JVM and you can just pass the the
text across so when we write something
like this in Ruby we can write in drop
eval application JavaScript and we can
give it a little string of JavaScript
code and that will return the the value
16 so what we have here is we have some
JavaScript in our program and we have
some Ruby in our program and we can take
the value that comes out of JavaScript
and we can use it in Ruby if we scale
this up to defining something more than
just a single little expression we
actually want to define functions in one
language to use them for another they
sorts become a little bit more unwieldy
so if we say I want to eval in something
in JavaScript from Ruby I want to define
an add function that I export that add
function then I import it from Ruby and
then I call it and that's something
which works we can get the we can
perform that computation and the idea is
here that say you have some function
written in JavaScript that maybe is this
currently your front-end and you'd like
to using your back-end written in Ruby
you can put across the code like this so
again we have
something that is in JavaScript and then
something that isn't in Ruby but the
JavaScript here is almost like a
second-class citizen isn't it as being
part of a string rather than being
something that is the same level as the
Ruby if we break the JavaScript in a
separate file and then Eve out the file
then maybe we can make it so it looks
sort of first-class as well we'd like to
do things at a final level of
granularity than this some IDs help you
with this with zombie you can tell
IntelliJ to look for this pattern and to
say syntax highlight the code in there
actually as if it was JavaScript this
sort of string still needs to be escaped
and things like that so the next level
we might like to go to is to say let's
simply let you write a function
declaration from JavaScript to be in
Ruby we're lucky that the Ruby and
JavaScript syntax grammars don't clash
very much so we can we can add a new
rule that says if someone writes this
function add in Ruby then actually let's
start interpreting that as JavaScript
rather than interpreting it as Ruby and
this allows us to instead of writing in
a string simply write the source code
naturally out so we have literally one
filed admin javascript and has the Ruby
they exist on the same level one is more
important than the other though Ruby in
this case is the sort of outer language
but we could have the outer language
being any other if we wanted to and at
this point you can literally copy and
paste this code around you don't have to
convert it into a string for sticking
inside of string this doesn't just work
for primitive values that last example
returned a sort of simple number which
is sort of the simplest thing we could
do so it makes it look like it's too
simple so if we do a an object as well
if we have a JavaScript function which
is a way of declaring objects of course
in JavaScript a sort of point of an XY
value we have a JavaScript function
which creates a random set of points we
call that from Ruby then we get these
JavaScript objects and I'm accessing
them using the Ruby syntax for accessing
a field and with that goes in and gets
that data out of that JavaScript object
so before in systems which try and do
this sort of thing we could have the
data shared between the two languages
what we're doing here is also sharing
the code in the same file and keeping
every millisecond top-level again what
we have here is we have the Java scripts
and we have the Ruby working together
now this sort of thing has been possible
for it hasn't been possible to do the
kind of having a language on the same
level but showing the data has been
possible between different systems and
for there's an API in Java for doing
scripting Ruby as an API for accessing
Ruby and evaluating different Ruby
strings the difference is performance
and this is what having all these
languages in the same virtual machine
having the same system to implement all
these languages this is what makes a
difference normally you won't want to do
the examples we've shown there because
of going from one language to another
has that cost and I'll show examples of
that cost later on but it's expensive to
do so let's take an example of some real
Ruby code this is part of a image
processing library from Ruby as people
are processing PNG files in this case
and converting the color spaces and
things like that so we have a clamp
function which takes a number a minimum
the maximum and puts the the number
between the minimum maximum returns the
middle value does it by creating a
variance sorting it let me have some
logics and for converting CMYK the color
space to RGB and then I've written a
benchmark where I've created random a
random color and called that CMYK and
the Ruby stuff does lots of lots of
logic and writing the inner loop so it's
a loop here that's the benchmark and
within that we loop over all the the
color channels we then call this clamp
too to keep a value in the sort of
bitrate
this benchmark notation is just
something I invented myself so is
something saying here's a loop and this
is what I want a benchmark and I've used
random inputs here to stop the whole
thing being just optimized away because
the sophisticated gypped sprawl beings
very good at that now the first thing to
notice is the performance of grow a VM
from running just that Ruby code versus
other implementations of Ruby so we've
been trusting how many times you can run
that clamp operation per second I've got
the the rubric rotation that's part of
gravy em I've got JRuby which is another
implementation of Ruby on the JVM uses
excuse me uses in both dynamic magnin
instruction they added two support to
nanan languages and we have the standard
implementation Ruby which I've called
just Ruby so that's an implementation
written in C let's bring around coral a
while so this is what grow VN gives you
for Ruby before we even start talking
about JavaScript so room is Ronnie's
language app which has got popular
they've added more more than a part of a
VM but am be nice to have the time or
the money to go all the way to the sort
of level but Google does with v8 or or
who does with hotspot so the performance
of Ruby is quite limited but our
implementation Ruby running on the
gravity M using our technology using
just Ruby to start with is far higher
than other implementations of Ruby we
have a small team who have implemented
Ruby we've managed to get to that level
of performance beyond what JRuby and the
standard memorization Ruby a be able to
do because this technology allows you to
just prototype the language and have it
be fast but what are more interested
here is rather than just that raw
performance is what polyglot does to the
performance so I've said Ruby access
interface for being able to eval
JavaScript from Ruby people use it to do
things like run CoffeeScript to process
CSS files and stuff like that as part of
their their web application build so
what here is we can we can create a v8
interpreter called a v8 context
now you can eval some code written in in
JavaScript what I've done here is I've
rewritten that clamp routine that
function is called right in the middle
of the whole benchmark to be in
JavaScript so between a number a number
gets returned between a minimum maximum
here have used the more simple sort of
disk if case to do that
and I'm calling that function and
calling the JavaScript instead of
calling the Ruby not only written the
job rewritten the JavaScript written
that function in JavaScript also made it
a bit simpler so instead of creating an
array creating an object and sorting it
which is another object I've used the
more sort of simple straightforward way
of doing it if we compare the
performance of Ruby combined with
JavaScript so the performance of Ruby
just Ruby and the performance of Ruby
combined with JavaScript using v8 the
performance is much lower so remember we
already said that the standardization of
Ruby was slow and then if we use the
standard rotation of Ruby with v8 it's
even slower so you're paying a huge cost
to using polyglot so maybe we decide
that we've already got this function
written in JavaScript let's reuse that
that's the cost of doing that and that's
the fundamental thing which makes
polyglots limited and hard to do is that
that performance is low we've got
multiple invitations of JavaScript we've
got an implementation of Ruby on the JVM
so perhaps the JVM the normal
conventional JVM solves this problem
this invitation of JavaScript called
RINO that works on the JVM so we can
create a rhino context in exactly the
same way it's created a v8 context and
the the JVM translation of Ruby using
invoke dynamic with just Ruby again
there's issues performance cliff
comparing that to the version of Ruby
that's using JavaScript via Rhino as
well as Ruby so even when these
languages on the set on the JVM so on
the same VM we've got different stations
languages but they're both on the JVM
we still get this performance cliff so
the the idea of polygons on JVM Searle
has this fundamental limitation of
performance because these languages are
imprinted in in different ways
Nats horn is a new implementation of
JavaScript's new in Java 8 on the JVM
and again we can create a context for it
the same way we can eval the string in
the same way and that's one does a bit
better because of its a slightly more
modern implementation in JavaScript do
we still have this cliff going between
the two so in our implementation of
JavaScript and Ruby we have this this
benefit compared to the other
implementations that we can simply write
them in the same file so we have clamp
going between maximum but I've written
it without any kind of string around it
and now I'm simply calling it directly
as if it was a Ruby function we've lost
the sort of I'd have a bit of extra
logic there because it was an object
that came from the separate context in
the previous examples this now looks
much more natural so it's a benefit
there but the real benefit on the the
Grove VM is that there's no performance
difference between running just Ruby on
the JVM to running Ruby with JavaScript
on the JVM so there's a tiny tile like
one pixel difference there but there's a
narrow bar I haven't shown for
simplicity and really it's almost
exactly the same performance and a few
more slides I'll show you these actually
precisely the same performance and
that's compared to this huge cliff you
get to running just the Ruby with just
on JRuby so without the JavaScript
performance cliff which is tiny down
here if I showed it
what compared just implementation in
Ruby so there's no performance penalty
to using polygons in this situation and
that's something which we haven't had
before even waving these multiple
languages on top of the JVM systems
going the next level of polygons VM so
if I put all those implementations of
Ruby together I'm saying going all the
way from gravia and running just ruby or
running with JavaScript and same
performs all way down to running Ruby
with v8 the difference is so huge I'm
going to make this scale logarithmic
here so each one of these steps here is
ten times slower as you go down so you
can see how much slower it is to use
something like JavaScript and this is
interesting because we said the v8 was
one of these
premium implementations of languages and
use lots of technology and use lots of
money to get there but it's the jumping
between the implementations where the
cost is the even if both are really
really well optimized combined them
doesn't give you a really well optimized
implementation it's only when they work
together so let's talk about how growl
achieves this so there are already lots
of invitations languages on the JVM I've
said there's there's JRuby which is
invitation Ruby there's jython
which is like Python there's render
minimization of are these
implementations work by missing JVM
bytecode and when they said in the
original description of the JVM that it
could be used for multiple languages
because that's something they said right
from the start that's how they said it
would work because they can always
language can emit bytecode and they
could all work together that way the
problem is that the JVM is a bit of a
black box even if you're a research
expert in virtual machines hotspot is
still a black box and very few people
have the experience to work on it and
all these languages can do the target
and JVM same thing they can do is poor
bytecode in for the top of it so it's
great they could all omit bytecode but
anything they can do when they've admit
to that bytecode is poured into the JVM
now the idea is that somewhere within
hotspot there's a just-in-time compiler
a JIT which turns your Java bytecode or
Java program or your ruby program into
high-performance machine code but the
path to that yet it's quite torturous
and often if you speak to the developers
of languages like Jerry B they'll tell
you that they don't know why something
hasn't been compiled as they wanted they
can't figure it out some of the stuff
doesn't even get compiled at all they
can't figure out what are they not
hitting some cash threshold limits and
like that so all I can do is pour in and
hope for the best
the central idea of growl and what
started the growl vm is the idea let's
take that JIT compiler out of the black
box and make it invisible
so in moment the only interface to the
JIT is to pour bytecode in we've taken
the JIT and we rewritten it into Java
and this means that it's a we can use it
as a library like any other Java library
and instead of having one interface
which is bytecode in machine code out
let's have lots of interfaces let's have
lots of things you
control precisely to control exactly
what's being done with your program but
growley is complicated to use
it's a compiler it's very very
sophisticated so we've written something
else could truffle which is why you saw
the name truffle from earlier and the
idea is truffled talks to grab on your
behalf and truffle is a framework for
envisioning languages i said that the
simplest way to written language was to
write a tree data structure of your
program and then to walk it to execute
it truffle and allows you to do that
helps you to write a Java program which
does that without having to know much
more and the idea is someone who's sort
of undergraduate working in a languages
class could understand how to write one
of these languages and then get all the
way down that stack we talked about the
VM implementation techniques and get
that far to implementation which works
in this polyglot world slightly
confusing terminology here just to
clarify growl is the new JIT compiler
for the JVM growl VM is the JVM with
growl and that truffle framework and all
our languages bundled into it you get
one package that's everything that runs
all these languages in a poly good way
and truffle is this framework which runs
growl on your behalf looking at it again
to make sure it's clear the conventional
way of using the JVM is a guest language
like Ruby or Python and mixed bytecode
and that goes into the JVM the because
we've bought growled this JIT compiler
outside the JVM made it just a normal
Java library that means you can talk to
it be using the compilers internal data
structures you can control what
atomization passes are run you can
examine the machine because you get out
of it but that's complicated so truffle
sits to that middle and all you have to
do is give truffle a language
interpreter
and it does everything else on your
behalf so it's talking about the very
basics of a truffle and grant what makes
it so easy to make this high-performance
language implementations that work so
well together so if you if you have an
expression in a programming language
such as X plus y times Z we can express
that as a tree data structure we call
each of these nodes and each node either
is some source of data or it does
something so in this case we've got the
sources are the X Y and the dead local
variables let's say the
our and the operations perform something
what we've done is we've taken the the
grammar and the syntax and made that
explicit in the tree so the fact that
you do the y x there before you do the
plus is sort of become explicit here and
then to execute that all we have to do
is to walk that tree and say right I'll
execute why I'll execute
Z then I'll execute the multiply then
the X and the add the JVM bytecode comes
into that in that you could take that
tree and you can convert it to JVM
bytecode that looks something like this
I'm it's a made-up bytecode format this
specific matter but we load X load Y
then we multiply it then we add and then
the JIT compiler does that that next
transformation for you and takes that
bytecode and turned it into high
performance machine code that's very
complicated looks like this the idea was
that the JVM did that step for you so
the JVM includes a JIT compiler and it
can go from that bytecode no matter how
you generated that for your particular
language into machine code and then we
can think about its being grove vm and
the garage it gives you the next step in
the truffle allows you just take your
AST interpreter this tree deck structure
in terms of your language and then also
does a wave with the step of generating
bytecode so it's a whole a whole process
easier way to develop a language and
this means that people have good ideas
for languages people have niche
languages can do that one simple step
and then they can get all this
high-performance stuff coming for free
and it's more so than what we can do on
the JVM currently because we've also
taken away that that step of generating
the bytecode we think how can an air T
interrupts I said that it was the
simplest way to implement a language but
we're saying our own predation these
languages are really fast so so how is
that working we've developed a technique
called ast self specialization this is a
new way of implementing programming
language that we've developed in our
group if we have that tree of nodes that
represent your program we have a
thinking where we start them all where
they all have a state we start them off
in an uninitialized state and what we do
is we have a lattice of different
different ways each node and work this
is particularly two different dynamic
languages we have a language like
JavaScript there's a
a string type double type there's an
integer type these are invisible to the
programmer but they're they're still
JavaScript some of the data will
represent numbers as live or an integer
or a double even though they all appear
to be doubles and they're caused to be a
canary type which says I'll handle
anything and the idea is these nodes are
replaced with the specialized version
for what they need to do and then over
time your program become specialized to
handle particular types of data and can
speed up so if you have a JavaScript
program which can handle any type of
objects when you do a B that I do is
that a could be any particular object we
specialize it over time to suit the the
program as it's running and then we use
a technique called partial evaluation to
take the this interpreter written using
this technique and produce a piece of
optimized machine code from it partial
evaluation is a complicated term but the
idea is we simply take all the Java code
that goes into interpreting this tree we
inline the entire thing together we
optimize it all together we get out a
single meta at the end which we compiled
to machine code partial evaluation is a
fascinating research topic if you want
to know how it works
I'm always recommend this talk by Tom
codon compiles for free if you google
that you'll find it he talks about this
in theory and we're doing it in reality
the great thing about truffle is that it
always allows you to reverse
optimizations you've applied you can go
from this compiled optimize machine code
we can go back to the ast interpreter
the simple representation and keep
executing with that and the reason we do
this is because it allows us to be
really aggressive and probably optimize
so a language like JavaScript language
like Ruby anything happen can happen at
any time so you could be in the middle
of a ruby method and someone could
decide to redefine the add operator on
another thread and that's something you
need to support so how do you reduce
efficient machine code when that could
happen what we do is we assume them will
ever redefine add and if they do
redefine that then we stop everything
and we go from the machine code back to
this AST interpreter start
carry on executing there and then in the
future after we've changed the types of
someone studied through a double in
where we only added inches before we can
recompile in that
other optimized representation let's go
back to probably got for a second we
said that the programs represented as
these tree day structures and each one
of these circles is there for a method
with its own little tree in and they all
call each other so a call this method
calls this method and that calls this
method and these trees all call each
other and execute values one of the
fundamental optimizations we can do is
we can in line for one method to another
so if you're making a call from this
method to this method and that call is
executed a lot then what we can do is
we'll say we'll create a separate copy
of that method and we'll connect it
directly up in the tree and the the
advantage of having this single way of
representing languages so every language
represents their their programs as trees
is we can actually do the same thing
across languages as well
so before all these rathod's methods
were Ruby methods let's say now one of
them is executed in JavaScript which is
the case we had in lead the example I
was showing you we now have one method
executed in JavaScript and we calling it
frequently from Ruby what we can now
actually do is in line from the Ruby to
the JavaScript because of they're both
just trees and in fact to the
implementation system to truffle and
growl it can forget about where they
came from
it can forget that one was a tree that
came from Ruby and one was a tree that
came from Ruby from JavaScript and it
can simply optimize them together so the
the poly box boundary the poly got cost
goes away because of the implementation
system doesn't care where your your
program representations come from all it
cares about is that it can handle them
the same way we're going to do now is
show you a deliberately extreme example
of this to show you how far it can go
I'm going to show you some machine code
but you don't have to understand what it
does I'll point out the the really
significant parts of it so let's define
a benchmark here where we've got a
subroutine so it simply takes a value
scalar value and it counts up from that
to that value from zero from zero to
that value incrementing I each time and
then returns
the value of them added up and I've got
an array of values this is one to one
hundred and then I loop and reach value
I calculate the sum of that and I've got
a version hit that does the same thing
but I've replaced this sum routine now
with JavaScript so I've got the same
loop doing the same thing because if
you're doing in JavaScript instead on
right hand side so I want to look at
this particular loop here when we
compile it this while loop is going from
I which starts at 0 up to n which is the
value passed in and each time it adds on
one to the counter and adds on n again
to the the accumulator returns it so
just as it's loop in here what I've done
is I've compiled back to machine code by
using the JIT compiler by using growl
and this is the machine code we get out
of them so this machine code it uses
registers it does adding it does some
jumping if it's got the end of the loop
increment something which is increment
there and it jumps around to the top but
that little tight little piece of
machine code is sort of thing you might
get a really good C compiler now I've
shown you the machine code for both the
version written in Ruby and version
written in JavaScript it's interesting
that they are exactly the same so some
may use JavaScript in the past because
it's slightly more performant language
than Ruby here we're showing that the
two programs written in Ruby and in
JavaScript actually produced the same
performance actually to the level that
produces the same machine code let's go
a step further and say now we'll have a
loop here which is our some loop and
instead of using an add operator to add
end the accumulator each time we'll pull
that out into a separate function and I
have just that function written in
either Ruby or JavaScript and again
we're looking at this wild loop here so
we're looking at the same loop but now
that while loop itself that now contains
a mixture of the two languages so before
it was just the one language we look at
the difference between them now the
outer one is always Ruby and then the
add operator is done in either Ruby or
JavaScript and then we can compile them
we can compile both those two loops and
I'll zoom in this time
so what we have here is a loop so it
adds together adds the next value and it
jumps if it's larger than that we
increment and then we compare to where
we're going in the loop and then if we
still need to go further we jump back
around the top but when we had that
example that mix the Ruby and the
JavaScript together these two machine
instructions actually come from
JavaScript and the rest come from Ruby
so we've done so well it's allowing
these languages to integrate and
forgetting where they came from
but when it goes all the way through the
optimizer all the way through the
compiler we're now so good at
authorizing them together in that the
you can't tell the difference between
writing a single language program and
writing a language program is using
multiple languages so what is this for
as I said this is a research project in
the moment maybe I'll move to something
more in the future but I'm not really
suggesting people should routinely
writes alternate methods in different
languages and their programs we've made
it easy by doing this trick where we
allow you to write JavaScript next to
Ruby I wouldn't any saying when should
go out and write their program like that
it's more about removing the
consideration of performance from the
decision about whether you want to
combine language not so if you think in
the future that actually we've already
got a function which format this
reporter's we'd like in Ruby but we're
here in the in this node.js application
now we need that same functionality I
will have to rewrite it in in JavaScript
or we may have to write a micro service
and then do a request across the network
to call a Ruby instance actually this
allows you to put them in the same
language and the copying paste that code
across and not pay the performance cost
of it and this could make all library
systems available languages so if you
have if you look at the libraries the
huge rich libraries exist in the
comprehensive our archive network or the
ask school libraries everything in the
NPN archive anything in the Ruby gems
archive we can make all those libraries
available to all applications about APIs
by using polygon approach we could make
things easy to unify the front end and
the back end so if you have code that
you'd be using in the front end and
actually
like to move that to the back end to do
something this could make it easy to do
that it may be used for their handling
legacy applications where you'd be using
one language for a long time we'd like
to switch another language or a
particular reason it can delay start
making Krenzel changes to your language
and incremental improvements to which
language you're using so what the
practicality is what our Grove VMI said
it's a research project you may think it
just exists as papers of academic
conferences but you can get the girl at
the end today girl VM is the package
which includes everything you need to
get started so includes a JVM that we've
slightly modified and I'll talk about
modification in a second over the
runtime engine or development kit
version includes support for Java and
JavaScript and Ruby and R and they'll be
more languages supported in the future
there are some languages supported as
separate projects zombies invitation and
Python
that's what you get inside what we're
distributing you can get this is a
binary tar ball release or you can build
it yourself it's all open source
apart from JavaScript in that example
and this works on Mac and Linux so you
get this one box which includes
everything another option is an Java 9
this technology be really compatible
with the standard unmodified JVM so what
we have is we have a stack where we have
hotspot on the bottom which you get
under standard JVM that's written in C++
that's a black box I talked about let me
have our growl JIT compiler and the
truffle framework and our languages
which all implemented in Java up here
what we've done is we've implemented a
an interface between the hotspot part
and the Java part that is called JVM CI
the JVM compiler interface and just that
little part touches the C++ code and
modifies it and does what we need and
that that hook is now part of Java 9
it's called jet 243 the JVM compiler
interface and that's been merged into
Java 9 has been for a while this means
that you can you can come along with
growl and truffle and the languages
which perhaps you get by the Oracle
technology Network or perhaps in the
future may get those something like
maven you can simply plug these into the
standard JVM so if you wrote need a
modified JVM
the Grove VM to do this it's almost like
the the Java agent system if you've used
that you can plug in a Java agent and
one or two admins to your bytecode grah
plugs in a bit like that but as a agent
that is a new JIT compiler so it
takeaways from this oracle abs is
building grow vm to support poli
programs and programmers originally we
were looking at just the the raw
performance of these languages and
that's something we definitely achieved
i showed how much faster are just ruby
just running ruby was but because there
were these implementations that work
together in a similar format we looked
at supporting polyglot programs and
polyglot programmers we have extremely
high performance for these languages on
their own so i'm translation of Ruby
despite being written originally by one
intern for a few months is the fastest
implementation of Ruby there is by about
an order of magnitude and our
implementation of JavaScript is
compatible it is about comparable with
the implantation of v8 on implantation
of our is extremely fast as well but
what is completely unprecedented is the
the high performance for the language
interoperability we've got to the point
where you can rewrite a particular loop
function in the inner loop of your
program in a different language and
there to be as I show literally no cost
to doing that the instruction stably
swap in from a different language to all
compiles together and this though it's
research this will work on our own
modified Java 9 JVM so if you download
the early access builds today you can
use growl with that and start to use
this technology not in production that
using production or you can get it as a
bottle which includes everything in one
convenient package we're still have that
research stage but moving being towards
some which may be more than that in the
future where to find more information
the Oracle technology Network the ATN
has download the binary for our VM if
you just search on any search engine for
growl OTN you'll find it because the
real URL is a little bit long so just
growl ltn and you'll find it the source
code for growl and for the our
implementation and for the ruby
implementation and truffle is on github
so again if you search forget how
growl the amuel finder or its github.com
for - growl VM and it's pretty
fascinating that we've got this compiler
written in Java now if you've never
looked at how the JIT compiler works if
you decided to go and look at how the
current JIT compiler written in C++
works
you'd be pretty intimidated and I have a
PhD in implementing these languages and
I'm pretty intimidating looking at it
but if you look at the invitation of
growl poke around in there you'll find
things that you can understand written
in a nice way in Java it's really
maintainable if you want to get in touch
with us I'm Kristy Seaton on Twitter and
as I say github calm grow VM
we're also on a guitar channel we can
come and talk to us directly and I say
search for OTN Grove VM you'll find it
the growled team Oracle lamps is is
quite large it's not just me working on
this this is some of us at a retreat
recently and these are some of the
people who we have working with us
working on all our different languages
we have got a lot of academic
collaborations as well so it's a big
team behind this working on a big
project that we hope will be something
really big for polygons and languages
working on the JVM in the future thanks
very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>